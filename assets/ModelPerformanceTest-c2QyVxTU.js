const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/browserAll-DcNQBVkE.js","assets/webworkerAll-BbyK6mNU.js","assets/colorToUniform-C2GHuDhf.js","assets/CanvasPool-BlBkKKLu.js","assets/index-ByGj7Z9W.js","assets/index-Dw7RN6Qg.css","assets/WebGPURenderer-BQ_LKRBC.js","assets/SharedSystems-B8l2-_Qv.js","assets/WebGLRenderer-BZ74uuMe.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { h as Qa, c as ktt, _ as Bf, d as gW, e as Ik, r as ue, s as Dtt, a as ke, w as Yr, i as vW, b as he, g as Zi, F as kg, f as mW, o as gd, j as d1, k as oe, T as Ett, n as Jo, u as J, t as Dv, l as Je, m as Rt, p as De, q as Mtt, v as yW, x as Rtt, y as hL, C as Ntt, z as Li, A as Ltt, B as xW, D as fe, E as Ptt, G as $p, H as bW, I as Dg, J as Ak, K as kk, L as $tt, M as Gc, N as Ott, O as Ftt, P as Btt, Q as ztt, R as Vtt, S as ta, U as Ur, V as Wt, W as vI, X as mI, Y as de, Z as fr, $ as fL, a0 as Gtt, __tla as __tla_0 } from "./index-ByGj7Z9W.js";
let zN, gQ, Di, Eh, as, rn, hs, Lw, fYt, EG, cd, FYt, YYt, Ve, Yn, yr, Xr, ZYt, rk, mqt, B0, tk, RG, GT, LG, gYt, jr, zJ, po, vQ, fn, An, nqt, Sqt, Gqt, Uqt, jqt, Zqt, Jqt, NN, ch, t7t, e7t, l1, hk, xf, jjt, EQ, KG, qG, LXt, c1, $Xt, NQ, gte, Sv, Nx, EN, Pa, jG, pqt, fQ, KJ, gs, hQ, Vqt, Wqt, yG, Yqt, Kqt, bQ, jXt, MN, on, oQ, PXt, Ki, tjt, Oo, OJ;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })()
]).then(async () => {
  function Wtt(n, t) {
    for (var e = 0; e < t.length; e++) {
      const r = t[e];
      if (typeof r != "string" && !Array.isArray(r)) {
        for (const i in r) if (i !== "default" && !(i in n)) {
          const a = Object.getOwnPropertyDescriptor(r, i);
          a && Object.defineProperty(n, i, a.get ? a : {
            enumerable: true,
            get: () => r[i]
          });
        }
      }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
      value: "Module"
    }));
  }
  var yI = function(n, t) {
    return yI = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(e, r) {
      e.__proto__ = r;
    } || function(e, r) {
      for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }, yI(n, t);
  };
  function q(n, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    yI(n, t);
    function e() {
      this.constructor = n;
    }
    n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
  }
  var Utt = /* @__PURE__ */ function() {
    function n() {
      this.firefox = false, this.ie = false, this.edge = false, this.newEdge = false, this.weChat = false;
    }
    return n;
  }(), Htt = /* @__PURE__ */ function() {
    function n() {
      this.browser = new Utt(), this.node = false, this.wxa = false, this.worker = false, this.svgSupported = false, this.touchEventsSupported = false, this.pointerEventsSupported = false, this.domSupported = false, this.transformSupported = false, this.transform3dSupported = false, this.hasGlobalWindow = typeof window < "u";
    }
    return n;
  }(), ce = new Htt();
  typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (ce.wxa = true, ce.touchEventsSupported = true) : typeof document > "u" && typeof self < "u" ? ce.worker = true : !ce.hasGlobalWindow || "Deno" in window ? (ce.node = true, ce.svgSupported = true) : Xtt(navigator.userAgent, ce);
  function Xtt(n, t) {
    var e = t.browser, r = n.match(/Firefox\/([\d.]+)/), i = n.match(/MSIE\s([\d.]+)/) || n.match(/Trident\/.+?rv:(([\d.]+))/), a = n.match(/Edge?\/([\d.]+)/), s = /micromessenger/i.test(n);
    r && (e.firefox = true, e.version = r[1]), i && (e.ie = true, e.version = i[1]), a && (e.edge = true, e.version = a[1], e.newEdge = +a[1].split(".")[0] > 18), s && (e.weChat = true), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !e.ie && !e.edge, t.pointerEventsSupported = "onpointerdown" in window && (e.edge || e.ie && +e.version >= 11), t.domSupported = typeof document < "u";
    var o = document.documentElement.style;
    t.transform3dSupported = (e.ie && "transition" in o || e.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in o) && !("OTransition" in o), t.transformSupported = t.transform3dSupported || e.ie && +e.version >= 9;
  }
  var Dk = 12, _W = "sans-serif", Hl = Dk + "px " + _W, Ytt = 20, qtt = 100, jtt = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
  function Ktt(n) {
    var t = {};
    if (typeof JSON > "u") return t;
    for (var e = 0; e < n.length; e++) {
      var r = String.fromCharCode(e + 32), i = (n.charCodeAt(e) - Ytt) / qtt;
      t[r] = i;
    }
    return t;
  }
  var Ztt = Ktt(jtt), Xl = {
    createCanvas: function() {
      return typeof document < "u" && document.createElement("canvas");
    },
    measureText: /* @__PURE__ */ function() {
      var n, t;
      return function(e, r) {
        if (!n) {
          var i = Xl.createCanvas();
          n = i && i.getContext("2d");
        }
        if (n) return t !== r && (t = n.font = r || Hl), n.measureText(e);
        e = e || "", r = r || Hl;
        var a = /((?:\d+)?\.?\d*)px/.exec(r), s = a && +a[1] || Dk, o = 0;
        if (r.indexOf("mono") >= 0) o = s * e.length;
        else for (var l = 0; l < e.length; l++) {
          var u = Ztt[e[l]];
          o += u == null ? s : u * s;
        }
        return {
          width: o
        };
      };
    }(),
    loadImage: function(n, t, e) {
      var r = new Image();
      return r.onload = t, r.onerror = e, r.src = n, r;
    }
  }, wW = Qs([
    "Function",
    "RegExp",
    "Date",
    "Error",
    "CanvasGradient",
    "CanvasPattern",
    "Image",
    "Canvas"
  ], function(n, t) {
    return n["[object " + t + "]"] = true, n;
  }, {}), SW = Qs([
    "Int8",
    "Uint8",
    "Uint8Clamped",
    "Int16",
    "Uint16",
    "Int32",
    "Uint32",
    "Float32",
    "Float64"
  ], function(n, t) {
    return n["[object " + t + "Array]"] = true, n;
  }, {}), vd = Object.prototype.toString, p1 = Array.prototype, Jtt = p1.forEach, Qtt = p1.filter, Ek = p1.slice, tet = p1.map, dL = (function() {
  }).constructor, xy = dL ? dL.prototype : null, Mk = "__proto__", eet = 2311;
  function CW() {
    return eet++;
  }
  function Rk() {
    for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
    typeof console < "u" && console.error.apply(console, n);
  }
  function Bt(n) {
    if (n == null || typeof n != "object") return n;
    var t = n, e = vd.call(n);
    if (e === "[object Array]") {
      if (!sg(n)) {
        t = [];
        for (var r = 0, i = n.length; r < i; r++) t[r] = Bt(n[r]);
      }
    } else if (SW[e]) {
      if (!sg(n)) {
        var a = n.constructor;
        if (a.from) t = a.from(n);
        else {
          t = new a(n.length);
          for (var r = 0, i = n.length; r < i; r++) t[r] = n[r];
        }
      }
    } else if (!wW[e] && !sg(n) && !zf(n)) {
      t = {};
      for (var s in n) n.hasOwnProperty(s) && s !== Mk && (t[s] = Bt(n[s]));
    }
    return t;
  }
  function Zt(n, t, e) {
    if (!Ft(t) || !Ft(n)) return e ? Bt(t) : n;
    for (var r in t) if (t.hasOwnProperty(r) && r !== Mk) {
      var i = n[r], a = t[r];
      Ft(a) && Ft(i) && !ct(a) && !ct(i) && !zf(a) && !zf(i) && !pL(a) && !pL(i) && !sg(a) && !sg(i) ? Zt(i, a, e) : (e || !(r in n)) && (n[r] = Bt(t[r]));
    }
    return n;
  }
  function Nk(n, t) {
    for (var e = n[0], r = 1, i = n.length; r < i; r++) e = Zt(e, n[r], t);
    return e;
  }
  function rt(n, t) {
    if (Object.assign) Object.assign(n, t);
    else for (var e in t) t.hasOwnProperty(e) && e !== Mk && (n[e] = t[e]);
    return n;
  }
  function $t(n, t, e) {
    for (var r = ge(t), i = 0, a = r.length; i < a; i++) {
      var s = r[i];
      (e ? t[s] != null : n[s] == null) && (n[s] = t[s]);
    }
    return n;
  }
  function ne(n, t) {
    if (n) {
      if (n.indexOf) return n.indexOf(t);
      for (var e = 0, r = n.length; e < r; e++) if (n[e] === t) return e;
    }
    return -1;
  }
  function net(n, t) {
    var e = n.prototype;
    function r() {
    }
    r.prototype = t.prototype, n.prototype = new r();
    for (var i in e) e.hasOwnProperty(i) && (n.prototype[i] = e[i]);
    n.prototype.constructor = n, n.superClass = t;
  }
  function zn(n, t, e) {
    if (n = "prototype" in n ? n.prototype : n, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames) for (var r = Object.getOwnPropertyNames(t), i = 0; i < r.length; i++) {
      var a = r[i];
      a !== "constructor" && (e ? t[a] != null : n[a] == null) && (n[a] = t[a]);
    }
    else $t(n, t, e);
  }
  function Kr(n) {
    return !n || typeof n == "string" ? false : typeof n.length == "number";
  }
  function P(n, t, e) {
    if (n && t) if (n.forEach && n.forEach === Jtt) n.forEach(t, e);
    else if (n.length === +n.length) for (var r = 0, i = n.length; r < i; r++) t.call(e, n[r], r, n);
    else for (var a in n) n.hasOwnProperty(a) && t.call(e, n[a], a, n);
  }
  function ht(n, t, e) {
    if (!n) return [];
    if (!t) return Lk(n);
    if (n.map && n.map === tet) return n.map(t, e);
    for (var r = [], i = 0, a = n.length; i < a; i++) r.push(t.call(e, n[i], i, n));
    return r;
  }
  function Qs(n, t, e, r) {
    if (n && t) {
      for (var i = 0, a = n.length; i < a; i++) e = t.call(r, e, n[i], i, n);
      return e;
    }
  }
  function Le(n, t, e) {
    if (!n) return [];
    if (!t) return Lk(n);
    if (n.filter && n.filter === Qtt) return n.filter(t, e);
    for (var r = [], i = 0, a = n.length; i < a; i++) t.call(e, n[i], i, n) && r.push(n[i]);
    return r;
  }
  function ret(n, t, e) {
    if (n && t) {
      for (var r = 0, i = n.length; r < i; r++) if (t.call(e, n[r], r, n)) return n[r];
    }
  }
  function ge(n) {
    if (!n) return [];
    if (Object.keys) return Object.keys(n);
    var t = [];
    for (var e in n) n.hasOwnProperty(e) && t.push(e);
    return t;
  }
  function iet(n, t) {
    for (var e = [], r = 2; r < arguments.length; r++) e[r - 2] = arguments[r];
    return function() {
      return n.apply(t, e.concat(Ek.call(arguments)));
    };
  }
  var St = xy && Nt(xy.bind) ? xy.call.bind(xy.bind) : iet;
  function qt(n) {
    for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
    return function() {
      return n.apply(this, t.concat(Ek.call(arguments)));
    };
  }
  function ct(n) {
    return Array.isArray ? Array.isArray(n) : vd.call(n) === "[object Array]";
  }
  function Nt(n) {
    return typeof n == "function";
  }
  function wt(n) {
    return typeof n == "string";
  }
  function xI(n) {
    return vd.call(n) === "[object String]";
  }
  function _e(n) {
    return typeof n == "number";
  }
  function Ft(n) {
    var t = typeof n;
    return t === "function" || !!n && t === "object";
  }
  function pL(n) {
    return !!wW[vd.call(n)];
  }
  function Pi(n) {
    return !!SW[vd.call(n)];
  }
  function zf(n) {
    return typeof n == "object" && typeof n.nodeType == "number" && typeof n.ownerDocument == "object";
  }
  function g1(n) {
    return n.colorStops != null;
  }
  function aet(n) {
    return n.image != null;
  }
  function set(n) {
    return vd.call(n) === "[object RegExp]";
  }
  function Eg(n) {
    return n !== n;
  }
  function mr() {
    for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
    for (var e = 0, r = n.length; e < r; e++) if (n[e] != null) return n[e];
  }
  function Ht(n, t) {
    return n ?? t;
  }
  function Ws(n, t, e) {
    return n ?? t ?? e;
  }
  function Lk(n) {
    for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
    return Ek.apply(n, t);
  }
  function Pk(n) {
    if (typeof n == "number") return [
      n,
      n,
      n,
      n
    ];
    var t = n.length;
    return t === 2 ? [
      n[0],
      n[1],
      n[0],
      n[1]
    ] : t === 3 ? [
      n[0],
      n[1],
      n[2],
      n[1]
    ] : n;
  }
  function gi(n, t) {
    if (!n) throw new Error(t);
  }
  function ja(n) {
    return n == null ? null : typeof n.trim == "function" ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
  var TW = "__ec_primitive__";
  function $x(n) {
    n[TW] = true;
  }
  function sg(n) {
    return n[TW];
  }
  var oet = function() {
    function n() {
      this.data = {};
    }
    return n.prototype.delete = function(t) {
      var e = this.has(t);
      return e && delete this.data[t], e;
    }, n.prototype.has = function(t) {
      return this.data.hasOwnProperty(t);
    }, n.prototype.get = function(t) {
      return this.data[t];
    }, n.prototype.set = function(t, e) {
      return this.data[t] = e, this;
    }, n.prototype.keys = function() {
      return ge(this.data);
    }, n.prototype.forEach = function(t) {
      var e = this.data;
      for (var r in e) e.hasOwnProperty(r) && t(e[r], r);
    }, n;
  }(), IW = typeof Map == "function";
  function uet() {
    return IW ? /* @__PURE__ */ new Map() : new oet();
  }
  var cet = function() {
    function n(t) {
      var e = ct(t);
      this.data = uet();
      var r = this;
      t instanceof n ? t.each(i) : t && P(t, i);
      function i(a, s) {
        e ? r.set(a, s) : r.set(s, a);
      }
    }
    return n.prototype.hasKey = function(t) {
      return this.data.has(t);
    }, n.prototype.get = function(t) {
      return this.data.get(t);
    }, n.prototype.set = function(t, e) {
      return this.data.set(t, e), e;
    }, n.prototype.each = function(t, e) {
      this.data.forEach(function(r, i) {
        t.call(e, r, i);
      });
    }, n.prototype.keys = function() {
      var t = this.data.keys();
      return IW ? Array.from(t) : t;
    }, n.prototype.removeKey = function(t) {
      this.data.delete(t);
    }, n;
  }();
  function It(n) {
    return new cet(n);
  }
  function Mg(n, t) {
    for (var e = new n.constructor(n.length + t.length), r = 0; r < n.length; r++) e[r] = n[r];
    for (var i = n.length, r = 0; r < t.length; r++) e[r + i] = t[r];
    return e;
  }
  function v1(n, t) {
    var e;
    if (Object.create) e = Object.create(n);
    else {
      var r = function() {
      };
      r.prototype = n, e = new r();
    }
    return t && rt(e, t), e;
  }
  function AW(n) {
    var t = n.style;
    t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
  }
  function Ct(n, t) {
    return n.hasOwnProperty(t);
  }
  function Dn() {
  }
  var tx = 180 / Math.PI;
  function hh(n, t) {
    return n == null && (n = 0), t == null && (t = 0), [
      n,
      t
    ];
  }
  function ri(n, t) {
    return n[0] = t[0], n[1] = t[1], n;
  }
  function Mo(n) {
    return [
      n[0],
      n[1]
    ];
  }
  function het(n, t, e) {
    return n[0] = t, n[1] = e, n;
  }
  function gL(n, t, e) {
    return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n;
  }
  function bI(n, t, e, r) {
    return n[0] = t[0] + e[0] * r, n[1] = t[1] + e[1] * r, n;
  }
  function vc(n, t, e) {
    return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n;
  }
  function _I(n) {
    return Math.sqrt(fet(n));
  }
  function fet(n) {
    return n[0] * n[0] + n[1] * n[1];
  }
  function ex(n, t, e) {
    return n[0] = t[0] * e, n[1] = t[1] * e, n;
  }
  function md(n, t) {
    var e = _I(t);
    return e === 0 ? (n[0] = 0, n[1] = 0) : (n[0] = t[0] / e, n[1] = t[1] / e), n;
  }
  function wI(n, t) {
    return Math.sqrt((n[0] - t[0]) * (n[0] - t[0]) + (n[1] - t[1]) * (n[1] - t[1]));
  }
  var Sl = wI;
  function det(n, t) {
    return (n[0] - t[0]) * (n[0] - t[0]) + (n[1] - t[1]) * (n[1] - t[1]);
  }
  var Dc = det;
  function nx(n, t, e, r) {
    return n[0] = t[0] + r * (e[0] - t[0]), n[1] = t[1] + r * (e[1] - t[1]), n;
  }
  function Tr(n, t, e) {
    var r = t[0], i = t[1];
    return n[0] = e[0] * r + e[2] * i + e[4], n[1] = e[1] * r + e[3] * i + e[5], n;
  }
  function Cl(n, t, e) {
    return n[0] = Math.min(t[0], e[0]), n[1] = Math.min(t[1], e[1]), n;
  }
  function Tl(n, t, e) {
    return n[0] = Math.max(t[0], e[0]), n[1] = Math.max(t[1], e[1]), n;
  }
  var Rh = /* @__PURE__ */ function() {
    function n(t, e) {
      this.target = t, this.topTarget = e && e.topTarget;
    }
    return n;
  }(), pet = function() {
    function n(t) {
      this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
    }
    return n.prototype._dragStart = function(t) {
      for (var e = t.target; e && !e.draggable; ) e = e.parent || e.__hostTarget;
      e && (this._draggingTarget = e, e.dragging = true, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new Rh(e, t), "dragstart", t.event));
    }, n.prototype._drag = function(t) {
      var e = this._draggingTarget;
      if (e) {
        var r = t.offsetX, i = t.offsetY, a = r - this._x, s = i - this._y;
        this._x = r, this._y = i, e.drift(a, s, t), this.handler.dispatchToElement(new Rh(e, t), "drag", t.event);
        var o = this.handler.findHover(r, i, e).target, l = this._dropTarget;
        this._dropTarget = o, e !== o && (l && o !== l && this.handler.dispatchToElement(new Rh(l, t), "dragleave", t.event), o && o !== l && this.handler.dispatchToElement(new Rh(o, t), "dragenter", t.event));
      }
    }, n.prototype._dragEnd = function(t) {
      var e = this._draggingTarget;
      e && (e.dragging = false), this.handler.dispatchToElement(new Rh(e, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new Rh(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
    }, n;
  }(), Da = function() {
    function n(t) {
      t && (this._$eventProcessor = t);
    }
    return n.prototype.on = function(t, e, r, i) {
      this._$handlers || (this._$handlers = {});
      var a = this._$handlers;
      if (typeof e == "function" && (i = r, r = e, e = null), !r || !t) return this;
      var s = this._$eventProcessor;
      e != null && s && s.normalizeQuery && (e = s.normalizeQuery(e)), a[t] || (a[t] = []);
      for (var o = 0; o < a[t].length; o++) if (a[t][o].h === r) return this;
      var l = {
        h: r,
        query: e,
        ctx: i || this,
        callAtLast: r.zrEventfulCallAtLast
      }, u = a[t].length - 1, c = a[t][u];
      return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
    }, n.prototype.isSilent = function(t) {
      var e = this._$handlers;
      return !e || !e[t] || !e[t].length;
    }, n.prototype.off = function(t, e) {
      var r = this._$handlers;
      if (!r) return this;
      if (!t) return this._$handlers = {}, this;
      if (e) {
        if (r[t]) {
          for (var i = [], a = 0, s = r[t].length; a < s; a++) r[t][a].h !== e && i.push(r[t][a]);
          r[t] = i;
        }
        r[t] && r[t].length === 0 && delete r[t];
      } else delete r[t];
      return this;
    }, n.prototype.trigger = function(t) {
      for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
      if (!this._$handlers) return this;
      var i = this._$handlers[t], a = this._$eventProcessor;
      if (i) for (var s = e.length, o = i.length, l = 0; l < o; l++) {
        var u = i[l];
        if (!(a && a.filter && u.query != null && !a.filter(t, u.query))) switch (s) {
          case 0:
            u.h.call(u.ctx);
            break;
          case 1:
            u.h.call(u.ctx, e[0]);
            break;
          case 2:
            u.h.call(u.ctx, e[0], e[1]);
            break;
          default:
            u.h.apply(u.ctx, e);
            break;
        }
      }
      return a && a.afterTrigger && a.afterTrigger(t), this;
    }, n.prototype.triggerWithContext = function(t) {
      for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
      if (!this._$handlers) return this;
      var i = this._$handlers[t], a = this._$eventProcessor;
      if (i) for (var s = e.length, o = e[s - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(a && a.filter && c.query != null && !a.filter(t, c.query))) switch (s) {
          case 0:
            c.h.call(o);
            break;
          case 1:
            c.h.call(o, e[0]);
            break;
          case 2:
            c.h.call(o, e[0], e[1]);
            break;
          default:
            c.h.apply(o, e.slice(1, s - 1));
            break;
        }
      }
      return a && a.afterTrigger && a.afterTrigger(t), this;
    }, n;
  }(), get = Math.log(2);
  function SI(n, t, e, r, i, a) {
    var s = r + "-" + i, o = n.length;
    if (a.hasOwnProperty(s)) return a[s];
    if (t === 1) {
      var l = Math.round(Math.log((1 << o) - 1 & ~i) / get);
      return n[e][l];
    }
    for (var u = r | 1 << e, c = e + 1; r & 1 << c; ) c++;
    for (var h = 0, f = 0, d = 0; f < o; f++) {
      var p = 1 << f;
      p & i || (h += (d % 2 ? -1 : 1) * n[e][f] * SI(n, t - 1, c, u, i | p, a), d++);
    }
    return a[s] = h, h;
  }
  function vL(n, t) {
    var e = [
      [
        n[0],
        n[1],
        1,
        0,
        0,
        0,
        -t[0] * n[0],
        -t[0] * n[1]
      ],
      [
        0,
        0,
        0,
        n[0],
        n[1],
        1,
        -t[1] * n[0],
        -t[1] * n[1]
      ],
      [
        n[2],
        n[3],
        1,
        0,
        0,
        0,
        -t[2] * n[2],
        -t[2] * n[3]
      ],
      [
        0,
        0,
        0,
        n[2],
        n[3],
        1,
        -t[3] * n[2],
        -t[3] * n[3]
      ],
      [
        n[4],
        n[5],
        1,
        0,
        0,
        0,
        -t[4] * n[4],
        -t[4] * n[5]
      ],
      [
        0,
        0,
        0,
        n[4],
        n[5],
        1,
        -t[5] * n[4],
        -t[5] * n[5]
      ],
      [
        n[6],
        n[7],
        1,
        0,
        0,
        0,
        -t[6] * n[6],
        -t[6] * n[7]
      ],
      [
        0,
        0,
        0,
        n[6],
        n[7],
        1,
        -t[7] * n[6],
        -t[7] * n[7]
      ]
    ], r = {}, i = SI(e, 8, 0, 0, 0, r);
    if (i !== 0) {
      for (var a = [], s = 0; s < 8; s++) for (var o = 0; o < 8; o++) a[o] == null && (a[o] = 0), a[o] += ((s + o) % 2 ? -1 : 1) * SI(e, 7, s === 0 ? 1 : 0, 1 << s, 1 << o, r) / i * t[s];
      return function(l, u, c) {
        var h = u * a[6] + c * a[7] + 1;
        l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
      };
    }
  }
  var mL = "___zrEVENTSAVED", zw = [];
  function vet(n, t, e, r, i) {
    return CI(zw, t, r, i, true) && CI(n, e, zw[0], zw[1]);
  }
  function CI(n, t, e, r, i) {
    if (t.getBoundingClientRect && ce.domSupported && !kW(t)) {
      var a = t[mL] || (t[mL] = {}), s = met(t, a), o = yet(s, a, i);
      if (o) return o(n, e, r), true;
    }
    return false;
  }
  function met(n, t) {
    var e = t.markers;
    if (e) return e;
    e = t.markers = [];
    for (var r = [
      "left",
      "right"
    ], i = [
      "top",
      "bottom"
    ], a = 0; a < 4; a++) {
      var s = document.createElement("div"), o = s.style, l = a % 2, u = (a >> 1) % 2;
      o.cssText = [
        "position: absolute",
        "visibility: hidden",
        "padding: 0",
        "margin: 0",
        "border-width: 0",
        "user-select: none",
        "width:0",
        "height:0",
        r[l] + ":0",
        i[u] + ":0",
        r[1 - l] + ":auto",
        i[1 - u] + ":auto",
        ""
      ].join("!important;"), n.appendChild(s), e.push(s);
    }
    return e;
  }
  function yet(n, t, e) {
    for (var r = e ? "invTrans" : "trans", i = t[r], a = t.srcCoords, s = [], o = [], l = true, u = 0; u < 4; u++) {
      var c = n[u].getBoundingClientRect(), h = 2 * u, f = c.left, d = c.top;
      s.push(f, d), l = l && a && f === a[h] && d === a[h + 1], o.push(n[u].offsetLeft, n[u].offsetTop);
    }
    return l && i ? i : (t.srcCoords = s, t[r] = e ? vL(o, s) : vL(s, o));
  }
  function kW(n) {
    return n.nodeName.toUpperCase() === "CANVAS";
  }
  var xet = /([&<>"'])/g, bet = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function oi(n) {
    return n == null ? "" : (n + "").replace(xet, function(t, e) {
      return bet[e];
    });
  }
  var _et = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Vw = [], wet = ce.browser.firefox && +ce.browser.version.split(".")[0] < 39;
  function TI(n, t, e, r) {
    return e = e || {}, r ? yL(n, t, e) : wet && t.layerX != null && t.layerX !== t.offsetX ? (e.zrX = t.layerX, e.zrY = t.layerY) : t.offsetX != null ? (e.zrX = t.offsetX, e.zrY = t.offsetY) : yL(n, t, e), e;
  }
  function yL(n, t, e) {
    if (ce.domSupported && n.getBoundingClientRect) {
      var r = t.clientX, i = t.clientY;
      if (kW(n)) {
        var a = n.getBoundingClientRect();
        e.zrX = r - a.left, e.zrY = i - a.top;
        return;
      } else if (CI(Vw, n, r, i)) {
        e.zrX = Vw[0], e.zrY = Vw[1];
        return;
      }
    }
    e.zrX = e.zrY = 0;
  }
  function $k(n) {
    return n || window.event;
  }
  function ca(n, t, e) {
    if (t = $k(t), t.zrX != null) return t;
    var r = t.type, i = r && r.indexOf("touch") >= 0;
    if (i) {
      var s = r !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
      s && TI(n, s, t, e);
    } else {
      TI(n, t, t, e);
      var a = Cet(t);
      t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
    }
    var o = t.button;
    return t.which == null && o !== void 0 && _et.test(t.type) && (t.which = o & 1 ? 1 : o & 2 ? 3 : o & 4 ? 2 : 0), t;
  }
  function Cet(n) {
    var t = n.wheelDelta;
    if (t) return t;
    var e = n.deltaX, r = n.deltaY;
    if (e == null || r == null) return t;
    var i = Math.abs(r !== 0 ? r : e), a = r > 0 ? -1 : r < 0 ? 1 : e > 0 ? -1 : 1;
    return 3 * i * a;
  }
  function II(n, t, e, r) {
    n.addEventListener(t, e, r);
  }
  function Tet(n, t, e, r) {
    n.removeEventListener(t, e, r);
  }
  var Bo = function(n) {
    n.preventDefault(), n.stopPropagation(), n.cancelBubble = true;
  };
  function xL(n) {
    return n.which === 2 || n.which === 3;
  }
  var Iet = function() {
    function n() {
      this._track = [];
    }
    return n.prototype.recognize = function(t, e, r) {
      return this._doTrack(t, e, r), this._recognize(t);
    }, n.prototype.clear = function() {
      return this._track.length = 0, this;
    }, n.prototype._doTrack = function(t, e, r) {
      var i = t.touches;
      if (i) {
        for (var a = {
          points: [],
          touches: [],
          target: e,
          event: t
        }, s = 0, o = i.length; s < o; s++) {
          var l = i[s], u = TI(r, l, {});
          a.points.push([
            u.zrX,
            u.zrY
          ]), a.touches.push(l);
        }
        this._track.push(a);
      }
    }, n.prototype._recognize = function(t) {
      for (var e in Gw) if (Gw.hasOwnProperty(e)) {
        var r = Gw[e](this._track, t);
        if (r) return r;
      }
    }, n;
  }();
  function bL(n) {
    var t = n[1][0] - n[0][0], e = n[1][1] - n[0][1];
    return Math.sqrt(t * t + e * e);
  }
  function Aet(n) {
    return [
      (n[0][0] + n[1][0]) / 2,
      (n[0][1] + n[1][1]) / 2
    ];
  }
  var Gw = {
    pinch: function(n, t) {
      var e = n.length;
      if (e) {
        var r = (n[e - 1] || {}).points, i = (n[e - 2] || {}).points || r;
        if (i && i.length > 1 && r && r.length > 1) {
          var a = bL(r) / bL(i);
          !isFinite(a) && (a = 1), t.pinchScale = a;
          var s = Aet(r);
          return t.pinchX = s[0], t.pinchY = s[1], {
            type: "pinch",
            target: n[0].target,
            event: t
          };
        }
      }
    }
  };
  function Xi() {
    return [
      1,
      0,
      0,
      1,
      0,
      0
    ];
  }
  function m1(n) {
    return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n;
  }
  function Ok(n, t) {
    return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
  }
  function Ro(n, t, e) {
    var r = t[0] * e[0] + t[2] * e[1], i = t[1] * e[0] + t[3] * e[1], a = t[0] * e[2] + t[2] * e[3], s = t[1] * e[2] + t[3] * e[3], o = t[0] * e[4] + t[2] * e[5] + t[4], l = t[1] * e[4] + t[3] * e[5] + t[5];
    return n[0] = r, n[1] = i, n[2] = a, n[3] = s, n[4] = o, n[5] = l, n;
  }
  function to(n, t, e) {
    return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4] + e[0], n[5] = t[5] + e[1], n;
  }
  function fh(n, t, e, r) {
    r === void 0 && (r = [
      0,
      0
    ]);
    var i = t[0], a = t[2], s = t[4], o = t[1], l = t[3], u = t[5], c = Math.sin(e), h = Math.cos(e);
    return n[0] = i * h + o * c, n[1] = -i * c + o * h, n[2] = a * h + l * c, n[3] = -a * c + h * l, n[4] = h * (s - r[0]) + c * (u - r[1]) + r[0], n[5] = h * (u - r[1]) - c * (s - r[0]) + r[1], n;
  }
  function Fk(n, t, e) {
    var r = e[0], i = e[1];
    return n[0] = t[0] * r, n[1] = t[1] * i, n[2] = t[2] * r, n[3] = t[3] * i, n[4] = t[4] * r, n[5] = t[5] * i, n;
  }
  function yd(n, t) {
    var e = t[0], r = t[2], i = t[4], a = t[1], s = t[3], o = t[5], l = e * s - a * r;
    return l ? (l = 1 / l, n[0] = s * l, n[1] = -a * l, n[2] = -r * l, n[3] = e * l, n[4] = (r * o - s * i) * l, n[5] = (a * i - e * o) * l, n) : null;
  }
  function ket(n) {
    var t = Xi();
    return Ok(t, n), t;
  }
  var Qt = function() {
    function n(t, e) {
      this.x = t || 0, this.y = e || 0;
    }
    return n.prototype.copy = function(t) {
      return this.x = t.x, this.y = t.y, this;
    }, n.prototype.clone = function() {
      return new n(this.x, this.y);
    }, n.prototype.set = function(t, e) {
      return this.x = t, this.y = e, this;
    }, n.prototype.equal = function(t) {
      return t.x === this.x && t.y === this.y;
    }, n.prototype.add = function(t) {
      return this.x += t.x, this.y += t.y, this;
    }, n.prototype.scale = function(t) {
      this.x *= t, this.y *= t;
    }, n.prototype.scaleAndAdd = function(t, e) {
      this.x += t.x * e, this.y += t.y * e;
    }, n.prototype.sub = function(t) {
      return this.x -= t.x, this.y -= t.y, this;
    }, n.prototype.dot = function(t) {
      return this.x * t.x + this.y * t.y;
    }, n.prototype.len = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }, n.prototype.lenSquare = function() {
      return this.x * this.x + this.y * this.y;
    }, n.prototype.normalize = function() {
      var t = this.len();
      return this.x /= t, this.y /= t, this;
    }, n.prototype.distance = function(t) {
      var e = this.x - t.x, r = this.y - t.y;
      return Math.sqrt(e * e + r * r);
    }, n.prototype.distanceSquare = function(t) {
      var e = this.x - t.x, r = this.y - t.y;
      return e * e + r * r;
    }, n.prototype.negate = function() {
      return this.x = -this.x, this.y = -this.y, this;
    }, n.prototype.transform = function(t) {
      if (t) {
        var e = this.x, r = this.y;
        return this.x = t[0] * e + t[2] * r + t[4], this.y = t[1] * e + t[3] * r + t[5], this;
      }
    }, n.prototype.toArray = function(t) {
      return t[0] = this.x, t[1] = this.y, t;
    }, n.prototype.fromArray = function(t) {
      this.x = t[0], this.y = t[1];
    }, n.set = function(t, e, r) {
      t.x = e, t.y = r;
    }, n.copy = function(t, e) {
      t.x = e.x, t.y = e.y;
    }, n.len = function(t) {
      return Math.sqrt(t.x * t.x + t.y * t.y);
    }, n.lenSquare = function(t) {
      return t.x * t.x + t.y * t.y;
    }, n.dot = function(t, e) {
      return t.x * e.x + t.y * e.y;
    }, n.add = function(t, e, r) {
      t.x = e.x + r.x, t.y = e.y + r.y;
    }, n.sub = function(t, e, r) {
      t.x = e.x - r.x, t.y = e.y - r.y;
    }, n.scale = function(t, e, r) {
      t.x = e.x * r, t.y = e.y * r;
    }, n.scaleAndAdd = function(t, e, r, i) {
      t.x = e.x + r.x * i, t.y = e.y + r.y * i;
    }, n.lerp = function(t, e, r, i) {
      var a = 1 - i;
      t.x = a * e.x + i * r.x, t.y = a * e.y + i * r.y;
    }, n;
  }(), by = Math.min, _y = Math.max, wu = new Qt(), Su = new Qt(), Cu = new Qt(), Tu = new Qt(), Jd = new Qt(), Qd = new Qt(), te = function() {
    function n(t, e, r, i) {
      r < 0 && (t = t + r, r = -r), i < 0 && (e = e + i, i = -i), this.x = t, this.y = e, this.width = r, this.height = i;
    }
    return n.prototype.union = function(t) {
      var e = by(t.x, this.x), r = by(t.y, this.y);
      isFinite(this.x) && isFinite(this.width) ? this.width = _y(t.x + t.width, this.x + this.width) - e : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = _y(t.y + t.height, this.y + this.height) - r : this.height = t.height, this.x = e, this.y = r;
    }, n.prototype.applyTransform = function(t) {
      n.applyTransform(this, this, t);
    }, n.prototype.calculateTransform = function(t) {
      var e = this, r = t.width / e.width, i = t.height / e.height, a = Xi();
      return to(a, a, [
        -e.x,
        -e.y
      ]), Fk(a, a, [
        r,
        i
      ]), to(a, a, [
        t.x,
        t.y
      ]), a;
    }, n.prototype.intersect = function(t, e) {
      if (!t) return false;
      t instanceof n || (t = n.create(t));
      var r = this, i = r.x, a = r.x + r.width, s = r.y, o = r.y + r.height, l = t.x, u = t.x + t.width, c = t.y, h = t.y + t.height, f = !(a < l || u < i || o < c || h < s);
      if (e) {
        var d = 1 / 0, p = 0, g = Math.abs(a - l), v = Math.abs(u - i), m = Math.abs(o - c), y = Math.abs(h - s), x = Math.min(g, v), b = Math.min(m, y);
        a < l || u < i ? x > p && (p = x, g < v ? Qt.set(Qd, -g, 0) : Qt.set(Qd, v, 0)) : x < d && (d = x, g < v ? Qt.set(Jd, g, 0) : Qt.set(Jd, -v, 0)), o < c || h < s ? b > p && (p = b, m < y ? Qt.set(Qd, 0, -m) : Qt.set(Qd, 0, y)) : x < d && (d = x, m < y ? Qt.set(Jd, 0, m) : Qt.set(Jd, 0, -y));
      }
      return e && Qt.copy(e, f ? Jd : Qd), f;
    }, n.prototype.contain = function(t, e) {
      var r = this;
      return t >= r.x && t <= r.x + r.width && e >= r.y && e <= r.y + r.height;
    }, n.prototype.clone = function() {
      return new n(this.x, this.y, this.width, this.height);
    }, n.prototype.copy = function(t) {
      n.copy(this, t);
    }, n.prototype.plain = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    }, n.prototype.isFinite = function() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    }, n.prototype.isZero = function() {
      return this.width === 0 || this.height === 0;
    }, n.create = function(t) {
      return new n(t.x, t.y, t.width, t.height);
    }, n.copy = function(t, e) {
      t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height;
    }, n.applyTransform = function(t, e, r) {
      if (!r) {
        t !== e && n.copy(t, e);
        return;
      }
      if (r[1] < 1e-5 && r[1] > -1e-5 && r[2] < 1e-5 && r[2] > -1e-5) {
        var i = r[0], a = r[3], s = r[4], o = r[5];
        t.x = e.x * i + s, t.y = e.y * a + o, t.width = e.width * i, t.height = e.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
        return;
      }
      wu.x = Cu.x = e.x, wu.y = Tu.y = e.y, Su.x = Tu.x = e.x + e.width, Su.y = Cu.y = e.y + e.height, wu.transform(r), Tu.transform(r), Su.transform(r), Cu.transform(r), t.x = by(wu.x, Su.x, Cu.x, Tu.x), t.y = by(wu.y, Su.y, Cu.y, Tu.y);
      var l = _y(wu.x, Su.x, Cu.x, Tu.x), u = _y(wu.y, Su.y, Cu.y, Tu.y);
      t.width = l - t.x, t.height = u - t.y;
    }, n;
  }(), DW = "silent";
  function Det(n, t, e) {
    return {
      type: n,
      event: e,
      target: t.target,
      topTarget: t.topTarget,
      cancelBubble: false,
      offsetX: e.zrX,
      offsetY: e.zrY,
      gestureEvent: e.gestureEvent,
      pinchX: e.pinchX,
      pinchY: e.pinchY,
      pinchScale: e.pinchScale,
      wheelDelta: e.zrDelta,
      zrByTouch: e.zrByTouch,
      which: e.which,
      stop: Eet
    };
  }
  function Eet() {
    Bo(this.event);
  }
  var Met = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.handler = null, e;
    }
    return t.prototype.dispose = function() {
    }, t.prototype.setCursor = function() {
    }, t;
  }(Da), tp = /* @__PURE__ */ function() {
    function n(t, e) {
      this.x = t, this.y = e;
    }
    return n;
  }(), Ret = [
    "click",
    "dblclick",
    "mousewheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], Ww = new te(0, 0, 0, 0), EW = function(n) {
    q(t, n);
    function t(e, r, i, a, s) {
      var o = n.call(this) || this;
      return o._hovered = new tp(0, 0), o.storage = e, o.painter = r, o.painterRoot = a, o._pointerSize = s, i = i || new Met(), o.proxy = null, o.setHandlerProxy(i), o._draggingMgr = new pet(o), o;
    }
    return t.prototype.setHandlerProxy = function(e) {
      this.proxy && this.proxy.dispose(), e && (P(Ret, function(r) {
        e.on && e.on(r, this[r], this);
      }, this), e.handler = this), this.proxy = e;
    }, t.prototype.mousemove = function(e) {
      var r = e.zrX, i = e.zrY, a = MW(this, r, i), s = this._hovered, o = s.target;
      o && !o.__zr && (s = this.findHover(s.x, s.y), o = s.target);
      var l = this._hovered = a ? new tp(r, i) : this.findHover(r, i), u = l.target, c = this.proxy;
      c.setCursor && c.setCursor(u ? u.cursor : "default"), o && u !== o && this.dispatchToElement(s, "mouseout", e), this.dispatchToElement(l, "mousemove", e), u && u !== o && this.dispatchToElement(l, "mouseover", e);
    }, t.prototype.mouseout = function(e) {
      var r = e.zrEventControl;
      r !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", e), r !== "no_globalout" && this.trigger("globalout", {
        type: "globalout",
        event: e
      });
    }, t.prototype.resize = function() {
      this._hovered = new tp(0, 0);
    }, t.prototype.dispatch = function(e, r) {
      var i = this[e];
      i && i.call(this, r);
    }, t.prototype.dispose = function() {
      this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
    }, t.prototype.setCursorStyle = function(e) {
      var r = this.proxy;
      r.setCursor && r.setCursor(e);
    }, t.prototype.dispatchToElement = function(e, r, i) {
      e = e || {};
      var a = e.target;
      if (!(a && a.silent)) {
        for (var s = "on" + r, o = Det(r, e, i); a && (a[s] && (o.cancelBubble = !!a[s].call(a, o)), a.trigger(r, o), a = a.__hostTarget ? a.__hostTarget : a.parent, !o.cancelBubble); ) ;
        o.cancelBubble || (this.trigger(r, o), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
          typeof l[s] == "function" && l[s].call(l, o), l.trigger && l.trigger(r, o);
        }));
      }
    }, t.prototype.findHover = function(e, r, i) {
      var a = this.storage.getDisplayList(), s = new tp(e, r);
      if (_L(a, s, e, r, i), this._pointerSize && !s.target) {
        for (var o = [], l = this._pointerSize, u = l / 2, c = new te(e - u, r - u, l, l), h = a.length - 1; h >= 0; h--) {
          var f = a[h];
          f !== i && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (Ww.copy(f.getBoundingRect()), f.transform && Ww.applyTransform(f.transform), Ww.intersect(c) && o.push(f));
        }
        if (o.length) for (var d = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0; v < u; v += d) for (var m = 0; m < g; m += p) {
          var y = e + v * Math.cos(m), x = r + v * Math.sin(m);
          if (_L(o, s, y, x, i), s.target) return s;
        }
      }
      return s;
    }, t.prototype.processGesture = function(e, r) {
      this._gestureMgr || (this._gestureMgr = new Iet());
      var i = this._gestureMgr;
      r === "start" && i.clear();
      var a = i.recognize(e, this.findHover(e.zrX, e.zrY, null).target, this.proxy.dom);
      if (r === "end" && i.clear(), a) {
        var s = a.type;
        e.gestureEvent = s;
        var o = new tp();
        o.target = a.target, this.dispatchToElement(o, s, a.event);
      }
    }, t;
  }(Da);
  P([
    "click",
    "mousedown",
    "mouseup",
    "mousewheel",
    "dblclick",
    "contextmenu"
  ], function(n) {
    EW.prototype[n] = function(t) {
      var e = t.zrX, r = t.zrY, i = MW(this, e, r), a, s;
      if ((n !== "mouseup" || !i) && (a = this.findHover(e, r), s = a.target), n === "mousedown") this._downEl = s, this._downPoint = [
        t.zrX,
        t.zrY
      ], this._upEl = s;
      else if (n === "mouseup") this._upEl = s;
      else if (n === "click") {
        if (this._downEl !== this._upEl || !this._downPoint || Sl(this._downPoint, [
          t.zrX,
          t.zrY
        ]) > 4) return;
        this._downPoint = null;
      }
      this.dispatchToElement(a, n, t);
    };
  });
  function Net(n, t, e) {
    if (n[n.rectHover ? "rectContain" : "contain"](t, e)) {
      for (var r = n, i = void 0, a = false; r; ) {
        if (r.ignoreClip && (a = true), !a) {
          var s = r.getClipPath();
          if (s && !s.contain(t, e)) return false;
        }
        r.silent && (i = true);
        var o = r.__hostTarget;
        r = o || r.parent;
      }
      return i ? DW : true;
    }
    return false;
  }
  function _L(n, t, e, r, i) {
    for (var a = n.length - 1; a >= 0; a--) {
      var s = n[a], o = void 0;
      if (s !== i && !s.ignore && (o = Net(s, e, r)) && (!t.topTarget && (t.topTarget = s), o !== DW)) {
        t.target = s;
        break;
      }
    }
  }
  function MW(n, t, e) {
    var r = n.painter;
    return t < 0 || t > r.getWidth() || e < 0 || e > r.getHeight();
  }
  var RW = 32, ep = 7;
  function Let(n) {
    for (var t = 0; n >= RW; ) t |= n & 1, n >>= 1;
    return n + t;
  }
  function wL(n, t, e, r) {
    var i = t + 1;
    if (i === e) return 1;
    if (r(n[i++], n[t]) < 0) {
      for (; i < e && r(n[i], n[i - 1]) < 0; ) i++;
      Pet(n, t, i);
    } else for (; i < e && r(n[i], n[i - 1]) >= 0; ) i++;
    return i - t;
  }
  function Pet(n, t, e) {
    for (e--; t < e; ) {
      var r = n[t];
      n[t++] = n[e], n[e--] = r;
    }
  }
  function SL(n, t, e, r, i) {
    for (r === t && r++; r < e; r++) {
      for (var a = n[r], s = t, o = r, l; s < o; ) l = s + o >>> 1, i(a, n[l]) < 0 ? o = l : s = l + 1;
      var u = r - s;
      switch (u) {
        case 3:
          n[s + 3] = n[s + 2];
        case 2:
          n[s + 2] = n[s + 1];
        case 1:
          n[s + 1] = n[s];
          break;
        default:
          for (; u > 0; ) n[s + u] = n[s + u - 1], u--;
      }
      n[s] = a;
    }
  }
  function Uw(n, t, e, r, i, a) {
    var s = 0, o = 0, l = 1;
    if (a(n, t[e + i]) > 0) {
      for (o = r - i; l < o && a(n, t[e + i + l]) > 0; ) s = l, l = (l << 1) + 1, l <= 0 && (l = o);
      l > o && (l = o), s += i, l += i;
    } else {
      for (o = i + 1; l < o && a(n, t[e + i - l]) <= 0; ) s = l, l = (l << 1) + 1, l <= 0 && (l = o);
      l > o && (l = o);
      var u = s;
      s = i - l, l = i - u;
    }
    for (s++; s < l; ) {
      var c = s + (l - s >>> 1);
      a(n, t[e + c]) > 0 ? s = c + 1 : l = c;
    }
    return l;
  }
  function Hw(n, t, e, r, i, a) {
    var s = 0, o = 0, l = 1;
    if (a(n, t[e + i]) < 0) {
      for (o = i + 1; l < o && a(n, t[e + i - l]) < 0; ) s = l, l = (l << 1) + 1, l <= 0 && (l = o);
      l > o && (l = o);
      var u = s;
      s = i - l, l = i - u;
    } else {
      for (o = r - i; l < o && a(n, t[e + i + l]) >= 0; ) s = l, l = (l << 1) + 1, l <= 0 && (l = o);
      l > o && (l = o), s += i, l += i;
    }
    for (s++; s < l; ) {
      var c = s + (l - s >>> 1);
      a(n, t[e + c]) < 0 ? l = c : s = c + 1;
    }
    return l;
  }
  function $et(n, t) {
    var e = ep, r, i, a = 0, s = [];
    r = [], i = [];
    function o(d, p) {
      r[a] = d, i[a] = p, a += 1;
    }
    function l() {
      for (; a > 1; ) {
        var d = a - 2;
        if (d >= 1 && i[d - 1] <= i[d] + i[d + 1] || d >= 2 && i[d - 2] <= i[d] + i[d - 1]) i[d - 1] < i[d + 1] && d--;
        else if (i[d] > i[d + 1]) break;
        c(d);
      }
    }
    function u() {
      for (; a > 1; ) {
        var d = a - 2;
        d > 0 && i[d - 1] < i[d + 1] && d--, c(d);
      }
    }
    function c(d) {
      var p = r[d], g = i[d], v = r[d + 1], m = i[d + 1];
      i[d] = g + m, d === a - 3 && (r[d + 1] = r[d + 2], i[d + 1] = i[d + 2]), a--;
      var y = Hw(n[v], n, p, g, 0, t);
      p += y, g -= y, g !== 0 && (m = Uw(n[p + g - 1], n, v, m, m - 1, t), m !== 0 && (g <= m ? h(p, g, v, m) : f(p, g, v, m)));
    }
    function h(d, p, g, v) {
      var m = 0;
      for (m = 0; m < p; m++) s[m] = n[d + m];
      var y = 0, x = g, b = d;
      if (n[b++] = n[x++], --v === 0) {
        for (m = 0; m < p; m++) n[b + m] = s[y + m];
        return;
      }
      if (p === 1) {
        for (m = 0; m < v; m++) n[b + m] = n[x + m];
        n[b + v] = s[y];
        return;
      }
      for (var _ = e, w, S, I; ; ) {
        w = 0, S = 0, I = false;
        do
          if (t(n[x], s[y]) < 0) {
            if (n[b++] = n[x++], S++, w = 0, --v === 0) {
              I = true;
              break;
            }
          } else if (n[b++] = s[y++], w++, S = 0, --p === 1) {
            I = true;
            break;
          }
        while ((w | S) < _);
        if (I) break;
        do {
          if (w = Hw(n[x], s, y, p, 0, t), w !== 0) {
            for (m = 0; m < w; m++) n[b + m] = s[y + m];
            if (b += w, y += w, p -= w, p <= 1) {
              I = true;
              break;
            }
          }
          if (n[b++] = n[x++], --v === 0) {
            I = true;
            break;
          }
          if (S = Uw(s[y], n, x, v, 0, t), S !== 0) {
            for (m = 0; m < S; m++) n[b + m] = n[x + m];
            if (b += S, x += S, v -= S, v === 0) {
              I = true;
              break;
            }
          }
          if (n[b++] = s[y++], --p === 1) {
            I = true;
            break;
          }
          _--;
        } while (w >= ep || S >= ep);
        if (I) break;
        _ < 0 && (_ = 0), _ += 2;
      }
      if (e = _, e < 1 && (e = 1), p === 1) {
        for (m = 0; m < v; m++) n[b + m] = n[x + m];
        n[b + v] = s[y];
      } else {
        if (p === 0) throw new Error();
        for (m = 0; m < p; m++) n[b + m] = s[y + m];
      }
    }
    function f(d, p, g, v) {
      var m = 0;
      for (m = 0; m < v; m++) s[m] = n[g + m];
      var y = d + p - 1, x = v - 1, b = g + v - 1, _ = 0, w = 0;
      if (n[b--] = n[y--], --p === 0) {
        for (_ = b - (v - 1), m = 0; m < v; m++) n[_ + m] = s[m];
        return;
      }
      if (v === 1) {
        for (b -= p, y -= p, w = b + 1, _ = y + 1, m = p - 1; m >= 0; m--) n[w + m] = n[_ + m];
        n[b] = s[x];
        return;
      }
      for (var S = e; ; ) {
        var I = 0, T = 0, A = false;
        do
          if (t(s[x], n[y]) < 0) {
            if (n[b--] = n[y--], I++, T = 0, --p === 0) {
              A = true;
              break;
            }
          } else if (n[b--] = s[x--], T++, I = 0, --v === 1) {
            A = true;
            break;
          }
        while ((I | T) < S);
        if (A) break;
        do {
          if (I = p - Hw(s[x], n, d, p, p - 1, t), I !== 0) {
            for (b -= I, y -= I, p -= I, w = b + 1, _ = y + 1, m = I - 1; m >= 0; m--) n[w + m] = n[_ + m];
            if (p === 0) {
              A = true;
              break;
            }
          }
          if (n[b--] = s[x--], --v === 1) {
            A = true;
            break;
          }
          if (T = v - Uw(n[y], s, 0, v, v - 1, t), T !== 0) {
            for (b -= T, x -= T, v -= T, w = b + 1, _ = x + 1, m = 0; m < T; m++) n[w + m] = s[_ + m];
            if (v <= 1) {
              A = true;
              break;
            }
          }
          if (n[b--] = n[y--], --p === 0) {
            A = true;
            break;
          }
          S--;
        } while (I >= ep || T >= ep);
        if (A) break;
        S < 0 && (S = 0), S += 2;
      }
      if (e = S, e < 1 && (e = 1), v === 1) {
        for (b -= p, y -= p, w = b + 1, _ = y + 1, m = p - 1; m >= 0; m--) n[w + m] = n[_ + m];
        n[b] = s[x];
      } else {
        if (v === 0) throw new Error();
        for (_ = b - (v - 1), m = 0; m < v; m++) n[_ + m] = s[m];
      }
    }
    return {
      mergeRuns: l,
      forceMergeRuns: u,
      pushRun: o
    };
  }
  function rx(n, t, e, r) {
    e || (e = 0), r || (r = n.length);
    var i = r - e;
    if (!(i < 2)) {
      var a = 0;
      if (i < RW) {
        a = wL(n, e, r, t), SL(n, e, r, e + a, t);
        return;
      }
      var s = $et(n, t), o = Let(i);
      do {
        if (a = wL(n, e, r, t), a < o) {
          var l = i;
          l > o && (l = o), SL(n, e, e + l, e + a, t), a = l;
        }
        s.pushRun(e, a), s.mergeRuns(), i -= a, e += a;
      } while (i !== 0);
      s.forceMergeRuns();
    }
  }
  var Us = 1, ix = 2, Op = 4, CL = false;
  function Xw() {
    CL || (CL = true, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
  }
  function TL(n, t) {
    return n.zlevel === t.zlevel ? n.z === t.z ? n.z2 - t.z2 : n.z - t.z : n.zlevel - t.zlevel;
  }
  var Oet = function() {
    function n() {
      this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = TL;
    }
    return n.prototype.traverse = function(t, e) {
      for (var r = 0; r < this._roots.length; r++) this._roots[r].traverse(t, e);
    }, n.prototype.getDisplayList = function(t, e) {
      e = e || false;
      var r = this._displayList;
      return (t || !r.length) && this.updateDisplayList(e), r;
    }, n.prototype.updateDisplayList = function(t) {
      this._displayListLen = 0;
      for (var e = this._roots, r = this._displayList, i = 0, a = e.length; i < a; i++) this._updateAndAddDisplayable(e[i], null, t);
      r.length = this._displayListLen, rx(r, TL);
    }, n.prototype._updateAndAddDisplayable = function(t, e, r) {
      if (!(t.ignore && !r)) {
        t.beforeUpdate(), t.update(), t.afterUpdate();
        var i = t.getClipPath();
        if (t.ignoreClip) e = null;
        else if (i) {
          e ? e = e.slice() : e = [];
          for (var a = i, s = t; a; ) a.parent = s, a.updateTransform(), e.push(a), s = a, a = a.getClipPath();
        }
        if (t.childrenRef) {
          for (var o = t.childrenRef(), l = 0; l < o.length; l++) {
            var u = o[l];
            t.__dirty && (u.__dirty |= Us), this._updateAndAddDisplayable(u, e, r);
          }
          t.__dirty = 0;
        } else {
          var c = t;
          e && e.length ? c.__clipPaths = e : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (Xw(), c.z = 0), isNaN(c.z2) && (Xw(), c.z2 = 0), isNaN(c.zlevel) && (Xw(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
        }
        var h = t.getDecalElement && t.getDecalElement();
        h && this._updateAndAddDisplayable(h, e, r);
        var f = t.getTextGuideLine();
        f && this._updateAndAddDisplayable(f, e, r);
        var d = t.getTextContent();
        d && this._updateAndAddDisplayable(d, e, r);
      }
    }, n.prototype.addRoot = function(t) {
      t.__zr && t.__zr.storage === this || this._roots.push(t);
    }, n.prototype.delRoot = function(t) {
      if (t instanceof Array) {
        for (var e = 0, r = t.length; e < r; e++) this.delRoot(t[e]);
        return;
      }
      var i = ne(this._roots, t);
      i >= 0 && this._roots.splice(i, 1);
    }, n.prototype.delAllRoots = function() {
      this._roots = [], this._displayList = [], this._displayListLen = 0;
    }, n.prototype.getRoots = function() {
      return this._roots;
    }, n.prototype.dispose = function() {
      this._displayList = null, this._roots = null;
    }, n;
  }(), Ox;
  Ox = ce.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(n) {
    return setTimeout(n, 16);
  };
  var og = {
    linear: function(n) {
      return n;
    },
    quadraticIn: function(n) {
      return n * n;
    },
    quadraticOut: function(n) {
      return n * (2 - n);
    },
    quadraticInOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);
    },
    cubicIn: function(n) {
      return n * n * n;
    },
    cubicOut: function(n) {
      return --n * n * n + 1;
    },
    cubicInOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);
    },
    quarticIn: function(n) {
      return n * n * n * n;
    },
    quarticOut: function(n) {
      return 1 - --n * n * n * n;
    },
    quarticInOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2);
    },
    quinticIn: function(n) {
      return n * n * n * n * n;
    },
    quinticOut: function(n) {
      return --n * n * n * n * n + 1;
    },
    quinticInOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2);
    },
    sinusoidalIn: function(n) {
      return 1 - Math.cos(n * Math.PI / 2);
    },
    sinusoidalOut: function(n) {
      return Math.sin(n * Math.PI / 2);
    },
    sinusoidalInOut: function(n) {
      return 0.5 * (1 - Math.cos(Math.PI * n));
    },
    exponentialIn: function(n) {
      return n === 0 ? 0 : Math.pow(1024, n - 1);
    },
    exponentialOut: function(n) {
      return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);
    },
    exponentialInOut: function(n) {
      return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? 0.5 * Math.pow(1024, n - 1) : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);
    },
    circularIn: function(n) {
      return 1 - Math.sqrt(1 - n * n);
    },
    circularOut: function(n) {
      return Math.sqrt(1 - --n * n);
    },
    circularInOut: function(n) {
      return (n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
    },
    elasticIn: function(n) {
      var t, e = 0.1, r = 0.4;
      return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = r / 4) : t = r * Math.asin(1 / e) / (2 * Math.PI), -(e * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / r)));
    },
    elasticOut: function(n) {
      var t, e = 0.1, r = 0.4;
      return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = r / 4) : t = r * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * n) * Math.sin((n - t) * (2 * Math.PI) / r) + 1);
    },
    elasticInOut: function(n) {
      var t, e = 0.1, r = 0.4;
      return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = r / 4) : t = r * Math.asin(1 / e) / (2 * Math.PI), (n *= 2) < 1 ? -0.5 * (e * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / r)) : e * Math.pow(2, -10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / r) * 0.5 + 1);
    },
    backIn: function(n) {
      var t = 1.70158;
      return n * n * ((t + 1) * n - t);
    },
    backOut: function(n) {
      var t = 1.70158;
      return --n * n * ((t + 1) * n + t) + 1;
    },
    backInOut: function(n) {
      var t = 2.5949095;
      return (n *= 2) < 1 ? 0.5 * (n * n * ((t + 1) * n - t)) : 0.5 * ((n -= 2) * n * ((t + 1) * n + t) + 2);
    },
    bounceIn: function(n) {
      return 1 - og.bounceOut(1 - n);
    },
    bounceOut: function(n) {
      return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
    },
    bounceInOut: function(n) {
      return n < 0.5 ? og.bounceIn(n * 2) * 0.5 : og.bounceOut(n * 2 - 1) * 0.5 + 0.5;
    }
  }, wy = Math.pow, $l = Math.sqrt, NW = 1e-8, LW = 1e-4, IL = $l(3), Sy = 1 / 3, $s = hh(), ga = hh(), kf = hh();
  function Il(n) {
    return n > -1e-8 && n < NW;
  }
  function PW(n) {
    return n > NW || n < -1e-8;
  }
  function tr(n, t, e, r, i) {
    var a = 1 - i;
    return a * a * (a * n + 3 * i * t) + i * i * (i * r + 3 * a * e);
  }
  function AL(n, t, e, r, i) {
    var a = 1 - i;
    return 3 * (((t - n) * a + 2 * (e - t) * i) * a + (r - e) * i * i);
  }
  function Fx(n, t, e, r, i, a) {
    var s = r + 3 * (t - e) - n, o = 3 * (e - t * 2 + n), l = 3 * (t - n), u = n - i, c = o * o - 3 * s * l, h = o * l - 9 * s * u, f = l * l - 3 * o * u, d = 0;
    if (Il(c) && Il(h)) if (Il(o)) a[0] = 0;
    else {
      var p = -l / o;
      p >= 0 && p <= 1 && (a[d++] = p);
    }
    else {
      var g = h * h - 4 * c * f;
      if (Il(g)) {
        var v = h / c, p = -o / s + v, m = -v / 2;
        p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m);
      } else if (g > 0) {
        var y = $l(g), x = c * o + 1.5 * s * (-h + y), b = c * o + 1.5 * s * (-h - y);
        x < 0 ? x = -wy(-x, Sy) : x = wy(x, Sy), b < 0 ? b = -wy(-b, Sy) : b = wy(b, Sy);
        var p = (-o - (x + b)) / (3 * s);
        p >= 0 && p <= 1 && (a[d++] = p);
      } else {
        var _ = (2 * c * o - 3 * s * h) / (2 * $l(c * c * c)), w = Math.acos(_) / 3, S = $l(c), I = Math.cos(w), p = (-o - 2 * S * I) / (3 * s), m = (-o + S * (I + IL * Math.sin(w))) / (3 * s), T = (-o + S * (I - IL * Math.sin(w))) / (3 * s);
        p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m), T >= 0 && T <= 1 && (a[d++] = T);
      }
    }
    return d;
  }
  function $W(n, t, e, r, i) {
    var a = 6 * e - 12 * t + 6 * n, s = 9 * t + 3 * r - 3 * n - 9 * e, o = 3 * t - 3 * n, l = 0;
    if (Il(s)) {
      if (PW(a)) {
        var u = -o / a;
        u >= 0 && u <= 1 && (i[l++] = u);
      }
    } else {
      var c = a * a - 4 * s * o;
      if (Il(c)) i[0] = -a / (2 * s);
      else if (c > 0) {
        var h = $l(c), u = (-a + h) / (2 * s), f = (-a - h) / (2 * s);
        u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
      }
    }
    return l;
  }
  function Yl(n, t, e, r, i, a) {
    var s = (t - n) * i + n, o = (e - t) * i + t, l = (r - e) * i + e, u = (o - s) * i + s, c = (l - o) * i + o, h = (c - u) * i + u;
    a[0] = n, a[1] = s, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = r;
  }
  function OW(n, t, e, r, i, a, s, o, l, u, c) {
    var h, f = 5e-3, d = 1 / 0, p, g, v, m;
    $s[0] = l, $s[1] = u;
    for (var y = 0; y < 1; y += 0.05) ga[0] = tr(n, e, i, s, y), ga[1] = tr(t, r, a, o, y), v = Dc($s, ga), v < d && (h = y, d = v);
    d = 1 / 0;
    for (var x = 0; x < 32 && !(f < LW); x++) p = h - f, g = h + f, ga[0] = tr(n, e, i, s, p), ga[1] = tr(t, r, a, o, p), v = Dc(ga, $s), p >= 0 && v < d ? (h = p, d = v) : (kf[0] = tr(n, e, i, s, g), kf[1] = tr(t, r, a, o, g), m = Dc(kf, $s), g <= 1 && m < d ? (h = g, d = m) : f *= 0.5);
    return c && (c[0] = tr(n, e, i, s, h), c[1] = tr(t, r, a, o, h)), $l(d);
  }
  function Fet(n, t, e, r, i, a, s, o, l) {
    for (var u = n, c = t, h = 0, f = 1 / l, d = 1; d <= l; d++) {
      var p = d * f, g = tr(n, e, i, s, p), v = tr(t, r, a, o, p), m = g - u, y = v - c;
      h += Math.sqrt(m * m + y * y), u = g, c = v;
    }
    return h;
  }
  function pr(n, t, e, r) {
    var i = 1 - r;
    return i * (i * n + 2 * r * t) + r * r * e;
  }
  function AI(n, t, e, r) {
    return 2 * ((1 - r) * (t - n) + r * (e - t));
  }
  function Bet(n, t, e, r, i) {
    var a = n - 2 * t + e, s = 2 * (t - n), o = n - r, l = 0;
    if (Il(a)) {
      if (PW(s)) {
        var u = -o / s;
        u >= 0 && u <= 1 && (i[l++] = u);
      }
    } else {
      var c = s * s - 4 * a * o;
      if (Il(c)) {
        var u = -s / (2 * a);
        u >= 0 && u <= 1 && (i[l++] = u);
      } else if (c > 0) {
        var h = $l(c), u = (-s + h) / (2 * a), f = (-s - h) / (2 * a);
        u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
      }
    }
    return l;
  }
  function FW(n, t, e) {
    var r = n + e - 2 * t;
    return r === 0 ? 0.5 : (n - t) / r;
  }
  function Rg(n, t, e, r, i) {
    var a = (t - n) * r + n, s = (e - t) * r + t, o = (s - a) * r + a;
    i[0] = n, i[1] = a, i[2] = o, i[3] = o, i[4] = s, i[5] = e;
  }
  function BW(n, t, e, r, i, a, s, o, l) {
    var u, c = 5e-3, h = 1 / 0;
    $s[0] = s, $s[1] = o;
    for (var f = 0; f < 1; f += 0.05) {
      ga[0] = pr(n, e, i, f), ga[1] = pr(t, r, a, f);
      var d = Dc($s, ga);
      d < h && (u = f, h = d);
    }
    h = 1 / 0;
    for (var p = 0; p < 32 && !(c < LW); p++) {
      var g = u - c, v = u + c;
      ga[0] = pr(n, e, i, g), ga[1] = pr(t, r, a, g);
      var d = Dc(ga, $s);
      if (g >= 0 && d < h) u = g, h = d;
      else {
        kf[0] = pr(n, e, i, v), kf[1] = pr(t, r, a, v);
        var m = Dc(kf, $s);
        v <= 1 && m < h ? (u = v, h = m) : c *= 0.5;
      }
    }
    return l && (l[0] = pr(n, e, i, u), l[1] = pr(t, r, a, u)), $l(h);
  }
  function zet(n, t, e, r, i, a, s) {
    for (var o = n, l = t, u = 0, c = 1 / s, h = 1; h <= s; h++) {
      var f = h * c, d = pr(n, e, i, f), p = pr(t, r, a, f), g = d - o, v = p - l;
      u += Math.sqrt(g * g + v * v), o = d, l = p;
    }
    return u;
  }
  var Vet = /cubic-bezier\(([0-9,\.e ]+)\)/;
  function Bk(n) {
    var t = n && Vet.exec(n);
    if (t) {
      var e = t[1].split(","), r = +ja(e[0]), i = +ja(e[1]), a = +ja(e[2]), s = +ja(e[3]);
      if (isNaN(r + i + a + s)) return;
      var o = [];
      return function(l) {
        return l <= 0 ? 0 : l >= 1 ? 1 : Fx(0, r, a, 1, l, o) && tr(0, i, s, 1, o[0]);
      };
    }
  }
  var Get = function() {
    function n(t) {
      this._inited = false, this._startTime = 0, this._pausedTime = 0, this._paused = false, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || false, this.onframe = t.onframe || Dn, this.ondestroy = t.ondestroy || Dn, this.onrestart = t.onrestart || Dn, t.easing && this.setEasing(t.easing);
    }
    return n.prototype.step = function(t, e) {
      if (this._inited || (this._startTime = t + this._delay, this._inited = true), this._paused) {
        this._pausedTime += e;
        return;
      }
      var r = this._life, i = t - this._startTime - this._pausedTime, a = i / r;
      a < 0 && (a = 0), a = Math.min(a, 1);
      var s = this.easingFunc, o = s ? s(a) : a;
      if (this.onframe(o), a === 1) if (this.loop) {
        var l = i % r;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else return true;
      return false;
    }, n.prototype.pause = function() {
      this._paused = true;
    }, n.prototype.resume = function() {
      this._paused = false;
    }, n.prototype.setEasing = function(t) {
      this.easing = t, this.easingFunc = Nt(t) ? t : og[t] || Bk(t);
    }, n;
  }(), zW = /* @__PURE__ */ function() {
    function n(t) {
      this.value = t;
    }
    return n;
  }(), Wet = function() {
    function n() {
      this._len = 0;
    }
    return n.prototype.insert = function(t) {
      var e = new zW(t);
      return this.insertEntry(e), e;
    }, n.prototype.insertEntry = function(t) {
      this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
    }, n.prototype.remove = function(t) {
      var e = t.prev, r = t.next;
      e ? e.next = r : this.head = r, r ? r.prev = e : this.tail = e, t.next = t.prev = null, this._len--;
    }, n.prototype.len = function() {
      return this._len;
    }, n.prototype.clear = function() {
      this.head = this.tail = null, this._len = 0;
    }, n;
  }(), Ev = function() {
    function n(t) {
      this._list = new Wet(), this._maxSize = 10, this._map = {}, this._maxSize = t;
    }
    return n.prototype.put = function(t, e) {
      var r = this._list, i = this._map, a = null;
      if (i[t] == null) {
        var s = r.len(), o = this._lastRemovedEntry;
        if (s >= this._maxSize && s > 0) {
          var l = r.head;
          r.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l;
        }
        o ? o.value = e : o = new zW(e), o.key = t, r.insertEntry(o), i[t] = o;
      }
      return a;
    }, n.prototype.get = function(t) {
      var e = this._map[t], r = this._list;
      if (e != null) return e !== r.tail && (r.remove(e), r.insertEntry(e)), e.value;
    }, n.prototype.clear = function() {
      this._list.clear(), this._map = {};
    }, n.prototype.len = function() {
      return this._list.len();
    }, n;
  }(), kL = {
    transparent: [
      0,
      0,
      0,
      0
    ],
    aliceblue: [
      240,
      248,
      255,
      1
    ],
    antiquewhite: [
      250,
      235,
      215,
      1
    ],
    aqua: [
      0,
      255,
      255,
      1
    ],
    aquamarine: [
      127,
      255,
      212,
      1
    ],
    azure: [
      240,
      255,
      255,
      1
    ],
    beige: [
      245,
      245,
      220,
      1
    ],
    bisque: [
      255,
      228,
      196,
      1
    ],
    black: [
      0,
      0,
      0,
      1
    ],
    blanchedalmond: [
      255,
      235,
      205,
      1
    ],
    blue: [
      0,
      0,
      255,
      1
    ],
    blueviolet: [
      138,
      43,
      226,
      1
    ],
    brown: [
      165,
      42,
      42,
      1
    ],
    burlywood: [
      222,
      184,
      135,
      1
    ],
    cadetblue: [
      95,
      158,
      160,
      1
    ],
    chartreuse: [
      127,
      255,
      0,
      1
    ],
    chocolate: [
      210,
      105,
      30,
      1
    ],
    coral: [
      255,
      127,
      80,
      1
    ],
    cornflowerblue: [
      100,
      149,
      237,
      1
    ],
    cornsilk: [
      255,
      248,
      220,
      1
    ],
    crimson: [
      220,
      20,
      60,
      1
    ],
    cyan: [
      0,
      255,
      255,
      1
    ],
    darkblue: [
      0,
      0,
      139,
      1
    ],
    darkcyan: [
      0,
      139,
      139,
      1
    ],
    darkgoldenrod: [
      184,
      134,
      11,
      1
    ],
    darkgray: [
      169,
      169,
      169,
      1
    ],
    darkgreen: [
      0,
      100,
      0,
      1
    ],
    darkgrey: [
      169,
      169,
      169,
      1
    ],
    darkkhaki: [
      189,
      183,
      107,
      1
    ],
    darkmagenta: [
      139,
      0,
      139,
      1
    ],
    darkolivegreen: [
      85,
      107,
      47,
      1
    ],
    darkorange: [
      255,
      140,
      0,
      1
    ],
    darkorchid: [
      153,
      50,
      204,
      1
    ],
    darkred: [
      139,
      0,
      0,
      1
    ],
    darksalmon: [
      233,
      150,
      122,
      1
    ],
    darkseagreen: [
      143,
      188,
      143,
      1
    ],
    darkslateblue: [
      72,
      61,
      139,
      1
    ],
    darkslategray: [
      47,
      79,
      79,
      1
    ],
    darkslategrey: [
      47,
      79,
      79,
      1
    ],
    darkturquoise: [
      0,
      206,
      209,
      1
    ],
    darkviolet: [
      148,
      0,
      211,
      1
    ],
    deeppink: [
      255,
      20,
      147,
      1
    ],
    deepskyblue: [
      0,
      191,
      255,
      1
    ],
    dimgray: [
      105,
      105,
      105,
      1
    ],
    dimgrey: [
      105,
      105,
      105,
      1
    ],
    dodgerblue: [
      30,
      144,
      255,
      1
    ],
    firebrick: [
      178,
      34,
      34,
      1
    ],
    floralwhite: [
      255,
      250,
      240,
      1
    ],
    forestgreen: [
      34,
      139,
      34,
      1
    ],
    fuchsia: [
      255,
      0,
      255,
      1
    ],
    gainsboro: [
      220,
      220,
      220,
      1
    ],
    ghostwhite: [
      248,
      248,
      255,
      1
    ],
    gold: [
      255,
      215,
      0,
      1
    ],
    goldenrod: [
      218,
      165,
      32,
      1
    ],
    gray: [
      128,
      128,
      128,
      1
    ],
    green: [
      0,
      128,
      0,
      1
    ],
    greenyellow: [
      173,
      255,
      47,
      1
    ],
    grey: [
      128,
      128,
      128,
      1
    ],
    honeydew: [
      240,
      255,
      240,
      1
    ],
    hotpink: [
      255,
      105,
      180,
      1
    ],
    indianred: [
      205,
      92,
      92,
      1
    ],
    indigo: [
      75,
      0,
      130,
      1
    ],
    ivory: [
      255,
      255,
      240,
      1
    ],
    khaki: [
      240,
      230,
      140,
      1
    ],
    lavender: [
      230,
      230,
      250,
      1
    ],
    lavenderblush: [
      255,
      240,
      245,
      1
    ],
    lawngreen: [
      124,
      252,
      0,
      1
    ],
    lemonchiffon: [
      255,
      250,
      205,
      1
    ],
    lightblue: [
      173,
      216,
      230,
      1
    ],
    lightcoral: [
      240,
      128,
      128,
      1
    ],
    lightcyan: [
      224,
      255,
      255,
      1
    ],
    lightgoldenrodyellow: [
      250,
      250,
      210,
      1
    ],
    lightgray: [
      211,
      211,
      211,
      1
    ],
    lightgreen: [
      144,
      238,
      144,
      1
    ],
    lightgrey: [
      211,
      211,
      211,
      1
    ],
    lightpink: [
      255,
      182,
      193,
      1
    ],
    lightsalmon: [
      255,
      160,
      122,
      1
    ],
    lightseagreen: [
      32,
      178,
      170,
      1
    ],
    lightskyblue: [
      135,
      206,
      250,
      1
    ],
    lightslategray: [
      119,
      136,
      153,
      1
    ],
    lightslategrey: [
      119,
      136,
      153,
      1
    ],
    lightsteelblue: [
      176,
      196,
      222,
      1
    ],
    lightyellow: [
      255,
      255,
      224,
      1
    ],
    lime: [
      0,
      255,
      0,
      1
    ],
    limegreen: [
      50,
      205,
      50,
      1
    ],
    linen: [
      250,
      240,
      230,
      1
    ],
    magenta: [
      255,
      0,
      255,
      1
    ],
    maroon: [
      128,
      0,
      0,
      1
    ],
    mediumaquamarine: [
      102,
      205,
      170,
      1
    ],
    mediumblue: [
      0,
      0,
      205,
      1
    ],
    mediumorchid: [
      186,
      85,
      211,
      1
    ],
    mediumpurple: [
      147,
      112,
      219,
      1
    ],
    mediumseagreen: [
      60,
      179,
      113,
      1
    ],
    mediumslateblue: [
      123,
      104,
      238,
      1
    ],
    mediumspringgreen: [
      0,
      250,
      154,
      1
    ],
    mediumturquoise: [
      72,
      209,
      204,
      1
    ],
    mediumvioletred: [
      199,
      21,
      133,
      1
    ],
    midnightblue: [
      25,
      25,
      112,
      1
    ],
    mintcream: [
      245,
      255,
      250,
      1
    ],
    mistyrose: [
      255,
      228,
      225,
      1
    ],
    moccasin: [
      255,
      228,
      181,
      1
    ],
    navajowhite: [
      255,
      222,
      173,
      1
    ],
    navy: [
      0,
      0,
      128,
      1
    ],
    oldlace: [
      253,
      245,
      230,
      1
    ],
    olive: [
      128,
      128,
      0,
      1
    ],
    olivedrab: [
      107,
      142,
      35,
      1
    ],
    orange: [
      255,
      165,
      0,
      1
    ],
    orangered: [
      255,
      69,
      0,
      1
    ],
    orchid: [
      218,
      112,
      214,
      1
    ],
    palegoldenrod: [
      238,
      232,
      170,
      1
    ],
    palegreen: [
      152,
      251,
      152,
      1
    ],
    paleturquoise: [
      175,
      238,
      238,
      1
    ],
    palevioletred: [
      219,
      112,
      147,
      1
    ],
    papayawhip: [
      255,
      239,
      213,
      1
    ],
    peachpuff: [
      255,
      218,
      185,
      1
    ],
    peru: [
      205,
      133,
      63,
      1
    ],
    pink: [
      255,
      192,
      203,
      1
    ],
    plum: [
      221,
      160,
      221,
      1
    ],
    powderblue: [
      176,
      224,
      230,
      1
    ],
    purple: [
      128,
      0,
      128,
      1
    ],
    red: [
      255,
      0,
      0,
      1
    ],
    rosybrown: [
      188,
      143,
      143,
      1
    ],
    royalblue: [
      65,
      105,
      225,
      1
    ],
    saddlebrown: [
      139,
      69,
      19,
      1
    ],
    salmon: [
      250,
      128,
      114,
      1
    ],
    sandybrown: [
      244,
      164,
      96,
      1
    ],
    seagreen: [
      46,
      139,
      87,
      1
    ],
    seashell: [
      255,
      245,
      238,
      1
    ],
    sienna: [
      160,
      82,
      45,
      1
    ],
    silver: [
      192,
      192,
      192,
      1
    ],
    skyblue: [
      135,
      206,
      235,
      1
    ],
    slateblue: [
      106,
      90,
      205,
      1
    ],
    slategray: [
      112,
      128,
      144,
      1
    ],
    slategrey: [
      112,
      128,
      144,
      1
    ],
    snow: [
      255,
      250,
      250,
      1
    ],
    springgreen: [
      0,
      255,
      127,
      1
    ],
    steelblue: [
      70,
      130,
      180,
      1
    ],
    tan: [
      210,
      180,
      140,
      1
    ],
    teal: [
      0,
      128,
      128,
      1
    ],
    thistle: [
      216,
      191,
      216,
      1
    ],
    tomato: [
      255,
      99,
      71,
      1
    ],
    turquoise: [
      64,
      224,
      208,
      1
    ],
    violet: [
      238,
      130,
      238,
      1
    ],
    wheat: [
      245,
      222,
      179,
      1
    ],
    white: [
      255,
      255,
      255,
      1
    ],
    whitesmoke: [
      245,
      245,
      245,
      1
    ],
    yellow: [
      255,
      255,
      0,
      1
    ],
    yellowgreen: [
      154,
      205,
      50,
      1
    ]
  };
  function ts(n) {
    return n = Math.round(n), n < 0 ? 0 : n > 255 ? 255 : n;
  }
  function Uet(n) {
    return n = Math.round(n), n < 0 ? 0 : n > 360 ? 360 : n;
  }
  function Ng(n) {
    return n < 0 ? 0 : n > 1 ? 1 : n;
  }
  function Yw(n) {
    var t = n;
    return t.length && t.charAt(t.length - 1) === "%" ? ts(parseFloat(t) / 100 * 255) : ts(parseInt(t, 10));
  }
  function Ec(n) {
    var t = n;
    return t.length && t.charAt(t.length - 1) === "%" ? Ng(parseFloat(t) / 100) : Ng(parseFloat(t));
  }
  function qw(n, t, e) {
    return e < 0 ? e += 1 : e > 1 && (e -= 1), e * 6 < 1 ? n + (t - n) * e * 6 : e * 2 < 1 ? t : e * 3 < 2 ? n + (t - n) * (2 / 3 - e) * 6 : n;
  }
  function Al(n, t, e) {
    return n + (t - n) * e;
  }
  function ua(n, t, e, r, i) {
    return n[0] = t, n[1] = e, n[2] = r, n[3] = i, n;
  }
  function kI(n, t) {
    return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n;
  }
  var VW = new Ev(20), Cy = null;
  function Nh(n, t) {
    Cy && kI(Cy, t), Cy = VW.put(n, Cy || t.slice());
  }
  function Yi(n, t) {
    if (n) {
      t = t || [];
      var e = VW.get(n);
      if (e) return kI(t, e);
      n = n + "";
      var r = n.replace(/ /g, "").toLowerCase();
      if (r in kL) return kI(t, kL[r]), Nh(n, t), t;
      var i = r.length;
      if (r.charAt(0) === "#") {
        if (i === 4 || i === 5) {
          var a = parseInt(r.slice(1, 4), 16);
          if (!(a >= 0 && a <= 4095)) {
            ua(t, 0, 0, 0, 1);
            return;
          }
          return ua(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(r.slice(4), 16) / 15 : 1), Nh(n, t), t;
        } else if (i === 7 || i === 9) {
          var a = parseInt(r.slice(1, 7), 16);
          if (!(a >= 0 && a <= 16777215)) {
            ua(t, 0, 0, 0, 1);
            return;
          }
          return ua(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(r.slice(7), 16) / 255 : 1), Nh(n, t), t;
        }
        return;
      }
      var s = r.indexOf("("), o = r.indexOf(")");
      if (s !== -1 && o + 1 === i) {
        var l = r.substr(0, s), u = r.substr(s + 1, o - (s + 1)).split(","), c = 1;
        switch (l) {
          case "rgba":
            if (u.length !== 4) return u.length === 3 ? ua(t, +u[0], +u[1], +u[2], 1) : ua(t, 0, 0, 0, 1);
            c = Ec(u.pop());
          case "rgb":
            if (u.length >= 3) return ua(t, Yw(u[0]), Yw(u[1]), Yw(u[2]), u.length === 3 ? c : Ec(u[3])), Nh(n, t), t;
            ua(t, 0, 0, 0, 1);
            return;
          case "hsla":
            if (u.length !== 4) {
              ua(t, 0, 0, 0, 1);
              return;
            }
            return u[3] = Ec(u[3]), DI(u, t), Nh(n, t), t;
          case "hsl":
            if (u.length !== 3) {
              ua(t, 0, 0, 0, 1);
              return;
            }
            return DI(u, t), Nh(n, t), t;
          default:
            return;
        }
      }
      ua(t, 0, 0, 0, 1);
    }
  }
  function DI(n, t) {
    var e = (parseFloat(n[0]) % 360 + 360) % 360 / 360, r = Ec(n[1]), i = Ec(n[2]), a = i <= 0.5 ? i * (r + 1) : i + r - i * r, s = i * 2 - a;
    return t = t || [], ua(t, ts(qw(s, a, e + 1 / 3) * 255), ts(qw(s, a, e) * 255), ts(qw(s, a, e - 1 / 3) * 255), 1), n.length === 4 && (t[3] = n[3]), t;
  }
  function Het(n) {
    if (n) {
      var t = n[0] / 255, e = n[1] / 255, r = n[2] / 255, i = Math.min(t, e, r), a = Math.max(t, e, r), s = a - i, o = (a + i) / 2, l, u;
      if (s === 0) l = 0, u = 0;
      else {
        o < 0.5 ? u = s / (a + i) : u = s / (2 - a - i);
        var c = ((a - t) / 6 + s / 2) / s, h = ((a - e) / 6 + s / 2) / s, f = ((a - r) / 6 + s / 2) / s;
        t === a ? l = f - h : e === a ? l = 1 / 3 + c - f : r === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
      }
      var d = [
        l * 360,
        u,
        o
      ];
      return n[3] != null && d.push(n[3]), d;
    }
  }
  function EI(n, t) {
    var e = Yi(n);
    if (e) {
      for (var r = 0; r < 3; r++) t < 0 ? e[r] = e[r] * (1 - t) | 0 : e[r] = (255 - e[r]) * t + e[r] | 0, e[r] > 255 ? e[r] = 255 : e[r] < 0 && (e[r] = 0);
      return No(e, e.length === 4 ? "rgba" : "rgb");
    }
  }
  function jw(n, t, e) {
    if (!(!(t && t.length) || !(n >= 0 && n <= 1))) {
      e = e || [];
      var r = n * (t.length - 1), i = Math.floor(r), a = Math.ceil(r), s = t[i], o = t[a], l = r - i;
      return e[0] = ts(Al(s[0], o[0], l)), e[1] = ts(Al(s[1], o[1], l)), e[2] = ts(Al(s[2], o[2], l)), e[3] = Ng(Al(s[3], o[3], l)), e;
    }
  }
  function Xet(n, t, e) {
    if (!(!(t && t.length) || !(n >= 0 && n <= 1))) {
      var r = n * (t.length - 1), i = Math.floor(r), a = Math.ceil(r), s = Yi(t[i]), o = Yi(t[a]), l = r - i, u = No([
        ts(Al(s[0], o[0], l)),
        ts(Al(s[1], o[1], l)),
        ts(Al(s[2], o[2], l)),
        Ng(Al(s[3], o[3], l))
      ], "rgba");
      return e ? {
        color: u,
        leftIndex: i,
        rightIndex: a,
        value: r
      } : u;
    }
  }
  function lg(n, t, e, r) {
    var i = Yi(n);
    if (n) return i = Het(i), t != null && (i[0] = Uet(t)), e != null && (i[1] = Ec(e)), r != null && (i[2] = Ec(r)), No(DI(i), "rgba");
  }
  function Bx(n, t) {
    var e = Yi(n);
    if (e && t != null) return e[3] = Ng(t), No(e, "rgba");
  }
  function No(n, t) {
    if (!(!n || !n.length)) {
      var e = n[0] + "," + n[1] + "," + n[2];
      return (t === "rgba" || t === "hsva" || t === "hsla") && (e += "," + n[3]), t + "(" + e + ")";
    }
  }
  function zx(n, t) {
    var e = Yi(n);
    return e ? (0.299 * e[0] + 0.587 * e[1] + 0.114 * e[2]) * e[3] / 255 + (1 - e[3]) * t : 0;
  }
  var DL = new Ev(100);
  function MI(n) {
    if (wt(n)) {
      var t = DL.get(n);
      return t || (t = EI(n, -0.1), DL.put(n, t)), t;
    } else if (g1(n)) {
      var e = rt({}, n);
      return e.colorStops = ht(n.colorStops, function(r) {
        return {
          offset: r.offset,
          color: EI(r.color, -0.1)
        };
      }), e;
    }
    return n;
  }
  var Vx = Math.round;
  function Lg(n) {
    var t;
    if (!n || n === "transparent") n = "none";
    else if (typeof n == "string" && n.indexOf("rgba") > -1) {
      var e = Yi(n);
      e && (n = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")", t = e[3]);
    }
    return {
      color: n,
      opacity: t ?? 1
    };
  }
  var Yet = 1e-4;
  function kl(n) {
    return n < Yet && n > -1e-4;
  }
  function Ty(n) {
    return Vx(n * 1e3) / 1e3;
  }
  function RI(n) {
    return Vx(n * 1e4) / 1e4;
  }
  function qet(n) {
    return "matrix(" + Ty(n[0]) + "," + Ty(n[1]) + "," + Ty(n[2]) + "," + Ty(n[3]) + "," + RI(n[4]) + "," + RI(n[5]) + ")";
  }
  var jet = {
    left: "start",
    right: "end",
    center: "middle",
    middle: "middle"
  };
  function Ket(n, t, e) {
    return e === "top" ? n += t / 2 : e === "bottom" && (n -= t / 2), n;
  }
  function Zet(n) {
    return n && (n.shadowBlur || n.shadowOffsetX || n.shadowOffsetY);
  }
  function Jet(n) {
    var t = n.style, e = n.getGlobalScale();
    return [
      t.shadowColor,
      (t.shadowBlur || 0).toFixed(2),
      (t.shadowOffsetX || 0).toFixed(2),
      (t.shadowOffsetY || 0).toFixed(2),
      e[0],
      e[1]
    ].join(",");
  }
  function GW(n) {
    return n && !!n.image;
  }
  function Qet(n) {
    return n && !!n.svgElement;
  }
  function zk(n) {
    return GW(n) || Qet(n);
  }
  function WW(n) {
    return n.type === "linear";
  }
  function UW(n) {
    return n.type === "radial";
  }
  function HW(n) {
    return n && (n.type === "linear" || n.type === "radial");
  }
  function y1(n) {
    return "url(#" + n + ")";
  }
  function XW(n) {
    var t = n.getGlobalScale(), e = Math.max(t[0], t[1]);
    return Math.max(Math.ceil(Math.log(e) / Math.log(10)), 1);
  }
  function YW(n) {
    var t = n.x || 0, e = n.y || 0, r = (n.rotation || 0) * tx, i = Ht(n.scaleX, 1), a = Ht(n.scaleY, 1), s = n.skewX || 0, o = n.skewY || 0, l = [];
    return (t || e) && l.push("translate(" + t + "px," + e + "px)"), r && l.push("rotate(" + r + ")"), (i !== 1 || a !== 1) && l.push("scale(" + i + "," + a + ")"), (s || o) && l.push("skew(" + Vx(s * tx) + "deg, " + Vx(o * tx) + "deg)"), l.join(" ");
  }
  var tnt = function() {
    return ce.hasGlobalWindow && Nt(window.btoa) ? function(n) {
      return window.btoa(unescape(encodeURIComponent(n)));
    } : typeof Buffer < "u" ? function(n) {
      return Buffer.from(n).toString("base64");
    } : function(n) {
      return null;
    };
  }(), NI = Array.prototype.slice;
  function _o(n, t, e) {
    return (t - n) * e + n;
  }
  function Kw(n, t, e, r) {
    for (var i = t.length, a = 0; a < i; a++) n[a] = _o(t[a], e[a], r);
    return n;
  }
  function ent(n, t, e, r) {
    for (var i = t.length, a = i && t[0].length, s = 0; s < i; s++) {
      n[s] || (n[s] = []);
      for (var o = 0; o < a; o++) n[s][o] = _o(t[s][o], e[s][o], r);
    }
    return n;
  }
  function Iy(n, t, e, r) {
    for (var i = t.length, a = 0; a < i; a++) n[a] = t[a] + e[a] * r;
    return n;
  }
  function EL(n, t, e, r) {
    for (var i = t.length, a = i && t[0].length, s = 0; s < i; s++) {
      n[s] || (n[s] = []);
      for (var o = 0; o < a; o++) n[s][o] = t[s][o] + e[s][o] * r;
    }
    return n;
  }
  function nnt(n, t) {
    for (var e = n.length, r = t.length, i = e > r ? t : n, a = Math.min(e, r), s = i[a - 1] || {
      color: [
        0,
        0,
        0,
        0
      ],
      offset: 0
    }, o = a; o < Math.max(e, r); o++) i.push({
      offset: s.offset,
      color: s.color.slice()
    });
  }
  function rnt(n, t, e) {
    var r = n, i = t;
    if (!(!r.push || !i.push)) {
      var a = r.length, s = i.length;
      if (a !== s) {
        var o = a > s;
        if (o) r.length = s;
        else for (var l = a; l < s; l++) r.push(e === 1 ? i[l] : NI.call(i[l]));
      }
      for (var u = r[0] && r[0].length, l = 0; l < r.length; l++) if (e === 1) isNaN(r[l]) && (r[l] = i[l]);
      else for (var c = 0; c < u; c++) isNaN(r[l][c]) && (r[l][c] = i[l][c]);
    }
  }
  function ug(n) {
    if (Kr(n)) {
      var t = n.length;
      if (Kr(n[0])) {
        for (var e = [], r = 0; r < t; r++) e.push(NI.call(n[r]));
        return e;
      }
      return NI.call(n);
    }
    return n;
  }
  function ax(n) {
    return n[0] = Math.floor(n[0]) || 0, n[1] = Math.floor(n[1]) || 0, n[2] = Math.floor(n[2]) || 0, n[3] = n[3] == null ? 1 : n[3], "rgba(" + n.join(",") + ")";
  }
  function int(n) {
    return Kr(n && n[0]) ? 2 : 1;
  }
  var Ay = 0, sx = 1, qW = 2, Fp = 3, LI = 4, PI = 5, ML = 6;
  function RL(n) {
    return n === LI || n === PI;
  }
  function ky(n) {
    return n === sx || n === qW;
  }
  var np = [
    0,
    0,
    0,
    0
  ], ant = function() {
    function n(t) {
      this.keyframes = [], this.discrete = false, this._invalid = false, this._needsSort = false, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
    }
    return n.prototype.isFinished = function() {
      return this._finished;
    }, n.prototype.setFinished = function() {
      this._finished = true, this._additiveTrack && this._additiveTrack.setFinished();
    }, n.prototype.needsAnimate = function() {
      return this.keyframes.length >= 1;
    }, n.prototype.getAdditiveTrack = function() {
      return this._additiveTrack;
    }, n.prototype.addKeyframe = function(t, e, r) {
      this._needsSort = true;
      var i = this.keyframes, a = i.length, s = false, o = ML, l = e;
      if (Kr(e)) {
        var u = int(e);
        o = u, (u === 1 && !_e(e[0]) || u === 2 && !_e(e[0][0])) && (s = true);
      } else if (_e(e) && !Eg(e)) o = Ay;
      else if (wt(e)) if (!isNaN(+e)) o = Ay;
      else {
        var c = Yi(e);
        c && (l = c, o = Fp);
      }
      else if (g1(e)) {
        var h = rt({}, l);
        h.colorStops = ht(e.colorStops, function(d) {
          return {
            offset: d.offset,
            color: Yi(d.color)
          };
        }), WW(e) ? o = LI : UW(e) && (o = PI), l = h;
      }
      a === 0 ? this.valType = o : (o !== this.valType || o === ML) && (s = true), this.discrete = this.discrete || s;
      var f = {
        time: t,
        value: l,
        rawValue: e,
        percent: 0
      };
      return r && (f.easing = r, f.easingFunc = Nt(r) ? r : og[r] || Bk(r)), i.push(f), f;
    }, n.prototype.prepare = function(t, e) {
      var r = this.keyframes;
      this._needsSort && r.sort(function(g, v) {
        return g.time - v.time;
      });
      for (var i = this.valType, a = r.length, s = r[a - 1], o = this.discrete, l = ky(i), u = RL(i), c = 0; c < a; c++) {
        var h = r[c], f = h.value, d = s.value;
        h.percent = h.time / t, o || (l && c !== a - 1 ? rnt(f, d, i) : u && nnt(f.colorStops, d.colorStops));
      }
      if (!o && i !== PI && e && this.needsAnimate() && e.needsAnimate() && i === e.valType && !e._finished) {
        this._additiveTrack = e;
        for (var p = r[0].value, c = 0; c < a; c++) i === Ay ? r[c].additiveValue = r[c].value - p : i === Fp ? r[c].additiveValue = Iy([], r[c].value, p, -1) : ky(i) && (r[c].additiveValue = i === sx ? Iy([], r[c].value, p, -1) : EL([], r[c].value, p, -1));
      }
    }, n.prototype.step = function(t, e) {
      if (!this._finished) {
        this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
        var r = this._additiveTrack != null, i = r ? "additiveValue" : "value", a = this.valType, s = this.keyframes, o = s.length, l = this.propName, u = a === Fp, c, h = this._lastFr, f = Math.min, d, p;
        if (o === 1) d = p = s[0];
        else {
          if (e < 0) c = 0;
          else if (e < this._lastFrP) {
            var g = f(h + 1, o - 1);
            for (c = g; c >= 0 && !(s[c].percent <= e); c--) ;
            c = f(c, o - 2);
          } else {
            for (c = h; c < o && !(s[c].percent > e); c++) ;
            c = f(c - 1, o - 2);
          }
          p = s[c + 1], d = s[c];
        }
        if (d && p) {
          this._lastFr = c, this._lastFrP = e;
          var v = p.percent - d.percent, m = v === 0 ? 1 : f((e - d.percent) / v, 1);
          p.easingFunc && (m = p.easingFunc(m));
          var y = r ? this._additiveValue : u ? np : t[l];
          if ((ky(a) || u) && !y && (y = this._additiveValue = []), this.discrete) t[l] = m < 1 ? d.rawValue : p.rawValue;
          else if (ky(a)) a === sx ? Kw(y, d[i], p[i], m) : ent(y, d[i], p[i], m);
          else if (RL(a)) {
            var x = d[i], b = p[i], _ = a === LI;
            t[l] = {
              type: _ ? "linear" : "radial",
              x: _o(x.x, b.x, m),
              y: _o(x.y, b.y, m),
              colorStops: ht(x.colorStops, function(S, I) {
                var T = b.colorStops[I];
                return {
                  offset: _o(S.offset, T.offset, m),
                  color: ax(Kw([], S.color, T.color, m))
                };
              }),
              global: b.global
            }, _ ? (t[l].x2 = _o(x.x2, b.x2, m), t[l].y2 = _o(x.y2, b.y2, m)) : t[l].r = _o(x.r, b.r, m);
          } else if (u) Kw(y, d[i], p[i], m), r || (t[l] = ax(y));
          else {
            var w = _o(d[i], p[i], m);
            r ? this._additiveValue = w : t[l] = w;
          }
          r && this._addToTarget(t);
        }
      }
    }, n.prototype._addToTarget = function(t) {
      var e = this.valType, r = this.propName, i = this._additiveValue;
      e === Ay ? t[r] = t[r] + i : e === Fp ? (Yi(t[r], np), Iy(np, np, i, 1), t[r] = ax(np)) : e === sx ? Iy(t[r], t[r], i, 1) : e === qW && EL(t[r], t[r], i, 1);
    }, n;
  }(), Vk = function() {
    function n(t, e, r, i) {
      if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = e, e && i) {
        Rk("Can' use additive animation on looped animation.");
        return;
      }
      this._additiveAnimators = i, this._allowDiscrete = r;
    }
    return n.prototype.getMaxTime = function() {
      return this._maxTime;
    }, n.prototype.getDelay = function() {
      return this._delay;
    }, n.prototype.getLoop = function() {
      return this._loop;
    }, n.prototype.getTarget = function() {
      return this._target;
    }, n.prototype.changeTarget = function(t) {
      this._target = t;
    }, n.prototype.when = function(t, e, r) {
      return this.whenWithKeys(t, e, ge(e), r);
    }, n.prototype.whenWithKeys = function(t, e, r, i) {
      for (var a = this._tracks, s = 0; s < r.length; s++) {
        var o = r[s], l = a[o];
        if (!l) {
          l = a[o] = new ant(o);
          var u = void 0, c = this._getAdditiveTrack(o);
          if (c) {
            var h = c.keyframes, f = h[h.length - 1];
            u = f && f.value, c.valType === Fp && u && (u = ax(u));
          } else u = this._target[o];
          if (u == null) continue;
          t > 0 && l.addKeyframe(0, ug(u), i), this._trackKeys.push(o);
        }
        l.addKeyframe(t, ug(e[o]), i);
      }
      return this._maxTime = Math.max(this._maxTime, t), this;
    }, n.prototype.pause = function() {
      this._clip.pause(), this._paused = true;
    }, n.prototype.resume = function() {
      this._clip.resume(), this._paused = false;
    }, n.prototype.isPaused = function() {
      return !!this._paused;
    }, n.prototype.duration = function(t) {
      return this._maxTime = t, this._force = true, this;
    }, n.prototype._doneCallback = function() {
      this._setTracksFinished(), this._clip = null;
      var t = this._doneCbs;
      if (t) for (var e = t.length, r = 0; r < e; r++) t[r].call(this);
    }, n.prototype._abortedCallback = function() {
      this._setTracksFinished();
      var t = this.animation, e = this._abortedCbs;
      if (t && t.removeClip(this._clip), this._clip = null, e) for (var r = 0; r < e.length; r++) e[r].call(this);
    }, n.prototype._setTracksFinished = function() {
      for (var t = this._tracks, e = this._trackKeys, r = 0; r < e.length; r++) t[e[r]].setFinished();
    }, n.prototype._getAdditiveTrack = function(t) {
      var e, r = this._additiveAnimators;
      if (r) for (var i = 0; i < r.length; i++) {
        var a = r[i].getTrack(t);
        a && (e = a);
      }
      return e;
    }, n.prototype.start = function(t) {
      if (!(this._started > 0)) {
        this._started = 1;
        for (var e = this, r = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
          var s = this._trackKeys[a], o = this._tracks[s], l = this._getAdditiveTrack(s), u = o.keyframes, c = u.length;
          if (o.prepare(i, l), o.needsAnimate()) if (!this._allowDiscrete && o.discrete) {
            var h = u[c - 1];
            h && (e._target[o.propName] = h.rawValue), o.setFinished();
          } else r.push(o);
        }
        if (r.length || this._force) {
          var f = new Get({
            life: i,
            loop: this._loop,
            delay: this._delay || 0,
            onframe: function(d) {
              e._started = 2;
              var p = e._additiveAnimators;
              if (p) {
                for (var g = false, v = 0; v < p.length; v++) if (p[v]._clip) {
                  g = true;
                  break;
                }
                g || (e._additiveAnimators = null);
              }
              for (var v = 0; v < r.length; v++) r[v].step(e._target, d);
              var m = e._onframeCbs;
              if (m) for (var v = 0; v < m.length; v++) m[v](e._target, d);
            },
            ondestroy: function() {
              e._doneCallback();
            }
          });
          this._clip = f, this.animation && this.animation.addClip(f), t && f.setEasing(t);
        } else this._doneCallback();
        return this;
      }
    }, n.prototype.stop = function(t) {
      if (this._clip) {
        var e = this._clip;
        t && e.onframe(1), this._abortedCallback();
      }
    }, n.prototype.delay = function(t) {
      return this._delay = t, this;
    }, n.prototype.during = function(t) {
      return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
    }, n.prototype.done = function(t) {
      return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
    }, n.prototype.aborted = function(t) {
      return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
    }, n.prototype.getClip = function() {
      return this._clip;
    }, n.prototype.getTrack = function(t) {
      return this._tracks[t];
    }, n.prototype.getTracks = function() {
      var t = this;
      return ht(this._trackKeys, function(e) {
        return t._tracks[e];
      });
    }, n.prototype.stopTracks = function(t, e) {
      if (!t.length || !this._clip) return true;
      for (var r = this._tracks, i = this._trackKeys, a = 0; a < t.length; a++) {
        var s = r[t[a]];
        s && !s.isFinished() && (e ? s.step(this._target, 1) : this._started === 1 && s.step(this._target, 0), s.setFinished());
      }
      for (var o = true, a = 0; a < i.length; a++) if (!r[i[a]].isFinished()) {
        o = false;
        break;
      }
      return o && this._abortedCallback(), o;
    }, n.prototype.saveTo = function(t, e, r) {
      if (t) {
        e = e || this._trackKeys;
        for (var i = 0; i < e.length; i++) {
          var a = e[i], s = this._tracks[a];
          if (!(!s || s.isFinished())) {
            var o = s.keyframes, l = o[r ? 0 : o.length - 1];
            l && (t[a] = ug(l.rawValue));
          }
        }
      }
    }, n.prototype.__changeFinalValue = function(t, e) {
      e = e || ge(t);
      for (var r = 0; r < e.length; r++) {
        var i = e[r], a = this._tracks[i];
        if (a) {
          var s = a.keyframes;
          if (s.length > 1) {
            var o = s.pop();
            a.addKeyframe(o.time, t[i]), a.prepare(this._maxTime, a.getAdditiveTrack());
          }
        }
      }
    }, n;
  }();
  function wf() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  var snt = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this) || this;
      return r._running = false, r._time = 0, r._pausedTime = 0, r._pauseStart = 0, r._paused = false, e = e || {}, r.stage = e.stage || {}, r;
    }
    return t.prototype.addClip = function(e) {
      e.animation && this.removeClip(e), this._head ? (this._tail.next = e, e.prev = this._tail, e.next = null, this._tail = e) : this._head = this._tail = e, e.animation = this;
    }, t.prototype.addAnimator = function(e) {
      e.animation = this;
      var r = e.getClip();
      r && this.addClip(r);
    }, t.prototype.removeClip = function(e) {
      if (e.animation) {
        var r = e.prev, i = e.next;
        r ? r.next = i : this._head = i, i ? i.prev = r : this._tail = r, e.next = e.prev = e.animation = null;
      }
    }, t.prototype.removeAnimator = function(e) {
      var r = e.getClip();
      r && this.removeClip(r), e.animation = null;
    }, t.prototype.update = function(e) {
      for (var r = wf() - this._pausedTime, i = r - this._time, a = this._head; a; ) {
        var s = a.next, o = a.step(r, i);
        o && (a.ondestroy(), this.removeClip(a)), a = s;
      }
      this._time = r, e || (this.trigger("frame", i), this.stage.update && this.stage.update());
    }, t.prototype._startLoop = function() {
      var e = this;
      this._running = true;
      function r() {
        e._running && (Ox(r), !e._paused && e.update());
      }
      Ox(r);
    }, t.prototype.start = function() {
      this._running || (this._time = wf(), this._pausedTime = 0, this._startLoop());
    }, t.prototype.stop = function() {
      this._running = false;
    }, t.prototype.pause = function() {
      this._paused || (this._pauseStart = wf(), this._paused = true);
    }, t.prototype.resume = function() {
      this._paused && (this._pausedTime += wf() - this._pauseStart, this._paused = false);
    }, t.prototype.clear = function() {
      for (var e = this._head; e; ) {
        var r = e.next;
        e.prev = e.next = e.animation = null, e = r;
      }
      this._head = this._tail = null;
    }, t.prototype.isFinished = function() {
      return this._head == null;
    }, t.prototype.animate = function(e, r) {
      r = r || {}, this.start();
      var i = new Vk(e, r.loop);
      return this.addAnimator(i), i;
    }, t;
  }(Da), ont = 300, Zw = ce.domSupported, Jw = function() {
    var n = [
      "click",
      "dblclick",
      "mousewheel",
      "wheel",
      "mouseout",
      "mouseup",
      "mousedown",
      "mousemove",
      "contextmenu"
    ], t = [
      "touchstart",
      "touchend",
      "touchmove"
    ], e = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    }, r = ht(n, function(i) {
      var a = i.replace("mouse", "pointer");
      return e.hasOwnProperty(a) ? a : i;
    });
    return {
      mouse: n,
      touch: t,
      pointer: r
    };
  }(), NL = {
    mouse: [
      "mousemove",
      "mouseup"
    ],
    pointer: [
      "pointermove",
      "pointerup"
    ]
  }, LL = false;
  function $I(n) {
    var t = n.pointerType;
    return t === "pen" || t === "touch";
  }
  function lnt(n) {
    n.touching = true, n.touchTimer != null && (clearTimeout(n.touchTimer), n.touchTimer = null), n.touchTimer = setTimeout(function() {
      n.touching = false, n.touchTimer = null;
    }, 700);
  }
  function Qw(n) {
    n && (n.zrByTouch = true);
  }
  function unt(n, t) {
    return ca(n.dom, new cnt(n, t), true);
  }
  function jW(n, t) {
    for (var e = t, r = false; e && e.nodeType !== 9 && !(r = e.domBelongToZr || e !== t && e === n.painterRoot); ) e = e.parentNode;
    return r;
  }
  var cnt = /* @__PURE__ */ function() {
    function n(t, e) {
      this.stopPropagation = Dn, this.stopImmediatePropagation = Dn, this.preventDefault = Dn, this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY;
    }
    return n;
  }(), Wa = {
    mousedown: function(n) {
      n = ca(this.dom, n), this.__mayPointerCapture = [
        n.zrX,
        n.zrY
      ], this.trigger("mousedown", n);
    },
    mousemove: function(n) {
      n = ca(this.dom, n);
      var t = this.__mayPointerCapture;
      t && (n.zrX !== t[0] || n.zrY !== t[1]) && this.__togglePointerCapture(true), this.trigger("mousemove", n);
    },
    mouseup: function(n) {
      n = ca(this.dom, n), this.__togglePointerCapture(false), this.trigger("mouseup", n);
    },
    mouseout: function(n) {
      n = ca(this.dom, n);
      var t = n.toElement || n.relatedTarget;
      jW(this, t) || (this.__pointerCapturing && (n.zrEventControl = "no_globalout"), this.trigger("mouseout", n));
    },
    wheel: function(n) {
      LL = true, n = ca(this.dom, n), this.trigger("mousewheel", n);
    },
    mousewheel: function(n) {
      LL || (n = ca(this.dom, n), this.trigger("mousewheel", n));
    },
    touchstart: function(n) {
      n = ca(this.dom, n), Qw(n), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(n, "start"), Wa.mousemove.call(this, n), Wa.mousedown.call(this, n);
    },
    touchmove: function(n) {
      n = ca(this.dom, n), Qw(n), this.handler.processGesture(n, "change"), Wa.mousemove.call(this, n);
    },
    touchend: function(n) {
      n = ca(this.dom, n), Qw(n), this.handler.processGesture(n, "end"), Wa.mouseup.call(this, n), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < ont && Wa.click.call(this, n);
    },
    pointerdown: function(n) {
      Wa.mousedown.call(this, n);
    },
    pointermove: function(n) {
      $I(n) || Wa.mousemove.call(this, n);
    },
    pointerup: function(n) {
      Wa.mouseup.call(this, n);
    },
    pointerout: function(n) {
      $I(n) || Wa.mouseout.call(this, n);
    }
  };
  P([
    "click",
    "dblclick",
    "contextmenu"
  ], function(n) {
    Wa[n] = function(t) {
      t = ca(this.dom, t), this.trigger(n, t);
    };
  });
  var OI = {
    pointermove: function(n) {
      $I(n) || OI.mousemove.call(this, n);
    },
    pointerup: function(n) {
      OI.mouseup.call(this, n);
    },
    mousemove: function(n) {
      this.trigger("mousemove", n);
    },
    mouseup: function(n) {
      var t = this.__pointerCapturing;
      this.__togglePointerCapture(false), this.trigger("mouseup", n), t && (n.zrEventControl = "only_globalout", this.trigger("mouseout", n));
    }
  };
  function hnt(n, t) {
    var e = t.domHandlers;
    ce.pointerEventsSupported ? P(Jw.pointer, function(r) {
      ox(t, r, function(i) {
        e[r].call(n, i);
      });
    }) : (ce.touchEventsSupported && P(Jw.touch, function(r) {
      ox(t, r, function(i) {
        e[r].call(n, i), lnt(t);
      });
    }), P(Jw.mouse, function(r) {
      ox(t, r, function(i) {
        i = $k(i), t.touching || e[r].call(n, i);
      });
    }));
  }
  function fnt(n, t) {
    ce.pointerEventsSupported ? P(NL.pointer, e) : ce.touchEventsSupported || P(NL.mouse, e);
    function e(r) {
      function i(a) {
        a = $k(a), jW(n, a.target) || (a = unt(n, a), t.domHandlers[r].call(n, a));
      }
      ox(t, r, i, {
        capture: true
      });
    }
  }
  function ox(n, t, e, r) {
    n.mounted[t] = e, n.listenerOpts[t] = r, II(n.domTarget, t, e, r);
  }
  function tS(n) {
    var t = n.mounted;
    for (var e in t) t.hasOwnProperty(e) && Tet(n.domTarget, e, t[e], n.listenerOpts[e]);
    n.mounted = {};
  }
  var PL = /* @__PURE__ */ function() {
    function n(t, e) {
      this.mounted = {}, this.listenerOpts = {}, this.touching = false, this.domTarget = t, this.domHandlers = e;
    }
    return n;
  }(), dnt = function(n) {
    q(t, n);
    function t(e, r) {
      var i = n.call(this) || this;
      return i.__pointerCapturing = false, i.dom = e, i.painterRoot = r, i._localHandlerScope = new PL(e, Wa), Zw && (i._globalHandlerScope = new PL(document, OI)), hnt(i, i._localHandlerScope), i;
    }
    return t.prototype.dispose = function() {
      tS(this._localHandlerScope), Zw && tS(this._globalHandlerScope);
    }, t.prototype.setCursor = function(e) {
      this.dom.style && (this.dom.style.cursor = e || "default");
    }, t.prototype.__togglePointerCapture = function(e) {
      if (this.__mayPointerCapture = null, Zw && +this.__pointerCapturing ^ +e) {
        this.__pointerCapturing = e;
        var r = this._globalHandlerScope;
        e ? fnt(this, r) : tS(r);
      }
    }, t;
  }(Da), KW = 1;
  ce.hasGlobalWindow && (KW = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
  var Gx = KW, FI = 0.4, BI = "#333", zI = "#ccc", pnt = "#eee", $L = m1, gnt = 5e-5;
  function Iu(n) {
    return n > gnt || n < -5e-5;
  }
  var Au = [], Lh = [], eS = Xi(), nS = Math.abs, To = function() {
    function n() {
    }
    return n.prototype.getLocalTransform = function(t) {
      return n.getLocalTransform(this, t);
    }, n.prototype.setPosition = function(t) {
      this.x = t[0], this.y = t[1];
    }, n.prototype.setScale = function(t) {
      this.scaleX = t[0], this.scaleY = t[1];
    }, n.prototype.setSkew = function(t) {
      this.skewX = t[0], this.skewY = t[1];
    }, n.prototype.setOrigin = function(t) {
      this.originX = t[0], this.originY = t[1];
    }, n.prototype.needLocalTransform = function() {
      return Iu(this.rotation) || Iu(this.x) || Iu(this.y) || Iu(this.scaleX - 1) || Iu(this.scaleY - 1) || Iu(this.skewX) || Iu(this.skewY);
    }, n.prototype.updateTransform = function() {
      var t = this.parent && this.parent.transform, e = this.needLocalTransform(), r = this.transform;
      if (!(e || t)) {
        r && ($L(r), this.invTransform = null);
        return;
      }
      r = r || Xi(), e ? this.getLocalTransform(r) : $L(r), t && (e ? Ro(r, t, r) : Ok(r, t)), this.transform = r, this._resolveGlobalScaleRatio(r);
    }, n.prototype._resolveGlobalScaleRatio = function(t) {
      var e = this.globalScaleRatio;
      if (e != null && e !== 1) {
        this.getGlobalScale(Au);
        var r = Au[0] < 0 ? -1 : 1, i = Au[1] < 0 ? -1 : 1, a = ((Au[0] - r) * e + r) / Au[0] || 0, s = ((Au[1] - i) * e + i) / Au[1] || 0;
        t[0] *= a, t[1] *= a, t[2] *= s, t[3] *= s;
      }
      this.invTransform = this.invTransform || Xi(), yd(this.invTransform, t);
    }, n.prototype.getComputedTransform = function() {
      for (var t = this, e = []; t; ) e.push(t), t = t.parent;
      for (; t = e.pop(); ) t.updateTransform();
      return this.transform;
    }, n.prototype.setLocalTransform = function(t) {
      if (t) {
        var e = t[0] * t[0] + t[1] * t[1], r = t[2] * t[2] + t[3] * t[3], i = Math.atan2(t[1], t[0]), a = Math.PI / 2 + i - Math.atan2(t[3], t[2]);
        r = Math.sqrt(r) * Math.cos(a), e = Math.sqrt(e), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +t[4], this.y = +t[5], this.scaleX = e, this.scaleY = r, this.originX = 0, this.originY = 0;
      }
    }, n.prototype.decomposeTransform = function() {
      if (this.transform) {
        var t = this.parent, e = this.transform;
        t && t.transform && (t.invTransform = t.invTransform || Xi(), Ro(Lh, t.invTransform, e), e = Lh);
        var r = this.originX, i = this.originY;
        (r || i) && (eS[4] = r, eS[5] = i, Ro(Lh, e, eS), Lh[4] -= r, Lh[5] -= i, e = Lh), this.setLocalTransform(e);
      }
    }, n.prototype.getGlobalScale = function(t) {
      var e = this.transform;
      return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
    }, n.prototype.transformCoordToLocal = function(t, e) {
      var r = [
        t,
        e
      ], i = this.invTransform;
      return i && Tr(r, r, i), r;
    }, n.prototype.transformCoordToGlobal = function(t, e) {
      var r = [
        t,
        e
      ], i = this.transform;
      return i && Tr(r, r, i), r;
    }, n.prototype.getLineScale = function() {
      var t = this.transform;
      return t && nS(t[0] - 1) > 1e-10 && nS(t[3] - 1) > 1e-10 ? Math.sqrt(nS(t[0] * t[3] - t[2] * t[1])) : 1;
    }, n.prototype.copyTransform = function(t) {
      ZW(this, t);
    }, n.getLocalTransform = function(t, e) {
      e = e || [];
      var r = t.originX || 0, i = t.originY || 0, a = t.scaleX, s = t.scaleY, o = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, h = t.y, f = t.skewX ? Math.tan(t.skewX) : 0, d = t.skewY ? Math.tan(-t.skewY) : 0;
      if (r || i || o || l) {
        var p = r + o, g = i + l;
        e[4] = -p * a - f * g * s, e[5] = -g * s - d * p * a;
      } else e[4] = e[5] = 0;
      return e[0] = a, e[3] = s, e[1] = d * a, e[2] = f * s, u && fh(e, e, u), e[4] += r + c, e[5] += i + h, e;
    }, n.initDefaultProps = function() {
      var t = n.prototype;
      t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
    }(), n;
  }(), eo = [
    "x",
    "y",
    "originX",
    "originY",
    "anchorX",
    "anchorY",
    "rotation",
    "scaleX",
    "scaleY",
    "skewX",
    "skewY"
  ];
  function ZW(n, t) {
    for (var e = 0; e < eo.length; e++) {
      var r = eo[e];
      n[r] = t[r];
    }
  }
  var OL = {};
  function qi(n, t) {
    t = t || Hl;
    var e = OL[t];
    e || (e = OL[t] = new Ev(500));
    var r = e.get(n);
    return r == null && (r = Xl.measureText(n, t).width, e.put(n, r)), r;
  }
  function FL(n, t, e, r) {
    var i = qi(n, t), a = x1(t), s = Bp(0, i, e), o = cf(0, a, r), l = new te(s, o, i, a);
    return l;
  }
  function Mv(n, t, e, r) {
    var i = ((n || "") + "").split(`
`), a = i.length;
    if (a === 1) return FL(i[0], t, e, r);
    for (var s = new te(0, 0, 0, 0), o = 0; o < i.length; o++) {
      var l = FL(i[o], t, e, r);
      o === 0 ? s.copy(l) : s.union(l);
    }
    return s;
  }
  function Bp(n, t, e) {
    return e === "right" ? n -= t : e === "center" && (n -= t / 2), n;
  }
  function cf(n, t, e) {
    return e === "middle" ? n -= t / 2 : e === "bottom" && (n -= t), n;
  }
  function x1(n) {
    return qi("\u56FD", n);
  }
  function ss(n, t) {
    return typeof n == "string" ? n.lastIndexOf("%") >= 0 ? parseFloat(n) / 100 * t : parseFloat(n) : n;
  }
  function Wx(n, t, e) {
    var r = t.position || "inside", i = t.distance != null ? t.distance : 5, a = e.height, s = e.width, o = a / 2, l = e.x, u = e.y, c = "left", h = "top";
    if (r instanceof Array) l += ss(r[0], e.width), u += ss(r[1], e.height), c = null, h = null;
    else switch (r) {
      case "left":
        l -= i, u += o, c = "right", h = "middle";
        break;
      case "right":
        l += i + s, u += o, h = "middle";
        break;
      case "top":
        l += s / 2, u -= i, c = "center", h = "bottom";
        break;
      case "bottom":
        l += s / 2, u += a + i, c = "center";
        break;
      case "inside":
        l += s / 2, u += o, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += i, u += o, h = "middle";
        break;
      case "insideRight":
        l += s - i, u += o, c = "right", h = "middle";
        break;
      case "insideTop":
        l += s / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += s / 2, u += a - i, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += s - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += a - i, h = "bottom";
        break;
      case "insideBottomRight":
        l += s - i, u += a - i, c = "right", h = "bottom";
        break;
    }
    return n = n || {}, n.x = l, n.y = u, n.align = c, n.verticalAlign = h, n;
  }
  var rS = "__zr_normal__", iS = eo.concat([
    "ignore"
  ]), vnt = Qs(eo, function(n, t) {
    return n[t] = true, n;
  }, {
    ignore: false
  }), Ph = {}, mnt = new te(0, 0, 0, 0), b1 = function() {
    function n(t) {
      this.id = CW(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
    }
    return n.prototype._init = function(t) {
      this.attr(t);
    }, n.prototype.drift = function(t, e, r) {
      switch (this.draggable) {
        case "horizontal":
          e = 0;
          break;
        case "vertical":
          t = 0;
          break;
      }
      var i = this.transform;
      i || (i = this.transform = [
        1,
        0,
        0,
        1,
        0,
        0
      ]), i[4] += t, i[5] += e, this.decomposeTransform(), this.markRedraw();
    }, n.prototype.beforeUpdate = function() {
    }, n.prototype.afterUpdate = function() {
    }, n.prototype.update = function() {
      this.updateTransform(), this.__dirty && this.updateInnerText();
    }, n.prototype.updateInnerText = function(t) {
      var e = this._textContent;
      if (e && (!e.ignore || t)) {
        this.textConfig || (this.textConfig = {});
        var r = this.textConfig, i = r.local, a = e.innerTransformable, s = void 0, o = void 0, l = false;
        a.parent = i ? this : null;
        var u = false;
        if (a.copyTransform(e), r.position != null) {
          var c = mnt;
          r.layoutRect ? c.copy(r.layoutRect) : c.copy(this.getBoundingRect()), i || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Ph, r, c) : Wx(Ph, r, c), a.x = Ph.x, a.y = Ph.y, s = Ph.align, o = Ph.verticalAlign;
          var h = r.origin;
          if (h && r.rotation != null) {
            var f = void 0, d = void 0;
            h === "center" ? (f = c.width * 0.5, d = c.height * 0.5) : (f = ss(h[0], c.width), d = ss(h[1], c.height)), u = true, a.originX = -a.x + f + (i ? 0 : c.x), a.originY = -a.y + d + (i ? 0 : c.y);
          }
        }
        r.rotation != null && (a.rotation = r.rotation);
        var p = r.offset;
        p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
        var g = r.inside == null ? typeof r.position == "string" && r.position.indexOf("inside") >= 0 : r.inside, v = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), m = void 0, y = void 0, x = void 0;
        g && this.canBeInsideText() ? (m = r.insideFill, y = r.insideStroke, (m == null || m === "auto") && (m = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(m), x = true)) : (m = r.outsideFill, y = r.outsideStroke, (m == null || m === "auto") && (m = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(m), x = true)), m = m || "#000", (m !== v.fill || y !== v.stroke || x !== v.autoStroke || s !== v.align || o !== v.verticalAlign) && (l = true, v.fill = m, v.stroke = y, v.autoStroke = x, v.align = s, v.verticalAlign = o, e.setDefaultTextStyle(v)), e.__dirty |= Us, l && e.dirtyStyle(true);
      }
    }, n.prototype.canBeInsideText = function() {
      return true;
    }, n.prototype.getInsideTextFill = function() {
      return "#fff";
    }, n.prototype.getInsideTextStroke = function(t) {
      return "#000";
    }, n.prototype.getOutsideFill = function() {
      return this.__zr && this.__zr.isDarkMode() ? zI : BI;
    }, n.prototype.getOutsideStroke = function(t) {
      var e = this.__zr && this.__zr.getBackgroundColor(), r = typeof e == "string" && Yi(e);
      r || (r = [
        255,
        255,
        255,
        1
      ]);
      for (var i = r[3], a = this.__zr.isDarkMode(), s = 0; s < 3; s++) r[s] = r[s] * i + (a ? 0 : 255) * (1 - i);
      return r[3] = 1, No(r, "rgba");
    }, n.prototype.traverse = function(t, e) {
    }, n.prototype.attrKV = function(t, e) {
      t === "textConfig" ? this.setTextConfig(e) : t === "textContent" ? this.setTextContent(e) : t === "clipPath" ? this.setClipPath(e) : t === "extra" ? (this.extra = this.extra || {}, rt(this.extra, e)) : this[t] = e;
    }, n.prototype.hide = function() {
      this.ignore = true, this.markRedraw();
    }, n.prototype.show = function() {
      this.ignore = false, this.markRedraw();
    }, n.prototype.attr = function(t, e) {
      if (typeof t == "string") this.attrKV(t, e);
      else if (Ft(t)) for (var r = t, i = ge(r), a = 0; a < i.length; a++) {
        var s = i[a];
        this.attrKV(s, t[s]);
      }
      return this.markRedraw(), this;
    }, n.prototype.saveCurrentToNormalState = function(t) {
      this._innerSaveToNormal(t);
      for (var e = this._normalState, r = 0; r < this.animators.length; r++) {
        var i = this.animators[r], a = i.__fromStateTransition;
        if (!(i.getLoop() || a && a !== rS)) {
          var s = i.targetName, o = s ? e[s] : e;
          i.saveTo(o);
        }
      }
    }, n.prototype._innerSaveToNormal = function(t) {
      var e = this._normalState;
      e || (e = this._normalState = {}), t.textConfig && !e.textConfig && (e.textConfig = this.textConfig), this._savePrimaryToNormal(t, e, iS);
    }, n.prototype._savePrimaryToNormal = function(t, e, r) {
      for (var i = 0; i < r.length; i++) {
        var a = r[i];
        t[a] != null && !(a in e) && (e[a] = this[a]);
      }
    }, n.prototype.hasState = function() {
      return this.currentStates.length > 0;
    }, n.prototype.getState = function(t) {
      return this.states[t];
    }, n.prototype.ensureState = function(t) {
      var e = this.states;
      return e[t] || (e[t] = {}), e[t];
    }, n.prototype.clearStates = function(t) {
      this.useState(rS, false, t);
    }, n.prototype.useState = function(t, e, r, i) {
      var a = t === rS, s = this.hasState();
      if (!(!s && a)) {
        var o = this.currentStates, l = this.stateTransition;
        if (!(ne(o, t) >= 0 && (e || o.length === 1))) {
          var u;
          if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
            Rk("State " + t + " not exists.");
            return;
          }
          a || this.saveCurrentToNormalState(u);
          var c = !!(u && u.hoverLayer || i);
          c && this._toggleHoverLayerFlag(true), this._applyStateObj(t, u, this._normalState, e, !r && !this.__inHover && l && l.duration > 0, l);
          var h = this._textContent, f = this._textGuide;
          return h && h.useState(t, e, r, c), f && f.useState(t, e, r, c), a ? (this.currentStates = [], this._normalState = {}) : e ? this.currentStates.push(t) : this.currentStates = [
            t
          ], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= -2), u;
        }
      }
    }, n.prototype.useStates = function(t, e, r) {
      if (!t.length) this.clearStates();
      else {
        var i = [], a = this.currentStates, s = t.length, o = s === a.length;
        if (o) {
          for (var l = 0; l < s; l++) if (t[l] !== a[l]) {
            o = false;
            break;
          }
        }
        if (o) return;
        for (var l = 0; l < s; l++) {
          var u = t[l], c = void 0;
          this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && i.push(c);
        }
        var h = i[s - 1], f = !!(h && h.hoverLayer || r);
        f && this._toggleHoverLayerFlag(true);
        var d = this._mergeStates(i), p = this.stateTransition;
        this.saveCurrentToNormalState(d), this._applyStateObj(t.join(","), d, this._normalState, false, !e && !this.__inHover && p && p.duration > 0, p);
        var g = this._textContent, v = this._textGuide;
        g && g.useStates(t, e, f), v && v.useStates(t, e, f), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= -2);
      }
    }, n.prototype.isSilent = function() {
      for (var t = this.silent, e = this.parent; !t && e; ) {
        if (e.silent) {
          t = true;
          break;
        }
        e = e.parent;
      }
      return t;
    }, n.prototype._updateAnimationTargets = function() {
      for (var t = 0; t < this.animators.length; t++) {
        var e = this.animators[t];
        e.targetName && e.changeTarget(this[e.targetName]);
      }
    }, n.prototype.removeState = function(t) {
      var e = ne(this.currentStates, t);
      if (e >= 0) {
        var r = this.currentStates.slice();
        r.splice(e, 1), this.useStates(r);
      }
    }, n.prototype.replaceState = function(t, e, r) {
      var i = this.currentStates.slice(), a = ne(i, t), s = ne(i, e) >= 0;
      a >= 0 ? s ? i.splice(a, 1) : i[a] = e : r && !s && i.push(e), this.useStates(i);
    }, n.prototype.toggleState = function(t, e) {
      e ? this.useState(t, true) : this.removeState(t);
    }, n.prototype._mergeStates = function(t) {
      for (var e = {}, r, i = 0; i < t.length; i++) {
        var a = t[i];
        rt(e, a), a.textConfig && (r = r || {}, rt(r, a.textConfig));
      }
      return r && (e.textConfig = r), e;
    }, n.prototype._applyStateObj = function(t, e, r, i, a, s) {
      var o = !(e && i);
      e && e.textConfig ? (this.textConfig = rt({}, i ? this.textConfig : r.textConfig), rt(this.textConfig, e.textConfig)) : o && r.textConfig && (this.textConfig = r.textConfig);
      for (var l = {}, u = false, c = 0; c < iS.length; c++) {
        var h = iS[c], f = a && vnt[h];
        e && e[h] != null ? f ? (u = true, l[h] = e[h]) : this[h] = e[h] : o && r[h] != null && (f ? (u = true, l[h] = r[h]) : this[h] = r[h]);
      }
      if (!a) for (var c = 0; c < this.animators.length; c++) {
        var d = this.animators[c], p = d.targetName;
        d.getLoop() || d.__changeFinalValue(p ? (e || r)[p] : e || r);
      }
      u && this._transitionState(t, l, s);
    }, n.prototype._attachComponent = function(t) {
      if (!(t.__zr && !t.__hostTarget) && t !== this) {
        var e = this.__zr;
        e && t.addSelfToZr(e), t.__zr = e, t.__hostTarget = this;
      }
    }, n.prototype._detachComponent = function(t) {
      t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
    }, n.prototype.getClipPath = function() {
      return this._clipPath;
    }, n.prototype.setClipPath = function(t) {
      this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
    }, n.prototype.removeClipPath = function() {
      var t = this._clipPath;
      t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
    }, n.prototype.getTextContent = function() {
      return this._textContent;
    }, n.prototype.setTextContent = function(t) {
      var e = this._textContent;
      e !== t && (e && e !== t && this.removeTextContent(), t.innerTransformable = new To(), this._attachComponent(t), this._textContent = t, this.markRedraw());
    }, n.prototype.setTextConfig = function(t) {
      this.textConfig || (this.textConfig = {}), rt(this.textConfig, t), this.markRedraw();
    }, n.prototype.removeTextConfig = function() {
      this.textConfig = null, this.markRedraw();
    }, n.prototype.removeTextContent = function() {
      var t = this._textContent;
      t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
    }, n.prototype.getTextGuideLine = function() {
      return this._textGuide;
    }, n.prototype.setTextGuideLine = function(t) {
      this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
    }, n.prototype.removeTextGuideLine = function() {
      var t = this._textGuide;
      t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
    }, n.prototype.markRedraw = function() {
      this.__dirty |= Us;
      var t = this.__zr;
      t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
    }, n.prototype.dirty = function() {
      this.markRedraw();
    }, n.prototype._toggleHoverLayerFlag = function(t) {
      this.__inHover = t;
      var e = this._textContent, r = this._textGuide;
      e && (e.__inHover = t), r && (r.__inHover = t);
    }, n.prototype.addSelfToZr = function(t) {
      if (this.__zr !== t) {
        this.__zr = t;
        var e = this.animators;
        if (e) for (var r = 0; r < e.length; r++) t.animation.addAnimator(e[r]);
        this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
      }
    }, n.prototype.removeSelfFromZr = function(t) {
      if (this.__zr) {
        this.__zr = null;
        var e = this.animators;
        if (e) for (var r = 0; r < e.length; r++) t.animation.removeAnimator(e[r]);
        this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
      }
    }, n.prototype.animate = function(t, e, r) {
      var i = t ? this[t] : this, a = new Vk(i, e, r);
      return t && (a.targetName = t), this.addAnimator(a, t), a;
    }, n.prototype.addAnimator = function(t, e) {
      var r = this.__zr, i = this;
      t.during(function() {
        i.updateDuringAnimation(e);
      }).done(function() {
        var a = i.animators, s = ne(a, t);
        s >= 0 && a.splice(s, 1);
      }), this.animators.push(t), r && r.animation.addAnimator(t), r && r.wakeUp();
    }, n.prototype.updateDuringAnimation = function(t) {
      this.markRedraw();
    }, n.prototype.stopAnimation = function(t, e) {
      for (var r = this.animators, i = r.length, a = [], s = 0; s < i; s++) {
        var o = r[s];
        !t || t === o.scope ? o.stop(e) : a.push(o);
      }
      return this.animators = a, this;
    }, n.prototype.animateTo = function(t, e, r) {
      aS(this, t, e, r);
    }, n.prototype.animateFrom = function(t, e, r) {
      aS(this, t, e, r, true);
    }, n.prototype._transitionState = function(t, e, r, i) {
      for (var a = aS(this, e, r, i), s = 0; s < a.length; s++) a[s].__fromStateTransition = t;
    }, n.prototype.getBoundingRect = function() {
      return null;
    }, n.prototype.getPaintRect = function() {
      return null;
    }, n.initDefaultProps = function() {
      var t = n.prototype;
      t.type = "element", t.name = "", t.ignore = t.silent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = false, t.__dirty = Us;
      function e(r, i, a, s) {
        Object.defineProperty(t, r, {
          get: function() {
            if (!this[i]) {
              var l = this[i] = [];
              o(this, l);
            }
            return this[i];
          },
          set: function(l) {
            this[a] = l[0], this[s] = l[1], this[i] = l, o(this, l);
          }
        });
        function o(l, u) {
          Object.defineProperty(u, 0, {
            get: function() {
              return l[a];
            },
            set: function(c) {
              l[a] = c;
            }
          }), Object.defineProperty(u, 1, {
            get: function() {
              return l[s];
            },
            set: function(c) {
              l[s] = c;
            }
          });
        }
      }
      Object.defineProperty && (e("position", "_legacyPos", "x", "y"), e("scale", "_legacyScale", "scaleX", "scaleY"), e("origin", "_legacyOrigin", "originX", "originY"));
    }(), n;
  }();
  zn(b1, Da);
  zn(b1, To);
  function aS(n, t, e, r, i) {
    e = e || {};
    var a = [];
    JW(n, "", n, t, e, r, a, i);
    var s = a.length, o = false, l = e.done, u = e.aborted, c = function() {
      o = true, s--, s <= 0 && (o ? l && l() : u && u());
    }, h = function() {
      s--, s <= 0 && (o ? l && l() : u && u());
    };
    s || l && l(), a.length > 0 && e.during && a[0].during(function(p, g) {
      e.during(g);
    });
    for (var f = 0; f < a.length; f++) {
      var d = a[f];
      c && d.done(c), h && d.aborted(h), e.force && d.duration(e.duration), d.start(e.easing);
    }
    return a;
  }
  function sS(n, t, e) {
    for (var r = 0; r < e; r++) n[r] = t[r];
  }
  function ynt(n) {
    return Kr(n[0]);
  }
  function xnt(n, t, e) {
    if (Kr(t[e])) if (Kr(n[e]) || (n[e] = []), Pi(t[e])) {
      var r = t[e].length;
      n[e].length !== r && (n[e] = new t[e].constructor(r), sS(n[e], t[e], r));
    } else {
      var i = t[e], a = n[e], s = i.length;
      if (ynt(i)) for (var o = i[0].length, l = 0; l < s; l++) a[l] ? sS(a[l], i[l], o) : a[l] = Array.prototype.slice.call(i[l]);
      else sS(a, i, s);
      a.length = i.length;
    }
    else n[e] = t[e];
  }
  function bnt(n, t) {
    return n === t || Kr(n) && Kr(t) && _nt(n, t);
  }
  function _nt(n, t) {
    var e = n.length;
    if (e !== t.length) return false;
    for (var r = 0; r < e; r++) if (n[r] !== t[r]) return false;
    return true;
  }
  function JW(n, t, e, r, i, a, s, o) {
    for (var l = ge(r), u = i.duration, c = i.delay, h = i.additive, f = i.setToFinal, d = !Ft(a), p = n.animators, g = [], v = 0; v < l.length; v++) {
      var m = l[v], y = r[m];
      if (y != null && e[m] != null && (d || a[m])) if (Ft(y) && !Kr(y) && !g1(y)) {
        if (t) {
          o || (e[m] = y, n.updateDuringAnimation(t));
          continue;
        }
        JW(n, m, e[m], y, i, a && a[m], s, o);
      } else g.push(m);
      else o || (e[m] = y, n.updateDuringAnimation(t), g.push(m));
    }
    var x = g.length;
    if (!h && x) for (var b = 0; b < p.length; b++) {
      var _ = p[b];
      if (_.targetName === t) {
        var w = _.stopTracks(g);
        if (w) {
          var S = ne(p, _);
          p.splice(S, 1);
        }
      }
    }
    if (i.force || (g = Le(g, function(C) {
      return !bnt(r[C], e[C]);
    }), x = g.length), x > 0 || i.force && !s.length) {
      var I = void 0, T = void 0, A = void 0;
      if (o) {
        T = {}, f && (I = {});
        for (var b = 0; b < x; b++) {
          var m = g[b];
          T[m] = e[m], f ? I[m] = r[m] : e[m] = r[m];
        }
      } else if (f) {
        A = {};
        for (var b = 0; b < x; b++) {
          var m = g[b];
          A[m] = ug(e[m]), xnt(e, r, m);
        }
      }
      var _ = new Vk(e, false, false, h ? Le(p, function(D) {
        return D.targetName === t;
      }) : null);
      _.targetName = t, i.scope && (_.scope = i.scope), f && I && _.whenWithKeys(0, I, g), A && _.whenWithKeys(0, A, g), _.whenWithKeys(u ?? 500, o ? T : r, g).delay(c || 0), n.addAnimator(_, t), s.push(_);
    }
  }
  var Vt = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this) || this;
      return r.isGroup = true, r._children = [], r.attr(e), r;
    }
    return t.prototype.childrenRef = function() {
      return this._children;
    }, t.prototype.children = function() {
      return this._children.slice();
    }, t.prototype.childAt = function(e) {
      return this._children[e];
    }, t.prototype.childOfName = function(e) {
      for (var r = this._children, i = 0; i < r.length; i++) if (r[i].name === e) return r[i];
    }, t.prototype.childCount = function() {
      return this._children.length;
    }, t.prototype.add = function(e) {
      return e && e !== this && e.parent !== this && (this._children.push(e), this._doAdd(e)), this;
    }, t.prototype.addBefore = function(e, r) {
      if (e && e !== this && e.parent !== this && r && r.parent === this) {
        var i = this._children, a = i.indexOf(r);
        a >= 0 && (i.splice(a, 0, e), this._doAdd(e));
      }
      return this;
    }, t.prototype.replace = function(e, r) {
      var i = ne(this._children, e);
      return i >= 0 && this.replaceAt(r, i), this;
    }, t.prototype.replaceAt = function(e, r) {
      var i = this._children, a = i[r];
      if (e && e !== this && e.parent !== this && e !== a) {
        i[r] = e, a.parent = null;
        var s = this.__zr;
        s && a.removeSelfFromZr(s), this._doAdd(e);
      }
      return this;
    }, t.prototype._doAdd = function(e) {
      e.parent && e.parent.remove(e), e.parent = this;
      var r = this.__zr;
      r && r !== e.__zr && e.addSelfToZr(r), r && r.refresh();
    }, t.prototype.remove = function(e) {
      var r = this.__zr, i = this._children, a = ne(i, e);
      return a < 0 ? this : (i.splice(a, 1), e.parent = null, r && e.removeSelfFromZr(r), r && r.refresh(), this);
    }, t.prototype.removeAll = function() {
      for (var e = this._children, r = this.__zr, i = 0; i < e.length; i++) {
        var a = e[i];
        r && a.removeSelfFromZr(r), a.parent = null;
      }
      return e.length = 0, this;
    }, t.prototype.eachChild = function(e, r) {
      for (var i = this._children, a = 0; a < i.length; a++) {
        var s = i[a];
        e.call(r, s, a);
      }
      return this;
    }, t.prototype.traverse = function(e, r) {
      for (var i = 0; i < this._children.length; i++) {
        var a = this._children[i], s = e.call(r, a);
        a.isGroup && !s && a.traverse(e, r);
      }
      return this;
    }, t.prototype.addSelfToZr = function(e) {
      n.prototype.addSelfToZr.call(this, e);
      for (var r = 0; r < this._children.length; r++) {
        var i = this._children[r];
        i.addSelfToZr(e);
      }
    }, t.prototype.removeSelfFromZr = function(e) {
      n.prototype.removeSelfFromZr.call(this, e);
      for (var r = 0; r < this._children.length; r++) {
        var i = this._children[r];
        i.removeSelfFromZr(e);
      }
    }, t.prototype.getBoundingRect = function(e) {
      for (var r = new te(0, 0, 0, 0), i = e || this._children, a = [], s = null, o = 0; o < i.length; o++) {
        var l = i[o];
        if (!(l.ignore || l.invisible)) {
          var u = l.getBoundingRect(), c = l.getLocalTransform(a);
          c ? (te.applyTransform(r, u, c), s = s || r.clone(), s.union(r)) : (s = s || u.clone(), s.union(u));
        }
      }
      return s || r;
    }, t;
  }(b1);
  Vt.prototype.type = "group";
  var lx = {}, QW = {};
  function wnt(n) {
    delete QW[n];
  }
  function Snt(n) {
    if (!n) return false;
    if (typeof n == "string") return zx(n, 1) < FI;
    if (n.colorStops) {
      for (var t = n.colorStops, e = 0, r = t.length, i = 0; i < r; i++) e += zx(t[i].color, 1);
      return e /= r, e < FI;
    }
    return false;
  }
  var Cnt = function() {
    function n(t, e, r) {
      var i = this;
      this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = true, this._needsRefreshHover = true, this._darkMode = false, r = r || {}, this.dom = e, this.id = t;
      var a = new Oet(), s = r.renderer || "canvas";
      lx[s] || (s = ge(lx)[0]), r.useDirtyRect = r.useDirtyRect == null ? false : r.useDirtyRect;
      var o = new lx[s](e, a, r, t), l = r.ssr || o.ssrOnly;
      this.storage = a, this.painter = o;
      var u = !ce.node && !ce.worker && !l ? new dnt(o.getViewportRoot(), o.root) : null, c = r.useCoarsePointer, h = c == null || c === "auto" ? ce.touchEventsSupported : !!c, f = 44, d;
      h && (d = Ht(r.pointerSize, f)), this.handler = new EW(a, o, u, o.root, d), this.animation = new snt({
        stage: {
          update: l ? null : function() {
            return i._flush(true);
          }
        }
      }), l || this.animation.start();
    }
    return n.prototype.add = function(t) {
      this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
    }, n.prototype.remove = function(t) {
      this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
    }, n.prototype.configLayer = function(t, e) {
      this._disposed || (this.painter.configLayer && this.painter.configLayer(t, e), this.refresh());
    }, n.prototype.setBackgroundColor = function(t) {
      this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = Snt(t));
    }, n.prototype.getBackgroundColor = function() {
      return this._backgroundColor;
    }, n.prototype.setDarkMode = function(t) {
      this._darkMode = t;
    }, n.prototype.isDarkMode = function() {
      return this._darkMode;
    }, n.prototype.refreshImmediately = function(t) {
      this._disposed || (t || this.animation.update(true), this._needsRefresh = false, this.painter.refresh(), this._needsRefresh = false);
    }, n.prototype.refresh = function() {
      this._disposed || (this._needsRefresh = true, this.animation.start());
    }, n.prototype.flush = function() {
      this._disposed || this._flush(false);
    }, n.prototype._flush = function(t) {
      var e, r = wf();
      this._needsRefresh && (e = true, this.refreshImmediately(t)), this._needsRefreshHover && (e = true, this.refreshHoverImmediately());
      var i = wf();
      e ? (this._stillFrameAccum = 0, this.trigger("rendered", {
        elapsedTime: i - r
      })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
    }, n.prototype.setSleepAfterStill = function(t) {
      this._sleepAfterStill = t;
    }, n.prototype.wakeUp = function() {
      this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
    }, n.prototype.refreshHover = function() {
      this._needsRefreshHover = true;
    }, n.prototype.refreshHoverImmediately = function() {
      this._disposed || (this._needsRefreshHover = false, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
    }, n.prototype.resize = function(t) {
      this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
    }, n.prototype.clearAnimation = function() {
      this._disposed || this.animation.clear();
    }, n.prototype.getWidth = function() {
      if (!this._disposed) return this.painter.getWidth();
    }, n.prototype.getHeight = function() {
      if (!this._disposed) return this.painter.getHeight();
    }, n.prototype.setCursorStyle = function(t) {
      this._disposed || this.handler.setCursorStyle(t);
    }, n.prototype.findHover = function(t, e) {
      if (!this._disposed) return this.handler.findHover(t, e);
    }, n.prototype.on = function(t, e, r) {
      return this._disposed || this.handler.on(t, e, r), this;
    }, n.prototype.off = function(t, e) {
      this._disposed || this.handler.off(t, e);
    }, n.prototype.trigger = function(t, e) {
      this._disposed || this.handler.trigger(t, e);
    }, n.prototype.clear = function() {
      if (!this._disposed) {
        for (var t = this.storage.getRoots(), e = 0; e < t.length; e++) t[e] instanceof Vt && t[e].removeSelfFromZr(this);
        this.storage.delAllRoots(), this.painter.clear();
      }
    }, n.prototype.dispose = function() {
      this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = true, wnt(this.id));
    }, n;
  }();
  function BL(n, t) {
    var e = new Cnt(CW(), n, t);
    return QW[e.id] = e, e;
  }
  function Tnt(n, t) {
    lx[n] = t;
  }
  var VI;
  function Int(n) {
    if (typeof VI == "function") return VI(n);
  }
  function Ant(n) {
    VI = n;
  }
  var knt = 1e-4, tU = 20;
  function Dnt(n) {
    return n.replace(/^\s+|\s+$/g, "");
  }
  function Pe(n, t, e, r) {
    var i = t[0], a = t[1], s = e[0], o = e[1], l = a - i, u = o - s;
    if (l === 0) return u === 0 ? s : (s + o) / 2;
    if (r) if (l > 0) {
      if (n <= i) return s;
      if (n >= a) return o;
    } else {
      if (n >= i) return s;
      if (n <= a) return o;
    }
    else {
      if (n === i) return s;
      if (n === a) return o;
    }
    return (n - i) / l * u + s;
  }
  function yt(n, t) {
    switch (n) {
      case "center":
      case "middle":
        n = "50%";
        break;
      case "left":
      case "top":
        n = "0%";
        break;
      case "right":
      case "bottom":
        n = "100%";
        break;
    }
    return wt(n) ? Dnt(n).match(/%$/) ? parseFloat(n) / 100 * t : parseFloat(n) : n == null ? NaN : +n;
  }
  function Cn(n, t, e) {
    return t == null && (t = 10), t = Math.min(Math.max(0, t), tU), n = (+n).toFixed(t), e ? n : +n;
  }
  function _a(n) {
    return n.sort(function(t, e) {
      return t - e;
    }), n;
  }
  function Fs(n) {
    if (n = +n, isNaN(n)) return 0;
    if (n > 1e-14) {
      for (var t = 1, e = 0; e < 15; e++, t *= 10) if (Math.round(n * t) / t === n) return e;
    }
    return Ent(n);
  }
  function Ent(n) {
    var t = n.toString().toLowerCase(), e = t.indexOf("e"), r = e > 0 ? +t.slice(e + 1) : 0, i = e > 0 ? e : t.length, a = t.indexOf("."), s = a < 0 ? 0 : i - 1 - a;
    return Math.max(0, s - r);
  }
  function eU(n, t) {
    var e = Math.log, r = Math.LN10, i = Math.floor(e(n[1] - n[0]) / r), a = Math.round(e(Math.abs(t[1] - t[0])) / r), s = Math.min(Math.max(-i + a, 0), 20);
    return isFinite(s) ? s : 20;
  }
  function Mnt(n, t) {
    var e = Qs(n, function(d, p) {
      return d + (isNaN(p) ? 0 : p);
    }, 0);
    if (e === 0) return [];
    for (var r = Math.pow(10, t), i = ht(n, function(d) {
      return (isNaN(d) ? 0 : d) / e * r * 100;
    }), a = r * 100, s = ht(i, function(d) {
      return Math.floor(d);
    }), o = Qs(s, function(d, p) {
      return d + p;
    }, 0), l = ht(i, function(d, p) {
      return d - s[p];
    }); o < a; ) {
      for (var u = Number.NEGATIVE_INFINITY, c = null, h = 0, f = l.length; h < f; ++h) l[h] > u && (u = l[h], c = h);
      ++s[c], l[c] = 0, ++o;
    }
    return ht(s, function(d) {
      return d / r;
    });
  }
  function Rnt(n, t) {
    var e = Math.max(Fs(n), Fs(t)), r = n + t;
    return e > tU ? r : Cn(r, e);
  }
  var zL = 9007199254740991;
  function nU(n) {
    var t = Math.PI * 2;
    return (n % t + t) % t;
  }
  function Pg(n) {
    return n > -1e-4 && n < knt;
  }
  var Nnt = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function no(n) {
    if (n instanceof Date) return n;
    if (wt(n)) {
      var t = Nnt.exec(n);
      if (!t) return /* @__PURE__ */ new Date(NaN);
      if (t[8]) {
        var e = +t[4] || 0;
        return t[8].toUpperCase() !== "Z" && (e -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, e, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
      } else return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
    } else if (n == null) return /* @__PURE__ */ new Date(NaN);
    return new Date(Math.round(n));
  }
  function Lnt(n) {
    return Math.pow(10, Gk(n));
  }
  function Gk(n) {
    if (n === 0) return 0;
    var t = Math.floor(Math.log(n) / Math.LN10);
    return n / Math.pow(10, t) >= 10 && t++, t;
  }
  function rU(n, t) {
    var e = Gk(n), r = Math.pow(10, e), i = n / r, a;
    return i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10, n = a * r, e >= -20 ? +n.toFixed(e < 0 ? -e : 0) : n;
  }
  function oS(n, t) {
    var e = (n.length - 1) * t + 1, r = Math.floor(e), i = +n[r - 1], a = e - r;
    return a ? i + a * (n[r] - i) : i;
  }
  function VL(n) {
    n.sort(function(l, u) {
      return o(l, u, 0) ? -1 : 1;
    });
    for (var t = -1 / 0, e = 1, r = 0; r < n.length; ) {
      for (var i = n[r].interval, a = n[r].close, s = 0; s < 2; s++) i[s] <= t && (i[s] = t, a[s] = s ? 1 : 1 - e), t = i[s], e = a[s];
      i[0] === i[1] && a[0] * a[1] !== 1 ? n.splice(r, 1) : r++;
    }
    return n;
    function o(l, u, c) {
      return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && o(l, u, 1));
    }
  }
  function zo(n) {
    var t = parseFloat(n);
    return t == n && (t !== 0 || !wt(n) || n.indexOf("x") <= 0) ? t : NaN;
  }
  function iU(n) {
    return !isNaN(zo(n));
  }
  function aU() {
    return Math.round(Math.random() * 9);
  }
  function sU(n, t) {
    return t === 0 ? n : sU(t, n % t);
  }
  function GL(n, t) {
    return n == null ? t : t == null ? n : n * t / sU(n, t);
  }
  function Ne(n) {
    throw new Error(n);
  }
  function WL(n, t, e) {
    return (t - n) * e + n;
  }
  var oU = "series\0", lU = "\0_ec_\0";
  function He(n) {
    return n instanceof Array ? n : n == null ? [] : [
      n
    ];
  }
  function Wc(n, t, e) {
    if (n) {
      n[t] = n[t] || {}, n.emphasis = n.emphasis || {}, n.emphasis[t] = n.emphasis[t] || {};
      for (var r = 0, i = e.length; r < i; r++) {
        var a = e[r];
        !n.emphasis[t].hasOwnProperty(a) && n[t].hasOwnProperty(a) && (n.emphasis[t][a] = n[t][a]);
      }
    }
  }
  var UL = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "rich",
    "tag",
    "color",
    "textBorderColor",
    "textBorderWidth",
    "width",
    "height",
    "lineHeight",
    "align",
    "verticalAlign",
    "baseline",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "textShadowColor",
    "textShadowBlur",
    "textShadowOffsetX",
    "textShadowOffsetY",
    "backgroundColor",
    "borderColor",
    "borderWidth",
    "borderRadius",
    "padding"
  ];
  function xd(n) {
    return Ft(n) && !ct(n) && !(n instanceof Date) ? n.value : n;
  }
  function Pnt(n) {
    return Ft(n) && !(n instanceof Array);
  }
  function uU(n, t, e) {
    var r = e === "normalMerge", i = e === "replaceMerge", a = e === "replaceAll";
    n = n || [], t = (t || []).slice();
    var s = It();
    P(t, function(l, u) {
      if (!Ft(l)) {
        t[u] = null;
        return;
      }
    });
    var o = $nt(n, s, e);
    return (r || i) && Ont(o, n, s, t), r && Fnt(o, t), r || i ? Bnt(o, t, i) : a && znt(o, t), Vnt(o), o;
  }
  function $nt(n, t, e) {
    var r = [];
    if (e === "replaceAll") return r;
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      a && a.id != null && t.set(a.id, i), r.push({
        existing: e === "replaceMerge" || $g(a) ? null : a,
        newOption: null,
        keyInfo: null,
        brandNew: null
      });
    }
    return r;
  }
  function Ont(n, t, e, r) {
    P(r, function(i, a) {
      if (!(!i || i.id == null)) {
        var s = cg(i.id), o = e.get(s);
        if (o != null) {
          var l = n[o];
          gi(!l.newOption, 'Duplicated option on id "' + s + '".'), l.newOption = i, l.existing = t[o], r[a] = null;
        }
      }
    });
  }
  function Fnt(n, t) {
    P(t, function(e, r) {
      if (!(!e || e.name == null)) for (var i = 0; i < n.length; i++) {
        var a = n[i].existing;
        if (!n[i].newOption && a && (a.id == null || e.id == null) && !$g(e) && !$g(a) && cU("name", a, e)) {
          n[i].newOption = e, t[r] = null;
          return;
        }
      }
    });
  }
  function Bnt(n, t, e) {
    P(t, function(r) {
      if (r) {
        for (var i, a = 0; (i = n[a]) && (i.newOption || $g(i.existing) || i.existing && r.id != null && !cU("id", r, i.existing)); ) a++;
        i ? (i.newOption = r, i.brandNew = e) : n.push({
          newOption: r,
          brandNew: e,
          existing: null,
          keyInfo: null
        }), a++;
      }
    });
  }
  function znt(n, t) {
    P(t, function(e) {
      n.push({
        newOption: e,
        brandNew: true,
        existing: null,
        keyInfo: null
      });
    });
  }
  function Vnt(n) {
    var t = It();
    P(n, function(e) {
      var r = e.existing;
      r && t.set(r.id, e);
    }), P(n, function(e) {
      var r = e.newOption;
      gi(!r || r.id == null || !t.get(r.id) || t.get(r.id) === e, "id duplicates: " + (r && r.id)), r && r.id != null && t.set(r.id, e), !e.keyInfo && (e.keyInfo = {});
    }), P(n, function(e, r) {
      var i = e.existing, a = e.newOption, s = e.keyInfo;
      if (Ft(a)) {
        if (s.name = a.name != null ? cg(a.name) : i ? i.name : oU + r, i) s.id = cg(i.id);
        else if (a.id != null) s.id = cg(a.id);
        else {
          var o = 0;
          do
            s.id = "\0" + s.name + "\0" + o++;
          while (t.get(s.id));
        }
        t.set(s.id, e);
      }
    });
  }
  function cU(n, t, e) {
    var r = Un(t[n], null), i = Un(e[n], null);
    return r != null && i != null && r === i;
  }
  function cg(n) {
    return Un(n, "");
  }
  function Un(n, t) {
    return n == null ? t : wt(n) ? n : _e(n) || xI(n) ? n + "" : t;
  }
  function Wk(n) {
    var t = n.name;
    return !!(t && t.indexOf(oU));
  }
  function $g(n) {
    return n && n.id != null && cg(n.id).indexOf(lU) === 0;
  }
  function Gnt(n) {
    return lU + n;
  }
  function Wnt(n, t, e) {
    P(n, function(r) {
      var i = r.newOption;
      Ft(i) && (r.keyInfo.mainType = t, r.keyInfo.subType = Unt(t, i, r.existing, e));
    });
  }
  function Unt(n, t, e, r) {
    var i = t.type ? t.type : e ? e.subType : r.determineSubType(n, t);
    return i;
  }
  function Hnt(n, t) {
    var e = {}, r = {};
    return i(n || [], e), i(t || [], r, e), [
      a(e),
      a(r)
    ];
    function i(s, o, l) {
      for (var u = 0, c = s.length; u < c; u++) {
        var h = Un(s[u].seriesId, null);
        if (h == null) return;
        for (var f = He(s[u].dataIndex), d = l && l[h], p = 0, g = f.length; p < g; p++) {
          var v = f[p];
          d && d[v] ? d[v] = null : (o[h] || (o[h] = {}))[v] = 1;
        }
      }
    }
    function a(s, o) {
      var l = [];
      for (var u in s) if (s.hasOwnProperty(u) && s[u] != null) if (o) l.push(+u);
      else {
        var c = a(s[u], true);
        c.length && l.push({
          seriesId: u,
          dataIndex: c
        });
      }
      return l;
    }
  }
  function Uc(n, t) {
    if (t.dataIndexInside != null) return t.dataIndexInside;
    if (t.dataIndex != null) return ct(t.dataIndex) ? ht(t.dataIndex, function(e) {
      return n.indexOfRawIndex(e);
    }) : n.indexOfRawIndex(t.dataIndex);
    if (t.name != null) return ct(t.name) ? ht(t.name, function(e) {
      return n.indexOfName(e);
    }) : n.indexOfName(t.name);
  }
  function xe() {
    var n = "__ec_inner_" + Xnt++;
    return function(t) {
      return t[n] || (t[n] = {});
    };
  }
  var Xnt = aU();
  function hg(n, t, e) {
    var r = Uk(t, e), i = r.mainTypeSpecified, a = r.queryOptionMap, s = r.others, o = s, l = e ? e.defaultMainType : null;
    return !i && l && a.set(l, {}), a.each(function(u, c) {
      var h = Rv(n, c, u, {
        useDefault: l === c,
        enableAll: e && e.enableAll != null ? e.enableAll : true,
        enableNone: e && e.enableNone != null ? e.enableNone : true
      });
      o[c + "Models"] = h.models, o[c + "Model"] = h.models[0];
    }), o;
  }
  function Uk(n, t) {
    var e;
    if (wt(n)) {
      var r = {};
      r[n + "Index"] = 0, e = r;
    } else e = n;
    var i = It(), a = {}, s = false;
    return P(e, function(o, l) {
      if (l === "dataIndex" || l === "dataIndexInside") {
        a[l] = o;
        return;
      }
      var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
      if (!(!c || !h || t && t.includeMainTypes && ne(t.includeMainTypes, c) < 0)) {
        s = s || !!c;
        var f = i.get(c) || i.set(c, {});
        f[h] = o;
      }
    }), {
      mainTypeSpecified: s,
      queryOptionMap: i,
      others: a
    };
  }
  var On = {
    useDefault: true,
    enableAll: false,
    enableNone: false
  }, Ynt = {
    useDefault: false,
    enableAll: true,
    enableNone: true
  };
  function Rv(n, t, e, r) {
    r = r || On;
    var i = e.index, a = e.id, s = e.name, o = {
      models: null,
      specified: i != null || a != null || s != null
    };
    if (!o.specified) {
      var l = void 0;
      return o.models = r.useDefault && (l = n.getComponent(t)) ? [
        l
      ] : [], o;
    }
    return i === "none" || i === false ? (gi(r.enableNone, '`"none"` or `false` is not a valid value on index option.'), o.models = [], o) : (i === "all" && (gi(r.enableAll, '`"all"` is not a valid value on index option.'), i = a = s = null), o.models = n.queryComponents({
      mainType: t,
      index: i,
      id: a,
      name: s
    }), o);
  }
  function hU(n, t, e) {
    n.setAttribute ? n.setAttribute(t, e) : n[t] = e;
  }
  function qnt(n, t) {
    return n.getAttribute ? n.getAttribute(t) : n[t];
  }
  function jnt(n) {
    return n === "auto" ? ce.domSupported ? "html" : "richText" : n || "html";
  }
  function GI(n, t) {
    var e = It(), r = [];
    return P(n, function(i) {
      var a = t(i);
      (e.get(a) || (r.push(a), e.set(a, []))).push(i);
    }), {
      keys: r,
      buckets: e
    };
  }
  function fU(n, t, e, r, i) {
    var a = t == null || t === "auto";
    if (r == null) return r;
    if (_e(r)) {
      var s = WL(e || 0, r, i);
      return Cn(s, a ? Math.max(Fs(e || 0), Fs(r)) : t);
    } else {
      if (wt(r)) return i < 1 ? e : r;
      for (var o = [], l = e, u = r, c = Math.max(l ? l.length : 0, u.length), h = 0; h < c; ++h) {
        var f = n.getDimensionInfo(h);
        if (f && f.type === "ordinal") o[h] = (i < 1 && l ? l : u)[h];
        else {
          var d = l && l[h] ? l[h] : 0, p = u[h], s = WL(d, p, i);
          o[h] = Cn(s, a ? Math.max(Fs(d), Fs(p)) : t);
        }
      }
      return o;
    }
  }
  var Knt = ".", ku = "___EC__COMPONENT__CONTAINER___", dU = "___EC__EXTENDED_CLASS___";
  function Bs(n) {
    var t = {
      main: "",
      sub: ""
    };
    if (n) {
      var e = n.split(Knt);
      t.main = e[0] || "", t.sub = e[1] || "";
    }
    return t;
  }
  function Znt(n) {
    gi(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(n), 'componentType "' + n + '" illegal');
  }
  function Jnt(n) {
    return !!(n && n[dU]);
  }
  function Hk(n, t) {
    n.$constructor = n, n.extend = function(e) {
      var r = this, i;
      return Qnt(r) ? i = function(a) {
        q(s, a);
        function s() {
          return a.apply(this, arguments) || this;
        }
        return s;
      }(r) : (i = function() {
        (e.$constructor || r).apply(this, arguments);
      }, net(i, this)), rt(i.prototype, e), i[dU] = true, i.extend = this.extend, i.superCall = nrt, i.superApply = rrt, i.superClass = r, i;
    };
  }
  function Qnt(n) {
    return Nt(n) && /^class\s/.test(Function.prototype.toString.call(n));
  }
  function pU(n, t) {
    n.extend = t.extend;
  }
  var trt = Math.round(Math.random() * 10);
  function ert(n) {
    var t = [
      "__\0is_clz",
      trt++
    ].join("_");
    n.prototype[t] = true, n.isInstance = function(e) {
      return !!(e && e[t]);
    };
  }
  function nrt(n, t) {
    for (var e = [], r = 2; r < arguments.length; r++) e[r - 2] = arguments[r];
    return this.superClass.prototype[t].apply(n, e);
  }
  function rrt(n, t, e) {
    return this.superClass.prototype[t].apply(n, e);
  }
  function _1(n) {
    var t = {};
    n.registerClass = function(r) {
      var i = r.type || r.prototype.type;
      if (i) {
        Znt(i), r.prototype.type = i;
        var a = Bs(i);
        if (!a.sub) t[a.main] = r;
        else if (a.sub !== ku) {
          var s = e(a);
          s[a.sub] = r;
        }
      }
      return r;
    }, n.getClass = function(r, i, a) {
      var s = t[r];
      if (s && s[ku] && (s = i ? s[i] : null), a && !s) throw new Error(i ? "Component " + r + "." + (i || "") + " is used but not imported." : r + ".type should be specified.");
      return s;
    }, n.getClassesByMainType = function(r) {
      var i = Bs(r), a = [], s = t[i.main];
      return s && s[ku] ? P(s, function(o, l) {
        l !== ku && a.push(o);
      }) : a.push(s), a;
    }, n.hasClass = function(r) {
      var i = Bs(r);
      return !!t[i.main];
    }, n.getAllClassMainTypes = function() {
      var r = [];
      return P(t, function(i, a) {
        r.push(a);
      }), r;
    }, n.hasSubTypes = function(r) {
      var i = Bs(r), a = t[i.main];
      return a && a[ku];
    };
    function e(r) {
      var i = t[r.main];
      return (!i || !i[ku]) && (i = t[r.main] = {}, i[ku] = true), i;
    }
  }
  function Hc(n, t) {
    for (var e = 0; e < n.length; e++) n[e][1] || (n[e][1] = n[e][0]);
    return t = t || false, function(r, i, a) {
      for (var s = {}, o = 0; o < n.length; o++) {
        var l = n[o][1];
        if (!(i && ne(i, l) >= 0 || a && ne(a, l) < 0)) {
          var u = r.getShallow(l, t);
          u != null && (s[n[o][0]] = u);
        }
      }
      return s;
    };
  }
  var irt = [
    [
      "fill",
      "color"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "opacity"
    ],
    [
      "shadowColor"
    ]
  ], art = Hc(irt), srt = function() {
    function n() {
    }
    return n.prototype.getAreaStyle = function(t, e) {
      return art(this, t, e);
    }, n;
  }(), WI = new Ev(50);
  function ort(n) {
    if (typeof n == "string") {
      var t = WI.get(n);
      return t && t.image;
    } else return n;
  }
  function Xk(n, t, e, r, i) {
    if (n) if (typeof n == "string") {
      if (t && t.__zrImageSrc === n || !e) return t;
      var a = WI.get(n), s = {
        hostEl: e,
        cb: r,
        cbPayload: i
      };
      return a ? (t = a.image, !w1(t) && a.pending.push(s)) : (t = Xl.loadImage(n, HL, HL), t.__zrImageSrc = n, WI.put(n, t.__cachedImgObj = {
        image: t,
        pending: [
          s
        ]
      })), t;
    } else return n;
    else return t;
  }
  function HL() {
    var n = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;
    for (var t = 0; t < n.pending.length; t++) {
      var e = n.pending[t], r = e.cb;
      r && r(this, e.cbPayload), e.hostEl.dirty();
    }
    n.pending.length = 0;
  }
  function w1(n) {
    return n && n.width && n.height;
  }
  var lS = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
  function lrt(n, t, e, r, i, a) {
    if (!e) {
      n.text = "", n.isTruncated = false;
      return;
    }
    var s = (t + "").split(`
`);
    a = gU(e, r, i, a);
    for (var o = false, l = {}, u = 0, c = s.length; u < c; u++) vU(l, s[u], a), s[u] = l.textLine, o = o || l.isTruncated;
    n.text = s.join(`
`), n.isTruncated = o;
  }
  function gU(n, t, e, r) {
    r = r || {};
    var i = rt({}, r);
    i.font = t, e = Ht(e, "..."), i.maxIterations = Ht(r.maxIterations, 2);
    var a = i.minChar = Ht(r.minChar, 0);
    i.cnCharWidth = qi("\u56FD", t);
    var s = i.ascCharWidth = qi("a", t);
    i.placeholder = Ht(r.placeholder, "");
    for (var o = n = Math.max(0, n - 1), l = 0; l < a && o >= s; l++) o -= s;
    var u = qi(e, t);
    return u > o && (e = "", u = 0), o = n - u, i.ellipsis = e, i.ellipsisWidth = u, i.contentWidth = o, i.containerWidth = n, i;
  }
  function vU(n, t, e) {
    var r = e.containerWidth, i = e.font, a = e.contentWidth;
    if (!r) {
      n.textLine = "", n.isTruncated = false;
      return;
    }
    var s = qi(t, i);
    if (s <= r) {
      n.textLine = t, n.isTruncated = false;
      return;
    }
    for (var o = 0; ; o++) {
      if (s <= a || o >= e.maxIterations) {
        t += e.ellipsis;
        break;
      }
      var l = o === 0 ? urt(t, a, e.ascCharWidth, e.cnCharWidth) : s > 0 ? Math.floor(t.length * a / s) : 0;
      t = t.substr(0, l), s = qi(t, i);
    }
    t === "" && (t = e.placeholder), n.textLine = t, n.isTruncated = true;
  }
  function urt(n, t, e, r) {
    for (var i = 0, a = 0, s = n.length; a < s && i < t; a++) {
      var o = n.charCodeAt(a);
      i += 0 <= o && o <= 127 ? e : r;
    }
    return a;
  }
  function crt(n, t) {
    n != null && (n += "");
    var e = t.overflow, r = t.padding, i = t.font, a = e === "truncate", s = x1(i), o = Ht(t.lineHeight, s), l = !!t.backgroundColor, u = t.lineOverflow === "truncate", c = false, h = t.width, f;
    h != null && (e === "break" || e === "breakAll") ? f = n ? mU(n, t.font, h, e === "breakAll", 0).lines : [] : f = n ? n.split(`
`) : [];
    var d = f.length * o, p = Ht(t.height, d);
    if (d > p && u) {
      var g = Math.floor(p / o);
      c = c || f.length > g, f = f.slice(0, g);
    }
    if (n && a && h != null) for (var v = gU(h, i, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), m = {}, y = 0; y < f.length; y++) vU(m, f[y], v), f[y] = m.textLine, c = c || m.isTruncated;
    for (var x = p, b = 0, y = 0; y < f.length; y++) b = Math.max(qi(f[y], i), b);
    h == null && (h = b);
    var _ = b;
    return r && (x += r[0] + r[2], _ += r[1] + r[3], h += r[1] + r[3]), l && (_ = h), {
      lines: f,
      height: p,
      outerWidth: _,
      outerHeight: x,
      lineHeight: o,
      calculatedLineHeight: s,
      contentWidth: b,
      contentHeight: d,
      width: h,
      isTruncated: c
    };
  }
  var hrt = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), XL = /* @__PURE__ */ function() {
    function n(t) {
      this.tokens = [], t && (this.tokens = t);
    }
    return n;
  }(), frt = /* @__PURE__ */ function() {
    function n() {
      this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = false;
    }
    return n;
  }();
  function drt(n, t) {
    var e = new frt();
    if (n != null && (n += ""), !n) return e;
    for (var r = t.width, i = t.height, a = t.overflow, s = (a === "break" || a === "breakAll") && r != null ? {
      width: r,
      accumWidth: 0,
      breakAll: a === "breakAll"
    } : null, o = lS.lastIndex = 0, l; (l = lS.exec(n)) != null; ) {
      var u = l.index;
      u > o && uS(e, n.substring(o, u), t, s), uS(e, l[2], t, s, l[1]), o = lS.lastIndex;
    }
    o < n.length && uS(e, n.substring(o, n.length), t, s);
    var c = [], h = 0, f = 0, d = t.padding, p = a === "truncate", g = t.lineOverflow === "truncate", v = {};
    function m(O, F, z) {
      O.width = F, O.lineHeight = z, h += z, f = Math.max(f, F);
    }
    t: for (var y = 0; y < e.lines.length; y++) {
      for (var x = e.lines[y], b = 0, _ = 0, w = 0; w < x.tokens.length; w++) {
        var S = x.tokens[w], I = S.styleName && t.rich[S.styleName] || {}, T = S.textPadding = I.padding, A = T ? T[1] + T[3] : 0, C = S.font = I.font || t.font;
        S.contentHeight = x1(C);
        var D = Ht(I.height, S.contentHeight);
        if (S.innerHeight = D, T && (D += T[0] + T[2]), S.height = D, S.lineHeight = Ws(I.lineHeight, t.lineHeight, D), S.align = I && I.align || t.align, S.verticalAlign = I && I.verticalAlign || "middle", g && i != null && h + S.lineHeight > i) {
          var E = e.lines.length;
          w > 0 ? (x.tokens = x.tokens.slice(0, w), m(x, _, b), e.lines = e.lines.slice(0, y + 1)) : e.lines = e.lines.slice(0, y), e.isTruncated = e.isTruncated || e.lines.length < E;
          break t;
        }
        var M = I.width, L = M == null || M === "auto";
        if (typeof M == "string" && M.charAt(M.length - 1) === "%") S.percentWidth = M, c.push(S), S.contentWidth = qi(S.text, C);
        else {
          if (L) {
            var k = I.backgroundColor, N = k && k.image;
            N && (N = ort(N), w1(N) && (S.width = Math.max(S.width, N.width * D / N.height)));
          }
          var R = p && r != null ? r - _ : null;
          R != null && R < S.width ? !L || R < A ? (S.text = "", S.width = S.contentWidth = 0) : (lrt(v, S.text, R - A, C, t.ellipsis, {
            minChar: t.truncateMinChar
          }), S.text = v.text, e.isTruncated = e.isTruncated || v.isTruncated, S.width = S.contentWidth = qi(S.text, C)) : S.contentWidth = qi(S.text, C);
        }
        S.width += A, _ += S.width, I && (b = Math.max(b, S.lineHeight));
      }
      m(x, _, b);
    }
    e.outerWidth = e.width = Ht(r, f), e.outerHeight = e.height = Ht(i, h), e.contentHeight = h, e.contentWidth = f, d && (e.outerWidth += d[1] + d[3], e.outerHeight += d[0] + d[2]);
    for (var y = 0; y < c.length; y++) {
      var S = c[y], $ = S.percentWidth;
      S.width = parseInt($, 10) / 100 * e.width;
    }
    return e;
  }
  function uS(n, t, e, r, i) {
    var a = t === "", s = i && e.rich[i] || {}, o = n.lines, l = s.font || e.font, u = false, c, h;
    if (r) {
      var f = s.padding, d = f ? f[1] + f[3] : 0;
      if (s.width != null && s.width !== "auto") {
        var p = ss(s.width, r.width) + d;
        o.length > 0 && p + r.accumWidth > r.width && (c = t.split(`
`), u = true), r.accumWidth = p;
      } else {
        var g = mU(t, l, r.width, r.breakAll, r.accumWidth);
        r.accumWidth = g.accumWidth + d, h = g.linesWidths, c = g.lines;
      }
    } else c = t.split(`
`);
    for (var v = 0; v < c.length; v++) {
      var m = c[v], y = new hrt();
      if (y.styleName = i, y.text = m, y.isLineHolder = !m && !a, typeof s.width == "number" ? y.width = s.width : y.width = h ? h[v] : qi(m, l), !v && !u) {
        var x = (o[o.length - 1] || (o[0] = new XL())).tokens, b = x.length;
        b === 1 && x[0].isLineHolder ? x[0] = y : (m || !b || a) && x.push(y);
      } else o.push(new XL([
        y
      ]));
    }
  }
  function prt(n) {
    var t = n.charCodeAt(0);
    return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
  }
  var grt = Qs(",&?/;] ".split(""), function(n, t) {
    return n[t] = true, n;
  }, {});
  function vrt(n) {
    return prt(n) ? !!grt[n] : true;
  }
  function mU(n, t, e, r, i) {
    for (var a = [], s = [], o = "", l = "", u = 0, c = 0, h = 0; h < n.length; h++) {
      var f = n.charAt(h);
      if (f === `
`) {
        l && (o += l, c += u), a.push(o), s.push(c), o = "", l = "", u = 0, c = 0;
        continue;
      }
      var d = qi(f, t), p = r ? false : !vrt(f);
      if (a.length ? c + d > e : i + c + d > e) {
        c ? (o || l) && (p ? (o || (o = l, l = "", u = 0, c = u), a.push(o), s.push(c - u), l += f, u += d, o = "", c = u) : (l && (o += l, l = "", u = 0), a.push(o), s.push(c), o = f, c = d)) : p ? (a.push(l), s.push(u), l = f, u = d) : (a.push(f), s.push(d));
        continue;
      }
      c += d, p ? (l += f, u += d) : (l && (o += l, l = "", u = 0), o += f);
    }
    return !a.length && !o && (o = n, l = "", u = 0), l && (o += l), o && (a.push(o), s.push(c)), a.length === 1 && (c += i), {
      accumWidth: c,
      lines: a,
      linesWidths: s
    };
  }
  var UI = "__zr_style_" + Math.round(Math.random() * 10), Mc = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    opacity: 1,
    blend: "source-over"
  }, S1 = {
    style: {
      shadowBlur: true,
      shadowOffsetX: true,
      shadowOffsetY: true,
      shadowColor: true,
      opacity: true
    }
  };
  Mc[UI] = true;
  var YL = [
    "z",
    "z2",
    "invisible"
  ], mrt = [
    "invisible"
  ], Ia = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype._init = function(e) {
      for (var r = ge(e), i = 0; i < r.length; i++) {
        var a = r[i];
        a === "style" ? this.useStyle(e[a]) : n.prototype.attrKV.call(this, a, e[a]);
      }
      this.style || this.useStyle({});
    }, t.prototype.beforeBrush = function() {
    }, t.prototype.afterBrush = function() {
    }, t.prototype.innerBeforeBrush = function() {
    }, t.prototype.innerAfterBrush = function() {
    }, t.prototype.shouldBePainted = function(e, r, i, a) {
      var s = this.transform;
      if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && yrt(this, e, r) || s && !s[0] && !s[3]) return false;
      if (i && this.__clipPaths) {
        for (var o = 0; o < this.__clipPaths.length; ++o) if (this.__clipPaths[o].isZeroArea()) return false;
      }
      if (a && this.parent) for (var l = this.parent; l; ) {
        if (l.ignore) return false;
        l = l.parent;
      }
      return true;
    }, t.prototype.contain = function(e, r) {
      return this.rectContain(e, r);
    }, t.prototype.traverse = function(e, r) {
      e.call(r, this);
    }, t.prototype.rectContain = function(e, r) {
      var i = this.transformCoordToLocal(e, r), a = this.getBoundingRect();
      return a.contain(i[0], i[1]);
    }, t.prototype.getPaintRect = function() {
      var e = this._paintRect;
      if (!this._paintRect || this.__dirty) {
        var r = this.transform, i = this.getBoundingRect(), a = this.style, s = a.shadowBlur || 0, o = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
        e = this._paintRect || (this._paintRect = new te(0, 0, 0, 0)), r ? te.applyTransform(e, i, r) : e.copy(i), (s || o || l) && (e.width += s * 2 + Math.abs(o), e.height += s * 2 + Math.abs(l), e.x = Math.min(e.x, e.x + o - s), e.y = Math.min(e.y, e.y + l - s));
        var u = this.dirtyRectTolerance;
        e.isZero() || (e.x = Math.floor(e.x - u), e.y = Math.floor(e.y - u), e.width = Math.ceil(e.width + 1 + u * 2), e.height = Math.ceil(e.height + 1 + u * 2));
      }
      return e;
    }, t.prototype.setPrevPaintRect = function(e) {
      e ? (this._prevPaintRect = this._prevPaintRect || new te(0, 0, 0, 0), this._prevPaintRect.copy(e)) : this._prevPaintRect = null;
    }, t.prototype.getPrevPaintRect = function() {
      return this._prevPaintRect;
    }, t.prototype.animateStyle = function(e) {
      return this.animate("style", e);
    }, t.prototype.updateDuringAnimation = function(e) {
      e === "style" ? this.dirtyStyle() : this.markRedraw();
    }, t.prototype.attrKV = function(e, r) {
      e !== "style" ? n.prototype.attrKV.call(this, e, r) : this.style ? this.setStyle(r) : this.useStyle(r);
    }, t.prototype.setStyle = function(e, r) {
      return typeof e == "string" ? this.style[e] = r : rt(this.style, e), this.dirtyStyle(), this;
    }, t.prototype.dirtyStyle = function(e) {
      e || this.markRedraw(), this.__dirty |= ix, this._rect && (this._rect = null);
    }, t.prototype.dirty = function() {
      this.dirtyStyle();
    }, t.prototype.styleChanged = function() {
      return !!(this.__dirty & ix);
    }, t.prototype.styleUpdated = function() {
      this.__dirty &= -3;
    }, t.prototype.createStyle = function(e) {
      return v1(Mc, e);
    }, t.prototype.useStyle = function(e) {
      e[UI] || (e = this.createStyle(e)), this.__inHover ? this.__hoverStyle = e : this.style = e, this.dirtyStyle();
    }, t.prototype.isStyleObject = function(e) {
      return e[UI];
    }, t.prototype._innerSaveToNormal = function(e) {
      n.prototype._innerSaveToNormal.call(this, e);
      var r = this._normalState;
      e.style && !r.style && (r.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(e, r, YL);
    }, t.prototype._applyStateObj = function(e, r, i, a, s, o) {
      n.prototype._applyStateObj.call(this, e, r, i, a, s, o);
      var l = !(r && a), u;
      if (r && r.style ? s ? a ? u = r.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, r.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(u, r.style)) : l && (u = i.style), u) if (s) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l) for (var h = ge(c), f = 0; f < h.length; f++) {
          var d = h[f];
          d in u && (u[d] = u[d], this.style[d] = c[d]);
        }
        for (var p = ge(u), f = 0; f < p.length; f++) {
          var d = p[f];
          this.style[d] = this.style[d];
        }
        this._transitionState(e, {
          style: u
        }, o, this.getAnimationStyleProps());
      } else this.useStyle(u);
      for (var g = this.__inHover ? mrt : YL, f = 0; f < g.length; f++) {
        var d = g[f];
        r && r[d] != null ? this[d] = r[d] : l && i[d] != null && (this[d] = i[d]);
      }
    }, t.prototype._mergeStates = function(e) {
      for (var r = n.prototype._mergeStates.call(this, e), i, a = 0; a < e.length; a++) {
        var s = e[a];
        s.style && (i = i || {}, this._mergeStyle(i, s.style));
      }
      return i && (r.style = i), r;
    }, t.prototype._mergeStyle = function(e, r) {
      return rt(e, r), e;
    }, t.prototype.getAnimationStyleProps = function() {
      return S1;
    }, t.initDefaultProps = function() {
      var e = t.prototype;
      e.type = "displayable", e.invisible = false, e.z = 0, e.z2 = 0, e.zlevel = 0, e.culling = false, e.cursor = "pointer", e.rectHover = false, e.incremental = false, e._rect = null, e.dirtyRectTolerance = 0, e.__dirty = Us | ix;
    }(), t;
  }(b1), cS = new te(0, 0, 0, 0), hS = new te(0, 0, 0, 0);
  function yrt(n, t, e) {
    return cS.copy(n.getBoundingRect()), n.transform && cS.applyTransform(n.transform), hS.width = t, hS.height = e, !cS.intersect(hS);
  }
  var Ai = Math.min, ki = Math.max, fS = Math.sin, dS = Math.cos, Du = Math.PI * 2, Dy = hh(), Ey = hh(), My = hh();
  function C1(n, t, e) {
    if (n.length !== 0) {
      for (var r = n[0], i = r[0], a = r[0], s = r[1], o = r[1], l = 1; l < n.length; l++) r = n[l], i = Ai(i, r[0]), a = ki(a, r[0]), s = Ai(s, r[1]), o = ki(o, r[1]);
      t[0] = i, t[1] = s, e[0] = a, e[1] = o;
    }
  }
  function qL(n, t, e, r, i, a) {
    i[0] = Ai(n, e), i[1] = Ai(t, r), a[0] = ki(n, e), a[1] = ki(t, r);
  }
  var jL = [], KL = [];
  function xrt(n, t, e, r, i, a, s, o, l, u) {
    var c = $W, h = tr, f = c(n, e, i, s, jL);
    l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
    for (var d = 0; d < f; d++) {
      var p = h(n, e, i, s, jL[d]);
      l[0] = Ai(p, l[0]), u[0] = ki(p, u[0]);
    }
    f = c(t, r, a, o, KL);
    for (var d = 0; d < f; d++) {
      var g = h(t, r, a, o, KL[d]);
      l[1] = Ai(g, l[1]), u[1] = ki(g, u[1]);
    }
    l[0] = Ai(n, l[0]), u[0] = ki(n, u[0]), l[0] = Ai(s, l[0]), u[0] = ki(s, u[0]), l[1] = Ai(t, l[1]), u[1] = ki(t, u[1]), l[1] = Ai(o, l[1]), u[1] = ki(o, u[1]);
  }
  function brt(n, t, e, r, i, a, s, o) {
    var l = FW, u = pr, c = ki(Ai(l(n, e, i), 1), 0), h = ki(Ai(l(t, r, a), 1), 0), f = u(n, e, i, c), d = u(t, r, a, h);
    s[0] = Ai(n, i, f), s[1] = Ai(t, a, d), o[0] = ki(n, i, f), o[1] = ki(t, a, d);
  }
  function _rt(n, t, e, r, i, a, s, o, l) {
    var u = Cl, c = Tl, h = Math.abs(i - a);
    if (h % Du < 1e-4 && h > 1e-4) {
      o[0] = n - e, o[1] = t - r, l[0] = n + e, l[1] = t + r;
      return;
    }
    if (Dy[0] = dS(i) * e + n, Dy[1] = fS(i) * r + t, Ey[0] = dS(a) * e + n, Ey[1] = fS(a) * r + t, u(o, Dy, Ey), c(l, Dy, Ey), i = i % Du, i < 0 && (i = i + Du), a = a % Du, a < 0 && (a = a + Du), i > a && !s ? a += Du : i < a && s && (i += Du), s) {
      var f = a;
      a = i, i = f;
    }
    for (var d = 0; d < a; d += Math.PI / 2) d > i && (My[0] = dS(d) * e + n, My[1] = fS(d) * r + t, u(o, My, o), c(l, My, l));
  }
  var Ke = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  }, Eu = [], Mu = [], xs = [], sl = [], bs = [], _s = [], pS = Math.min, gS = Math.max, Ru = Math.cos, Nu = Math.sin, go = Math.abs, HI = Math.PI, ml = HI * 2, vS = typeof Float32Array < "u", rp = [];
  function mS(n) {
    var t = Math.round(n / HI * 1e8) / 1e8;
    return t % 2 * HI;
  }
  function Yk(n, t) {
    var e = mS(n[0]);
    e < 0 && (e += ml);
    var r = e - n[0], i = n[1];
    i += r, !t && i - e >= ml ? i = e + ml : t && e - i >= ml ? i = e - ml : !t && e > i ? i = e + (ml - mS(e - i)) : t && e < i && (i = e - (ml - mS(i - e))), n[0] = e, n[1] = i;
  }
  var ro = function() {
    function n(t) {
      this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = false), this._saveData && (this.data = []);
    }
    return n.prototype.increaseVersion = function() {
      this._version++;
    }, n.prototype.getVersion = function() {
      return this._version;
    }, n.prototype.setScale = function(t, e, r) {
      r = r || 0, r > 0 && (this._ux = go(r / Gx / t) || 0, this._uy = go(r / Gx / e) || 0);
    }, n.prototype.setDPR = function(t) {
      this.dpr = t;
    }, n.prototype.setContext = function(t) {
      this._ctx = t;
    }, n.prototype.getContext = function() {
      return this._ctx;
    }, n.prototype.beginPath = function() {
      return this._ctx && this._ctx.beginPath(), this.reset(), this;
    }, n.prototype.reset = function() {
      this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
    }, n.prototype.moveTo = function(t, e) {
      return this._drawPendingPt(), this.addData(Ke.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this;
    }, n.prototype.lineTo = function(t, e) {
      var r = go(t - this._xi), i = go(e - this._yi), a = r > this._ux || i > this._uy;
      if (this.addData(Ke.L, t, e), this._ctx && a && this._ctx.lineTo(t, e), a) this._xi = t, this._yi = e, this._pendingPtDist = 0;
      else {
        var s = r * r + i * i;
        s > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = e, this._pendingPtDist = s);
      }
      return this;
    }, n.prototype.bezierCurveTo = function(t, e, r, i, a, s) {
      return this._drawPendingPt(), this.addData(Ke.C, t, e, r, i, a, s), this._ctx && this._ctx.bezierCurveTo(t, e, r, i, a, s), this._xi = a, this._yi = s, this;
    }, n.prototype.quadraticCurveTo = function(t, e, r, i) {
      return this._drawPendingPt(), this.addData(Ke.Q, t, e, r, i), this._ctx && this._ctx.quadraticCurveTo(t, e, r, i), this._xi = r, this._yi = i, this;
    }, n.prototype.arc = function(t, e, r, i, a, s) {
      this._drawPendingPt(), rp[0] = i, rp[1] = a, Yk(rp, s), i = rp[0], a = rp[1];
      var o = a - i;
      return this.addData(Ke.A, t, e, r, r, i, o, 0, s ? 0 : 1), this._ctx && this._ctx.arc(t, e, r, i, a, s), this._xi = Ru(a) * r + t, this._yi = Nu(a) * r + e, this;
    }, n.prototype.arcTo = function(t, e, r, i, a) {
      return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, e, r, i, a), this;
    }, n.prototype.rect = function(t, e, r, i) {
      return this._drawPendingPt(), this._ctx && this._ctx.rect(t, e, r, i), this.addData(Ke.R, t, e, r, i), this;
    }, n.prototype.closePath = function() {
      this._drawPendingPt(), this.addData(Ke.Z);
      var t = this._ctx, e = this._x0, r = this._y0;
      return t && t.closePath(), this._xi = e, this._yi = r, this;
    }, n.prototype.fill = function(t) {
      t && t.fill(), this.toStatic();
    }, n.prototype.stroke = function(t) {
      t && t.stroke(), this.toStatic();
    }, n.prototype.len = function() {
      return this._len;
    }, n.prototype.setData = function(t) {
      var e = t.length;
      !(this.data && this.data.length === e) && vS && (this.data = new Float32Array(e));
      for (var r = 0; r < e; r++) this.data[r] = t[r];
      this._len = e;
    }, n.prototype.appendPath = function(t) {
      t instanceof Array || (t = [
        t
      ]);
      for (var e = t.length, r = 0, i = this._len, a = 0; a < e; a++) r += t[a].len();
      vS && this.data instanceof Float32Array && (this.data = new Float32Array(i + r));
      for (var a = 0; a < e; a++) for (var s = t[a].data, o = 0; o < s.length; o++) this.data[i++] = s[o];
      this._len = i;
    }, n.prototype.addData = function(t, e, r, i, a, s, o, l, u) {
      if (this._saveData) {
        var c = this.data;
        this._len + arguments.length > c.length && (this._expandData(), c = this.data);
        for (var h = 0; h < arguments.length; h++) c[this._len++] = arguments[h];
      }
    }, n.prototype._drawPendingPt = function() {
      this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
    }, n.prototype._expandData = function() {
      if (!(this.data instanceof Array)) {
        for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
        this.data = t;
      }
    }, n.prototype.toStatic = function() {
      if (this._saveData) {
        this._drawPendingPt();
        var t = this.data;
        t instanceof Array && (t.length = this._len, vS && this._len > 11 && (this.data = new Float32Array(t)));
      }
    }, n.prototype.getBoundingRect = function() {
      xs[0] = xs[1] = bs[0] = bs[1] = Number.MAX_VALUE, sl[0] = sl[1] = _s[0] = _s[1] = -Number.MAX_VALUE;
      var t = this.data, e = 0, r = 0, i = 0, a = 0, s;
      for (s = 0; s < this._len; ) {
        var o = t[s++], l = s === 1;
        switch (l && (e = t[s], r = t[s + 1], i = e, a = r), o) {
          case Ke.M:
            e = i = t[s++], r = a = t[s++], bs[0] = i, bs[1] = a, _s[0] = i, _s[1] = a;
            break;
          case Ke.L:
            qL(e, r, t[s], t[s + 1], bs, _s), e = t[s++], r = t[s++];
            break;
          case Ke.C:
            xrt(e, r, t[s++], t[s++], t[s++], t[s++], t[s], t[s + 1], bs, _s), e = t[s++], r = t[s++];
            break;
          case Ke.Q:
            brt(e, r, t[s++], t[s++], t[s], t[s + 1], bs, _s), e = t[s++], r = t[s++];
            break;
          case Ke.A:
            var u = t[s++], c = t[s++], h = t[s++], f = t[s++], d = t[s++], p = t[s++] + d;
            s += 1;
            var g = !t[s++];
            l && (i = Ru(d) * h + u, a = Nu(d) * f + c), _rt(u, c, h, f, d, p, g, bs, _s), e = Ru(p) * h + u, r = Nu(p) * f + c;
            break;
          case Ke.R:
            i = e = t[s++], a = r = t[s++];
            var v = t[s++], m = t[s++];
            qL(i, a, i + v, a + m, bs, _s);
            break;
          case Ke.Z:
            e = i, r = a;
            break;
        }
        Cl(xs, xs, bs), Tl(sl, sl, _s);
      }
      return s === 0 && (xs[0] = xs[1] = sl[0] = sl[1] = 0), new te(xs[0], xs[1], sl[0] - xs[0], sl[1] - xs[1]);
    }, n.prototype._calculateLength = function() {
      var t = this.data, e = this._len, r = this._ux, i = this._uy, a = 0, s = 0, o = 0, l = 0;
      this._pathSegLen || (this._pathSegLen = []);
      for (var u = this._pathSegLen, c = 0, h = 0, f = 0; f < e; ) {
        var d = t[f++], p = f === 1;
        p && (a = t[f], s = t[f + 1], o = a, l = s);
        var g = -1;
        switch (d) {
          case Ke.M:
            a = o = t[f++], s = l = t[f++];
            break;
          case Ke.L: {
            var v = t[f++], m = t[f++], y = v - a, x = m - s;
            (go(y) > r || go(x) > i || f === e - 1) && (g = Math.sqrt(y * y + x * x), a = v, s = m);
            break;
          }
          case Ke.C: {
            var b = t[f++], _ = t[f++], v = t[f++], m = t[f++], w = t[f++], S = t[f++];
            g = Fet(a, s, b, _, v, m, w, S, 10), a = w, s = S;
            break;
          }
          case Ke.Q: {
            var b = t[f++], _ = t[f++], v = t[f++], m = t[f++];
            g = zet(a, s, b, _, v, m, 10), a = v, s = m;
            break;
          }
          case Ke.A:
            var I = t[f++], T = t[f++], A = t[f++], C = t[f++], D = t[f++], E = t[f++], M = E + D;
            f += 1, p && (o = Ru(D) * A + I, l = Nu(D) * C + T), g = gS(A, C) * pS(ml, Math.abs(E)), a = Ru(M) * A + I, s = Nu(M) * C + T;
            break;
          case Ke.R: {
            o = a = t[f++], l = s = t[f++];
            var L = t[f++], k = t[f++];
            g = L * 2 + k * 2;
            break;
          }
          case Ke.Z: {
            var y = o - a, x = l - s;
            g = Math.sqrt(y * y + x * x), a = o, s = l;
            break;
          }
        }
        g >= 0 && (u[h++] = g, c += g);
      }
      return this._pathLen = c, c;
    }, n.prototype.rebuildPath = function(t, e) {
      var r = this.data, i = this._ux, a = this._uy, s = this._len, o, l, u, c, h, f, d = e < 1, p, g, v = 0, m = 0, y, x = 0, b, _;
      if (!(d && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, y = e * g, !y))) t: for (var w = 0; w < s; ) {
        var S = r[w++], I = w === 1;
        switch (I && (u = r[w], c = r[w + 1], o = u, l = c), S !== Ke.L && x > 0 && (t.lineTo(b, _), x = 0), S) {
          case Ke.M:
            o = u = r[w++], l = c = r[w++], t.moveTo(u, c);
            break;
          case Ke.L: {
            h = r[w++], f = r[w++];
            var T = go(h - u), A = go(f - c);
            if (T > i || A > a) {
              if (d) {
                var C = p[m++];
                if (v + C > y) {
                  var D = (y - v) / C;
                  t.lineTo(u * (1 - D) + h * D, c * (1 - D) + f * D);
                  break t;
                }
                v += C;
              }
              t.lineTo(h, f), u = h, c = f, x = 0;
            } else {
              var E = T * T + A * A;
              E > x && (b = h, _ = f, x = E);
            }
            break;
          }
          case Ke.C: {
            var M = r[w++], L = r[w++], k = r[w++], N = r[w++], R = r[w++], $ = r[w++];
            if (d) {
              var C = p[m++];
              if (v + C > y) {
                var D = (y - v) / C;
                Yl(u, M, k, R, D, Eu), Yl(c, L, N, $, D, Mu), t.bezierCurveTo(Eu[1], Mu[1], Eu[2], Mu[2], Eu[3], Mu[3]);
                break t;
              }
              v += C;
            }
            t.bezierCurveTo(M, L, k, N, R, $), u = R, c = $;
            break;
          }
          case Ke.Q: {
            var M = r[w++], L = r[w++], k = r[w++], N = r[w++];
            if (d) {
              var C = p[m++];
              if (v + C > y) {
                var D = (y - v) / C;
                Rg(u, M, k, D, Eu), Rg(c, L, N, D, Mu), t.quadraticCurveTo(Eu[1], Mu[1], Eu[2], Mu[2]);
                break t;
              }
              v += C;
            }
            t.quadraticCurveTo(M, L, k, N), u = k, c = N;
            break;
          }
          case Ke.A:
            var O = r[w++], F = r[w++], z = r[w++], V = r[w++], U = r[w++], X = r[w++], at = r[w++], pt = !r[w++], it = z > V ? z : V, et = go(z - V) > 1e-3, ft = U + X, ut = false;
            if (d) {
              var C = p[m++];
              v + C > y && (ft = U + X * (y - v) / C, ut = true), v += C;
            }
            if (et && t.ellipse ? t.ellipse(O, F, z, V, at, U, ft, pt) : t.arc(O, F, it, U, ft, pt), ut) break t;
            I && (o = Ru(U) * z + O, l = Nu(U) * V + F), u = Ru(ft) * z + O, c = Nu(ft) * V + F;
            break;
          case Ke.R:
            o = u = r[w], l = c = r[w + 1], h = r[w++], f = r[w++];
            var gt = r[w++], kt = r[w++];
            if (d) {
              var C = p[m++];
              if (v + C > y) {
                var At = y - v;
                t.moveTo(h, f), t.lineTo(h + pS(At, gt), f), At -= gt, At > 0 && t.lineTo(h + gt, f + pS(At, kt)), At -= kt, At > 0 && t.lineTo(h + gS(gt - At, 0), f + kt), At -= gt, At > 0 && t.lineTo(h, f + gS(kt - At, 0));
                break t;
              }
              v += C;
            }
            t.rect(h, f, gt, kt);
            break;
          case Ke.Z:
            if (d) {
              var C = p[m++];
              if (v + C > y) {
                var D = (y - v) / C;
                t.lineTo(u * (1 - D) + o * D, c * (1 - D) + l * D);
                break t;
              }
              v += C;
            }
            t.closePath(), u = o, c = l;
        }
      }
    }, n.prototype.clone = function() {
      var t = new n(), e = this.data;
      return t.data = e.slice ? e.slice() : Array.prototype.slice.call(e), t._len = this._len, t;
    }, n.CMD = Ke, n.initDefaultProps = function() {
      var t = n.prototype;
      t._saveData = true, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
    }(), n;
  }();
  function bl(n, t, e, r, i, a, s) {
    if (i === 0) return false;
    var o = i, l = 0, u = n;
    if (s > t + o && s > r + o || s < t - o && s < r - o || a > n + o && a > e + o || a < n - o && a < e - o) return false;
    if (n !== e) l = (t - r) / (n - e), u = (n * r - e * t) / (n - e);
    else return Math.abs(a - n) <= o / 2;
    var c = l * a - s + u, h = c * c / (l * l + 1);
    return h <= o / 2 * o / 2;
  }
  function wrt(n, t, e, r, i, a, s, o, l, u, c) {
    if (l === 0) return false;
    var h = l;
    if (c > t + h && c > r + h && c > a + h && c > o + h || c < t - h && c < r - h && c < a - h && c < o - h || u > n + h && u > e + h && u > i + h && u > s + h || u < n - h && u < e - h && u < i - h && u < s - h) return false;
    var f = OW(n, t, e, r, i, a, s, o, u, c, null);
    return f <= h / 2;
  }
  function yU(n, t, e, r, i, a, s, o, l) {
    if (s === 0) return false;
    var u = s;
    if (l > t + u && l > r + u && l > a + u || l < t - u && l < r - u && l < a - u || o > n + u && o > e + u && o > i + u || o < n - u && o < e - u && o < i - u) return false;
    var c = BW(n, t, e, r, i, a, o, l, null);
    return c <= u / 2;
  }
  var ZL = Math.PI * 2;
  function Ui(n) {
    return n %= ZL, n < 0 && (n += ZL), n;
  }
  var ip = Math.PI * 2;
  function Srt(n, t, e, r, i, a, s, o, l) {
    if (s === 0) return false;
    var u = s;
    o -= n, l -= t;
    var c = Math.sqrt(o * o + l * l);
    if (c - u > e || c + u < e) return false;
    if (Math.abs(r - i) % ip < 1e-4) return true;
    if (a) {
      var h = r;
      r = Ui(i), i = Ui(h);
    } else r = Ui(r), i = Ui(i);
    r > i && (i += ip);
    var f = Math.atan2(l, o);
    return f < 0 && (f += ip), f >= r && f <= i || f + ip >= r && f + ip <= i;
  }
  function wo(n, t, e, r, i, a) {
    if (a > t && a > r || a < t && a < r || r === t) return 0;
    var s = (a - t) / (r - t), o = r < t ? 1 : -1;
    (s === 1 || s === 0) && (o = r < t ? 0.5 : -0.5);
    var l = s * (e - n) + n;
    return l === i ? 1 / 0 : l > i ? o : 0;
  }
  var ol = ro.CMD, Lu = Math.PI * 2, Crt = 1e-4;
  function Trt(n, t) {
    return Math.abs(n - t) < Crt;
  }
  var ii = [
    -1,
    -1,
    -1
  ], da = [
    -1,
    -1
  ];
  function Irt() {
    var n = da[0];
    da[0] = da[1], da[1] = n;
  }
  function Art(n, t, e, r, i, a, s, o, l, u) {
    if (u > t && u > r && u > a && u > o || u < t && u < r && u < a && u < o) return 0;
    var c = Fx(t, r, a, o, u, ii);
    if (c === 0) return 0;
    for (var h = 0, f = -1, d = void 0, p = void 0, g = 0; g < c; g++) {
      var v = ii[g], m = v === 0 || v === 1 ? 0.5 : 1, y = tr(n, e, i, s, v);
      y < l || (f < 0 && (f = $W(t, r, a, o, da), da[1] < da[0] && f > 1 && Irt(), d = tr(t, r, a, o, da[0]), f > 1 && (p = tr(t, r, a, o, da[1]))), f === 2 ? v < da[0] ? h += d < t ? m : -m : v < da[1] ? h += p < d ? m : -m : h += o < p ? m : -m : v < da[0] ? h += d < t ? m : -m : h += o < d ? m : -m);
    }
    return h;
  }
  function krt(n, t, e, r, i, a, s, o) {
    if (o > t && o > r && o > a || o < t && o < r && o < a) return 0;
    var l = Bet(t, r, a, o, ii);
    if (l === 0) return 0;
    var u = FW(t, r, a);
    if (u >= 0 && u <= 1) {
      for (var c = 0, h = pr(t, r, a, u), f = 0; f < l; f++) {
        var d = ii[f] === 0 || ii[f] === 1 ? 0.5 : 1, p = pr(n, e, i, ii[f]);
        p < s || (ii[f] < u ? c += h < t ? d : -d : c += a < h ? d : -d);
      }
      return c;
    } else {
      var d = ii[0] === 0 || ii[0] === 1 ? 0.5 : 1, p = pr(n, e, i, ii[0]);
      return p < s ? 0 : a < t ? d : -d;
    }
  }
  function Drt(n, t, e, r, i, a, s, o) {
    if (o -= t, o > e || o < -e) return 0;
    var l = Math.sqrt(e * e - o * o);
    ii[0] = -l, ii[1] = l;
    var u = Math.abs(r - i);
    if (u < 1e-4) return 0;
    if (u >= Lu - 1e-4) {
      r = 0, i = Lu;
      var c = a ? 1 : -1;
      return s >= ii[0] + n && s <= ii[1] + n ? c : 0;
    }
    if (r > i) {
      var h = r;
      r = i, i = h;
    }
    r < 0 && (r += Lu, i += Lu);
    for (var f = 0, d = 0; d < 2; d++) {
      var p = ii[d];
      if (p + n > s) {
        var g = Math.atan2(o, p), c = a ? 1 : -1;
        g < 0 && (g = Lu + g), (g >= r && g <= i || g + Lu >= r && g + Lu <= i) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), f += c);
      }
    }
    return f;
  }
  function xU(n, t, e, r, i) {
    for (var a = n.data, s = n.len(), o = 0, l = 0, u = 0, c = 0, h = 0, f, d, p = 0; p < s; ) {
      var g = a[p++], v = p === 1;
      switch (g === ol.M && p > 1 && (e || (o += wo(l, u, c, h, r, i))), v && (l = a[p], u = a[p + 1], c = l, h = u), g) {
        case ol.M:
          c = a[p++], h = a[p++], l = c, u = h;
          break;
        case ol.L:
          if (e) {
            if (bl(l, u, a[p], a[p + 1], t, r, i)) return true;
          } else o += wo(l, u, a[p], a[p + 1], r, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case ol.C:
          if (e) {
            if (wrt(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], t, r, i)) return true;
          } else o += Art(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], r, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case ol.Q:
          if (e) {
            if (yU(l, u, a[p++], a[p++], a[p], a[p + 1], t, r, i)) return true;
          } else o += krt(l, u, a[p++], a[p++], a[p], a[p + 1], r, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case ol.A:
          var m = a[p++], y = a[p++], x = a[p++], b = a[p++], _ = a[p++], w = a[p++];
          p += 1;
          var S = !!(1 - a[p++]);
          f = Math.cos(_) * x + m, d = Math.sin(_) * b + y, v ? (c = f, h = d) : o += wo(l, u, f, d, r, i);
          var I = (r - m) * b / x + m;
          if (e) {
            if (Srt(m, y, b, _, _ + w, S, t, I, i)) return true;
          } else o += Drt(m, y, b, _, _ + w, S, I, i);
          l = Math.cos(_ + w) * x + m, u = Math.sin(_ + w) * b + y;
          break;
        case ol.R:
          c = l = a[p++], h = u = a[p++];
          var T = a[p++], A = a[p++];
          if (f = c + T, d = h + A, e) {
            if (bl(c, h, f, h, t, r, i) || bl(f, h, f, d, t, r, i) || bl(f, d, c, d, t, r, i) || bl(c, d, c, h, t, r, i)) return true;
          } else o += wo(f, h, f, d, r, i), o += wo(c, d, c, h, r, i);
          break;
        case ol.Z:
          if (e) {
            if (bl(l, u, c, h, t, r, i)) return true;
          } else o += wo(l, u, c, h, r, i);
          l = c, u = h;
          break;
      }
    }
    return !e && !Trt(u, h) && (o += wo(l, u, c, h, r, i) || 0), o !== 0;
  }
  function Ert(n, t, e) {
    return xU(n, 0, false, t, e);
  }
  function Mrt(n, t, e, r) {
    return xU(n, t, true, e, r);
  }
  var Ux = $t({
    fill: "#000",
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
  }, Mc), Rrt = {
    style: $t({
      fill: true,
      stroke: true,
      strokePercent: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineDashOffset: true,
      lineWidth: true,
      miterLimit: true
    }, S1.style)
  }, yS = eo.concat([
    "invisible",
    "culling",
    "z",
    "z2",
    "zlevel",
    "parent"
  ]), le = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.update = function() {
      var e = this;
      n.prototype.update.call(this);
      var r = this.style;
      if (r.decal) {
        var i = this._decalEl = this._decalEl || new t();
        i.buildPath === t.prototype.buildPath && (i.buildPath = function(l) {
          e.buildPath(l, e.shape);
        }), i.silent = true;
        var a = i.style;
        for (var s in r) a[s] !== r[s] && (a[s] = r[s]);
        a.fill = r.fill ? r.decal : null, a.decal = null, a.shadowColor = null, r.strokeFirst && (a.stroke = null);
        for (var o = 0; o < yS.length; ++o) i[yS[o]] = this[yS[o]];
        i.__dirty |= Us;
      } else this._decalEl && (this._decalEl = null);
    }, t.prototype.getDecalElement = function() {
      return this._decalEl;
    }, t.prototype._init = function(e) {
      var r = ge(e);
      this.shape = this.getDefaultShape();
      var i = this.getDefaultStyle();
      i && this.useStyle(i);
      for (var a = 0; a < r.length; a++) {
        var s = r[a], o = e[s];
        s === "style" ? this.style ? rt(this.style, o) : this.useStyle(o) : s === "shape" ? rt(this.shape, o) : n.prototype.attrKV.call(this, s, o);
      }
      this.style || this.useStyle({});
    }, t.prototype.getDefaultStyle = function() {
      return null;
    }, t.prototype.getDefaultShape = function() {
      return {};
    }, t.prototype.canBeInsideText = function() {
      return this.hasFill();
    }, t.prototype.getInsideTextFill = function() {
      var e = this.style.fill;
      if (e !== "none") {
        if (wt(e)) {
          var r = zx(e, 0);
          return r > 0.5 ? BI : r > 0.2 ? pnt : zI;
        } else if (e) return zI;
      }
      return BI;
    }, t.prototype.getInsideTextStroke = function(e) {
      var r = this.style.fill;
      if (wt(r)) {
        var i = this.__zr, a = !!(i && i.isDarkMode()), s = zx(e, 0) < FI;
        if (a === s) return r;
      }
    }, t.prototype.buildPath = function(e, r, i) {
    }, t.prototype.pathUpdated = function() {
      this.__dirty &= -5;
    }, t.prototype.getUpdatedPathProxy = function(e) {
      return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, e), this.path;
    }, t.prototype.createPathProxy = function() {
      this.path = new ro(false);
    }, t.prototype.hasStroke = function() {
      var e = this.style, r = e.stroke;
      return !(r == null || r === "none" || !(e.lineWidth > 0));
    }, t.prototype.hasFill = function() {
      var e = this.style, r = e.fill;
      return r != null && r !== "none";
    }, t.prototype.getBoundingRect = function() {
      var e = this._rect, r = this.style, i = !e;
      if (i) {
        var a = false;
        this.path || (a = true, this.createPathProxy());
        var s = this.path;
        (a || this.__dirty & Op) && (s.beginPath(), this.buildPath(s, this.shape, false), this.pathUpdated()), e = s.getBoundingRect();
      }
      if (this._rect = e, this.hasStroke() && this.path && this.path.len() > 0) {
        var o = this._rectStroke || (this._rectStroke = e.clone());
        if (this.__dirty || i) {
          o.copy(e);
          var l = r.strokeNoScale ? this.getLineScale() : 1, u = r.lineWidth;
          if (!this.hasFill()) {
            var c = this.strokeContainThreshold;
            u = Math.max(u, c ?? 4);
          }
          l > 1e-10 && (o.width += u / l, o.height += u / l, o.x -= u / l / 2, o.y -= u / l / 2);
        }
        return o;
      }
      return e;
    }, t.prototype.contain = function(e, r) {
      var i = this.transformCoordToLocal(e, r), a = this.getBoundingRect(), s = this.style;
      if (e = i[0], r = i[1], a.contain(e, r)) {
        var o = this.path;
        if (this.hasStroke()) {
          var l = s.lineWidth, u = s.strokeNoScale ? this.getLineScale() : 1;
          if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), Mrt(o, l / u, e, r))) return true;
        }
        if (this.hasFill()) return Ert(o, e, r);
      }
      return false;
    }, t.prototype.dirtyShape = function() {
      this.__dirty |= Op, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
    }, t.prototype.dirty = function() {
      this.dirtyStyle(), this.dirtyShape();
    }, t.prototype.animateShape = function(e) {
      return this.animate("shape", e);
    }, t.prototype.updateDuringAnimation = function(e) {
      e === "style" ? this.dirtyStyle() : e === "shape" ? this.dirtyShape() : this.markRedraw();
    }, t.prototype.attrKV = function(e, r) {
      e === "shape" ? this.setShape(r) : n.prototype.attrKV.call(this, e, r);
    }, t.prototype.setShape = function(e, r) {
      var i = this.shape;
      return i || (i = this.shape = {}), typeof e == "string" ? i[e] = r : rt(i, e), this.dirtyShape(), this;
    }, t.prototype.shapeChanged = function() {
      return !!(this.__dirty & Op);
    }, t.prototype.createStyle = function(e) {
      return v1(Ux, e);
    }, t.prototype._innerSaveToNormal = function(e) {
      n.prototype._innerSaveToNormal.call(this, e);
      var r = this._normalState;
      e.shape && !r.shape && (r.shape = rt({}, this.shape));
    }, t.prototype._applyStateObj = function(e, r, i, a, s, o) {
      n.prototype._applyStateObj.call(this, e, r, i, a, s, o);
      var l = !(r && a), u;
      if (r && r.shape ? s ? a ? u = r.shape : (u = rt({}, i.shape), rt(u, r.shape)) : (u = rt({}, a ? this.shape : i.shape), rt(u, r.shape)) : l && (u = i.shape), u) if (s) {
        this.shape = rt({}, this.shape);
        for (var c = {}, h = ge(u), f = 0; f < h.length; f++) {
          var d = h[f];
          typeof u[d] == "object" ? this.shape[d] = u[d] : c[d] = u[d];
        }
        this._transitionState(e, {
          shape: c
        }, o);
      } else this.shape = u, this.dirtyShape();
    }, t.prototype._mergeStates = function(e) {
      for (var r = n.prototype._mergeStates.call(this, e), i, a = 0; a < e.length; a++) {
        var s = e[a];
        s.shape && (i = i || {}, this._mergeStyle(i, s.shape));
      }
      return i && (r.shape = i), r;
    }, t.prototype.getAnimationStyleProps = function() {
      return Rrt;
    }, t.prototype.isZeroArea = function() {
      return false;
    }, t.extend = function(e) {
      var r = function(a) {
        q(s, a);
        function s(o) {
          var l = a.call(this, o) || this;
          return e.init && e.init.call(l, o), l;
        }
        return s.prototype.getDefaultStyle = function() {
          return Bt(e.style);
        }, s.prototype.getDefaultShape = function() {
          return Bt(e.shape);
        }, s;
      }(t);
      for (var i in e) typeof e[i] == "function" && (r.prototype[i] = e[i]);
      return r;
    }, t.initDefaultProps = function() {
      var e = t.prototype;
      e.type = "path", e.strokeContainThreshold = 5, e.segmentIgnoreThreshold = 0, e.subPixelOptimize = false, e.autoBatch = false, e.__dirty = Us | ix | Op;
    }(), t;
  }(Ia), Nrt = $t({
    strokeFirst: true,
    font: Hl,
    x: 0,
    y: 0,
    textAlign: "left",
    textBaseline: "top",
    miterLimit: 2
  }, Ux), Vf = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.hasStroke = function() {
      var e = this.style, r = e.stroke;
      return r != null && r !== "none" && e.lineWidth > 0;
    }, t.prototype.hasFill = function() {
      var e = this.style, r = e.fill;
      return r != null && r !== "none";
    }, t.prototype.createStyle = function(e) {
      return v1(Nrt, e);
    }, t.prototype.setBoundingRect = function(e) {
      this._rect = e;
    }, t.prototype.getBoundingRect = function() {
      var e = this.style;
      if (!this._rect) {
        var r = e.text;
        r != null ? r += "" : r = "";
        var i = Mv(r, e.font, e.textAlign, e.textBaseline);
        if (i.x += e.x || 0, i.y += e.y || 0, this.hasStroke()) {
          var a = e.lineWidth;
          i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a;
        }
        this._rect = i;
      }
      return this._rect;
    }, t.initDefaultProps = function() {
      var e = t.prototype;
      e.dirtyRectTolerance = 10;
    }(), t;
  }(Ia);
  Vf.prototype.type = "tspan";
  var Lrt = $t({
    x: 0,
    y: 0
  }, Mc), Prt = {
    style: $t({
      x: true,
      y: true,
      width: true,
      height: true,
      sx: true,
      sy: true,
      sWidth: true,
      sHeight: true
    }, S1.style)
  };
  function $rt(n) {
    return !!(n && typeof n != "string" && n.width && n.height);
  }
  var br = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.createStyle = function(e) {
      return v1(Lrt, e);
    }, t.prototype._getSize = function(e) {
      var r = this.style, i = r[e];
      if (i != null) return i;
      var a = $rt(r.image) ? r.image : this.__image;
      if (!a) return 0;
      var s = e === "width" ? "height" : "width", o = r[s];
      return o == null ? a[e] : a[e] / a[s] * o;
    }, t.prototype.getWidth = function() {
      return this._getSize("width");
    }, t.prototype.getHeight = function() {
      return this._getSize("height");
    }, t.prototype.getAnimationStyleProps = function() {
      return Prt;
    }, t.prototype.getBoundingRect = function() {
      var e = this.style;
      return this._rect || (this._rect = new te(e.x || 0, e.y || 0, this.getWidth(), this.getHeight())), this._rect;
    }, t;
  }(Ia);
  br.prototype.type = "image";
  function Ort(n, t) {
    var e = t.x, r = t.y, i = t.width, a = t.height, s = t.r, o, l, u, c;
    i < 0 && (e = e + i, i = -i), a < 0 && (r = r + a, a = -a), typeof s == "number" ? o = l = u = c = s : s instanceof Array ? s.length === 1 ? o = l = u = c = s[0] : s.length === 2 ? (o = u = s[0], l = c = s[1]) : s.length === 3 ? (o = s[0], l = c = s[1], u = s[2]) : (o = s[0], l = s[1], u = s[2], c = s[3]) : o = l = u = c = 0;
    var h;
    o + l > i && (h = o + l, o *= i / h, l *= i / h), u + c > i && (h = u + c, u *= i / h, c *= i / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), o + c > a && (h = o + c, o *= a / h, c *= a / h), n.moveTo(e + o, r), n.lineTo(e + i - l, r), l !== 0 && n.arc(e + i - l, r + l, l, -Math.PI / 2, 0), n.lineTo(e + i, r + a - u), u !== 0 && n.arc(e + i - u, r + a - u, u, 0, Math.PI / 2), n.lineTo(e + c, r + a), c !== 0 && n.arc(e + c, r + a - c, c, Math.PI / 2, Math.PI), n.lineTo(e, r + o), o !== 0 && n.arc(e + o, r + o, o, Math.PI, Math.PI * 1.5);
  }
  var Sf = Math.round;
  function bU(n, t, e) {
    if (t) {
      var r = t.x1, i = t.x2, a = t.y1, s = t.y2;
      n.x1 = r, n.x2 = i, n.y1 = a, n.y2 = s;
      var o = e && e.lineWidth;
      return o && (Sf(r * 2) === Sf(i * 2) && (n.x1 = n.x2 = mc(r, o, true)), Sf(a * 2) === Sf(s * 2) && (n.y1 = n.y2 = mc(a, o, true))), n;
    }
  }
  function _U(n, t, e) {
    if (t) {
      var r = t.x, i = t.y, a = t.width, s = t.height;
      n.x = r, n.y = i, n.width = a, n.height = s;
      var o = e && e.lineWidth;
      return o && (n.x = mc(r, o, true), n.y = mc(i, o, true), n.width = Math.max(mc(r + a, o, false) - n.x, a === 0 ? 0 : 1), n.height = Math.max(mc(i + s, o, false) - n.y, s === 0 ? 0 : 1)), n;
    }
  }
  function mc(n, t, e) {
    if (!t) return n;
    var r = Sf(n * 2);
    return (r + Sf(t)) % 2 === 0 ? r / 2 : (r + (e ? 1 : -1)) / 2;
  }
  var Frt = /* @__PURE__ */ function() {
    function n() {
      this.x = 0, this.y = 0, this.width = 0, this.height = 0;
    }
    return n;
  }(), Brt = {}, ye = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new Frt();
    }, t.prototype.buildPath = function(e, r) {
      var i, a, s, o;
      if (this.subPixelOptimize) {
        var l = _U(Brt, r, this.style);
        i = l.x, a = l.y, s = l.width, o = l.height, l.r = r.r, r = l;
      } else i = r.x, a = r.y, s = r.width, o = r.height;
      r.r ? Ort(e, r) : e.rect(i, a, s, o);
    }, t.prototype.isZeroArea = function() {
      return !this.shape.width || !this.shape.height;
    }, t;
  }(le);
  ye.prototype.type = "rect";
  var JL = {
    fill: "#000"
  }, QL = 2, zrt = {
    style: $t({
      fill: true,
      stroke: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineWidth: true,
      fontSize: true,
      lineHeight: true,
      width: true,
      height: true,
      textShadowColor: true,
      textShadowBlur: true,
      textShadowOffsetX: true,
      textShadowOffsetY: true,
      backgroundColor: true,
      padding: true,
      borderColor: true,
      borderWidth: true,
      borderRadius: true
    }, S1.style)
  }, be = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this) || this;
      return r.type = "text", r._children = [], r._defaultStyle = JL, r.attr(e), r;
    }
    return t.prototype.childrenRef = function() {
      return this._children;
    }, t.prototype.update = function() {
      n.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
      for (var e = 0; e < this._children.length; e++) {
        var r = this._children[e];
        r.zlevel = this.zlevel, r.z = this.z, r.z2 = this.z2, r.culling = this.culling, r.cursor = this.cursor, r.invisible = this.invisible;
      }
    }, t.prototype.updateTransform = function() {
      var e = this.innerTransformable;
      e ? (e.updateTransform(), e.transform && (this.transform = e.transform)) : n.prototype.updateTransform.call(this);
    }, t.prototype.getLocalTransform = function(e) {
      var r = this.innerTransformable;
      return r ? r.getLocalTransform(e) : n.prototype.getLocalTransform.call(this, e);
    }, t.prototype.getComputedTransform = function() {
      return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(true)), n.prototype.getComputedTransform.call(this);
    }, t.prototype._updateSubTexts = function() {
      this._childCursor = 0, Wrt(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
    }, t.prototype.addSelfToZr = function(e) {
      n.prototype.addSelfToZr.call(this, e);
      for (var r = 0; r < this._children.length; r++) this._children[r].__zr = e;
    }, t.prototype.removeSelfFromZr = function(e) {
      n.prototype.removeSelfFromZr.call(this, e);
      for (var r = 0; r < this._children.length; r++) this._children[r].__zr = null;
    }, t.prototype.getBoundingRect = function() {
      if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
        for (var e = new te(0, 0, 0, 0), r = this._children, i = [], a = null, s = 0; s < r.length; s++) {
          var o = r[s], l = o.getBoundingRect(), u = o.getLocalTransform(i);
          u ? (e.copy(l), e.applyTransform(u), a = a || e.clone(), a.union(e)) : (a = a || l.clone(), a.union(l));
        }
        this._rect = a || e;
      }
      return this._rect;
    }, t.prototype.setDefaultTextStyle = function(e) {
      this._defaultStyle = e || JL;
    }, t.prototype.setTextContent = function(e) {
    }, t.prototype._mergeStyle = function(e, r) {
      if (!r) return e;
      var i = r.rich, a = e.rich || i && {};
      return rt(e, r), i && a ? (this._mergeRich(a, i), e.rich = a) : a && (e.rich = a), e;
    }, t.prototype._mergeRich = function(e, r) {
      for (var i = ge(r), a = 0; a < i.length; a++) {
        var s = i[a];
        e[s] = e[s] || {}, rt(e[s], r[s]);
      }
    }, t.prototype.getAnimationStyleProps = function() {
      return zrt;
    }, t.prototype._getOrCreateChild = function(e) {
      var r = this._children[this._childCursor];
      return (!r || !(r instanceof e)) && (r = new e()), this._children[this._childCursor++] = r, r.__zr = this.__zr, r.parent = this, r;
    }, t.prototype._updatePlainTexts = function() {
      var e = this.style, r = e.font || Hl, i = e.padding, a = sP(e), s = crt(a, e), o = xS(e), l = !!e.backgroundColor, u = s.outerHeight, c = s.outerWidth, h = s.contentWidth, f = s.lines, d = s.lineHeight, p = this._defaultStyle;
      this.isTruncated = !!s.isTruncated;
      var g = e.x || 0, v = e.y || 0, m = e.align || p.align || "left", y = e.verticalAlign || p.verticalAlign || "top", x = g, b = cf(v, s.contentHeight, y);
      if (o || i) {
        var _ = Bp(g, c, m), w = cf(v, u, y);
        o && this._renderBackground(e, e, _, w, c, u);
      }
      b += d / 2, i && (x = aP(g, m, i), y === "top" ? b += i[0] : y === "bottom" && (b -= i[2]));
      for (var S = 0, I = false, T = iP("fill" in e ? e.fill : (I = true, p.fill)), A = rP("stroke" in e ? e.stroke : !l && (!p.autoStroke || I) ? (S = QL, p.stroke) : null), C = e.textShadowBlur > 0, D = e.width != null && (e.overflow === "truncate" || e.overflow === "break" || e.overflow === "breakAll"), E = s.calculatedLineHeight, M = 0; M < f.length; M++) {
        var L = this._getOrCreateChild(Vf), k = L.createStyle();
        L.useStyle(k), k.text = f[M], k.x = x, k.y = b, k.textAlign = m, k.textBaseline = "middle", k.opacity = e.opacity, k.strokeFirst = true, C && (k.shadowBlur = e.textShadowBlur || 0, k.shadowColor = e.textShadowColor || "transparent", k.shadowOffsetX = e.textShadowOffsetX || 0, k.shadowOffsetY = e.textShadowOffsetY || 0), k.stroke = A, k.fill = T, A && (k.lineWidth = e.lineWidth || S, k.lineDash = e.lineDash, k.lineDashOffset = e.lineDashOffset || 0), k.font = r, eP(k, e), b += d, D && L.setBoundingRect(new te(Bp(k.x, h, k.textAlign), cf(k.y, E, k.textBaseline), h, E));
      }
    }, t.prototype._updateRichTexts = function() {
      var e = this.style, r = sP(e), i = drt(r, e), a = i.width, s = i.outerWidth, o = i.outerHeight, l = e.padding, u = e.x || 0, c = e.y || 0, h = this._defaultStyle, f = e.align || h.align, d = e.verticalAlign || h.verticalAlign;
      this.isTruncated = !!i.isTruncated;
      var p = Bp(u, s, f), g = cf(c, o, d), v = p, m = g;
      l && (v += l[3], m += l[0]);
      var y = v + a;
      xS(e) && this._renderBackground(e, e, p, g, s, o);
      for (var x = !!e.backgroundColor, b = 0; b < i.lines.length; b++) {
        for (var _ = i.lines[b], w = _.tokens, S = w.length, I = _.lineHeight, T = _.width, A = 0, C = v, D = y, E = S - 1, M = void 0; A < S && (M = w[A], !M.align || M.align === "left"); ) this._placeToken(M, e, I, m, C, "left", x), T -= M.width, C += M.width, A++;
        for (; E >= 0 && (M = w[E], M.align === "right"); ) this._placeToken(M, e, I, m, D, "right", x), T -= M.width, D -= M.width, E--;
        for (C += (a - (C - v) - (y - D) - T) / 2; A <= E; ) M = w[A], this._placeToken(M, e, I, m, C + M.width / 2, "center", x), C += M.width, A++;
        m += I;
      }
    }, t.prototype._placeToken = function(e, r, i, a, s, o, l) {
      var u = r.rich[e.styleName] || {};
      u.text = e.text;
      var c = e.verticalAlign, h = a + i / 2;
      c === "top" ? h = a + e.height / 2 : c === "bottom" && (h = a + i - e.height / 2);
      var f = !e.isLineHolder && xS(u);
      f && this._renderBackground(u, r, o === "right" ? s - e.width : o === "center" ? s - e.width / 2 : s, h - e.height / 2, e.width, e.height);
      var d = !!u.backgroundColor, p = e.textPadding;
      p && (s = aP(s, o, p), h -= e.height / 2 - p[0] - e.innerHeight / 2);
      var g = this._getOrCreateChild(Vf), v = g.createStyle();
      g.useStyle(v);
      var m = this._defaultStyle, y = false, x = 0, b = iP("fill" in u ? u.fill : "fill" in r ? r.fill : (y = true, m.fill)), _ = rP("stroke" in u ? u.stroke : "stroke" in r ? r.stroke : !d && !l && (!m.autoStroke || y) ? (x = QL, m.stroke) : null), w = u.textShadowBlur > 0 || r.textShadowBlur > 0;
      v.text = e.text, v.x = s, v.y = h, w && (v.shadowBlur = u.textShadowBlur || r.textShadowBlur || 0, v.shadowColor = u.textShadowColor || r.textShadowColor || "transparent", v.shadowOffsetX = u.textShadowOffsetX || r.textShadowOffsetX || 0, v.shadowOffsetY = u.textShadowOffsetY || r.textShadowOffsetY || 0), v.textAlign = o, v.textBaseline = "middle", v.font = e.font || Hl, v.opacity = Ws(u.opacity, r.opacity, 1), eP(v, u), _ && (v.lineWidth = Ws(u.lineWidth, r.lineWidth, x), v.lineDash = Ht(u.lineDash, r.lineDash), v.lineDashOffset = r.lineDashOffset || 0, v.stroke = _), b && (v.fill = b);
      var S = e.contentWidth, I = e.contentHeight;
      g.setBoundingRect(new te(Bp(v.x, S, v.textAlign), cf(v.y, I, v.textBaseline), S, I));
    }, t.prototype._renderBackground = function(e, r, i, a, s, o) {
      var l = e.backgroundColor, u = e.borderWidth, c = e.borderColor, h = l && l.image, f = l && !h, d = e.borderRadius, p = this, g, v;
      if (f || e.lineHeight || u && c) {
        g = this._getOrCreateChild(ye), g.useStyle(g.createStyle()), g.style.fill = null;
        var m = g.shape;
        m.x = i, m.y = a, m.width = s, m.height = o, m.r = d, g.dirtyShape();
      }
      if (f) {
        var y = g.style;
        y.fill = l || null, y.fillOpacity = Ht(e.fillOpacity, 1);
      } else if (h) {
        v = this._getOrCreateChild(br), v.onload = function() {
          p.dirtyStyle();
        };
        var x = v.style;
        x.image = l.image, x.x = i, x.y = a, x.width = s, x.height = o;
      }
      if (u && c) {
        var y = g.style;
        y.lineWidth = u, y.stroke = c, y.strokeOpacity = Ht(e.strokeOpacity, 1), y.lineDash = e.borderDash, y.lineDashOffset = e.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = true, y.lineWidth *= 2);
      }
      var b = (g || v).style;
      b.shadowBlur = e.shadowBlur || 0, b.shadowColor = e.shadowColor || "transparent", b.shadowOffsetX = e.shadowOffsetX || 0, b.shadowOffsetY = e.shadowOffsetY || 0, b.opacity = Ws(e.opacity, r.opacity, 1);
    }, t.makeFont = function(e) {
      var r = "";
      return SU(e) && (r = [
        e.fontStyle,
        e.fontWeight,
        wU(e.fontSize),
        e.fontFamily || "sans-serif"
      ].join(" ")), r && ja(r) || e.textFont || e.font;
    }, t;
  }(Ia), Vrt = {
    left: true,
    right: 1,
    center: 1
  }, Grt = {
    top: 1,
    bottom: 1,
    middle: 1
  }, tP = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily"
  ];
  function wU(n) {
    return typeof n == "string" && (n.indexOf("px") !== -1 || n.indexOf("rem") !== -1 || n.indexOf("em") !== -1) ? n : isNaN(+n) ? Dk + "px" : n + "px";
  }
  function eP(n, t) {
    for (var e = 0; e < tP.length; e++) {
      var r = tP[e], i = t[r];
      i != null && (n[r] = i);
    }
  }
  function SU(n) {
    return n.fontSize != null || n.fontFamily || n.fontWeight;
  }
  function Wrt(n) {
    return nP(n), P(n.rich, nP), n;
  }
  function nP(n) {
    if (n) {
      n.font = be.makeFont(n);
      var t = n.align;
      t === "middle" && (t = "center"), n.align = t == null || Vrt[t] ? t : "left";
      var e = n.verticalAlign;
      e === "center" && (e = "middle"), n.verticalAlign = e == null || Grt[e] ? e : "top";
      var r = n.padding;
      r && (n.padding = Pk(n.padding));
    }
  }
  function rP(n, t) {
    return n == null || t <= 0 || n === "transparent" || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
  }
  function iP(n) {
    return n == null || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
  }
  function aP(n, t, e) {
    return t === "right" ? n - e[1] : t === "center" ? n + e[3] / 2 - e[1] / 2 : n + e[3];
  }
  function sP(n) {
    var t = n.text;
    return t != null && (t += ""), t;
  }
  function xS(n) {
    return !!(n.backgroundColor || n.lineHeight || n.borderWidth && n.borderColor);
  }
  var Ut = xe(), XI = function(n, t, e, r) {
    if (r) {
      var i = Ut(r);
      i.dataIndex = e, i.dataType = t, i.seriesIndex = n, i.ssrType = "chart", r.type === "group" && r.traverse(function(a) {
        var s = Ut(a);
        s.seriesIndex = n, s.dataIndex = e, s.dataType = t, s.ssrType = "chart";
      });
    }
  }, oP = 1, lP = {}, CU = xe(), qk = xe(), jk = 0, Nv = 1, T1 = 2, vi = [
    "emphasis",
    "blur",
    "select"
  ], Og = [
    "normal",
    "emphasis",
    "blur",
    "select"
  ], bd = 10, Urt = 9, Rc = "highlight", ux = "downplay", fg = "select", cx = "unselect", dg = "toggleSelect";
  function $h(n) {
    return n != null && n !== "none";
  }
  function I1(n, t, e) {
    n.onHoverStateChange && (n.hoverState || 0) !== e && n.onHoverStateChange(t), n.hoverState = e;
  }
  function TU(n) {
    I1(n, "emphasis", T1);
  }
  function IU(n) {
    n.hoverState === T1 && I1(n, "normal", jk);
  }
  function Kk(n) {
    I1(n, "blur", Nv);
  }
  function AU(n) {
    n.hoverState === Nv && I1(n, "normal", jk);
  }
  function Hrt(n) {
    n.selected = true;
  }
  function Xrt(n) {
    n.selected = false;
  }
  function uP(n, t, e) {
    t(n, e);
  }
  function Qo(n, t, e) {
    uP(n, t, e), n.isGroup && n.traverse(function(r) {
      uP(r, t, e);
    });
  }
  function Hx(n, t) {
    switch (t) {
      case "emphasis":
        n.hoverState = T1;
        break;
      case "normal":
        n.hoverState = jk;
        break;
      case "blur":
        n.hoverState = Nv;
        break;
      case "select":
        n.selected = true;
    }
  }
  function Yrt(n, t, e, r) {
    for (var i = n.style, a = {}, s = 0; s < t.length; s++) {
      var o = t[s], l = i[o];
      a[o] = l ?? (r && r[o]);
    }
    for (var s = 0; s < n.animators.length; s++) {
      var u = n.animators[s];
      u.__fromStateTransition && u.__fromStateTransition.indexOf(e) < 0 && u.targetName === "style" && u.saveTo(a, t);
    }
    return a;
  }
  function qrt(n, t, e, r) {
    var i = e && ne(e, "select") >= 0, a = false;
    if (n instanceof le) {
      var s = CU(n), o = i && s.selectFill || s.normalFill, l = i && s.selectStroke || s.normalStroke;
      if ($h(o) || $h(l)) {
        r = r || {};
        var u = r.style || {};
        u.fill === "inherit" ? (a = true, r = rt({}, r), u = rt({}, u), u.fill = o) : !$h(u.fill) && $h(o) ? (a = true, r = rt({}, r), u = rt({}, u), u.fill = MI(o)) : !$h(u.stroke) && $h(l) && (a || (r = rt({}, r), u = rt({}, u)), u.stroke = MI(l)), r.style = u;
      }
    }
    if (r && r.z2 == null) {
      a || (r = rt({}, r));
      var c = n.z2EmphasisLift;
      r.z2 = n.z2 + (c ?? bd);
    }
    return r;
  }
  function jrt(n, t, e) {
    if (e && e.z2 == null) {
      e = rt({}, e);
      var r = n.z2SelectLift;
      e.z2 = n.z2 + (r ?? Urt);
    }
    return e;
  }
  function Krt(n, t, e) {
    var r = ne(n.currentStates, t) >= 0, i = n.style.opacity, a = r ? null : Yrt(n, [
      "opacity"
    ], t, {
      opacity: 1
    });
    e = e || {};
    var s = e.style || {};
    return s.opacity == null && (e = rt({}, e), s = rt({
      opacity: r ? i : a.opacity * 0.1
    }, s), e.style = s), e;
  }
  function bS(n, t) {
    var e = this.states[n];
    if (this.style) {
      if (n === "emphasis") return qrt(this, n, t, e);
      if (n === "blur") return Krt(this, n, e);
      if (n === "select") return jrt(this, n, e);
    }
    return e;
  }
  function Xc(n) {
    n.stateProxy = bS;
    var t = n.getTextContent(), e = n.getTextGuideLine();
    t && (t.stateProxy = bS), e && (e.stateProxy = bS);
  }
  function cP(n, t) {
    !MU(n, t) && !n.__highByOuter && Qo(n, TU);
  }
  function hP(n, t) {
    !MU(n, t) && !n.__highByOuter && Qo(n, IU);
  }
  function Vo(n, t) {
    n.__highByOuter |= 1 << (t || 0), Qo(n, TU);
  }
  function Go(n, t) {
    !(n.__highByOuter &= ~(1 << (t || 0))) && Qo(n, IU);
  }
  function kU(n) {
    Qo(n, Kk);
  }
  function Zk(n) {
    Qo(n, AU);
  }
  function DU(n) {
    Qo(n, Hrt);
  }
  function EU(n) {
    Qo(n, Xrt);
  }
  function MU(n, t) {
    return n.__highDownSilentOnTouch && t.zrByTouch;
  }
  function RU(n) {
    var t = n.getModel(), e = [], r = [];
    t.eachComponent(function(i, a) {
      var s = qk(a), o = i === "series", l = o ? n.getViewOfSeriesModel(a) : n.getViewOfComponentModel(a);
      !o && r.push(l), s.isBlured && (l.group.traverse(function(u) {
        AU(u);
      }), o && e.push(a)), s.isBlured = false;
    }), P(r, function(i) {
      i && i.toggleBlurSeries && i.toggleBlurSeries(e, false, t);
    });
  }
  function YI(n, t, e, r) {
    var i = r.getModel();
    e = e || "coordinateSystem";
    function a(u, c) {
      for (var h = 0; h < c.length; h++) {
        var f = u.getItemGraphicEl(c[h]);
        f && Zk(f);
      }
    }
    if (n != null && !(!t || t === "none")) {
      var s = i.getSeriesByIndex(n), o = s.coordinateSystem;
      o && o.master && (o = o.master);
      var l = [];
      i.eachSeries(function(u) {
        var c = s === u, h = u.coordinateSystem;
        h && h.master && (h = h.master);
        var f = h && o ? h === o : c;
        if (!(e === "series" && !c || e === "coordinateSystem" && !f || t === "series" && c)) {
          var d = r.getViewOfSeriesModel(u);
          if (d.group.traverse(function(v) {
            v.__highByOuter && c && t === "self" || Kk(v);
          }), Kr(t)) a(u.getData(), t);
          else if (Ft(t)) for (var p = ge(t), g = 0; g < p.length; g++) a(u.getData(p[g]), t[p[g]]);
          l.push(u), qk(u).isBlured = true;
        }
      }), i.eachComponent(function(u, c) {
        if (u !== "series") {
          var h = r.getViewOfComponentModel(c);
          h && h.toggleBlurSeries && h.toggleBlurSeries(l, true, i);
        }
      });
    }
  }
  function qI(n, t, e) {
    if (!(n == null || t == null)) {
      var r = e.getModel().getComponent(n, t);
      if (r) {
        qk(r).isBlured = true;
        var i = e.getViewOfComponentModel(r);
        !i || !i.focusBlurEnabled || i.group.traverse(function(a) {
          Kk(a);
        });
      }
    }
  }
  function Zrt(n, t, e) {
    var r = n.seriesIndex, i = n.getData(t.dataType);
    if (i) {
      var a = Uc(i, t);
      a = (ct(a) ? a[0] : a) || 0;
      var s = i.getItemGraphicEl(a);
      if (!s) for (var o = i.count(), l = 0; !s && l < o; ) s = i.getItemGraphicEl(l++);
      if (s) {
        var u = Ut(s);
        YI(r, u.focus, u.blurScope, e);
      } else {
        var c = n.get([
          "emphasis",
          "focus"
        ]), h = n.get([
          "emphasis",
          "blurScope"
        ]);
        c != null && YI(r, c, h, e);
      }
    }
  }
  function Jk(n, t, e, r) {
    var i = {
      focusSelf: false,
      dispatchers: null
    };
    if (n == null || n === "series" || t == null || e == null) return i;
    var a = r.getModel().getComponent(n, t);
    if (!a) return i;
    var s = r.getViewOfComponentModel(a);
    if (!s || !s.findHighDownDispatchers) return i;
    for (var o = s.findHighDownDispatchers(e), l, u = 0; u < o.length; u++) if (Ut(o[u]).focus === "self") {
      l = true;
      break;
    }
    return {
      focusSelf: l,
      dispatchers: o
    };
  }
  function Jrt(n, t, e) {
    var r = Ut(n), i = Jk(r.componentMainType, r.componentIndex, r.componentHighDownName, e), a = i.dispatchers, s = i.focusSelf;
    a ? (s && qI(r.componentMainType, r.componentIndex, e), P(a, function(o) {
      return cP(o, t);
    })) : (YI(r.seriesIndex, r.focus, r.blurScope, e), r.focus === "self" && qI(r.componentMainType, r.componentIndex, e), cP(n, t));
  }
  function Qrt(n, t, e) {
    RU(e);
    var r = Ut(n), i = Jk(r.componentMainType, r.componentIndex, r.componentHighDownName, e).dispatchers;
    i ? P(i, function(a) {
      return hP(a, t);
    }) : hP(n, t);
  }
  function tit(n, t, e) {
    if (KI(t)) {
      var r = t.dataType, i = n.getData(r), a = Uc(i, t);
      ct(a) || (a = [
        a
      ]), n[t.type === dg ? "toggleSelect" : t.type === fg ? "select" : "unselect"](a, r);
    }
  }
  function fP(n) {
    var t = n.getAllData();
    P(t, function(e) {
      var r = e.data, i = e.type;
      r.eachItemGraphicEl(function(a, s) {
        n.isSelected(s, i) ? DU(a) : EU(a);
      });
    });
  }
  function eit(n) {
    var t = [];
    return n.eachSeries(function(e) {
      var r = e.getAllData();
      P(r, function(i) {
        i.data;
        var a = i.type, s = e.getSelectedDataIndices();
        if (s.length > 0) {
          var o = {
            dataIndex: s,
            seriesIndex: e.seriesIndex
          };
          a != null && (o.dataType = a), t.push(o);
        }
      });
    }), t;
  }
  function Nc(n, t, e) {
    yc(n, true), Qo(n, Xc), jI(n, t, e);
  }
  function nit(n) {
    yc(n, false);
  }
  function bn(n, t, e, r) {
    r ? nit(n) : Nc(n, t, e);
  }
  function jI(n, t, e) {
    var r = Ut(n);
    t != null ? (r.focus = t, r.blurScope = e) : r.focus && (r.focus = null);
  }
  var dP = [
    "emphasis",
    "blur",
    "select"
  ], rit = {
    itemStyle: "getItemStyle",
    lineStyle: "getLineStyle",
    areaStyle: "getAreaStyle"
  };
  function Ar(n, t, e, r) {
    e = e || "itemStyle";
    for (var i = 0; i < dP.length; i++) {
      var a = dP[i], s = t.getModel([
        a,
        e
      ]), o = n.ensureState(a);
      o.style = r ? r(s) : s[rit[e]]();
    }
  }
  function yc(n, t) {
    var e = t === false, r = n;
    n.highDownSilentOnTouch && (r.__highDownSilentOnTouch = n.highDownSilentOnTouch), (!e || r.__highDownDispatcher) && (r.__highByOuter = r.__highByOuter || 0, r.__highDownDispatcher = !e);
  }
  function Fg(n) {
    return !!(n && n.__highDownDispatcher);
  }
  function iit(n, t, e) {
    var r = Ut(n);
    r.componentMainType = t.mainType, r.componentIndex = t.componentIndex, r.componentHighDownName = e;
  }
  function ait(n) {
    var t = lP[n];
    return t == null && oP <= 32 && (t = lP[n] = oP++), t;
  }
  function KI(n) {
    var t = n.type;
    return t === fg || t === cx || t === dg;
  }
  function pP(n) {
    var t = n.type;
    return t === Rc || t === ux;
  }
  function sit(n) {
    var t = CU(n);
    t.normalFill = n.style.fill, t.normalStroke = n.style.stroke;
    var e = n.states.select || {};
    t.selectFill = e.style && e.style.fill || null, t.selectStroke = e.style && e.style.stroke || null;
  }
  var Oh = ro.CMD, oit = [
    [],
    [],
    []
  ], gP = Math.sqrt, lit = Math.atan2;
  function NU(n, t) {
    if (t) {
      var e = n.data, r = n.len(), i, a, s, o, l, u, c = Oh.M, h = Oh.C, f = Oh.L, d = Oh.R, p = Oh.A, g = Oh.Q;
      for (s = 0, o = 0; s < r; ) {
        switch (i = e[s++], o = s, a = 0, i) {
          case c:
            a = 1;
            break;
          case f:
            a = 1;
            break;
          case h:
            a = 3;
            break;
          case g:
            a = 2;
            break;
          case p:
            var v = t[4], m = t[5], y = gP(t[0] * t[0] + t[1] * t[1]), x = gP(t[2] * t[2] + t[3] * t[3]), b = lit(-t[1] / x, t[0] / y);
            e[s] *= y, e[s++] += v, e[s] *= x, e[s++] += m, e[s++] *= y, e[s++] *= x, e[s++] += b, e[s++] += b, s += 2, o = s;
            break;
          case d:
            u[0] = e[s++], u[1] = e[s++], Tr(u, u, t), e[o++] = u[0], e[o++] = u[1], u[0] += e[s++], u[1] += e[s++], Tr(u, u, t), e[o++] = u[0], e[o++] = u[1];
        }
        for (l = 0; l < a; l++) {
          var _ = oit[l];
          _[0] = e[s++], _[1] = e[s++], Tr(_, _, t), e[o++] = _[0], e[o++] = _[1];
        }
      }
      n.increaseVersion();
    }
  }
  var _S = Math.sqrt, Ry = Math.sin, Ny = Math.cos, ap = Math.PI;
  function vP(n) {
    return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
  }
  function ZI(n, t) {
    return (n[0] * t[0] + n[1] * t[1]) / (vP(n) * vP(t));
  }
  function mP(n, t) {
    return (n[0] * t[1] < n[1] * t[0] ? -1 : 1) * Math.acos(ZI(n, t));
  }
  function yP(n, t, e, r, i, a, s, o, l, u, c) {
    var h = l * (ap / 180), f = Ny(h) * (n - e) / 2 + Ry(h) * (t - r) / 2, d = -1 * Ry(h) * (n - e) / 2 + Ny(h) * (t - r) / 2, p = f * f / (s * s) + d * d / (o * o);
    p > 1 && (s *= _S(p), o *= _S(p));
    var g = (i === a ? -1 : 1) * _S((s * s * (o * o) - s * s * (d * d) - o * o * (f * f)) / (s * s * (d * d) + o * o * (f * f))) || 0, v = g * s * d / o, m = g * -o * f / s, y = (n + e) / 2 + Ny(h) * v - Ry(h) * m, x = (t + r) / 2 + Ry(h) * v + Ny(h) * m, b = mP([
      1,
      0
    ], [
      (f - v) / s,
      (d - m) / o
    ]), _ = [
      (f - v) / s,
      (d - m) / o
    ], w = [
      (-1 * f - v) / s,
      (-1 * d - m) / o
    ], S = mP(_, w);
    if (ZI(_, w) <= -1 && (S = ap), ZI(_, w) >= 1 && (S = 0), S < 0) {
      var I = Math.round(S / ap * 1e6) / 1e6;
      S = ap * 2 + I % 2 * ap;
    }
    c.addData(u, y, x, s, o, b, S, h, a);
  }
  var uit = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, cit = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function hit(n) {
    var t = new ro();
    if (!n) return t;
    var e = 0, r = 0, i = e, a = r, s, o = ro.CMD, l = n.match(uit);
    if (!l) return t;
    for (var u = 0; u < l.length; u++) {
      for (var c = l[u], h = c.charAt(0), f = void 0, d = c.match(cit) || [], p = d.length, g = 0; g < p; g++) d[g] = parseFloat(d[g]);
      for (var v = 0; v < p; ) {
        var m = void 0, y = void 0, x = void 0, b = void 0, _ = void 0, w = void 0, S = void 0, I = e, T = r, A = void 0, C = void 0;
        switch (h) {
          case "l":
            e += d[v++], r += d[v++], f = o.L, t.addData(f, e, r);
            break;
          case "L":
            e = d[v++], r = d[v++], f = o.L, t.addData(f, e, r);
            break;
          case "m":
            e += d[v++], r += d[v++], f = o.M, t.addData(f, e, r), i = e, a = r, h = "l";
            break;
          case "M":
            e = d[v++], r = d[v++], f = o.M, t.addData(f, e, r), i = e, a = r, h = "L";
            break;
          case "h":
            e += d[v++], f = o.L, t.addData(f, e, r);
            break;
          case "H":
            e = d[v++], f = o.L, t.addData(f, e, r);
            break;
          case "v":
            r += d[v++], f = o.L, t.addData(f, e, r);
            break;
          case "V":
            r = d[v++], f = o.L, t.addData(f, e, r);
            break;
          case "C":
            f = o.C, t.addData(f, d[v++], d[v++], d[v++], d[v++], d[v++], d[v++]), e = d[v - 2], r = d[v - 1];
            break;
          case "c":
            f = o.C, t.addData(f, d[v++] + e, d[v++] + r, d[v++] + e, d[v++] + r, d[v++] + e, d[v++] + r), e += d[v - 2], r += d[v - 1];
            break;
          case "S":
            m = e, y = r, A = t.len(), C = t.data, s === o.C && (m += e - C[A - 4], y += r - C[A - 3]), f = o.C, I = d[v++], T = d[v++], e = d[v++], r = d[v++], t.addData(f, m, y, I, T, e, r);
            break;
          case "s":
            m = e, y = r, A = t.len(), C = t.data, s === o.C && (m += e - C[A - 4], y += r - C[A - 3]), f = o.C, I = e + d[v++], T = r + d[v++], e += d[v++], r += d[v++], t.addData(f, m, y, I, T, e, r);
            break;
          case "Q":
            I = d[v++], T = d[v++], e = d[v++], r = d[v++], f = o.Q, t.addData(f, I, T, e, r);
            break;
          case "q":
            I = d[v++] + e, T = d[v++] + r, e += d[v++], r += d[v++], f = o.Q, t.addData(f, I, T, e, r);
            break;
          case "T":
            m = e, y = r, A = t.len(), C = t.data, s === o.Q && (m += e - C[A - 4], y += r - C[A - 3]), e = d[v++], r = d[v++], f = o.Q, t.addData(f, m, y, e, r);
            break;
          case "t":
            m = e, y = r, A = t.len(), C = t.data, s === o.Q && (m += e - C[A - 4], y += r - C[A - 3]), e += d[v++], r += d[v++], f = o.Q, t.addData(f, m, y, e, r);
            break;
          case "A":
            x = d[v++], b = d[v++], _ = d[v++], w = d[v++], S = d[v++], I = e, T = r, e = d[v++], r = d[v++], f = o.A, yP(I, T, e, r, w, S, x, b, _, f, t);
            break;
          case "a":
            x = d[v++], b = d[v++], _ = d[v++], w = d[v++], S = d[v++], I = e, T = r, e += d[v++], r += d[v++], f = o.A, yP(I, T, e, r, w, S, x, b, _, f, t);
            break;
        }
      }
      (h === "z" || h === "Z") && (f = o.Z, t.addData(f), e = i, r = a), s = f;
    }
    return t.toStatic(), t;
  }
  var LU = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.applyTransform = function(e) {
    }, t;
  }(le);
  function PU(n) {
    return n.setData != null;
  }
  function $U(n, t) {
    var e = hit(n), r = rt({}, t);
    return r.buildPath = function(i) {
      if (PU(i)) {
        i.setData(e.data);
        var a = i.getContext();
        a && i.rebuildPath(a, 1);
      } else {
        var a = i;
        e.rebuildPath(a, 1);
      }
    }, r.applyTransform = function(i) {
      NU(e, i), this.dirtyShape();
    }, r;
  }
  function OU(n, t) {
    return new LU($U(n, t));
  }
  function fit(n, t) {
    var e = $U(n, t), r = function(i) {
      q(a, i);
      function a(s) {
        var o = i.call(this, s) || this;
        return o.applyTransform = e.applyTransform, o.buildPath = e.buildPath, o;
      }
      return a;
    }(LU);
    return r;
  }
  function dit(n, t) {
    for (var e = [], r = n.length, i = 0; i < r; i++) {
      var a = n[i];
      e.push(a.getUpdatedPathProxy(true));
    }
    var s = new le(t);
    return s.createPathProxy(), s.buildPath = function(o) {
      if (PU(o)) {
        o.appendPath(e);
        var l = o.getContext();
        l && o.rebuildPath(l, 1);
      }
    }, s;
  }
  function Qk(n, t) {
    t = t || {};
    var e = new le();
    return n.shape && e.setShape(n.shape), e.setStyle(n.style), t.bakeTransform ? NU(e.path, n.getComputedTransform()) : t.toLocal ? e.setLocalTransform(n.getComputedTransform()) : e.copyTransform(n), e.buildPath = n.buildPath, e.applyTransform = e.applyTransform, e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel, e;
  }
  var pit = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r = 0;
    }
    return n;
  }(), tl = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new pit();
    }, t.prototype.buildPath = function(e, r) {
      e.moveTo(r.cx + r.r, r.cy), e.arc(r.cx, r.cy, r.r, 0, Math.PI * 2);
    }, t;
  }(le);
  tl.prototype.type = "circle";
  var git = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
    }
    return n;
  }(), A1 = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new git();
    }, t.prototype.buildPath = function(e, r) {
      var i = 0.5522848, a = r.cx, s = r.cy, o = r.rx, l = r.ry, u = o * i, c = l * i;
      e.moveTo(a - o, s), e.bezierCurveTo(a - o, s - c, a - u, s - l, a, s - l), e.bezierCurveTo(a + u, s - l, a + o, s - c, a + o, s), e.bezierCurveTo(a + o, s + c, a + u, s + l, a, s + l), e.bezierCurveTo(a - u, s + l, a - o, s + c, a - o, s), e.closePath();
    }, t;
  }(le);
  A1.prototype.type = "ellipse";
  var FU = Math.PI, wS = FU * 2, Pu = Math.sin, Fh = Math.cos, vit = Math.acos, Or = Math.atan2, xP = Math.abs, pg = Math.sqrt, zp = Math.max, ws = Math.min, Va = 1e-4;
  function mit(n, t, e, r, i, a, s, o) {
    var l = e - n, u = r - t, c = s - i, h = o - a, f = h * l - c * u;
    if (!(f * f < Va)) return f = (c * (t - a) - h * (n - i)) / f, [
      n + f * l,
      t + f * u
    ];
  }
  function Ly(n, t, e, r, i, a, s) {
    var o = n - e, l = t - r, u = (s ? a : -a) / pg(o * o + l * l), c = u * l, h = -u * o, f = n + c, d = t + h, p = e + c, g = r + h, v = (f + p) / 2, m = (d + g) / 2, y = p - f, x = g - d, b = y * y + x * x, _ = i - a, w = f * g - p * d, S = (x < 0 ? -1 : 1) * pg(zp(0, _ * _ * b - w * w)), I = (w * x - y * S) / b, T = (-w * y - x * S) / b, A = (w * x + y * S) / b, C = (-w * y + x * S) / b, D = I - v, E = T - m, M = A - v, L = C - m;
    return D * D + E * E > M * M + L * L && (I = A, T = C), {
      cx: I,
      cy: T,
      x0: -c,
      y0: -h,
      x1: I * (i / _ - 1),
      y1: T * (i / _ - 1)
    };
  }
  function yit(n) {
    var t;
    if (ct(n)) {
      var e = n.length;
      if (!e) return n;
      e === 1 ? t = [
        n[0],
        n[0],
        0,
        0
      ] : e === 2 ? t = [
        n[0],
        n[0],
        n[1],
        n[1]
      ] : e === 3 ? t = n.concat(n[2]) : t = n;
    } else t = [
      n,
      n,
      n,
      n
    ];
    return t;
  }
  function xit(n, t) {
    var e, r = zp(t.r, 0), i = zp(t.r0 || 0, 0), a = r > 0, s = i > 0;
    if (!(!a && !s)) {
      if (a || (r = i, i = 0), i > r) {
        var o = r;
        r = i, i = o;
      }
      var l = t.startAngle, u = t.endAngle;
      if (!(isNaN(l) || isNaN(u))) {
        var c = t.cx, h = t.cy, f = !!t.clockwise, d = xP(u - l), p = d > wS && d % wS;
        if (p > Va && (d = p), !(r > Va)) n.moveTo(c, h);
        else if (d > wS - Va) n.moveTo(c + r * Fh(l), h + r * Pu(l)), n.arc(c, h, r, l, u, !f), i > Va && (n.moveTo(c + i * Fh(u), h + i * Pu(u)), n.arc(c, h, i, u, l, f));
        else {
          var g = void 0, v = void 0, m = void 0, y = void 0, x = void 0, b = void 0, _ = void 0, w = void 0, S = void 0, I = void 0, T = void 0, A = void 0, C = void 0, D = void 0, E = void 0, M = void 0, L = r * Fh(l), k = r * Pu(l), N = i * Fh(u), R = i * Pu(u), $ = d > Va;
          if ($) {
            var O = t.cornerRadius;
            O && (e = yit(O), g = e[0], v = e[1], m = e[2], y = e[3]);
            var F = xP(r - i) / 2;
            if (x = ws(F, m), b = ws(F, y), _ = ws(F, g), w = ws(F, v), T = S = zp(x, b), A = I = zp(_, w), (S > Va || I > Va) && (C = r * Fh(u), D = r * Pu(u), E = i * Fh(l), M = i * Pu(l), d < FU)) {
              var z = mit(L, k, E, M, C, D, N, R);
              if (z) {
                var V = L - z[0], U = k - z[1], X = C - z[0], at = D - z[1], pt = 1 / Pu(vit((V * X + U * at) / (pg(V * V + U * U) * pg(X * X + at * at))) / 2), it = pg(z[0] * z[0] + z[1] * z[1]);
                T = ws(S, (r - it) / (pt + 1)), A = ws(I, (i - it) / (pt - 1));
              }
            }
          }
          if (!$) n.moveTo(c + L, h + k);
          else if (T > Va) {
            var et = ws(m, T), ft = ws(y, T), ut = Ly(E, M, L, k, r, et, f), gt = Ly(C, D, N, R, r, ft, f);
            n.moveTo(c + ut.cx + ut.x0, h + ut.cy + ut.y0), T < S && et === ft ? n.arc(c + ut.cx, h + ut.cy, T, Or(ut.y0, ut.x0), Or(gt.y0, gt.x0), !f) : (et > 0 && n.arc(c + ut.cx, h + ut.cy, et, Or(ut.y0, ut.x0), Or(ut.y1, ut.x1), !f), n.arc(c, h, r, Or(ut.cy + ut.y1, ut.cx + ut.x1), Or(gt.cy + gt.y1, gt.cx + gt.x1), !f), ft > 0 && n.arc(c + gt.cx, h + gt.cy, ft, Or(gt.y1, gt.x1), Or(gt.y0, gt.x0), !f));
          } else n.moveTo(c + L, h + k), n.arc(c, h, r, l, u, !f);
          if (!(i > Va) || !$) n.lineTo(c + N, h + R);
          else if (A > Va) {
            var et = ws(g, A), ft = ws(v, A), ut = Ly(N, R, C, D, i, -ft, f), gt = Ly(L, k, E, M, i, -et, f);
            n.lineTo(c + ut.cx + ut.x0, h + ut.cy + ut.y0), A < I && et === ft ? n.arc(c + ut.cx, h + ut.cy, A, Or(ut.y0, ut.x0), Or(gt.y0, gt.x0), !f) : (ft > 0 && n.arc(c + ut.cx, h + ut.cy, ft, Or(ut.y0, ut.x0), Or(ut.y1, ut.x1), !f), n.arc(c, h, i, Or(ut.cy + ut.y1, ut.cx + ut.x1), Or(gt.cy + gt.y1, gt.cx + gt.x1), f), et > 0 && n.arc(c + gt.cx, h + gt.cy, et, Or(gt.y1, gt.x1), Or(gt.y0, gt.x0), !f));
          } else n.lineTo(c + N, h + R), n.arc(c, h, i, u, l, f);
        }
        n.closePath();
      }
    }
  }
  var bit = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true, this.cornerRadius = 0;
    }
    return n;
  }(), mi = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new bit();
    }, t.prototype.buildPath = function(e, r) {
      xit(e, r);
    }, t.prototype.isZeroArea = function() {
      return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
    }, t;
  }(le);
  mi.prototype.type = "sector";
  var _it = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
    }
    return n;
  }(), Lv = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new _it();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.cx, a = r.cy, s = Math.PI * 2;
      e.moveTo(i + r.r, a), e.arc(i, a, r.r, 0, s, false), e.moveTo(i + r.r0, a), e.arc(i, a, r.r0, 0, s, true);
    }, t;
  }(le);
  Lv.prototype.type = "ring";
  function wit(n, t, e, r) {
    var i = [], a = [], s = [], o = [], l, u, c, h;
    if (r) {
      c = [
        1 / 0,
        1 / 0
      ], h = [
        -1 / 0,
        -1 / 0
      ];
      for (var f = 0, d = n.length; f < d; f++) Cl(c, c, n[f]), Tl(h, h, n[f]);
      Cl(c, c, r[0]), Tl(h, h, r[1]);
    }
    for (var f = 0, d = n.length; f < d; f++) {
      var p = n[f];
      if (e) l = n[f ? f - 1 : d - 1], u = n[(f + 1) % d];
      else if (f === 0 || f === d - 1) {
        i.push(Mo(n[f]));
        continue;
      } else l = n[f - 1], u = n[f + 1];
      vc(a, u, l), ex(a, a, t);
      var g = wI(p, l), v = wI(p, u), m = g + v;
      m !== 0 && (g /= m, v /= m), ex(s, a, -g), ex(o, a, v);
      var y = gL([], p, s), x = gL([], p, o);
      r && (Tl(y, y, c), Cl(y, y, h), Tl(x, x, c), Cl(x, x, h)), i.push(y), i.push(x);
    }
    return e && i.push(i.shift()), i;
  }
  function BU(n, t, e) {
    var r = t.smooth, i = t.points;
    if (i && i.length >= 2) {
      if (r) {
        var a = wit(i, r, e, t.smoothConstraint);
        n.moveTo(i[0][0], i[0][1]);
        for (var s = i.length, o = 0; o < (e ? s : s - 1); o++) {
          var l = a[o * 2], u = a[o * 2 + 1], c = i[(o + 1) % s];
          n.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
        }
      } else {
        n.moveTo(i[0][0], i[0][1]);
        for (var o = 1, h = i.length; o < h; o++) n.lineTo(i[o][0], i[o][1]);
      }
      e && n.closePath();
    }
  }
  var Sit = /* @__PURE__ */ function() {
    function n() {
      this.points = null, this.smooth = 0, this.smoothConstraint = null;
    }
    return n;
  }(), yi = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new Sit();
    }, t.prototype.buildPath = function(e, r) {
      BU(e, r, true);
    }, t;
  }(le);
  yi.prototype.type = "polygon";
  var Cit = /* @__PURE__ */ function() {
    function n() {
      this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
    }
    return n;
  }(), _i = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new Cit();
    }, t.prototype.buildPath = function(e, r) {
      BU(e, r, false);
    }, t;
  }(le);
  _i.prototype.type = "polyline";
  var Tit = {}, Iit = /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return n;
  }(), ir = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new Iit();
    }, t.prototype.buildPath = function(e, r) {
      var i, a, s, o;
      if (this.subPixelOptimize) {
        var l = bU(Tit, r, this.style);
        i = l.x1, a = l.y1, s = l.x2, o = l.y2;
      } else i = r.x1, a = r.y1, s = r.x2, o = r.y2;
      var u = r.percent;
      u !== 0 && (e.moveTo(i, a), u < 1 && (s = i * (1 - u) + s * u, o = a * (1 - u) + o * u), e.lineTo(s, o));
    }, t.prototype.pointAt = function(e) {
      var r = this.shape;
      return [
        r.x1 * (1 - e) + r.x2 * e,
        r.y1 * (1 - e) + r.y2 * e
      ];
    }, t;
  }(le);
  ir.prototype.type = "line";
  var Si = [], Ait = /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
    }
    return n;
  }();
  function bP(n, t, e) {
    var r = n.cpx2, i = n.cpy2;
    return r != null || i != null ? [
      (e ? AL : tr)(n.x1, n.cpx1, n.cpx2, n.x2, t),
      (e ? AL : tr)(n.y1, n.cpy1, n.cpy2, n.y2, t)
    ] : [
      (e ? AI : pr)(n.x1, n.cpx1, n.x2, t),
      (e ? AI : pr)(n.y1, n.cpy1, n.y2, t)
    ];
  }
  var Pv = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new Ait();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.x1, a = r.y1, s = r.x2, o = r.y2, l = r.cpx1, u = r.cpy1, c = r.cpx2, h = r.cpy2, f = r.percent;
      f !== 0 && (e.moveTo(i, a), c == null || h == null ? (f < 1 && (Rg(i, l, s, f, Si), l = Si[1], s = Si[2], Rg(a, u, o, f, Si), u = Si[1], o = Si[2]), e.quadraticCurveTo(l, u, s, o)) : (f < 1 && (Yl(i, l, c, s, f, Si), l = Si[1], c = Si[2], s = Si[3], Yl(a, u, h, o, f, Si), u = Si[1], h = Si[2], o = Si[3]), e.bezierCurveTo(l, u, c, h, s, o)));
    }, t.prototype.pointAt = function(e) {
      return bP(this.shape, e, false);
    }, t.prototype.tangentAt = function(e) {
      var r = bP(this.shape, e, true);
      return md(r, r);
    }, t;
  }(le);
  Pv.prototype.type = "bezier-curve";
  var kit = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
    }
    return n;
  }(), k1 = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new kit();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.cx, a = r.cy, s = Math.max(r.r, 0), o = r.startAngle, l = r.endAngle, u = r.clockwise, c = Math.cos(o), h = Math.sin(o);
      e.moveTo(c * s + i, h * s + a), e.arc(i, a, s, o, l, !u);
    }, t;
  }(le);
  k1.prototype.type = "arc";
  var tD = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = "compound", e;
    }
    return t.prototype._updatePathDirty = function() {
      for (var e = this.shape.paths, r = this.shapeChanged(), i = 0; i < e.length; i++) r = r || e[i].shapeChanged();
      r && this.dirtyShape();
    }, t.prototype.beforeBrush = function() {
      this._updatePathDirty();
      for (var e = this.shape.paths || [], r = this.getGlobalScale(), i = 0; i < e.length; i++) e[i].path || e[i].createPathProxy(), e[i].path.setScale(r[0], r[1], e[i].segmentIgnoreThreshold);
    }, t.prototype.buildPath = function(e, r) {
      for (var i = r.paths || [], a = 0; a < i.length; a++) i[a].buildPath(e, i[a].shape, true);
    }, t.prototype.afterBrush = function() {
      for (var e = this.shape.paths || [], r = 0; r < e.length; r++) e[r].pathUpdated();
    }, t.prototype.getBoundingRect = function() {
      return this._updatePathDirty.call(this), le.prototype.getBoundingRect.call(this);
    }, t;
  }(le), zU = function() {
    function n(t) {
      this.colorStops = t || [];
    }
    return n.prototype.addColorStop = function(t, e) {
      this.colorStops.push({
        offset: t,
        color: e
      });
    }, n;
  }(), $v = function(n) {
    q(t, n);
    function t(e, r, i, a, s, o) {
      var l = n.call(this, s) || this;
      return l.x = e ?? 0, l.y = r ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = o || false, l;
    }
    return t;
  }(zU), VU = function(n) {
    q(t, n);
    function t(e, r, i, a, s) {
      var o = n.call(this, a) || this;
      return o.x = e ?? 0.5, o.y = r ?? 0.5, o.r = i ?? 0.5, o.type = "radial", o.global = s || false, o;
    }
    return t;
  }(zU), $u = [
    0,
    0
  ], Ou = [
    0,
    0
  ], Py = new Qt(), $y = new Qt(), Xx = function() {
    function n(t, e) {
      this._corners = [], this._axes = [], this._origin = [
        0,
        0
      ];
      for (var r = 0; r < 4; r++) this._corners[r] = new Qt();
      for (var r = 0; r < 2; r++) this._axes[r] = new Qt();
      t && this.fromBoundingRect(t, e);
    }
    return n.prototype.fromBoundingRect = function(t, e) {
      var r = this._corners, i = this._axes, a = t.x, s = t.y, o = a + t.width, l = s + t.height;
      if (r[0].set(a, s), r[1].set(o, s), r[2].set(o, l), r[3].set(a, l), e) for (var u = 0; u < 4; u++) r[u].transform(e);
      Qt.sub(i[0], r[1], r[0]), Qt.sub(i[1], r[3], r[0]), i[0].normalize(), i[1].normalize();
      for (var u = 0; u < 2; u++) this._origin[u] = i[u].dot(r[0]);
    }, n.prototype.intersect = function(t, e) {
      var r = true, i = !e;
      return Py.set(1 / 0, 1 / 0), $y.set(0, 0), !this._intersectCheckOneSide(this, t, Py, $y, i, 1) && (r = false, i) || !this._intersectCheckOneSide(t, this, Py, $y, i, -1) && (r = false, i) || i || Qt.copy(e, r ? Py : $y), r;
    }, n.prototype._intersectCheckOneSide = function(t, e, r, i, a, s) {
      for (var o = true, l = 0; l < 2; l++) {
        var u = this._axes[l];
        if (this._getProjMinMaxOnAxis(l, t._corners, $u), this._getProjMinMaxOnAxis(l, e._corners, Ou), $u[1] < Ou[0] || $u[0] > Ou[1]) {
          if (o = false, a) return o;
          var c = Math.abs(Ou[0] - $u[1]), h = Math.abs($u[0] - Ou[1]);
          Math.min(c, h) > i.len() && (c < h ? Qt.scale(i, u, -c * s) : Qt.scale(i, u, h * s));
        } else if (r) {
          var c = Math.abs(Ou[0] - $u[1]), h = Math.abs($u[0] - Ou[1]);
          Math.min(c, h) < r.len() && (c < h ? Qt.scale(r, u, c * s) : Qt.scale(r, u, -h * s));
        }
      }
      return o;
    }, n.prototype._getProjMinMaxOnAxis = function(t, e, r) {
      for (var i = this._axes[t], a = this._origin, s = e[0].dot(i) + a[t], o = s, l = s, u = 1; u < e.length; u++) {
        var c = e[u].dot(i) + a[t];
        o = Math.min(c, o), l = Math.max(c, l);
      }
      r[0] = o, r[1] = l;
    }, n;
  }(), Dit = [], Eit = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.notClear = true, e.incremental = true, e._displayables = [], e._temporaryDisplayables = [], e._cursor = 0, e;
    }
    return t.prototype.traverse = function(e, r) {
      e.call(r, this);
    }, t.prototype.useStyle = function() {
      this.style = {};
    }, t.prototype.getCursor = function() {
      return this._cursor;
    }, t.prototype.innerAfterBrush = function() {
      this._cursor = this._displayables.length;
    }, t.prototype.clearDisplaybles = function() {
      this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = false;
    }, t.prototype.clearTemporalDisplayables = function() {
      this._temporaryDisplayables = [];
    }, t.prototype.addDisplayable = function(e, r) {
      r ? this._temporaryDisplayables.push(e) : this._displayables.push(e), this.markRedraw();
    }, t.prototype.addDisplayables = function(e, r) {
      r = r || false;
      for (var i = 0; i < e.length; i++) this.addDisplayable(e[i], r);
    }, t.prototype.getDisplayables = function() {
      return this._displayables;
    }, t.prototype.getTemporalDisplayables = function() {
      return this._temporaryDisplayables;
    }, t.prototype.eachPendingDisplayable = function(e) {
      for (var r = this._cursor; r < this._displayables.length; r++) e && e(this._displayables[r]);
      for (var r = 0; r < this._temporaryDisplayables.length; r++) e && e(this._temporaryDisplayables[r]);
    }, t.prototype.update = function() {
      this.updateTransform();
      for (var e = this._cursor; e < this._displayables.length; e++) {
        var r = this._displayables[e];
        r.parent = this, r.update(), r.parent = null;
      }
      for (var e = 0; e < this._temporaryDisplayables.length; e++) {
        var r = this._temporaryDisplayables[e];
        r.parent = this, r.update(), r.parent = null;
      }
    }, t.prototype.getBoundingRect = function() {
      if (!this._rect) {
        for (var e = new te(1 / 0, 1 / 0, -1 / 0, -1 / 0), r = 0; r < this._displayables.length; r++) {
          var i = this._displayables[r], a = i.getBoundingRect().clone();
          i.needLocalTransform() && a.applyTransform(i.getLocalTransform(Dit)), e.union(a);
        }
        this._rect = e;
      }
      return this._rect;
    }, t.prototype.contain = function(e, r) {
      var i = this.transformCoordToLocal(e, r), a = this.getBoundingRect();
      if (a.contain(i[0], i[1])) for (var s = 0; s < this._displayables.length; s++) {
        var o = this._displayables[s];
        if (o.contain(e, r)) return true;
      }
      return false;
    }, t;
  }(Ia), GU = xe();
  function _d(n, t, e, r, i) {
    var a;
    if (t && t.ecModel) {
      var s = t.ecModel.getUpdatePayload();
      a = s && s.animation;
    }
    var o = t && t.isAnimationEnabled(), l = n === "update";
    if (o) {
      var u = void 0, c = void 0, h = void 0;
      r ? (u = Ht(r.duration, 200), c = Ht(r.easing, "cubicOut"), h = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), Nt(h) && (h = h(e, i)), Nt(u) && (u = u(e));
      var f = {
        duration: u || 0,
        delay: h,
        easing: c
      };
      return f;
    } else return null;
  }
  function eD(n, t, e, r, i, a, s) {
    var o = false, l;
    Nt(i) ? (s = a, a = i, i = null) : Ft(i) && (a = i.cb, s = i.during, o = i.isFrom, l = i.removeOpt, i = i.dataIndex);
    var u = n === "leave";
    u || t.stopAnimation("leave");
    var c = _d(n, r, i, u ? l || {} : null, r && r.getAnimationDelayParams ? r.getAnimationDelayParams(t, i) : null);
    if (c && c.duration > 0) {
      var h = c.duration, f = c.delay, d = c.easing, p = {
        duration: h,
        delay: f || 0,
        easing: d,
        done: a,
        force: !!a || !!s,
        setToFinal: !u,
        scope: n,
        during: s
      };
      o ? t.animateFrom(e, p) : t.animateTo(e, p);
    } else t.stopAnimation(), !o && t.attr(e), s && s(1), a && a();
  }
  function Ie(n, t, e, r, i, a) {
    eD("update", n, t, e, r, i, a);
  }
  function dn(n, t, e, r, i, a) {
    eD("enter", n, t, e, r, i, a);
  }
  function Df(n) {
    if (!n.__zr) return true;
    for (var t = 0; t < n.animators.length; t++) {
      var e = n.animators[t];
      if (e.scope === "leave") return true;
    }
    return false;
  }
  function ql(n, t, e, r, i, a) {
    Df(n) || eD("leave", n, t, e, r, i, a);
  }
  function _P(n, t, e, r) {
    n.removeTextContent(), n.removeTextGuideLine(), ql(n, {
      style: {
        opacity: 0
      }
    }, t, e, r);
  }
  function Bg(n, t, e) {
    function r() {
      n.parent && n.parent.remove(n);
    }
    n.isGroup ? n.traverse(function(i) {
      i.isGroup || _P(i, t, e, r);
    }) : _P(n, t, e, r);
  }
  function os(n) {
    GU(n).oldStyle = n.style;
  }
  function Mit(n) {
    return GU(n).oldStyle;
  }
  var Yx = Math.max, qx = Math.min, JI = {};
  function Rit(n) {
    return le.extend(n);
  }
  var Nit = fit;
  function Lit(n, t) {
    return Nit(n, t);
  }
  function fs(n, t) {
    JI[n] = t;
  }
  function nD(n) {
    if (JI.hasOwnProperty(n)) return JI[n];
  }
  function D1(n, t, e, r) {
    var i = OU(n, t);
    return e && (r === "center" && (e = UU(e, i.getBoundingRect())), HU(i, e)), i;
  }
  function WU(n, t, e) {
    var r = new br({
      style: {
        image: n,
        x: t.x,
        y: t.y,
        width: t.width,
        height: t.height
      },
      onload: function(i) {
        if (e === "center") {
          var a = {
            width: i.width,
            height: i.height
          };
          r.setStyle(UU(t, a));
        }
      }
    });
    return r;
  }
  function UU(n, t) {
    var e = t.width / t.height, r = n.height * e, i;
    r <= n.width ? i = n.height : (r = n.width, i = r / e);
    var a = n.x + n.width / 2, s = n.y + n.height / 2;
    return {
      x: a - r / 2,
      y: s - i / 2,
      width: r,
      height: i
    };
  }
  var ya = dit;
  function HU(n, t) {
    if (n.applyTransform) {
      var e = n.getBoundingRect(), r = e.calculateTransform(t);
      n.applyTransform(r);
    }
  }
  function Gf(n, t) {
    return bU(n, n, {
      lineWidth: t
    }), n;
  }
  function Pit(n) {
    return _U(n.shape, n.shape, n.style), n;
  }
  var hx = mc;
  function Lc(n, t) {
    for (var e = m1([]); n && n !== t; ) Ro(e, n.getLocalTransform(), e), n = n.parent;
    return e;
  }
  function es(n, t, e) {
    return t && !Kr(t) && (t = To.getLocalTransform(t)), e && (t = yd([], t)), Tr([], n, t);
  }
  function E1(n, t, e) {
    var r = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Math.abs(2 * t[4] / t[0]), i = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Math.abs(2 * t[4] / t[2]), a = [
      n === "left" ? -r : n === "right" ? r : 0,
      n === "top" ? -i : n === "bottom" ? i : 0
    ];
    return a = es(a, t, e), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
  }
  function wP(n) {
    return !n.isGroup;
  }
  function $it(n) {
    return n.shape != null;
  }
  function Ov(n, t, e) {
    if (!n || !t) return;
    function r(s) {
      var o = {};
      return s.traverse(function(l) {
        wP(l) && l.anid && (o[l.anid] = l);
      }), o;
    }
    function i(s) {
      var o = {
        x: s.x,
        y: s.y,
        rotation: s.rotation
      };
      return $it(s) && (o.shape = rt({}, s.shape)), o;
    }
    var a = r(n);
    t.traverse(function(s) {
      if (wP(s) && s.anid) {
        var o = a[s.anid];
        if (o) {
          var l = i(s);
          s.attr(i(o)), Ie(s, l, e, Ut(s).dataIndex);
        }
      }
    });
  }
  function XU(n, t) {
    return ht(n, function(e) {
      var r = e[0];
      r = Yx(r, t.x), r = qx(r, t.x + t.width);
      var i = e[1];
      return i = Yx(i, t.y), i = qx(i, t.y + t.height), [
        r,
        i
      ];
    });
  }
  function Oit(n, t) {
    var e = Yx(n.x, t.x), r = qx(n.x + n.width, t.x + t.width), i = Yx(n.y, t.y), a = qx(n.y + n.height, t.y + t.height);
    if (r >= e && a >= i) return {
      x: e,
      y: i,
      width: r - e,
      height: a - i
    };
  }
  function Fv(n, t, e) {
    var r = rt({
      rectHover: true
    }, t), i = r.style = {
      strokeNoScale: true
    };
    if (e = e || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }, n) return n.indexOf("image://") === 0 ? (i.image = n.slice(8), $t(i, e), new br(r)) : D1(n.replace("path://", ""), r, e, "center");
  }
  function Vp(n, t, e, r, i) {
    for (var a = 0, s = i[i.length - 1]; a < i.length; a++) {
      var o = i[a];
      if (YU(n, t, e, r, o[0], o[1], s[0], s[1])) return true;
      s = o;
    }
  }
  function YU(n, t, e, r, i, a, s, o) {
    var l = e - n, u = r - t, c = s - i, h = o - a, f = SS(c, h, l, u);
    if (Fit(f)) return false;
    var d = n - i, p = t - a, g = SS(d, p, l, u) / f;
    if (g < 0 || g > 1) return false;
    var v = SS(d, p, c, h) / f;
    return !(v < 0 || v > 1);
  }
  function SS(n, t, e, r) {
    return n * r - e * t;
  }
  function Fit(n) {
    return n <= 1e-6 && n >= -1e-6;
  }
  function dh(n) {
    var t = n.itemTooltipOption, e = n.componentModel, r = n.itemName, i = wt(t) ? {
      formatter: t
    } : t, a = e.mainType, s = e.componentIndex, o = {
      componentType: a,
      name: r,
      $vars: [
        "name"
      ]
    };
    o[a + "Index"] = s;
    var l = n.formatterParamsExtra;
    l && P(ge(l), function(c) {
      Ct(o, c) || (o[c] = l[c], o.$vars.push(c));
    });
    var u = Ut(n.el);
    u.componentMainType = a, u.componentIndex = s, u.tooltipConfig = {
      name: r,
      option: $t({
        content: r,
        encodeHTMLContent: true,
        formatterParams: o
      }, i)
    };
  }
  function SP(n, t) {
    var e;
    n.isGroup && (e = t(n)), e || n.traverse(t);
  }
  function su(n, t) {
    if (n) if (ct(n)) for (var e = 0; e < n.length; e++) SP(n[e], t);
    else SP(n, t);
  }
  fs("circle", tl);
  fs("ellipse", A1);
  fs("sector", mi);
  fs("ring", Lv);
  fs("polygon", yi);
  fs("polyline", _i);
  fs("rect", ye);
  fs("line", ir);
  fs("bezierCurve", Pv);
  fs("arc", k1);
  const ph = Object.freeze(Object.defineProperty({
    __proto__: null,
    Arc: k1,
    BezierCurve: Pv,
    BoundingRect: te,
    Circle: tl,
    CompoundPath: tD,
    Ellipse: A1,
    Group: Vt,
    Image: br,
    IncrementalDisplayable: Eit,
    Line: ir,
    LinearGradient: $v,
    OrientedBoundingRect: Xx,
    Path: le,
    Point: Qt,
    Polygon: yi,
    Polyline: _i,
    RadialGradient: VU,
    Rect: ye,
    Ring: Lv,
    Sector: mi,
    Text: be,
    applyTransform: es,
    clipPointsByRect: XU,
    clipRectByRect: Oit,
    createIcon: Fv,
    extendPath: Lit,
    extendShape: Rit,
    getShapeClass: nD,
    getTransform: Lc,
    groupTransition: Ov,
    initProps: dn,
    isElementRemoved: Df,
    lineLineIntersect: YU,
    linePolygonIntersect: Vp,
    makeImage: WU,
    makePath: D1,
    mergePath: ya,
    registerShape: fs,
    removeElement: ql,
    removeElementWithFadeOut: Bg,
    resizePath: HU,
    setTooltipConfig: dh,
    subPixelOptimize: hx,
    subPixelOptimizeLine: Gf,
    subPixelOptimizeRect: Pit,
    transformDirection: E1,
    traverseElements: su,
    updateProps: Ie
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var M1 = {};
  function qU(n, t) {
    for (var e = 0; e < vi.length; e++) {
      var r = vi[e], i = t[r], a = n.ensureState(r);
      a.style = a.style || {}, a.style.text = i;
    }
    var s = n.currentStates.slice();
    n.clearStates(true), n.setStyle({
      text: t.normal
    }), n.useStates(s, true);
  }
  function QI(n, t, e) {
    var r = n.labelFetcher, i = n.labelDataIndex, a = n.labelDimIndex, s = t.normal, o;
    r && (o = r.getFormattedLabel(i, "normal", null, a, s && s.get("formatter"), e != null ? {
      interpolatedValue: e
    } : null)), o == null && (o = Nt(n.defaultText) ? n.defaultText(i, n, e) : n.defaultText);
    for (var l = {
      normal: o
    }, u = 0; u < vi.length; u++) {
      var c = vi[u], h = t[c];
      l[c] = Ht(r ? r.getFormattedLabel(i, c, null, a, h && h.get("formatter")) : null, o);
    }
    return l;
  }
  function kr(n, t, e, r) {
    e = e || M1;
    for (var i = n instanceof be, a = false, s = 0; s < Og.length; s++) {
      var o = t[Og[s]];
      if (o && o.getShallow("show")) {
        a = true;
        break;
      }
    }
    var l = i ? n : n.getTextContent();
    if (a) {
      i || (l || (l = new be(), n.setTextContent(l)), n.stateProxy && (l.stateProxy = n.stateProxy));
      var u = QI(e, t), c = t.normal, h = !!c.getShallow("show"), f = nn(c, r && r.normal, e, false, !i);
      f.text = u.normal, i || n.setTextConfig(jx(c, e, false));
      for (var s = 0; s < vi.length; s++) {
        var d = vi[s], o = t[d];
        if (o) {
          var p = l.ensureState(d), g = !!Ht(o.getShallow("show"), h);
          if (g !== h && (p.ignore = !g), p.style = nn(o, r && r[d], e, true, !i), p.style.text = u[d], !i) {
            var v = n.ensureState(d);
            v.textConfig = jx(o, e, true);
          }
        }
      }
      l.silent = !!c.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !h, l.useStyle(f), l.dirty(), e.enableTextSetter && (wd(l).setLabelText = function(m) {
        var y = QI(e, t, m);
        qU(l, y);
      });
    } else l && (l.ignore = true);
    n.dirty();
  }
  function ur(n, t) {
    t = t || "label";
    for (var e = {
      normal: n.getModel(t)
    }, r = 0; r < vi.length; r++) {
      var i = vi[r];
      e[i] = n.getModel([
        i,
        t
      ]);
    }
    return e;
  }
  function nn(n, t, e, r, i) {
    var a = {};
    return Bit(a, n, e, r, i), t && rt(a, t), a;
  }
  function jx(n, t, e) {
    t = t || {};
    var r = {}, i, a = n.getShallow("rotate"), s = Ht(n.getShallow("distance"), e ? null : 5), o = n.getShallow("offset");
    return i = n.getShallow("position") || (e ? null : "inside"), i === "outside" && (i = t.defaultOutsidePosition || "top"), i != null && (r.position = i), o != null && (r.offset = o), a != null && (a *= Math.PI / 180, r.rotation = a), s != null && (r.distance = s), r.outsideFill = n.get("color") === "inherit" ? t.inheritColor || null : "auto", r;
  }
  function Bit(n, t, e, r, i) {
    e = e || M1;
    var a = t.ecModel, s = a && a.option.textStyle, o = zit(t), l;
    if (o) {
      l = {};
      for (var u in o) if (o.hasOwnProperty(u)) {
        var c = t.getModel([
          "rich",
          u
        ]);
        AP(l[u] = {}, c, s, e, r, i, false, true);
      }
    }
    l && (n.rich = l);
    var h = t.get("overflow");
    h && (n.overflow = h);
    var f = t.get("minMargin");
    f != null && (n.margin = f), AP(n, t, s, e, r, i, true, false);
  }
  function zit(n) {
    for (var t; n && n !== n.ecModel; ) {
      var e = (n.option || M1).rich;
      if (e) {
        t = t || {};
        for (var r = ge(e), i = 0; i < r.length; i++) {
          var a = r[i];
          t[a] = 1;
        }
      }
      n = n.parentModel;
    }
    return t;
  }
  var CP = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "textShadowColor",
    "textShadowBlur",
    "textShadowOffsetX",
    "textShadowOffsetY"
  ], TP = [
    "align",
    "lineHeight",
    "width",
    "height",
    "tag",
    "verticalAlign",
    "ellipsis"
  ], IP = [
    "padding",
    "borderWidth",
    "borderRadius",
    "borderDashOffset",
    "backgroundColor",
    "borderColor",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY"
  ];
  function AP(n, t, e, r, i, a, s, o) {
    e = !i && e || M1;
    var l = r && r.inheritColor, u = t.getShallow("color"), c = t.getShallow("textBorderColor"), h = Ht(t.getShallow("opacity"), e.opacity);
    (u === "inherit" || u === "auto") && (l ? u = l : u = null), (c === "inherit" || c === "auto") && (l ? c = l : c = null), a || (u = u || e.color, c = c || e.textBorderColor), u != null && (n.fill = u), c != null && (n.stroke = c);
    var f = Ht(t.getShallow("textBorderWidth"), e.textBorderWidth);
    f != null && (n.lineWidth = f);
    var d = Ht(t.getShallow("textBorderType"), e.textBorderType);
    d != null && (n.lineDash = d);
    var p = Ht(t.getShallow("textBorderDashOffset"), e.textBorderDashOffset);
    p != null && (n.lineDashOffset = p), !i && h == null && !o && (h = r && r.defaultOpacity), h != null && (n.opacity = h), !i && !a && n.fill == null && r.inheritColor && (n.fill = r.inheritColor);
    for (var g = 0; g < CP.length; g++) {
      var v = CP[g], m = Ht(t.getShallow(v), e[v]);
      m != null && (n[v] = m);
    }
    for (var g = 0; g < TP.length; g++) {
      var v = TP[g], m = t.getShallow(v);
      m != null && (n[v] = m);
    }
    if (n.verticalAlign == null) {
      var y = t.getShallow("baseline");
      y != null && (n.verticalAlign = y);
    }
    if (!s || !r.disableBox) {
      for (var g = 0; g < IP.length; g++) {
        var v = IP[g], m = t.getShallow(v);
        m != null && (n[v] = m);
      }
      var x = t.getShallow("borderType");
      x != null && (n.borderDash = x), (n.backgroundColor === "auto" || n.backgroundColor === "inherit") && l && (n.backgroundColor = l), (n.borderColor === "auto" || n.borderColor === "inherit") && l && (n.borderColor = l);
    }
  }
  function rD(n, t) {
    var e = t && t.getModel("textStyle");
    return ja([
      n.fontStyle || e && e.getShallow("fontStyle") || "",
      n.fontWeight || e && e.getShallow("fontWeight") || "",
      (n.fontSize || e && e.getShallow("fontSize") || 12) + "px",
      n.fontFamily || e && e.getShallow("fontFamily") || "sans-serif"
    ].join(" "));
  }
  var wd = xe();
  function jU(n, t, e, r) {
    if (n) {
      var i = wd(n);
      i.prevValue = i.value, i.value = e;
      var a = t.normal;
      i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = r, i.statesModels = t);
    }
  }
  function KU(n, t, e, r, i) {
    var a = wd(n);
    if (!a.valueAnimation || a.prevValue === a.value) return;
    var s = a.defaultInterpolatedText, o = Ht(a.interpolatedValue, a.prevValue), l = a.value;
    function u(c) {
      var h = fU(e, a.precision, o, l, c);
      a.interpolatedValue = c === 1 ? null : h;
      var f = QI({
        labelDataIndex: t,
        labelFetcher: i,
        defaultText: s ? s(h) : h + ""
      }, a.statesModels, h);
      qU(n, f);
    }
    n.percent = 0, (a.prevValue == null ? dn : Ie)(n, {
      percent: 1
    }, r, t, null, u);
  }
  var Vit = [
    "textStyle",
    "color"
  ], CS = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "padding",
    "lineHeight",
    "rich",
    "width",
    "height",
    "overflow"
  ], TS = new be(), Git = function() {
    function n() {
    }
    return n.prototype.getTextColor = function(t) {
      var e = this.ecModel;
      return this.getShallow("color") || (!t && e ? e.get(Vit) : null);
    }, n.prototype.getFont = function() {
      return rD({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, n.prototype.getTextRect = function(t) {
      for (var e = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, r = 0; r < CS.length; r++) e[CS[r]] = this.getShallow(CS[r]);
      return TS.useStyle(e), TS.update(), TS.getBoundingRect();
    }, n;
  }(), ZU = [
    [
      "lineWidth",
      "width"
    ],
    [
      "stroke",
      "color"
    ],
    [
      "opacity"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ],
    [
      "lineDash",
      "type"
    ],
    [
      "lineDashOffset",
      "dashOffset"
    ],
    [
      "lineCap",
      "cap"
    ],
    [
      "lineJoin",
      "join"
    ],
    [
      "miterLimit"
    ]
  ], Wit = Hc(ZU), Uit = function() {
    function n() {
    }
    return n.prototype.getLineStyle = function(t) {
      return Wit(this, t);
    }, n;
  }(), JU = [
    [
      "fill",
      "color"
    ],
    [
      "stroke",
      "borderColor"
    ],
    [
      "lineWidth",
      "borderWidth"
    ],
    [
      "opacity"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ],
    [
      "lineDash",
      "borderType"
    ],
    [
      "lineDashOffset",
      "borderDashOffset"
    ],
    [
      "lineCap",
      "borderCap"
    ],
    [
      "lineJoin",
      "borderJoin"
    ],
    [
      "miterLimit",
      "borderMiterLimit"
    ]
  ], Hit = Hc(JU), Xit = function() {
    function n() {
    }
    return n.prototype.getItemStyle = function(t, e) {
      return Hit(this, t, e);
    }, n;
  }(), $e = function() {
    function n(t, e, r) {
      this.parentModel = e, this.ecModel = r, this.option = t;
    }
    return n.prototype.init = function(t, e, r) {
    }, n.prototype.mergeOption = function(t, e) {
      Zt(this.option, t, true);
    }, n.prototype.get = function(t, e) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !e && this.parentModel);
    }, n.prototype.getShallow = function(t, e) {
      var r = this.option, i = r == null ? r : r[t];
      if (i == null && !e) {
        var a = this.parentModel;
        a && (i = a.getShallow(t));
      }
      return i;
    }, n.prototype.getModel = function(t, e) {
      var r = t != null, i = r ? this.parsePath(t) : null, a = r ? this._doGet(i) : this.option;
      return e = e || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new n(a, e, this.ecModel);
    }, n.prototype.isEmpty = function() {
      return this.option == null;
    }, n.prototype.restoreData = function() {
    }, n.prototype.clone = function() {
      var t = this.constructor;
      return new t(Bt(this.option));
    }, n.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, n.prototype.resolveParentPath = function(t) {
      return t;
    }, n.prototype.isAnimationEnabled = function() {
      if (!ce.node && this.option) {
        if (this.option.animation != null) return !!this.option.animation;
        if (this.parentModel) return this.parentModel.isAnimationEnabled();
      }
    }, n.prototype._doGet = function(t, e) {
      var r = this.option;
      if (!t) return r;
      for (var i = 0; i < t.length && !(t[i] && (r = r && typeof r == "object" ? r[t[i]] : null, r == null)); i++) ;
      return r == null && e && (r = e._doGet(this.resolveParentPath(t), e.parentModel)), r;
    }, n;
  }();
  Hk($e);
  ert($e);
  zn($e, Uit);
  zn($e, Xit);
  zn($e, srt);
  zn($e, Git);
  var Yit = Math.round(Math.random() * 10);
  function Sd(n) {
    return [
      n || "",
      Yit++
    ].join("_");
  }
  function qit(n) {
    var t = {};
    n.registerSubTypeDefaulter = function(e, r) {
      var i = Bs(e);
      t[i.main] = r;
    }, n.determineSubType = function(e, r) {
      var i = r.type;
      if (!i) {
        var a = Bs(e).main;
        n.hasSubTypes(e) && t[a] && (i = t[a](r));
      }
      return i;
    };
  }
  function jit(n, t) {
    n.topologicalTravel = function(a, s, o, l) {
      if (!a.length) return;
      var u = e(s), c = u.graph, h = u.noEntryList, f = {};
      for (P(a, function(y) {
        f[y] = true;
      }); h.length; ) {
        var d = h.pop(), p = c[d], g = !!f[d];
        g && (o.call(l, d, p.originalDeps.slice()), delete f[d]), P(p.successor, g ? m : v);
      }
      P(f, function() {
        var y = "";
        throw new Error(y);
      });
      function v(y) {
        c[y].entryCount--, c[y].entryCount === 0 && h.push(y);
      }
      function m(y) {
        f[y] = true, v(y);
      }
    };
    function e(a) {
      var s = {}, o = [];
      return P(a, function(l) {
        var u = r(s, l), c = u.originalDeps = t(l), h = i(c, a);
        u.entryCount = h.length, u.entryCount === 0 && o.push(l), P(h, function(f) {
          ne(u.predecessor, f) < 0 && u.predecessor.push(f);
          var d = r(s, f);
          ne(d.successor, f) < 0 && d.successor.push(l);
        });
      }), {
        graph: s,
        noEntryList: o
      };
    }
    function r(a, s) {
      return a[s] || (a[s] = {
        predecessor: [],
        successor: []
      }), a[s];
    }
    function i(a, s) {
      var o = [];
      return P(a, function(l) {
        ne(s, l) >= 0 && o.push(l);
      }), o;
    }
  }
  function ou(n, t) {
    return Zt(Zt({}, n, true), t, true);
  }
  const Kit = {
    time: {
      month: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ],
      monthAbbr: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      dayOfWeek: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ],
      dayOfWeekAbbr: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ]
    },
    legend: {
      selector: {
        all: "All",
        inverse: "Inv"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "Box Select",
          polygon: "Lasso Select",
          lineX: "Horizontally Select",
          lineY: "Vertically Select",
          keep: "Keep Selections",
          clear: "Clear Selections"
        }
      },
      dataView: {
        title: "Data View",
        lang: [
          "Data View",
          "Close",
          "Refresh"
        ]
      },
      dataZoom: {
        title: {
          zoom: "Zoom",
          back: "Zoom Reset"
        }
      },
      magicType: {
        title: {
          line: "Switch to Line Chart",
          bar: "Switch to Bar Chart",
          stack: "Stack",
          tiled: "Tile"
        }
      },
      restore: {
        title: "Restore"
      },
      saveAsImage: {
        title: "Save as Image",
        lang: [
          "Right Click to Save Image"
        ]
      }
    },
    series: {
      typeNames: {
        pie: "Pie chart",
        bar: "Bar chart",
        line: "Line chart",
        scatter: "Scatter plot",
        effectScatter: "Ripple scatter plot",
        radar: "Radar chart",
        tree: "Tree",
        treemap: "Treemap",
        boxplot: "Boxplot",
        candlestick: "Candlestick",
        k: "K line chart",
        heatmap: "Heat map",
        map: "Map",
        parallel: "Parallel coordinate map",
        lines: "Line graph",
        graph: "Relationship graph",
        sankey: "Sankey diagram",
        funnel: "Funnel chart",
        gauge: "Gauge",
        pictorialBar: "Pictorial bar",
        themeRiver: "Theme River Map",
        sunburst: "Sunburst",
        custom: "Custom chart",
        chart: "Chart"
      }
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: "This is a chart"
      },
      series: {
        single: {
          prefix: "",
          withName: " with type {seriesType} named {seriesName}.",
          withoutName: " with type {seriesType}."
        },
        multiple: {
          prefix: ". It consists of {seriesCount} series count.",
          withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
          withoutName: " The {seriesId} series is a {seriesType}.",
          separator: {
            middle: "",
            end: ""
          }
        }
      },
      data: {
        allData: "The data is as follows: ",
        partialData: "The first {displayCnt} items are: ",
        withName: "the data for {name} is {value}",
        withoutName: "{value}",
        separator: {
          middle: ", ",
          end: ". "
        }
      }
    }
  }, Zit = {
    time: {
      month: [
        "\u4E00\u6708",
        "\u4E8C\u6708",
        "\u4E09\u6708",
        "\u56DB\u6708",
        "\u4E94\u6708",
        "\u516D\u6708",
        "\u4E03\u6708",
        "\u516B\u6708",
        "\u4E5D\u6708",
        "\u5341\u6708",
        "\u5341\u4E00\u6708",
        "\u5341\u4E8C\u6708"
      ],
      monthAbbr: [
        "1\u6708",
        "2\u6708",
        "3\u6708",
        "4\u6708",
        "5\u6708",
        "6\u6708",
        "7\u6708",
        "8\u6708",
        "9\u6708",
        "10\u6708",
        "11\u6708",
        "12\u6708"
      ],
      dayOfWeek: [
        "\u661F\u671F\u65E5",
        "\u661F\u671F\u4E00",
        "\u661F\u671F\u4E8C",
        "\u661F\u671F\u4E09",
        "\u661F\u671F\u56DB",
        "\u661F\u671F\u4E94",
        "\u661F\u671F\u516D"
      ],
      dayOfWeekAbbr: [
        "\u65E5",
        "\u4E00",
        "\u4E8C",
        "\u4E09",
        "\u56DB",
        "\u4E94",
        "\u516D"
      ]
    },
    legend: {
      selector: {
        all: "\u5168\u9009",
        inverse: "\u53CD\u9009"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "\u77E9\u5F62\u9009\u62E9",
          polygon: "\u5708\u9009",
          lineX: "\u6A2A\u5411\u9009\u62E9",
          lineY: "\u7EB5\u5411\u9009\u62E9",
          keep: "\u4FDD\u6301\u9009\u62E9",
          clear: "\u6E05\u9664\u9009\u62E9"
        }
      },
      dataView: {
        title: "\u6570\u636E\u89C6\u56FE",
        lang: [
          "\u6570\u636E\u89C6\u56FE",
          "\u5173\u95ED",
          "\u5237\u65B0"
        ]
      },
      dataZoom: {
        title: {
          zoom: "\u533A\u57DF\u7F29\u653E",
          back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
        }
      },
      magicType: {
        title: {
          line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
          bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
          stack: "\u5207\u6362\u4E3A\u5806\u53E0",
          tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
        }
      },
      restore: {
        title: "\u8FD8\u539F"
      },
      saveAsImage: {
        title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
        lang: [
          "\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"
        ]
      }
    },
    series: {
      typeNames: {
        pie: "\u997C\u56FE",
        bar: "\u67F1\u72B6\u56FE",
        line: "\u6298\u7EBF\u56FE",
        scatter: "\u6563\u70B9\u56FE",
        effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
        radar: "\u96F7\u8FBE\u56FE",
        tree: "\u6811\u56FE",
        treemap: "\u77E9\u5F62\u6811\u56FE",
        boxplot: "\u7BB1\u578B\u56FE",
        candlestick: "K\u7EBF\u56FE",
        k: "K\u7EBF\u56FE",
        heatmap: "\u70ED\u529B\u56FE",
        map: "\u5730\u56FE",
        parallel: "\u5E73\u884C\u5750\u6807\u56FE",
        lines: "\u7EBF\u56FE",
        graph: "\u5173\u7CFB\u56FE",
        sankey: "\u6851\u57FA\u56FE",
        funnel: "\u6F0F\u6597\u56FE",
        gauge: "\u4EEA\u8868\u76D8\u56FE",
        pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
        themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
        sunburst: "\u65ED\u65E5\u56FE",
        custom: "\u81EA\u5B9A\u4E49\u56FE\u8868",
        chart: "\u56FE\u8868"
      }
    },
    aria: {
      general: {
        withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
        withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
      },
      series: {
        single: {
          prefix: "",
          withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
          withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
        },
        multiple: {
          prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
          withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
          withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
          separator: {
            middle: "\uFF1B",
            end: "\u3002"
          }
        }
      },
      data: {
        allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
        partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
        withName: "{name}\u7684\u6570\u636E\u662F{value}",
        withoutName: "{value}",
        separator: {
          middle: "\uFF0C",
          end: ""
        }
      }
    }
  };
  var Kx = "ZH", iD = "EN", Ef = iD, fx = {}, aD = {}, QU = ce.domSupported ? function() {
    var n = (document.documentElement.lang || navigator.language || navigator.browserLanguage || Ef).toUpperCase();
    return n.indexOf(Kx) > -1 ? Kx : Ef;
  }() : Ef;
  function t5(n, t) {
    n = n.toUpperCase(), aD[n] = new $e(t), fx[n] = t;
  }
  function Jit(n) {
    if (wt(n)) {
      var t = fx[n.toUpperCase()] || {};
      return n === Kx || n === iD ? Bt(t) : Zt(Bt(t), Bt(fx[Ef]), false);
    } else return Zt(Bt(n), Bt(fx[Ef]), false);
  }
  function tA(n) {
    return aD[n];
  }
  function Qit() {
    return aD[Ef];
  }
  t5(iD, Kit);
  t5(Kx, Zit);
  var sD = 1e3, oD = sD * 60, gg = oD * 60, xa = gg * 24, kP = xa * 365, Gp = {
    year: "{yyyy}",
    month: "{MMM}",
    day: "{d}",
    hour: "{HH}:{mm}",
    minute: "{HH}:{mm}",
    second: "{HH}:{mm}:{ss}",
    millisecond: "{HH}:{mm}:{ss} {SSS}",
    none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
  }, Oy = "{yyyy}-{MM}-{dd}", DP = {
    year: "{yyyy}",
    month: "{yyyy}-{MM}",
    day: Oy,
    hour: Oy + " " + Gp.hour,
    minute: Oy + " " + Gp.minute,
    second: Oy + " " + Gp.second,
    millisecond: Gp.none
  }, IS = [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ], e5 = [
    "year",
    "half-year",
    "quarter",
    "month",
    "week",
    "half-week",
    "day",
    "half-day",
    "quarter-day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  function ll(n, t) {
    return n += "", "0000".substr(0, t - n.length) + n;
  }
  function Mf(n) {
    switch (n) {
      case "half-year":
      case "quarter":
        return "month";
      case "week":
      case "half-week":
        return "day";
      case "half-day":
      case "quarter-day":
        return "hour";
      default:
        return n;
    }
  }
  function tat(n) {
    return n === Mf(n);
  }
  function eat(n) {
    switch (n) {
      case "year":
      case "month":
        return "day";
      case "millisecond":
        return "millisecond";
      default:
        return "second";
    }
  }
  function R1(n, t, e, r) {
    var i = no(n), a = i[lD(e)](), s = i[Rf(e)]() + 1, o = Math.floor((s - 1) / 3) + 1, l = i[N1(e)](), u = i["get" + (e ? "UTC" : "") + "Day"](), c = i[zg(e)](), h = (c - 1) % 12 + 1, f = i[L1(e)](), d = i[P1(e)](), p = i[$1(e)](), g = c >= 12 ? "pm" : "am", v = g.toUpperCase(), m = r instanceof $e ? r : tA(r || QU) || Qit(), y = m.getModel("time"), x = y.get("month"), b = y.get("monthAbbr"), _ = y.get("dayOfWeek"), w = y.get("dayOfWeekAbbr");
    return (t || "").replace(/{a}/g, g + "").replace(/{A}/g, v + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, ll(a % 100 + "", 2)).replace(/{Q}/g, o + "").replace(/{MMMM}/g, x[s - 1]).replace(/{MMM}/g, b[s - 1]).replace(/{MM}/g, ll(s, 2)).replace(/{M}/g, s + "").replace(/{dd}/g, ll(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, _[u]).replace(/{ee}/g, w[u]).replace(/{e}/g, u + "").replace(/{HH}/g, ll(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, ll(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, ll(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, ll(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, ll(p, 3)).replace(/{S}/g, p + "");
  }
  function nat(n, t, e, r, i) {
    var a = null;
    if (wt(e)) a = e;
    else if (Nt(e)) a = e(n.value, t, {
      level: n.level
    });
    else {
      var s = rt({}, Gp);
      if (n.level > 0) for (var o = 0; o < IS.length; ++o) s[IS[o]] = "{primary|" + s[IS[o]] + "}";
      var l = e ? e.inherit === false ? e : $t(e, s) : s, u = n5(n.value, i);
      if (l[u]) a = l[u];
      else if (l.inherit) {
        for (var c = e5.indexOf(u), o = c - 1; o >= 0; --o) if (l[u]) {
          a = l[u];
          break;
        }
        a = a || s.none;
      }
      if (ct(a)) {
        var h = n.level == null ? 0 : n.level >= 0 ? n.level : a.length + n.level;
        h = Math.min(h, a.length - 1), a = a[h];
      }
    }
    return R1(new Date(n.value), a, i, r);
  }
  function n5(n, t) {
    var e = no(n), r = e[Rf(t)]() + 1, i = e[N1(t)](), a = e[zg(t)](), s = e[L1(t)](), o = e[P1(t)](), l = e[$1(t)](), u = l === 0, c = u && o === 0, h = c && s === 0, f = h && a === 0, d = f && i === 1, p = d && r === 1;
    return p ? "year" : d ? "month" : f ? "day" : h ? "hour" : c ? "minute" : u ? "second" : "millisecond";
  }
  function EP(n, t, e) {
    var r = _e(n) ? no(n) : n;
    switch (t = t || n5(n, e), t) {
      case "year":
        return r[lD(e)]();
      case "half-year":
        return r[Rf(e)]() >= 6 ? 1 : 0;
      case "quarter":
        return Math.floor((r[Rf(e)]() + 1) / 4);
      case "month":
        return r[Rf(e)]();
      case "day":
        return r[N1(e)]();
      case "half-day":
        return r[zg(e)]() / 24;
      case "hour":
        return r[zg(e)]();
      case "minute":
        return r[L1(e)]();
      case "second":
        return r[P1(e)]();
      case "millisecond":
        return r[$1(e)]();
    }
  }
  function lD(n) {
    return n ? "getUTCFullYear" : "getFullYear";
  }
  function Rf(n) {
    return n ? "getUTCMonth" : "getMonth";
  }
  function N1(n) {
    return n ? "getUTCDate" : "getDate";
  }
  function zg(n) {
    return n ? "getUTCHours" : "getHours";
  }
  function L1(n) {
    return n ? "getUTCMinutes" : "getMinutes";
  }
  function P1(n) {
    return n ? "getUTCSeconds" : "getSeconds";
  }
  function $1(n) {
    return n ? "getUTCMilliseconds" : "getMilliseconds";
  }
  function rat(n) {
    return n ? "setUTCFullYear" : "setFullYear";
  }
  function r5(n) {
    return n ? "setUTCMonth" : "setMonth";
  }
  function i5(n) {
    return n ? "setUTCDate" : "setDate";
  }
  function a5(n) {
    return n ? "setUTCHours" : "setHours";
  }
  function s5(n) {
    return n ? "setUTCMinutes" : "setMinutes";
  }
  function o5(n) {
    return n ? "setUTCSeconds" : "setSeconds";
  }
  function l5(n) {
    return n ? "setUTCMilliseconds" : "setMilliseconds";
  }
  function u5(n) {
    if (!iU(n)) return wt(n) ? n : "-";
    var t = (n + "").split(".");
    return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
  }
  function c5(n, t) {
    return n = (n || "").toLowerCase().replace(/-(.)/g, function(e, r) {
      return r.toUpperCase();
    }), t && n && (n = n.charAt(0).toUpperCase() + n.slice(1)), n;
  }
  var Cd = Pk;
  function eA(n, t, e) {
    var r = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
    function i(c) {
      return c && ja(c) ? c : "-";
    }
    function a(c) {
      return !!(c != null && !isNaN(c) && isFinite(c));
    }
    var s = t === "time", o = n instanceof Date;
    if (s || o) {
      var l = s ? no(n) : n;
      if (isNaN(+l)) {
        if (o) return "-";
      } else return R1(l, r, e);
    }
    if (t === "ordinal") return xI(n) ? i(n) : _e(n) && a(n) ? n + "" : "-";
    var u = zo(n);
    return a(u) ? u5(u) : xI(n) ? i(n) : typeof n == "boolean" ? n + "" : "-";
  }
  var MP = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g"
  ], AS = function(n, t) {
    return "{" + n + (t ?? "") + "}";
  };
  function h5(n, t, e) {
    ct(t) || (t = [
      t
    ]);
    var r = t.length;
    if (!r) return "";
    for (var i = t[0].$vars || [], a = 0; a < i.length; a++) {
      var s = MP[a];
      n = n.replace(AS(s), AS(s, 0));
    }
    for (var o = 0; o < r; o++) for (var l = 0; l < i.length; l++) {
      var u = t[o][i[l]];
      n = n.replace(AS(MP[l], o), e ? oi(u) : u);
    }
    return n;
  }
  function iat(n, t, e) {
    return P(t, function(r, i) {
      n = n.replace("{" + i + "}", r);
    }), n;
  }
  function aat(n, t) {
    var e = wt(n) ? {
      color: n,
      extraCssText: t
    } : n || {}, r = e.color, i = e.type;
    t = e.extraCssText;
    var a = e.renderMode || "html";
    if (!r) return "";
    if (a === "html") return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + oi(r) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + oi(r) + ";" + (t || "") + '"></span>';
    var s = e.markerId || "markerX";
    return {
      renderMode: a,
      content: "{" + s + "|}  ",
      style: i === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: r
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: r
      }
    };
  }
  function Yc(n, t) {
    return t = t || "transparent", wt(n) ? n : Ft(n) && n.colorStops && (n.colorStops[0] || {}).color || t;
  }
  function Zx(n, t) {
    if (t === "_blank" || t === "blank") {
      var e = window.open();
      e.opener = null, e.location.href = n;
    } else window.open(n, t);
  }
  var dx = P, f5 = [
    "left",
    "right",
    "top",
    "bottom",
    "width",
    "height"
  ], xc = [
    [
      "width",
      "left",
      "right"
    ],
    [
      "height",
      "top",
      "bottom"
    ]
  ];
  function uD(n, t, e, r, i) {
    var a = 0, s = 0;
    r == null && (r = 1 / 0), i == null && (i = 1 / 0);
    var o = 0;
    t.eachChild(function(l, u) {
      var c = l.getBoundingRect(), h = t.childAt(u + 1), f = h && h.getBoundingRect(), d, p;
      if (n === "horizontal") {
        var g = c.width + (f ? -f.x + c.x : 0);
        d = a + g, d > r || l.newline ? (a = 0, d = g, s += o + e, o = c.height) : o = Math.max(o, c.height);
      } else {
        var v = c.height + (f ? -f.y + c.y : 0);
        p = s + v, p > i || l.newline ? (a += o + e, s = 0, p = v, o = c.width) : o = Math.max(o, c.width);
      }
      l.newline || (l.x = a, l.y = s, l.markRedraw(), n === "horizontal" ? a = d + e : s = p + e);
    });
  }
  var Pc = uD;
  qt(uD, "vertical");
  qt(uD, "horizontal");
  function sat(n, t, e) {
    var r = t.width, i = t.height, a = yt(n.left, r), s = yt(n.top, i), o = yt(n.right, r), l = yt(n.bottom, i);
    return (isNaN(a) || isNaN(parseFloat(n.left))) && (a = 0), (isNaN(o) || isNaN(parseFloat(n.right))) && (o = r), (isNaN(s) || isNaN(parseFloat(n.top))) && (s = 0), (isNaN(l) || isNaN(parseFloat(n.bottom))) && (l = i), e = Cd(e || 0), {
      width: Math.max(o - a - e[1] - e[3], 0),
      height: Math.max(l - s - e[0] - e[2], 0)
    };
  }
  function Zn(n, t, e) {
    e = Cd(e || 0);
    var r = t.width, i = t.height, a = yt(n.left, r), s = yt(n.top, i), o = yt(n.right, r), l = yt(n.bottom, i), u = yt(n.width, r), c = yt(n.height, i), h = e[2] + e[0], f = e[1] + e[3], d = n.aspect;
    switch (isNaN(u) && (u = r - o - f - a), isNaN(c) && (c = i - l - h - s), d != null && (isNaN(u) && isNaN(c) && (d > r / i ? u = r * 0.8 : c = i * 0.8), isNaN(u) && (u = d * c), isNaN(c) && (c = u / d)), isNaN(a) && (a = r - o - u - f), isNaN(s) && (s = i - l - c - h), n.left || n.right) {
      case "center":
        a = r / 2 - u / 2 - e[3];
        break;
      case "right":
        a = r - u - f;
        break;
    }
    switch (n.top || n.bottom) {
      case "middle":
      case "center":
        s = i / 2 - c / 2 - e[0];
        break;
      case "bottom":
        s = i - c - h;
        break;
    }
    a = a || 0, s = s || 0, isNaN(u) && (u = r - f - a - (o || 0)), isNaN(c) && (c = i - h - s - (l || 0));
    var p = new te(a + e[3], s + e[0], u, c);
    return p.margin = e, p;
  }
  function O1(n, t, e, r, i, a) {
    var s = !i || !i.hv || i.hv[0], o = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
    if (a = a || n, a.x = n.x, a.y = n.y, !s && !o) return false;
    var u;
    if (l === "raw") u = n.type === "group" ? new te(0, 0, +t.width || 0, +t.height || 0) : n.getBoundingRect();
    else if (u = n.getBoundingRect(), n.needLocalTransform()) {
      var c = n.getLocalTransform();
      u = u.clone(), u.applyTransform(c);
    }
    var h = Zn($t({
      width: u.width,
      height: u.height
    }, t), e, r), f = s ? h.x - u.x : 0, d = o ? h.y - u.y : 0;
    return l === "raw" ? (a.x = f, a.y = d) : (a.x += f, a.y += d), a === n && n.markRedraw(), true;
  }
  function oat(n, t) {
    return n[xc[t][0]] != null || n[xc[t][1]] != null && n[xc[t][2]] != null;
  }
  function Vg(n) {
    var t = n.layoutMode || n.constructor.layoutMode;
    return Ft(t) ? t : t ? {
      type: t
    } : null;
  }
  function jl(n, t, e) {
    var r = e && e.ignoreSize;
    !ct(r) && (r = [
      r,
      r
    ]);
    var i = s(xc[0], 0), a = s(xc[1], 1);
    u(xc[0], n, i), u(xc[1], n, a);
    function s(c, h) {
      var f = {}, d = 0, p = {}, g = 0, v = 2;
      if (dx(c, function(x) {
        p[x] = n[x];
      }), dx(c, function(x) {
        o(t, x) && (f[x] = p[x] = t[x]), l(f, x) && d++, l(p, x) && g++;
      }), r[h]) return l(t, c[1]) ? p[c[2]] = null : l(t, c[2]) && (p[c[1]] = null), p;
      if (g === v || !d) return p;
      if (d >= v) return f;
      for (var m = 0; m < c.length; m++) {
        var y = c[m];
        if (!o(f, y) && o(n, y)) {
          f[y] = n[y];
          break;
        }
      }
      return f;
    }
    function o(c, h) {
      return c.hasOwnProperty(h);
    }
    function l(c, h) {
      return c[h] != null && c[h] !== "auto";
    }
    function u(c, h, f) {
      dx(c, function(d) {
        h[d] = f[d];
      });
    }
  }
  function Td(n) {
    return d5({}, n);
  }
  function d5(n, t) {
    return t && n && dx(f5, function(e) {
      t.hasOwnProperty(e) && (n[e] = t[e]);
    }), n;
  }
  var lat = xe(), pe = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this, e, r, i) || this;
      return a.uid = Sd("ec_cpt_model"), a;
    }
    return t.prototype.init = function(e, r, i) {
      this.mergeDefaultAndTheme(e, i);
    }, t.prototype.mergeDefaultAndTheme = function(e, r) {
      var i = Vg(this), a = i ? Td(e) : {}, s = r.getTheme();
      Zt(e, s.get(this.mainType)), Zt(e, this.getDefaultOption()), i && jl(e, a, i);
    }, t.prototype.mergeOption = function(e, r) {
      Zt(this.option, e, true);
      var i = Vg(this);
      i && jl(this.option, e, i);
    }, t.prototype.optionUpdated = function(e, r) {
    }, t.prototype.getDefaultOption = function() {
      var e = this.constructor;
      if (!Jnt(e)) return e.defaultOption;
      var r = lat(this);
      if (!r.defaultOption) {
        for (var i = [], a = e; a; ) {
          var s = a.prototype.defaultOption;
          s && i.push(s), a = a.superClass;
        }
        for (var o = {}, l = i.length - 1; l >= 0; l--) o = Zt(o, i[l], true);
        r.defaultOption = o;
      }
      return r.defaultOption;
    }, t.prototype.getReferringComponents = function(e, r) {
      var i = e + "Index", a = e + "Id";
      return Rv(this.ecModel, e, {
        index: this.get(i, true),
        id: this.get(a, true)
      }, r);
    }, t.prototype.getBoxLayoutParams = function() {
      var e = this;
      return {
        left: e.get("left"),
        top: e.get("top"),
        right: e.get("right"),
        bottom: e.get("bottom"),
        width: e.get("width"),
        height: e.get("height")
      };
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(e) {
      this.option.zlevel = e;
    }, t.protoInitialize = function() {
      var e = t.prototype;
      e.type = "component", e.id = "", e.name = "", e.mainType = "", e.subType = "", e.componentIndex = 0;
    }(), t;
  }($e);
  pU(pe, $e);
  _1(pe);
  qit(pe);
  jit(pe, uat);
  function uat(n) {
    var t = [];
    return P(pe.getClassesByMainType(n), function(e) {
      t = t.concat(e.dependencies || e.prototype.dependencies || []);
    }), t = ht(t, function(e) {
      return Bs(e).main;
    }), n !== "dataset" && ne(t, "dataset") <= 0 && t.unshift("dataset"), t;
  }
  var p5 = "";
  typeof navigator < "u" && (p5 = navigator.platform || "");
  var Bh = "rgba(0, 0, 0, 0.2)";
  const cat = {
    darkMode: "auto",
    colorBy: "series",
    color: [
      "#5470c6",
      "#91cc75",
      "#fac858",
      "#ee6666",
      "#73c0de",
      "#3ba272",
      "#fc8452",
      "#9a60b4",
      "#ea7ccc"
    ],
    gradientColor: [
      "#f6efa6",
      "#d88273",
      "#bf444c"
    ],
    aria: {
      decal: {
        decals: [
          {
            color: Bh,
            dashArrayX: [
              1,
              0
            ],
            dashArrayY: [
              2,
              5
            ],
            symbolSize: 1,
            rotation: Math.PI / 6
          },
          {
            color: Bh,
            symbol: "circle",
            dashArrayX: [
              [
                8,
                8
              ],
              [
                0,
                8,
                8,
                0
              ]
            ],
            dashArrayY: [
              6,
              0
            ],
            symbolSize: 0.8
          },
          {
            color: Bh,
            dashArrayX: [
              1,
              0
            ],
            dashArrayY: [
              4,
              3
            ],
            rotation: -Math.PI / 4
          },
          {
            color: Bh,
            dashArrayX: [
              [
                6,
                6
              ],
              [
                0,
                6,
                6,
                0
              ]
            ],
            dashArrayY: [
              6,
              0
            ]
          },
          {
            color: Bh,
            dashArrayX: [
              [
                1,
                0
              ],
              [
                1,
                6
              ]
            ],
            dashArrayY: [
              1,
              0,
              6,
              0
            ],
            rotation: Math.PI / 4
          },
          {
            color: Bh,
            symbol: "triangle",
            dashArrayX: [
              [
                9,
                9
              ],
              [
                0,
                9,
                9,
                0
              ]
            ],
            dashArrayY: [
              7,
              2
            ],
            symbolSize: 0.75
          }
        ]
      }
    },
    textStyle: {
      fontFamily: p5.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
      fontSize: 12,
      fontStyle: "normal",
      fontWeight: "normal"
    },
    blendMode: null,
    stateAnimation: {
      duration: 300,
      easing: "cubicOut"
    },
    animation: "auto",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut",
    animationEasingUpdate: "cubicInOut",
    animationThreshold: 2e3,
    progressiveThreshold: 3e3,
    progressive: 400,
    hoverLayerThreshold: 3e3,
    useUTC: false
  };
  var g5 = It([
    "tooltip",
    "label",
    "itemName",
    "itemId",
    "itemGroupId",
    "itemChildGroupId",
    "seriesName"
  ]), Ea = "original", Zr = "arrayRows", Ma = "objectRows", uo = "keyedColumns", Ol = "typedArray", v5 = "unknown", Hs = "column", Id = "row", Cr = {
    Must: 1,
    Might: 2,
    Not: 3
  }, m5 = xe();
  function hat(n) {
    m5(n).datasetMap = It();
  }
  function y5(n, t, e) {
    var r = {}, i = hD(t);
    if (!i || !n) return r;
    var a = [], s = [], o = t.ecModel, l = m5(o).datasetMap, u = i.uid + "_" + e.seriesLayoutBy, c, h;
    n = n.slice(), P(n, function(g, v) {
      var m = Ft(g) ? g : n[v] = {
        name: g
      };
      m.type === "ordinal" && c == null && (c = v, h = p(m)), r[m.name] = [];
    });
    var f = l.get(u) || l.set(u, {
      categoryWayDim: h,
      valueWayDim: 0
    });
    P(n, function(g, v) {
      var m = g.name, y = p(g);
      if (c == null) {
        var x = f.valueWayDim;
        d(r[m], x, y), d(s, x, y), f.valueWayDim += y;
      } else if (c === v) d(r[m], 0, y), d(a, 0, y);
      else {
        var x = f.categoryWayDim;
        d(r[m], x, y), d(s, x, y), f.categoryWayDim += y;
      }
    });
    function d(g, v, m) {
      for (var y = 0; y < m; y++) g.push(v + y);
    }
    function p(g) {
      var v = g.dimsDef;
      return v ? v.length : 1;
    }
    return a.length && (r.itemName = a), s.length && (r.seriesName = s), r;
  }
  function cD(n, t, e) {
    var r = {}, i = hD(n);
    if (!i) return r;
    var a = t.sourceFormat, s = t.dimensionsDefine, o;
    (a === Ma || a === uo) && P(s, function(c, h) {
      (Ft(c) ? c.name : c) === "name" && (o = h);
    });
    var l = function() {
      for (var c = {}, h = {}, f = [], d = 0, p = Math.min(5, e); d < p; d++) {
        var g = b5(t.data, a, t.seriesLayoutBy, s, t.startIndex, d);
        f.push(g);
        var v = g === Cr.Not;
        if (v && c.v == null && d !== o && (c.v = d), (c.n == null || c.n === c.v || !v && f[c.n] === Cr.Not) && (c.n = d), m(c) && f[c.n] !== Cr.Not) return c;
        v || (g === Cr.Might && h.v == null && d !== o && (h.v = d), (h.n == null || h.n === h.v) && (h.n = d));
      }
      function m(y) {
        return y.v != null && y.n != null;
      }
      return m(c) ? c : m(h) ? h : null;
    }();
    if (l) {
      r.value = [
        l.v
      ];
      var u = o ?? l.n;
      r.itemName = [
        u
      ], r.seriesName = [
        u
      ];
    }
    return r;
  }
  function hD(n) {
    var t = n.get("data", true);
    if (!t) return Rv(n.ecModel, "dataset", {
      index: n.get("datasetIndex", true),
      id: n.get("datasetId", true)
    }, On).models[0];
  }
  function fat(n) {
    return !n.get("transform", true) && !n.get("fromTransformResult", true) ? [] : Rv(n.ecModel, "dataset", {
      index: n.get("fromDatasetIndex", true),
      id: n.get("fromDatasetId", true)
    }, On).models;
  }
  function x5(n, t) {
    return b5(n.data, n.sourceFormat, n.seriesLayoutBy, n.dimensionsDefine, n.startIndex, t);
  }
  function b5(n, t, e, r, i, a) {
    var s, o = 5;
    if (Pi(n)) return Cr.Not;
    var l, u;
    if (r) {
      var c = r[a];
      Ft(c) ? (l = c.name, u = c.type) : wt(c) && (l = c);
    }
    if (u != null) return u === "ordinal" ? Cr.Must : Cr.Not;
    if (t === Zr) {
      var h = n;
      if (e === Id) {
        for (var f = h[a], d = 0; d < (f || []).length && d < o; d++) if ((s = b(f[i + d])) != null) return s;
      } else for (var d = 0; d < h.length && d < o; d++) {
        var p = h[i + d];
        if (p && (s = b(p[a])) != null) return s;
      }
    } else if (t === Ma) {
      var g = n;
      if (!l) return Cr.Not;
      for (var d = 0; d < g.length && d < o; d++) {
        var v = g[d];
        if (v && (s = b(v[l])) != null) return s;
      }
    } else if (t === uo) {
      var m = n;
      if (!l) return Cr.Not;
      var f = m[l];
      if (!f || Pi(f)) return Cr.Not;
      for (var d = 0; d < f.length && d < o; d++) if ((s = b(f[d])) != null) return s;
    } else if (t === Ea) for (var y = n, d = 0; d < y.length && d < o; d++) {
      var v = y[d], x = xd(v);
      if (!ct(x)) return Cr.Not;
      if ((s = b(x[a])) != null) return s;
    }
    function b(_) {
      var w = wt(_);
      if (_ != null && Number.isFinite(Number(_)) && _ !== "") return w ? Cr.Might : Cr.Not;
      if (w && _ !== "-") return Cr.Must;
    }
    return Cr.Not;
  }
  var nA = It();
  function dat(n, t) {
    gi(nA.get(n) == null && t), nA.set(n, t);
  }
  function pat(n, t, e) {
    var r = nA.get(t);
    if (!r) return e;
    var i = r(n);
    return i ? e.concat(i) : e;
  }
  var RP = xe(), gat = xe(), fD = function() {
    function n() {
    }
    return n.prototype.getColorFromPalette = function(t, e, r) {
      var i = He(this.get("color", true)), a = this.get("colorLayer", true);
      return _5(this, RP, i, a, t, e, r);
    }, n.prototype.clearColorPalette = function() {
      mat(this, RP);
    }, n;
  }();
  function rA(n, t, e, r) {
    var i = He(n.get([
      "aria",
      "decal",
      "decals"
    ]));
    return _5(n, gat, i, null, t, e, r);
  }
  function vat(n, t) {
    for (var e = n.length, r = 0; r < e; r++) if (n[r].length > t) return n[r];
    return n[e - 1];
  }
  function _5(n, t, e, r, i, a, s) {
    a = a || n;
    var o = t(a), l = o.paletteIdx || 0, u = o.paletteNameMap = o.paletteNameMap || {};
    if (u.hasOwnProperty(i)) return u[i];
    var c = s == null || !r ? e : vat(r, s);
    if (c = c || e, !(!c || !c.length)) {
      var h = c[l];
      return i && (u[i] = h), o.paletteIdx = (l + 1) % c.length, h;
    }
  }
  function mat(n, t) {
    t(n).paletteIdx = 0, t(n).paletteNameMap = {};
  }
  var Fy, sp, NP, LP = "\0_ec_inner", yat = 1, dD = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.init = function(e, r, i, a, s, o) {
      a = a || {}, this.option = null, this._theme = new $e(a), this._locale = new $e(s), this._optionManager = o;
    }, t.prototype.setOption = function(e, r, i) {
      var a = OP(r);
      this._optionManager.setOption(e, i, a), this._resetOption(null, a);
    }, t.prototype.resetOption = function(e, r) {
      return this._resetOption(e, OP(r));
    }, t.prototype._resetOption = function(e, r) {
      var i = false, a = this._optionManager;
      if (!e || e === "recreate") {
        var s = a.mountOption(e === "recreate");
        !this.option || e === "recreate" ? NP(this, s) : (this.restoreData(), this._mergeOption(s, r)), i = true;
      }
      if ((e === "timeline" || e === "media") && this.restoreData(), !e || e === "recreate" || e === "timeline") {
        var o = a.getTimelineOption(this);
        o && (i = true, this._mergeOption(o, r));
      }
      if (!e || e === "recreate" || e === "media") {
        var l = a.getMediaOption(this);
        l.length && P(l, function(u) {
          i = true, this._mergeOption(u, r);
        }, this);
      }
      return i;
    }, t.prototype.mergeOption = function(e) {
      this._mergeOption(e, null);
    }, t.prototype._mergeOption = function(e, r) {
      var i = this.option, a = this._componentsMap, s = this._componentsCount, o = [], l = It(), u = r && r.replaceMergeMainTypeMap;
      hat(this), P(e, function(h, f) {
        h != null && (pe.hasClass(f) ? f && (o.push(f), l.set(f, true)) : i[f] = i[f] == null ? Bt(h) : Zt(i[f], h, true));
      }), u && u.each(function(h, f) {
        pe.hasClass(f) && !l.get(f) && (o.push(f), l.set(f, true));
      }), pe.topologicalTravel(o, pe.getAllClassMainTypes(), c, this);
      function c(h) {
        var f = pat(this, h, He(e[h])), d = a.get(h), p = d ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll", g = uU(d, f, p);
        Wnt(g, h, pe), i[h] = null, a.set(h, null), s.set(h, 0);
        var v = [], m = [], y = 0, x;
        P(g, function(b, _) {
          var w = b.existing, S = b.newOption;
          if (!S) w && (w.mergeOption({}, this), w.optionUpdated({}, false));
          else {
            var I = h === "series", T = pe.getClass(h, b.keyInfo.subType, !I);
            if (!T) return;
            if (h === "tooltip") {
              if (x) return;
              x = true;
            }
            if (w && w.constructor === T) w.name = b.keyInfo.name, w.mergeOption(S, this), w.optionUpdated(S, false);
            else {
              var A = rt({
                componentIndex: _
              }, b.keyInfo);
              w = new T(S, this, this, A), rt(w, A), b.brandNew && (w.__requireNewView = true), w.init(S, this, this), w.optionUpdated(null, true);
            }
          }
          w ? (v.push(w.option), m.push(w), y++) : (v.push(void 0), m.push(void 0));
        }, this), i[h] = v, a.set(h, m), s.set(h, y), h === "series" && Fy(this);
      }
      this._seriesIndices || Fy(this);
    }, t.prototype.getOption = function() {
      var e = Bt(this.option);
      return P(e, function(r, i) {
        if (pe.hasClass(i)) {
          for (var a = He(r), s = a.length, o = false, l = s - 1; l >= 0; l--) a[l] && !$g(a[l]) ? o = true : (a[l] = null, !o && s--);
          a.length = s, e[i] = a;
        }
      }), delete e[LP], e;
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(e) {
      this._payload = e;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(e, r) {
      var i = this._componentsMap.get(e);
      if (i) {
        var a = i[r || 0];
        if (a) return a;
        if (r == null) {
          for (var s = 0; s < i.length; s++) if (i[s]) return i[s];
        }
      }
    }, t.prototype.queryComponents = function(e) {
      var r = e.mainType;
      if (!r) return [];
      var i = e.index, a = e.id, s = e.name, o = this._componentsMap.get(r);
      if (!o || !o.length) return [];
      var l;
      return i != null ? (l = [], P(He(i), function(u) {
        o[u] && l.push(o[u]);
      })) : a != null ? l = PP("id", a, o) : s != null ? l = PP("name", s, o) : l = Le(o, function(u) {
        return !!u;
      }), $P(l, e);
    }, t.prototype.findComponents = function(e) {
      var r = e.query, i = e.mainType, a = o(r), s = a ? this.queryComponents(a) : Le(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l($P(s, e));
      function o(u) {
        var c = i + "Index", h = i + "Id", f = i + "Name";
        return u && (u[c] != null || u[h] != null || u[f] != null) ? {
          mainType: i,
          index: u[c],
          id: u[h],
          name: u[f]
        } : null;
      }
      function l(u) {
        return e.filter ? Le(u, e.filter) : u;
      }
    }, t.prototype.eachComponent = function(e, r, i) {
      var a = this._componentsMap;
      if (Nt(e)) {
        var s = r, o = e;
        a.each(function(h, f) {
          for (var d = 0; h && d < h.length; d++) {
            var p = h[d];
            p && o.call(s, f, p, p.componentIndex);
          }
        });
      } else for (var l = wt(e) ? a.get(e) : Ft(e) ? this.findComponents(e) : null, u = 0; l && u < l.length; u++) {
        var c = l[u];
        c && r.call(i, c, c.componentIndex);
      }
    }, t.prototype.getSeriesByName = function(e) {
      var r = Un(e, null);
      return Le(this._componentsMap.get("series"), function(i) {
        return !!i && r != null && i.name === r;
      });
    }, t.prototype.getSeriesByIndex = function(e) {
      return this._componentsMap.get("series")[e];
    }, t.prototype.getSeriesByType = function(e) {
      return Le(this._componentsMap.get("series"), function(r) {
        return !!r && r.subType === e;
      });
    }, t.prototype.getSeries = function() {
      return Le(this._componentsMap.get("series"), function(e) {
        return !!e;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(e, r) {
      sp(this), P(this._seriesIndices, function(i) {
        var a = this._componentsMap.get("series")[i];
        e.call(r, a, i);
      }, this);
    }, t.prototype.eachRawSeries = function(e, r) {
      P(this._componentsMap.get("series"), function(i) {
        i && e.call(r, i, i.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(e, r, i) {
      sp(this), P(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        s.subType === e && r.call(i, s, a);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(e, r, i) {
      return P(this.getSeriesByType(e), r, i);
    }, t.prototype.isSeriesFiltered = function(e) {
      return sp(this), this._seriesIndicesMap.get(e.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(e, r) {
      sp(this);
      var i = [];
      P(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        e.call(r, s, a) && i.push(a);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = It(i);
    }, t.prototype.restoreData = function(e) {
      Fy(this);
      var r = this._componentsMap, i = [];
      r.each(function(a, s) {
        pe.hasClass(s) && i.push(s);
      }), pe.topologicalTravel(i, pe.getAllClassMainTypes(), function(a) {
        P(r.get(a), function(s) {
          s && (a !== "series" || !xat(s, e)) && s.restoreData();
        });
      });
    }, t.internalField = function() {
      Fy = function(e) {
        var r = e._seriesIndices = [];
        P(e._componentsMap.get("series"), function(i) {
          i && r.push(i.componentIndex);
        }), e._seriesIndicesMap = It(r);
      }, sp = function(e) {
      }, NP = function(e, r) {
        e.option = {}, e.option[LP] = yat, e._componentsMap = It({
          series: []
        }), e._componentsCount = It();
        var i = r.aria;
        Ft(i) && i.enabled == null && (i.enabled = true), bat(r, e._theme.option), Zt(r, cat, false), e._mergeOption(r, null);
      };
    }(), t;
  }($e);
  function xat(n, t) {
    if (t) {
      var e = t.seriesIndex, r = t.seriesId, i = t.seriesName;
      return e != null && n.componentIndex !== e || r != null && n.id !== r || i != null && n.name !== i;
    }
  }
  function bat(n, t) {
    var e = n.color && !n.colorLayer;
    P(t, function(r, i) {
      i === "colorLayer" && e || pe.hasClass(i) || (typeof r == "object" ? n[i] = n[i] ? Zt(n[i], r, false) : Bt(r) : n[i] == null && (n[i] = r));
    });
  }
  function PP(n, t, e) {
    if (ct(t)) {
      var r = It();
      return P(t, function(a) {
        if (a != null) {
          var s = Un(a, null);
          s != null && r.set(a, true);
        }
      }), Le(e, function(a) {
        return a && r.get(a[n]);
      });
    } else {
      var i = Un(t, null);
      return Le(e, function(a) {
        return a && i != null && a[n] === i;
      });
    }
  }
  function $P(n, t) {
    return t.hasOwnProperty("subType") ? Le(n, function(e) {
      return e && e.subType === t.subType;
    }) : n;
  }
  function OP(n) {
    var t = It();
    return n && P(He(n.replaceMerge), function(e) {
      t.set(e, true);
    }), {
      replaceMergeMainTypeMap: t
    };
  }
  zn(dD, fD);
  var _at = [
    "getDom",
    "getZr",
    "getWidth",
    "getHeight",
    "getDevicePixelRatio",
    "dispatchAction",
    "isSSR",
    "isDisposed",
    "on",
    "off",
    "getDataURL",
    "getConnectedDataURL",
    "getOption",
    "getId",
    "updateLabelLayout"
  ], w5 = /* @__PURE__ */ function() {
    function n(t) {
      P(_at, function(e) {
        this[e] = St(t[e], t);
      }, this);
    }
    return n;
  }(), kS = {}, Bv = function() {
    function n() {
      this._coordinateSystems = [];
    }
    return n.prototype.create = function(t, e) {
      var r = [];
      P(kS, function(i, a) {
        var s = i.create(t, e);
        r = r.concat(s || []);
      }), this._coordinateSystems = r;
    }, n.prototype.update = function(t, e) {
      P(this._coordinateSystems, function(r) {
        r.update && r.update(t, e);
      });
    }, n.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, n.register = function(t, e) {
      kS[t] = e;
    }, n.get = function(t) {
      return kS[t];
    }, n;
  }(), wat = /^(min|max)?(.+)$/, Sat = function() {
    function n(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return n.prototype.setOption = function(t, e, r) {
      t && (P(He(t.series), function(s) {
        s && s.data && Pi(s.data) && $x(s.data);
      }), P(He(t.dataset), function(s) {
        s && s.source && Pi(s.source) && $x(s.source);
      })), t = Bt(t);
      var i = this._optionBackup, a = Cat(t, e, !i);
      this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, n.prototype.mountOption = function(t) {
      var e = this._optionBackup;
      return this._timelineOptions = e.timelineOptions, this._mediaList = e.mediaList, this._mediaDefault = e.mediaDefault, this._currentMediaIndices = [], Bt(t ? e.baseOption : this._newBaseOption);
    }, n.prototype.getTimelineOption = function(t) {
      var e, r = this._timelineOptions;
      if (r.length) {
        var i = t.getComponent("timeline");
        i && (e = Bt(r[i.getCurrentIndex()]));
      }
      return e;
    }, n.prototype.getMediaOption = function(t) {
      var e = this._api.getWidth(), r = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, s = [], o = [];
      if (!i.length && !a) return o;
      for (var l = 0, u = i.length; l < u; l++) Tat(i[l].query, e, r) && s.push(l);
      return !s.length && a && (s = [
        -1
      ]), s.length && !Aat(s, this._currentMediaIndices) && (o = ht(s, function(c) {
        return Bt(c === -1 ? a.option : i[c].option);
      })), this._currentMediaIndices = s, o;
    }, n;
  }();
  function Cat(n, t, e) {
    var r = [], i, a, s = n.baseOption, o = n.timeline, l = n.options, u = n.media, c = !!n.media, h = !!(l || o || s && s.timeline);
    s ? (a = s, a.timeline || (a.timeline = o)) : ((h || c) && (n.options = n.media = null), a = n), c && ct(u) && P(u, function(d) {
      d && d.option && (d.query ? r.push(d) : i || (i = d));
    }), f(a), P(l, function(d) {
      return f(d);
    }), P(r, function(d) {
      return f(d.option);
    });
    function f(d) {
      P(t, function(p) {
        p(d, e);
      });
    }
    return {
      baseOption: a,
      timelineOptions: l || [],
      mediaDefault: i,
      mediaList: r
    };
  }
  function Tat(n, t, e) {
    var r = {
      width: t,
      height: e,
      aspectratio: t / e
    }, i = true;
    return P(n, function(a, s) {
      var o = s.match(wat);
      if (!(!o || !o[1] || !o[2])) {
        var l = o[1], u = o[2].toLowerCase();
        Iat(r[u], a, l) || (i = false);
      }
    }), i;
  }
  function Iat(n, t, e) {
    return e === "min" ? n >= t : e === "max" ? n <= t : n === t;
  }
  function Aat(n, t) {
    return n.join(",") === t.join(",");
  }
  var Oa = P, Gg = Ft, FP = [
    "areaStyle",
    "lineStyle",
    "nodeStyle",
    "linkStyle",
    "chordStyle",
    "label",
    "labelLine"
  ];
  function DS(n) {
    var t = n && n.itemStyle;
    if (t) for (var e = 0, r = FP.length; e < r; e++) {
      var i = FP[e], a = t.normal, s = t.emphasis;
      a && a[i] && (n[i] = n[i] || {}, n[i].normal ? Zt(n[i].normal, a[i]) : n[i].normal = a[i], a[i] = null), s && s[i] && (n[i] = n[i] || {}, n[i].emphasis ? Zt(n[i].emphasis, s[i]) : n[i].emphasis = s[i], s[i] = null);
    }
  }
  function Vr(n, t, e) {
    if (n && n[t] && (n[t].normal || n[t].emphasis)) {
      var r = n[t].normal, i = n[t].emphasis;
      r && (e ? (n[t].normal = n[t].emphasis = null, $t(n[t], r)) : n[t] = r), i && (n.emphasis = n.emphasis || {}, n.emphasis[t] = i, i.focus && (n.emphasis.focus = i.focus), i.blurScope && (n.emphasis.blurScope = i.blurScope));
    }
  }
  function Wp(n) {
    Vr(n, "itemStyle"), Vr(n, "lineStyle"), Vr(n, "areaStyle"), Vr(n, "label"), Vr(n, "labelLine"), Vr(n, "upperLabel"), Vr(n, "edgeLabel");
  }
  function Pn(n, t) {
    var e = Gg(n) && n[t], r = Gg(e) && e.textStyle;
    if (r) for (var i = 0, a = UL.length; i < a; i++) {
      var s = UL[i];
      r.hasOwnProperty(s) && (e[s] = r[s]);
    }
  }
  function ha(n) {
    n && (Wp(n), Pn(n, "label"), n.emphasis && Pn(n.emphasis, "label"));
  }
  function kat(n) {
    if (Gg(n)) {
      DS(n), Wp(n), Pn(n, "label"), Pn(n, "upperLabel"), Pn(n, "edgeLabel"), n.emphasis && (Pn(n.emphasis, "label"), Pn(n.emphasis, "upperLabel"), Pn(n.emphasis, "edgeLabel"));
      var t = n.markPoint;
      t && (DS(t), ha(t));
      var e = n.markLine;
      e && (DS(e), ha(e));
      var r = n.markArea;
      r && ha(r);
      var i = n.data;
      if (n.type === "graph") {
        i = i || n.nodes;
        var a = n.links || n.edges;
        if (a && !Pi(a)) for (var s = 0; s < a.length; s++) ha(a[s]);
        P(n.categories, function(u) {
          Wp(u);
        });
      }
      if (i && !Pi(i)) for (var s = 0; s < i.length; s++) ha(i[s]);
      if (t = n.markPoint, t && t.data) for (var o = t.data, s = 0; s < o.length; s++) ha(o[s]);
      if (e = n.markLine, e && e.data) for (var l = e.data, s = 0; s < l.length; s++) ct(l[s]) ? (ha(l[s][0]), ha(l[s][1])) : ha(l[s]);
      n.type === "gauge" ? (Pn(n, "axisLabel"), Pn(n, "title"), Pn(n, "detail")) : n.type === "treemap" ? (Vr(n.breadcrumb, "itemStyle"), P(n.levels, function(u) {
        Wp(u);
      })) : n.type === "tree" && Wp(n.leaves);
    }
  }
  function vo(n) {
    return ct(n) ? n : n ? [
      n
    ] : [];
  }
  function BP(n) {
    return (ct(n) ? n[0] : n) || {};
  }
  function Dat(n, t) {
    Oa(vo(n.series), function(r) {
      Gg(r) && kat(r);
    });
    var e = [
      "xAxis",
      "yAxis",
      "radiusAxis",
      "angleAxis",
      "singleAxis",
      "parallelAxis",
      "radar"
    ];
    t && e.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Oa(e, function(r) {
      Oa(vo(n[r]), function(i) {
        i && (Pn(i, "axisLabel"), Pn(i.axisPointer, "label"));
      });
    }), Oa(vo(n.parallel), function(r) {
      var i = r && r.parallelAxisDefault;
      Pn(i, "axisLabel"), Pn(i && i.axisPointer, "label");
    }), Oa(vo(n.calendar), function(r) {
      Vr(r, "itemStyle"), Pn(r, "dayLabel"), Pn(r, "monthLabel"), Pn(r, "yearLabel");
    }), Oa(vo(n.radar), function(r) {
      Pn(r, "name"), r.name && r.axisName == null && (r.axisName = r.name, delete r.name), r.nameGap != null && r.axisNameGap == null && (r.axisNameGap = r.nameGap, delete r.nameGap);
    }), Oa(vo(n.geo), function(r) {
      Gg(r) && (ha(r), Oa(vo(r.regions), function(i) {
        ha(i);
      }));
    }), Oa(vo(n.timeline), function(r) {
      ha(r), Vr(r, "label"), Vr(r, "itemStyle"), Vr(r, "controlStyle", true);
      var i = r.data;
      ct(i) && P(i, function(a) {
        Ft(a) && (Vr(a, "label"), Vr(a, "itemStyle"));
      });
    }), Oa(vo(n.toolbox), function(r) {
      Vr(r, "iconStyle"), Oa(r.feature, function(i) {
        Vr(i, "iconStyle");
      });
    }), Pn(BP(n.axisPointer), "label"), Pn(BP(n.tooltip).axisPointer, "label");
  }
  function Eat(n, t) {
    for (var e = t.split(","), r = n, i = 0; i < e.length && (r = r && r[e[i]], r != null); i++) ;
    return r;
  }
  function Mat(n, t, e, r) {
    for (var i = t.split(","), a = n, s, o = 0; o < i.length - 1; o++) s = i[o], a[s] == null && (a[s] = {}), a = a[s];
    a[i[o]] == null && (a[i[o]] = e);
  }
  function zP(n) {
    n && P(Rat, function(t) {
      t[0] in n && !(t[1] in n) && (n[t[1]] = n[t[0]]);
    });
  }
  var Rat = [
    [
      "x",
      "left"
    ],
    [
      "y",
      "top"
    ],
    [
      "x2",
      "right"
    ],
    [
      "y2",
      "bottom"
    ]
  ], Nat = [
    "grid",
    "geo",
    "parallel",
    "legend",
    "toolbox",
    "title",
    "visualMap",
    "dataZoom",
    "timeline"
  ], ES = [
    [
      "borderRadius",
      "barBorderRadius"
    ],
    [
      "borderColor",
      "barBorderColor"
    ],
    [
      "borderWidth",
      "barBorderWidth"
    ]
  ];
  function op(n) {
    var t = n && n.itemStyle;
    if (t) for (var e = 0; e < ES.length; e++) {
      var r = ES[e][1], i = ES[e][0];
      t[r] != null && (t[i] = t[r]);
    }
  }
  function VP(n) {
    n && n.alignTo === "edge" && n.margin != null && n.edgeDistance == null && (n.edgeDistance = n.margin);
  }
  function GP(n) {
    n && n.downplay && !n.blur && (n.blur = n.downplay);
  }
  function Lat(n) {
    n && n.focusNodeAdjacency != null && (n.emphasis = n.emphasis || {}, n.emphasis.focus == null && (n.emphasis.focus = "adjacency"));
  }
  function S5(n, t) {
    if (n) for (var e = 0; e < n.length; e++) t(n[e]), n[e] && S5(n[e].children, t);
  }
  function C5(n, t) {
    Dat(n, t), n.series = He(n.series), P(n.series, function(e) {
      if (Ft(e)) {
        var r = e.type;
        if (r === "line") e.clipOverflow != null && (e.clip = e.clipOverflow);
        else if (r === "pie" || r === "gauge") {
          e.clockWise != null && (e.clockwise = e.clockWise), VP(e.label);
          var i = e.data;
          if (i && !Pi(i)) for (var a = 0; a < i.length; a++) VP(i[a]);
          e.hoverOffset != null && (e.emphasis = e.emphasis || {}, (e.emphasis.scaleSize = null) && (e.emphasis.scaleSize = e.hoverOffset));
        } else if (r === "gauge") {
          var s = Eat(e, "pointer.color");
          s != null && Mat(e, "itemStyle.color", s);
        } else if (r === "bar") {
          op(e), op(e.backgroundStyle), op(e.emphasis);
          var i = e.data;
          if (i && !Pi(i)) for (var a = 0; a < i.length; a++) typeof i[a] == "object" && (op(i[a]), op(i[a] && i[a].emphasis));
        } else if (r === "sunburst") {
          var o = e.highlightPolicy;
          o && (e.emphasis = e.emphasis || {}, e.emphasis.focus || (e.emphasis.focus = o)), GP(e), S5(e.data, GP);
        } else r === "graph" || r === "sankey" ? Lat(e) : r === "map" && (e.mapType && !e.map && (e.map = e.mapType), e.mapLocation && $t(e, e.mapLocation));
        e.hoverAnimation != null && (e.emphasis = e.emphasis || {}, e.emphasis && e.emphasis.scale == null && (e.emphasis.scale = e.hoverAnimation)), zP(e);
      }
    }), n.dataRange && (n.visualMap = n.dataRange), P(Nat, function(e) {
      var r = n[e];
      r && (ct(r) || (r = [
        r
      ]), P(r, function(i) {
        zP(i);
      }));
    });
  }
  function Pat(n) {
    var t = It();
    n.eachSeries(function(e) {
      var r = e.get("stack");
      if (r) {
        var i = t.get(r) || t.set(r, []), a = e.getData(), s = {
          stackResultDimension: a.getCalculationInfo("stackResultDimension"),
          stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
          stackedDimension: a.getCalculationInfo("stackedDimension"),
          stackedByDimension: a.getCalculationInfo("stackedByDimension"),
          isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
          data: a,
          seriesModel: e
        };
        if (!s.stackedDimension || !(s.isStackedByIndex || s.stackedByDimension)) return;
        i.length && a.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(s);
      }
    }), t.each($at);
  }
  function $at(n) {
    P(n, function(t, e) {
      var r = [], i = [
        NaN,
        NaN
      ], a = [
        t.stackResultDimension,
        t.stackedOverDimension
      ], s = t.data, o = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
      s.modify(a, function(u, c, h) {
        var f = s.get(t.stackedDimension, h);
        if (isNaN(f)) return i;
        var d, p;
        o ? p = s.getRawIndex(h) : d = s.get(t.stackedByDimension, h);
        for (var g = NaN, v = e - 1; v >= 0; v--) {
          var m = n[v];
          if (o || (p = m.data.rawIndexOf(m.stackedByDimension, d)), p >= 0) {
            var y = m.data.getByRawIndex(m.stackResultDimension, p);
            if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && f >= 0 && y > 0 || l === "samesign" && f <= 0 && y < 0) {
              f = Rnt(f, y), g = y;
              break;
            }
          }
        }
        return r[0] = f, r[1] = g, r;
      });
    });
  }
  var F1 = /* @__PURE__ */ function() {
    function n(t) {
      this.data = t.data || (t.sourceFormat === uo ? {} : []), this.sourceFormat = t.sourceFormat || v5, this.seriesLayoutBy = t.seriesLayoutBy || Hs, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var e = this.dimensionsDefine = t.dimensionsDefine;
      if (e) for (var r = 0; r < e.length; r++) {
        var i = e[r];
        i.type == null && x5(this, r) === Cr.Must && (i.type = "ordinal");
      }
    }
    return n;
  }();
  function pD(n) {
    return n instanceof F1;
  }
  function iA(n, t, e) {
    e = e || T5(n);
    var r = t.seriesLayoutBy, i = Fat(n, e, r, t.sourceHeader, t.dimensions), a = new F1({
      data: n,
      sourceFormat: e,
      seriesLayoutBy: r,
      dimensionsDefine: i.dimensionsDefine,
      startIndex: i.startIndex,
      dimensionsDetectedCount: i.dimensionsDetectedCount,
      metaRawOption: Bt(t)
    });
    return a;
  }
  function gD(n) {
    return new F1({
      data: n,
      sourceFormat: Pi(n) ? Ol : Ea
    });
  }
  function Oat(n) {
    return new F1({
      data: n.data,
      sourceFormat: n.sourceFormat,
      seriesLayoutBy: n.seriesLayoutBy,
      dimensionsDefine: Bt(n.dimensionsDefine),
      startIndex: n.startIndex,
      dimensionsDetectedCount: n.dimensionsDetectedCount
    });
  }
  function T5(n) {
    var t = v5;
    if (Pi(n)) t = Ol;
    else if (ct(n)) {
      n.length === 0 && (t = Zr);
      for (var e = 0, r = n.length; e < r; e++) {
        var i = n[e];
        if (i != null) {
          if (ct(i) || Pi(i)) {
            t = Zr;
            break;
          } else if (Ft(i)) {
            t = Ma;
            break;
          }
        }
      }
    } else if (Ft(n)) {
      for (var a in n) if (Ct(n, a) && Kr(n[a])) {
        t = uo;
        break;
      }
    }
    return t;
  }
  function Fat(n, t, e, r, i) {
    var a, s;
    if (!n) return {
      dimensionsDefine: WP(i),
      startIndex: s,
      dimensionsDetectedCount: a
    };
    if (t === Zr) {
      var o = n;
      r === "auto" || r == null ? UP(function(u) {
        u != null && u !== "-" && (wt(u) ? s == null && (s = 1) : s = 0);
      }, e, o, 10) : s = _e(r) ? r : r ? 1 : 0, !i && s === 1 && (i = [], UP(function(u, c) {
        i[c] = u != null ? u + "" : "";
      }, e, o, 1 / 0)), a = i ? i.length : e === Id ? o.length : o[0] ? o[0].length : null;
    } else if (t === Ma) i || (i = Bat(n));
    else if (t === uo) i || (i = [], P(n, function(u, c) {
      i.push(c);
    }));
    else if (t === Ea) {
      var l = xd(n[0]);
      a = ct(l) && l.length || 1;
    }
    return {
      startIndex: s,
      dimensionsDefine: WP(i),
      dimensionsDetectedCount: a
    };
  }
  function Bat(n) {
    for (var t = 0, e; t < n.length && !(e = n[t++]); ) ;
    if (e) return ge(e);
  }
  function WP(n) {
    if (n) {
      var t = It();
      return ht(n, function(e, r) {
        e = Ft(e) ? e : {
          name: e
        };
        var i = {
          name: e.name,
          displayName: e.displayName,
          type: e.type
        };
        if (i.name == null) return i;
        i.name += "", i.displayName == null && (i.displayName = i.name);
        var a = t.get(i.name);
        return a ? i.name += "-" + a.count++ : t.set(i.name, {
          count: 1
        }), i;
      });
    }
  }
  function UP(n, t, e, r) {
    if (t === Id) for (var i = 0; i < e.length && i < r; i++) n(e[i] ? e[i][0] : null, i);
    else for (var a = e[0] || [], i = 0; i < a.length && i < r; i++) n(a[i], i);
  }
  function I5(n) {
    var t = n.sourceFormat;
    return t === Ma || t === uo;
  }
  var Fu, Bu, zu, HP, XP, A5 = function() {
    function n(t, e) {
      var r = pD(t) ? t : gD(t);
      this._source = r;
      var i = this._data = r.data;
      r.sourceFormat === Ol && (this._offset = 0, this._dimSize = e, this._data = i), XP(this, i, r);
    }
    return n.prototype.getSource = function() {
      return this._source;
    }, n.prototype.count = function() {
      return 0;
    }, n.prototype.getItem = function(t, e) {
    }, n.prototype.appendData = function(t) {
    }, n.prototype.clean = function() {
    }, n.protoInitialize = function() {
      var t = n.prototype;
      t.pure = false, t.persistent = true;
    }(), n.internalField = function() {
      var t;
      XP = function(s, o, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, f = l.dimensionsDefine, d = HP[vD(u, c)];
        if (rt(s, d), u === Ol) s.getItem = e, s.count = i, s.fillStorage = r;
        else {
          var p = k5(u, c);
          s.getItem = St(p, null, o, h, f);
          var g = D5(u, c);
          s.count = St(g, null, o, h, f);
        }
      };
      var e = function(s, o) {
        s = s - this._offset, o = o || [];
        for (var l = this._data, u = this._dimSize, c = u * s, h = 0; h < u; h++) o[h] = l[c + h];
        return o;
      }, r = function(s, o, l, u) {
        for (var c = this._data, h = this._dimSize, f = 0; f < h; f++) {
          for (var d = u[f], p = d[0] == null ? 1 / 0 : d[0], g = d[1] == null ? -1 / 0 : d[1], v = o - s, m = l[f], y = 0; y < v; y++) {
            var x = c[y * h + f];
            m[s + y] = x, x < p && (p = x), x > g && (g = x);
          }
          d[0] = p, d[1] = g;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      HP = (t = {}, t[Zr + "_" + Hs] = {
        pure: true,
        appendData: a
      }, t[Zr + "_" + Id] = {
        pure: true,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[Ma] = {
        pure: true,
        appendData: a
      }, t[uo] = {
        pure: true,
        appendData: function(s) {
          var o = this._data;
          P(s, function(l, u) {
            for (var c = o[u] || (o[u] = []), h = 0; h < (l || []).length; h++) c.push(l[h]);
          });
        }
      }, t[Ea] = {
        appendData: a
      }, t[Ol] = {
        persistent: false,
        pure: true,
        appendData: function(s) {
          this._data = s;
        },
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function a(s) {
        for (var o = 0; o < s.length; o++) this._data.push(s[o]);
      }
    }(), n;
  }(), YP = function(n, t, e, r) {
    return n[r];
  }, zat = (Fu = {}, Fu[Zr + "_" + Hs] = function(n, t, e, r) {
    return n[r + t];
  }, Fu[Zr + "_" + Id] = function(n, t, e, r, i) {
    r += t;
    for (var a = i || [], s = n, o = 0; o < s.length; o++) {
      var l = s[o];
      a[o] = l ? l[r] : null;
    }
    return a;
  }, Fu[Ma] = YP, Fu[uo] = function(n, t, e, r, i) {
    for (var a = i || [], s = 0; s < e.length; s++) {
      var o = e[s].name, l = n[o];
      a[s] = l ? l[r] : null;
    }
    return a;
  }, Fu[Ea] = YP, Fu);
  function k5(n, t) {
    var e = zat[vD(n, t)];
    return e;
  }
  var qP = function(n, t, e) {
    return n.length;
  }, Vat = (Bu = {}, Bu[Zr + "_" + Hs] = function(n, t, e) {
    return Math.max(0, n.length - t);
  }, Bu[Zr + "_" + Id] = function(n, t, e) {
    var r = n[0];
    return r ? Math.max(0, r.length - t) : 0;
  }, Bu[Ma] = qP, Bu[uo] = function(n, t, e) {
    var r = e[0].name, i = n[r];
    return i ? i.length : 0;
  }, Bu[Ea] = qP, Bu);
  function D5(n, t) {
    var e = Vat[vD(n, t)];
    return e;
  }
  var MS = function(n, t, e) {
    return n[t];
  }, Gat = (zu = {}, zu[Zr] = MS, zu[Ma] = function(n, t, e) {
    return n[e];
  }, zu[uo] = MS, zu[Ea] = function(n, t, e) {
    var r = xd(n);
    return r instanceof Array ? r[t] : r;
  }, zu[Ol] = MS, zu);
  function E5(n) {
    var t = Gat[n];
    return t;
  }
  function vD(n, t) {
    return n === Zr ? n + "_" + t : n;
  }
  function Wf(n, t, e) {
    if (n) {
      var r = n.getRawDataItem(t);
      if (r != null) {
        var i = n.getStore(), a = i.getSource().sourceFormat;
        if (e != null) {
          var s = n.getDimensionIndex(e), o = i.getDimensionProperty(s);
          return E5(a)(r, s, o);
        } else {
          var l = r;
          return a === Ea && (l = xd(r)), l;
        }
      }
    }
  }
  var Wat = /\{@(.+?)\}/g, B1 = function() {
    function n() {
    }
    return n.prototype.getDataParams = function(t, e) {
      var r = this.getData(e), i = this.getRawValue(t, e), a = r.getRawIndex(t), s = r.getName(t), o = r.getRawDataItem(t), l = r.getItemVisual(t, "style"), u = l && l[r.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, f = h === "series", d = r.userOutput && r.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: f ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: f ? this.id : null,
        seriesName: f ? this.name : null,
        name: s,
        dataIndex: a,
        data: o,
        dataType: e,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        $vars: [
          "seriesName",
          "name",
          "value"
        ]
      };
    }, n.prototype.getFormattedLabel = function(t, e, r, i, a, s) {
      e = e || "normal";
      var o = this.getData(r), l = this.getDataParams(t, r);
      if (s && (l.value = s.interpolatedValue), i != null && ct(l.value) && (l.value = l.value[i]), !a) {
        var u = o.getItemModel(t);
        a = u.get(e === "normal" ? [
          "label",
          "formatter"
        ] : [
          e,
          "label",
          "formatter"
        ]);
      }
      if (Nt(a)) return l.status = e, l.dimensionIndex = i, a(l);
      if (wt(a)) {
        var c = h5(a, l);
        return c.replace(Wat, function(h, f) {
          var d = f.length, p = f;
          p.charAt(0) === "[" && p.charAt(d - 1) === "]" && (p = +p.slice(1, d - 1));
          var g = Wf(o, t, p);
          if (s && ct(s.interpolatedValue)) {
            var v = o.getDimensionIndex(p);
            v >= 0 && (g = s.interpolatedValue[v]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, n.prototype.getRawValue = function(t, e) {
      return Wf(this.getData(e), t);
    }, n.prototype.formatTooltip = function(t, e, r) {
    }, n;
  }();
  function jP(n) {
    var t, e;
    return Ft(n) ? n.type && (e = n) : t = n, {
      text: t,
      frag: e
    };
  }
  function vg(n) {
    return new Uat(n);
  }
  var Uat = function() {
    function n(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = true;
    }
    return n.prototype.perform = function(t) {
      var e = this._upstream, r = t && t.skip;
      if (this._dirty && e) {
        var i = this.context;
        i.data = i.outputData = e.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !r && (a = this._plan(this.context));
      var s = c(this._modBy), o = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (s !== l || o !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = false, h = this._doReset(r)), this._modBy = l, this._modDataCount = u;
      var f = t && t.step;
      if (e ? this._dueEnd = e._outputDueEnd : this._dueEnd = this._count ? this._count(this.context) : 1 / 0, this._progress) {
        var d = this._dueIndex, p = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
        if (!r && (h || d < p)) {
          var g = this._progress;
          if (ct(g)) for (var v = 0; v < g.length; v++) this._doProgress(g[v], d, p, l, u);
          else this._doProgress(g, d, p, l, u);
        }
        this._dueIndex = p;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        this._outputDueEnd = m;
      } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, n.prototype.dirty = function() {
      this._dirty = true, this._onDirty && this._onDirty(this.context);
    }, n.prototype._doProgress = function(t, e, r, i, a) {
      KP.reset(e, r, i, a), this._callingProgress = t, this._callingProgress({
        start: e,
        end: r,
        count: r - e,
        next: KP.next
      }, this.context);
    }, n.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var e, r;
      !t && this._reset && (e = this._reset(this.context), e && e.progress && (r = e.forceFirstProgress, e = e.progress), ct(e) && !e.length && (e = null)), this._progress = e, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), r;
    }, n.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, n.prototype.pipe = function(t) {
      (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, n.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = false, this._disposed = true);
    }, n.prototype.getUpstream = function() {
      return this._upstream;
    }, n.prototype.getDownstream = function() {
      return this._downstream;
    }, n.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, n;
  }(), KP = /* @__PURE__ */ function() {
    var n, t, e, r, i, a = {
      reset: function(l, u, c, h) {
        t = l, n = u, e = c, r = h, i = Math.ceil(r / e), a.next = e > 1 && r > 0 ? o : s;
      }
    };
    return a;
    function s() {
      return t < n ? t++ : null;
    }
    function o() {
      var l = t % i * e + Math.ceil(t / i), u = t >= n ? null : l < r ? l : t;
      return t++, u;
    }
  }();
  function Fl(n, t) {
    var e = t && t.type;
    return e === "ordinal" ? n : (e === "time" && !_e(n) && n != null && n !== "-" && (n = +no(n)), n == null || n === "" ? NaN : Number(n));
  }
  var Hat = It({
    number: function(n) {
      return parseFloat(n);
    },
    time: function(n) {
      return +no(n);
    },
    trim: function(n) {
      return wt(n) ? ja(n) : n;
    }
  });
  function M5(n) {
    return Hat.get(n);
  }
  var R5 = {
    lt: function(n, t) {
      return n < t;
    },
    lte: function(n, t) {
      return n <= t;
    },
    gt: function(n, t) {
      return n > t;
    },
    gte: function(n, t) {
      return n >= t;
    }
  }, Xat = function() {
    function n(t, e) {
      if (!_e(e)) {
        var r = "";
        Ne(r);
      }
      this._opFn = R5[t], this._rvalFloat = zo(e);
    }
    return n.prototype.evaluate = function(t) {
      return _e(t) ? this._opFn(t, this._rvalFloat) : this._opFn(zo(t), this._rvalFloat);
    }, n;
  }(), N5 = function() {
    function n(t, e) {
      var r = t === "desc";
      this._resultLT = r ? 1 : -1, e == null && (e = r ? "min" : "max"), this._incomparable = e === "min" ? -1 / 0 : 1 / 0;
    }
    return n.prototype.evaluate = function(t, e) {
      var r = _e(t) ? t : zo(t), i = _e(e) ? e : zo(e), a = isNaN(r), s = isNaN(i);
      if (a && (r = this._incomparable), s && (i = this._incomparable), a && s) {
        var o = wt(t), l = wt(e);
        o && (r = l ? t : 0), l && (i = o ? e : 0);
      }
      return r < i ? this._resultLT : r > i ? -this._resultLT : 0;
    }, n;
  }(), Yat = function() {
    function n(t, e) {
      this._rval = e, this._isEQ = t, this._rvalTypeof = typeof e, this._rvalFloat = zo(e);
    }
    return n.prototype.evaluate = function(t) {
      var e = t === this._rval;
      if (!e) {
        var r = typeof t;
        r !== this._rvalTypeof && (r === "number" || this._rvalTypeof === "number") && (e = zo(t) === this._rvalFloat);
      }
      return this._isEQ ? e : !e;
    }, n;
  }();
  function qat(n, t) {
    return n === "eq" || n === "ne" ? new Yat(n === "eq", t) : Ct(R5, n) ? new Xat(n, t) : null;
  }
  var jat = function() {
    function n() {
    }
    return n.prototype.getRawData = function() {
      throw new Error("not supported");
    }, n.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, n.prototype.cloneRawData = function() {
    }, n.prototype.getDimensionInfo = function(t) {
    }, n.prototype.cloneAllDimensionInfo = function() {
    }, n.prototype.count = function() {
    }, n.prototype.retrieveValue = function(t, e) {
    }, n.prototype.retrieveValueFromItem = function(t, e) {
    }, n.prototype.convertValue = function(t, e) {
      return Fl(t, e);
    }, n;
  }();
  function Kat(n, t) {
    var e = new jat(), r = n.data, i = e.sourceFormat = n.sourceFormat, a = n.startIndex, s = "";
    n.seriesLayoutBy !== Hs && Ne(s);
    var o = [], l = {}, u = n.dimensionsDefine;
    if (u) P(u, function(g, v) {
      var m = g.name, y = {
        index: v,
        name: m,
        displayName: g.displayName
      };
      if (o.push(y), m != null) {
        var x = "";
        Ct(l, m) && Ne(x), l[m] = y;
      }
    });
    else for (var c = 0; c < n.dimensionsDetectedCount; c++) o.push({
      index: c
    });
    var h = k5(i, Hs);
    t.__isBuiltIn && (e.getRawDataItem = function(g) {
      return h(r, a, o, g);
    }, e.getRawData = St(Zat, null, n)), e.cloneRawData = St(Jat, null, n);
    var f = D5(i, Hs);
    e.count = St(f, null, r, a, o);
    var d = E5(i);
    e.retrieveValue = function(g, v) {
      var m = h(r, a, o, g);
      return p(m, v);
    };
    var p = e.retrieveValueFromItem = function(g, v) {
      if (g != null) {
        var m = o[v];
        if (m) return d(g, v, m.name);
      }
    };
    return e.getDimensionInfo = St(Qat, null, o, l), e.cloneAllDimensionInfo = St(tst, null, o), e;
  }
  function Zat(n) {
    var t = n.sourceFormat;
    if (!mD(t)) {
      var e = "";
      Ne(e);
    }
    return n.data;
  }
  function Jat(n) {
    var t = n.sourceFormat, e = n.data;
    if (!mD(t)) {
      var r = "";
      Ne(r);
    }
    if (t === Zr) {
      for (var i = [], a = 0, s = e.length; a < s; a++) i.push(e[a].slice());
      return i;
    } else if (t === Ma) {
      for (var i = [], a = 0, s = e.length; a < s; a++) i.push(rt({}, e[a]));
      return i;
    }
  }
  function Qat(n, t, e) {
    if (e != null) {
      if (_e(e) || !isNaN(e) && !Ct(t, e)) return n[e];
      if (Ct(t, e)) return t[e];
    }
  }
  function tst(n) {
    return Bt(n);
  }
  var L5 = It();
  function est(n) {
    n = Bt(n);
    var t = n.type, e = "";
    t || Ne(e);
    var r = t.split(":");
    r.length !== 2 && Ne(e);
    var i = false;
    r[0] === "echarts" && (t = r[1], i = true), n.__isBuiltIn = i, L5.set(t, n);
  }
  function nst(n, t, e) {
    var r = He(n), i = r.length, a = "";
    i || Ne(a);
    for (var s = 0, o = i; s < o; s++) {
      var l = r[s];
      t = rst(l, t), s !== o - 1 && (t.length = Math.max(t.length, 1));
    }
    return t;
  }
  function rst(n, t, e, r) {
    var i = "";
    t.length || Ne(i), Ft(n) || Ne(i);
    var a = n.type, s = L5.get(a);
    s || Ne(i);
    var o = ht(t, function(u) {
      return Kat(u, s);
    }), l = He(s.transform({
      upstream: o[0],
      upstreamList: o,
      config: Bt(n.config)
    }));
    return ht(l, function(u, c) {
      var h = "";
      Ft(u) || Ne(h), u.data || Ne(h);
      var f = T5(u.data);
      mD(f) || Ne(h);
      var d, p = t[0];
      if (p && c === 0 && !u.dimensions) {
        var g = p.startIndex;
        g && (u.data = p.data.slice(0, g).concat(u.data)), d = {
          seriesLayoutBy: Hs,
          sourceHeader: g,
          dimensions: p.metaRawOption.dimensions
        };
      } else d = {
        seriesLayoutBy: Hs,
        sourceHeader: 0,
        dimensions: u.dimensions
      };
      return iA(u.data, d, null);
    });
  }
  function mD(n) {
    return n === Zr || n === Ma;
  }
  var z1 = "undefined", ist = typeof Uint32Array === z1 ? Array : Uint32Array, ast = typeof Uint16Array === z1 ? Array : Uint16Array, P5 = typeof Int32Array === z1 ? Array : Int32Array, ZP = typeof Float64Array === z1 ? Array : Float64Array, $5 = {
    float: ZP,
    int: P5,
    ordinal: Array,
    number: Array,
    time: ZP
  }, RS;
  function zh(n) {
    return n > 65535 ? ist : ast;
  }
  function Vh() {
    return [
      1 / 0,
      -1 / 0
    ];
  }
  function sst(n) {
    var t = n.constructor;
    return t === Array ? n.slice() : new t(n);
  }
  function JP(n, t, e, r, i) {
    var a = $5[e || "float"];
    if (i) {
      var s = n[t], o = s && s.length;
      if (o !== r) {
        for (var l = new a(r), u = 0; u < o; u++) l[u] = s[u];
        n[t] = l;
      }
    } else n[t] = new a(r);
  }
  var aA = function() {
    function n() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = It();
    }
    return n.prototype.initData = function(t, e, r) {
      this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = t.getSource(), a = this.defaultDimValueGetter = RS[i.sourceFormat];
      this._dimValueGetter = r || a, this._rawExtent = [], I5(i), this._dimensions = ht(e, function(s) {
        return {
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, n.prototype.getProvider = function() {
      return this._provider;
    }, n.prototype.getSource = function() {
      return this._provider.getSource();
    }, n.prototype.ensureCalculationDimension = function(t, e) {
      var r = this._calcDimNameToIdx, i = this._dimensions, a = r.get(t);
      if (a != null) {
        if (i[a].type === e) return a;
      } else a = i.length;
      return i[a] = {
        type: e
      }, r.set(t, a), this._chunks[a] = new $5[e || "float"](this._rawCount), this._rawExtent[a] = Vh(), a;
    }, n.prototype.collectOrdinalMeta = function(t, e) {
      var r = this._chunks[t], i = this._dimensions[t], a = this._rawExtent, s = i.ordinalOffset || 0, o = r.length;
      s === 0 && (a[t] = Vh());
      for (var l = a[t], u = s; u < o; u++) {
        var c = r[u] = e.parseAndCollect(r[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = e, i.ordinalOffset = o, i.type = "ordinal";
    }, n.prototype.getOrdinalMeta = function(t) {
      var e = this._dimensions[t], r = e.ordinalMeta;
      return r;
    }, n.prototype.getDimensionProperty = function(t) {
      var e = this._dimensions[t];
      return e && e.property;
    }, n.prototype.appendData = function(t) {
      var e = this._provider, r = this.count();
      e.appendData(t);
      var i = e.count();
      return e.persistent || (i += r), r < i && this._initDataFromProvider(r, i, true), [
        r,
        i
      ];
    }, n.prototype.appendValues = function(t, e) {
      for (var r = this._chunks, i = this._dimensions, a = i.length, s = this._rawExtent, o = this.count(), l = o + Math.max(t.length, e || 0), u = 0; u < a; u++) {
        var c = i[u];
        JP(r, u, c.type, l, true);
      }
      for (var h = [], f = o; f < l; f++) for (var d = f - o, p = 0; p < a; p++) {
        var c = i[p], g = RS.arrayRows.call(this, t[d] || h, c.property, d, p);
        r[p][f] = g;
        var v = s[p];
        g < v[0] && (v[0] = g), g > v[1] && (v[1] = g);
      }
      return this._rawCount = this._count = l, {
        start: o,
        end: l
      };
    }, n.prototype._initDataFromProvider = function(t, e, r) {
      for (var i = this._provider, a = this._chunks, s = this._dimensions, o = s.length, l = this._rawExtent, u = ht(s, function(y) {
        return y.property;
      }), c = 0; c < o; c++) {
        var h = s[c];
        l[c] || (l[c] = Vh()), JP(a, c, h.type, e, r);
      }
      if (i.fillStorage) i.fillStorage(t, e, a, l);
      else for (var f = [], d = t; d < e; d++) {
        f = i.getItem(d, f);
        for (var p = 0; p < o; p++) {
          var g = a[p], v = this._dimValueGetter(f, u[p], d, p);
          g[d] = v;
          var m = l[p];
          v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
        }
      }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = e, this._extent = [];
    }, n.prototype.count = function() {
      return this._count;
    }, n.prototype.get = function(t, e) {
      if (!(e >= 0 && e < this._count)) return NaN;
      var r = this._chunks[t];
      return r ? r[this.getRawIndex(e)] : NaN;
    }, n.prototype.getValues = function(t, e) {
      var r = [], i = [];
      if (e == null) {
        e = t, t = [];
        for (var a = 0; a < this._dimensions.length; a++) i.push(a);
      } else i = t;
      for (var a = 0, s = i.length; a < s; a++) r.push(this.get(i[a], e));
      return r;
    }, n.prototype.getByRawIndex = function(t, e) {
      if (!(e >= 0 && e < this._rawCount)) return NaN;
      var r = this._chunks[t];
      return r ? r[e] : NaN;
    }, n.prototype.getSum = function(t) {
      var e = this._chunks[t], r = 0;
      if (e) for (var i = 0, a = this.count(); i < a; i++) {
        var s = this.get(t, i);
        isNaN(s) || (r += s);
      }
      return r;
    }, n.prototype.getMedian = function(t) {
      var e = [];
      this.each([
        t
      ], function(a) {
        isNaN(a) || e.push(a);
      });
      var r = e.sort(function(a, s) {
        return a - s;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? r[(i - 1) / 2] : (r[i / 2] + r[i / 2 - 1]) / 2;
    }, n.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0) return -1;
      if (!this._indices) return t;
      var e = this._indices, r = e[t];
      if (r != null && r < this._count && r === t) return t;
      for (var i = 0, a = this._count - 1; i <= a; ) {
        var s = (i + a) / 2 | 0;
        if (e[s] < t) i = s + 1;
        else if (e[s] > t) a = s - 1;
        else return s;
      }
      return -1;
    }, n.prototype.indicesOfNearest = function(t, e, r) {
      var i = this._chunks, a = i[t], s = [];
      if (!a) return s;
      r == null && (r = 1 / 0);
      for (var o = 1 / 0, l = -1, u = 0, c = 0, h = this.count(); c < h; c++) {
        var f = this.getRawIndex(c), d = e - a[f], p = Math.abs(d);
        p <= r && ((p < o || p === o && d >= 0 && l < 0) && (o = p, l = d, u = 0), d === l && (s[u++] = c));
      }
      return s.length = u, s;
    }, n.prototype.getIndices = function() {
      var t, e = this._indices;
      if (e) {
        var r = e.constructor, i = this._count;
        if (r === Array) {
          t = new r(i);
          for (var a = 0; a < i; a++) t[a] = e[a];
        } else t = new r(e.buffer, 0, i);
      } else {
        var r = zh(this._rawCount);
        t = new r(this.count());
        for (var a = 0; a < t.length; a++) t[a] = a;
      }
      return t;
    }, n.prototype.filter = function(t, e) {
      if (!this._count) return this;
      for (var r = this.clone(), i = r.count(), a = zh(r._rawCount), s = new a(i), o = [], l = t.length, u = 0, c = t[0], h = r._chunks, f = 0; f < i; f++) {
        var d = void 0, p = r.getRawIndex(f);
        if (l === 0) d = e(f);
        else if (l === 1) {
          var g = h[c][p];
          d = e(g, f);
        } else {
          for (var v = 0; v < l; v++) o[v] = h[t[v]][p];
          o[v] = f, d = e.apply(null, o);
        }
        d && (s[u++] = p);
      }
      return u < i && (r._indices = s), r._count = u, r._extent = [], r._updateGetRawIdx(), r;
    }, n.prototype.selectRange = function(t) {
      var e = this.clone(), r = e._count;
      if (!r) return this;
      var i = ge(t), a = i.length;
      if (!a) return this;
      var s = e.count(), o = zh(e._rawCount), l = new o(s), u = 0, c = i[0], h = t[c][0], f = t[c][1], d = e._chunks, p = false;
      if (!e._indices) {
        var g = 0;
        if (a === 1) {
          for (var v = d[i[0]], m = 0; m < r; m++) {
            var y = v[m];
            (y >= h && y <= f || isNaN(y)) && (l[u++] = g), g++;
          }
          p = true;
        } else if (a === 2) {
          for (var v = d[i[0]], x = d[i[1]], b = t[i[1]][0], _ = t[i[1]][1], m = 0; m < r; m++) {
            var y = v[m], w = x[m];
            (y >= h && y <= f || isNaN(y)) && (w >= b && w <= _ || isNaN(w)) && (l[u++] = g), g++;
          }
          p = true;
        }
      }
      if (!p) if (a === 1) for (var m = 0; m < s; m++) {
        var S = e.getRawIndex(m), y = d[i[0]][S];
        (y >= h && y <= f || isNaN(y)) && (l[u++] = S);
      }
      else for (var m = 0; m < s; m++) {
        for (var I = true, S = e.getRawIndex(m), T = 0; T < a; T++) {
          var A = i[T], y = d[A][S];
          (y < t[A][0] || y > t[A][1]) && (I = false);
        }
        I && (l[u++] = e.getRawIndex(m));
      }
      return u < s && (e._indices = l), e._count = u, e._extent = [], e._updateGetRawIdx(), e;
    }, n.prototype.map = function(t, e) {
      var r = this.clone(t);
      return this._updateDims(r, t, e), r;
    }, n.prototype.modify = function(t, e) {
      this._updateDims(this, t, e);
    }, n.prototype._updateDims = function(t, e, r) {
      for (var i = t._chunks, a = [], s = e.length, o = t.count(), l = [], u = t._rawExtent, c = 0; c < e.length; c++) u[e[c]] = Vh();
      for (var h = 0; h < o; h++) {
        for (var f = t.getRawIndex(h), d = 0; d < s; d++) l[d] = i[e[d]][f];
        l[s] = h;
        var p = r && r.apply(null, l);
        if (p != null) {
          typeof p != "object" && (a[0] = p, p = a);
          for (var c = 0; c < p.length; c++) {
            var g = e[c], v = p[c], m = u[g], y = i[g];
            y && (y[f] = v), v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      }
    }, n.prototype.lttbDownSample = function(t, e) {
      var r = this.clone([
        t
      ], true), i = r._chunks, a = i[t], s = this.count(), o = 0, l = Math.floor(1 / e), u = this.getRawIndex(0), c, h, f, d = new (zh(this._rawCount))(Math.min((Math.ceil(s / l) + 2) * 2, s));
      d[o++] = u;
      for (var p = 1; p < s - 1; p += l) {
        for (var g = Math.min(p + l, s - 1), v = Math.min(p + l * 2, s), m = (v + g) / 2, y = 0, x = g; x < v; x++) {
          var b = this.getRawIndex(x), _ = a[b];
          isNaN(_) || (y += _);
        }
        y /= v - g;
        var w = p, S = Math.min(p + l, s), I = p - 1, T = a[u];
        c = -1, f = w;
        for (var A = -1, C = 0, x = w; x < S; x++) {
          var b = this.getRawIndex(x), _ = a[b];
          if (isNaN(_)) {
            C++, A < 0 && (A = b);
            continue;
          }
          h = Math.abs((I - m) * (_ - T) - (I - x) * (y - T)), h > c && (c = h, f = b);
        }
        C > 0 && C < S - w && (d[o++] = Math.min(A, f), f = Math.max(A, f)), d[o++] = f, u = f;
      }
      return d[o++] = this.getRawIndex(s - 1), r._count = o, r._indices = d, r.getRawIndex = this._getRawIdx, r;
    }, n.prototype.minmaxDownSample = function(t, e) {
      for (var r = this.clone([
        t
      ], true), i = r._chunks, a = Math.floor(1 / e), s = i[t], o = this.count(), l = new (zh(this._rawCount))(Math.ceil(o / a) * 2), u = 0, c = 0; c < o; c += a) {
        var h = c, f = s[this.getRawIndex(h)], d = c, p = s[this.getRawIndex(d)], g = a;
        c + a > o && (g = o - c);
        for (var v = 0; v < g; v++) {
          var m = this.getRawIndex(c + v), y = s[m];
          y < f && (f = y, h = c + v), y > p && (p = y, d = c + v);
        }
        var x = this.getRawIndex(h), b = this.getRawIndex(d);
        h < d ? (l[u++] = x, l[u++] = b) : (l[u++] = b, l[u++] = x);
      }
      return r._count = u, r._indices = l, r._updateGetRawIdx(), r;
    }, n.prototype.downSample = function(t, e, r, i) {
      for (var a = this.clone([
        t
      ], true), s = a._chunks, o = [], l = Math.floor(1 / e), u = s[t], c = this.count(), h = a._rawExtent[t] = Vh(), f = new (zh(this._rawCount))(Math.ceil(c / l)), d = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, o.length = l);
        for (var g = 0; g < l; g++) {
          var v = this.getRawIndex(p + g);
          o[g] = u[v];
        }
        var m = r(o), y = this.getRawIndex(Math.min(p + i(o, m) || 0, c - 1));
        u[y] = m, m < h[0] && (h[0] = m), m > h[1] && (h[1] = m), f[d++] = y;
      }
      return a._count = d, a._indices = f, a._updateGetRawIdx(), a;
    }, n.prototype.each = function(t, e) {
      if (this._count) for (var r = t.length, i = this._chunks, a = 0, s = this.count(); a < s; a++) {
        var o = this.getRawIndex(a);
        switch (r) {
          case 0:
            e(a);
            break;
          case 1:
            e(i[t[0]][o], a);
            break;
          case 2:
            e(i[t[0]][o], i[t[1]][o], a);
            break;
          default:
            for (var l = 0, u = []; l < r; l++) u[l] = i[t[l]][o];
            u[l] = a, e.apply(null, u);
        }
      }
    }, n.prototype.getDataExtent = function(t) {
      var e = this._chunks[t], r = Vh();
      if (!e) return r;
      var i = this.count(), a = !this._indices, s;
      if (a) return this._rawExtent[t].slice();
      if (s = this._extent[t], s) return s.slice();
      s = r;
      for (var o = s[0], l = s[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), h = e[c];
        h < o && (o = h), h > l && (l = h);
      }
      return s = [
        o,
        l
      ], this._extent[t] = s, s;
    }, n.prototype.getRawDataItem = function(t) {
      var e = this.getRawIndex(t);
      if (this._provider.persistent) return this._provider.getItem(e);
      for (var r = [], i = this._chunks, a = 0; a < i.length; a++) r.push(i[a][e]);
      return r;
    }, n.prototype.clone = function(t, e) {
      var r = new n(), i = this._chunks, a = t && Qs(t, function(o, l) {
        return o[l] = true, o;
      }, {});
      if (a) for (var s = 0; s < i.length; s++) r._chunks[s] = a[s] ? sst(i[s]) : i[s];
      else r._chunks = i;
      return this._copyCommonProps(r), e || (r._indices = this._cloneIndices()), r._updateGetRawIdx(), r;
    }, n.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = Bt(this._extent), t._rawExtent = Bt(this._rawExtent);
    }, n.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, e = void 0;
        if (t === Array) {
          var r = this._indices.length;
          e = new t(r);
          for (var i = 0; i < r; i++) e[i] = this._indices[i];
        } else e = new t(this._indices);
        return e;
      }
      return null;
    }, n.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, n.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, n.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, n.internalField = function() {
      function t(e, r, i, a) {
        return Fl(e[a], this._dimensions[a]);
      }
      RS = {
        arrayRows: t,
        objectRows: function(e, r, i, a) {
          return Fl(e[r], this._dimensions[a]);
        },
        keyedColumns: t,
        original: function(e, r, i, a) {
          var s = e && (e.value == null ? e : e.value);
          return Fl(s instanceof Array ? s[a] : s, this._dimensions[a]);
        },
        typedArray: function(e, r, i, a) {
          return e[a];
        }
      };
    }(), n;
  }(), O5 = function() {
    function n(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = true, this._sourceHost = t;
    }
    return n.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = true;
    }, n.prototype._setLocalSource = function(t, e) {
      this._sourceList = t, this._upstreamSignList = e, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, n.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, n.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = false);
    }, n.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, e = this._getUpstreamSourceManagers(), r = !!e.length, i, a;
      if (By(t)) {
        var s = t, o = void 0, l = void 0, u = void 0;
        if (r) {
          var c = e[0];
          c.prepareSource(), u = c.getSource(), o = u.data, l = u.sourceFormat, a = [
            c._getVersionSign()
          ];
        } else o = s.get("data", true), l = Pi(o) ? Ol : Ea, a = [];
        var h = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, d = Ht(h.seriesLayoutBy, f.seriesLayoutBy) || null, p = Ht(h.sourceHeader, f.sourceHeader), g = Ht(h.dimensions, f.dimensions), v = d !== f.seriesLayoutBy || !!p != !!f.sourceHeader || g;
        i = v ? [
          iA(o, {
            seriesLayoutBy: d,
            sourceHeader: p,
            dimensions: g
          }, l)
        ] : [];
      } else {
        var m = t;
        if (r) {
          var y = this._applyTransform(e);
          i = y.sourceList, a = y.upstreamSignList;
        } else {
          var x = m.get("source", true);
          i = [
            iA(x, this._getSourceMetaRawOption(), null)
          ], a = [];
        }
      }
      this._setLocalSource(i, a);
    }, n.prototype._applyTransform = function(t) {
      var e = this._sourceHost, r = e.get("transform", true), i = e.get("fromTransformResult", true);
      if (i != null) {
        var a = "";
        t.length !== 1 && t$(a);
      }
      var s, o = [], l = [];
      return P(t, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), h = "";
        i != null && !c && t$(h), o.push(c), l.push(u._getVersionSign());
      }), r ? s = nst(r, o, {
        datasetIndex: e.componentIndex
      }) : i != null && (s = [
        Oat(o[0])
      ]), {
        sourceList: s,
        upstreamSignList: l
      };
    }, n.prototype._isDirty = function() {
      if (this._dirty) return true;
      for (var t = this._getUpstreamSourceManagers(), e = 0; e < t.length; e++) {
        var r = t[e];
        if (r._isDirty() || this._upstreamSignList[e] !== r._getVersionSign()) return true;
      }
    }, n.prototype.getSource = function(t) {
      t = t || 0;
      var e = this._sourceList[t];
      if (!e) {
        var r = this._getUpstreamSourceManagers();
        return r[0] && r[0].getSource(t);
      }
      return e;
    }, n.prototype.getSharedDataStore = function(t) {
      var e = t.makeStoreSchema();
      return this._innerGetDataStore(e.dimensions, t.source, e.hash);
    }, n.prototype._innerGetDataStore = function(t, e, r) {
      var i = 0, a = this._storeList, s = a[i];
      s || (s = a[i] = {});
      var o = s[r];
      if (!o) {
        var l = this._getUpstreamSourceManagers()[0];
        By(this._sourceHost) && l ? o = l._innerGetDataStore(t, e, r) : (o = new aA(), o.initData(new A5(e, t.length), t)), s[r] = o;
      }
      return o;
    }, n.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (By(t)) {
        var e = hD(t);
        return e ? [
          e.getSourceManager()
        ] : [];
      } else return ht(fat(t), function(r) {
        return r.getSourceManager();
      });
    }, n.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, e, r, i;
      if (By(t)) e = t.get("seriesLayoutBy", true), r = t.get("sourceHeader", true), i = t.get("dimensions", true);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = t;
        e = a.get("seriesLayoutBy", true), r = a.get("sourceHeader", true), i = a.get("dimensions", true);
      }
      return {
        seriesLayoutBy: e,
        sourceHeader: r,
        dimensions: i
      };
    }, n;
  }();
  function QP(n) {
    var t = n.option.transform;
    t && $x(n.option.transform);
  }
  function By(n) {
    return n.mainType === "series";
  }
  function t$(n) {
    throw new Error(n);
  }
  var ost = "line-height:1";
  function F5(n) {
    var t = n.lineHeight;
    return t == null ? ost : "line-height:" + oi(t + "") + "px";
  }
  function B5(n, t) {
    var e = n.color || "#6e7079", r = n.fontSize || 12, i = n.fontWeight || "400", a = n.color || "#464646", s = n.fontSize || 14, o = n.fontWeight || "900";
    return t === "html" ? {
      nameStyle: "font-size:" + oi(r + "") + "px;color:" + oi(e) + ";font-weight:" + oi(i + ""),
      valueStyle: "font-size:" + oi(s + "") + "px;color:" + oi(a) + ";font-weight:" + oi(o + "")
    } : {
      nameStyle: {
        fontSize: r,
        fill: e,
        fontWeight: i
      },
      valueStyle: {
        fontSize: s,
        fill: a,
        fontWeight: o
      }
    };
  }
  var lst = [
    0,
    10,
    20,
    30
  ], ust = [
    "",
    `
`,
    `

`,
    `


`
  ];
  function cr(n, t) {
    return t.type = n, t;
  }
  function sA(n) {
    return n.type === "section";
  }
  function z5(n) {
    return sA(n) ? cst : hst;
  }
  function V5(n) {
    if (sA(n)) {
      var t = 0, e = n.blocks.length, r = e > 1 || e > 0 && !n.noHeader;
      return P(n.blocks, function(i) {
        var a = V5(i);
        a >= t && (t = a + +(r && (!a || sA(i) && !i.noHeader)));
      }), t;
    }
    return 0;
  }
  function cst(n, t, e, r) {
    var i = t.noHeader, a = fst(V5(t)), s = [], o = t.blocks || [];
    gi(!o || ct(o)), o = o || [];
    var l = n.orderMode;
    if (t.sortBlocks && l) {
      o = o.slice();
      var u = {
        valueAsc: "asc",
        valueDesc: "desc"
      };
      if (Ct(u, l)) {
        var c = new N5(u[l], null);
        o.sort(function(g, v) {
          return c.evaluate(g.sortParam, v.sortParam);
        });
      } else l === "seriesDesc" && o.reverse();
    }
    P(o, function(g, v) {
      var m = t.valueFormatter, y = z5(g)(m ? rt(rt({}, n), {
        valueFormatter: m
      }) : n, g, v > 0 ? a.html : 0, r);
      y != null && s.push(y);
    });
    var h = n.renderMode === "richText" ? s.join(a.richText) : oA(r, s.join(""), i ? e : a.html);
    if (i) return h;
    var f = eA(t.header, "ordinal", n.useUTC), d = B5(r, n.renderMode).nameStyle, p = F5(r);
    return n.renderMode === "richText" ? G5(n, f, d) + a.richText + h : oA(r, '<div style="' + d + ";" + p + ';">' + oi(f) + "</div>" + h, e);
  }
  function hst(n, t, e, r) {
    var i = n.renderMode, a = t.noName, s = t.noValue, o = !t.markerType, l = t.name, u = n.useUTC, c = t.valueFormatter || n.valueFormatter || function(b) {
      return b = ct(b) ? b : [
        b
      ], ht(b, function(_, w) {
        return eA(_, ct(d) ? d[w] : d, u);
      });
    };
    if (!(a && s)) {
      var h = o ? "" : n.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || "#333", i), f = a ? "" : eA(l, "ordinal", u), d = t.valueType, p = s ? [] : c(t.value, t.dataIndex), g = !o || !a, v = !o && a, m = B5(r, i), y = m.nameStyle, x = m.valueStyle;
      return i === "richText" ? (o ? "" : h) + (a ? "" : G5(n, f, y)) + (s ? "" : gst(n, p, g, v, x)) : oA(r, (o ? "" : h) + (a ? "" : dst(f, !o, y)) + (s ? "" : pst(p, g, v, x)), e);
    }
  }
  function e$(n, t, e, r, i, a) {
    if (n) {
      var s = z5(n), o = {
        useUTC: i,
        renderMode: e,
        orderMode: r,
        markupStyleCreator: t,
        valueFormatter: n.valueFormatter
      };
      return s(o, n, 0, a);
    }
  }
  function fst(n) {
    return {
      html: lst[n],
      richText: ust[n]
    };
  }
  function oA(n, t, e) {
    var r = '<div style="clear:both"></div>', i = "margin: " + e + "px 0 0", a = F5(n);
    return '<div style="' + i + ";" + a + ';">' + t + r + "</div>";
  }
  function dst(n, t, e) {
    var r = t ? "margin-left:2px" : "";
    return '<span style="' + e + ";" + r + '">' + oi(n) + "</span>";
  }
  function pst(n, t, e, r) {
    var i = e ? "10px" : "20px", a = t ? "float:right;margin-left:" + i : "";
    return n = ct(n) ? n : [
      n
    ], '<span style="' + a + ";" + r + '">' + ht(n, function(s) {
      return oi(s);
    }).join("&nbsp;&nbsp;") + "</span>";
  }
  function G5(n, t, e) {
    return n.markupStyleCreator.wrapRichTextStyle(t, e);
  }
  function gst(n, t, e, r, i) {
    var a = [
      i
    ], s = r ? 10 : 20;
    return e && a.push({
      padding: [
        0,
        0,
        0,
        s
      ],
      align: "right"
    }), n.markupStyleCreator.wrapRichTextStyle(ct(t) ? t.join("  ") : t, a);
  }
  function W5(n, t) {
    var e = n.getData().getItemVisual(t, "style"), r = e[n.visualDrawType];
    return Yc(r);
  }
  function U5(n, t) {
    var e = n.get("padding");
    return e ?? (t === "richText" ? [
      8,
      10
    ] : 10);
  }
  var NS = function() {
    function n() {
      this.richTextStyles = {}, this._nextStyleNameId = aU();
    }
    return n.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, n.prototype.makeTooltipMarker = function(t, e, r) {
      var i = r === "richText" ? this._generateStyleName() : null, a = aat({
        color: e,
        type: t,
        renderMode: r,
        markerId: i
      });
      return wt(a) ? a : (this.richTextStyles[i] = a.style, a.content);
    }, n.prototype.wrapRichTextStyle = function(t, e) {
      var r = {};
      ct(e) ? P(e, function(a) {
        return rt(r, a);
      }) : rt(r, e);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = r, "{" + i + "|" + t + "}";
    }, n;
  }();
  function H5(n) {
    var t = n.series, e = n.dataIndex, r = n.multipleSeries, i = t.getData(), a = i.mapDimensionsAll("defaultedTooltip"), s = a.length, o = t.getRawValue(e), l = ct(o), u = W5(t, e), c, h, f, d;
    if (s > 1 || l && !s) {
      var p = vst(o, t, e, a, u);
      c = p.inlineValues, h = p.inlineValueTypes, f = p.blocks, d = p.inlineValues[0];
    } else if (s) {
      var g = i.getDimensionInfo(a[0]);
      d = c = Wf(i, e, a[0]), h = g.type;
    } else d = c = l ? o[0] : o;
    var v = Wk(t), m = v && t.name || "", y = i.getName(e), x = r ? m : y;
    return cr("section", {
      header: m,
      noHeader: r || !v,
      sortParam: d,
      blocks: [
        cr("nameValue", {
          markerType: "item",
          markerColor: u,
          name: x,
          noName: !ja(x),
          value: c,
          valueType: h,
          dataIndex: e
        })
      ].concat(f || [])
    });
  }
  function vst(n, t, e, r, i) {
    var a = t.getData(), s = Qs(n, function(h, f, d) {
      var p = a.getDimensionInfo(d);
      return h = h || p && p.tooltip !== false && p.displayName != null;
    }, false), o = [], l = [], u = [];
    r.length ? P(r, function(h) {
      c(Wf(a, e, h), h);
    }) : P(n, c);
    function c(h, f) {
      var d = a.getDimensionInfo(f);
      !d || d.otherDims.tooltip === false || (s ? u.push(cr("nameValue", {
        markerType: "subItem",
        markerColor: i,
        name: d.displayName,
        value: h,
        valueType: d.type
      })) : (o.push(h), l.push(d.type)));
    }
    return {
      inlineValues: o,
      inlineValueTypes: l,
      blocks: u
    };
  }
  var ul = xe();
  function zy(n, t) {
    return n.getName(t) || n.getId(t);
  }
  var px = "__universalTransitionEnabled", an = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e._selectedDataIndicesMap = {}, e;
    }
    return t.prototype.init = function(e, r, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = vg({
        count: yst,
        reset: xst
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(e, i);
      var a = ul(this).sourceManager = new O5(this);
      a.prepareSource();
      var s = this.getInitialData(e, i);
      r$(s, this), this.dataTask.context.data = s, ul(this).dataBeforeProcessed = s, n$(this), this._initSelectedMapFromData(s);
    }, t.prototype.mergeDefaultAndTheme = function(e, r) {
      var i = Vg(this), a = i ? Td(e) : {}, s = this.subType;
      pe.hasClass(s) && (s += "Series"), Zt(e, r.getTheme().get(this.subType)), Zt(e, this.getDefaultOption()), Wc(e, "label", [
        "show"
      ]), this.fillDataTextStyle(e.data), i && jl(e, a, i);
    }, t.prototype.mergeOption = function(e, r) {
      e = Zt(this.option, e, true), this.fillDataTextStyle(e.data);
      var i = Vg(this);
      i && jl(this.option, e, i);
      var a = ul(this).sourceManager;
      a.dirty(), a.prepareSource();
      var s = this.getInitialData(e, r);
      r$(s, this), this.dataTask.dirty(), this.dataTask.context.data = s, ul(this).dataBeforeProcessed = s, n$(this), this._initSelectedMapFromData(s);
    }, t.prototype.fillDataTextStyle = function(e) {
      if (e && !Pi(e)) for (var r = [
        "show"
      ], i = 0; i < e.length; i++) e[i] && e[i].label && Wc(e[i], "label", r);
    }, t.prototype.getInitialData = function(e, r) {
    }, t.prototype.appendData = function(e) {
      var r = this.getRawData();
      r.appendData(e.data);
    }, t.prototype.getData = function(e) {
      var r = lA(this);
      if (r) {
        var i = r.context.data;
        return e == null || !i.getLinkedData ? i : i.getLinkedData(e);
      } else return ul(this).data;
    }, t.prototype.getAllData = function() {
      var e = this.getData();
      return e && e.getLinkedDataAll ? e.getLinkedDataAll() : [
        {
          data: e
        }
      ];
    }, t.prototype.setData = function(e) {
      var r = lA(this);
      if (r) {
        var i = r.context;
        i.outputData = e, r !== this.dataTask && (i.data = e);
      }
      ul(this).data = e;
    }, t.prototype.getEncode = function() {
      var e = this.get("encode", true);
      if (e) return It(e);
    }, t.prototype.getSourceManager = function() {
      return ul(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return ul(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var e = this.get("colorBy");
      return e || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var e = this.coordinateSystem;
      return e && e.getBaseAxis && e.getBaseAxis();
    }, t.prototype.formatTooltip = function(e, r, i) {
      return H5({
        series: this,
        dataIndex: e,
        multipleSeries: r
      });
    }, t.prototype.isAnimationEnabled = function() {
      var e = this.ecModel;
      if (ce.node && !(e && e.ssr)) return false;
      var r = this.getShallow("animation");
      return r && this.getData().count() > this.getShallow("animationThreshold") && (r = false), !!r;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(e, r, i) {
      var a = this.ecModel, s = fD.prototype.getColorFromPalette.call(this, e, r, i);
      return s || (s = a.getColorFromPalette(e, r, i)), s;
    }, t.prototype.coordDimToDataDim = function(e) {
      return this.getRawData().mapDimensionsAll(e);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(e, r) {
      this._innerSelect(this.getData(r), e);
    }, t.prototype.unselect = function(e, r) {
      var i = this.option.selectedMap;
      if (i) {
        var a = this.option.selectedMode, s = this.getData(r);
        if (a === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var o = 0; o < e.length; o++) {
          var l = e[o], u = zy(s, l);
          i[u] = false, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(e, r) {
      for (var i = [], a = 0; a < e.length; a++) i[0] = e[a], this.isSelected(e[a], r) ? this.unselect(i, r) : this.select(i, r);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
      for (var e = this._selectedDataIndicesMap, r = ge(e), i = [], a = 0; a < r.length; a++) {
        var s = e[r[a]];
        s >= 0 && i.push(s);
      }
      return i;
    }, t.prototype.isSelected = function(e, r) {
      var i = this.option.selectedMap;
      if (!i) return false;
      var a = this.getData(r);
      return (i === "all" || i[zy(a, e)]) && !a.getItemModel(e).get([
        "select",
        "disabled"
      ]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[px]) return true;
      var e = this.option.universalTransition;
      return e ? e === true ? true : e && e.enabled : false;
    }, t.prototype._innerSelect = function(e, r) {
      var i, a, s = this.option, o = s.selectedMode, l = r.length;
      if (!(!o || !l)) {
        if (o === "series") s.selectedMap = "all";
        else if (o === "multiple") {
          Ft(s.selectedMap) || (s.selectedMap = {});
          for (var u = s.selectedMap, c = 0; c < l; c++) {
            var h = r[c], f = zy(e, h);
            u[f] = true, this._selectedDataIndicesMap[f] = e.getRawIndex(h);
          }
        } else if (o === "single" || o === true) {
          var d = r[l - 1], f = zy(e, d);
          s.selectedMap = (i = {}, i[f] = true, i), this._selectedDataIndicesMap = (a = {}, a[f] = e.getRawIndex(d), a);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(e) {
      if (!this.option.selectedMap) {
        var r = [];
        e.hasItemOption && e.each(function(i) {
          var a = e.getRawDataItem(i);
          a && a.selected && r.push(i);
        }), r.length > 0 && this._innerSelect(e, r);
      }
    }, t.registerClass = function(e) {
      return pe.registerClass(e);
    }, t.protoInitialize = function() {
      var e = t.prototype;
      e.type = "series.__base__", e.seriesIndex = 0, e.ignoreStyleOnData = false, e.hasSymbolVisual = false, e.defaultSymbol = "circle", e.visualStyleAccessPath = "itemStyle", e.visualDrawType = "fill";
    }(), t;
  }(pe);
  zn(an, B1);
  zn(an, fD);
  pU(an, pe);
  function n$(n) {
    var t = n.name;
    Wk(n) || (n.name = mst(n) || t);
  }
  function mst(n) {
    var t = n.getRawData(), e = t.mapDimensionsAll("seriesName"), r = [];
    return P(e, function(i) {
      var a = t.getDimensionInfo(i);
      a.displayName && r.push(a.displayName);
    }), r.join(" ");
  }
  function yst(n) {
    return n.model.getRawData().count();
  }
  function xst(n) {
    var t = n.model;
    return t.setData(t.getRawData().cloneShallow()), bst;
  }
  function bst(n, t) {
    t.outputData && n.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
  }
  function r$(n, t) {
    P(Mg(n.CHANGABLE_METHODS, n.DOWNSAMPLE_METHODS), function(e) {
      n.wrapMethod(e, qt(_st, t));
    });
  }
  function _st(n, t) {
    var e = lA(n);
    return e && e.setOutputEnd((t || this).count()), t;
  }
  function lA(n) {
    var t = (n.ecModel || {}).scheduler, e = t && t.getPipeline(n.uid);
    if (e) {
      var r = e.currentTask;
      if (r) {
        var i = r.agentStubMap;
        i && (r = i.get(n.uid));
      }
      return r;
    }
  }
  var vn = function() {
    function n() {
      this.group = new Vt(), this.uid = Sd("viewComponent");
    }
    return n.prototype.init = function(t, e) {
    }, n.prototype.render = function(t, e, r, i) {
    }, n.prototype.dispose = function(t, e) {
    }, n.prototype.updateView = function(t, e, r, i) {
    }, n.prototype.updateLayout = function(t, e, r, i) {
    }, n.prototype.updateVisual = function(t, e, r, i) {
    }, n.prototype.toggleBlurSeries = function(t, e, r) {
    }, n.prototype.eachRendered = function(t) {
      var e = this.group;
      e && e.traverse(t);
    }, n;
  }();
  Hk(vn);
  _1(vn);
  function Ad() {
    var n = xe();
    return function(t) {
      var e = n(t), r = t.pipelineContext, i = !!e.large, a = !!e.progressiveRender, s = e.large = !!(r && r.large), o = e.progressiveRender = !!(r && r.progressiveRender);
      return (i !== s || a !== o) && "reset";
    };
  }
  var X5 = xe(), wst = Ad(), qe = function() {
    function n() {
      this.group = new Vt(), this.uid = Sd("viewChart"), this.renderTask = vg({
        plan: Sst,
        reset: Cst
      }), this.renderTask.context = {
        view: this
      };
    }
    return n.prototype.init = function(t, e) {
    }, n.prototype.render = function(t, e, r, i) {
    }, n.prototype.highlight = function(t, e, r, i) {
      var a = t.getData(i && i.dataType);
      a && a$(a, i, "emphasis");
    }, n.prototype.downplay = function(t, e, r, i) {
      var a = t.getData(i && i.dataType);
      a && a$(a, i, "normal");
    }, n.prototype.remove = function(t, e) {
      this.group.removeAll();
    }, n.prototype.dispose = function(t, e) {
    }, n.prototype.updateView = function(t, e, r, i) {
      this.render(t, e, r, i);
    }, n.prototype.updateLayout = function(t, e, r, i) {
      this.render(t, e, r, i);
    }, n.prototype.updateVisual = function(t, e, r, i) {
      this.render(t, e, r, i);
    }, n.prototype.eachRendered = function(t) {
      su(this.group, t);
    }, n.markUpdateMethod = function(t, e) {
      X5(t).updateMethod = e;
    }, n.protoInitialize = function() {
      var t = n.prototype;
      t.type = "chart";
    }(), n;
  }();
  function i$(n, t, e) {
    n && Fg(n) && (t === "emphasis" ? Vo : Go)(n, e);
  }
  function a$(n, t, e) {
    var r = Uc(n, t), i = t && t.highlightKey != null ? ait(t.highlightKey) : null;
    r != null ? P(He(r), function(a) {
      i$(n.getItemGraphicEl(a), e, i);
    }) : n.eachItemGraphicEl(function(a) {
      i$(a, e, i);
    });
  }
  Hk(qe);
  _1(qe);
  function Sst(n) {
    return wst(n.model);
  }
  function Cst(n) {
    var t = n.model, e = n.ecModel, r = n.api, i = n.payload, a = t.pipelineContext.progressiveRender, s = n.view, o = i && X5(i).updateMethod, l = a ? "incrementalPrepareRender" : o && s[o] ? o : "render";
    return l !== "render" && s[l](t, e, r, i), Tst[l];
  }
  var Tst = {
    incrementalPrepareRender: {
      progress: function(n, t) {
        t.view.incrementalRender(n, t.model, t.ecModel, t.api, t.payload);
      }
    },
    render: {
      forceFirstProgress: true,
      progress: function(n, t) {
        t.view.render(t.model, t.ecModel, t.api, t.payload);
      }
    }
  }, Jx = "\0__throttleOriginMethod", s$ = "\0__throttleRate", o$ = "\0__throttleType";
  function yD(n, t, e) {
    var r, i = 0, a = 0, s = null, o, l, u, c;
    t = t || 0;
    function h() {
      a = (/* @__PURE__ */ new Date()).getTime(), s = null, n.apply(l, u || []);
    }
    var f = function() {
      for (var d = [], p = 0; p < arguments.length; p++) d[p] = arguments[p];
      r = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
      var g = c || t, v = c || e;
      c = null, o = r - (v ? i : a) - g, clearTimeout(s), v ? s = setTimeout(h, g) : o >= 0 ? h() : s = setTimeout(h, -o), i = r;
    };
    return f.clear = function() {
      s && (clearTimeout(s), s = null);
    }, f.debounceNextCall = function(d) {
      c = d;
    }, f;
  }
  function kd(n, t, e, r) {
    var i = n[t];
    if (i) {
      var a = i[Jx] || i, s = i[o$], o = i[s$];
      if (o !== e || s !== r) {
        if (e == null || !r) return n[t] = a;
        i = n[t] = yD(a, e, r === "debounce"), i[Jx] = a, i[o$] = r, i[s$] = e;
      }
      return i;
    }
  }
  function Wg(n, t) {
    var e = n[t];
    e && e[Jx] && (e.clear && e.clear(), n[t] = e[Jx]);
  }
  var l$ = xe(), u$ = {
    itemStyle: Hc(JU, true),
    lineStyle: Hc(ZU, true)
  }, Ist = {
    lineStyle: "stroke",
    itemStyle: "fill"
  };
  function Y5(n, t) {
    var e = n.visualStyleMapper || u$[t];
    return e || (console.warn("Unknown style type '" + t + "'."), u$.itemStyle);
  }
  function q5(n, t) {
    var e = n.visualDrawType || Ist[t];
    return e || (console.warn("Unknown style type '" + t + "'."), "fill");
  }
  var Ast = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(n, t) {
      var e = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = n.getModel(r), a = Y5(n, r), s = a(i), o = i.getShallow("decal");
      o && (e.setVisual("decal", o), o.dirty = true);
      var l = q5(n, r), u = s[l], c = Nt(u) ? u : null, h = s.fill === "auto" || s.stroke === "auto";
      if (!s[l] || c || h) {
        var f = n.getColorFromPalette(n.name, null, t.getSeriesCount());
        s[l] || (s[l] = f, e.setVisual("colorFromPalette", true)), s.fill = s.fill === "auto" || Nt(s.fill) ? f : s.fill, s.stroke = s.stroke === "auto" || Nt(s.stroke) ? f : s.stroke;
      }
      if (e.setVisual("style", s), e.setVisual("drawType", l), !t.isSeriesFiltered(n) && c) return e.setVisual("colorFromPalette", false), {
        dataEach: function(d, p) {
          var g = n.getDataParams(p), v = rt({}, s);
          v[l] = c(g), d.setItemVisual(p, "style", v);
        }
      };
    }
  }, lp = new $e(), kst = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(n, t) {
      if (!(n.ignoreStyleOnData || t.isSeriesFiltered(n))) {
        var e = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = Y5(n, r), a = e.getVisual("drawType");
        return {
          dataEach: e.hasItemOption ? function(s, o) {
            var l = s.getRawDataItem(o);
            if (l && l[r]) {
              lp.option = l[r];
              var u = i(lp), c = s.ensureUniqueItemVisual(o, "style");
              rt(c, u), lp.option.decal && (s.setItemVisual(o, "decal", lp.option.decal), lp.option.decal.dirty = true), a in u && s.setItemVisual(o, "colorFromPalette", false);
            }
          } : null
        };
      }
    }
  }, Dst = {
    performRawSeries: true,
    overallReset: function(n) {
      var t = It();
      n.eachSeries(function(e) {
        var r = e.getColorBy();
        if (!e.isColorBySeries()) {
          var i = e.type + "-" + r, a = t.get(i);
          a || (a = {}, t.set(i, a)), l$(e).scope = a;
        }
      }), n.eachSeries(function(e) {
        if (!(e.isColorBySeries() || n.isSeriesFiltered(e))) {
          var r = e.getRawData(), i = {}, a = e.getData(), s = l$(e).scope, o = e.visualStyleAccessPath || "itemStyle", l = q5(e, o);
          a.each(function(u) {
            var c = a.getRawIndex(u);
            i[c] = u;
          }), r.each(function(u) {
            var c = i[u], h = a.getItemVisual(c, "colorFromPalette");
            if (h) {
              var f = a.ensureUniqueItemVisual(c, "style"), d = r.getName(u) || u + "", p = r.count();
              f[l] = e.getColorFromPalette(d, s, p);
            }
          });
        }
      });
    }
  }, Vy = Math.PI;
  function Est(n, t) {
    t = t || {}, $t(t, {
      text: "loading",
      textColor: "#000",
      fontSize: 12,
      fontWeight: "normal",
      fontStyle: "normal",
      fontFamily: "sans-serif",
      maskColor: "rgba(255, 255, 255, 0.8)",
      showSpinner: true,
      color: "#5470c6",
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    });
    var e = new Vt(), r = new ye({
      style: {
        fill: t.maskColor
      },
      zlevel: t.zlevel,
      z: 1e4
    });
    e.add(r);
    var i = new be({
      style: {
        text: t.text,
        fill: t.textColor,
        fontSize: t.fontSize,
        fontWeight: t.fontWeight,
        fontStyle: t.fontStyle,
        fontFamily: t.fontFamily
      },
      zlevel: t.zlevel,
      z: 10001
    }), a = new ye({
      style: {
        fill: "none"
      },
      textContent: i,
      textConfig: {
        position: "right",
        distance: 10
      },
      zlevel: t.zlevel,
      z: 10001
    });
    e.add(a);
    var s;
    return t.showSpinner && (s = new k1({
      shape: {
        startAngle: -Vy / 2,
        endAngle: -Vy / 2 + 0.1,
        r: t.spinnerRadius
      },
      style: {
        stroke: t.color,
        lineCap: "round",
        lineWidth: t.lineWidth
      },
      zlevel: t.zlevel,
      z: 10001
    }), s.animateShape(true).when(1e3, {
      endAngle: Vy * 3 / 2
    }).start("circularInOut"), s.animateShape(true).when(1e3, {
      startAngle: Vy * 3 / 2
    }).delay(300).start("circularInOut"), e.add(s)), e.resize = function() {
      var o = i.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (n.getWidth() - l * 2 - (t.showSpinner && o ? 10 : 0) - o) / 2 - (t.showSpinner && o ? 0 : 5 + o / 2) + (t.showSpinner ? 0 : o / 2) + (o ? 0 : l), c = n.getHeight() / 2;
      t.showSpinner && s.setShape({
        cx: u,
        cy: c
      }), a.setShape({
        x: u - l,
        y: c - l,
        width: l * 2,
        height: l * 2
      }), r.setShape({
        x: 0,
        y: 0,
        width: n.getWidth(),
        height: n.getHeight()
      });
    }, e.resize(), e;
  }
  var j5 = function() {
    function n(t, e, r, i) {
      this._stageTaskMap = It(), this.ecInstance = t, this.api = e, r = this._dataProcessorHandlers = r.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = r.concat(i);
    }
    return n.prototype.restoreData = function(t, e) {
      t.restoreData(e), this._stageTaskMap.each(function(r) {
        var i = r.overallTask;
        i && i.dirty();
      });
    }, n.prototype.getPerformArgs = function(t, e) {
      if (t.__pipeline) {
        var r = this._pipelineMap.get(t.__pipeline.id), i = r.context, a = !e && r.progressiveEnabled && (!i || i.progressiveRender) && t.__idxInPipeline > r.blockIndex, s = a ? r.step : null, o = i && i.modDataCount, l = o != null ? Math.ceil(o / s) : null;
        return {
          step: s,
          modBy: l,
          modDataCount: o
        };
      }
    }, n.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, n.prototype.updateStreamModes = function(t, e) {
      var r = this._pipelineMap.get(t.uid), i = t.getData(), a = i.count(), s = r.progressiveEnabled && e.incrementalPrepareRender && a >= r.threshold, o = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
      t.pipelineContext = r.context = {
        progressiveRender: s,
        modDataCount: l,
        large: o
      };
    }, n.prototype.restorePipelines = function(t) {
      var e = this, r = e._pipelineMap = It();
      t.eachSeries(function(i) {
        var a = i.getProgressive(), s = i.uid;
        r.set(s, {
          id: s,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), e._pipe(i, i.dataTask);
      });
    }, n.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, e = this.api.getModel(), r = this.api;
      P(this._allHandlers, function(i) {
        var a = t.get(i.uid) || t.set(i.uid, {}), s = "";
        gi(!(i.reset && i.overallReset), s), i.reset && this._createSeriesStageTask(i, a, e, r), i.overallReset && this._createOverallStageTask(i, a, e, r);
      }, this);
    }, n.prototype.prepareView = function(t, e, r, i) {
      var a = t.renderTask, s = a.context;
      s.model = e, s.ecModel = r, s.api = i, a.__block = !t.incrementalPrepareRender, this._pipe(e, a);
    }, n.prototype.performDataProcessorTasks = function(t, e) {
      this._performStageTasks(this._dataProcessorHandlers, t, e, {
        block: true
      });
    }, n.prototype.performVisualTasks = function(t, e, r) {
      this._performStageTasks(this._visualHandlers, t, e, r);
    }, n.prototype._performStageTasks = function(t, e, r, i) {
      i = i || {};
      var a = false, s = this;
      P(t, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = s._stageTaskMap.get(l.uid), h = c.seriesTaskMap, f = c.overallTask;
          if (f) {
            var d, p = f.agentStubMap;
            p.each(function(v) {
              o(i, v) && (v.dirty(), d = true);
            }), d && f.dirty(), s.updatePayload(f, r);
            var g = s.getPerformArgs(f, i.block);
            p.each(function(v) {
              v.perform(g);
            }), f.perform(g) && (a = true);
          } else h && h.each(function(v, m) {
            o(i, v) && v.dirty();
            var y = s.getPerformArgs(v, i.block);
            y.skip = !l.performRawSeries && e.isSeriesFiltered(v.context.model), s.updatePayload(v, r), v.perform(y) && (a = true);
          });
        }
      });
      function o(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, n.prototype.performSeriesTasks = function(t) {
      var e;
      t.eachSeries(function(r) {
        e = r.dataTask.perform() || e;
      }), this.unfinished = e || this.unfinished;
    }, n.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var e = t.tail;
        do {
          if (e.__block) {
            t.blockIndex = e.__idxInPipeline;
            break;
          }
          e = e.getUpstream();
        } while (e);
      });
    }, n.prototype.updatePayload = function(t, e) {
      e !== "remain" && (t.context.payload = e);
    }, n.prototype._createSeriesStageTask = function(t, e, r, i) {
      var a = this, s = e.seriesTaskMap, o = e.seriesTaskMap = It(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? r.eachRawSeries(c) : l ? r.eachRawSeriesByType(l, c) : u && u(r, i).each(c);
      function c(h) {
        var f = h.uid, d = o.set(f, s && s.get(f) || vg({
          plan: Pst,
          reset: $st,
          count: Fst
        }));
        d.context = {
          model: h,
          ecModel: r,
          api: i,
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a
        }, a._pipe(h, d);
      }
    }, n.prototype._createOverallStageTask = function(t, e, r, i) {
      var a = this, s = e.overallTask = e.overallTask || vg({
        reset: Mst
      });
      s.context = {
        ecModel: r,
        api: i,
        overallReset: t.overallReset,
        scheduler: a
      };
      var o = s.agentStubMap, l = s.agentStubMap = It(), u = t.seriesType, c = t.getTargetSeries, h = true, f = false, d = "";
      gi(!t.createOnAllSeries, d), u ? r.eachRawSeriesByType(u, p) : c ? c(r, i).each(p) : (h = false, P(r.getSeries(), p));
      function p(g) {
        var v = g.uid, m = l.set(v, o && o.get(v) || (f = true, vg({
          reset: Rst,
          onDirty: Lst
        })));
        m.context = {
          model: g,
          overallProgress: h
        }, m.agent = s, m.__block = h, a._pipe(g, m);
      }
      f && s.dirty();
    }, n.prototype._pipe = function(t, e) {
      var r = t.uid, i = this._pipelineMap.get(r);
      !i.head && (i.head = e), i.tail && i.tail.pipe(e), i.tail = e, e.__idxInPipeline = i.count++, e.__pipeline = i;
    }, n.wrapStageHandler = function(t, e) {
      return Nt(t) && (t = {
        overallReset: t,
        seriesType: Bst(t)
      }), t.uid = Sd("stageHandler"), e && (t.visualType = e), t;
    }, n;
  }();
  function Mst(n) {
    n.overallReset(n.ecModel, n.api, n.payload);
  }
  function Rst(n) {
    return n.overallProgress && Nst;
  }
  function Nst() {
    this.agent.dirty(), this.getDownstream().dirty();
  }
  function Lst() {
    this.agent && this.agent.dirty();
  }
  function Pst(n) {
    return n.plan ? n.plan(n.model, n.ecModel, n.api, n.payload) : null;
  }
  function $st(n) {
    n.useClearVisual && n.data.clearAllVisual();
    var t = n.resetDefines = He(n.reset(n.model, n.ecModel, n.api, n.payload));
    return t.length > 1 ? ht(t, function(e, r) {
      return K5(r);
    }) : Ost;
  }
  var Ost = K5(0);
  function K5(n) {
    return function(t, e) {
      var r = e.data, i = e.resetDefines[n];
      if (i && i.dataEach) for (var a = t.start; a < t.end; a++) i.dataEach(r, a);
      else i && i.progress && i.progress(t, r);
    };
  }
  function Fst(n) {
    return n.data.count();
  }
  function Bst(n) {
    Qx = null;
    try {
      n(Ug, Z5);
    } catch {
    }
    return Qx;
  }
  var Ug = {}, Z5 = {}, Qx;
  J5(Ug, dD);
  J5(Z5, w5);
  Ug.eachSeriesByType = Ug.eachRawSeriesByType = function(n) {
    Qx = n;
  };
  Ug.eachComponent = function(n) {
    n.mainType === "series" && n.subType && (Qx = n.subType);
  };
  function J5(n, t) {
    for (var e in t.prototype) n[e] = Dn;
  }
  var c$ = [
    "#37A2DA",
    "#32C5E9",
    "#67E0E3",
    "#9FE6B8",
    "#FFDB5C",
    "#ff9f7f",
    "#fb7293",
    "#E062AE",
    "#E690D1",
    "#e7bcf3",
    "#9d96f5",
    "#8378EA",
    "#96BFFF"
  ];
  const zst = {
    color: c$,
    colorLayer: [
      [
        "#37A2DA",
        "#ffd85c",
        "#fd7b5f"
      ],
      [
        "#37A2DA",
        "#67E0E3",
        "#FFDB5C",
        "#ff9f7f",
        "#E062AE",
        "#9d96f5"
      ],
      [
        "#37A2DA",
        "#32C5E9",
        "#9FE6B8",
        "#FFDB5C",
        "#ff9f7f",
        "#fb7293",
        "#e7bcf3",
        "#8378EA",
        "#96BFFF"
      ],
      c$
    ]
  };
  var Br = "#B9B8CE", h$ = "#100C2A", Gy = function() {
    return {
      axisLine: {
        lineStyle: {
          color: Br
        }
      },
      splitLine: {
        lineStyle: {
          color: "#484753"
        }
      },
      splitArea: {
        areaStyle: {
          color: [
            "rgba(255,255,255,0.02)",
            "rgba(255,255,255,0.05)"
          ]
        }
      },
      minorSplitLine: {
        lineStyle: {
          color: "#20203B"
        }
      }
    };
  }, f$ = [
    "#4992ff",
    "#7cffb2",
    "#fddd60",
    "#ff6e76",
    "#58d9f9",
    "#05c091",
    "#ff8a45",
    "#8d48e3",
    "#dd79ff"
  ], Q5 = {
    darkMode: true,
    color: f$,
    backgroundColor: h$,
    axisPointer: {
      lineStyle: {
        color: "#817f91"
      },
      crossStyle: {
        color: "#817f91"
      },
      label: {
        color: "#fff"
      }
    },
    legend: {
      textStyle: {
        color: Br
      },
      pageTextStyle: {
        color: Br
      }
    },
    textStyle: {
      color: Br
    },
    title: {
      textStyle: {
        color: "#EEF1FA"
      },
      subtextStyle: {
        color: "#B9B8CE"
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: Br
      }
    },
    dataZoom: {
      borderColor: "#71708A",
      textStyle: {
        color: Br
      },
      brushStyle: {
        color: "rgba(135,163,206,0.3)"
      },
      handleStyle: {
        color: "#353450",
        borderColor: "#C5CBE3"
      },
      moveHandleStyle: {
        color: "#B0B6C3",
        opacity: 0.3
      },
      fillerColor: "rgba(135,163,206,0.2)",
      emphasis: {
        handleStyle: {
          borderColor: "#91B7F2",
          color: "#4D587D"
        },
        moveHandleStyle: {
          color: "#636D9A",
          opacity: 0.7
        }
      },
      dataBackground: {
        lineStyle: {
          color: "#71708A",
          width: 1
        },
        areaStyle: {
          color: "#71708A"
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#87A3CE"
        },
        areaStyle: {
          color: "#87A3CE"
        }
      }
    },
    visualMap: {
      textStyle: {
        color: Br
      }
    },
    timeline: {
      lineStyle: {
        color: Br
      },
      label: {
        color: Br
      },
      controlStyle: {
        color: Br,
        borderColor: Br
      }
    },
    calendar: {
      itemStyle: {
        color: h$
      },
      dayLabel: {
        color: Br
      },
      monthLabel: {
        color: Br
      },
      yearLabel: {
        color: Br
      }
    },
    timeAxis: Gy(),
    logAxis: Gy(),
    valueAxis: Gy(),
    categoryAxis: Gy(),
    line: {
      symbol: "circle"
    },
    graph: {
      color: f$
    },
    gauge: {
      title: {
        color: Br
      },
      axisLine: {
        lineStyle: {
          color: [
            [
              1,
              "rgba(207,212,219,0.2)"
            ]
          ]
        }
      },
      axisLabel: {
        color: Br
      },
      detail: {
        color: "#EEF1FA"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#f64e56",
        color0: "#54ea92",
        borderColor: "#f64e56",
        borderColor0: "#54ea92"
      }
    }
  };
  Q5.categoryAxis.splitLine.show = false;
  var Vst = function() {
    function n() {
    }
    return n.prototype.normalizeQuery = function(t) {
      var e = {}, r = {}, i = {};
      if (wt(t)) {
        var a = Bs(t);
        e.mainType = a.main || null, e.subType = a.sub || null;
      } else {
        var s = [
          "Index",
          "Name",
          "Id"
        ], o = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        P(t, function(l, u) {
          for (var c = false, h = 0; h < s.length; h++) {
            var f = s[h], d = u.lastIndexOf(f);
            if (d > 0 && d === u.length - f.length) {
              var p = u.slice(0, d);
              p !== "data" && (e.mainType = p, e[f.toLowerCase()] = l, c = true);
            }
          }
          o.hasOwnProperty(u) && (r[u] = l, c = true), c || (i[u] = l);
        });
      }
      return {
        cptQuery: e,
        dataQuery: r,
        otherQuery: i
      };
    }, n.prototype.filter = function(t, e) {
      var r = this.eventInfo;
      if (!r) return true;
      var i = r.targetEl, a = r.packedEvent, s = r.model, o = r.view;
      if (!s || !o) return true;
      var l = e.cptQuery, u = e.dataQuery;
      return c(l, s, "mainType") && c(l, s, "subType") && c(l, s, "index", "componentIndex") && c(l, s, "name") && c(l, s, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!o.filterForExposedEvent || o.filterForExposedEvent(t, e.otherQuery, i, a));
      function c(h, f, d, p) {
        return h[d] == null || f[p || d] === h[d];
      }
    }, n.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, n;
  }(), uA = [
    "symbol",
    "symbolSize",
    "symbolRotate",
    "symbolOffset"
  ], d$ = uA.concat([
    "symbolKeepAspect"
  ]), Gst = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(n, t) {
      var e = n.getData();
      if (n.legendIcon && e.setVisual("legendIcon", n.legendIcon), !n.hasSymbolVisual) return;
      for (var r = {}, i = {}, a = false, s = 0; s < uA.length; s++) {
        var o = uA[s], l = n.get(o);
        Nt(l) ? (a = true, i[o] = l) : r[o] = l;
      }
      if (r.symbol = r.symbol || n.defaultSymbol, e.setVisual(rt({
        legendIcon: n.legendIcon || r.symbol,
        symbolKeepAspect: n.get("symbolKeepAspect")
      }, r)), t.isSeriesFiltered(n)) return;
      var u = ge(i);
      function c(h, f) {
        for (var d = n.getRawValue(f), p = n.getDataParams(f), g = 0; g < u.length; g++) {
          var v = u[g];
          h.setItemVisual(f, v, i[v](d, p));
        }
      }
      return {
        dataEach: a ? c : null
      };
    }
  }, Wst = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(n, t) {
      if (!n.hasSymbolVisual || t.isSeriesFiltered(n)) return;
      var e = n.getData();
      function r(i, a) {
        for (var s = i.getItemModel(a), o = 0; o < d$.length; o++) {
          var l = d$[o], u = s.getShallow(l, true);
          u != null && i.setItemVisual(a, l, u);
        }
      }
      return {
        dataEach: e.hasItemOption ? r : null
      };
    }
  };
  function xD(n, t, e) {
    switch (e) {
      case "color":
        var r = n.getItemVisual(t, "style");
        return r[n.getVisual("drawType")];
      case "opacity":
        return n.getItemVisual(t, "style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return n.getItemVisual(t, e);
    }
  }
  function zv(n, t) {
    switch (t) {
      case "color":
        var e = n.getVisual("style");
        return e[n.getVisual("drawType")];
      case "opacity":
        return n.getVisual("style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return n.getVisual(t);
    }
  }
  function tH(n, t, e, r) {
    switch (e) {
      case "color":
        var i = n.ensureUniqueItemVisual(t, "style");
        i[n.getVisual("drawType")] = r, n.setItemVisual(t, "colorFromPalette", false);
        break;
      case "opacity":
        n.ensureUniqueItemVisual(t, "style").opacity = r;
        break;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        n.setItemVisual(t, e, r);
        break;
    }
  }
  function eH(n, t) {
    function e(r, i) {
      var a = [];
      return r.eachComponent({
        mainType: "series",
        subType: n,
        query: i
      }, function(s) {
        a.push(s.seriesIndex);
      }), a;
    }
    P([
      [
        n + "ToggleSelect",
        "toggleSelect"
      ],
      [
        n + "Select",
        "select"
      ],
      [
        n + "UnSelect",
        "unselect"
      ]
    ], function(r) {
      t(r[0], function(i, a, s) {
        i = rt({}, i), s.dispatchAction(rt(i, {
          type: r[1],
          seriesIndex: e(a, i)
        }));
      });
    });
  }
  function Gh(n, t, e, r, i) {
    var a = n + t;
    e.isSilent(a) || r.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(s) {
      for (var o = s.seriesIndex, l = s.option.selectedMap, u = i.selected, c = 0; c < u.length; c++) if (u[c].seriesIndex === o) {
        var h = s.getData(), f = Uc(h, i.fromActionPayload);
        e.trigger(a, {
          type: a,
          seriesId: s.id,
          name: ct(f) ? h.getName(f[0]) : h.getName(f),
          selected: wt(l) ? l : rt({}, l)
        });
      }
    });
  }
  function Ust(n, t, e) {
    n.on("selectchanged", function(r) {
      var i = e.getModel();
      r.isFromClick ? (Gh("map", "selectchanged", t, i, r), Gh("pie", "selectchanged", t, i, r)) : r.fromAction === "select" ? (Gh("map", "selected", t, i, r), Gh("pie", "selected", t, i, r)) : r.fromAction === "unselect" && (Gh("map", "unselected", t, i, r), Gh("pie", "unselected", t, i, r));
    });
  }
  function bc(n, t, e) {
    for (var r; n && !(t(n) && (r = n, e)); ) n = n.__hostTarget || n.parent;
    return r;
  }
  var Hst = Math.round(Math.random() * 9), Xst = typeof Object.defineProperty == "function", Yst = function() {
    function n() {
      this._id = "__ec_inner_" + Hst++;
    }
    return n.prototype.get = function(t) {
      return this._guard(t)[this._id];
    }, n.prototype.set = function(t, e) {
      var r = this._guard(t);
      return Xst ? Object.defineProperty(r, this._id, {
        value: e,
        enumerable: false,
        configurable: true
      }) : r[this._id] = e, this;
    }, n.prototype.delete = function(t) {
      return this.has(t) ? (delete this._guard(t)[this._id], true) : false;
    }, n.prototype.has = function(t) {
      return !!this._guard(t)[this._id];
    }, n.prototype._guard = function(t) {
      if (t !== Object(t)) throw TypeError("Value of WeakMap is not a non-null object.");
      return t;
    }, n;
  }(), qst = le.extend({
    type: "triangle",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(n, t) {
      var e = t.cx, r = t.cy, i = t.width / 2, a = t.height / 2;
      n.moveTo(e, r - a), n.lineTo(e + i, r + a), n.lineTo(e - i, r + a), n.closePath();
    }
  }), jst = le.extend({
    type: "diamond",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(n, t) {
      var e = t.cx, r = t.cy, i = t.width / 2, a = t.height / 2;
      n.moveTo(e, r - a), n.lineTo(e + i, r), n.lineTo(e, r + a), n.lineTo(e - i, r), n.closePath();
    }
  }), Kst = le.extend({
    type: "pin",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(n, t) {
      var e = t.x, r = t.y, i = t.width / 5 * 3, a = Math.max(i, t.height), s = i / 2, o = s * s / (a - s), l = r - a + s + o, u = Math.asin(o / s), c = Math.cos(u) * s, h = Math.sin(u), f = Math.cos(u), d = s * 0.6, p = s * 0.7;
      n.moveTo(e - c, l + o), n.arc(e, l, s, Math.PI - u, Math.PI * 2 + u), n.bezierCurveTo(e + c - h * d, l + o + f * d, e, r - p, e, r), n.bezierCurveTo(e, r - p, e - c + h * d, l + o + f * d, e - c, l + o), n.closePath();
    }
  }), Zst = le.extend({
    type: "arrow",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(n, t) {
      var e = t.height, r = t.width, i = t.x, a = t.y, s = r / 3 * 2;
      n.moveTo(i, a), n.lineTo(i + s, a + e), n.lineTo(i, a + e / 4 * 3), n.lineTo(i - s, a + e), n.lineTo(i, a), n.closePath();
    }
  }), Jst = {
    line: ir,
    rect: ye,
    roundRect: ye,
    square: ye,
    circle: tl,
    diamond: jst,
    pin: Kst,
    arrow: Zst,
    triangle: qst
  }, Qst = {
    line: function(n, t, e, r, i) {
      i.x1 = n, i.y1 = t + r / 2, i.x2 = n + e, i.y2 = t + r / 2;
    },
    rect: function(n, t, e, r, i) {
      i.x = n, i.y = t, i.width = e, i.height = r;
    },
    roundRect: function(n, t, e, r, i) {
      i.x = n, i.y = t, i.width = e, i.height = r, i.r = Math.min(e, r) / 4;
    },
    square: function(n, t, e, r, i) {
      var a = Math.min(e, r);
      i.x = n, i.y = t, i.width = a, i.height = a;
    },
    circle: function(n, t, e, r, i) {
      i.cx = n + e / 2, i.cy = t + r / 2, i.r = Math.min(e, r) / 2;
    },
    diamond: function(n, t, e, r, i) {
      i.cx = n + e / 2, i.cy = t + r / 2, i.width = e, i.height = r;
    },
    pin: function(n, t, e, r, i) {
      i.x = n + e / 2, i.y = t + r / 2, i.width = e, i.height = r;
    },
    arrow: function(n, t, e, r, i) {
      i.x = n + e / 2, i.y = t + r / 2, i.width = e, i.height = r;
    },
    triangle: function(n, t, e, r, i) {
      i.cx = n + e / 2, i.cy = t + r / 2, i.width = e, i.height = r;
    }
  }, tb = {};
  P(Jst, function(n, t) {
    tb[t] = new n();
  });
  var tot = le.extend({
    type: "symbol",
    shape: {
      symbolType: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function(n, t, e) {
      var r = Wx(n, t, e), i = this.shape;
      return i && i.symbolType === "pin" && t.position === "inside" && (r.y = e.y + e.height * 0.4), r;
    },
    buildPath: function(n, t, e) {
      var r = t.symbolType;
      if (r !== "none") {
        var i = tb[r];
        i || (r = "rect", i = tb[r]), Qst[r](t.x, t.y, t.width, t.height, i.shape), i.buildPath(n, i.shape, e);
      }
    }
  });
  function eot(n, t) {
    if (this.type !== "image") {
      var e = this.style;
      this.__isEmptyBrush ? (e.stroke = n, e.fill = t || "#fff", e.lineWidth = 2) : this.shape.symbolType === "line" ? e.stroke = n : e.fill = n, this.markRedraw();
    }
  }
  function Fn(n, t, e, r, i, a, s) {
    var o = n.indexOf("empty") === 0;
    o && (n = n.substr(5, 1).toLowerCase() + n.substr(6));
    var l;
    return n.indexOf("image://") === 0 ? l = WU(n.slice(8), new te(t, e, r, i), s ? "center" : "cover") : n.indexOf("path://") === 0 ? l = D1(n.slice(7), {}, new te(t, e, r, i), s ? "center" : "cover") : l = new tot({
      shape: {
        symbolType: n,
        x: t,
        y: e,
        width: r,
        height: i
      }
    }), l.__isEmptyBrush = o, l.setColor = eot, a && l.setColor(a), l;
  }
  function Dd(n) {
    return ct(n) || (n = [
      +n,
      +n
    ]), [
      n[0] || 0,
      n[1] || 0
    ];
  }
  function gh(n, t) {
    if (n != null) return ct(n) || (n = [
      n,
      n
    ]), [
      yt(n[0], t[0]) || 0,
      yt(Ht(n[1], n[0]), t[1]) || 0
    ];
  }
  function _c(n) {
    return isFinite(n);
  }
  function not(n, t, e) {
    var r = t.x == null ? 0 : t.x, i = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, s = t.y2 == null ? 0 : t.y2;
    t.global || (r = r * e.width + e.x, i = i * e.width + e.x, a = a * e.height + e.y, s = s * e.height + e.y), r = _c(r) ? r : 0, i = _c(i) ? i : 1, a = _c(a) ? a : 0, s = _c(s) ? s : 0;
    var o = n.createLinearGradient(r, a, i, s);
    return o;
  }
  function rot(n, t, e) {
    var r = e.width, i = e.height, a = Math.min(r, i), s = t.x == null ? 0.5 : t.x, o = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
    t.global || (s = s * r + e.x, o = o * i + e.y, l = l * a), s = _c(s) ? s : 0.5, o = _c(o) ? o : 0.5, l = l >= 0 && _c(l) ? l : 0.5;
    var u = n.createRadialGradient(s, o, 0, s, o, l);
    return u;
  }
  function cA(n, t, e) {
    for (var r = t.type === "radial" ? rot(n, t, e) : not(n, t, e), i = t.colorStops, a = 0; a < i.length; a++) r.addColorStop(i[a].offset, i[a].color);
    return r;
  }
  function iot(n, t) {
    if (n === t || !n && !t) return false;
    if (!n || !t || n.length !== t.length) return true;
    for (var e = 0; e < n.length; e++) if (n[e] !== t[e]) return true;
    return false;
  }
  function Wy(n) {
    return parseInt(n, 10);
  }
  function Cf(n, t, e) {
    var r = [
      "width",
      "height"
    ][t], i = [
      "clientWidth",
      "clientHeight"
    ][t], a = [
      "paddingLeft",
      "paddingTop"
    ][t], s = [
      "paddingRight",
      "paddingBottom"
    ][t];
    if (e[r] != null && e[r] !== "auto") return parseFloat(e[r]);
    var o = document.defaultView.getComputedStyle(n);
    return (n[i] || Wy(o[r]) || Wy(n.style[r])) - (Wy(o[a]) || 0) - (Wy(o[s]) || 0) | 0;
  }
  function aot(n, t) {
    return !n || n === "solid" || !(t > 0) ? null : n === "dashed" ? [
      4 * t,
      2 * t
    ] : n === "dotted" ? [
      t
    ] : _e(n) ? [
      n
    ] : ct(n) ? n : null;
  }
  function bD(n) {
    var t = n.style, e = t.lineDash && t.lineWidth > 0 && aot(t.lineDash, t.lineWidth), r = t.lineDashOffset;
    if (e) {
      var i = t.strokeNoScale && n.getLineScale ? n.getLineScale() : 1;
      i && i !== 1 && (e = ht(e, function(a) {
        return a / i;
      }), r /= i);
    }
    return [
      e,
      r
    ];
  }
  var sot = new ro(true);
  function eb(n) {
    var t = n.stroke;
    return !(t == null || t === "none" || !(n.lineWidth > 0));
  }
  function p$(n) {
    return typeof n == "string" && n !== "none";
  }
  function nb(n) {
    var t = n.fill;
    return t != null && t !== "none";
  }
  function g$(n, t) {
    if (t.fillOpacity != null && t.fillOpacity !== 1) {
      var e = n.globalAlpha;
      n.globalAlpha = t.fillOpacity * t.opacity, n.fill(), n.globalAlpha = e;
    } else n.fill();
  }
  function v$(n, t) {
    if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
      var e = n.globalAlpha;
      n.globalAlpha = t.strokeOpacity * t.opacity, n.stroke(), n.globalAlpha = e;
    } else n.stroke();
  }
  function hA(n, t, e) {
    var r = Xk(t.image, t.__image, e);
    if (w1(r)) {
      var i = n.createPattern(r, t.repeat || "repeat");
      if (typeof DOMMatrix == "function" && i && i.setTransform) {
        var a = new DOMMatrix();
        a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * tx), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), i.setTransform(a);
      }
      return i;
    }
  }
  function oot(n, t, e, r) {
    var i, a = eb(e), s = nb(e), o = e.strokePercent, l = o < 1, u = !t.path;
    (!t.silent || l) && u && t.createPathProxy();
    var c = t.path || sot, h = t.__dirty;
    if (!r) {
      var f = e.fill, d = e.stroke, p = s && !!f.colorStops, g = a && !!d.colorStops, v = s && !!f.image, m = a && !!d.image, y = void 0, x = void 0, b = void 0, _ = void 0, w = void 0;
      (p || g) && (w = t.getBoundingRect()), p && (y = h ? cA(n, f, w) : t.__canvasFillGradient, t.__canvasFillGradient = y), g && (x = h ? cA(n, d, w) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = x), v && (b = h || !t.__canvasFillPattern ? hA(n, f, t) : t.__canvasFillPattern, t.__canvasFillPattern = b), m && (_ = h || !t.__canvasStrokePattern ? hA(n, d, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = b), p ? n.fillStyle = y : v && (b ? n.fillStyle = b : s = false), g ? n.strokeStyle = x : m && (_ ? n.strokeStyle = _ : a = false);
    }
    var S = t.getGlobalScale();
    c.setScale(S[0], S[1], t.segmentIgnoreThreshold);
    var I, T;
    n.setLineDash && e.lineDash && (i = bD(t), I = i[0], T = i[1]);
    var A = true;
    (u || h & Op) && (c.setDPR(n.dpr), l ? c.setContext(null) : (c.setContext(n), A = false), c.reset(), t.buildPath(c, t.shape, r), c.toStatic(), t.pathUpdated()), A && c.rebuildPath(n, l ? o : 1), I && (n.setLineDash(I), n.lineDashOffset = T), r || (e.strokeFirst ? (a && v$(n, e), s && g$(n, e)) : (s && g$(n, e), a && v$(n, e))), I && n.setLineDash([]);
  }
  function lot(n, t, e) {
    var r = t.__image = Xk(e.image, t.__image, t, t.onload);
    if (!(!r || !w1(r))) {
      var i = e.x || 0, a = e.y || 0, s = t.getWidth(), o = t.getHeight(), l = r.width / r.height;
      if (s == null && o != null ? s = o * l : o == null && s != null ? o = s / l : s == null && o == null && (s = r.width, o = r.height), e.sWidth && e.sHeight) {
        var u = e.sx || 0, c = e.sy || 0;
        n.drawImage(r, u, c, e.sWidth, e.sHeight, i, a, s, o);
      } else if (e.sx && e.sy) {
        var u = e.sx, c = e.sy, h = s - u, f = o - c;
        n.drawImage(r, u, c, h, f, i, a, s, o);
      } else n.drawImage(r, i, a, s, o);
    }
  }
  function uot(n, t, e) {
    var r, i = e.text;
    if (i != null && (i += ""), i) {
      n.font = e.font || Hl, n.textAlign = e.textAlign, n.textBaseline = e.textBaseline;
      var a = void 0, s = void 0;
      n.setLineDash && e.lineDash && (r = bD(t), a = r[0], s = r[1]), a && (n.setLineDash(a), n.lineDashOffset = s), e.strokeFirst ? (eb(e) && n.strokeText(i, e.x, e.y), nb(e) && n.fillText(i, e.x, e.y)) : (nb(e) && n.fillText(i, e.x, e.y), eb(e) && n.strokeText(i, e.x, e.y)), a && n.setLineDash([]);
    }
  }
  var m$ = [
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY"
  ], y$ = [
    [
      "lineCap",
      "butt"
    ],
    [
      "lineJoin",
      "miter"
    ],
    [
      "miterLimit",
      10
    ]
  ];
  function nH(n, t, e, r, i) {
    var a = false;
    if (!r && (e = e || {}, t === e)) return false;
    if (r || t.opacity !== e.opacity) {
      Ei(n, i), a = true;
      var s = Math.max(Math.min(t.opacity, 1), 0);
      n.globalAlpha = isNaN(s) ? Mc.opacity : s;
    }
    (r || t.blend !== e.blend) && (a || (Ei(n, i), a = true), n.globalCompositeOperation = t.blend || Mc.blend);
    for (var o = 0; o < m$.length; o++) {
      var l = m$[o];
      (r || t[l] !== e[l]) && (a || (Ei(n, i), a = true), n[l] = n.dpr * (t[l] || 0));
    }
    return (r || t.shadowColor !== e.shadowColor) && (a || (Ei(n, i), a = true), n.shadowColor = t.shadowColor || Mc.shadowColor), a;
  }
  function x$(n, t, e, r, i) {
    var a = Hg(t, i.inHover), s = r ? null : e && Hg(e, i.inHover) || {};
    if (a === s) return false;
    var o = nH(n, a, s, r, i);
    if ((r || a.fill !== s.fill) && (o || (Ei(n, i), o = true), p$(a.fill) && (n.fillStyle = a.fill)), (r || a.stroke !== s.stroke) && (o || (Ei(n, i), o = true), p$(a.stroke) && (n.strokeStyle = a.stroke)), (r || a.opacity !== s.opacity) && (o || (Ei(n, i), o = true), n.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
      var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
      n.lineWidth !== u && (o || (Ei(n, i), o = true), n.lineWidth = u);
    }
    for (var c = 0; c < y$.length; c++) {
      var h = y$[c], f = h[0];
      (r || a[f] !== s[f]) && (o || (Ei(n, i), o = true), n[f] = a[f] || h[1]);
    }
    return o;
  }
  function cot(n, t, e, r, i) {
    return nH(n, Hg(t, i.inHover), e && Hg(e, i.inHover), r, i);
  }
  function rH(n, t) {
    var e = t.transform, r = n.dpr || 1;
    e ? n.setTransform(r * e[0], r * e[1], r * e[2], r * e[3], r * e[4], r * e[5]) : n.setTransform(r, 0, 0, r, 0, 0);
  }
  function hot(n, t, e) {
    for (var r = false, i = 0; i < n.length; i++) {
      var a = n[i];
      r = r || a.isZeroArea(), rH(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
    }
    e.allClipped = r;
  }
  function fot(n, t) {
    return n && t ? n[0] !== t[0] || n[1] !== t[1] || n[2] !== t[2] || n[3] !== t[3] || n[4] !== t[4] || n[5] !== t[5] : !(!n && !t);
  }
  var b$ = 1, _$ = 2, w$ = 3, S$ = 4;
  function dot(n) {
    var t = nb(n), e = eb(n);
    return !(n.lineDash || !(+t ^ +e) || t && typeof n.fill != "string" || e && typeof n.stroke != "string" || n.strokePercent < 1 || n.strokeOpacity < 1 || n.fillOpacity < 1);
  }
  function Ei(n, t) {
    t.batchFill && n.fill(), t.batchStroke && n.stroke(), t.batchFill = "", t.batchStroke = "";
  }
  function Hg(n, t) {
    return t && n.__hoverStyle || n.style;
  }
  function iH(n, t) {
    wc(n, t, {
      inHover: false,
      viewWidth: 0,
      viewHeight: 0
    }, true);
  }
  function wc(n, t, e, r) {
    var i = t.transform;
    if (!t.shouldBePainted(e.viewWidth, e.viewHeight, false, false)) {
      t.__dirty &= -2, t.__isRendered = false;
      return;
    }
    var a = t.__clipPaths, s = e.prevElClipPaths, o = false, l = false;
    if ((!s || iot(a, s)) && (s && s.length && (Ei(n, e), n.restore(), l = o = true, e.prevElClipPaths = null, e.allClipped = false, e.prevEl = null), a && a.length && (Ei(n, e), n.save(), hot(a, n, e), o = true), e.prevElClipPaths = a), e.allClipped) {
      t.__isRendered = false;
      return;
    }
    t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
    var u = e.prevEl;
    u || (l = o = true);
    var c = t instanceof le && t.autoBatch && dot(t.style);
    o || fot(i, u.transform) ? (Ei(n, e), rH(n, t)) : c || Ei(n, e);
    var h = Hg(t, e.inHover);
    t instanceof le ? (e.lastDrawType !== b$ && (l = true, e.lastDrawType = b$), x$(n, t, u, l, e), (!c || !e.batchFill && !e.batchStroke) && n.beginPath(), oot(n, t, h, c), c && (e.batchFill = h.fill || "", e.batchStroke = h.stroke || "")) : t instanceof Vf ? (e.lastDrawType !== w$ && (l = true, e.lastDrawType = w$), x$(n, t, u, l, e), uot(n, t, h)) : t instanceof br ? (e.lastDrawType !== _$ && (l = true, e.lastDrawType = _$), cot(n, t, u, l, e), lot(n, t, h)) : t.getTemporalDisplayables && (e.lastDrawType !== S$ && (l = true, e.lastDrawType = S$), pot(n, t, e)), c && r && Ei(n, e), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), e.prevEl = t, t.__dirty = 0, t.__isRendered = true;
  }
  function pot(n, t, e) {
    var r = t.getDisplayables(), i = t.getTemporalDisplayables();
    n.save();
    var a = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: false,
      viewWidth: e.viewWidth,
      viewHeight: e.viewHeight,
      inHover: e.inHover
    }, s, o;
    for (s = t.getCursor(), o = r.length; s < o; s++) {
      var l = r[s];
      l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), wc(n, l, a, s === o - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
    }
    for (var u = 0, c = i.length; u < c; u++) {
      var l = i[u];
      l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), wc(n, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
    }
    t.clearTemporalDisplayables(), t.notClear = true, n.restore();
  }
  var LS = new Yst(), C$ = new Ev(100), T$ = [
    "symbol",
    "symbolSize",
    "symbolKeepAspect",
    "color",
    "backgroundColor",
    "dashArrayX",
    "dashArrayY",
    "maxTileWidth",
    "maxTileHeight"
  ];
  function Uf(n, t) {
    if (n === "none") return null;
    var e = t.getDevicePixelRatio(), r = t.getZr(), i = r.painter.type === "svg";
    n.dirty && LS.delete(n);
    var a = LS.get(n);
    if (a) return a;
    var s = $t(n, {
      symbol: "rect",
      symbolSize: 1,
      symbolKeepAspect: true,
      color: "rgba(0, 0, 0, 0.2)",
      backgroundColor: null,
      dashArrayX: 5,
      dashArrayY: 5,
      rotation: 0,
      maxTileWidth: 512,
      maxTileHeight: 512
    });
    s.backgroundColor === "none" && (s.backgroundColor = null);
    var o = {
      repeat: "repeat"
    };
    return l(o), o.rotation = s.rotation, o.scaleX = o.scaleY = i ? 1 : 1 / e, LS.set(n, o), n.dirty = false, o;
    function l(u) {
      for (var c = [
        e
      ], h = true, f = 0; f < T$.length; ++f) {
        var d = s[T$[f]];
        if (d != null && !ct(d) && !wt(d) && !_e(d) && typeof d != "boolean") {
          h = false;
          break;
        }
        c.push(d);
      }
      var p;
      if (h) {
        p = c.join(",") + (i ? "-svg" : "");
        var g = C$.get(p);
        g && (i ? u.svgElement = g : u.image = g);
      }
      var v = sH(s.dashArrayX), m = got(s.dashArrayY), y = aH(s.symbol), x = vot(v), b = oH(m), _ = !i && Xl.createCanvas(), w = i && {
        tag: "g",
        attrs: {},
        key: "dcl",
        children: []
      }, S = T(), I;
      _ && (_.width = S.width * e, _.height = S.height * e, I = _.getContext("2d")), A(), h && C$.put(p, _ || w), u.image = _, u.svgElement = w, u.svgWidth = S.width, u.svgHeight = S.height;
      function T() {
        for (var C = 1, D = 0, E = x.length; D < E; ++D) C = GL(C, x[D]);
        for (var M = 1, D = 0, E = y.length; D < E; ++D) M = GL(M, y[D].length);
        C *= M;
        var L = b * x.length * y.length;
        return {
          width: Math.max(1, Math.min(C, s.maxTileWidth)),
          height: Math.max(1, Math.min(L, s.maxTileHeight))
        };
      }
      function A() {
        I && (I.clearRect(0, 0, _.width, _.height), s.backgroundColor && (I.fillStyle = s.backgroundColor, I.fillRect(0, 0, _.width, _.height)));
        for (var C = 0, D = 0; D < m.length; ++D) C += m[D];
        if (C <= 0) return;
        for (var E = -b, M = 0, L = 0, k = 0; E < S.height; ) {
          if (M % 2 === 0) {
            for (var N = L / 2 % y.length, R = 0, $ = 0, O = 0; R < S.width * 2; ) {
              for (var F = 0, D = 0; D < v[k].length; ++D) F += v[k][D];
              if (F <= 0) break;
              if ($ % 2 === 0) {
                var z = (1 - s.symbolSize) * 0.5, V = R + v[k][$] * z, U = E + m[M] * z, X = v[k][$] * s.symbolSize, at = m[M] * s.symbolSize, pt = O / 2 % y[N].length;
                it(V, U, X, at, y[N][pt]);
              }
              R += v[k][$], ++O, ++$, $ === v[k].length && ($ = 0);
            }
            ++k, k === v.length && (k = 0);
          }
          E += m[M], ++L, ++M, M === m.length && (M = 0);
        }
        function it(et, ft, ut, gt, kt) {
          var At = i ? 1 : e, mt = Fn(kt, et * At, ft * At, ut * At, gt * At, s.color, s.symbolKeepAspect);
          if (i) {
            var _t = r.painter.renderOneToVNode(mt);
            _t && w.children.push(_t);
          } else iH(I, mt);
        }
      }
    }
  }
  function aH(n) {
    if (!n || n.length === 0) return [
      [
        "rect"
      ]
    ];
    if (wt(n)) return [
      [
        n
      ]
    ];
    for (var t = true, e = 0; e < n.length; ++e) if (!wt(n[e])) {
      t = false;
      break;
    }
    if (t) return aH([
      n
    ]);
    for (var r = [], e = 0; e < n.length; ++e) wt(n[e]) ? r.push([
      n[e]
    ]) : r.push(n[e]);
    return r;
  }
  function sH(n) {
    if (!n || n.length === 0) return [
      [
        0,
        0
      ]
    ];
    if (_e(n)) {
      var t = Math.ceil(n);
      return [
        [
          t,
          t
        ]
      ];
    }
    for (var e = true, r = 0; r < n.length; ++r) if (!_e(n[r])) {
      e = false;
      break;
    }
    if (e) return sH([
      n
    ]);
    for (var i = [], r = 0; r < n.length; ++r) if (_e(n[r])) {
      var t = Math.ceil(n[r]);
      i.push([
        t,
        t
      ]);
    } else {
      var t = ht(n[r], function(o) {
        return Math.ceil(o);
      });
      t.length % 2 === 1 ? i.push(t.concat(t)) : i.push(t);
    }
    return i;
  }
  function got(n) {
    if (!n || typeof n == "object" && n.length === 0) return [
      0,
      0
    ];
    if (_e(n)) {
      var t = Math.ceil(n);
      return [
        t,
        t
      ];
    }
    var e = ht(n, function(r) {
      return Math.ceil(r);
    });
    return n.length % 2 ? e.concat(e) : e;
  }
  function vot(n) {
    return ht(n, function(t) {
      return oH(t);
    });
  }
  function oH(n) {
    for (var t = 0, e = 0; e < n.length; ++e) t += n[e];
    return n.length % 2 === 1 ? t * 2 : t;
  }
  function mot(n, t) {
    n.eachRawSeries(function(e) {
      if (!n.isSeriesFiltered(e)) {
        var r = e.getData();
        r.hasItemVisual() && r.each(function(s) {
          var o = r.getItemVisual(s, "decal");
          if (o) {
            var l = r.ensureUniqueItemVisual(s, "style");
            l.decal = Uf(o, t);
          }
        });
        var i = r.getVisual("decal");
        if (i) {
          var a = r.getVisual("style");
          a.decal = Uf(i, t);
        }
      }
    });
  }
  var Ua = new Da(), lH = {};
  function yot(n, t) {
    lH[n] = t;
  }
  function xot(n) {
    return lH[n];
  }
  var bot = 1, _ot = 800, wot = 900, Sot = 1e3, Cot = 2e3, Tot = 5e3, uH = 1e3, Iot = 1100, _D = 2e3, cH = 3e3, Aot = 4e3, V1 = 4500, kot = 4600, Dot = 5e3, Eot = 6e3, hH = 7e3, Mot = {
    PROCESSOR: {
      FILTER: Sot,
      SERIES_FILTER: _ot,
      STATISTIC: Tot
    },
    VISUAL: {
      LAYOUT: uH,
      PROGRESSIVE_LAYOUT: Iot,
      GLOBAL: _D,
      CHART: cH,
      POST_CHART_LAYOUT: kot,
      COMPONENT: Aot,
      BRUSH: Dot,
      CHART_ITEM: V1,
      ARIA: Eot,
      DECAL: hH
    }
  }, Fr = "__flagInMainProcess", Ci = "__pendingUpdate", PS = "__needsUpdateStatus", I$ = /^[a-zA-Z0-9_]+$/, $S = "__connectUpdateStatus", A$ = 0, Rot = 1, Not = 2;
  function fH(n) {
    return function() {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      if (this.isDisposed()) {
        this.id;
        return;
      }
      return pH(this, n, t);
    };
  }
  function dH(n) {
    return function() {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      return pH(this, n, t);
    };
  }
  function pH(n, t, e) {
    return e[0] = e[0] && e[0].toLowerCase(), Da.prototype[t].apply(n, e);
  }
  var gH = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t;
  }(Da), vH = gH.prototype;
  vH.on = dH("on");
  vH.off = dH("off");
  var Wh, OS, Uy, cl, FS, BS, zS, up, cp, k$, D$, VS, E$, Hy, M$, mH, ra, R$, yH = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this, new Vst()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, wt(r) && (r = xH[r]), a._dom = e;
      var s = "canvas", o = "auto", l = false;
      i.ssr && Ant(function(f) {
        var d = Ut(f), p = d.dataIndex;
        if (p != null) {
          var g = It();
          return g.set("series_index", d.seriesIndex), g.set("data_index", p), d.ssrType && g.set("ssr_type", d.ssrType), g;
        }
      });
      var u = a._zr = BL(e, {
        renderer: i.renderer || s,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: Ht(i.useDirtyRect, l),
        useCoarsePointer: Ht(i.useCoarsePointer, o),
        pointerSize: i.pointerSize
      });
      a._ssr = i.ssr, a._throttledZrFlush = yD(St(u.flush, u), 17), r = Bt(r), r && C5(r, true), a._theme = r, a._locale = Jit(i.locale || QU), a._coordSysMgr = new Bv();
      var c = a._api = M$(a);
      function h(f, d) {
        return f.__prio - d.__prio;
      }
      return rx(ib, h), rx(fA, h), a._scheduler = new j5(a, c, fA, ib), a._messageCenter = new gH(), a._initEvents(), a.resize = St(a.resize, a), u.animation.on("frame", a._onframe, a), k$(u, a), D$(u, a), $x(a), a;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        R$(this);
        var e = this._scheduler;
        if (this[Ci]) {
          var r = this[Ci].silent;
          this[Fr] = true;
          try {
            Wh(this), cl.update.call(this, null, this[Ci].updateParams);
          } catch (l) {
            throw this[Fr] = false, this[Ci] = null, l;
          }
          this._zr.flush(), this[Fr] = false, this[Ci] = null, up.call(this, r), cp.call(this, r);
        } else if (e.unfinished) {
          var i = bot, a = this._model, s = this._api;
          e.unfinished = false;
          do {
            var o = +/* @__PURE__ */ new Date();
            e.performSeriesTasks(a), e.performDataProcessorTasks(a), BS(this, a), e.performVisualTasks(a), Hy(this, this._model, s, "remain", {}), i -= +/* @__PURE__ */ new Date() - o;
          } while (i > 0 && e.unfinished);
          e.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(e, r, i) {
      if (!this[Fr]) {
        if (this._disposed) {
          this.id;
          return;
        }
        var a, s, o;
        if (Ft(r) && (i = r.lazyUpdate, a = r.silent, s = r.replaceMerge, o = r.transition, r = r.notMerge), this[Fr] = true, !this._model || r) {
          var l = new Sat(this._api), u = this._theme, c = this._model = new dD();
          c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
        }
        this._model.setOption(e, {
          replaceMerge: s
        }, dA);
        var h = {
          seriesTransition: o,
          optionChanged: true
        };
        if (i) this[Ci] = {
          silent: a,
          updateParams: h
        }, this[Fr] = false, this.getZr().wakeUp();
        else {
          try {
            Wh(this), cl.update.call(this, null, h);
          } catch (f) {
            throw this[Ci] = null, this[Fr] = false, f;
          }
          this._ssr || this._zr.flush(), this[Ci] = null, this[Fr] = false, up.call(this, a), cp.call(this, a);
        }
      }
    }, t.prototype.setTheme = function() {
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || ce.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(e) {
      return this.renderToCanvas(e);
    }, t.prototype.renderToCanvas = function(e) {
      e = e || {};
      var r = this._zr.painter;
      return r.getRenderedCanvas({
        backgroundColor: e.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: e.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(e) {
      e = e || {};
      var r = this._zr.painter;
      return r.renderToString({
        useViewBox: e.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      if (ce.svgSupported) {
        var e = this._zr, r = e.storage.getDisplayList();
        return P(r, function(i) {
          i.stopAnimation(null, true);
        }), e.painter.toDataURL();
      }
    }, t.prototype.getDataURL = function(e) {
      if (this._disposed) {
        this.id;
        return;
      }
      e = e || {};
      var r = e.excludeComponents, i = this._model, a = [], s = this;
      P(r, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = s._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = true);
        });
      });
      var o = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(e).toDataURL("image/" + (e && e.type || "png"));
      return P(a, function(l) {
        l.group.ignore = false;
      }), o;
    }, t.prototype.getConnectedDataURL = function(e) {
      if (this._disposed) {
        this.id;
        return;
      }
      var r = e.type === "svg", i = this.group, a = Math.min, s = Math.max, o = 1 / 0;
      if (N$[i]) {
        var l = o, u = o, c = -o, h = -o, f = [], d = e && e.pixelRatio || this.getDevicePixelRatio();
        P(yg, function(x, b) {
          if (x.group === i) {
            var _ = r ? x.getZr().painter.getSvgDom().innerHTML : x.renderToCanvas(Bt(e)), w = x.getDom().getBoundingClientRect();
            l = a(w.left, l), u = a(w.top, u), c = s(w.right, c), h = s(w.bottom, h), f.push({
              dom: _,
              left: w.left,
              top: w.top
            });
          }
        }), l *= d, u *= d, c *= d, h *= d;
        var p = c - l, g = h - u, v = Xl.createCanvas(), m = BL(v, {
          renderer: r ? "svg" : "canvas"
        });
        if (m.resize({
          width: p,
          height: g
        }), r) {
          var y = "";
          return P(f, function(x) {
            var b = x.left - l, _ = x.top - u;
            y += '<g transform="translate(' + b + "," + _ + ')">' + x.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, e.connectedBackgroundColor && m.painter.setBackgroundColor(e.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else return e.connectedBackgroundColor && m.add(new ye({
          shape: {
            x: 0,
            y: 0,
            width: p,
            height: g
          },
          style: {
            fill: e.connectedBackgroundColor
          }
        })), P(f, function(x) {
          var b = new br({
            style: {
              x: x.left * d - l,
              y: x.top * d - u,
              image: x.dom
            }
          });
          m.add(b);
        }), m.refreshImmediately(), v.toDataURL("image/" + (e && e.type || "png"));
      } else return this.getDataURL(e);
    }, t.prototype.convertToPixel = function(e, r) {
      return FS(this, "convertToPixel", e, r);
    }, t.prototype.convertFromPixel = function(e, r) {
      return FS(this, "convertFromPixel", e, r);
    }, t.prototype.containPixel = function(e, r) {
      if (this._disposed) {
        this.id;
        return;
      }
      var i = this._model, a, s = hg(i, e);
      return P(s, function(o, l) {
        l.indexOf("Models") >= 0 && P(o, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint) a = a || !!c.containPoint(r);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint && (a = a || h.containPoint(r, u));
          }
        }, this);
      }, this), !!a;
    }, t.prototype.getVisual = function(e, r) {
      var i = this._model, a = hg(i, e, {
        defaultMainType: "series"
      }), s = a.seriesModel, o = s.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? o.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? xD(o, l, r) : zv(o, r);
    }, t.prototype.getViewOfComponentModel = function(e) {
      return this._componentsMap[e.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(e) {
      return this._chartsMap[e.__viewId];
    }, t.prototype._initEvents = function() {
      var e = this;
      P(Lot, function(r) {
        var i = function(a) {
          var s = e.getModel(), o = a.target, l, u = r === "globalout";
          if (u ? l = {} : o && bc(o, function(p) {
            var g = Ut(p);
            if (g && g.dataIndex != null) {
              var v = g.dataModel || s.getSeriesByIndex(g.seriesIndex);
              return l = v && v.getDataParams(g.dataIndex, g.dataType, o) || {}, true;
            } else if (g.eventData) return l = rt({}, g.eventData), true;
          }, true), l) {
            var c = l.componentType, h = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", h = l.seriesIndex);
            var f = c && h != null && s.getComponent(c, h), d = f && e[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            l.event = a, l.type = r, e._$eventProcessor.eventInfo = {
              targetEl: o,
              packedEvent: l,
              model: f,
              view: d
            }, e.trigger(r, l);
          }
        };
        i.zrEventfulCallAtLast = true, e._zr.on(r, i, e);
      }), P(mg, function(r, i) {
        e._messageCenter.on(i, function(a) {
          this.trigger(i, a);
        }, e);
      }), P([
        "selectchanged"
      ], function(r) {
        e._messageCenter.on(r, function(i) {
          this.trigger(r, i);
        }, e);
      }), Ust(this._messageCenter, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this.setOption({
        series: []
      }, true);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._disposed = true;
      var e = this.getDom();
      e && hU(this.getDom(), SD, "");
      var r = this, i = r._api, a = r._model;
      P(r._componentsViews, function(s) {
        s.dispose(a, i);
      }), P(r._chartsViews, function(s) {
        s.dispose(a, i);
      }), r._zr.dispose(), r._dom = r._model = r._chartsMap = r._componentsMap = r._chartsViews = r._componentsViews = r._scheduler = r._api = r._zr = r._throttledZrFlush = r._theme = r._coordSysMgr = r._messageCenter = null, delete yg[r.id];
    }, t.prototype.resize = function(e) {
      if (!this[Fr]) {
        if (this._disposed) {
          this.id;
          return;
        }
        this._zr.resize(e);
        var r = this._model;
        if (this._loadingFX && this._loadingFX.resize(), !!r) {
          var i = r.resetOption("media"), a = e && e.silent;
          this[Ci] && (a == null && (a = this[Ci].silent), i = true, this[Ci] = null), this[Fr] = true;
          try {
            i && Wh(this), cl.update.call(this, {
              type: "resize",
              animation: rt({
                duration: 0
              }, e && e.animation)
            });
          } catch (s) {
            throw this[Fr] = false, s;
          }
          this[Fr] = false, up.call(this, a), cp.call(this, a);
        }
      }
    }, t.prototype.showLoading = function(e, r) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (Ft(e) && (r = e, e = ""), e = e || "default", this.hideLoading(), !!pA[e]) {
        var i = pA[e](this._api, r), a = this._zr;
        this._loadingFX = i, a.add(i);
      }
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(e) {
      var r = rt({}, e);
      return r.type = mg[e.type], r;
    }, t.prototype.dispatchAction = function(e, r) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (Ft(r) || (r = {
        silent: !!r
      }), !!rb[e.type] && this._model) {
        if (this[Fr]) {
          this._pendingActions.push(e);
          return;
        }
        var i = r.silent;
        zS.call(this, e, i);
        var a = r.flush;
        a ? this._zr.flush() : a !== false && ce.browser.weChat && this._throttledZrFlush(), up.call(this, i), cp.call(this, i);
      }
    }, t.prototype.updateLabelLayout = function() {
      Ua.trigger("series:layoutlabels", this._model, this._api, {
        updatedSeries: []
      });
    }, t.prototype.appendData = function(e) {
      if (this._disposed) {
        this.id;
        return;
      }
      var r = e.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(r);
      a.appendData(e), this._scheduler.unfinished = true, this.getZr().wakeUp();
    }, t.internalField = function() {
      Wh = function(h) {
        var f = h._scheduler;
        f.restorePipelines(h._model), f.prepareStageTasks(), OS(h, true), OS(h, false), f.plan();
      }, OS = function(h, f) {
        for (var d = h._model, p = h._scheduler, g = f ? h._componentsViews : h._chartsViews, v = f ? h._componentsMap : h._chartsMap, m = h._zr, y = h._api, x = 0; x < g.length; x++) g[x].__alive = false;
        f ? d.eachComponent(function(w, S) {
          w !== "series" && b(S);
        }) : d.eachSeries(b);
        function b(w) {
          var S = w.__requireNewView;
          w.__requireNewView = false;
          var I = "_ec_" + w.id + "_" + w.type, T = !S && v[I];
          if (!T) {
            var A = Bs(w.type), C = f ? vn.getClass(A.main, A.sub) : qe.getClass(A.sub);
            T = new C(), T.init(d, y), v[I] = T, g.push(T), m.add(T.group);
          }
          w.__viewId = T.__id = I, T.__alive = true, T.__model = w, T.group.__ecComponentInfo = {
            mainType: w.mainType,
            index: w.componentIndex
          }, !f && p.prepareView(T, w, d, y);
        }
        for (var x = 0; x < g.length; ) {
          var _ = g[x];
          _.__alive ? x++ : (!f && _.renderTask.dispose(), m.remove(_.group), _.dispose(d, y), g.splice(x, 1), v[_.__id] === _ && delete v[_.__id], _.__id = _.group.__ecComponentInfo = null);
        }
      }, Uy = function(h, f, d, p, g) {
        var v = h._model;
        if (v.setUpdatePayload(d), !p) {
          P([].concat(h._componentsViews).concat(h._chartsViews), _);
          return;
        }
        var m = {};
        m[p + "Id"] = d[p + "Id"], m[p + "Index"] = d[p + "Index"], m[p + "Name"] = d[p + "Name"];
        var y = {
          mainType: p,
          query: m
        };
        g && (y.subType = g);
        var x = d.excludeSeriesId, b;
        x != null && (b = It(), P(He(x), function(w) {
          var S = Un(w, null);
          S != null && b.set(S, true);
        })), v && v.eachComponent(y, function(w) {
          var S = b && b.get(w.id) != null;
          if (!S) if (pP(d)) if (w instanceof an) d.type === Rc && !d.notBlur && !w.get([
            "emphasis",
            "disabled"
          ]) && Zrt(w, d, h._api);
          else {
            var I = Jk(w.mainType, w.componentIndex, d.name, h._api), T = I.focusSelf, A = I.dispatchers;
            d.type === Rc && T && !d.notBlur && qI(w.mainType, w.componentIndex, h._api), A && P(A, function(C) {
              d.type === Rc ? Vo(C) : Go(C);
            });
          }
          else KI(d) && w instanceof an && (tit(w, d, h._api), fP(w), ra(h));
        }, h), v && v.eachComponent(y, function(w) {
          var S = b && b.get(w.id) != null;
          S || _(h[p === "series" ? "_chartsMap" : "_componentsMap"][w.__viewId]);
        }, h);
        function _(w) {
          w && w.__alive && w[f] && w[f](w.__model, v, h._api, d);
        }
      }, cl = {
        prepareAndUpdate: function(h) {
          Wh(this), cl.update.call(this, h, {
            optionChanged: h.newOption != null
          });
        },
        update: function(h, f) {
          var d = this._model, p = this._api, g = this._zr, v = this._coordSysMgr, m = this._scheduler;
          if (d) {
            d.setUpdatePayload(h), m.restoreData(d, h), m.performSeriesTasks(d), v.create(d, p), m.performDataProcessorTasks(d, h), BS(this, d), v.update(d, p), e(d), m.performVisualTasks(d, h), VS(this, d, p, h, f);
            var y = d.get("backgroundColor") || "transparent", x = d.get("darkMode");
            g.setBackgroundColor(y), x != null && x !== "auto" && g.setDarkMode(x), Ua.trigger("afterupdate", d, p);
          }
        },
        updateTransform: function(h) {
          var f = this, d = this._model, p = this._api;
          if (d) {
            d.setUpdatePayload(h);
            var g = [];
            d.eachComponent(function(m, y) {
              if (m !== "series") {
                var x = f.getViewOfComponentModel(y);
                if (x && x.__alive) if (x.updateTransform) {
                  var b = x.updateTransform(y, d, p, h);
                  b && b.update && g.push(x);
                } else g.push(x);
              }
            });
            var v = It();
            d.eachSeries(function(m) {
              var y = f._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var x = y.updateTransform(m, d, p, h);
                x && x.update && v.set(m.uid, 1);
              } else v.set(m.uid, 1);
            }), e(d), this._scheduler.performVisualTasks(d, h, {
              setDirty: true,
              dirtyMap: v
            }), Hy(this, d, p, h, {}, v), Ua.trigger("afterupdate", d, p);
          }
        },
        updateView: function(h) {
          var f = this._model;
          f && (f.setUpdatePayload(h), qe.markUpdateMethod(h, "updateView"), e(f), this._scheduler.performVisualTasks(f, h, {
            setDirty: true
          }), VS(this, f, this._api, h, {}), Ua.trigger("afterupdate", f, this._api));
        },
        updateVisual: function(h) {
          var f = this, d = this._model;
          d && (d.setUpdatePayload(h), d.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), qe.markUpdateMethod(h, "updateVisual"), e(d), this._scheduler.performVisualTasks(d, h, {
            visualType: "visual",
            setDirty: true
          }), d.eachComponent(function(p, g) {
            if (p !== "series") {
              var v = f.getViewOfComponentModel(g);
              v && v.__alive && v.updateVisual(g, d, f._api, h);
            }
          }), d.eachSeries(function(p) {
            var g = f._chartsMap[p.__viewId];
            g.updateVisual(p, d, f._api, h);
          }), Ua.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(h) {
          cl.update.call(this, h);
        }
      }, FS = function(h, f, d, p) {
        if (h._disposed) {
          h.id;
          return;
        }
        for (var g = h._model, v = h._coordSysMgr.getCoordinateSystems(), m, y = hg(g, d), x = 0; x < v.length; x++) {
          var b = v[x];
          if (b[f] && (m = b[f](g, y, p)) != null) return m;
        }
      }, BS = function(h, f) {
        var d = h._chartsMap, p = h._scheduler;
        f.eachSeries(function(g) {
          p.updateStreamModes(g, d[g.__viewId]);
        });
      }, zS = function(h, f) {
        var d = this, p = this.getModel(), g = h.type, v = h.escapeConnect, m = rb[g], y = m.actionInfo, x = (y.update || "update").split(":"), b = x.pop(), _ = x[0] != null && Bs(x[0]);
        this[Fr] = true;
        var w = [
          h
        ], S = false;
        h.batch && (S = true, w = ht(h.batch, function(M) {
          return M = $t(rt({}, M), h), M.batch = null, M;
        }));
        var I = [], T, A = KI(h), C = pP(h);
        if (C && RU(this._api), P(w, function(M) {
          if (T = m.action(M, d._model, d._api), T = T || rt({}, M), T.type = y.event || T.type, I.push(T), C) {
            var L = Uk(h), k = L.queryOptionMap, N = L.mainTypeSpecified, R = N ? k.keys()[0] : "series";
            Uy(d, b, M, R), ra(d);
          } else A ? (Uy(d, b, M, "series"), ra(d)) : _ && Uy(d, b, M, _.main, _.sub);
        }), b !== "none" && !C && !A && !_) try {
          this[Ci] ? (Wh(this), cl.update.call(this, h), this[Ci] = null) : cl[b].call(this, h);
        } catch (M) {
          throw this[Fr] = false, M;
        }
        if (S ? T = {
          type: y.event || g,
          escapeConnect: v,
          batch: I
        } : T = I[0], this[Fr] = false, !f) {
          var D = this._messageCenter;
          if (D.trigger(T.type, T), A) {
            var E = {
              type: "selectchanged",
              escapeConnect: v,
              selected: eit(p),
              isFromClick: h.isFromClick || false,
              fromAction: h.type,
              fromActionPayload: h
            };
            D.trigger(E.type, E);
          }
        }
      }, up = function(h) {
        for (var f = this._pendingActions; f.length; ) {
          var d = f.shift();
          zS.call(this, d, h);
        }
      }, cp = function(h) {
        !h && this.trigger("updated");
      }, k$ = function(h, f) {
        h.on("rendered", function(d) {
          f.trigger("rendered", d), h.animation.isFinished() && !f[Ci] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
        });
      }, D$ = function(h, f) {
        h.on("mouseover", function(d) {
          var p = d.target, g = bc(p, Fg);
          g && (Jrt(g, d, f._api), ra(f));
        }).on("mouseout", function(d) {
          var p = d.target, g = bc(p, Fg);
          g && (Qrt(g, d, f._api), ra(f));
        }).on("click", function(d) {
          var p = d.target, g = bc(p, function(y) {
            return Ut(y).dataIndex != null;
          }, true);
          if (g) {
            var v = g.selected ? "unselect" : "select", m = Ut(g);
            f._api.dispatchAction({
              type: v,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: true
            });
          }
        });
      };
      function e(h) {
        h.clearColorPalette(), h.eachSeries(function(f) {
          f.clearColorPalette();
        });
      }
      function r(h) {
        var f = [], d = [], p = false;
        if (h.eachComponent(function(y, x) {
          var b = x.get("zlevel") || 0, _ = x.get("z") || 0, w = x.getZLevelKey();
          p = p || !!w, (y === "series" ? d : f).push({
            zlevel: b,
            z: _,
            idx: x.componentIndex,
            type: y,
            key: w
          });
        }), p) {
          var g = f.concat(d), v, m;
          rx(g, function(y, x) {
            return y.zlevel === x.zlevel ? y.z - x.z : y.zlevel - x.zlevel;
          }), P(g, function(y) {
            var x = h.getComponent(y.type, y.idx), b = y.zlevel, _ = y.key;
            v != null && (b = Math.max(v, b)), _ ? (b === v && _ !== m && b++, m = _) : m && (b === v && b++, m = ""), v = b, x.setZLevel(b);
          });
        }
      }
      VS = function(h, f, d, p, g) {
        r(f), E$(h, f, d, p, g), P(h._chartsViews, function(v) {
          v.__alive = false;
        }), Hy(h, f, d, p, g), P(h._chartsViews, function(v) {
          v.__alive || v.remove(f, d);
        });
      }, E$ = function(h, f, d, p, g, v) {
        P(v || h._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, f, d, p), o(y, m), c(y, m);
        });
      }, Hy = function(h, f, d, p, g, v) {
        var m = h._scheduler;
        g = rt(g || {}, {
          updatedSeries: f.getSeries()
        }), Ua.trigger("series:beforeupdate", f, d, g);
        var y = false;
        f.eachSeries(function(x) {
          var b = h._chartsMap[x.__viewId];
          b.__alive = true;
          var _ = b.renderTask;
          m.updatePayload(_, p), u(x, b), v && v.get(x.uid) && _.dirty(), _.perform(m.getPerformArgs(_)) && (y = true), b.group.silent = !!x.get("silent"), s(x, b), fP(x);
        }), m.unfinished = y || m.unfinished, Ua.trigger("series:layoutlabels", f, d, g), Ua.trigger("series:transition", f, d, g), f.eachSeries(function(x) {
          var b = h._chartsMap[x.__viewId];
          o(x, b), c(x, b);
        }), a(h, f), Ua.trigger("series:afterupdate", f, d, g);
      }, ra = function(h) {
        h[PS] = true, h.getZr().wakeUp();
      }, R$ = function(h) {
        h[PS] && (h.getZr().storage.traverse(function(f) {
          Df(f) || i(f);
        }), h[PS] = false);
      };
      function i(h) {
        for (var f = [], d = h.currentStates, p = 0; p < d.length; p++) {
          var g = d[p];
          g === "emphasis" || g === "blur" || g === "select" || f.push(g);
        }
        h.selected && h.states.select && f.push("select"), h.hoverState === T1 && h.states.emphasis ? f.push("emphasis") : h.hoverState === Nv && h.states.blur && f.push("blur"), h.useStates(f);
      }
      function a(h, f) {
        var d = h._zr, p = d.storage, g = 0;
        p.traverse(function(v) {
          v.isGroup || g++;
        }), g > f.get("hoverLayerThreshold") && !ce.node && !ce.worker && f.eachSeries(function(v) {
          if (!v.preventUsingHoverLayer) {
            var m = h._chartsMap[v.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = true);
            });
          }
        });
      }
      function s(h, f) {
        var d = h.get("blendMode") || null;
        f.eachRendered(function(p) {
          p.isGroup || (p.style.blend = d);
        });
      }
      function o(h, f) {
        if (!h.preventAutoZ) {
          var d = h.get("z") || 0, p = h.get("zlevel") || 0;
          f.eachRendered(function(g) {
            return l(g, d, p, -1 / 0), true;
          });
        }
      }
      function l(h, f, d, p) {
        var g = h.getTextContent(), v = h.getTextGuideLine(), m = h.isGroup;
        if (m) for (var y = h.childrenRef(), x = 0; x < y.length; x++) p = Math.max(l(y[x], f, d, p), p);
        else h.z = f, h.zlevel = d, p = Math.max(h.z2, p);
        if (g && (g.z = f, g.zlevel = d, isFinite(p) && (g.z2 = p + 2)), v) {
          var b = h.textGuideLineConfig;
          v.z = f, v.zlevel = d, isFinite(p) && (v.z2 = p + (b && b.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(h, f) {
        f.eachRendered(function(d) {
          if (!Df(d)) {
            var p = d.getTextContent(), g = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function c(h, f) {
        var d = h.getModel("stateAnimation"), p = h.isAnimationEnabled(), g = d.get("duration"), v = g > 0 ? {
          duration: g,
          delay: d.get("delay"),
          easing: d.get("easing")
        } : null;
        f.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (Df(m)) return;
            if (m instanceof le && sit(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (p) {
              m.stateTransition = v;
              var x = m.getTextContent(), b = m.getTextGuideLine();
              x && (x.stateTransition = v), b && (b.stateTransition = v);
            }
            m.__dirty && i(m);
          }
        });
      }
      M$ = function(h) {
        return new (function(f) {
          q(d, f);
          function d() {
            return f !== null && f.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null) return h._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, d.prototype.enterEmphasis = function(p, g) {
            Vo(p, g), ra(h);
          }, d.prototype.leaveEmphasis = function(p, g) {
            Go(p, g), ra(h);
          }, d.prototype.enterBlur = function(p) {
            kU(p), ra(h);
          }, d.prototype.leaveBlur = function(p) {
            Zk(p), ra(h);
          }, d.prototype.enterSelect = function(p) {
            DU(p), ra(h);
          }, d.prototype.leaveSelect = function(p) {
            EU(p), ra(h);
          }, d.prototype.getModel = function() {
            return h.getModel();
          }, d.prototype.getViewOfComponentModel = function(p) {
            return h.getViewOfComponentModel(p);
          }, d.prototype.getViewOfSeriesModel = function(p) {
            return h.getViewOfSeriesModel(p);
          }, d;
        }(w5))(h);
      }, mH = function(h) {
        function f(d, p) {
          for (var g = 0; g < d.length; g++) {
            var v = d[g];
            v[$S] = p;
          }
        }
        P(mg, function(d, p) {
          h._messageCenter.on(p, function(g) {
            if (N$[h.group] && h[$S] !== A$) {
              if (g && g.escapeConnect) return;
              var v = h.makeActionFromEvent(g), m = [];
              P(yg, function(y) {
                y !== h && y.group === h.group && m.push(y);
              }), f(m, A$), P(m, function(y) {
                y[$S] !== Rot && y.dispatchAction(v);
              }), f(m, Not);
            }
          });
        });
      };
    }(), t;
  }(Da), wD = yH.prototype;
  wD.on = fH("on");
  wD.off = fH("off");
  wD.one = function(n, t, e) {
    var r = this;
    function i() {
      for (var a = [], s = 0; s < arguments.length; s++) a[s] = arguments[s];
      t && t.apply && t.apply(this, a), r.off(n, i);
    }
    this.on.call(this, n, i, e);
  };
  var Lot = [
    "click",
    "dblclick",
    "mouseover",
    "mouseout",
    "mousemove",
    "mousedown",
    "mouseup",
    "globalout",
    "contextmenu"
  ];
  var rb = {}, mg = {}, fA = [], dA = [], ib = [], xH = {}, pA = {}, yg = {}, N$ = {}, Pot = +/* @__PURE__ */ new Date() - 0, SD = "_echarts_instance_";
  function $ot(n, t, e) {
    {
      var r = Oot(n);
      if (r) return r;
    }
    var i = new yH(n, t, e);
    return i.id = "ec_" + Pot++, yg[i.id] = i, hU(n, SD, i.id), mH(i), Ua.trigger("afterinit", i), i;
  }
  function Oot(n) {
    return yg[qnt(n, SD)];
  }
  function bH(n, t) {
    xH[n] = t;
  }
  function _H(n) {
    ne(dA, n) < 0 && dA.push(n);
  }
  function wH(n, t) {
    TD(fA, n, t, Cot);
  }
  function Fot(n) {
    CD("afterinit", n);
  }
  function Bot(n) {
    CD("afterupdate", n);
  }
  function CD(n, t) {
    Ua.on(n, t);
  }
  function co(n, t, e) {
    Nt(t) && (e = t, t = "");
    var r = Ft(n) ? n.type : [
      n,
      n = {
        event: t
      }
    ][0];
    n.event = (n.event || r).toLowerCase(), t = n.event, !mg[t] && (gi(I$.test(r) && I$.test(t)), rb[r] || (rb[r] = {
      action: e,
      actionInfo: n
    }), mg[t] = r);
  }
  function zot(n, t) {
    Bv.register(n, t);
  }
  function Vot(n, t) {
    TD(ib, n, t, uH, "layout");
  }
  function vh(n, t) {
    TD(ib, n, t, cH, "visual");
  }
  var L$ = [];
  function TD(n, t, e, r, i) {
    if ((Nt(t) || Ft(t)) && (e = t, t = r), !(ne(L$, e) >= 0)) {
      L$.push(e);
      var a = j5.wrapStageHandler(e, i);
      a.__prio = t, a.__raw = e, n.push(a);
    }
  }
  function SH(n, t) {
    pA[n] = t;
  }
  function Got(n, t, e) {
    var r = xot("registerMap");
    r && r(n, t, e);
  }
  var Wot = est;
  vh(_D, Ast);
  vh(V1, kst);
  vh(V1, Dst);
  vh(_D, Gst);
  vh(V1, Wst);
  vh(hH, mot);
  _H(C5);
  wH(wot, Pat);
  SH("default", Est);
  co({
    type: Rc,
    event: Rc,
    update: Rc
  }, Dn);
  co({
    type: ux,
    event: ux,
    update: ux
  }, Dn);
  co({
    type: fg,
    event: fg,
    update: fg
  }, Dn);
  co({
    type: cx,
    event: cx,
    update: cx
  }, Dn);
  co({
    type: dg,
    event: dg,
    update: dg
  }, Dn);
  bH("light", zst);
  bH("dark", Q5);
  var P$ = [], Uot = {
    registerPreprocessor: _H,
    registerProcessor: wH,
    registerPostInit: Fot,
    registerPostUpdate: Bot,
    registerUpdateLifecycle: CD,
    registerAction: co,
    registerCoordinateSystem: zot,
    registerLayout: Vot,
    registerVisual: vh,
    registerTransform: Wot,
    registerLoading: SH,
    registerMap: Got,
    registerImpl: yot,
    PRIORITY: Mot,
    ComponentModel: pe,
    ComponentView: vn,
    SeriesModel: an,
    ChartView: qe,
    registerComponentModel: function(n) {
      pe.registerClass(n);
    },
    registerComponentView: function(n) {
      vn.registerClass(n);
    },
    registerSeriesModel: function(n) {
      an.registerClass(n);
    },
    registerChartView: function(n) {
      qe.registerClass(n);
    },
    registerSubTypeDefaulter: function(n, t) {
      pe.registerSubTypeDefaulter(n, t);
    },
    registerPainter: function(n, t) {
      Tnt(n, t);
    }
  };
  function se(n) {
    if (ct(n)) {
      P(n, function(t) {
        se(t);
      });
      return;
    }
    ne(P$, n) >= 0 || (P$.push(n), Nt(n) && (n = {
      install: n
    }), n.install(Uot));
  }
  function hp(n) {
    return n == null ? 0 : n.length || 1;
  }
  function $$(n) {
    return n;
  }
  var Wo = function() {
    function n(t, e, r, i, a, s) {
      this._old = t, this._new = e, this._oldKeyGetter = r || $$, this._newKeyGetter = i || $$, this.context = a, this._diffModeMultiple = s === "multiple";
    }
    return n.prototype.add = function(t) {
      return this._add = t, this;
    }, n.prototype.update = function(t) {
      return this._update = t, this;
    }, n.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, n.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, n.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, n.prototype.remove = function(t) {
      return this._remove = t, this;
    }, n.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, n.prototype._executeOneToOne = function() {
      var t = this._old, e = this._new, r = {}, i = new Array(t.length), a = new Array(e.length);
      this._initIndexMap(t, null, i, "_oldKeyGetter"), this._initIndexMap(e, r, a, "_newKeyGetter");
      for (var s = 0; s < t.length; s++) {
        var o = i[s], l = r[o], u = hp(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (r[o] = l[0]), this._update && this._update(c, s);
        } else u === 1 ? (r[o] = null, this._update && this._update(l, s)) : this._remove && this._remove(s);
      }
      this._performRestAdd(a, r);
    }, n.prototype._executeMultiple = function() {
      var t = this._old, e = this._new, r = {}, i = {}, a = [], s = [];
      this._initIndexMap(t, r, a, "_oldKeyGetter"), this._initIndexMap(e, i, s, "_newKeyGetter");
      for (var o = 0; o < a.length; o++) {
        var l = a[o], u = r[l], c = i[l], h = hp(u), f = hp(c);
        if (h > 1 && f === 1) this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (h === 1 && f > 1) this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (h === 1 && f === 1) this._update && this._update(c, u), i[l] = null;
        else if (h > 1 && f > 1) this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (h > 1) for (var d = 0; d < h; d++) this._remove && this._remove(u[d]);
        else this._remove && this._remove(u);
      }
      this._performRestAdd(s, i);
    }, n.prototype._performRestAdd = function(t, e) {
      for (var r = 0; r < t.length; r++) {
        var i = t[r], a = e[i], s = hp(a);
        if (s > 1) for (var o = 0; o < s; o++) this._add && this._add(a[o]);
        else s === 1 && this._add && this._add(a);
        e[i] = null;
      }
    }, n.prototype._initIndexMap = function(t, e, r, i) {
      for (var a = this._diffModeMultiple, s = 0; s < t.length; s++) {
        var o = "_ec_" + this[i](t[s], s);
        if (a || (r[s] = o), !!e) {
          var l = e[o], u = hp(l);
          u === 0 ? (e[o] = s, a && r.push(o)) : u === 1 ? e[o] = [
            l,
            s
          ] : l.push(s);
        }
      }
    }, n;
  }(), Hot = function() {
    function n(t, e) {
      this._encode = t, this._schema = e;
    }
    return n.prototype.get = function() {
      return {
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, n.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, n;
  }();
  function Xot(n, t) {
    var e = {}, r = e.encode = {}, i = It(), a = [], s = [], o = {};
    P(n.dimensions, function(f) {
      var d = n.getDimensionInfo(f), p = d.coordDim;
      if (p) {
        var g = d.coordDimIndex;
        GS(r, p)[g] = f, d.isExtraCoord || (i.set(p, 1), Yot(d.type) && (a[0] = f), GS(o, p)[g] = n.getDimensionIndex(d.name)), d.defaultTooltip && s.push(f);
      }
      g5.each(function(v, m) {
        var y = GS(r, m), x = d.otherDims[m];
        x != null && x !== false && (y[x] = d.name);
      });
    });
    var l = [], u = {};
    i.each(function(f, d) {
      var p = r[d];
      u[d] = p[0], l = l.concat(p);
    }), e.dataDimsOnCoord = l, e.dataDimIndicesOnCoord = ht(l, function(f) {
      return n.getDimensionInfo(f).storeDimIndex;
    }), e.encodeFirstDimNotExtra = u;
    var c = r.label;
    c && c.length && (a = c.slice());
    var h = r.tooltip;
    return h && h.length ? s = h.slice() : s.length || (s = a.slice()), r.defaultedLabel = a, r.defaultedTooltip = s, e.userOutput = new Hot(o, t), e;
  }
  function GS(n, t) {
    return n.hasOwnProperty(t) || (n[t] = []), n[t];
  }
  function ab(n) {
    return n === "category" ? "ordinal" : n === "time" ? "time" : "float";
  }
  function Yot(n) {
    return !(n === "ordinal" || n === "time");
  }
  var gx = /* @__PURE__ */ function() {
    function n(t) {
      this.otherDims = {}, t != null && rt(this, t);
    }
    return n;
  }(), qot = xe(), jot = {
    float: "f",
    int: "i",
    ordinal: "o",
    number: "n",
    time: "t"
  }, CH = function() {
    function n(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return n.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, n.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = AH(this.source)));
    }, n.prototype.getSourceDimensionIndex = function(t) {
      return Ht(this._dimNameMap.get(t), -1);
    }, n.prototype.getSourceDimension = function(t) {
      var e = this.source.dimensionsDefine;
      if (e) return e[t];
    }, n.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, e = I5(this.source), r = !kH(t), i = "", a = [], s = 0, o = 0; s < t; s++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[o];
        if (h && h.storeDimIndex === s) l = e ? h.name : null, u = h.type, c = h.ordinalMeta, o++;
        else {
          var f = this.getSourceDimension(s);
          f && (l = e ? f.name : null, u = f.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), e && l != null && (!h || !h.isCalculationCoord) && (i += r ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += jot[u] || "f", c && (i += c.uid), i += "$";
      }
      var d = this.source, p = [
        d.seriesLayoutBy,
        d.startIndex,
        i
      ].join("$$");
      return {
        dimensions: a,
        hash: p
      };
    }, n.prototype.makeOutputDimensionNames = function() {
      for (var t = [], e = 0, r = 0; e < this._fullDimCount; e++) {
        var i = void 0, a = this.dimensions[r];
        if (a && a.storeDimIndex === e) a.isCalculationCoord || (i = a.name), r++;
        else {
          var s = this.getSourceDimension(e);
          s && (i = s.name);
        }
        t.push(i);
      }
      return t;
    }, n.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = true, this._fullDimCount++, this._updateDimOmitted(true);
    }, n;
  }();
  function TH(n) {
    return n instanceof CH;
  }
  function IH(n) {
    for (var t = It(), e = 0; e < (n || []).length; e++) {
      var r = n[e], i = Ft(r) ? r.name : r;
      i != null && t.get(i) == null && t.set(i, e);
    }
    return t;
  }
  function AH(n) {
    var t = qot(n);
    return t.dimNameMap || (t.dimNameMap = IH(n.dimensionsDefine));
  }
  function kH(n) {
    return n > 30;
  }
  var fp = Ft, hl = ht, Kot = typeof Int32Array > "u" ? Array : Int32Array, Zot = "e\0\0", O$ = -1, Jot = [
    "hasItemOption",
    "_nameList",
    "_idList",
    "_invertedIndicesMap",
    "_dimSummary",
    "userOutput",
    "_rawData",
    "_dimValueGetter",
    "_nameDimIdx",
    "_idDimIdx",
    "_nameRepeatCount"
  ], Qot = [
    "_approximateExtent"
  ], F$, Xy, dp, pp, WS, gp, US, fi = function() {
    function n(t, e) {
      this.type = "list", this._dimOmitted = false, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = false, this.TRANSFERABLE_METHODS = [
        "cloneShallow",
        "downSample",
        "minmaxDownSample",
        "lttbDownSample",
        "map"
      ], this.CHANGABLE_METHODS = [
        "filterSelf",
        "selectRange"
      ], this.DOWNSAMPLE_METHODS = [
        "downSample",
        "minmaxDownSample",
        "lttbDownSample"
      ];
      var r, i = false;
      TH(t) ? (r = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (i = true, r = t), r = r || [
        "x",
        "y"
      ];
      for (var a = {}, s = [], o = {}, l = false, u = {}, c = 0; c < r.length; c++) {
        var h = r[c], f = wt(h) ? new gx({
          name: h
        }) : h instanceof gx ? h : new gx(h), d = f.name;
        f.type = f.type || "float", f.coordDim || (f.coordDim = d, f.coordDimIndex = 0);
        var p = f.otherDims = f.otherDims || {};
        s.push(d), a[d] = f, u[d] != null && (l = true), f.createInvertedIndices && (o[d] = []), p.itemName === 0 && (this._nameDimIdx = c), p.itemId === 0 && (this._idDimIdx = c), i && (f.storeDimIndex = c);
      }
      if (this.dimensions = s, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = e, this._invertedIndicesMap = o, this._dimOmitted) {
        var g = this._dimIdxToName = It();
        P(s, function(v) {
          g.set(a[v].storeDimIndex, v);
        });
      }
    }
    return n.prototype.getDimension = function(t) {
      var e = this._recognizeDimIndex(t);
      if (e == null) return t;
      if (e = t, !this._dimOmitted) return this.dimensions[e];
      var r = this._dimIdxToName.get(e);
      if (r != null) return r;
      var i = this._schema.getSourceDimension(e);
      if (i) return i.name;
    }, n.prototype.getDimensionIndex = function(t) {
      var e = this._recognizeDimIndex(t);
      if (e != null) return e;
      if (t == null) return -1;
      var r = this._getDimInfo(t);
      return r ? r.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, n.prototype._recognizeDimIndex = function(t) {
      if (_e(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0)) return +t;
    }, n.prototype._getStoreDimIndex = function(t) {
      var e = this.getDimensionIndex(t);
      return e;
    }, n.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, n.prototype._initGetDimensionInfo = function(t) {
      var e = this._dimInfos;
      this._getDimInfo = t ? function(r) {
        return e.hasOwnProperty(r) ? e[r] : void 0;
      } : function(r) {
        return e[r];
      };
    }, n.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, n.prototype.mapDimension = function(t, e) {
      var r = this._dimSummary;
      if (e == null) return r.encodeFirstDimNotExtra[t];
      var i = r.encode[t];
      return i ? i[e] : null;
    }, n.prototype.mapDimensionsAll = function(t) {
      var e = this._dimSummary, r = e.encode[t];
      return (r || []).slice();
    }, n.prototype.getStore = function() {
      return this._store;
    }, n.prototype.initData = function(t, e, r) {
      var i = this, a;
      if (t instanceof aA && (a = t), !a) {
        var s = this.dimensions, o = pD(t) || Kr(t) ? new A5(t, s.length) : t;
        a = new aA();
        var l = hl(s, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        a.initData(o, l, r);
      }
      this._store = a, this._nameList = (e || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = Xot(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, n.prototype.appendData = function(t) {
      var e = this._store.appendData(t);
      this._doInit(e[0], e[1]);
    }, n.prototype.appendValues = function(t, e) {
      var r = this._store.appendValues(t, e && e.length), i = r.start, a = r.end, s = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), e) for (var o = i; o < a; o++) {
        var l = o - i;
        this._nameList[o] = e[l], s && US(this, o);
      }
    }, n.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, e = this.dimensions, r = 0; r < e.length; r++) {
        var i = this._dimInfos[e[r]];
        i.ordinalMeta && t.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, n.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== Ol && !t.fillStorage;
    }, n.prototype._doInit = function(t, e) {
      if (!(t >= e)) {
        var r = this._store, i = r.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, s = this._idList, o = i.getSource().sourceFormat, l = o === Ea;
        if (l && !i.pure) for (var u = [], c = t; c < e; c++) {
          var h = i.getItem(c, u);
          if (!this.hasItemOption && Pnt(h) && (this.hasItemOption = true), h) {
            var f = h.name;
            a[c] == null && f != null && (a[c] = Un(f, null));
            var d = h.id;
            s[c] == null && d != null && (s[c] = Un(d, null));
          }
        }
        if (this._shouldMakeIdFromName()) for (var c = t; c < e; c++) US(this, c);
        F$(this);
      }
    }, n.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, n.prototype.setApproximateExtent = function(t, e) {
      e = this.getDimension(e), this._approximateExtent[e] = t.slice();
    }, n.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, n.prototype.setCalculationInfo = function(t, e) {
      fp(t) ? rt(this._calculationInfo, t) : this._calculationInfo[t] = e;
    }, n.prototype.getName = function(t) {
      var e = this.getRawIndex(t), r = this._nameList[e];
      return r == null && this._nameDimIdx != null && (r = dp(this, this._nameDimIdx, e)), r == null && (r = ""), r;
    }, n.prototype._getCategory = function(t, e) {
      var r = this._store.get(t, e), i = this._store.getOrdinalMeta(t);
      return i ? i.categories[r] : r;
    }, n.prototype.getId = function(t) {
      return Xy(this, this.getRawIndex(t));
    }, n.prototype.count = function() {
      return this._store.count();
    }, n.prototype.get = function(t, e) {
      var r = this._store, i = this._dimInfos[t];
      if (i) return r.get(i.storeDimIndex, e);
    }, n.prototype.getByRawIndex = function(t, e) {
      var r = this._store, i = this._dimInfos[t];
      if (i) return r.getByRawIndex(i.storeDimIndex, e);
    }, n.prototype.getIndices = function() {
      return this._store.getIndices();
    }, n.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, n.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, n.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, n.prototype.getValues = function(t, e) {
      var r = this, i = this._store;
      return ct(t) ? i.getValues(hl(t, function(a) {
        return r._getStoreDimIndex(a);
      }), e) : i.getValues(t);
    }, n.prototype.hasValue = function(t) {
      for (var e = this._dimSummary.dataDimIndicesOnCoord, r = 0, i = e.length; r < i; r++) if (isNaN(this._store.get(e[r], t))) return false;
      return true;
    }, n.prototype.indexOfName = function(t) {
      for (var e = 0, r = this._store.count(); e < r; e++) if (this.getName(e) === t) return e;
      return -1;
    }, n.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, n.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, n.prototype.rawIndexOf = function(t, e) {
      var r = t && this._invertedIndicesMap[t], i = r && r[e];
      return i == null || isNaN(i) ? O$ : i;
    }, n.prototype.indicesOfNearest = function(t, e, r) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(t), e, r);
    }, n.prototype.each = function(t, e, r) {
      Nt(t) && (r = e, e = t, t = []);
      var i = r || this, a = hl(pp(t), this._getStoreDimIndex, this);
      this._store.each(a, i ? St(e, i) : e);
    }, n.prototype.filterSelf = function(t, e, r) {
      Nt(t) && (r = e, e = t, t = []);
      var i = r || this, a = hl(pp(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, i ? St(e, i) : e), this;
    }, n.prototype.selectRange = function(t) {
      var e = this, r = {}, i = ge(t);
      return P(i, function(a) {
        var s = e._getStoreDimIndex(a);
        r[s] = t[a];
      }), this._store = this._store.selectRange(r), this;
    }, n.prototype.mapArray = function(t, e, r) {
      Nt(t) && (r = e, e = t, t = []), r = r || this;
      var i = [];
      return this.each(t, function() {
        i.push(e && e.apply(this, arguments));
      }, r), i;
    }, n.prototype.map = function(t, e, r, i) {
      var a = r || i || this, s = hl(pp(t), this._getStoreDimIndex, this), o = gp(this);
      return o._store = this._store.map(s, a ? St(e, a) : e), o;
    }, n.prototype.modify = function(t, e, r, i) {
      var a = r || i || this, s = hl(pp(t), this._getStoreDimIndex, this);
      this._store.modify(s, a ? St(e, a) : e);
    }, n.prototype.downSample = function(t, e, r, i) {
      var a = gp(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(t), e, r, i), a;
    }, n.prototype.minmaxDownSample = function(t, e) {
      var r = gp(this);
      return r._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), e), r;
    }, n.prototype.lttbDownSample = function(t, e) {
      var r = gp(this);
      return r._store = this._store.lttbDownSample(this._getStoreDimIndex(t), e), r;
    }, n.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, n.prototype.getItemModel = function(t) {
      var e = this.hostModel, r = this.getRawDataItem(t);
      return new $e(r, e, e && e.ecModel);
    }, n.prototype.diff = function(t) {
      var e = this;
      return new Wo(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(r) {
        return Xy(t, r);
      }, function(r) {
        return Xy(e, r);
      });
    }, n.prototype.getVisual = function(t) {
      var e = this._visual;
      return e && e[t];
    }, n.prototype.setVisual = function(t, e) {
      this._visual = this._visual || {}, fp(t) ? rt(this._visual, t) : this._visual[t] = e;
    }, n.prototype.getItemVisual = function(t, e) {
      var r = this._itemVisuals[t], i = r && r[e];
      return i ?? this.getVisual(e);
    }, n.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, n.prototype.ensureUniqueItemVisual = function(t, e) {
      var r = this._itemVisuals, i = r[t];
      i || (i = r[t] = {});
      var a = i[e];
      return a == null && (a = this.getVisual(e), ct(a) ? a = a.slice() : fp(a) && (a = rt({}, a)), i[e] = a), a;
    }, n.prototype.setItemVisual = function(t, e, r) {
      var i = this._itemVisuals[t] || {};
      this._itemVisuals[t] = i, fp(e) ? rt(i, e) : i[e] = r;
    }, n.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, n.prototype.setLayout = function(t, e) {
      fp(t) ? rt(this._layout, t) : this._layout[t] = e;
    }, n.prototype.getLayout = function(t) {
      return this._layout[t];
    }, n.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, n.prototype.setItemLayout = function(t, e, r) {
      this._itemLayouts[t] = r ? rt(this._itemLayouts[t] || {}, e) : e;
    }, n.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, n.prototype.setItemGraphicEl = function(t, e) {
      var r = this.hostModel && this.hostModel.seriesIndex;
      XI(r, this.dataType, t, e), this._graphicEls[t] = e;
    }, n.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, n.prototype.eachItemGraphicEl = function(t, e) {
      P(this._graphicEls, function(r, i) {
        r && t && t.call(e, r, i);
      });
    }, n.prototype.cloneShallow = function(t) {
      return t || (t = new n(this._schema ? this._schema : hl(this.dimensions, this._getDimInfo, this), this.hostModel)), WS(t, this), t._store = this._store, t;
    }, n.prototype.wrapMethod = function(t, e) {
      var r = this[t];
      Nt(r) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var i = r.apply(this, arguments);
        return e.apply(this, [
          i
        ].concat(Lk(arguments)));
      });
    }, n.internalField = function() {
      F$ = function(t) {
        var e = t._invertedIndicesMap;
        P(e, function(r, i) {
          var a = t._dimInfos[i], s = a.ordinalMeta, o = t._store;
          if (s) {
            r = e[i] = new Kot(s.categories.length);
            for (var l = 0; l < r.length; l++) r[l] = O$;
            for (var l = 0; l < o.count(); l++) r[o.get(a.storeDimIndex, l)] = l;
          }
        });
      }, dp = function(t, e, r) {
        return Un(t._getCategory(e, r), null);
      }, Xy = function(t, e) {
        var r = t._idList[e];
        return r == null && t._idDimIdx != null && (r = dp(t, t._idDimIdx, e)), r == null && (r = Zot + e), r;
      }, pp = function(t) {
        return ct(t) || (t = t != null ? [
          t
        ] : []), t;
      }, gp = function(t) {
        var e = new n(t._schema ? t._schema : hl(t.dimensions, t._getDimInfo, t), t.hostModel);
        return WS(e, t), e;
      }, WS = function(t, e) {
        P(Jot.concat(e.__wrappedMethods || []), function(r) {
          e.hasOwnProperty(r) && (t[r] = e[r]);
        }), t.__wrappedMethods = e.__wrappedMethods, P(Qot, function(r) {
          t[r] = Bt(e[r]);
        }), t._calculationInfo = rt({}, e._calculationInfo);
      }, US = function(t, e) {
        var r = t._nameList, i = t._idList, a = t._nameDimIdx, s = t._idDimIdx, o = r[e], l = i[e];
        if (o == null && a != null && (r[e] = o = dp(t, a, e)), l == null && s != null && (i[e] = l = dp(t, s, e)), l == null && o != null) {
          var u = t._nameRepeatCount, c = u[o] = (u[o] || 0) + 1;
          l = o, c > 1 && (l += "__ec__" + c), i[e] = l;
        }
      };
    }(), n;
  }();
  function Vv(n, t) {
    pD(n) || (n = gD(n)), t = t || {};
    var e = t.coordDimensions || [], r = t.dimensionsDefine || n.dimensionsDefine || [], i = It(), a = [], s = elt(n, e, r, t.dimensionsCount), o = t.canOmitUnusedDimensions && kH(s), l = r === n.dimensionsDefine, u = l ? AH(n) : IH(r), c = t.encodeDefine;
    !c && t.encodeDefaulter && (c = t.encodeDefaulter(n, s));
    for (var h = It(c), f = new P5(s), d = 0; d < f.length; d++) f[d] = -1;
    function p(T) {
      var A = f[T];
      if (A < 0) {
        var C = r[T], D = Ft(C) ? C : {
          name: C
        }, E = new gx(), M = D.name;
        M != null && u.get(M) != null && (E.name = E.displayName = M), D.type != null && (E.type = D.type), D.displayName != null && (E.displayName = D.displayName);
        var L = a.length;
        return f[T] = L, E.storeDimIndex = T, a.push(E), E;
      }
      return a[A];
    }
    if (!o) for (var d = 0; d < s; d++) p(d);
    h.each(function(T, A) {
      var C = He(T).slice();
      if (C.length === 1 && !wt(C[0]) && C[0] < 0) {
        h.set(A, false);
        return;
      }
      var D = h.set(A, []);
      P(C, function(E, M) {
        var L = wt(E) ? u.get(E) : E;
        L != null && L < s && (D[M] = L, v(p(L), A, M));
      });
    });
    var g = 0;
    P(e, function(T) {
      var A, C, D, E;
      if (wt(T)) A = T, E = {};
      else {
        E = T, A = E.name;
        var M = E.ordinalMeta;
        E.ordinalMeta = null, E = rt({}, E), E.ordinalMeta = M, C = E.dimsDef, D = E.otherDims, E.name = E.coordDim = E.coordDimIndex = E.dimsDef = E.otherDims = null;
      }
      var L = h.get(A);
      if (L !== false) {
        if (L = He(L), !L.length) for (var k = 0; k < (C && C.length || 1); k++) {
          for (; g < s && p(g).coordDim != null; ) g++;
          g < s && L.push(g++);
        }
        P(L, function(N, R) {
          var $ = p(N);
          if (l && E.type != null && ($.type = E.type), v($t($, E), A, R), $.name == null && C) {
            var O = C[R];
            !Ft(O) && (O = {
              name: O
            }), $.name = $.displayName = O.name, $.defaultTooltip = O.defaultTooltip;
          }
          D && $t($.otherDims, D);
        });
      }
    });
    function v(T, A, C) {
      g5.get(A) != null ? T.otherDims[A] = C : (T.coordDim = A, T.coordDimIndex = C, i.set(A, true));
    }
    var m = t.generateCoord, y = t.generateCoordCount, x = y != null;
    y = m ? y || 1 : 0;
    var b = m || "value";
    function _(T) {
      T.name == null && (T.name = T.coordDim);
    }
    if (o) P(a, function(T) {
      _(T);
    }), a.sort(function(T, A) {
      return T.storeDimIndex - A.storeDimIndex;
    });
    else for (var w = 0; w < s; w++) {
      var S = p(w), I = S.coordDim;
      I == null && (S.coordDim = nlt(b, i, x), S.coordDimIndex = 0, (!m || y <= 0) && (S.isExtraCoord = true), y--), _(S), S.type == null && (x5(n, w) === Cr.Must || S.isExtraCoord && (S.otherDims.itemName != null || S.otherDims.seriesName != null)) && (S.type = "ordinal");
    }
    return tlt(a), new CH({
      source: n,
      dimensions: a,
      fullDimensionCount: s,
      dimensionOmitted: o
    });
  }
  function tlt(n) {
    for (var t = It(), e = 0; e < n.length; e++) {
      var r = n[e], i = r.name, a = t.get(i) || 0;
      a > 0 && (r.name = i + (a - 1)), a++, t.set(i, a);
    }
  }
  function elt(n, t, e, r) {
    var i = Math.max(n.dimensionsDetectedCount || 1, t.length, e.length, r || 0);
    return P(t, function(a) {
      var s;
      Ft(a) && (s = a.dimsDef) && (i = Math.max(i, s.length));
    }), i;
  }
  function nlt(n, t, e) {
    if (e || t.hasKey(n)) {
      for (var r = 0; t.hasKey(n + r); ) r++;
      n += r;
    }
    return t.set(n, true), n;
  }
  var rlt = /* @__PURE__ */ function() {
    function n(t) {
      this.coordSysDims = [], this.axisMap = It(), this.categoryAxisMap = It(), this.coordSysName = t;
    }
    return n;
  }();
  function ilt(n) {
    var t = n.get("coordinateSystem"), e = new rlt(t), r = alt[t];
    if (r) return r(n, e, e.axisMap, e.categoryAxisMap), e;
  }
  var alt = {
    cartesian2d: function(n, t, e, r) {
      var i = n.getReferringComponents("xAxis", On).models[0], a = n.getReferringComponents("yAxis", On).models[0];
      t.coordSysDims = [
        "x",
        "y"
      ], e.set("x", i), e.set("y", a), Uh(i) && (r.set("x", i), t.firstCategoryDimIndex = 0), Uh(a) && (r.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
    },
    singleAxis: function(n, t, e, r) {
      var i = n.getReferringComponents("singleAxis", On).models[0];
      t.coordSysDims = [
        "single"
      ], e.set("single", i), Uh(i) && (r.set("single", i), t.firstCategoryDimIndex = 0);
    },
    polar: function(n, t, e, r) {
      var i = n.getReferringComponents("polar", On).models[0], a = i.findAxisModel("radiusAxis"), s = i.findAxisModel("angleAxis");
      t.coordSysDims = [
        "radius",
        "angle"
      ], e.set("radius", a), e.set("angle", s), Uh(a) && (r.set("radius", a), t.firstCategoryDimIndex = 0), Uh(s) && (r.set("angle", s), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
    },
    geo: function(n, t, e, r) {
      t.coordSysDims = [
        "lng",
        "lat"
      ];
    },
    parallel: function(n, t, e, r) {
      var i = n.ecModel, a = i.getComponent("parallel", n.get("parallelIndex")), s = t.coordSysDims = a.dimensions.slice();
      P(a.parallelAxisIndex, function(o, l) {
        var u = i.getComponent("parallelAxis", o), c = s[l];
        e.set(c, u), Uh(u) && (r.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
      });
    }
  };
  function Uh(n) {
    return n.get("type") === "category";
  }
  function slt(n, t, e) {
    e = e || {};
    var r = e.byIndex, i = e.stackedCoordDimension, a, s, o;
    olt(t) ? a = t : (s = t.schema, a = s.dimensions, o = t.store);
    var l = !!(n && n.get("stack")), u, c, h, f;
    if (P(a, function(y, x) {
      wt(y) && (a[x] = y = {
        name: y
      }), l && !y.isExtraCoord && (!r && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
    }), c && !r && !u && (r = true), c) {
      h = "__\0ecstackresult_" + n.id, f = "__\0ecstackedover_" + n.id, u && (u.createInvertedIndices = true);
      var d = c.coordDim, p = c.type, g = 0;
      P(a, function(y) {
        y.coordDim === d && g++;
      });
      var v = {
        name: h,
        coordDim: d,
        coordDimIndex: g,
        type: p,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: a.length
      }, m = {
        name: f,
        coordDim: f,
        coordDimIndex: g + 1,
        type: p,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: a.length + 1
      };
      s ? (o && (v.storeDimIndex = o.ensureCalculationDimension(f, p), m.storeDimIndex = o.ensureCalculationDimension(h, p)), s.appendCalculationDimension(v), s.appendCalculationDimension(m)) : (a.push(v), a.push(m));
    }
    return {
      stackedDimension: c && c.name,
      stackedByDimension: u && u.name,
      isStackedByIndex: r,
      stackedOverDimension: f,
      stackResultDimension: h
    };
  }
  function olt(n) {
    return !TH(n.schema);
  }
  function Kl(n, t) {
    return !!t && t === n.getCalculationInfo("stackedDimension");
  }
  function DH(n, t) {
    return Kl(n, t) ? n.getCalculationInfo("stackResultDimension") : t;
  }
  function llt(n, t) {
    var e = n.get("coordinateSystem"), r = Bv.get(e), i;
    return t && t.coordSysDims && (i = ht(t.coordSysDims, function(a) {
      var s = {
        name: a
      }, o = t.axisMap.get(a);
      if (o) {
        var l = o.get("type");
        s.type = ab(l);
      }
      return s;
    })), i || (i = r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || [
      "x",
      "y"
    ]), i;
  }
  function ult(n, t, e) {
    var r, i;
    return e && P(n, function(a, s) {
      var o = a.coordDim, l = e.categoryAxisMap.get(o);
      l && (r == null && (r = s), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = true)), a.otherDims.itemName != null && (i = true);
    }), !i && r != null && (n[r].otherDims.itemName = 0), r;
  }
  function el(n, t, e) {
    e = e || {};
    var r = t.getSourceManager(), i, a = false;
    n ? (a = true, i = gD(n)) : (i = r.getSource(), a = i.sourceFormat === Ea);
    var s = ilt(t), o = llt(t, s), l = e.useEncodeDefaulter, u = Nt(l) ? l : l ? qt(y5, o, t) : null, c = {
      coordDimensions: o,
      generateCoord: e.generateCoord,
      encodeDefine: t.getEncode(),
      encodeDefaulter: u,
      canOmitUnusedDimensions: !a
    }, h = Vv(i, c), f = ult(h.dimensions, e.createInvertedIndices, s), d = a ? null : r.getSharedDataStore(h), p = slt(t, {
      schema: h,
      store: d
    }), g = new fi(h, t);
    g.setCalculationInfo(p);
    var v = f != null && clt(i) ? function(m, y, x, b) {
      return b === f ? x : this.defaultDimValueGetter(m, y, x, b);
    } : null;
    return g.hasItemOption = false, g.initData(a ? i : d, null, v), g;
  }
  function clt(n) {
    if (n.sourceFormat === Ea) {
      var t = hlt(n.data || []);
      return !ct(xd(t));
    }
  }
  function hlt(n) {
    for (var t = 0; t < n.length && n[t] == null; ) t++;
    return n[t];
  }
  var ho = function() {
    function n(t) {
      this._setting = t || {}, this._extent = [
        1 / 0,
        -1 / 0
      ];
    }
    return n.prototype.getSetting = function(t) {
      return this._setting[t];
    }, n.prototype.unionExtent = function(t) {
      var e = this._extent;
      t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]);
    }, n.prototype.unionExtentFromData = function(t, e) {
      this.unionExtent(t.getApproximateExtent(e));
    }, n.prototype.getExtent = function() {
      return this._extent.slice();
    }, n.prototype.setExtent = function(t, e) {
      var r = this._extent;
      isNaN(t) || (r[0] = t), isNaN(e) || (r[1] = e);
    }, n.prototype.isInExtentRange = function(t) {
      return this._extent[0] <= t && this._extent[1] >= t;
    }, n.prototype.isBlank = function() {
      return this._isBlank;
    }, n.prototype.setBlank = function(t) {
      this._isBlank = t;
    }, n;
  }();
  _1(ho);
  var flt = 0, gA = function() {
    function n(t) {
      this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++flt;
    }
    return n.createByAxisModel = function(t) {
      var e = t.option, r = e.data, i = r && ht(r, dlt);
      return new n({
        categories: i,
        needCollect: !i,
        deduplication: e.dedplication !== false
      });
    }, n.prototype.getOrdinal = function(t) {
      return this._getOrCreateMap().get(t);
    }, n.prototype.parseAndCollect = function(t) {
      var e, r = this._needCollect;
      if (!wt(t) && !r) return t;
      if (r && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e;
      var i = this._getOrCreateMap();
      return e = i.get(t), e == null && (r ? (e = this.categories.length, this.categories[e] = t, i.set(t, e)) : e = NaN), e;
    }, n.prototype._getOrCreateMap = function() {
      return this._map || (this._map = It(this.categories));
    }, n;
  }();
  function dlt(n) {
    return Ft(n) && n.value != null ? n.value : n + "";
  }
  function vA(n) {
    return n.type === "interval" || n.type === "log";
  }
  function plt(n, t, e, r) {
    var i = {}, a = n[1] - n[0], s = i.interval = rU(a / t);
    e != null && s < e && (s = i.interval = e), r != null && s > r && (s = i.interval = r);
    var o = i.intervalPrecision = EH(s), l = i.niceTickExtent = [
      Cn(Math.ceil(n[0] / s) * s, o),
      Cn(Math.floor(n[1] / s) * s, o)
    ];
    return glt(l, n), i;
  }
  function HS(n) {
    var t = Math.pow(10, Gk(n)), e = n / t;
    return e ? e === 2 ? e = 3 : e === 3 ? e = 5 : e *= 2 : e = 1, Cn(e * t);
  }
  function EH(n) {
    return Fs(n) + 2;
  }
  function B$(n, t, e) {
    n[t] = Math.max(Math.min(n[t], e[1]), e[0]);
  }
  function glt(n, t) {
    !isFinite(n[0]) && (n[0] = t[0]), !isFinite(n[1]) && (n[1] = t[1]), B$(n, 0, t), B$(n, 1, t), n[0] > n[1] && (n[0] = n[1]);
  }
  function G1(n, t) {
    return n >= t[0] && n <= t[1];
  }
  function W1(n, t) {
    return t[1] === t[0] ? 0.5 : (n - t[0]) / (t[1] - t[0]);
  }
  function U1(n, t) {
    return n * (t[1] - t[0]) + t[0];
  }
  var H1 = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      r.type = "ordinal";
      var i = r.getSetting("ordinalMeta");
      return i || (i = new gA({})), ct(i) && (i = new gA({
        categories: ht(i, function(a) {
          return Ft(a) ? a.value : a;
        })
      })), r._ordinalMeta = i, r._extent = r.getSetting("extent") || [
        0,
        i.categories.length - 1
      ], r;
    }
    return t.prototype.parse = function(e) {
      return e == null ? NaN : wt(e) ? this._ordinalMeta.getOrdinal(e) : Math.round(e);
    }, t.prototype.contain = function(e) {
      return e = this.parse(e), G1(e, this._extent) && this._ordinalMeta.categories[e] != null;
    }, t.prototype.normalize = function(e) {
      return e = this._getTickNumber(this.parse(e)), W1(e, this._extent);
    }, t.prototype.scale = function(e) {
      return e = Math.round(U1(e, this._extent)), this.getRawOrdinalNumber(e);
    }, t.prototype.getTicks = function() {
      for (var e = [], r = this._extent, i = r[0]; i <= r[1]; ) e.push({
        value: i
      }), i++;
      return e;
    }, t.prototype.getMinorTicks = function(e) {
    }, t.prototype.setSortInfo = function(e) {
      if (e == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var r = e.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], s = 0, o = this._ordinalMeta.categories.length, l = Math.min(o, r.length); s < l; ++s) {
        var u = r[s];
        i[s] = u, a[u] = s;
      }
      for (var c = 0; s < o; ++s) {
        for (; a[c] != null; ) c++;
        i.push(c), a[c] = s;
      }
    }, t.prototype._getTickNumber = function(e) {
      var r = this._ticksByOrdinalNumber;
      return r && e >= 0 && e < r.length ? r[e] : e;
    }, t.prototype.getRawOrdinalNumber = function(e) {
      var r = this._ordinalNumbersByTick;
      return r && e >= 0 && e < r.length ? r[e] : e;
    }, t.prototype.getLabel = function(e) {
      if (!this.isBlank()) {
        var r = this.getRawOrdinalNumber(e.value), i = this._ordinalMeta.categories[r];
        return i == null ? "" : i + "";
      }
    }, t.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, t.prototype.unionExtentFromData = function(e, r) {
      this.unionExtent(e.getApproximateExtent(r));
    }, t.prototype.isInExtentRange = function(e) {
      return e = this._getTickNumber(e), this._extent[0] <= e && this._extent[1] >= e;
    }, t.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, t.prototype.calcNiceTicks = function() {
    }, t.prototype.calcNiceExtent = function() {
    }, t.type = "ordinal", t;
  }(ho);
  ho.registerClass(H1);
  var Vu = Cn, Uo = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = "interval", e._interval = 0, e._intervalPrecision = 2, e;
    }
    return t.prototype.parse = function(e) {
      return e;
    }, t.prototype.contain = function(e) {
      return G1(e, this._extent);
    }, t.prototype.normalize = function(e) {
      return W1(e, this._extent);
    }, t.prototype.scale = function(e) {
      return U1(e, this._extent);
    }, t.prototype.setExtent = function(e, r) {
      var i = this._extent;
      isNaN(e) || (i[0] = parseFloat(e)), isNaN(r) || (i[1] = parseFloat(r));
    }, t.prototype.unionExtent = function(e) {
      var r = this._extent;
      e[0] < r[0] && (r[0] = e[0]), e[1] > r[1] && (r[1] = e[1]), this.setExtent(r[0], r[1]);
    }, t.prototype.getInterval = function() {
      return this._interval;
    }, t.prototype.setInterval = function(e) {
      this._interval = e, this._niceExtent = this._extent.slice(), this._intervalPrecision = EH(e);
    }, t.prototype.getTicks = function(e) {
      var r = this._interval, i = this._extent, a = this._niceExtent, s = this._intervalPrecision, o = [];
      if (!r) return o;
      var l = 1e4;
      i[0] < a[0] && (e ? o.push({
        value: Vu(a[0] - r, s)
      }) : o.push({
        value: i[0]
      }));
      for (var u = a[0]; u <= a[1] && (o.push({
        value: u
      }), u = Vu(u + r, s), u !== o[o.length - 1].value); ) if (o.length > l) return [];
      var c = o.length ? o[o.length - 1].value : a[1];
      return i[1] > c && (e ? o.push({
        value: Vu(c + r, s)
      }) : o.push({
        value: i[1]
      })), o;
    }, t.prototype.getMinorTicks = function(e) {
      for (var r = this.getTicks(true), i = [], a = this.getExtent(), s = 1; s < r.length; s++) {
        for (var o = r[s], l = r[s - 1], u = 0, c = [], h = o.value - l.value, f = h / e; u < e - 1; ) {
          var d = Vu(l.value + (u + 1) * f);
          d > a[0] && d < a[1] && c.push(d), u++;
        }
        i.push(c);
      }
      return i;
    }, t.prototype.getLabel = function(e, r) {
      if (e == null) return "";
      var i = r && r.precision;
      i == null ? i = Fs(e.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var a = Vu(e.value, i, true);
      return u5(a);
    }, t.prototype.calcNiceTicks = function(e, r, i) {
      e = e || 5;
      var a = this._extent, s = a[1] - a[0];
      if (isFinite(s)) {
        s < 0 && (s = -s, a.reverse());
        var o = plt(a, e, r, i);
        this._intervalPrecision = o.intervalPrecision, this._interval = o.interval, this._niceExtent = o.niceTickExtent;
      }
    }, t.prototype.calcNiceExtent = function(e) {
      var r = this._extent;
      if (r[0] === r[1]) if (r[0] !== 0) {
        var i = Math.abs(r[0]);
        e.fixMax || (r[1] += i / 2), r[0] -= i / 2;
      } else r[1] = 1;
      var a = r[1] - r[0];
      isFinite(a) || (r[0] = 0, r[1] = 1), this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
      var s = this._interval;
      e.fixMin || (r[0] = Vu(Math.floor(r[0] / s) * s)), e.fixMax || (r[1] = Vu(Math.ceil(r[1] / s) * s));
    }, t.prototype.setNiceExtent = function(e, r) {
      this._niceExtent = [
        e,
        r
      ];
    }, t.type = "interval", t;
  }(ho);
  ho.registerClass(Uo);
  var MH = typeof Float32Array < "u", vlt = MH ? Float32Array : Array;
  function zs(n) {
    return ct(n) ? MH ? new Float32Array(n) : n : new vlt(n);
  }
  var mA = "__ec_stack_";
  function RH(n) {
    return n.get("stack") || mA + n.seriesIndex;
  }
  function ID(n) {
    return n.dim + n.index;
  }
  function mlt(n) {
    var t = [], e = n.axis, r = "axis0";
    if (e.type === "category") {
      for (var i = e.getBandWidth(), a = 0; a < n.count; a++) t.push($t({
        bandWidth: i,
        axisKey: r,
        stackId: mA + a
      }, n));
      for (var s = PH(t), o = [], a = 0; a < n.count; a++) {
        var l = s[r][mA + a];
        l.offsetCenter = l.offset + l.width / 2, o.push(l);
      }
      return o;
    }
  }
  function NH(n, t) {
    var e = [];
    return t.eachSeriesByType(n, function(r) {
      FH(r) && e.push(r);
    }), e;
  }
  function ylt(n) {
    var t = {};
    P(n, function(l) {
      var u = l.coordinateSystem, c = u.getBaseAxis();
      if (!(c.type !== "time" && c.type !== "value")) for (var h = l.getData(), f = c.dim + "_" + c.index, d = h.getDimensionIndex(h.mapDimension(c.dim)), p = h.getStore(), g = 0, v = p.count(); g < v; ++g) {
        var m = p.get(d, g);
        t[f] ? t[f].push(m) : t[f] = [
          m
        ];
      }
    });
    var e = {};
    for (var r in t) if (t.hasOwnProperty(r)) {
      var i = t[r];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, s = 1; s < i.length; ++s) {
          var o = i[s] - i[s - 1];
          o > 0 && (a = a === null ? o : Math.min(a, o));
        }
        e[r] = a;
      }
    }
    return e;
  }
  function LH(n) {
    var t = ylt(n), e = [];
    return P(n, function(r) {
      var i = r.coordinateSystem, a = i.getBaseAxis(), s = a.getExtent(), o;
      if (a.type === "category") o = a.getBandWidth();
      else if (a.type === "value" || a.type === "time") {
        var l = a.dim + "_" + a.index, u = t[l], c = Math.abs(s[1] - s[0]), h = a.scale.getExtent(), f = Math.abs(h[1] - h[0]);
        o = u ? c / f * u : c;
      } else {
        var d = r.getData();
        o = Math.abs(s[1] - s[0]) / d.count();
      }
      var p = yt(r.get("barWidth"), o), g = yt(r.get("barMaxWidth"), o), v = yt(r.get("barMinWidth") || (BH(r) ? 0.5 : 1), o), m = r.get("barGap"), y = r.get("barCategoryGap");
      e.push({
        bandWidth: o,
        barWidth: p,
        barMaxWidth: g,
        barMinWidth: v,
        barGap: m,
        barCategoryGap: y,
        axisKey: ID(a),
        stackId: RH(r)
      });
    }), PH(e);
  }
  function PH(n) {
    var t = {};
    P(n, function(r, i) {
      var a = r.axisKey, s = r.bandWidth, o = t[a] || {
        bandWidth: s,
        remainedWidth: s,
        autoWidthCount: 0,
        categoryGap: null,
        gap: "20%",
        stacks: {}
      }, l = o.stacks;
      t[a] = o;
      var u = r.stackId;
      l[u] || o.autoWidthCount++, l[u] = l[u] || {
        width: 0,
        maxWidth: 0
      };
      var c = r.barWidth;
      c && !l[u].width && (l[u].width = c, c = Math.min(o.remainedWidth, c), o.remainedWidth -= c);
      var h = r.barMaxWidth;
      h && (l[u].maxWidth = h);
      var f = r.barMinWidth;
      f && (l[u].minWidth = f);
      var d = r.barGap;
      d != null && (o.gap = d);
      var p = r.barCategoryGap;
      p != null && (o.categoryGap = p);
    });
    var e = {};
    return P(t, function(r, i) {
      e[i] = {};
      var a = r.stacks, s = r.bandWidth, o = r.categoryGap;
      if (o == null) {
        var l = ge(a).length;
        o = Math.max(35 - l * 4, 15) + "%";
      }
      var u = yt(o, s), c = yt(r.gap, 1), h = r.remainedWidth, f = r.autoWidthCount, d = (h - u) / (f + (f - 1) * c);
      d = Math.max(d, 0), P(a, function(m) {
        var y = m.maxWidth, x = m.minWidth;
        if (m.width) {
          var b = m.width;
          y && (b = Math.min(b, y)), x && (b = Math.max(b, x)), m.width = b, h -= b + c * b, f--;
        } else {
          var b = d;
          y && y < b && (b = Math.min(y, h)), x && x > b && (b = x), b !== d && (m.width = b, h -= b + c * b, f--);
        }
      }), d = (h - u) / (f + (f - 1) * c), d = Math.max(d, 0);
      var p = 0, g;
      P(a, function(m, y) {
        m.width || (m.width = d), g = m, p += m.width * (1 + c);
      }), g && (p -= g.width * c);
      var v = -p / 2;
      P(a, function(m, y) {
        e[i][y] = e[i][y] || {
          bandWidth: s,
          offset: v,
          width: m.width
        }, v += m.width * (1 + c);
      });
    }), e;
  }
  function xlt(n, t, e) {
    if (n && t) {
      var r = n[ID(t)];
      return r;
    }
  }
  function $H(n, t) {
    var e = NH(n, t), r = LH(e);
    P(e, function(i) {
      var a = i.getData(), s = i.coordinateSystem, o = s.getBaseAxis(), l = RH(i), u = r[ID(o)][l], c = u.offset, h = u.width;
      a.setLayout({
        bandWidth: u.bandWidth,
        offset: c,
        size: h
      });
    });
  }
  function OH(n) {
    return {
      seriesType: n,
      plan: Ad(),
      reset: function(t) {
        if (FH(t)) {
          var e = t.getData(), r = t.coordinateSystem, i = r.getBaseAxis(), a = r.getOtherAxis(i), s = e.getDimensionIndex(e.mapDimension(a.dim)), o = e.getDimensionIndex(e.mapDimension(i.dim)), l = t.get("showBackground", true), u = e.mapDimension(a.dim), c = e.getCalculationInfo("stackResultDimension"), h = Kl(e, u) && !!e.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), d = blt(i, a), p = BH(t), g = t.get("barMinHeight") || 0, v = c && e.getDimensionIndex(c), m = e.getLayout("size"), y = e.getLayout("offset");
          return {
            progress: function(x, b) {
              for (var _ = x.count, w = p && zs(_ * 3), S = p && l && zs(_ * 3), I = p && zs(_), T = r.master.getRect(), A = f ? T.width : T.height, C, D = b.getStore(), E = 0; (C = x.next()) != null; ) {
                var M = D.get(h ? v : s, C), L = D.get(o, C), k = d, N = void 0;
                h && (N = +M - D.get(s, C));
                var R = void 0, $ = void 0, O = void 0, F = void 0;
                if (f) {
                  var z = r.dataToPoint([
                    M,
                    L
                  ]);
                  if (h) {
                    var V = r.dataToPoint([
                      N,
                      L
                    ]);
                    k = V[0];
                  }
                  R = k, $ = z[1] + y, O = z[0] - k, F = m, Math.abs(O) < g && (O = (O < 0 ? -1 : 1) * g);
                } else {
                  var z = r.dataToPoint([
                    L,
                    M
                  ]);
                  if (h) {
                    var V = r.dataToPoint([
                      L,
                      N
                    ]);
                    k = V[1];
                  }
                  R = z[0] + y, $ = k, O = m, F = z[1] - k, Math.abs(F) < g && (F = (F <= 0 ? -1 : 1) * g);
                }
                p ? (w[E] = R, w[E + 1] = $, w[E + 2] = f ? O : F, S && (S[E] = f ? T.x : R, S[E + 1] = f ? $ : T.y, S[E + 2] = A), I[C] = C) : b.setItemLayout(C, {
                  x: R,
                  y: $,
                  width: O,
                  height: F
                }), E += 3;
              }
              p && b.setLayout({
                largePoints: w,
                largeDataIndices: I,
                largeBackgroundPoints: S,
                valueAxisHorizontal: f
              });
            }
          };
        }
      }
    };
  }
  function FH(n) {
    return n.coordinateSystem && n.coordinateSystem.type === "cartesian2d";
  }
  function BH(n) {
    return n.pipelineContext && n.pipelineContext.large;
  }
  function blt(n, t) {
    var e = t.model.get("startValue");
    return e || (e = 0), t.toGlobalCoord(t.dataToCoord(t.type === "log" ? e > 0 ? e : 1 : e));
  }
  var _lt = function(n, t, e, r) {
    for (; e < r; ) {
      var i = e + r >>> 1;
      n[i][1] < t ? e = i + 1 : r = i;
    }
    return e;
  }, AD = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "time", r;
    }
    return t.prototype.getLabel = function(e) {
      var r = this.getSetting("useUTC");
      return R1(e.value, DP[eat(Mf(this._minLevelUnit))] || DP.second, r, this.getSetting("locale"));
    }, t.prototype.getFormattedLabel = function(e, r, i) {
      var a = this.getSetting("useUTC"), s = this.getSetting("locale");
      return nat(e, r, i, s, a);
    }, t.prototype.getTicks = function() {
      var e = this._interval, r = this._extent, i = [];
      if (!e) return i;
      i.push({
        value: r[0],
        level: 0
      });
      var a = this.getSetting("useUTC"), s = klt(this._minLevelUnit, this._approxInterval, a, r);
      return i = i.concat(s), i.push({
        value: r[1],
        level: 0
      }), i;
    }, t.prototype.calcNiceExtent = function(e) {
      var r = this._extent;
      if (r[0] === r[1] && (r[0] -= xa, r[1] += xa), r[1] === -1 / 0 && r[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        r[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), r[0] = r[1] - xa;
      }
      this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
    }, t.prototype.calcNiceTicks = function(e, r, i) {
      e = e || 10;
      var a = this._extent, s = a[1] - a[0];
      this._approxInterval = s / e, r != null && this._approxInterval < r && (this._approxInterval = r), i != null && this._approxInterval > i && (this._approxInterval = i);
      var o = Yy.length, l = Math.min(_lt(Yy, this._approxInterval, 0, o), o - 1);
      this._interval = Yy[l][1], this._minLevelUnit = Yy[Math.max(l - 1, 0)][0];
    }, t.prototype.parse = function(e) {
      return _e(e) ? e : +no(e);
    }, t.prototype.contain = function(e) {
      return G1(this.parse(e), this._extent);
    }, t.prototype.normalize = function(e) {
      return W1(this.parse(e), this._extent);
    }, t.prototype.scale = function(e) {
      return U1(e, this._extent);
    }, t.type = "time", t;
  }(Uo), Yy = [
    [
      "second",
      sD
    ],
    [
      "minute",
      oD
    ],
    [
      "hour",
      gg
    ],
    [
      "quarter-day",
      gg * 6
    ],
    [
      "half-day",
      gg * 12
    ],
    [
      "day",
      xa * 1.2
    ],
    [
      "half-week",
      xa * 3.5
    ],
    [
      "week",
      xa * 7
    ],
    [
      "month",
      xa * 31
    ],
    [
      "quarter",
      xa * 95
    ],
    [
      "half-year",
      kP / 2
    ],
    [
      "year",
      kP
    ]
  ];
  function wlt(n, t, e, r) {
    var i = no(t), a = no(e), s = function(p) {
      return EP(i, p, r) === EP(a, p, r);
    }, o = function() {
      return s("year");
    }, l = function() {
      return o() && s("month");
    }, u = function() {
      return l() && s("day");
    }, c = function() {
      return u() && s("hour");
    }, h = function() {
      return c() && s("minute");
    }, f = function() {
      return h() && s("second");
    }, d = function() {
      return f() && s("millisecond");
    };
    switch (n) {
      case "year":
        return o();
      case "month":
        return l();
      case "day":
        return u();
      case "hour":
        return c();
      case "minute":
        return h();
      case "second":
        return f();
      case "millisecond":
        return d();
    }
  }
  function Slt(n, t) {
    return n /= xa, n > 16 ? 16 : n > 7.5 ? 7 : n > 3.5 ? 4 : n > 1.5 ? 2 : 1;
  }
  function Clt(n) {
    var t = 30 * xa;
    return n /= t, n > 6 ? 6 : n > 3 ? 3 : n > 2 ? 2 : 1;
  }
  function Tlt(n) {
    return n /= gg, n > 12 ? 12 : n > 6 ? 6 : n > 3.5 ? 4 : n > 2 ? 2 : 1;
  }
  function z$(n, t) {
    return n /= t ? oD : sD, n > 30 ? 30 : n > 20 ? 20 : n > 15 ? 15 : n > 10 ? 10 : n > 5 ? 5 : n > 2 ? 2 : 1;
  }
  function Ilt(n) {
    return rU(n);
  }
  function Alt(n, t, e) {
    var r = new Date(n);
    switch (Mf(t)) {
      case "year":
      case "month":
        r[r5(e)](0);
      case "day":
        r[i5(e)](1);
      case "hour":
        r[a5(e)](0);
      case "minute":
        r[s5(e)](0);
      case "second":
        r[o5(e)](0), r[l5(e)](0);
    }
    return r.getTime();
  }
  function klt(n, t, e, r) {
    var i = 1e4, a = e5, s = 0;
    function o(A, C, D, E, M, L, k) {
      for (var N = new Date(C), R = C, $ = N[E](); R < D && R <= r[1]; ) k.push({
        value: R
      }), $ += A, N[M]($), R = N.getTime();
      k.push({
        value: R,
        notAdd: true
      });
    }
    function l(A, C, D) {
      var E = [], M = !C.length;
      if (!wlt(Mf(A), r[0], r[1], e)) {
        M && (C = [
          {
            value: Alt(new Date(r[0]), A, e)
          },
          {
            value: r[1]
          }
        ]);
        for (var L = 0; L < C.length - 1; L++) {
          var k = C[L].value, N = C[L + 1].value;
          if (k !== N) {
            var R = void 0, $ = void 0, O = void 0, F = false;
            switch (A) {
              case "year":
                R = Math.max(1, Math.round(t / xa / 365)), $ = lD(e), O = rat(e);
                break;
              case "half-year":
              case "quarter":
              case "month":
                R = Clt(t), $ = Rf(e), O = r5(e);
                break;
              case "week":
              case "half-week":
              case "day":
                R = Slt(t), $ = N1(e), O = i5(e), F = true;
                break;
              case "half-day":
              case "quarter-day":
              case "hour":
                R = Tlt(t), $ = zg(e), O = a5(e);
                break;
              case "minute":
                R = z$(t, true), $ = L1(e), O = s5(e);
                break;
              case "second":
                R = z$(t, false), $ = P1(e), O = o5(e);
                break;
              case "millisecond":
                R = Ilt(t), $ = $1(e), O = l5(e);
                break;
            }
            o(R, k, N, $, O, F, E), A === "year" && D.length > 1 && L === 0 && D.unshift({
              value: D[0].value - R
            });
          }
        }
        for (var L = 0; L < E.length; L++) D.push(E[L]);
        return E;
      }
    }
    for (var u = [], c = [], h = 0, f = 0, d = 0; d < a.length && s++ < i; ++d) {
      var p = Mf(a[d]);
      if (tat(a[d])) {
        l(a[d], u[u.length - 1] || [], c);
        var g = a[d + 1] ? Mf(a[d + 1]) : null;
        if (p !== g) {
          if (c.length) {
            f = h, c.sort(function(A, C) {
              return A.value - C.value;
            });
            for (var v = [], m = 0; m < c.length; ++m) {
              var y = c[m].value;
              (m === 0 || c[m - 1].value !== y) && (v.push(c[m]), y >= r[0] && y <= r[1] && h++);
            }
            var x = (r[1] - r[0]) / t;
            if (h > x * 1.5 && f > x / 1.5 || (u.push(v), h > x || n === a[d])) break;
          }
          c = [];
        }
      }
    }
    for (var b = Le(ht(u, function(A) {
      return Le(A, function(C) {
        return C.value >= r[0] && C.value <= r[1] && !C.notAdd;
      });
    }), function(A) {
      return A.length > 0;
    }), _ = [], w = b.length - 1, d = 0; d < b.length; ++d) for (var S = b[d], I = 0; I < S.length; ++I) _.push({
      value: S[I].value,
      level: w - d
    });
    _.sort(function(A, C) {
      return A.value - C.value;
    });
    for (var T = [], d = 0; d < _.length; ++d) (d === 0 || _[d].value !== _[d - 1].value) && T.push(_[d]);
    return T;
  }
  ho.registerClass(AD);
  var V$ = ho.prototype, xg = Uo.prototype, Dlt = Cn, Elt = Math.floor, Mlt = Math.ceil, qy = Math.pow, Fa = Math.log, kD = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = "log", e.base = 10, e._originalScale = new Uo(), e._interval = 0, e;
    }
    return t.prototype.getTicks = function(e) {
      var r = this._originalScale, i = this._extent, a = r.getExtent(), s = xg.getTicks.call(this, e);
      return ht(s, function(o) {
        var l = o.value, u = Cn(qy(this.base, l));
        return u = l === i[0] && this._fixMin ? jy(u, a[0]) : u, u = l === i[1] && this._fixMax ? jy(u, a[1]) : u, {
          value: u
        };
      }, this);
    }, t.prototype.setExtent = function(e, r) {
      var i = Fa(this.base);
      e = Fa(Math.max(0, e)) / i, r = Fa(Math.max(0, r)) / i, xg.setExtent.call(this, e, r);
    }, t.prototype.getExtent = function() {
      var e = this.base, r = V$.getExtent.call(this);
      r[0] = qy(e, r[0]), r[1] = qy(e, r[1]);
      var i = this._originalScale, a = i.getExtent();
      return this._fixMin && (r[0] = jy(r[0], a[0])), this._fixMax && (r[1] = jy(r[1], a[1])), r;
    }, t.prototype.unionExtent = function(e) {
      this._originalScale.unionExtent(e);
      var r = this.base;
      e[0] = Fa(e[0]) / Fa(r), e[1] = Fa(e[1]) / Fa(r), V$.unionExtent.call(this, e);
    }, t.prototype.unionExtentFromData = function(e, r) {
      this.unionExtent(e.getApproximateExtent(r));
    }, t.prototype.calcNiceTicks = function(e) {
      e = e || 10;
      var r = this._extent, i = r[1] - r[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var a = Lnt(i), s = e / i * a;
        for (s <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; ) a *= 10;
        var o = [
          Cn(Mlt(r[0] / a) * a),
          Cn(Elt(r[1] / a) * a)
        ];
        this._interval = a, this._niceExtent = o;
      }
    }, t.prototype.calcNiceExtent = function(e) {
      xg.calcNiceExtent.call(this, e), this._fixMin = e.fixMin, this._fixMax = e.fixMax;
    }, t.prototype.parse = function(e) {
      return e;
    }, t.prototype.contain = function(e) {
      return e = Fa(e) / Fa(this.base), G1(e, this._extent);
    }, t.prototype.normalize = function(e) {
      return e = Fa(e) / Fa(this.base), W1(e, this._extent);
    }, t.prototype.scale = function(e) {
      return e = U1(e, this._extent), qy(this.base, e);
    }, t.type = "log", t;
  }(ho), zH = kD.prototype;
  zH.getMinorTicks = xg.getMinorTicks;
  zH.getLabel = xg.getLabel;
  function jy(n, t) {
    return Dlt(n, Fs(t));
  }
  ho.registerClass(kD);
  var Rlt = function() {
    function n(t, e, r) {
      this._prepareParams(t, e, r);
    }
    return n.prototype._prepareParams = function(t, e, r) {
      r[1] < r[0] && (r = [
        NaN,
        NaN
      ]), this._dataMin = r[0], this._dataMax = r[1];
      var i = this._isOrdinal = t.type === "ordinal";
      this._needCrossZero = t.type === "interval" && e.getNeedCrossZero && e.getNeedCrossZero();
      var a = e.get("min", true);
      a == null && (a = e.get("startValue", true));
      var s = this._modelMinRaw = a;
      Nt(s) ? this._modelMinNum = Ky(t, s({
        min: r[0],
        max: r[1]
      })) : s !== "dataMin" && (this._modelMinNum = Ky(t, s));
      var o = this._modelMaxRaw = e.get("max", true);
      if (Nt(o) ? this._modelMaxNum = Ky(t, o({
        min: r[0],
        max: r[1]
      })) : o !== "dataMax" && (this._modelMaxNum = Ky(t, o)), i) this._axisDataLen = e.getCategories().length;
      else {
        var l = e.get("boundaryGap"), u = ct(l) ? l : [
          l || 0,
          l || 0
        ];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? this._boundaryGapInner = [
          0,
          0
        ] : this._boundaryGapInner = [
          ss(u[0], 1),
          ss(u[1], 1)
        ];
      }
    }, n.prototype.calculate = function() {
      var t = this._isOrdinal, e = this._dataMin, r = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, s = t ? null : r - e || Math.abs(e), o = this._modelMinRaw === "dataMin" ? e : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? r : this._modelMaxNum, u = o != null, c = l != null;
      o == null && (o = t ? i ? 0 : NaN : e - a[0] * s), l == null && (l = t ? i ? i - 1 : NaN : r + a[1] * s), (o == null || !isFinite(o)) && (o = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var h = Eg(o) || Eg(l) || t && !i;
      this._needCrossZero && (o > 0 && l > 0 && !u && (o = 0), o < 0 && l < 0 && !c && (l = 0));
      var f = this._determinedMin, d = this._determinedMax;
      return f != null && (o = f, u = true), d != null && (l = d, c = true), {
        min: o,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: h
      };
    }, n.prototype.modifyDataMinMax = function(t, e) {
      this[Llt[t]] = e;
    }, n.prototype.setDeterminedMinMax = function(t, e) {
      var r = Nlt[t];
      this[r] = e;
    }, n.prototype.freeze = function() {
      this.frozen = true;
    }, n;
  }(), Nlt = {
    min: "_determinedMin",
    max: "_determinedMax"
  }, Llt = {
    min: "_dataMin",
    max: "_dataMax"
  };
  function VH(n, t, e) {
    var r = n.rawExtentInfo;
    return r || (r = new Rlt(n, t, e), n.rawExtentInfo = r, r);
  }
  function Ky(n, t) {
    return t == null ? null : Eg(t) ? NaN : n.parse(t);
  }
  function GH(n, t) {
    var e = n.type, r = VH(n, t, n.getExtent()).calculate();
    n.setBlank(r.isBlank);
    var i = r.min, a = r.max, s = t.ecModel;
    if (s && e === "time") {
      var o = NH("bar", s), l = false;
      if (P(o, function(h) {
        l = l || h.getBaseAxis() === t.axis;
      }), l) {
        var u = LH(o), c = Plt(i, a, t, u);
        i = c.min, a = c.max;
      }
    }
    return {
      extent: [
        i,
        a
      ],
      fixMin: r.minFixed,
      fixMax: r.maxFixed
    };
  }
  function Plt(n, t, e, r) {
    var i = e.axis.getExtent(), a = Math.abs(i[1] - i[0]), s = xlt(r, e.axis);
    if (s === void 0) return {
      min: n,
      max: t
    };
    var o = 1 / 0;
    P(s, function(d) {
      o = Math.min(d.offset, o);
    });
    var l = -1 / 0;
    P(s, function(d) {
      l = Math.max(d.offset + d.width, l);
    }), o = Math.abs(o), l = Math.abs(l);
    var u = o + l, c = t - n, h = 1 - (o + l) / a, f = c / h - c;
    return t += f * (l / u), n -= f * (o / u), {
      min: n,
      max: t
    };
  }
  function Hf(n, t) {
    var e = t, r = GH(n, e), i = r.extent, a = e.get("splitNumber");
    n instanceof kD && (n.base = e.get("logBase"));
    var s = n.type, o = e.get("interval"), l = s === "interval" || s === "time";
    n.setExtent(i[0], i[1]), n.calcNiceExtent({
      splitNumber: a,
      fixMin: r.fixMin,
      fixMax: r.fixMax,
      minInterval: l ? e.get("minInterval") : null,
      maxInterval: l ? e.get("maxInterval") : null
    }), o != null && n.setInterval && n.setInterval(o);
  }
  function X1(n, t) {
    if (t = t || n.get("type"), t) switch (t) {
      case "category":
        return new H1({
          ordinalMeta: n.getOrdinalMeta ? n.getOrdinalMeta() : n.getCategories(),
          extent: [
            1 / 0,
            -1 / 0
          ]
        });
      case "time":
        return new AD({
          locale: n.ecModel.getLocaleModel(),
          useUTC: n.ecModel.get("useUTC")
        });
      default:
        return new (ho.getClass(t) || Uo)();
    }
  }
  function $lt(n) {
    var t = n.scale.getExtent(), e = t[0], r = t[1];
    return !(e > 0 && r > 0 || e < 0 && r < 0);
  }
  function Ed(n) {
    var t = n.getLabelModel().get("formatter"), e = n.type === "category" ? n.scale.getExtent()[0] : null;
    return n.scale.type === "time" ? /* @__PURE__ */ function(r) {
      return function(i, a) {
        return n.scale.getFormattedLabel(i, a, r);
      };
    }(t) : wt(t) ? /* @__PURE__ */ function(r) {
      return function(i) {
        var a = n.scale.getLabel(i), s = r.replace("{value}", a ?? "");
        return s;
      };
    }(t) : Nt(t) ? /* @__PURE__ */ function(r) {
      return function(i, a) {
        return e != null && (a = i.value - e), r(DD(n, i), a, i.level != null ? {
          level: i.level
        } : null);
      };
    }(t) : function(r) {
      return n.scale.getLabel(r);
    };
  }
  function DD(n, t) {
    return n.type === "category" ? n.scale.getLabel(t) : t.value;
  }
  function Olt(n) {
    var t = n.model, e = n.scale;
    if (!(!t.get([
      "axisLabel",
      "show"
    ]) || e.isBlank())) {
      var r, i, a = e.getExtent();
      e instanceof H1 ? i = e.count() : (r = e.getTicks(), i = r.length);
      var s = n.getLabelModel(), o = Ed(n), l, u = 1;
      i > 40 && (u = Math.ceil(i / 40));
      for (var c = 0; c < i; c += u) {
        var h = r ? r[c] : {
          value: a[0] + c
        }, f = o(h, c), d = s.getTextRect(f), p = Flt(d, s.get("rotate") || 0);
        l ? l.union(p) : l = p;
      }
      return l;
    }
  }
  function Flt(n, t) {
    var e = t * Math.PI / 180, r = n.width, i = n.height, a = r * Math.abs(Math.cos(e)) + Math.abs(i * Math.sin(e)), s = r * Math.abs(Math.sin(e)) + Math.abs(i * Math.cos(e)), o = new te(n.x, n.y, a, s);
    return o;
  }
  function ED(n) {
    var t = n.get("interval");
    return t ?? "auto";
  }
  function WH(n) {
    return n.type === "category" && ED(n.getLabelModel()) === 0;
  }
  function sb(n, t) {
    var e = {};
    return P(n.mapDimensionsAll(t), function(r) {
      e[DH(n, r)] = true;
    }), ge(e);
  }
  function Blt(n, t, e) {
    t && P(sb(t, e), function(r) {
      var i = t.getApproximateExtent(r);
      i[0] < n[0] && (n[0] = i[0]), i[1] > n[1] && (n[1] = i[1]);
    });
  }
  var Gv = function() {
    function n() {
    }
    return n.prototype.getNeedCrossZero = function() {
      var t = this.option;
      return !t.scale;
    }, n.prototype.getCoordSysModel = function() {
    }, n;
  }(), zlt = 1e-8;
  function G$(n, t) {
    return Math.abs(n - t) < zlt;
  }
  function uc(n, t, e) {
    var r = 0, i = n[0];
    if (!i) return false;
    for (var a = 1; a < n.length; a++) {
      var s = n[a];
      r += wo(i[0], i[1], s[0], s[1], t, e), i = s;
    }
    var o = n[0];
    return (!G$(i[0], o[0]) || !G$(i[1], o[1])) && (r += wo(i[0], i[1], o[0], o[1], t, e)), r !== 0;
  }
  var Vlt = [];
  function XS(n, t) {
    for (var e = 0; e < n.length; e++) Tr(n[e], n[e], t);
  }
  function W$(n, t, e, r) {
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      r && (a = r.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Cl(t, t, a), Tl(e, e, a));
    }
  }
  function Glt(n) {
    for (var t = 0, e = 0, r = 0, i = n.length, a = n[i - 1][0], s = n[i - 1][1], o = 0; o < i; o++) {
      var l = n[o][0], u = n[o][1], c = a * u - l * s;
      t += c, e += (a + l) * c, r += (s + u) * c, a = l, s = u;
    }
    return t ? [
      e / t / 3,
      r / t / 3,
      t
    ] : [
      n[0][0] || 0,
      n[0][1] || 0
    ];
  }
  var UH = function() {
    function n(t) {
      this.name = t;
    }
    return n.prototype.setCenter = function(t) {
      this._center = t;
    }, n.prototype.getCenter = function() {
      var t = this._center;
      return t || (t = this._center = this.calcCenter()), t;
    }, n;
  }(), U$ = /* @__PURE__ */ function() {
    function n(t, e) {
      this.type = "polygon", this.exterior = t, this.interiors = e;
    }
    return n;
  }(), H$ = /* @__PURE__ */ function() {
    function n(t) {
      this.type = "linestring", this.points = t;
    }
    return n;
  }(), HH = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this, e) || this;
      return a.type = "geoJSON", a.geometries = r, a._center = i && [
        i[0],
        i[1]
      ], a;
    }
    return t.prototype.calcCenter = function() {
      for (var e = this.geometries, r, i = 0, a = 0; a < e.length; a++) {
        var s = e[a], o = s.exterior, l = o && o.length;
        l > i && (r = s, i = l);
      }
      if (r) return Glt(r.exterior);
      var u = this.getBoundingRect();
      return [
        u.x + u.width / 2,
        u.y + u.height / 2
      ];
    }, t.prototype.getBoundingRect = function(e) {
      var r = this._rect;
      if (r && !e) return r;
      var i = [
        1 / 0,
        1 / 0
      ], a = [
        -1 / 0,
        -1 / 0
      ], s = this.geometries;
      return P(s, function(o) {
        o.type === "polygon" ? W$(o.exterior, i, a, e) : P(o.points, function(l) {
          W$(l, i, a, e);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), r = new te(i[0], i[1], a[0] - i[0], a[1] - i[1]), e || (this._rect = r), r;
    }, t.prototype.contain = function(e) {
      var r = this.getBoundingRect(), i = this.geometries;
      if (!r.contain(e[0], e[1])) return false;
      t: for (var a = 0, s = i.length; a < s; a++) {
        var o = i[a];
        if (o.type === "polygon") {
          var l = o.exterior, u = o.interiors;
          if (uc(l, e[0], e[1])) {
            for (var c = 0; c < (u ? u.length : 0); c++) if (uc(u[c], e[0], e[1])) continue t;
            return true;
          }
        }
      }
      return false;
    }, t.prototype.transformTo = function(e, r, i, a) {
      var s = this.getBoundingRect(), o = s.width / s.height;
      i ? a || (a = i / o) : i = o * a;
      for (var l = new te(e, r, i, a), u = s.calculateTransform(l), c = this.geometries, h = 0; h < c.length; h++) {
        var f = c[h];
        f.type === "polygon" ? (XS(f.exterior, u), P(f.interiors, function(d) {
          XS(d, u);
        })) : P(f.points, function(d) {
          XS(d, u);
        });
      }
      s = this._rect, s.copy(l), this._center = [
        s.x + s.width / 2,
        s.y + s.height / 2
      ];
    }, t.prototype.cloneShallow = function(e) {
      e == null && (e = this.name);
      var r = new t(e, this.geometries, this._center);
      return r._rect = this._rect, r.transformTo = null, r;
    }, t;
  }(UH), Wlt = function(n) {
    q(t, n);
    function t(e, r) {
      var i = n.call(this, e) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = r, i;
    }
    return t.prototype.calcCenter = function() {
      for (var e = this._elOnlyForCalculate, r = e.getBoundingRect(), i = [
        r.x + r.width / 2,
        r.y + r.height / 2
      ], a = m1(Vlt), s = e; s && !s.isGeoSVGGraphicRoot; ) Ro(a, s.getLocalTransform(), a), s = s.parent;
      return yd(a, a), Tr(i, i, a), i;
    }, t;
  }(UH);
  function Ult(n) {
    if (!n.UTF8Encoding) return n;
    var t = n, e = t.UTF8Scale;
    e == null && (e = 1024);
    var r = t.features;
    return P(r, function(i) {
      var a = i.geometry, s = a.encodeOffsets, o = a.coordinates;
      if (s) switch (a.type) {
        case "LineString":
          a.coordinates = XH(o, s, e);
          break;
        case "Polygon":
          YS(o, s, e);
          break;
        case "MultiLineString":
          YS(o, s, e);
          break;
        case "MultiPolygon":
          P(o, function(l, u) {
            return YS(l, s[u], e);
          });
      }
    }), t.UTF8Encoding = false, t;
  }
  function YS(n, t, e) {
    for (var r = 0; r < n.length; r++) n[r] = XH(n[r], t[r], e);
  }
  function XH(n, t, e) {
    for (var r = [], i = t[0], a = t[1], s = 0; s < n.length; s += 2) {
      var o = n.charCodeAt(s) - 64, l = n.charCodeAt(s + 1) - 64;
      o = o >> 1 ^ -(o & 1), l = l >> 1 ^ -(l & 1), o += i, l += a, i = o, a = l, r.push([
        o / e,
        l / e
      ]);
    }
    return r;
  }
  function Hlt(n, t) {
    return n = Ult(n), ht(Le(n.features, function(e) {
      return e.geometry && e.properties && e.geometry.coordinates.length > 0;
    }), function(e) {
      var r = e.properties, i = e.geometry, a = [];
      switch (i.type) {
        case "Polygon":
          var s = i.coordinates;
          a.push(new U$(s[0], s.slice(1)));
          break;
        case "MultiPolygon":
          P(i.coordinates, function(l) {
            l[0] && a.push(new U$(l[0], l.slice(1)));
          });
          break;
        case "LineString":
          a.push(new H$([
            i.coordinates
          ]));
          break;
        case "MultiLineString":
          a.push(new H$(i.coordinates));
      }
      var o = new HH(r[t || "name"], a, r.cp);
      return o.properties = r, o;
    });
  }
  var Xg = xe();
  function YH(n, t) {
    var e = ht(t, function(r) {
      return n.scale.parse(r);
    });
    return n.type === "time" && e.length > 0 && (e.sort(), e.unshift(e[0]), e.push(e[e.length - 1])), e;
  }
  function Xlt(n) {
    var t = n.getLabelModel().get("customValues");
    if (t) {
      var e = Ed(n), r = n.scale.getExtent(), i = YH(n, t), a = Le(i, function(s) {
        return s >= r[0] && s <= r[1];
      });
      return {
        labels: ht(a, function(s) {
          var o = {
            value: s
          };
          return {
            formattedLabel: e(o),
            rawLabel: n.scale.getLabel(o),
            tickValue: s
          };
        })
      };
    }
    return n.type === "category" ? qlt(n) : Klt(n);
  }
  function Ylt(n, t) {
    var e = n.getTickModel().get("customValues");
    if (e) {
      var r = n.scale.getExtent(), i = YH(n, e);
      return {
        ticks: Le(i, function(a) {
          return a >= r[0] && a <= r[1];
        })
      };
    }
    return n.type === "category" ? jlt(n, t) : {
      ticks: ht(n.scale.getTicks(), function(a) {
        return a.value;
      })
    };
  }
  function qlt(n) {
    var t = n.getLabelModel(), e = qH(n, t);
    return !t.get("show") || n.scale.isBlank() ? {
      labels: [],
      labelCategoryInterval: e.labelCategoryInterval
    } : e;
  }
  function qH(n, t) {
    var e = jH(n, "labels"), r = ED(t), i = KH(e, r);
    if (i) return i;
    var a, s;
    return Nt(r) ? a = QH(n, r) : (s = r === "auto" ? Zlt(n) : r, a = JH(n, s)), ZH(e, r, {
      labels: a,
      labelCategoryInterval: s
    });
  }
  function jlt(n, t) {
    var e = jH(n, "ticks"), r = ED(t), i = KH(e, r);
    if (i) return i;
    var a, s;
    if ((!t.get("show") || n.scale.isBlank()) && (a = []), Nt(r)) a = QH(n, r, true);
    else if (r === "auto") {
      var o = qH(n, n.getLabelModel());
      s = o.labelCategoryInterval, a = ht(o.labels, function(l) {
        return l.tickValue;
      });
    } else s = r, a = JH(n, s, true);
    return ZH(e, r, {
      ticks: a,
      tickCategoryInterval: s
    });
  }
  function Klt(n) {
    var t = n.scale.getTicks(), e = Ed(n);
    return {
      labels: ht(t, function(r, i) {
        return {
          level: r.level,
          formattedLabel: e(r, i),
          rawLabel: n.scale.getLabel(r),
          tickValue: r.value
        };
      })
    };
  }
  function jH(n, t) {
    return Xg(n)[t] || (Xg(n)[t] = []);
  }
  function KH(n, t) {
    for (var e = 0; e < n.length; e++) if (n[e].key === t) return n[e].value;
  }
  function ZH(n, t, e) {
    return n.push({
      key: t,
      value: e
    }), e;
  }
  function Zlt(n) {
    var t = Xg(n).autoInterval;
    return t ?? (Xg(n).autoInterval = n.calculateCategoryInterval());
  }
  function Jlt(n) {
    var t = Qlt(n), e = Ed(n), r = (t.axisRotate - t.labelRotate) / 180 * Math.PI, i = n.scale, a = i.getExtent(), s = i.count();
    if (a[1] - a[0] < 1) return 0;
    var o = 1;
    s > 40 && (o = Math.max(1, Math.floor(s / 40)));
    for (var l = a[0], u = n.dataToCoord(l + 1) - n.dataToCoord(l), c = Math.abs(u * Math.cos(r)), h = Math.abs(u * Math.sin(r)), f = 0, d = 0; l <= a[1]; l += o) {
      var p = 0, g = 0, v = Mv(e({
        value: l
      }), t.font, "center", "top");
      p = v.width * 1.3, g = v.height * 1.3, f = Math.max(f, p, 7), d = Math.max(d, g, 7);
    }
    var m = f / c, y = d / h;
    isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0);
    var x = Math.max(0, Math.floor(Math.min(m, y))), b = Xg(n.model), _ = n.getExtent(), w = b.lastAutoInterval, S = b.lastTickCount;
    return w != null && S != null && Math.abs(w - x) <= 1 && Math.abs(S - s) <= 1 && w > x && b.axisExtent0 === _[0] && b.axisExtent1 === _[1] ? x = w : (b.lastTickCount = s, b.lastAutoInterval = x, b.axisExtent0 = _[0], b.axisExtent1 = _[1]), x;
  }
  function Qlt(n) {
    var t = n.getLabelModel();
    return {
      axisRotate: n.getRotate ? n.getRotate() : n.isHorizontal && !n.isHorizontal() ? 90 : 0,
      labelRotate: t.get("rotate") || 0,
      font: t.getFont()
    };
  }
  function JH(n, t, e) {
    var r = Ed(n), i = n.scale, a = i.getExtent(), s = n.getLabelModel(), o = [], l = Math.max((t || 0) + 1, 1), u = a[0], c = i.count();
    u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
    var h = WH(n), f = s.get("showMinLabel") || h, d = s.get("showMaxLabel") || h;
    f && u !== a[0] && g(a[0]);
    for (var p = u; p <= a[1]; p += l) g(p);
    d && p - l !== a[1] && g(a[1]);
    function g(v) {
      var m = {
        value: v
      };
      o.push(e ? v : {
        formattedLabel: r(m),
        rawLabel: i.getLabel(m),
        tickValue: v
      });
    }
    return o;
  }
  function QH(n, t, e) {
    var r = n.scale, i = Ed(n), a = [];
    return P(r.getTicks(), function(s) {
      var o = r.getLabel(s), l = s.value;
      t(s.value, o) && a.push(e ? l : {
        formattedLabel: i(s),
        rawLabel: o,
        tickValue: l
      });
    }), a;
  }
  var X$ = [
    0,
    1
  ], ds = function() {
    function n(t, e, r) {
      this.onBand = false, this.inverse = false, this.dim = t, this.scale = e, this._extent = r || [
        0,
        0
      ];
    }
    return n.prototype.contain = function(t) {
      var e = this._extent, r = Math.min(e[0], e[1]), i = Math.max(e[0], e[1]);
      return t >= r && t <= i;
    }, n.prototype.containData = function(t) {
      return this.scale.contain(t);
    }, n.prototype.getExtent = function() {
      return this._extent.slice();
    }, n.prototype.getPixelPrecision = function(t) {
      return eU(t || this.scale.getExtent(), this._extent);
    }, n.prototype.setExtent = function(t, e) {
      var r = this._extent;
      r[0] = t, r[1] = e;
    }, n.prototype.dataToCoord = function(t, e) {
      var r = this._extent, i = this.scale;
      return t = i.normalize(t), this.onBand && i.type === "ordinal" && (r = r.slice(), Y$(r, i.count())), Pe(t, X$, r, e);
    }, n.prototype.coordToData = function(t, e) {
      var r = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (r = r.slice(), Y$(r, i.count()));
      var a = Pe(t, r, X$, e);
      return this.scale.scale(a);
    }, n.prototype.pointToData = function(t, e) {
    }, n.prototype.getTicksCoords = function(t) {
      t = t || {};
      var e = t.tickModel || this.getTickModel(), r = Ylt(this, e), i = r.ticks, a = ht(i, function(o) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(o) : o),
          tickValue: o
        };
      }, this), s = e.get("alignWithLabel");
      return tut(this, a, s, t.clamp), a;
    }, n.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal") return [];
      var t = this.model.getModel("minorTick"), e = t.get("splitNumber");
      e > 0 && e < 100 || (e = 5);
      var r = this.scale.getMinorTicks(e), i = ht(r, function(a) {
        return ht(a, function(s) {
          return {
            coord: this.dataToCoord(s),
            tickValue: s
          };
        }, this);
      }, this);
      return i;
    }, n.prototype.getViewLabels = function() {
      return Xlt(this).labels;
    }, n.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, n.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, n.prototype.getBandWidth = function() {
      var t = this._extent, e = this.scale.getExtent(), r = e[1] - e[0] + (this.onBand ? 1 : 0);
      r === 0 && (r = 1);
      var i = Math.abs(t[1] - t[0]);
      return Math.abs(i) / r;
    }, n.prototype.calculateCategoryInterval = function() {
      return Jlt(this);
    }, n;
  }();
  function Y$(n, t) {
    var e = n[1] - n[0], r = t, i = e / r / 2;
    n[0] += i, n[1] -= i;
  }
  function tut(n, t, e, r) {
    var i = t.length;
    if (!n.onBand || e || !i) return;
    var a = n.getExtent(), s, o;
    if (i === 1) t[0].coord = a[0], s = t[1] = {
      coord: a[1],
      tickValue: t[0].tickValue
    };
    else {
      var l = t[i - 1].tickValue - t[0].tickValue, u = (t[i - 1].coord - t[0].coord) / l;
      P(t, function(d) {
        d.coord -= u / 2;
      });
      var c = n.scale.getExtent();
      o = 1 + c[1] - t[i - 1].tickValue, s = {
        coord: t[i - 1].coord + u * o,
        tickValue: c[1] + 1
      }, t.push(s);
    }
    var h = a[0] > a[1];
    f(t[0].coord, a[0]) && (r ? t[0].coord = a[0] : t.shift()), r && f(a[0], t[0].coord) && t.unshift({
      coord: a[0]
    }), f(a[1], s.coord) && (r ? s.coord = a[1] : t.pop()), r && f(s.coord, a[1]) && t.push({
      coord: a[1]
    });
    function f(d, p) {
      return d = Cn(d), p = Cn(p), h ? d > p : d < p;
    }
  }
  var vp = Math.PI * 2, Gu = ro.CMD, eut = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function nut(n, t, e, r, i) {
    var a = e.width, s = e.height;
    switch (n) {
      case "top":
        r.set(e.x + a / 2, e.y - t), i.set(0, -1);
        break;
      case "bottom":
        r.set(e.x + a / 2, e.y + s + t), i.set(0, 1);
        break;
      case "left":
        r.set(e.x - t, e.y + s / 2), i.set(-1, 0);
        break;
      case "right":
        r.set(e.x + a + t, e.y + s / 2), i.set(1, 0);
        break;
    }
  }
  function rut(n, t, e, r, i, a, s, o, l) {
    s -= n, o -= t;
    var u = Math.sqrt(s * s + o * o);
    s /= u, o /= u;
    var c = s * e + n, h = o * e + t;
    if (Math.abs(r - i) % vp < 1e-4) return l[0] = c, l[1] = h, u - e;
    if (a) {
      var f = r;
      r = Ui(i), i = Ui(f);
    } else r = Ui(r), i = Ui(i);
    r > i && (i += vp);
    var d = Math.atan2(o, s);
    if (d < 0 && (d += vp), d >= r && d <= i || d + vp >= r && d + vp <= i) return l[0] = c, l[1] = h, u - e;
    var p = e * Math.cos(r) + n, g = e * Math.sin(r) + t, v = e * Math.cos(i) + n, m = e * Math.sin(i) + t, y = (p - s) * (p - s) + (g - o) * (g - o), x = (v - s) * (v - s) + (m - o) * (m - o);
    return y < x ? (l[0] = p, l[1] = g, Math.sqrt(y)) : (l[0] = v, l[1] = m, Math.sqrt(x));
  }
  function ob(n, t, e, r, i, a, s, o) {
    var l = i - n, u = a - t, c = e - n, h = r - t, f = Math.sqrt(c * c + h * h);
    c /= f, h /= f;
    var d = l * c + u * h, p = d / f;
    o && (p = Math.min(Math.max(p, 0), 1)), p *= f;
    var g = s[0] = n + p * c, v = s[1] = t + p * h;
    return Math.sqrt((g - i) * (g - i) + (v - a) * (v - a));
  }
  function t6(n, t, e, r, i, a, s) {
    e < 0 && (n = n + e, e = -e), r < 0 && (t = t + r, r = -r);
    var o = n + e, l = t + r, u = s[0] = Math.min(Math.max(i, n), o), c = s[1] = Math.min(Math.max(a, t), l);
    return Math.sqrt((u - i) * (u - i) + (c - a) * (c - a));
  }
  var Ha = [];
  function iut(n, t, e) {
    var r = t6(t.x, t.y, t.width, t.height, n.x, n.y, Ha);
    return e.set(Ha[0], Ha[1]), r;
  }
  function aut(n, t, e) {
    for (var r = 0, i = 0, a = 0, s = 0, o, l, u = 1 / 0, c = t.data, h = n.x, f = n.y, d = 0; d < c.length; ) {
      var p = c[d++];
      d === 1 && (r = c[d], i = c[d + 1], a = r, s = i);
      var g = u;
      switch (p) {
        case Gu.M:
          a = c[d++], s = c[d++], r = a, i = s;
          break;
        case Gu.L:
          g = ob(r, i, c[d], c[d + 1], h, f, Ha, true), r = c[d++], i = c[d++];
          break;
        case Gu.C:
          g = OW(r, i, c[d++], c[d++], c[d++], c[d++], c[d], c[d + 1], h, f, Ha), r = c[d++], i = c[d++];
          break;
        case Gu.Q:
          g = BW(r, i, c[d++], c[d++], c[d], c[d + 1], h, f, Ha), r = c[d++], i = c[d++];
          break;
        case Gu.A:
          var v = c[d++], m = c[d++], y = c[d++], x = c[d++], b = c[d++], _ = c[d++];
          d += 1;
          var w = !!(1 - c[d++]);
          o = Math.cos(b) * y + v, l = Math.sin(b) * x + m, d <= 1 && (a = o, s = l);
          var S = (h - v) * x / y + v;
          g = rut(v, m, x, b, b + _, w, S, f, Ha), r = Math.cos(b + _) * y + v, i = Math.sin(b + _) * x + m;
          break;
        case Gu.R:
          a = r = c[d++], s = i = c[d++];
          var I = c[d++], T = c[d++];
          g = t6(a, s, I, T, h, f, Ha);
          break;
        case Gu.Z:
          g = ob(r, i, a, s, h, f, Ha, true), r = a, i = s;
          break;
      }
      g < u && (u = g, e.set(Ha[0], Ha[1]));
    }
    return u;
  }
  var Ka = new Qt(), en = new Qt(), In = new Qt(), Vs = new Qt(), Os = new Qt();
  function q$(n, t) {
    if (n) {
      var e = n.getTextGuideLine(), r = n.getTextContent();
      if (r && e) {
        var i = n.textGuideLineConfig || {}, a = [
          [
            0,
            0
          ],
          [
            0,
            0
          ],
          [
            0,
            0
          ]
        ], s = i.candidates || eut, o = r.getBoundingRect().clone();
        o.applyTransform(r.getComputedTransform());
        var l = 1 / 0, u = i.anchor, c = n.getComputedTransform(), h = c && yd([], c), f = t.get("length2") || 0;
        u && In.copy(u);
        for (var d = 0; d < s.length; d++) {
          var p = s[d];
          nut(p, 0, o, Ka, Vs), Qt.scaleAndAdd(en, Ka, Vs, f), en.transform(h);
          var g = n.getBoundingRect(), v = u ? u.distance(en) : n instanceof le ? aut(en, n.path, In) : iut(en, g, In);
          v < l && (l = v, en.transform(c), In.transform(c), In.toArray(a[0]), en.toArray(a[1]), Ka.toArray(a[2]));
        }
        e6(a, t.get("minTurnAngle")), e.setShape({
          points: a
        });
      }
    }
  }
  var lb = [], ai = new Qt();
  function e6(n, t) {
    if (t <= 180 && t > 0) {
      t = t / 180 * Math.PI, Ka.fromArray(n[0]), en.fromArray(n[1]), In.fromArray(n[2]), Qt.sub(Vs, Ka, en), Qt.sub(Os, In, en);
      var e = Vs.len(), r = Os.len();
      if (!(e < 1e-3 || r < 1e-3)) {
        Vs.scale(1 / e), Os.scale(1 / r);
        var i = Vs.dot(Os), a = Math.cos(t);
        if (a < i) {
          var s = ob(en.x, en.y, In.x, In.y, Ka.x, Ka.y, lb, false);
          ai.fromArray(lb), ai.scaleAndAdd(Os, s / Math.tan(Math.PI - t));
          var o = In.x !== en.x ? (ai.x - en.x) / (In.x - en.x) : (ai.y - en.y) / (In.y - en.y);
          if (isNaN(o)) return;
          o < 0 ? Qt.copy(ai, en) : o > 1 && Qt.copy(ai, In), ai.toArray(n[1]);
        }
      }
    }
  }
  function sut(n, t, e) {
    if (e <= 180 && e > 0) {
      e = e / 180 * Math.PI, Ka.fromArray(n[0]), en.fromArray(n[1]), In.fromArray(n[2]), Qt.sub(Vs, en, Ka), Qt.sub(Os, In, en);
      var r = Vs.len(), i = Os.len();
      if (!(r < 1e-3 || i < 1e-3)) {
        Vs.scale(1 / r), Os.scale(1 / i);
        var a = Vs.dot(t), s = Math.cos(e);
        if (a < s) {
          var o = ob(en.x, en.y, In.x, In.y, Ka.x, Ka.y, lb, false);
          ai.fromArray(lb);
          var l = Math.PI / 2, u = Math.acos(Os.dot(t)), c = l + u - e;
          if (c >= l) Qt.copy(ai, In);
          else {
            ai.scaleAndAdd(Os, o / Math.tan(Math.PI / 2 - c));
            var h = In.x !== en.x ? (ai.x - en.x) / (In.x - en.x) : (ai.y - en.y) / (In.y - en.y);
            if (isNaN(h)) return;
            h < 0 ? Qt.copy(ai, en) : h > 1 && Qt.copy(ai, In);
          }
          ai.toArray(n[1]);
        }
      }
    }
  }
  function qS(n, t, e, r) {
    var i = e === "normal", a = i ? n : n.ensureState(e);
    a.ignore = t;
    var s = r.get("smooth");
    s && s === true && (s = 0.3), a.shape = a.shape || {}, s > 0 && (a.shape.smooth = s);
    var o = r.getModel("lineStyle").getLineStyle();
    i ? n.useStyle(o) : a.style = o;
  }
  function out(n, t) {
    var e = t.smooth, r = t.points;
    if (r) if (n.moveTo(r[0][0], r[0][1]), e > 0 && r.length >= 3) {
      var i = Sl(r[0], r[1]), a = Sl(r[1], r[2]);
      if (!i || !a) {
        n.lineTo(r[1][0], r[1][1]), n.lineTo(r[2][0], r[2][1]);
        return;
      }
      var s = Math.min(i, a) * e, o = nx([], r[1], r[0], s / i), l = nx([], r[1], r[2], s / a), u = nx([], o, l, 0.5);
      n.bezierCurveTo(o[0], o[1], o[0], o[1], u[0], u[1]), n.bezierCurveTo(l[0], l[1], l[0], l[1], r[2][0], r[2][1]);
    } else for (var c = 1; c < r.length; c++) n.lineTo(r[c][0], r[c][1]);
  }
  function MD(n, t, e) {
    var r = n.getTextGuideLine(), i = n.getTextContent();
    if (!i) {
      r && n.removeTextGuideLine();
      return;
    }
    for (var a = t.normal, s = a.get("show"), o = i.ignore, l = 0; l < Og.length; l++) {
      var u = Og[l], c = t[u], h = u === "normal";
      if (c) {
        var f = c.get("show"), d = h ? o : Ht(i.states[u] && i.states[u].ignore, o);
        if (d || !Ht(f, s)) {
          var p = h ? r : r && r.states[u];
          p && (p.ignore = true), r && qS(r, true, u, c);
          continue;
        }
        r || (r = new _i(), n.setTextGuideLine(r), !h && (o || !s) && qS(r, true, "normal", t.normal), n.stateProxy && (r.stateProxy = n.stateProxy)), qS(r, false, u, c);
      }
    }
    if (r) {
      $t(r.style, e), r.style.fill = null;
      var g = a.get("showAbove"), v = n.textGuideLineConfig = n.textGuideLineConfig || {};
      v.showAbove = g || false, r.buildPath = out;
    }
  }
  function RD(n, t) {
    t = t || "labelLine";
    for (var e = {
      normal: n.getModel(t)
    }, r = 0; r < vi.length; r++) {
      var i = vi[r];
      e[i] = n.getModel([
        i,
        t
      ]);
    }
    return e;
  }
  function n6(n) {
    for (var t = [], e = 0; e < n.length; e++) {
      var r = n[e];
      if (!r.defaultAttr.ignore) {
        var i = r.label, a = i.getComputedTransform(), s = i.getBoundingRect(), o = !a || a[1] < 1e-5 && a[2] < 1e-5, l = i.style.margin || 0, u = s.clone();
        u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
        var c = o ? new Xx(s, a) : null;
        t.push({
          label: i,
          labelLine: r.labelLine,
          rect: u,
          localRect: s,
          obb: c,
          priority: r.priority,
          defaultAttr: r.defaultAttr,
          layoutOption: r.computedLayoutOption,
          axisAligned: o,
          transform: a
        });
      }
    }
    return t;
  }
  function r6(n, t, e, r, i, a) {
    var s = n.length;
    if (s < 2) return;
    n.sort(function(w, S) {
      return w.rect[t] - S.rect[t];
    });
    for (var o = 0, l, u = false, c = 0; c < s; c++) {
      var h = n[c], f = h.rect;
      l = f[t] - o, l < 0 && (f[t] -= l, h.label[t] -= l, u = true), o = f[t] + f[e];
    }
    var d = n[0], p = n[s - 1], g, v;
    m(), g < 0 && b(-g, 0.8), v < 0 && b(v, 0.8), m(), y(g, v, 1), y(v, g, -1), m(), g < 0 && _(-g), v < 0 && _(v);
    function m() {
      g = d.rect[t] - r, v = i - p.rect[t] - p.rect[e];
    }
    function y(w, S, I) {
      if (w < 0) {
        var T = Math.min(S, -w);
        if (T > 0) {
          x(T * I, 0, s);
          var A = T + w;
          A < 0 && b(-A * I, 1);
        } else b(-w * I, 1);
      }
    }
    function x(w, S, I) {
      w !== 0 && (u = true);
      for (var T = S; T < I; T++) {
        var A = n[T], C = A.rect;
        C[t] += w, A.label[t] += w;
      }
    }
    function b(w, S) {
      for (var I = [], T = 0, A = 1; A < s; A++) {
        var C = n[A - 1].rect, D = Math.max(n[A].rect[t] - C[t] - C[e], 0);
        I.push(D), T += D;
      }
      if (T) {
        var E = Math.min(Math.abs(w) / T, S);
        if (w > 0) for (var A = 0; A < s - 1; A++) {
          var M = I[A] * E;
          x(M, 0, A + 1);
        }
        else for (var A = s - 1; A > 0; A--) {
          var M = I[A - 1] * E;
          x(-M, A, s);
        }
      }
    }
    function _(w) {
      var S = w < 0 ? -1 : 1;
      w = Math.abs(w);
      for (var I = Math.ceil(w / (s - 1)), T = 0; T < s - 1; T++) if (S > 0 ? x(I, 0, T + 1) : x(-I, s - T - 1, s), w -= I, w <= 0) return;
    }
    return u;
  }
  function lut(n, t, e, r) {
    return r6(n, "x", "width", t, e);
  }
  function i6(n, t, e, r) {
    return r6(n, "y", "height", t, e);
  }
  function a6(n) {
    var t = [];
    n.sort(function(g, v) {
      return v.priority - g.priority;
    });
    var e = new te(0, 0, 0, 0);
    function r(g) {
      if (!g.ignore) {
        var v = g.ensureState("emphasis");
        v.ignore == null && (v.ignore = false);
      }
      g.ignore = true;
    }
    for (var i = 0; i < n.length; i++) {
      var a = n[i], s = a.axisAligned, o = a.localRect, l = a.transform, u = a.label, c = a.labelLine;
      e.copy(a.rect), e.width -= 0.1, e.height -= 0.1, e.x += 0.05, e.y += 0.05;
      for (var h = a.obb, f = false, d = 0; d < t.length; d++) {
        var p = t[d];
        if (e.intersect(p.rect)) {
          if (s && p.axisAligned) {
            f = true;
            break;
          }
          if (p.obb || (p.obb = new Xx(p.localRect, p.transform)), h || (h = new Xx(o, l)), h.intersect(p.obb)) {
            f = true;
            break;
          }
        }
      }
      f ? (r(u), c && r(c)) : (u.attr("ignore", a.defaultAttr.ignore), c && c.attr("ignore", a.defaultAttr.labelGuideIgnore), t.push(a));
    }
  }
  function uut(n) {
    if (n) {
      for (var t = [], e = 0; e < n.length; e++) t.push(n[e].slice());
      return t;
    }
  }
  function cut(n, t) {
    var e = n.label, r = t && t.getTextGuideLine();
    return {
      dataIndex: n.dataIndex,
      dataType: n.dataType,
      seriesIndex: n.seriesModel.seriesIndex,
      text: n.label.style.text,
      rect: n.hostRect,
      labelRect: n.rect,
      align: e.style.align,
      verticalAlign: e.style.verticalAlign,
      labelLinePoints: uut(r && r.shape.points)
    };
  }
  var j$ = [
    "align",
    "verticalAlign",
    "width",
    "height",
    "fontSize"
  ], ei = new To(), jS = xe(), hut = xe();
  function Zy(n, t, e) {
    for (var r = 0; r < e.length; r++) {
      var i = e[r];
      t[i] != null && (n[i] = t[i]);
    }
  }
  var Jy = [
    "x",
    "y",
    "rotation"
  ], fut = function() {
    function n() {
      this._labelList = [], this._chartViewList = [];
    }
    return n.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, n.prototype._addLabel = function(t, e, r, i, a) {
      var s = i.style, o = i.__hostTarget, l = o.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      te.applyTransform(c, c, u), u ? ei.setLocalTransform(u) : (ei.x = ei.y = ei.rotation = ei.originX = ei.originY = 0, ei.scaleX = ei.scaleY = 1), ei.rotation = Ui(ei.rotation);
      var h = i.__hostTarget, f;
      if (h) {
        f = h.getBoundingRect().plain();
        var d = h.getComputedTransform();
        te.applyTransform(f, f, d);
      }
      var p = f && h.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: r,
        dataIndex: t,
        dataType: e,
        layoutOption: a,
        computedLayoutOption: null,
        rect: c,
        hostRect: f,
        priority: f ? f.width * f.height : 0,
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: ei.x,
          y: ei.y,
          scaleX: ei.scaleX,
          scaleY: ei.scaleY,
          rotation: ei.rotation,
          style: {
            x: s.x,
            y: s.y,
            align: s.align,
            verticalAlign: s.verticalAlign,
            width: s.width,
            height: s.height,
            fontSize: s.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, n.prototype.addLabelsOfSeries = function(t) {
      var e = this;
      this._chartViewList.push(t);
      var r = t.__model, i = r.get("labelLayout");
      (Nt(i) || ge(i).length) && t.group.traverse(function(a) {
        if (a.ignore) return true;
        var s = a.getTextContent(), o = Ut(a);
        s && !s.disableLabelLayout && e._addLabel(o.dataIndex, o.dataType, r, s, i);
      });
    }, n.prototype.updateLayoutConfig = function(t) {
      var e = t.getWidth(), r = t.getHeight();
      function i(x, b) {
        return function() {
          q$(x, b);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var s = this._labelList[a], o = s.label, l = o.__hostTarget, u = s.defaultAttr, c = void 0;
        Nt(s.layoutOption) ? c = s.layoutOption(cut(s, l)) : c = s.layoutOption, c = c || {}, s.computedLayoutOption = c;
        var h = Math.PI / 180;
        l && l.setTextConfig({
          local: false,
          position: c.x != null || c.y != null ? null : u.attachedPos,
          rotation: c.rotate != null ? c.rotate * h : u.attachedRot,
          offset: [
            c.dx || 0,
            c.dy || 0
          ]
        });
        var f = false;
        if (c.x != null ? (o.x = yt(c.x, e), o.setStyle("x", 0), f = true) : (o.x = u.x, o.setStyle("x", u.style.x)), c.y != null ? (o.y = yt(c.y, r), o.setStyle("y", 0), f = true) : (o.y = u.y, o.setStyle("y", u.style.y)), c.labelLinePoints) {
          var d = l.getTextGuideLine();
          d && (d.setShape({
            points: c.labelLinePoints
          }), f = false);
        }
        var p = jS(o);
        p.needsUpdateLabelLine = f, o.rotation = c.rotate != null ? c.rotate * h : u.rotation, o.scaleX = u.scaleX, o.scaleY = u.scaleY;
        for (var g = 0; g < j$.length; g++) {
          var v = j$[g];
          o.setStyle(v, c[v] != null ? c[v] : u.style[v]);
        }
        if (c.draggable) {
          if (o.draggable = true, o.cursor = "move", l) {
            var m = s.seriesModel;
            if (s.dataIndex != null) {
              var y = s.seriesModel.getData(s.dataType);
              m = y.getItemModel(s.dataIndex);
            }
            o.on("drag", i(l, m.getModel("labelLine")));
          }
        } else o.off("drag"), o.cursor = u.cursor;
      }
    }, n.prototype.layout = function(t) {
      var e = t.getWidth(), r = t.getHeight(), i = n6(this._labelList), a = Le(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), s = Le(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      lut(a, 0, e), i6(s, 0, r);
      var o = Le(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      a6(o);
    }, n.prototype.processLabelsOverall = function() {
      var t = this;
      P(this._chartViewList, function(e) {
        var r = e.__model, i = e.ignoreLabelLineUpdate, a = r.isAnimationEnabled();
        e.group.traverse(function(s) {
          if (s.ignore && !s.forceLabelAnimation) return true;
          var o = !i, l = s.getTextContent();
          !o && l && (o = jS(l).needsUpdateLabelLine), o && t._updateLabelLine(s, r), a && t._animateLabels(s, r);
        });
      });
    }, n.prototype._updateLabelLine = function(t, e) {
      var r = t.getTextContent(), i = Ut(t), a = i.dataIndex;
      if (r && a != null) {
        var s = e.getData(i.dataType), o = s.getItemModel(a), l = {}, u = s.getItemVisual(a, "style");
        if (u) {
          var c = s.getVisual("drawType");
          l.stroke = u[c];
        }
        var h = o.getModel("labelLine");
        MD(t, RD(o), l), q$(t, h);
      }
    }, n.prototype._animateLabels = function(t, e) {
      var r = t.getTextContent(), i = t.getTextGuideLine();
      if (r && (t.forceLabelAnimation || !r.ignore && !r.invisible && !t.disableLabelAnimation && !Df(t))) {
        var a = jS(r), s = a.oldLayout, o = Ut(t), l = o.dataIndex, u = {
          x: r.x,
          y: r.y,
          rotation: r.rotation
        }, c = e.getData(o.dataType);
        if (s) {
          r.attr(s);
          var f = t.prevStates;
          f && (ne(f, "select") >= 0 && r.attr(a.oldLayoutSelect), ne(f, "emphasis") >= 0 && r.attr(a.oldLayoutEmphasis)), Ie(r, u, e, l);
        } else if (r.attr(u), !wd(r).valueAnimation) {
          var h = Ht(r.style.opacity, 1);
          r.style.opacity = 0, dn(r, {
            style: {
              opacity: h
            }
          }, e, l);
        }
        if (a.oldLayout = u, r.states.select) {
          var d = a.oldLayoutSelect = {};
          Zy(d, u, Jy), Zy(d, r.states.select, Jy);
        }
        if (r.states.emphasis) {
          var p = a.oldLayoutEmphasis = {};
          Zy(p, u, Jy), Zy(p, r.states.emphasis, Jy);
        }
        KU(r, l, c, e, e);
      }
      if (i && !i.ignore && !i.invisible) {
        var a = hut(i), s = a.oldLayout, g = {
          points: i.shape.points
        };
        s ? (i.attr({
          shape: s
        }), Ie(i, {
          shape: g
        }, e)) : (i.setShape(g), i.style.strokePercent = 0, dn(i, {
          style: {
            strokePercent: 1
          }
        }, e)), a.oldLayout = g;
      }
    }, n;
  }(), KS = xe();
  function dut(n) {
    n.registerUpdateLifecycle("series:beforeupdate", function(t, e, r) {
      var i = KS(e).labelManager;
      i || (i = KS(e).labelManager = new fut()), i.clearLabels();
    }), n.registerUpdateLifecycle("series:layoutlabels", function(t, e, r) {
      var i = KS(e).labelManager;
      r.updatedSeries.forEach(function(a) {
        i.addLabelsOfSeries(e.getViewOfSeriesModel(a));
      }), i.updateLayoutConfig(e), i.layout(e), i.processLabelsOverall();
    });
  }
  var ZS = Math.sin, JS = Math.cos, s6 = Math.PI, Wu = Math.PI * 2, put = 180 / s6, o6 = function() {
    function n() {
    }
    return n.prototype.reset = function(t) {
      this._start = true, this._d = [], this._str = "", this._p = Math.pow(10, t || 4);
    }, n.prototype.moveTo = function(t, e) {
      this._add("M", t, e);
    }, n.prototype.lineTo = function(t, e) {
      this._add("L", t, e);
    }, n.prototype.bezierCurveTo = function(t, e, r, i, a, s) {
      this._add("C", t, e, r, i, a, s);
    }, n.prototype.quadraticCurveTo = function(t, e, r, i) {
      this._add("Q", t, e, r, i);
    }, n.prototype.arc = function(t, e, r, i, a, s) {
      this.ellipse(t, e, r, r, 0, i, a, s);
    }, n.prototype.ellipse = function(t, e, r, i, a, s, o, l) {
      var u = o - s, c = !l, h = Math.abs(u), f = kl(h - Wu) || (c ? u >= Wu : -u >= Wu), d = u > 0 ? u % Wu : u % Wu + Wu, p = false;
      f ? p = true : kl(h) ? p = false : p = d >= s6 == !!c;
      var g = t + r * JS(s), v = e + i * ZS(s);
      this._start && this._add("M", g, v);
      var m = Math.round(a * put);
      if (f) {
        var y = 1 / this._p, x = (c ? 1 : -1) * (Wu - y);
        this._add("A", r, i, m, 1, +c, t + r * JS(s + x), e + i * ZS(s + x)), y > 0.01 && this._add("A", r, i, m, 0, +c, g, v);
      } else {
        var b = t + r * JS(o), _ = e + i * ZS(o);
        this._add("A", r, i, m, +p, +c, b, _);
      }
    }, n.prototype.rect = function(t, e, r, i) {
      this._add("M", t, e), this._add("l", r, 0), this._add("l", 0, i), this._add("l", -r, 0), this._add("Z");
    }, n.prototype.closePath = function() {
      this._d.length > 0 && this._add("Z");
    }, n.prototype._add = function(t, e, r, i, a, s, o, l, u) {
      for (var c = [], h = this._p, f = 1; f < arguments.length; f++) {
        var d = arguments[f];
        if (isNaN(d)) {
          this._invalid = true;
          return;
        }
        c.push(Math.round(d * h) / h);
      }
      this._d.push(t + c.join(" ")), this._start = t === "Z";
    }, n.prototype.generateStr = function() {
      this._str = this._invalid ? "" : this._d.join(""), this._d = [];
    }, n.prototype.getStr = function() {
      return this._str;
    }, n;
  }(), ND = "none", gut = Math.round;
  function vut(n) {
    var t = n.fill;
    return t != null && t !== ND;
  }
  function mut(n) {
    var t = n.stroke;
    return t != null && t !== ND;
  }
  var yA = [
    "lineCap",
    "miterLimit",
    "lineJoin"
  ], yut = ht(yA, function(n) {
    return "stroke-" + n.toLowerCase();
  });
  function xut(n, t, e, r) {
    var i = t.opacity == null ? 1 : t.opacity;
    if (e instanceof br) {
      n("opacity", i);
      return;
    }
    if (vut(t)) {
      var a = Lg(t.fill);
      n("fill", a.color);
      var s = t.fillOpacity != null ? t.fillOpacity * a.opacity * i : a.opacity * i;
      s < 1 && n("fill-opacity", s);
    } else n("fill", ND);
    if (mut(t)) {
      var o = Lg(t.stroke);
      n("stroke", o.color);
      var l = t.strokeNoScale ? e.getLineScale() : 1, u = l ? (t.lineWidth || 0) / l : 0, c = t.strokeOpacity != null ? t.strokeOpacity * o.opacity * i : o.opacity * i, h = t.strokeFirst;
      if (u !== 1 && n("stroke-width", u), h && n("paint-order", h ? "stroke" : "fill"), c < 1 && n("stroke-opacity", c), t.lineDash) {
        var f = bD(e), d = f[0], p = f[1];
        d && (p = gut(p || 0), n("stroke-dasharray", d.join(",")), (p || r) && n("stroke-dashoffset", p));
      }
      for (var g = 0; g < yA.length; g++) {
        var v = yA[g];
        if (t[v] !== Ux[v]) {
          var m = t[v] || Ux[v];
          m && n(yut[g], m);
        }
      }
    }
  }
  var l6 = "http://www.w3.org/2000/svg", u6 = "http://www.w3.org/1999/xlink", but = "http://www.w3.org/2000/xmlns/", _ut = "http://www.w3.org/XML/1998/namespace", K$ = "ecmeta_";
  function c6(n) {
    return document.createElementNS(l6, n);
  }
  function ar(n, t, e, r, i) {
    return {
      tag: n,
      attrs: e || {},
      children: r,
      text: i,
      key: t
    };
  }
  function wut(n, t) {
    var e = [];
    if (t) for (var r in t) {
      var i = t[r], a = r;
      i !== false && (i !== true && i != null && (a += '="' + i + '"'), e.push(a));
    }
    return "<" + n + " " + e.join(" ") + ">";
  }
  function Sut(n) {
    return "</" + n + ">";
  }
  function LD(n, t) {
    t = t || {};
    var e = t.newline ? `
` : "";
    function r(i) {
      var a = i.children, s = i.tag, o = i.attrs, l = i.text;
      return wut(s, o) + (s !== "style" ? oi(l) : l || "") + (a ? "" + e + ht(a, function(u) {
        return r(u);
      }).join(e) + e : "") + Sut(s);
    }
    return r(n);
  }
  function Cut(n, t, e) {
    e = e || {};
    var r = e.newline ? `
` : "", i = " {" + r, a = r + "}", s = ht(ge(n), function(l) {
      return l + i + ht(ge(n[l]), function(u) {
        return u + ":" + n[l][u] + ";";
      }).join(r) + a;
    }).join(r), o = ht(ge(t), function(l) {
      return "@keyframes " + l + i + ht(ge(t[l]), function(u) {
        return u + i + ht(ge(t[l][u]), function(c) {
          var h = t[l][u][c];
          return c === "d" && (h = 'path("' + h + '")'), c + ":" + h + ";";
        }).join(r) + a;
      }).join(r) + a;
    }).join(r);
    return !s && !o ? "" : [
      "<![CDATA[",
      s,
      o,
      "]]>"
    ].join(r);
  }
  function xA(n) {
    return {
      zrId: n,
      shadowCache: {},
      patternCache: {},
      gradientCache: {},
      clipPathCache: {},
      defs: {},
      cssNodes: {},
      cssAnims: {},
      cssStyleCache: {},
      cssAnimIdx: 0,
      shadowIdx: 0,
      gradientIdx: 0,
      patternIdx: 0,
      clipPathIdx: 0
    };
  }
  function Z$(n, t, e, r) {
    return ar("svg", "root", {
      width: n,
      height: t,
      xmlns: l6,
      "xmlns:xlink": u6,
      version: "1.1",
      baseProfile: "full",
      viewBox: r ? "0 0 " + n + " " + t : false
    }, e);
  }
  var Tut = 0;
  function h6() {
    return Tut++;
  }
  var J$ = {
    cubicIn: "0.32,0,0.67,0",
    cubicOut: "0.33,1,0.68,1",
    cubicInOut: "0.65,0,0.35,1",
    quadraticIn: "0.11,0,0.5,0",
    quadraticOut: "0.5,1,0.89,1",
    quadraticInOut: "0.45,0,0.55,1",
    quarticIn: "0.5,0,0.75,0",
    quarticOut: "0.25,1,0.5,1",
    quarticInOut: "0.76,0,0.24,1",
    quinticIn: "0.64,0,0.78,0",
    quinticOut: "0.22,1,0.36,1",
    quinticInOut: "0.83,0,0.17,1",
    sinusoidalIn: "0.12,0,0.39,0",
    sinusoidalOut: "0.61,1,0.88,1",
    sinusoidalInOut: "0.37,0,0.63,1",
    exponentialIn: "0.7,0,0.84,0",
    exponentialOut: "0.16,1,0.3,1",
    exponentialInOut: "0.87,0,0.13,1",
    circularIn: "0.55,0,1,0.45",
    circularOut: "0,0.55,0.45,1",
    circularInOut: "0.85,0,0.15,1"
  }, Ju = "transform-origin";
  function Iut(n, t, e) {
    var r = rt({}, n.shape);
    rt(r, t), n.buildPath(e, r);
    var i = new o6();
    return i.reset(XW(n)), e.rebuildPath(i, 1), i.generateStr(), i.getStr();
  }
  function Aut(n, t) {
    var e = t.originX, r = t.originY;
    (e || r) && (n[Ju] = e + "px " + r + "px");
  }
  var kut = {
    fill: "fill",
    opacity: "opacity",
    lineWidth: "stroke-width",
    lineDashOffset: "stroke-dashoffset"
  };
  function f6(n, t) {
    var e = t.zrId + "-ani-" + t.cssAnimIdx++;
    return t.cssAnims[e] = n, e;
  }
  function Dut(n, t, e) {
    var r = n.shape.paths, i = {}, a, s;
    if (P(r, function(l) {
      var u = xA(e.zrId);
      u.animation = true, Y1(l, {}, u, true);
      var c = u.cssAnims, h = u.cssNodes, f = ge(c), d = f.length;
      if (d) {
        s = f[d - 1];
        var p = c[s];
        for (var g in p) {
          var v = p[g];
          i[g] = i[g] || {
            d: ""
          }, i[g].d += v.d || "";
        }
        for (var m in h) {
          var y = h[m].animation;
          y.indexOf(s) >= 0 && (a = y);
        }
      }
    }), !!a) {
      t.d = false;
      var o = f6(i, e);
      return a.replace(s, o);
    }
  }
  function Q$(n) {
    return wt(n) ? J$[n] ? "cubic-bezier(" + J$[n] + ")" : Bk(n) ? n : "" : "";
  }
  function Y1(n, t, e, r) {
    var i = n.animators, a = i.length, s = [];
    if (n instanceof tD) {
      var o = Dut(n, t, e);
      if (o) s.push(o);
      else if (!a) return;
    } else if (!a) return;
    for (var l = {}, u = 0; u < a; u++) {
      var c = i[u], h = [
        c.getMaxTime() / 1e3 + "s"
      ], f = Q$(c.getClip().easing), d = c.getDelay();
      f ? h.push(f) : h.push("linear"), d && h.push(d / 1e3 + "s"), c.getLoop() && h.push("infinite");
      var p = h.join(" ");
      l[p] = l[p] || [
        p,
        []
      ], l[p][1].push(c);
    }
    function g(y) {
      var x = y[1], b = x.length, _ = {}, w = {}, S = {}, I = "animation-timing-function";
      function T(it, et, ft) {
        for (var ut = it.getTracks(), gt = it.getMaxTime(), kt = 0; kt < ut.length; kt++) {
          var At = ut[kt];
          if (At.needsAnimate()) {
            var mt = At.keyframes, _t = At.propName;
            if (ft && (_t = ft(_t)), _t) for (var ee = 0; ee < mt.length; ee++) {
              var G = mt[ee], H = Math.round(G.time / gt * 100) + "%", dt = Q$(G.easing), Mt = G.rawValue;
              (wt(Mt) || _e(Mt)) && (et[H] = et[H] || {}, et[H][_t] = G.rawValue, dt && (et[H][I] = dt));
            }
          }
        }
      }
      for (var A = 0; A < b; A++) {
        var C = x[A], D = C.targetName;
        D ? D === "shape" && T(C, w) : !r && T(C, _);
      }
      for (var E in _) {
        var M = {};
        ZW(M, n), rt(M, _[E]);
        var L = YW(M), k = _[E][I];
        S[E] = L ? {
          transform: L
        } : {}, Aut(S[E], M), k && (S[E][I] = k);
      }
      var N, R = true;
      for (var E in w) {
        S[E] = S[E] || {};
        var $ = !N, k = w[E][I];
        $ && (N = new ro());
        var O = N.len();
        N.reset(), S[E].d = Iut(n, w[E], N);
        var F = N.len();
        if (!$ && O !== F) {
          R = false;
          break;
        }
        k && (S[E][I] = k);
      }
      if (!R) for (var E in S) delete S[E].d;
      if (!r) for (var A = 0; A < b; A++) {
        var C = x[A], D = C.targetName;
        D === "style" && T(C, S, function(ut) {
          return kut[ut];
        });
      }
      for (var z = ge(S), V = true, U, A = 1; A < z.length; A++) {
        var X = z[A - 1], at = z[A];
        if (S[X][Ju] !== S[at][Ju]) {
          V = false;
          break;
        }
        U = S[X][Ju];
      }
      if (V && U) {
        for (var E in S) S[E][Ju] && delete S[E][Ju];
        t[Ju] = U;
      }
      if (Le(z, function(it) {
        return ge(S[it]).length > 0;
      }).length) {
        var pt = f6(S, e);
        return pt + " " + y[0] + " both";
      }
    }
    for (var v in l) {
      var o = g(l[v]);
      o && s.push(o);
    }
    if (s.length) {
      var m = e.zrId + "-cls-" + h6();
      e.cssNodes["." + m] = {
        animation: s.join(",")
      }, t.class = m;
    }
  }
  function Eut(n, t, e) {
    if (!n.ignore) if (n.isSilent()) {
      var r = {
        "pointer-events": "none"
      };
      tO(r, t, e);
    } else {
      var i = n.states.emphasis && n.states.emphasis.style ? n.states.emphasis.style : {}, a = i.fill;
      if (!a) {
        var s = n.style && n.style.fill, o = n.states.select && n.states.select.style && n.states.select.style.fill, l = n.currentStates.indexOf("select") >= 0 && o || s;
        l && (a = MI(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && n.transform ? n.transform[0] : 1;
        u = u / c;
      }
      var r = {
        cursor: "pointer"
      };
      a && (r.fill = a), i.stroke && (r.stroke = i.stroke), u && (r["stroke-width"] = u), tO(r, t, e);
    }
  }
  function tO(n, t, e, r) {
    var i = JSON.stringify(n), a = e.cssStyleCache[i];
    a || (a = e.zrId + "-cls-" + h6(), e.cssStyleCache[i] = a, e.cssNodes["." + a + ":hover"] = n), t.class = t.class ? t.class + " " + a : a;
  }
  var Yg = Math.round;
  function d6(n) {
    return n && wt(n.src);
  }
  function p6(n) {
    return n && Nt(n.toDataURL);
  }
  function PD(n, t, e, r) {
    xut(function(i, a) {
      var s = i === "fill" || i === "stroke";
      s && HW(a) ? v6(t, n, i, r) : s && zk(a) ? m6(e, n, i, r) : n[i] = a, s && r.ssr && a === "none" && (n["pointer-events"] = "visible");
    }, t, e, false), Out(e, n, r);
  }
  function $D(n, t) {
    var e = Int(t);
    e && (e.each(function(r, i) {
      r != null && (n[(K$ + i).toLowerCase()] = r + "");
    }), t.isSilent() && (n[K$ + "silent"] = "true"));
  }
  function eO(n) {
    return kl(n[0] - 1) && kl(n[1]) && kl(n[2]) && kl(n[3] - 1);
  }
  function Mut(n) {
    return kl(n[4]) && kl(n[5]);
  }
  function OD(n, t, e) {
    if (t && !(Mut(t) && eO(t))) {
      var r = 1e4;
      n.transform = eO(t) ? "translate(" + Yg(t[4] * r) / r + " " + Yg(t[5] * r) / r + ")" : qet(t);
    }
  }
  function nO(n, t, e) {
    for (var r = n.points, i = [], a = 0; a < r.length; a++) i.push(Yg(r[a][0] * e) / e), i.push(Yg(r[a][1] * e) / e);
    t.points = i.join(" ");
  }
  function rO(n) {
    return !n.smooth;
  }
  function Rut(n) {
    var t = ht(n, function(e) {
      return typeof e == "string" ? [
        e,
        e
      ] : e;
    });
    return function(e, r, i) {
      for (var a = 0; a < t.length; a++) {
        var s = t[a], o = e[s[0]];
        o != null && (r[s[1]] = Yg(o * i) / i);
      }
    };
  }
  var Nut = {
    circle: [
      Rut([
        "cx",
        "cy",
        "r"
      ])
    ],
    polyline: [
      nO,
      rO
    ],
    polygon: [
      nO,
      rO
    ]
  };
  function Lut(n) {
    for (var t = n.animators, e = 0; e < t.length; e++) if (t[e].targetName === "shape") return true;
    return false;
  }
  function g6(n, t) {
    var e = n.style, r = n.shape, i = Nut[n.type], a = {}, s = t.animation, o = "path", l = n.style.strokePercent, u = t.compress && XW(n) || 4;
    if (i && !t.willUpdate && !(i[1] && !i[1](r)) && !(s && Lut(n)) && !(l < 1)) {
      o = n.type;
      var c = Math.pow(10, u);
      i[0](r, a, c);
    } else {
      var h = !n.path || n.shapeChanged();
      n.path || n.createPathProxy();
      var f = n.path;
      h && (f.beginPath(), n.buildPath(f, n.shape), n.pathUpdated());
      var d = f.getVersion(), p = n, g = p.__svgPathBuilder;
      (p.__svgPathVersion !== d || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new o6()), g.reset(u), f.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = d, p.__svgPathStrokePercent = l), a.d = g.getStr();
    }
    return OD(a, n.transform), PD(a, e, n, t), $D(a, n), t.animation && Y1(n, a, t), t.emphasis && Eut(n, a, t), ar(o, n.id + "", a);
  }
  function Put(n, t) {
    var e = n.style, r = e.image;
    if (r && !wt(r) && (d6(r) ? r = r.src : p6(r) && (r = r.toDataURL())), !!r) {
      var i = e.x || 0, a = e.y || 0, s = e.width, o = e.height, l = {
        href: r,
        width: s,
        height: o
      };
      return i && (l.x = i), a && (l.y = a), OD(l, n.transform), PD(l, e, n, t), $D(l, n), t.animation && Y1(n, l, t), ar("image", n.id + "", l);
    }
  }
  function $ut(n, t) {
    var e = n.style, r = e.text;
    if (r != null && (r += ""), !(!r || isNaN(e.x) || isNaN(e.y))) {
      var i = e.font || Hl, a = e.x || 0, s = Ket(e.y || 0, x1(i), e.textBaseline), o = jet[e.textAlign] || e.textAlign, l = {
        "dominant-baseline": "central",
        "text-anchor": o
      };
      if (SU(e)) {
        var u = "", c = e.fontStyle, h = wU(e.fontSize);
        if (!parseFloat(h)) return;
        var f = e.fontFamily || _W, d = e.fontWeight;
        u += "font-size:" + h + ";font-family:" + f + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), d && d !== "normal" && (u += "font-weight:" + d + ";"), l.style = u;
      } else l.style = "font: " + i;
      return r.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), s && (l.y = s), OD(l, n.transform), PD(l, e, n, t), $D(l, n), t.animation && Y1(n, l, t), ar("text", n.id + "", l, void 0, r);
    }
  }
  function iO(n, t) {
    if (n instanceof le) return g6(n, t);
    if (n instanceof br) return Put(n, t);
    if (n instanceof Vf) return $ut(n, t);
  }
  function Out(n, t, e) {
    var r = n.style;
    if (Zet(r)) {
      var i = Jet(n), a = e.shadowCache, s = a[i];
      if (!s) {
        var o = n.getGlobalScale(), l = o[0], u = o[1];
        if (!l || !u) return;
        var c = r.shadowOffsetX || 0, h = r.shadowOffsetY || 0, f = r.shadowBlur, d = Lg(r.shadowColor), p = d.opacity, g = d.color, v = f / 2 / l, m = f / 2 / u, y = v + " " + m;
        s = e.zrId + "-s" + e.shadowIdx++, e.defs[s] = ar("filter", s, {
          id: s,
          x: "-100%",
          y: "-100%",
          width: "300%",
          height: "300%"
        }, [
          ar("feDropShadow", "", {
            dx: c / l,
            dy: h / u,
            stdDeviation: y,
            "flood-color": g,
            "flood-opacity": p
          })
        ]), a[i] = s;
      }
      t.filter = y1(s);
    }
  }
  function v6(n, t, e, r) {
    var i = n[e], a, s = {
      gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
    };
    if (WW(i)) a = "linearGradient", s.x1 = i.x, s.y1 = i.y, s.x2 = i.x2, s.y2 = i.y2;
    else if (UW(i)) a = "radialGradient", s.cx = Ht(i.x, 0.5), s.cy = Ht(i.y, 0.5), s.r = Ht(i.r, 0.5);
    else return;
    for (var o = i.colorStops, l = [], u = 0, c = o.length; u < c; ++u) {
      var h = RI(o[u].offset) * 100 + "%", f = o[u].color, d = Lg(f), p = d.color, g = d.opacity, v = {
        offset: h
      };
      v["stop-color"] = p, g < 1 && (v["stop-opacity"] = g), l.push(ar("stop", u + "", v));
    }
    var m = ar(a, "", s, l), y = LD(m), x = r.gradientCache, b = x[y];
    b || (b = r.zrId + "-g" + r.gradientIdx++, x[y] = b, s.id = b, r.defs[b] = ar(a, b, s, l)), t[e] = y1(b);
  }
  function m6(n, t, e, r) {
    var i = n.style[e], a = n.getBoundingRect(), s = {}, o = i.repeat, l = o === "no-repeat", u = o === "repeat-x", c = o === "repeat-y", h;
    if (GW(i)) {
      var f = i.imageWidth, d = i.imageHeight, p = void 0, g = i.image;
      if (wt(g) ? p = g : d6(g) ? p = g.src : p6(g) && (p = g.toDataURL()), typeof Image > "u") {
        var v = "Image width/height must been given explictly in svg-ssr renderer.";
        gi(f, v), gi(d, v);
      } else if (f == null || d == null) {
        var m = function(A, C) {
          if (A) {
            var D = A.elm, E = f || C.width, M = d || C.height;
            A.tag === "pattern" && (u ? (M = 1, E /= a.width) : c && (E = 1, M /= a.height)), A.attrs.width = E, A.attrs.height = M, D && (D.setAttribute("width", E), D.setAttribute("height", M));
          }
        }, y = Xk(p, null, n, function(A) {
          l || m(w, A), m(h, A);
        });
        y && y.width && y.height && (f = f || y.width, d = d || y.height);
      }
      h = ar("image", "img", {
        href: p,
        width: f,
        height: d
      }), s.width = f, s.height = d;
    } else i.svgElement && (h = Bt(i.svgElement), s.width = i.svgWidth, s.height = i.svgHeight);
    if (h) {
      var x, b;
      l ? x = b = 1 : u ? (b = 1, x = s.width / a.width) : c ? (x = 1, b = s.height / a.height) : s.patternUnits = "userSpaceOnUse", x != null && !isNaN(x) && (s.width = x), b != null && !isNaN(b) && (s.height = b);
      var _ = YW(i);
      _ && (s.patternTransform = _);
      var w = ar("pattern", "", s, [
        h
      ]), S = LD(w), I = r.patternCache, T = I[S];
      T || (T = r.zrId + "-p" + r.patternIdx++, I[S] = T, s.id = T, w = r.defs[T] = ar("pattern", T, s, [
        h
      ])), t[e] = y1(T);
    }
  }
  function Fut(n, t, e) {
    var r = e.clipPathCache, i = e.defs, a = r[n.id];
    if (!a) {
      a = e.zrId + "-c" + e.clipPathIdx++;
      var s = {
        id: a
      };
      r[n.id] = a, i[a] = ar("clipPath", a, s, [
        g6(n, e)
      ]);
    }
    t["clip-path"] = y1(a);
  }
  function aO(n) {
    return document.createTextNode(n);
  }
  function cc(n, t, e) {
    n.insertBefore(t, e);
  }
  function sO(n, t) {
    n.removeChild(t);
  }
  function oO(n, t) {
    n.appendChild(t);
  }
  function y6(n) {
    return n.parentNode;
  }
  function x6(n) {
    return n.nextSibling;
  }
  function QS(n, t) {
    n.textContent = t;
  }
  var lO = 58, But = 120, zut = ar("", "");
  function bA(n) {
    return n === void 0;
  }
  function Ms(n) {
    return n !== void 0;
  }
  function Vut(n, t, e) {
    for (var r = {}, i = t; i <= e; ++i) {
      var a = n[i].key;
      a !== void 0 && (r[a] = i);
    }
    return r;
  }
  function Up(n, t) {
    var e = n.key === t.key, r = n.tag === t.tag;
    return r && e;
  }
  function qg(n) {
    var t, e = n.children, r = n.tag;
    if (Ms(r)) {
      var i = n.elm = c6(r);
      if (FD(zut, n), ct(e)) for (t = 0; t < e.length; ++t) {
        var a = e[t];
        a != null && oO(i, qg(a));
      }
      else Ms(n.text) && !Ft(n.text) && oO(i, aO(n.text));
    } else n.elm = aO(n.text);
    return n.elm;
  }
  function b6(n, t, e, r, i) {
    for (; r <= i; ++r) {
      var a = e[r];
      a != null && cc(n, qg(a), t);
    }
  }
  function ub(n, t, e, r) {
    for (; e <= r; ++e) {
      var i = t[e];
      if (i != null) if (Ms(i.tag)) {
        var a = y6(i.elm);
        sO(a, i.elm);
      } else sO(n, i.elm);
    }
  }
  function FD(n, t) {
    var e, r = t.elm, i = n && n.attrs || {}, a = t.attrs || {};
    if (i !== a) {
      for (e in a) {
        var s = a[e], o = i[e];
        o !== s && (s === true ? r.setAttribute(e, "") : s === false ? r.removeAttribute(e) : e === "style" ? r.style.cssText = s : e.charCodeAt(0) !== But ? r.setAttribute(e, s) : e === "xmlns:xlink" || e === "xmlns" ? r.setAttributeNS(but, e, s) : e.charCodeAt(3) === lO ? r.setAttributeNS(_ut, e, s) : e.charCodeAt(5) === lO ? r.setAttributeNS(u6, e, s) : r.setAttribute(e, s));
      }
      for (e in i) e in a || r.removeAttribute(e);
    }
  }
  function Gut(n, t, e) {
    for (var r = 0, i = 0, a = t.length - 1, s = t[0], o = t[a], l = e.length - 1, u = e[0], c = e[l], h, f, d, p; r <= a && i <= l; ) s == null ? s = t[++r] : o == null ? o = t[--a] : u == null ? u = e[++i] : c == null ? c = e[--l] : Up(s, u) ? (hf(s, u), s = t[++r], u = e[++i]) : Up(o, c) ? (hf(o, c), o = t[--a], c = e[--l]) : Up(s, c) ? (hf(s, c), cc(n, s.elm, x6(o.elm)), s = t[++r], c = e[--l]) : Up(o, u) ? (hf(o, u), cc(n, o.elm, s.elm), o = t[--a], u = e[++i]) : (bA(h) && (h = Vut(t, r, a)), f = h[u.key], bA(f) ? cc(n, qg(u), s.elm) : (d = t[f], d.tag !== u.tag ? cc(n, qg(u), s.elm) : (hf(d, u), t[f] = void 0, cc(n, d.elm, s.elm))), u = e[++i]);
    (r <= a || i <= l) && (r > a ? (p = e[l + 1] == null ? null : e[l + 1].elm, b6(n, p, e, i, l)) : ub(n, t, r, a));
  }
  function hf(n, t) {
    var e = t.elm = n.elm, r = n.children, i = t.children;
    n !== t && (FD(n, t), bA(t.text) ? Ms(r) && Ms(i) ? r !== i && Gut(e, r, i) : Ms(i) ? (Ms(n.text) && QS(e, ""), b6(e, null, i, 0, i.length - 1)) : Ms(r) ? ub(e, r, 0, r.length - 1) : Ms(n.text) && QS(e, "") : n.text !== t.text && (Ms(r) && ub(e, r, 0, r.length - 1), QS(e, t.text)));
  }
  function Wut(n, t) {
    if (Up(n, t)) hf(n, t);
    else {
      var e = n.elm, r = y6(e);
      qg(t), r !== null && (cc(r, t.elm, x6(e)), ub(r, [
        n
      ], 0, 0));
    }
    return t;
  }
  var Uut = 0, Hut = function() {
    function n(t, e, r) {
      if (this.type = "svg", this.refreshHover = uO(), this.configLayer = uO(), this.storage = e, this._opts = r = rt({}, r), this.root = t, this._id = "zr" + Uut++, this._oldVNode = Z$(r.width, r.height), t && !r.ssr) {
        var i = this._viewport = document.createElement("div");
        i.style.cssText = "position:relative;overflow:hidden";
        var a = this._svgDom = this._oldVNode.elm = c6("svg");
        FD(null, this._oldVNode), i.appendChild(a), t.appendChild(i);
      }
      this.resize(r.width, r.height);
    }
    return n.prototype.getType = function() {
      return this.type;
    }, n.prototype.getViewportRoot = function() {
      return this._viewport;
    }, n.prototype.getViewportRootOffset = function() {
      var t = this.getViewportRoot();
      if (t) return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
    }, n.prototype.getSvgDom = function() {
      return this._svgDom;
    }, n.prototype.refresh = function() {
      if (this.root) {
        var t = this.renderToVNode({
          willUpdate: true
        });
        t.attrs.style = "position:absolute;left:0;top:0;user-select:none", Wut(this._oldVNode, t), this._oldVNode = t;
      }
    }, n.prototype.renderOneToVNode = function(t) {
      return iO(t, xA(this._id));
    }, n.prototype.renderToVNode = function(t) {
      t = t || {};
      var e = this.storage.getDisplayList(true), r = this._width, i = this._height, a = xA(this._id);
      a.animation = t.animation, a.willUpdate = t.willUpdate, a.compress = t.compress, a.emphasis = t.emphasis, a.ssr = this._opts.ssr;
      var s = [], o = this._bgVNode = Xut(r, i, this._backgroundColor, a);
      o && s.push(o);
      var l = t.compress ? null : this._mainVNode = ar("g", "main", {}, []);
      this._paintList(e, a, l ? l.children : s), l && s.push(l);
      var u = ht(ge(a.defs), function(f) {
        return a.defs[f];
      });
      if (u.length && s.push(ar("defs", "defs", {}, u)), t.animation) {
        var c = Cut(a.cssNodes, a.cssAnims, {
          newline: true
        });
        if (c) {
          var h = ar("style", "stl", {}, [], c);
          s.push(h);
        }
      }
      return Z$(r, i, s, t.useViewBox);
    }, n.prototype.renderToString = function(t) {
      return t = t || {}, LD(this.renderToVNode({
        animation: Ht(t.cssAnimation, true),
        emphasis: Ht(t.cssEmphasis, true),
        willUpdate: false,
        compress: true,
        useViewBox: Ht(t.useViewBox, true)
      }), {
        newline: true
      });
    }, n.prototype.setBackgroundColor = function(t) {
      this._backgroundColor = t;
    }, n.prototype.getSvgRoot = function() {
      return this._mainVNode && this._mainVNode.elm;
    }, n.prototype._paintList = function(t, e, r) {
      for (var i = t.length, a = [], s = 0, o, l, u = 0, c = 0; c < i; c++) {
        var h = t[c];
        if (!h.invisible) {
          var f = h.__clipPaths, d = f && f.length || 0, p = l && l.length || 0, g = void 0;
          for (g = Math.max(d - 1, p - 1); g >= 0 && !(f && l && f[g] === l[g]); g--) ;
          for (var v = p - 1; v > g; v--) s--, o = a[s - 1];
          for (var m = g + 1; m < d; m++) {
            var y = {};
            Fut(f[m], y, e);
            var x = ar("g", "clip-g-" + u++, y, []);
            (o ? o.children : r).push(x), a[s++] = x, o = x;
          }
          l = f;
          var b = iO(h, e);
          b && (o ? o.children : r).push(b);
        }
      }
    }, n.prototype.resize = function(t, e) {
      var r = this._opts, i = this.root, a = this._viewport;
      if (t != null && (r.width = t), e != null && (r.height = e), i && a && (a.style.display = "none", t = Cf(i, 0, r), e = Cf(i, 1, r), a.style.display = ""), this._width !== t || this._height !== e) {
        if (this._width = t, this._height = e, a) {
          var s = a.style;
          s.width = t + "px", s.height = e + "px";
        }
        if (zk(this._backgroundColor)) this.refresh();
        else {
          var o = this._svgDom;
          o && (o.setAttribute("width", t), o.setAttribute("height", e));
          var l = this._bgVNode && this._bgVNode.elm;
          l && (l.setAttribute("width", t), l.setAttribute("height", e));
        }
      }
    }, n.prototype.getWidth = function() {
      return this._width;
    }, n.prototype.getHeight = function() {
      return this._height;
    }, n.prototype.dispose = function() {
      this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
    }, n.prototype.clear = function() {
      this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
    }, n.prototype.toDataURL = function(t) {
      var e = this.renderToString(), r = "data:image/svg+xml;";
      return t ? (e = tnt(e), e && r + "base64," + e) : r + "charset=UTF-8," + encodeURIComponent(e);
    }, n;
  }();
  function uO(n) {
    return function() {
    };
  }
  function Xut(n, t, e, r) {
    var i;
    if (e && e !== "none") if (i = ar("rect", "bg", {
      width: n,
      height: t,
      x: "0",
      y: "0"
    }), HW(e)) v6({
      fill: e
    }, i.attrs, "fill", r);
    else if (zk(e)) m6({
      style: {
        fill: e
      },
      dirty: Dn,
      getBoundingRect: function() {
        return {
          width: n,
          height: t
        };
      }
    }, i.attrs, "fill", r);
    else {
      var a = Lg(e), s = a.color, o = a.opacity;
      i.attrs.fill = s, o < 1 && (i.attrs["fill-opacity"] = o);
    }
    return i;
  }
  function Yut(n) {
    n.registerPainter("svg", Hut);
  }
  function cO(n, t, e) {
    var r = Xl.createCanvas(), i = t.getWidth(), a = t.getHeight(), s = r.style;
    return s && (s.position = "absolute", s.left = "0", s.top = "0", s.width = i + "px", s.height = a + "px", r.setAttribute("data-zr-dom-id", n)), r.width = i * e, r.height = a * e, r;
  }
  var tC = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this) || this;
      a.motionBlur = false, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = false, a.config = {}, a.incremental = false, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = true, a.__firstTimePaint = true, a.__used = false, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
      var s;
      i = i || Gx, typeof e == "string" ? s = cO(e, r, i) : Ft(e) && (s = e, e = s.id), a.id = e, a.dom = s;
      var o = s.style;
      return o && (AW(s), s.onselectstart = function() {
        return false;
      }, o.padding = "0", o.margin = "0", o.borderWidth = "0"), a.painter = r, a.dpr = i, a;
    }
    return t.prototype.getElementCount = function() {
      return this.__endIndex - this.__startIndex;
    }, t.prototype.afterBrush = function() {
      this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
    }, t.prototype.initContext = function() {
      this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
    }, t.prototype.setUnpainted = function() {
      this.__firstTimePaint = true;
    }, t.prototype.createBackBuffer = function() {
      var e = this.dpr;
      this.domBack = cO("back-" + this.id, this.painter, e), this.ctxBack = this.domBack.getContext("2d"), e !== 1 && this.ctxBack.scale(e, e);
    }, t.prototype.createRepaintRects = function(e, r, i, a) {
      if (this.__firstTimePaint) return this.__firstTimePaint = false, null;
      var s = [], o = this.maxRepaintRectCount, l = false, u = new te(0, 0, 0, 0);
      function c(y) {
        if (!(!y.isFinite() || y.isZero())) if (s.length === 0) {
          var x = new te(0, 0, 0, 0);
          x.copy(y), s.push(x);
        } else {
          for (var b = false, _ = 1 / 0, w = 0, S = 0; S < s.length; ++S) {
            var I = s[S];
            if (I.intersect(y)) {
              var T = new te(0, 0, 0, 0);
              T.copy(I), T.union(y), s[S] = T, b = true;
              break;
            } else if (l) {
              u.copy(y), u.union(I);
              var A = y.width * y.height, C = I.width * I.height, D = u.width * u.height, E = D - A - C;
              E < _ && (_ = E, w = S);
            }
          }
          if (l && (s[w].union(y), b = true), !b) {
            var x = new te(0, 0, 0, 0);
            x.copy(y), s.push(x);
          }
          l || (l = s.length >= o);
        }
      }
      for (var h = this.__startIndex; h < this.__endIndex; ++h) {
        var f = e[h];
        if (f) {
          var d = f.shouldBePainted(i, a, true, true), p = f.__isRendered && (f.__dirty & Us || !d) ? f.getPrevPaintRect() : null;
          p && c(p);
          var g = d && (f.__dirty & Us || !f.__isRendered) ? f.getPaintRect() : null;
          g && c(g);
        }
      }
      for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
        var f = r[h], d = f && f.shouldBePainted(i, a, true, true);
        if (f && (!d || !f.__zr) && f.__isRendered) {
          var p = f.getPrevPaintRect();
          p && c(p);
        }
      }
      var v;
      do {
        v = false;
        for (var h = 0; h < s.length; ) {
          if (s[h].isZero()) {
            s.splice(h, 1);
            continue;
          }
          for (var m = h + 1; m < s.length; ) s[h].intersect(s[m]) ? (v = true, s[h].union(s[m]), s.splice(m, 1)) : m++;
          h++;
        }
      } while (v);
      return this._paintRects = s, s;
    }, t.prototype.debugGetPaintRects = function() {
      return (this._paintRects || []).slice();
    }, t.prototype.resize = function(e, r) {
      var i = this.dpr, a = this.dom, s = a.style, o = this.domBack;
      s && (s.width = e + "px", s.height = r + "px"), a.width = e * i, a.height = r * i, o && (o.width = e * i, o.height = r * i, i !== 1 && this.ctxBack.scale(i, i));
    }, t.prototype.clear = function(e, r, i) {
      var a = this.dom, s = this.ctx, o = a.width, l = a.height;
      r = r || this.clearColor;
      var u = this.motionBlur && !e, c = this.lastFrameAlpha, h = this.dpr, f = this;
      u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, o / h, l / h));
      var d = this.domBack;
      function p(g, v, m, y) {
        if (s.clearRect(g, v, m, y), r && r !== "transparent") {
          var x = void 0;
          if (g1(r)) {
            var b = r.global || r.__width === m && r.__height === y;
            x = b && r.__canvasGradient || cA(s, r, {
              x: 0,
              y: 0,
              width: m,
              height: y
            }), r.__canvasGradient = x, r.__width = m, r.__height = y;
          } else aet(r) && (r.scaleX = r.scaleX || h, r.scaleY = r.scaleY || h, x = hA(s, r, {
            dirty: function() {
              f.setUnpainted(), f.painter.refresh();
            }
          }));
          s.save(), s.fillStyle = x || r, s.fillRect(g, v, m, y), s.restore();
        }
        u && (s.save(), s.globalAlpha = c, s.drawImage(d, g, v, m, y), s.restore());
      }
      !i || u ? p(0, 0, o, l) : i.length && P(i, function(g) {
        p(g.x * h, g.y * h, g.width * h, g.height * h);
      });
    }, t;
  }(Da), hO = 1e5, Uu = 314159, Qy = 0.01, qut = 1e-3;
  function jut(n) {
    return n ? n.__builtin__ ? true : !(typeof n.resize != "function" || typeof n.refresh != "function") : false;
  }
  function Kut(n, t) {
    var e = document.createElement("div");
    return e.style.cssText = [
      "position:relative",
      "width:" + n + "px",
      "height:" + t + "px",
      "padding:0",
      "margin:0",
      "border-width:0"
    ].join(";") + ";", e;
  }
  var Zut = function() {
    function n(t, e, r, i) {
      this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = false, this.type = "canvas";
      var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
      this._opts = r = rt({}, r || {}), this.dpr = r.devicePixelRatio || Gx, this._singleCanvas = a, this.root = t;
      var s = t.style;
      s && (AW(t), t.innerHTML = ""), this.storage = e;
      var o = this._zlevelList;
      this._prevDisplayList = [];
      var l = this._layers;
      if (a) {
        var c = t, h = c.width, f = c.height;
        r.width != null && (h = r.width), r.height != null && (f = r.height), this.dpr = r.devicePixelRatio || 1, c.width = h * this.dpr, c.height = f * this.dpr, this._width = h, this._height = f;
        var d = new tC(c, this, this.dpr);
        d.__builtin__ = true, d.initContext(), l[Uu] = d, d.zlevel = Uu, o.push(Uu), this._domRoot = t;
      } else {
        this._width = Cf(t, 0, r), this._height = Cf(t, 1, r);
        var u = this._domRoot = Kut(this._width, this._height);
        t.appendChild(u);
      }
    }
    return n.prototype.getType = function() {
      return "canvas";
    }, n.prototype.isSingleCanvas = function() {
      return this._singleCanvas;
    }, n.prototype.getViewportRoot = function() {
      return this._domRoot;
    }, n.prototype.getViewportRootOffset = function() {
      var t = this.getViewportRoot();
      if (t) return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
    }, n.prototype.refresh = function(t) {
      var e = this.storage.getDisplayList(true), r = this._prevDisplayList, i = this._zlevelList;
      this._redrawId = Math.random(), this._paintList(e, r, t, this._redrawId);
      for (var a = 0; a < i.length; a++) {
        var s = i[a], o = this._layers[s];
        if (!o.__builtin__ && o.refresh) {
          var l = a === 0 ? this._backgroundColor : null;
          o.refresh(l);
        }
      }
      return this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this;
    }, n.prototype.refreshHover = function() {
      this._paintHoverList(this.storage.getDisplayList(false));
    }, n.prototype._paintHoverList = function(t) {
      var e = t.length, r = this._hoverlayer;
      if (r && r.clear(), !!e) {
        for (var i = {
          inHover: true,
          viewWidth: this._width,
          viewHeight: this._height
        }, a, s = 0; s < e; s++) {
          var o = t[s];
          o.__inHover && (r || (r = this._hoverlayer = this.getLayer(hO)), a || (a = r.ctx, a.save()), wc(a, o, i, s === e - 1));
        }
        a && a.restore();
      }
    }, n.prototype.getHoverLayer = function() {
      return this.getLayer(hO);
    }, n.prototype.paintOne = function(t, e) {
      iH(t, e);
    }, n.prototype._paintList = function(t, e, r, i) {
      if (this._redrawId === i) {
        r = r || false, this._updateLayerStatus(t);
        var a = this._doPaintList(t, e, r), s = a.finished, o = a.needsRefreshHover;
        if (this._needsManuallyCompositing && this._compositeManually(), o && this._paintHoverList(t), s) this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
        else {
          var l = this;
          Ox(function() {
            l._paintList(t, e, r, i);
          });
        }
      }
    }, n.prototype._compositeManually = function() {
      var t = this.getLayer(Uu).ctx, e = this._domRoot.width, r = this._domRoot.height;
      t.clearRect(0, 0, e, r), this.eachBuiltinLayer(function(i) {
        i.virtual && t.drawImage(i.dom, 0, 0, e, r);
      });
    }, n.prototype._doPaintList = function(t, e, r) {
      for (var i = this, a = [], s = this._opts.useDirtyRect, o = 0; o < this._zlevelList.length; o++) {
        var l = this._zlevelList[o], u = this._layers[l];
        u.__builtin__ && u !== this._hoverlayer && (u.__dirty || r) && a.push(u);
      }
      for (var c = true, h = false, f = function(g) {
        var v = a[g], m = v.ctx, y = s && v.createRepaintRects(t, e, d._width, d._height), x = r ? v.__startIndex : v.__drawIndex, b = !r && v.incremental && Date.now, _ = b && Date.now(), w = v.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
        if (v.__startIndex === v.__endIndex) v.clear(false, w, y);
        else if (x === v.__startIndex) {
          var S = t[x];
          (!S.incremental || !S.notClear || r) && v.clear(false, w, y);
        }
        x === -1 && (console.error("For some unknown reason. drawIndex is -1"), x = v.__startIndex);
        var I, T = function(E) {
          var M = {
            inHover: false,
            allClipped: false,
            prevEl: null,
            viewWidth: i._width,
            viewHeight: i._height
          };
          for (I = x; I < v.__endIndex; I++) {
            var L = t[I];
            if (L.__inHover && (h = true), i._doPaintEl(L, v, s, E, M, I === v.__endIndex - 1), b) {
              var k = Date.now() - _;
              if (k > 15) break;
            }
          }
          M.prevElClipPaths && m.restore();
        };
        if (y) if (y.length === 0) I = v.__endIndex;
        else for (var A = d.dpr, C = 0; C < y.length; ++C) {
          var D = y[C];
          m.save(), m.beginPath(), m.rect(D.x * A, D.y * A, D.width * A, D.height * A), m.clip(), T(D), m.restore();
        }
        else m.save(), T(), m.restore();
        v.__drawIndex = I, v.__drawIndex < v.__endIndex && (c = false);
      }, d = this, p = 0; p < a.length; p++) f(p);
      return ce.wxa && P(this._layers, function(g) {
        g && g.ctx && g.ctx.draw && g.ctx.draw();
      }), {
        finished: c,
        needsRefreshHover: h
      };
    }, n.prototype._doPaintEl = function(t, e, r, i, a, s) {
      var o = e.ctx;
      if (r) {
        var l = t.getPaintRect();
        (!i || l && l.intersect(i)) && (wc(o, t, a, s), t.setPrevPaintRect(l));
      } else wc(o, t, a, s);
    }, n.prototype.getLayer = function(t, e) {
      this._singleCanvas && !this._needsManuallyCompositing && (t = Uu);
      var r = this._layers[t];
      return r || (r = new tC("zr_" + t, this, this.dpr), r.zlevel = t, r.__builtin__ = true, this._layerConfig[t] ? Zt(r, this._layerConfig[t], true) : this._layerConfig[t - Qy] && Zt(r, this._layerConfig[t - Qy], true), e && (r.virtual = e), this.insertLayer(t, r), r.initContext()), r;
    }, n.prototype.insertLayer = function(t, e) {
      var r = this._layers, i = this._zlevelList, a = i.length, s = this._domRoot, o = null, l = -1;
      if (!r[t] && jut(e)) {
        if (a > 0 && t > i[0]) {
          for (l = 0; l < a - 1 && !(i[l] < t && i[l + 1] > t); l++) ;
          o = r[i[l]];
        }
        if (i.splice(l + 1, 0, t), r[t] = e, !e.virtual) if (o) {
          var u = o.dom;
          u.nextSibling ? s.insertBefore(e.dom, u.nextSibling) : s.appendChild(e.dom);
        } else s.firstChild ? s.insertBefore(e.dom, s.firstChild) : s.appendChild(e.dom);
        e.painter || (e.painter = this);
      }
    }, n.prototype.eachLayer = function(t, e) {
      for (var r = this._zlevelList, i = 0; i < r.length; i++) {
        var a = r[i];
        t.call(e, this._layers[a], a);
      }
    }, n.prototype.eachBuiltinLayer = function(t, e) {
      for (var r = this._zlevelList, i = 0; i < r.length; i++) {
        var a = r[i], s = this._layers[a];
        s.__builtin__ && t.call(e, s, a);
      }
    }, n.prototype.eachOtherLayer = function(t, e) {
      for (var r = this._zlevelList, i = 0; i < r.length; i++) {
        var a = r[i], s = this._layers[a];
        s.__builtin__ || t.call(e, s, a);
      }
    }, n.prototype.getLayers = function() {
      return this._layers;
    }, n.prototype._updateLayerStatus = function(t) {
      this.eachBuiltinLayer(function(h, f) {
        h.__dirty = h.__used = false;
      });
      function e(h) {
        a && (a.__endIndex !== h && (a.__dirty = true), a.__endIndex = h);
      }
      if (this._singleCanvas) for (var r = 1; r < t.length; r++) {
        var i = t[r];
        if (i.zlevel !== t[r - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
      var a = null, s = 0, o, l;
      for (l = 0; l < t.length; l++) {
        var i = t[l], u = i.zlevel, c = void 0;
        o !== u && (o = u, s = 0), i.incremental ? (c = this.getLayer(u + qut, this._needsManuallyCompositing), c.incremental = true, s = 1) : c = this.getLayer(u + (s > 0 ? Qy : 0), this._needsManuallyCompositing), c.__builtin__ || Rk("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = true, c.__startIndex !== l && (c.__dirty = true), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, e(l), a = c), i.__dirty & Us && !i.__inHover && (c.__dirty = true, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
      }
      e(l), this.eachBuiltinLayer(function(h, f) {
        !h.__used && h.getElementCount() > 0 && (h.__dirty = true, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
      });
    }, n.prototype.clear = function() {
      return this.eachBuiltinLayer(this._clearLayer), this;
    }, n.prototype._clearLayer = function(t) {
      t.clear();
    }, n.prototype.setBackgroundColor = function(t) {
      this._backgroundColor = t, P(this._layers, function(e) {
        e.setUnpainted();
      });
    }, n.prototype.configLayer = function(t, e) {
      if (e) {
        var r = this._layerConfig;
        r[t] ? Zt(r[t], e, true) : r[t] = e;
        for (var i = 0; i < this._zlevelList.length; i++) {
          var a = this._zlevelList[i];
          if (a === t || a === t + Qy) {
            var s = this._layers[a];
            Zt(s, r[t], true);
          }
        }
      }
    }, n.prototype.delLayer = function(t) {
      var e = this._layers, r = this._zlevelList, i = e[t];
      i && (i.dom.parentNode.removeChild(i.dom), delete e[t], r.splice(ne(r, t), 1));
    }, n.prototype.resize = function(t, e) {
      if (this._domRoot.style) {
        var r = this._domRoot;
        r.style.display = "none";
        var i = this._opts, a = this.root;
        if (t != null && (i.width = t), e != null && (i.height = e), t = Cf(a, 0, i), e = Cf(a, 1, i), r.style.display = "", this._width !== t || e !== this._height) {
          r.style.width = t + "px", r.style.height = e + "px";
          for (var s in this._layers) this._layers.hasOwnProperty(s) && this._layers[s].resize(t, e);
          this.refresh(true);
        }
        this._width = t, this._height = e;
      } else {
        if (t == null || e == null) return;
        this._width = t, this._height = e, this.getLayer(Uu).resize(t, e);
      }
      return this;
    }, n.prototype.clearLayer = function(t) {
      var e = this._layers[t];
      e && e.clear();
    }, n.prototype.dispose = function() {
      this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
    }, n.prototype.getRenderedCanvas = function(t) {
      if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[Uu].dom;
      var e = new tC("image", this, t.pixelRatio || this.dpr);
      e.initContext(), e.clear(false, t.backgroundColor || this._backgroundColor);
      var r = e.ctx;
      if (t.pixelRatio <= this.dpr) {
        this.refresh();
        var i = e.dom.width, a = e.dom.height;
        this.eachLayer(function(h) {
          h.__builtin__ ? r.drawImage(h.dom, 0, 0, i, a) : h.renderToCanvas && (r.save(), h.renderToCanvas(r), r.restore());
        });
      } else for (var s = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      }, o = this.storage.getDisplayList(true), l = 0, u = o.length; l < u; l++) {
        var c = o[l];
        wc(r, c, s, l === u - 1);
      }
      return e.dom;
    }, n.prototype.getWidth = function() {
      return this._width;
    }, n.prototype.getHeight = function() {
      return this._height;
    }, n;
  }();
  function Jut(n) {
    n.registerPainter("canvas", Zut);
  }
  var Qut = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = true, e;
    }
    return t.prototype.getInitialData = function(e) {
      return el(null, this, {
        useEncodeDefaulter: true
      });
    }, t.prototype.getLegendIcon = function(e) {
      var r = new Vt(), i = Fn("line", 0, e.itemHeight / 2, e.itemWidth, 0, e.lineStyle.stroke, false);
      r.add(i), i.setStyle(e.lineStyle);
      var a = this.getData().getVisual("symbol"), s = this.getData().getVisual("symbolRotate"), o = a === "none" ? "circle" : a, l = e.itemHeight * 0.8, u = Fn(o, (e.itemWidth - l) / 2, (e.itemHeight - l) / 2, l, l, e.itemStyle.fill);
      r.add(u), u.setStyle(e.itemStyle);
      var c = e.iconRotate === "inherit" ? s : e.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([
        e.itemWidth / 2,
        e.itemHeight / 2
      ]), o.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), r;
    }, t.type = "series.line", t.dependencies = [
      "grid",
      "polar"
    ], t.defaultOption = {
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      clip: true,
      label: {
        position: "top"
      },
      endLabel: {
        show: false,
        valueAnimation: true,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: true
      },
      step: false,
      smooth: false,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: true,
      showAllSymbol: "auto",
      connectNulls: false,
      sampling: "none",
      animationEasing: "linear",
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: false
    }, t;
  }(an);
  function Xf(n, t) {
    var e = n.mapDimensionsAll("defaultedLabel"), r = e.length;
    if (r === 1) {
      var i = Wf(n, t, e[0]);
      return i != null ? i + "" : null;
    } else if (r) {
      for (var a = [], s = 0; s < e.length; s++) a.push(Wf(n, t, e[s]));
      return a.join(" ");
    }
  }
  function _6(n, t) {
    var e = n.mapDimensionsAll("defaultedLabel");
    if (!ct(t)) return t + "";
    for (var r = [], i = 0; i < e.length; i++) {
      var a = n.getDimensionIndex(e[i]);
      a >= 0 && r.push(t[a]);
    }
    return r.join(" ");
  }
  var Wv = function(n) {
    q(t, n);
    function t(e, r, i, a) {
      var s = n.call(this) || this;
      return s.updateData(e, r, i, a), s;
    }
    return t.prototype._createSymbol = function(e, r, i, a, s) {
      this.removeAll();
      var o = Fn(e, -1, -1, 2, 2, null, s);
      o.attr({
        z2: 100,
        culling: true,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), o.drift = tct, this._symbolType = e, this.add(o);
    }, t.prototype.stopSymbolAnimation = function(e) {
      this.childAt(0).stopAnimation(null, e);
    }, t.prototype.getSymbolType = function() {
      return this._symbolType;
    }, t.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, t.prototype.highlight = function() {
      Vo(this.childAt(0));
    }, t.prototype.downplay = function() {
      Go(this.childAt(0));
    }, t.prototype.setZ = function(e, r) {
      var i = this.childAt(0);
      i.zlevel = e, i.z = r;
    }, t.prototype.setDraggable = function(e, r) {
      var i = this.childAt(0);
      i.draggable = e, i.cursor = !r && e ? "move" : i.cursor;
    }, t.prototype.updateData = function(e, r, i, a) {
      this.silent = false;
      var s = e.getItemVisual(r, "symbol") || "circle", o = e.hostModel, l = t.getSymbolSize(e, r), u = s !== this._symbolType, c = a && a.disableAnimation;
      if (u) {
        var h = e.getItemVisual(r, "symbolKeepAspect");
        this._createSymbol(s, e, r, l, h);
      } else {
        var f = this.childAt(0);
        f.silent = false;
        var d = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? f.attr(d) : Ie(f, d, o, r), os(f);
      }
      if (this._updateCommon(e, r, l, i, a), u) {
        var f = this.childAt(0);
        if (!c) {
          var d = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              opacity: f.style.opacity
            }
          };
          f.scaleX = f.scaleY = 0, f.style.opacity = 0, dn(f, d, o, r);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, t.prototype._updateCommon = function(e, r, i, a, s) {
      var o = this.childAt(0), l = e.hostModel, u, c, h, f, d, p, g, v, m;
      if (a && (u = a.emphasisItemStyle, c = a.blurItemStyle, h = a.selectItemStyle, f = a.focus, d = a.blurScope, g = a.labelStatesModels, v = a.hoverScale, m = a.cursorStyle, p = a.emphasisDisabled), !a || e.hasItemOption) {
        var y = a && a.itemModel ? a.itemModel : e.getItemModel(r), x = y.getModel("emphasis");
        u = x.getModel("itemStyle").getItemStyle(), h = y.getModel([
          "select",
          "itemStyle"
        ]).getItemStyle(), c = y.getModel([
          "blur",
          "itemStyle"
        ]).getItemStyle(), f = x.get("focus"), d = x.get("blurScope"), p = x.get("disabled"), g = ur(y), v = x.getShallow("scale"), m = y.getShallow("cursor");
      }
      var b = e.getItemVisual(r, "symbolRotate");
      o.attr("rotation", (b || 0) * Math.PI / 180 || 0);
      var _ = gh(e.getItemVisual(r, "symbolOffset"), i);
      _ && (o.x = _[0], o.y = _[1]), m && o.attr("cursor", m);
      var w = e.getItemVisual(r, "style"), S = w.fill;
      if (o instanceof br) {
        var I = o.style;
        o.useStyle(rt({
          image: I.image,
          x: I.x,
          y: I.y,
          width: I.width,
          height: I.height
        }, w));
      } else o.__isEmptyBrush ? o.useStyle(rt({}, w)) : o.useStyle(w), o.style.decal = null, o.setColor(S, s && s.symbolInnerColor), o.style.strokeNoScale = true;
      var T = e.getItemVisual(r, "liftZ"), A = this._z2;
      T != null ? A == null && (this._z2 = o.z2, o.z2 += T) : A != null && (o.z2 = A, this._z2 = null);
      var C = s && s.useNameLabel;
      kr(o, g, {
        labelFetcher: l,
        labelDataIndex: r,
        defaultText: D,
        inheritColor: S,
        defaultOpacity: w.opacity
      });
      function D(L) {
        return C ? e.getName(L) : Xf(e, L);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var E = o.ensureState("emphasis");
      E.style = u, o.ensureState("select").style = h, o.ensureState("blur").style = c;
      var M = v == null || v === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(v) && v > 0 ? +v : 1;
      E.scaleX = this._sizeX * M, E.scaleY = this._sizeY * M, this.setSymbolScale(1), bn(this, f, d, p);
    }, t.prototype.setSymbolScale = function(e) {
      this.scaleX = this.scaleY = e;
    }, t.prototype.fadeOut = function(e, r, i) {
      var a = this.childAt(0), s = Ut(this).dataIndex, o = i && i.animation;
      if (this.silent = a.silent = true, i && i.fadeLabel) {
        var l = a.getTextContent();
        l && ql(l, {
          style: {
            opacity: 0
          }
        }, r, {
          dataIndex: s,
          removeOpt: o,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else a.removeTextContent();
      ql(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, r, {
        dataIndex: s,
        cb: e,
        removeOpt: o
      });
    }, t.getSymbolSize = function(e, r) {
      return Dd(e.getItemVisual(r, "symbolSize"));
    }, t;
  }(Vt);
  function tct(n, t) {
    this.parent.drift(n, t);
  }
  function eC(n, t, e, r) {
    return t && !isNaN(t[0]) && !isNaN(t[1]) && !(r.isIgnore && r.isIgnore(e)) && !(r.clipShape && !r.clipShape.contain(t[0], t[1])) && n.getItemVisual(e, "symbol") !== "none";
  }
  function fO(n) {
    return n != null && !Ft(n) && (n = {
      isIgnore: n
    }), n || {};
  }
  function dO(n) {
    var t = n.hostModel, e = t.getModel("emphasis");
    return {
      emphasisItemStyle: e.getModel("itemStyle").getItemStyle(),
      blurItemStyle: t.getModel([
        "blur",
        "itemStyle"
      ]).getItemStyle(),
      selectItemStyle: t.getModel([
        "select",
        "itemStyle"
      ]).getItemStyle(),
      focus: e.get("focus"),
      blurScope: e.get("blurScope"),
      emphasisDisabled: e.get("disabled"),
      hoverScale: e.get("scale"),
      labelStatesModels: ur(t),
      cursorStyle: t.get("cursor")
    };
  }
  var Uv = function() {
    function n(t) {
      this.group = new Vt(), this._SymbolCtor = t || Wv;
    }
    return n.prototype.updateData = function(t, e) {
      this._progressiveEls = null, e = fO(e);
      var r = this.group, i = t.hostModel, a = this._data, s = this._SymbolCtor, o = e.disableAnimation, l = dO(t), u = {
        disableAnimation: o
      }, c = e.getSymbolPoint || function(h) {
        return t.getItemLayout(h);
      };
      a || r.removeAll(), t.diff(a).add(function(h) {
        var f = c(h);
        if (eC(t, f, h, e)) {
          var d = new s(t, h, l, u);
          d.setPosition(f), t.setItemGraphicEl(h, d), r.add(d);
        }
      }).update(function(h, f) {
        var d = a.getItemGraphicEl(f), p = c(h);
        if (!eC(t, p, h, e)) {
          r.remove(d);
          return;
        }
        var g = t.getItemVisual(h, "symbol") || "circle", v = d && d.getSymbolType && d.getSymbolType();
        if (!d || v && v !== g) r.remove(d), d = new s(t, h, l, u), d.setPosition(p);
        else {
          d.updateData(t, h, l, u);
          var m = {
            x: p[0],
            y: p[1]
          };
          o ? d.attr(m) : Ie(d, m, i);
        }
        r.add(d), t.setItemGraphicEl(h, d);
      }).remove(function(h) {
        var f = a.getItemGraphicEl(h);
        f && f.fadeOut(function() {
          r.remove(f);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = t;
    }, n.prototype.updateLayout = function() {
      var t = this, e = this._data;
      e && e.eachItemGraphicEl(function(r, i) {
        var a = t._getSymbolPoint(i);
        r.setPosition(a), r.markRedraw();
      });
    }, n.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = dO(t), this._data = null, this.group.removeAll();
    }, n.prototype.incrementalUpdate = function(t, e, r) {
      this._progressiveEls = [], r = fO(r);
      function i(l) {
        l.isGroup || (l.incremental = true, l.ensureState("emphasis").hoverLayer = true);
      }
      for (var a = t.start; a < t.end; a++) {
        var s = e.getItemLayout(a);
        if (eC(e, s, a, r)) {
          var o = new this._SymbolCtor(e, a, this._seriesScope);
          o.traverse(i), o.setPosition(s), this.group.add(o), e.setItemGraphicEl(a, o), this._progressiveEls.push(o);
        }
      }
    }, n.prototype.eachRendered = function(t) {
      su(this._progressiveEls || this.group, t);
    }, n.prototype.remove = function(t) {
      var e = this.group, r = this._data;
      r && t ? r.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          e.remove(i);
        }, r.hostModel);
      }) : e.removeAll();
    }, n;
  }();
  function w6(n, t, e) {
    var r = n.getBaseAxis(), i = n.getOtherAxis(r), a = ect(i, e), s = r.dim, o = i.dim, l = t.mapDimension(o), u = t.mapDimension(s), c = o === "x" || o === "radius" ? 1 : 0, h = ht(n.dimensions, function(p) {
      return t.mapDimension(p);
    }), f = false, d = t.getCalculationInfo("stackResultDimension");
    return Kl(t, h[0]) && (f = true, h[0] = d), Kl(t, h[1]) && (f = true, h[1] = d), {
      dataDimsForPoint: h,
      valueStart: a,
      valueAxisDim: o,
      baseAxisDim: s,
      stacked: !!f,
      valueDim: l,
      baseDim: u,
      baseDataOffset: c,
      stackedOverDimension: t.getCalculationInfo("stackedOverDimension")
    };
  }
  function ect(n, t) {
    var e = 0, r = n.scale.getExtent();
    return t === "start" ? e = r[0] : t === "end" ? e = r[1] : _e(t) && !isNaN(t) ? e = t : r[0] > 0 ? e = r[0] : r[1] < 0 && (e = r[1]), e;
  }
  function S6(n, t, e, r) {
    var i = NaN;
    n.stacked && (i = e.get(e.getCalculationInfo("stackedOverDimension"), r)), isNaN(i) && (i = n.valueStart);
    var a = n.baseDataOffset, s = [];
    return s[a] = e.get(n.baseDim, r), s[1 - a] = i, t.dataToPoint(s);
  }
  function nct(n, t) {
    var e = [];
    return t.diff(n).add(function(r) {
      e.push({
        cmd: "+",
        idx: r
      });
    }).update(function(r, i) {
      e.push({
        cmd: "=",
        idx: i,
        idx1: r
      });
    }).remove(function(r) {
      e.push({
        cmd: "-",
        idx: r
      });
    }).execute(), e;
  }
  function rct(n, t, e, r, i, a, s, o) {
    for (var l = nct(n, t), u = [], c = [], h = [], f = [], d = [], p = [], g = [], v = w6(i, t, s), m = n.getLayout("points") || [], y = t.getLayout("points") || [], x = 0; x < l.length; x++) {
      var b = l[x], _ = true, w = void 0, S = void 0;
      switch (b.cmd) {
        case "=":
          w = b.idx * 2, S = b.idx1 * 2;
          var I = m[w], T = m[w + 1], A = y[S], C = y[S + 1];
          (isNaN(I) || isNaN(T)) && (I = A, T = C), u.push(I, T), c.push(A, C), h.push(e[w], e[w + 1]), f.push(r[S], r[S + 1]), g.push(t.getRawIndex(b.idx1));
          break;
        case "+":
          var D = b.idx, E = v.dataDimsForPoint, M = i.dataToPoint([
            t.get(E[0], D),
            t.get(E[1], D)
          ]);
          S = D * 2, u.push(M[0], M[1]), c.push(y[S], y[S + 1]);
          var L = S6(v, i, t, D);
          h.push(L[0], L[1]), f.push(r[S], r[S + 1]), g.push(t.getRawIndex(D));
          break;
        case "-":
          _ = false;
      }
      _ && (d.push(b), p.push(p.length));
    }
    p.sort(function(X, at) {
      return g[X] - g[at];
    });
    for (var k = u.length, N = zs(k), R = zs(k), $ = zs(k), O = zs(k), F = [], x = 0; x < p.length; x++) {
      var z = p[x], V = x * 2, U = z * 2;
      N[V] = u[U], N[V + 1] = u[U + 1], R[V] = c[U], R[V + 1] = c[U + 1], $[V] = h[U], $[V + 1] = h[U + 1], O[V] = f[U], O[V + 1] = f[U + 1], F[x] = d[z];
    }
    return {
      current: N,
      next: R,
      stackedOnCurrent: $,
      stackedOnNext: O,
      status: F
    };
  }
  var fl = Math.min, dl = Math.max;
  function $c(n, t) {
    return isNaN(n) || isNaN(t);
  }
  function _A(n, t, e, r, i, a, s, o, l) {
    for (var u, c, h, f, d, p, g = e, v = 0; v < r; v++) {
      var m = t[g * 2], y = t[g * 2 + 1];
      if (g >= i || g < 0) break;
      if ($c(m, y)) {
        if (l) {
          g += a;
          continue;
        }
        break;
      }
      if (g === e) n[a > 0 ? "moveTo" : "lineTo"](m, y), h = m, f = y;
      else {
        var x = m - u, b = y - c;
        if (x * x + b * b < 0.5) {
          g += a;
          continue;
        }
        if (s > 0) {
          for (var _ = g + a, w = t[_ * 2], S = t[_ * 2 + 1]; w === m && S === y && v < r; ) v++, _ += a, g += a, w = t[_ * 2], S = t[_ * 2 + 1], m = t[g * 2], y = t[g * 2 + 1], x = m - u, b = y - c;
          var I = v + 1;
          if (l) for (; $c(w, S) && I < r; ) I++, _ += a, w = t[_ * 2], S = t[_ * 2 + 1];
          var T = 0.5, A = 0, C = 0, D = void 0, E = void 0;
          if (I >= r || $c(w, S)) d = m, p = y;
          else {
            A = w - u, C = S - c;
            var M = m - u, L = w - m, k = y - c, N = S - y, R = void 0, $ = void 0;
            if (o === "x") {
              R = Math.abs(M), $ = Math.abs(L);
              var O = A > 0 ? 1 : -1;
              d = m - O * R * s, p = y, D = m + O * $ * s, E = y;
            } else if (o === "y") {
              R = Math.abs(k), $ = Math.abs(N);
              var F = C > 0 ? 1 : -1;
              d = m, p = y - F * R * s, D = m, E = y + F * $ * s;
            } else R = Math.sqrt(M * M + k * k), $ = Math.sqrt(L * L + N * N), T = $ / ($ + R), d = m - A * s * (1 - T), p = y - C * s * (1 - T), D = m + A * s * T, E = y + C * s * T, D = fl(D, dl(w, m)), E = fl(E, dl(S, y)), D = dl(D, fl(w, m)), E = dl(E, fl(S, y)), A = D - m, C = E - y, d = m - A * R / $, p = y - C * R / $, d = fl(d, dl(u, m)), p = fl(p, dl(c, y)), d = dl(d, fl(u, m)), p = dl(p, fl(c, y)), A = m - d, C = y - p, D = m + A * $ / R, E = y + C * $ / R;
          }
          n.bezierCurveTo(h, f, d, p, m, y), h = D, f = E;
        } else n.lineTo(m, y);
      }
      u = m, c = y, g += a;
    }
    return v;
  }
  var C6 = /* @__PURE__ */ function() {
    function n() {
      this.smooth = 0, this.smoothConstraint = true;
    }
    return n;
  }(), ict = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "ec-polyline", r;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new C6();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.points, a = 0, s = i.length / 2;
      if (r.connectNulls) {
        for (; s > 0 && $c(i[s * 2 - 2], i[s * 2 - 1]); s--) ;
        for (; a < s && $c(i[a * 2], i[a * 2 + 1]); a++) ;
      }
      for (; a < s; ) a += _A(e, i, a, s, s, 1, r.smooth, r.smoothMonotone, r.connectNulls) + 1;
    }, t.prototype.getPointOn = function(e, r) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, a = i.data, s = ro.CMD, o, l, u = r === "x", c = [], h = 0; h < a.length; ) {
        var f = a[h++], d = void 0, p = void 0, g = void 0, v = void 0, m = void 0, y = void 0, x = void 0;
        switch (f) {
          case s.M:
            o = a[h++], l = a[h++];
            break;
          case s.L:
            if (d = a[h++], p = a[h++], x = u ? (e - o) / (d - o) : (e - l) / (p - l), x <= 1 && x >= 0) {
              var b = u ? (p - l) * x + l : (d - o) * x + o;
              return u ? [
                e,
                b
              ] : [
                b,
                e
              ];
            }
            o = d, l = p;
            break;
          case s.C:
            d = a[h++], p = a[h++], g = a[h++], v = a[h++], m = a[h++], y = a[h++];
            var _ = u ? Fx(o, d, g, m, e, c) : Fx(l, p, v, y, e, c);
            if (_ > 0) for (var w = 0; w < _; w++) {
              var S = c[w];
              if (S <= 1 && S >= 0) {
                var b = u ? tr(l, p, v, y, S) : tr(o, d, g, m, S);
                return u ? [
                  e,
                  b
                ] : [
                  b,
                  e
                ];
              }
            }
            o = m, l = y;
            break;
        }
      }
    }, t;
  }(le), act = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t;
  }(C6), T6 = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "ec-polygon", r;
    }
    return t.prototype.getDefaultShape = function() {
      return new act();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.points, a = r.stackedOnPoints, s = 0, o = i.length / 2, l = r.smoothMonotone;
      if (r.connectNulls) {
        for (; o > 0 && $c(i[o * 2 - 2], i[o * 2 - 1]); o--) ;
        for (; s < o && $c(i[s * 2], i[s * 2 + 1]); s++) ;
      }
      for (; s < o; ) {
        var u = _A(e, i, s, o, o, 1, r.smooth, l, r.connectNulls);
        _A(e, a, s + u - 1, u, o, -1, r.stackedOnSmooth, l, r.connectNulls), s += u + 1, e.closePath();
      }
    }, t;
  }(le);
  function I6(n, t, e, r, i) {
    var a = n.getArea(), s = a.x, o = a.y, l = a.width, u = a.height, c = e.get([
      "lineStyle",
      "width"
    ]) || 0;
    s -= c / 2, o -= c / 2, l += c, u += c, l = Math.ceil(l), s !== Math.floor(s) && (s = Math.floor(s), l++);
    var h = new ye({
      shape: {
        x: s,
        y: o,
        width: l,
        height: u
      }
    });
    if (t) {
      var f = n.getBaseAxis(), d = f.isHorizontal(), p = f.inverse;
      d ? (p && (h.shape.x += l), h.shape.width = 0) : (p || (h.shape.y += u), h.shape.height = 0);
      var g = Nt(i) ? function(v) {
        i(v, h);
      } : null;
      dn(h, {
        shape: {
          width: l,
          height: u,
          x: s,
          y: o
        }
      }, e, null, r, g);
    }
    return h;
  }
  function A6(n, t, e) {
    var r = n.getArea(), i = Cn(r.r0, 1), a = Cn(r.r, 1), s = new mi({
      shape: {
        cx: Cn(n.cx, 1),
        cy: Cn(n.cy, 1),
        r0: i,
        r: a,
        startAngle: r.startAngle,
        endAngle: r.endAngle,
        clockwise: r.clockwise
      }
    });
    if (t) {
      var o = n.getBaseAxis().dim === "angle";
      o ? s.shape.endAngle = r.startAngle : s.shape.r = i, dn(s, {
        shape: {
          endAngle: r.endAngle,
          r: a
        }
      }, e);
    }
    return s;
  }
  function Hv(n, t, e, r, i) {
    if (n) {
      if (n.type === "polar") return A6(n, t, e);
      if (n.type === "cartesian2d") return I6(n, t, e, r, i);
    } else return null;
    return null;
  }
  function mh(n, t) {
    return n.type === t;
  }
  function pO(n, t) {
    if (n.length === t.length) {
      for (var e = 0; e < n.length; e++) if (n[e] !== t[e]) return;
      return true;
    }
  }
  function gO(n) {
    for (var t = 1 / 0, e = 1 / 0, r = -1 / 0, i = -1 / 0, a = 0; a < n.length; ) {
      var s = n[a++], o = n[a++];
      isNaN(s) || (t = Math.min(s, t), r = Math.max(s, r)), isNaN(o) || (e = Math.min(o, e), i = Math.max(o, i));
    }
    return [
      [
        t,
        e
      ],
      [
        r,
        i
      ]
    ];
  }
  function vO(n, t) {
    var e = gO(n), r = e[0], i = e[1], a = gO(t), s = a[0], o = a[1];
    return Math.max(Math.abs(r[0] - s[0]), Math.abs(r[1] - s[1]), Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1]));
  }
  function mO(n) {
    return _e(n) ? n : n ? 0.5 : 0;
  }
  function sct(n, t, e) {
    if (!e.valueDim) return [];
    for (var r = t.count(), i = zs(r * 2), a = 0; a < r; a++) {
      var s = S6(e, n, t, a);
      i[a * 2] = s[0], i[a * 2 + 1] = s[1];
    }
    return i;
  }
  function pl(n, t, e, r, i) {
    var a = e.getBaseAxis(), s = a.dim === "x" || a.dim === "radius" ? 0 : 1, o = [], l = 0, u = [], c = [], h = [], f = [];
    if (i) {
      for (l = 0; l < n.length; l += 2) {
        var d = t || n;
        !isNaN(d[l]) && !isNaN(d[l + 1]) && f.push(n[l], n[l + 1]);
      }
      n = f;
    }
    for (l = 0; l < n.length - 2; l += 2) switch (h[0] = n[l + 2], h[1] = n[l + 3], c[0] = n[l], c[1] = n[l + 1], o.push(c[0], c[1]), r) {
      case "end":
        u[s] = h[s], u[1 - s] = c[1 - s], o.push(u[0], u[1]);
        break;
      case "middle":
        var p = (c[s] + h[s]) / 2, g = [];
        u[s] = g[s] = p, u[1 - s] = c[1 - s], g[1 - s] = h[1 - s], o.push(u[0], u[1]), o.push(g[0], g[1]);
        break;
      default:
        u[s] = c[s], u[1 - s] = h[1 - s], o.push(u[0], u[1]);
    }
    return o.push(n[l++], n[l++]), o;
  }
  function oct(n, t) {
    var e = [], r = n.length, i, a;
    function s(c, h, f) {
      var d = c.coord, p = (f - d) / (h.coord - d), g = Xet(p, [
        c.color,
        h.color
      ]);
      return {
        coord: f,
        color: g
      };
    }
    for (var o = 0; o < r; o++) {
      var l = n[o], u = l.coord;
      if (u < 0) i = l;
      else if (u > t) {
        a ? e.push(s(a, l, t)) : i && e.push(s(i, l, 0), s(i, l, t));
        break;
      } else i && (e.push(s(i, l, 0)), i = null), e.push(l), a = l;
    }
    return e;
  }
  function lct(n, t, e) {
    var r = n.getVisual("visualMeta");
    if (!(!r || !r.length || !n.count()) && t.type === "cartesian2d") {
      for (var i, a, s = r.length - 1; s >= 0; s--) {
        var o = n.getDimensionInfo(r[s].dimension);
        if (i = o && o.coordDim, i === "x" || i === "y") {
          a = r[s];
          break;
        }
      }
      if (a) {
        var l = t.getAxis(i), u = ht(a.stops, function(x) {
          return {
            coord: l.toGlobalCoord(l.dataToCoord(x.value)),
            color: x.color
          };
        }), c = u.length, h = a.outerColors.slice();
        c && u[0].coord > u[c - 1].coord && (u.reverse(), h.reverse());
        var f = oct(u, i === "x" ? e.getWidth() : e.getHeight()), d = f.length;
        if (!d && c) return u[0].coord < 0 ? h[1] ? h[1] : u[c - 1].color : h[0] ? h[0] : u[0].color;
        var p = 10, g = f[0].coord - p, v = f[d - 1].coord + p, m = v - g;
        if (m < 1e-3) return "transparent";
        P(f, function(x) {
          x.offset = (x.coord - g) / m;
        }), f.push({
          offset: d ? f[d - 1].offset : 0.5,
          color: h[1] || "transparent"
        }), f.unshift({
          offset: d ? f[0].offset : 0.5,
          color: h[0] || "transparent"
        });
        var y = new $v(0, 0, 0, 0, f, true);
        return y[i] = g, y[i + "2"] = v, y;
      }
    }
  }
  function uct(n, t, e) {
    var r = n.get("showAllSymbol"), i = r === "auto";
    if (!(r && !i)) {
      var a = e.getAxesByScale("ordinal")[0];
      if (a && !(i && cct(a, t))) {
        var s = t.mapDimension(a.dim), o = {};
        return P(a.getViewLabels(), function(l) {
          var u = a.scale.getRawOrdinalNumber(l.tickValue);
          o[u] = 1;
        }), function(l) {
          return !o.hasOwnProperty(t.get(s, l));
        };
      }
    }
  }
  function cct(n, t) {
    var e = n.getExtent(), r = Math.abs(e[1] - e[0]) / n.scale.count();
    isNaN(r) && (r = 0);
    for (var i = t.count(), a = Math.max(1, Math.round(i / 5)), s = 0; s < i; s += a) if (Wv.getSymbolSize(t, s)[n.isHorizontal() ? 1 : 0] * 1.5 > r) return false;
    return true;
  }
  function hct(n, t) {
    return isNaN(n) || isNaN(t);
  }
  function fct(n) {
    for (var t = n.length / 2; t > 0 && hct(n[t * 2 - 2], n[t * 2 - 1]); t--) ;
    return t - 1;
  }
  function yO(n, t) {
    return [
      n[t * 2],
      n[t * 2 + 1]
    ];
  }
  function dct(n, t, e) {
    for (var r = n.length / 2, i = e === "x" ? 0 : 1, a, s, o = 0, l = -1, u = 0; u < r; u++) if (s = n[u * 2 + i], !(isNaN(s) || isNaN(n[u * 2 + 1 - i]))) {
      if (u === 0) {
        a = s;
        continue;
      }
      if (a <= t && s >= t || a >= t && s <= t) {
        l = u;
        break;
      }
      o = u, a = s;
    }
    return {
      range: [
        o,
        l
      ],
      t: (t - a) / (s - a)
    };
  }
  function k6(n) {
    if (n.get([
      "endLabel",
      "show"
    ])) return true;
    for (var t = 0; t < vi.length; t++) if (n.get([
      vi[t],
      "endLabel",
      "show"
    ])) return true;
    return false;
  }
  function nC(n, t, e, r) {
    if (mh(t, "cartesian2d")) {
      var i = r.getModel("endLabel"), a = i.get("valueAnimation"), s = r.getData(), o = {
        lastFrameIndex: 0
      }, l = k6(r) ? function(d, p) {
        n._endLabelOnDuring(d, p, s, o, a, i, t);
      } : null, u = t.getBaseAxis().isHorizontal(), c = I6(t, e, r, function() {
        var d = n._endLabel;
        d && e && o.originalX != null && d.attr({
          x: o.originalX,
          y: o.originalY
        });
      }, l);
      if (!r.get("clip", true)) {
        var h = c.shape, f = Math.max(h.width, h.height);
        u ? (h.y -= f, h.height += f * 2) : (h.x -= f, h.width += f * 2);
      }
      return l && l(1, c), c;
    } else return A6(t, e, r);
  }
  function pct(n, t) {
    var e = t.getBaseAxis(), r = e.isHorizontal(), i = e.inverse, a = r ? i ? "right" : "left" : "center", s = r ? "middle" : i ? "top" : "bottom";
    return {
      normal: {
        align: n.get("align") || a,
        verticalAlign: n.get("verticalAlign") || s
      }
    };
  }
  var gct = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.init = function() {
      var e = new Vt(), r = new Uv();
      this.group.add(r.group), this._symbolDraw = r, this._lineGroup = e, this._changePolyState = St(this._changePolyState, this);
    }, t.prototype.render = function(e, r, i) {
      var a = e.coordinateSystem, s = this.group, o = e.getData(), l = e.getModel("lineStyle"), u = e.getModel("areaStyle"), c = o.getLayout("points") || [], h = a.type === "polar", f = this._coordSys, d = this._symbolDraw, p = this._polyline, g = this._polygon, v = this._lineGroup, m = !r.ssr && e.get("animation"), y = !u.isEmpty(), x = u.get("origin"), b = w6(a, o, x), _ = y && sct(a, o, b), w = e.get("showSymbol"), S = e.get("connectNulls"), I = w && !h && uct(e, o, a), T = this._data;
      T && T.eachItemGraphicEl(function(X, at) {
        X.__temp && (s.remove(X), T.setItemGraphicEl(at, null));
      }), w || d.remove(), s.add(v);
      var A = h ? false : e.get("step"), C;
      a && a.getArea && e.get("clip", true) && (C = a.getArea(), C.width != null ? (C.x -= 0.1, C.y -= 0.1, C.width += 0.2, C.height += 0.2) : C.r0 && (C.r0 -= 0.5, C.r += 0.5)), this._clipShapeForSymbol = C;
      var D = lct(o, a, i) || o.getVisual("style")[o.getVisual("drawType")];
      if (!(p && f.type === a.type && A === this._step)) w && d.updateData(o, {
        isIgnore: I,
        clipShape: C,
        disableAnimation: true,
        getSymbolPoint: function(X) {
          return [
            c[X * 2],
            c[X * 2 + 1]
          ];
        }
      }), m && this._initSymbolLabelAnimation(o, a, C), A && (_ && (_ = pl(_, c, a, A, S)), c = pl(c, null, a, A, S)), p = this._newPolyline(c), y ? g = this._newPolygon(c, _) : g && (v.remove(g), g = this._polygon = null), h || this._initOrUpdateEndLabel(e, a, Yc(D)), v.setClipPath(nC(this, a, true, e));
      else {
        y && !g ? g = this._newPolygon(c, _) : g && !y && (v.remove(g), g = this._polygon = null), h || this._initOrUpdateEndLabel(e, a, Yc(D));
        var E = v.getClipPath();
        if (E) {
          var M = nC(this, a, false, e);
          dn(E, {
            shape: M.shape
          }, e);
        } else v.setClipPath(nC(this, a, true, e));
        w && d.updateData(o, {
          isIgnore: I,
          clipShape: C,
          disableAnimation: true,
          getSymbolPoint: function(X) {
            return [
              c[X * 2],
              c[X * 2 + 1]
            ];
          }
        }), (!pO(this._stackedOnPoints, _) || !pO(this._points, c)) && (m ? this._doUpdateAnimation(o, _, a, i, A, x, S) : (A && (_ && (_ = pl(_, c, a, A, S)), c = pl(c, null, a, A, S)), p.setShape({
          points: c
        }), g && g.setShape({
          points: c,
          stackedOnPoints: _
        })));
      }
      var L = e.getModel("emphasis"), k = L.get("focus"), N = L.get("blurScope"), R = L.get("disabled");
      if (p.useStyle($t(l.getLineStyle(), {
        fill: "none",
        stroke: D,
        lineJoin: "bevel"
      })), Ar(p, e, "lineStyle"), p.style.lineWidth > 0 && e.get([
        "emphasis",
        "lineStyle",
        "width"
      ]) === "bolder") {
        var $ = p.getState("emphasis").style;
        $.lineWidth = +p.style.lineWidth + 1;
      }
      Ut(p).seriesIndex = e.seriesIndex, bn(p, k, N, R);
      var O = mO(e.get("smooth")), F = e.get("smoothMonotone");
      if (p.setShape({
        smooth: O,
        smoothMonotone: F,
        connectNulls: S
      }), g) {
        var z = o.getCalculationInfo("stackedOnSeries"), V = 0;
        g.useStyle($t(u.getAreaStyle(), {
          fill: D,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: o.getVisual("style").decal
        })), z && (V = mO(z.get("smooth"))), g.setShape({
          smooth: O,
          stackedOnSmooth: V,
          smoothMonotone: F,
          connectNulls: S
        }), Ar(g, e, "areaStyle"), Ut(g).seriesIndex = e.seriesIndex, bn(g, k, N, R);
      }
      var U = this._changePolyState;
      o.eachItemGraphicEl(function(X) {
        X && (X.onHoverStateChange = U);
      }), this._polyline.onHoverStateChange = U, this._data = o, this._coordSys = a, this._stackedOnPoints = _, this._points = c, this._step = A, this._valueOrigin = x, e.get("triggerLineEvent") && (this.packEventData(e, p), g && this.packEventData(e, g));
    }, t.prototype.packEventData = function(e, r) {
      Ut(r).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: e.componentIndex,
        seriesIndex: e.seriesIndex,
        seriesName: e.name,
        seriesType: "line"
      };
    }, t.prototype.highlight = function(e, r, i, a) {
      var s = e.getData(), o = Uc(s, a);
      if (this._changePolyState("emphasis"), !(o instanceof Array) && o != null && o >= 0) {
        var l = s.getLayout("points"), u = s.getItemGraphicEl(o);
        if (!u) {
          var c = l[o * 2], h = l[o * 2 + 1];
          if (isNaN(c) || isNaN(h) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, h)) return;
          var f = e.get("zlevel") || 0, d = e.get("z") || 0;
          u = new Wv(s, o), u.x = c, u.y = h, u.setZ(f, d);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = f, p.z = d, p.z2 = this._polyline.z2 + 1), u.__temp = true, s.setItemGraphicEl(o, u), u.stopSymbolAnimation(true), this.group.add(u);
        }
        u.highlight();
      } else qe.prototype.highlight.call(this, e, r, i, a);
    }, t.prototype.downplay = function(e, r, i, a) {
      var s = e.getData(), o = Uc(s, a);
      if (this._changePolyState("normal"), o != null && o >= 0) {
        var l = s.getItemGraphicEl(o);
        l && (l.__temp ? (s.setItemGraphicEl(o, null), this.group.remove(l)) : l.downplay());
      } else qe.prototype.downplay.call(this, e, r, i, a);
    }, t.prototype._changePolyState = function(e) {
      var r = this._polygon;
      Hx(this._polyline, e), r && Hx(r, e);
    }, t.prototype._newPolyline = function(e) {
      var r = this._polyline;
      return r && this._lineGroup.remove(r), r = new ict({
        shape: {
          points: e
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(r), this._polyline = r, r;
    }, t.prototype._newPolygon = function(e, r) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new T6({
        shape: {
          points: e,
          stackedOnPoints: r
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, t.prototype._initSymbolLabelAnimation = function(e, r, i) {
      var a, s, o = r.getBaseAxis(), l = o.inverse;
      r.type === "cartesian2d" ? (a = o.isHorizontal(), s = false) : r.type === "polar" && (a = o.dim === "angle", s = true);
      var u = e.hostModel, c = u.get("animationDuration");
      Nt(c) && (c = c(null));
      var h = u.get("animationDelay") || 0, f = Nt(h) ? h(null) : h;
      e.eachItemGraphicEl(function(d, p) {
        var g = d;
        if (g) {
          var v = [
            d.x,
            d.y
          ], m = void 0, y = void 0, x = void 0;
          if (i) if (s) {
            var b = i, _ = r.pointToCoord(v);
            a ? (m = b.startAngle, y = b.endAngle, x = -_[1] / 180 * Math.PI) : (m = b.r0, y = b.r, x = _[0]);
          } else {
            var w = i;
            a ? (m = w.x, y = w.x + w.width, x = d.x) : (m = w.y + w.height, y = w.y, x = d.y);
          }
          var S = y === m ? 0 : (x - m) / (y - m);
          l && (S = 1 - S);
          var I = Nt(h) ? h(p) : c * S + f, T = g.getSymbolPath(), A = T.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: true,
            delay: I
          }), A && A.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: I
          }), T.disableLabelAnimation = true;
        }
      });
    }, t.prototype._initOrUpdateEndLabel = function(e, r, i) {
      var a = e.getModel("endLabel");
      if (k6(e)) {
        var s = e.getData(), o = this._polyline, l = s.getLayout("points");
        if (!l) {
          o.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new be({
          z2: 200
        }), u.ignoreClip = true, o.setTextContent(this._endLabel), o.disableLabelAnimation = true);
        var c = fct(l);
        c >= 0 && (kr(o, ur(e, "endLabel"), {
          inheritColor: i,
          labelFetcher: e,
          labelDataIndex: c,
          defaultText: function(h, f, d) {
            return d != null ? _6(s, d) : Xf(s, h);
          },
          enableTextSetter: true
        }, pct(a, r)), o.textConfig.position = null);
      } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, t.prototype._endLabelOnDuring = function(e, r, i, a, s, o, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        e < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var h = i.getLayout("points"), f = i.hostModel, d = f.get("connectNulls"), p = o.get("precision"), g = o.get("distance") || 0, v = l.getBaseAxis(), m = v.isHorizontal(), y = v.inverse, x = r.shape, b = y ? m ? x.x : x.y + x.height : m ? x.x + x.width : x.y, _ = (m ? g : 0) * (y ? -1 : 1), w = (m ? 0 : -g) * (y ? -1 : 1), S = m ? "x" : "y", I = dct(h, b, S), T = I.range, A = T[1] - T[0], C = void 0;
        if (A >= 1) {
          if (A > 1 && !d) {
            var D = yO(h, T[0]);
            u.attr({
              x: D[0] + _,
              y: D[1] + w
            }), s && (C = f.getRawValue(T[0]));
          } else {
            var D = c.getPointOn(b, S);
            D && u.attr({
              x: D[0] + _,
              y: D[1] + w
            });
            var E = f.getRawValue(T[0]), M = f.getRawValue(T[1]);
            s && (C = fU(i, p, E, M, I.t));
          }
          a.lastFrameIndex = T[0];
        } else {
          var L = e === 1 || a.lastFrameIndex > 0 ? T[0] : 0, D = yO(h, L);
          s && (C = f.getRawValue(L)), u.attr({
            x: D[0] + _,
            y: D[1] + w
          });
        }
        if (s) {
          var k = wd(u);
          typeof k.setLabelText == "function" && k.setLabelText(C);
        }
      }
    }, t.prototype._doUpdateAnimation = function(e, r, i, a, s, o, l) {
      var u = this._polyline, c = this._polygon, h = e.hostModel, f = rct(this._data, e, this._stackedOnPoints, r, this._coordSys, i, this._valueOrigin), d = f.current, p = f.stackedOnCurrent, g = f.next, v = f.stackedOnNext;
      if (s && (p = pl(f.stackedOnCurrent, f.current, i, s, l), d = pl(f.current, null, i, s, l), v = pl(f.stackedOnNext, f.next, i, s, l), g = pl(f.next, null, i, s, l)), vO(d, g) > 3e3 || c && vO(p, v) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), c && (c.stopAnimation(), c.setShape({
          points: g,
          stackedOnPoints: v
        }));
        return;
      }
      u.shape.__points = f.current, u.shape.points = d;
      var m = {
        shape: {
          points: g
        }
      };
      f.current !== d && (m.shape.__points = f.next), u.stopAnimation(), Ie(u, m, h), c && (c.setShape({
        points: d,
        stackedOnPoints: p
      }), c.stopAnimation(), Ie(c, {
        shape: {
          stackedOnPoints: v
        }
      }, h), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], x = f.status, b = 0; b < x.length; b++) {
        var _ = x[b].cmd;
        if (_ === "=") {
          var w = e.getItemGraphicEl(x[b].idx1);
          w && y.push({
            el: w,
            ptIdx: b
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var S = u.shape.__points, I = 0; I < y.length; I++) {
          var T = y[I].el, A = y[I].ptIdx * 2;
          T.x = S[A], T.y = S[A + 1], T.markRedraw();
        }
      });
    }, t.prototype.remove = function(e) {
      var r = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(true), i && i.eachItemGraphicEl(function(a, s) {
        a.__temp && (r.remove(a), i.setItemGraphicEl(s, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, t.type = "line", t;
  }(qe);
  function Xv(n, t) {
    return {
      seriesType: n,
      plan: Ad(),
      reset: function(e) {
        var r = e.getData(), i = e.coordinateSystem, a = e.pipelineContext, s = t || a.large;
        if (i) {
          var o = ht(i.dimensions, function(d) {
            return r.mapDimension(d);
          }).slice(0, 2), l = o.length, u = r.getCalculationInfo("stackResultDimension");
          Kl(r, o[0]) && (o[0] = u), Kl(r, o[1]) && (o[1] = u);
          var c = r.getStore(), h = r.getDimensionIndex(o[0]), f = r.getDimensionIndex(o[1]);
          return l && {
            progress: function(d, p) {
              for (var g = d.end - d.start, v = s && zs(g * l), m = [], y = [], x = d.start, b = 0; x < d.end; x++) {
                var _ = void 0;
                if (l === 1) {
                  var w = c.get(h, x);
                  _ = i.dataToPoint(w, null, y);
                } else m[0] = c.get(h, x), m[1] = c.get(f, x), _ = i.dataToPoint(m, null, y);
                s ? (v[b++] = _[0], v[b++] = _[1]) : p.setItemLayout(x, _.slice());
              }
              s && p.setLayout("points", v);
            }
          };
        }
      }
    };
  }
  var vct = {
    average: function(n) {
      for (var t = 0, e = 0, r = 0; r < n.length; r++) isNaN(n[r]) || (t += n[r], e++);
      return e === 0 ? NaN : t / e;
    },
    sum: function(n) {
      for (var t = 0, e = 0; e < n.length; e++) t += n[e] || 0;
      return t;
    },
    max: function(n) {
      for (var t = -1 / 0, e = 0; e < n.length; e++) n[e] > t && (t = n[e]);
      return isFinite(t) ? t : NaN;
    },
    min: function(n) {
      for (var t = 1 / 0, e = 0; e < n.length; e++) n[e] < t && (t = n[e]);
      return isFinite(t) ? t : NaN;
    },
    nearest: function(n) {
      return n[0];
    }
  }, mct = function(n) {
    return Math.round(n.length / 2);
  };
  function D6(n) {
    return {
      seriesType: n,
      reset: function(t, e, r) {
        var i = t.getData(), a = t.get("sampling"), s = t.coordinateSystem, o = i.count();
        if (o > 10 && s.type === "cartesian2d" && a) {
          var l = s.getBaseAxis(), u = s.getOtherAxis(l), c = l.getExtent(), h = r.getDevicePixelRatio(), f = Math.abs(c[1] - c[0]) * (h || 1), d = Math.round(o / f);
          if (isFinite(d) && d > 1) {
            a === "lttb" ? t.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / d)) : a === "minmax" && t.setData(i.minmaxDownSample(i.mapDimension(u.dim), 1 / d));
            var p = void 0;
            wt(a) ? p = vct[a] : Nt(a) && (p = a), p && t.setData(i.downSample(i.mapDimension(u.dim), 1 / d, p, mct));
          }
        }
      }
    };
  }
  function yct(n) {
    n.registerChartView(gct), n.registerSeriesModel(Qut), n.registerLayout(Xv("line", true)), n.registerVisual({
      seriesType: "line",
      reset: function(t) {
        var e = t.getData(), r = t.getModel("lineStyle").getLineStyle();
        r && !r.stroke && (r.stroke = e.getVisual("style").fill), e.setVisual("legendLineStyle", r);
      }
    }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, D6("line"));
  }
  var jg = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, r) {
      return el(null, this, {
        useEncodeDefaulter: true
      });
    }, t.prototype.getMarkerPosition = function(e, r, i) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var s = a.clampData(e), o = a.dataToPoint(s);
        if (i) P(a.getAxes(), function(f, d) {
          if (f.type === "category" && r != null) {
            var p = f.getTicksCoords(), g = f.getTickModel().get("alignWithLabel"), v = s[d], m = r[d] === "x1" || r[d] === "y1";
            if (m && !g && (v += 1), p.length < 2) return;
            if (p.length === 2) {
              o[d] = f.toGlobalCoord(f.getExtent()[m ? 1 : 0]);
              return;
            }
            for (var y = void 0, x = void 0, b = 1, _ = 0; _ < p.length; _++) {
              var w = p[_].coord, S = _ === p.length - 1 ? p[_ - 1].tickValue + b : p[_].tickValue;
              if (S === v) {
                x = w;
                break;
              } else if (S < v) y = w;
              else if (y != null && S > v) {
                x = (w + y) / 2;
                break;
              }
              _ === 1 && (b = S - p[0].tickValue);
            }
            x == null && (y ? y && (x = p[p.length - 1].coord) : x = p[0].coord), o[d] = f.toGlobalCoord(x);
          }
        });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), h = a.getBaseAxis().isHorizontal() ? 0 : 1;
          o[h] += u + c / 2;
        }
        return o;
      }
      return [
        NaN,
        NaN
      ];
    }, t.type = "series.__base_bar__", t.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      barMinHeight: 0,
      barMinAngle: 0,
      large: false,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, t;
  }(an);
  an.registerClass(jg);
  var xct = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function() {
      return el(null, this, {
        useEncodeDefaulter: true,
        createInvertedIndices: !!this.get("realtimeSort", true) || null
      });
    }, t.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : false;
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.get("progressiveThreshold"), r = this.get("largeThreshold");
      return r > e && (e = r), e;
    }, t.prototype.brushSelector = function(e, r, i) {
      return i.rect(r.getItemLayout(e));
    }, t.type = "series.bar", t.dependencies = [
      "grid",
      "polar"
    ], t.defaultOption = ou(jg.defaultOption, {
      clip: true,
      roundCap: false,
      showBackground: false,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: false
    }), t;
  }(jg), bct = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
    }
    return n;
  }(), cb = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "sausage", r;
    }
    return t.prototype.getDefaultShape = function() {
      return new bct();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.cx, a = r.cy, s = Math.max(r.r0 || 0, 0), o = Math.max(r.r, 0), l = (o - s) * 0.5, u = s + l, c = r.startAngle, h = r.endAngle, f = r.clockwise, d = Math.PI * 2, p = f ? h - c < d : c - h < d;
      p || (c = h - (f ? d : -d));
      var g = Math.cos(c), v = Math.sin(c), m = Math.cos(h), y = Math.sin(h);
      p ? (e.moveTo(g * s + i, v * s + a), e.arc(g * u + i, v * u + a, l, -Math.PI + c, c, !f)) : e.moveTo(g * o + i, v * o + a), e.arc(i, a, o, c, h, !f), e.arc(m * u + i, y * u + a, l, h - Math.PI * 2, h - Math.PI, !f), s !== 0 && e.arc(i, a, s, h, c, f);
    }, t;
  }(le);
  function _ct(n, t) {
    t = t || {};
    var e = t.isRoundCap;
    return function(r, i, a) {
      var s = i.position;
      if (!s || s instanceof Array) return Wx(r, i, a);
      var o = n(s), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, h = u.cy, f = u.r, d = u.r0, p = (f + d) / 2, g = u.startAngle, v = u.endAngle, m = (g + v) / 2, y = e ? Math.abs(f - d) / 2 : 0, x = Math.cos, b = Math.sin, _ = c + f * x(g), w = h + f * b(g), S = "left", I = "top";
      switch (o) {
        case "startArc":
          _ = c + (d - l) * x(m), w = h + (d - l) * b(m), S = "center", I = "top";
          break;
        case "insideStartArc":
          _ = c + (d + l) * x(m), w = h + (d + l) * b(m), S = "center", I = "bottom";
          break;
        case "startAngle":
          _ = c + p * x(g) + t0(g, l + y, false), w = h + p * b(g) + e0(g, l + y, false), S = "right", I = "middle";
          break;
        case "insideStartAngle":
          _ = c + p * x(g) + t0(g, -l + y, false), w = h + p * b(g) + e0(g, -l + y, false), S = "left", I = "middle";
          break;
        case "middle":
          _ = c + p * x(m), w = h + p * b(m), S = "center", I = "middle";
          break;
        case "endArc":
          _ = c + (f + l) * x(m), w = h + (f + l) * b(m), S = "center", I = "bottom";
          break;
        case "insideEndArc":
          _ = c + (f - l) * x(m), w = h + (f - l) * b(m), S = "center", I = "top";
          break;
        case "endAngle":
          _ = c + p * x(v) + t0(v, l + y, true), w = h + p * b(v) + e0(v, l + y, true), S = "left", I = "middle";
          break;
        case "insideEndAngle":
          _ = c + p * x(v) + t0(v, -l + y, true), w = h + p * b(v) + e0(v, -l + y, true), S = "right", I = "middle";
          break;
        default:
          return Wx(r, i, a);
      }
      return r = r || {}, r.x = _, r.y = w, r.align = S, r.verticalAlign = I, r;
    };
  }
  function wct(n, t, e, r) {
    if (_e(r)) {
      n.setTextConfig({
        rotation: r
      });
      return;
    } else if (ct(t)) {
      n.setTextConfig({
        rotation: 0
      });
      return;
    }
    var i = n.shape, a = i.clockwise ? i.startAngle : i.endAngle, s = i.clockwise ? i.endAngle : i.startAngle, o = (a + s) / 2, l, u = e(t);
    switch (u) {
      case "startArc":
      case "insideStartArc":
      case "middle":
      case "insideEndArc":
      case "endArc":
        l = o;
        break;
      case "startAngle":
      case "insideStartAngle":
        l = a;
        break;
      case "endAngle":
      case "insideEndAngle":
        l = s;
        break;
      default:
        n.setTextConfig({
          rotation: 0
        });
        return;
    }
    var c = Math.PI * 1.5 - l;
    u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), n.setTextConfig({
      rotation: c
    });
  }
  function t0(n, t, e) {
    return t * Math.sin(n) * (e ? -1 : 1);
  }
  function e0(n, t, e) {
    return t * Math.cos(n) * (e ? 1 : -1);
  }
  function Sc(n, t, e) {
    var r = n.get("borderRadius");
    if (r == null) return e ? {
      cornerRadius: 0
    } : null;
    ct(r) || (r = [
      r,
      r,
      r,
      r
    ]);
    var i = Math.abs(t.r || 0 - t.r0 || 0);
    return {
      cornerRadius: ht(r, function(a) {
        return ss(a, i);
      })
    };
  }
  var rC = Math.max, iC = Math.min;
  function Sct(n, t) {
    var e = n.getArea && n.getArea();
    if (mh(n, "cartesian2d")) {
      var r = n.getBaseAxis();
      if (r.type !== "category" || !r.onBand) {
        var i = t.getLayout("bandWidth");
        r.isHorizontal() ? (e.x -= i, e.width += i * 2) : (e.y -= i, e.height += i * 2);
      }
    }
    return e;
  }
  var Cct = function(n) {
    q(t, n);
    function t() {
      var e = n.call(this) || this;
      return e.type = t.type, e._isFirstFrame = true, e;
    }
    return t.prototype.render = function(e, r, i, a) {
      this._model = e, this._removeOnRenderedListener(i), this._updateDrawMode(e);
      var s = e.get("coordinateSystem");
      (s === "cartesian2d" || s === "polar") && (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(e, r, i) : this._renderNormal(e, r, i, a));
    }, t.prototype.incrementalPrepareRender = function(e) {
      this._clear(), this._updateDrawMode(e), this._updateLargeClip(e);
    }, t.prototype.incrementalRender = function(e, r) {
      this._progressiveEls = [], this._incrementalRenderLarge(e, r);
    }, t.prototype.eachRendered = function(e) {
      su(this._progressiveEls || this.group, e);
    }, t.prototype._updateDrawMode = function(e) {
      var r = e.pipelineContext.large;
      (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear());
    }, t.prototype._renderNormal = function(e, r, i, a) {
      var s = this.group, o = e.getData(), l = this._data, u = e.coordinateSystem, c = u.getBaseAxis(), h;
      u.type === "cartesian2d" ? h = c.isHorizontal() : u.type === "polar" && (h = c.dim === "angle");
      var f = e.isAnimationEnabled() ? e : null, d = Tct(e, u);
      d && this._enableRealtimeSort(d, o, i);
      var p = e.get("clip", true) || d, g = Sct(u, o);
      s.removeClipPath();
      var v = e.get("roundCap", true), m = e.get("showBackground", true), y = e.getModel("backgroundStyle"), x = y.get("borderRadius") || 0, b = [], _ = this._backgroundEls, w = a && a.isInitSort, S = a && a.type === "changeAxisOrder";
      function I(C) {
        var D = n0[u.type](o, C), E = Rct(u, h, D);
        return E.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? E.setShape("r", x) : E.setShape("cornerRadius", x), b[C] = E, E;
      }
      o.diff(l).add(function(C) {
        var D = o.getItemModel(C), E = n0[u.type](o, C, D);
        if (m && I(C), !(!o.hasValue(C) || !SO[u.type](E))) {
          var M = false;
          p && (M = xO[u.type](g, E));
          var L = bO[u.type](e, o, C, E, h, f, c.model, false, v);
          d && (L.forceLabelAnimation = true), CO(L, o, C, D, E, e, h, u.type === "polar"), w ? L.attr({
            shape: E
          }) : d ? _O(d, f, L, E, C, h, false, false) : dn(L, {
            shape: E
          }, e, C), o.setItemGraphicEl(C, L), s.add(L), L.ignore = M;
        }
      }).update(function(C, D) {
        var E = o.getItemModel(C), M = n0[u.type](o, C, E);
        if (m) {
          var L = void 0;
          _.length === 0 ? L = I(D) : (L = _[D], L.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? L.setShape("r", x) : L.setShape("cornerRadius", x), b[C] = L);
          var k = n0[u.type](o, C), N = M6(h, k, u);
          Ie(L, {
            shape: N
          }, f, C);
        }
        var R = l.getItemGraphicEl(D);
        if (!o.hasValue(C) || !SO[u.type](M)) {
          s.remove(R);
          return;
        }
        var $ = false;
        if (p && ($ = xO[u.type](g, M), $ && s.remove(R)), R ? os(R) : R = bO[u.type](e, o, C, M, h, f, c.model, !!R, v), d && (R.forceLabelAnimation = true), S) {
          var O = R.getTextContent();
          if (O) {
            var F = wd(O);
            F.prevValue != null && (F.prevValue = F.value);
          }
        } else CO(R, o, C, E, M, e, h, u.type === "polar");
        w ? R.attr({
          shape: M
        }) : d ? _O(d, f, R, M, C, h, true, S) : Ie(R, {
          shape: M
        }, e, C, null), o.setItemGraphicEl(C, R), R.ignore = $, s.add(R);
      }).remove(function(C) {
        var D = l.getItemGraphicEl(C);
        D && Bg(D, e, C);
      }).execute();
      var T = this._backgroundGroup || (this._backgroundGroup = new Vt());
      T.removeAll();
      for (var A = 0; A < b.length; ++A) T.add(b[A]);
      s.add(T), this._backgroundEls = b, this._data = o;
    }, t.prototype._renderLarge = function(e, r, i) {
      this._clear(), IO(e, this.group), this._updateLargeClip(e);
    }, t.prototype._incrementalRenderLarge = function(e, r) {
      this._removeBackground(), IO(r, this.group, this._progressiveEls, true);
    }, t.prototype._updateLargeClip = function(e) {
      var r = e.get("clip", true) && Hv(e.coordinateSystem, false, e), i = this.group;
      r ? i.setClipPath(r) : i.removeClipPath();
    }, t.prototype._enableRealtimeSort = function(e, r, i) {
      var a = this;
      if (r.count()) {
        var s = e.baseAxis;
        if (this._isFirstFrame) this._dispatchInitSort(r, e, i), this._isFirstFrame = false;
        else {
          var o = function(l) {
            var u = r.getItemGraphicEl(l), c = u && u.shape;
            return c && Math.abs(s.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(r, o, s, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, t.prototype._dataSort = function(e, r, i) {
      var a = [];
      return e.each(e.mapDimension(r.dim), function(s, o) {
        var l = i(o);
        l = l ?? NaN, a.push({
          dataIndex: o,
          mappedValue: l,
          ordinalNumber: s
        });
      }), a.sort(function(s, o) {
        return o.mappedValue - s.mappedValue;
      }), {
        ordinalNumbers: ht(a, function(s) {
          return s.ordinalNumber;
        })
      };
    }, t.prototype._isOrderChangedWithinSameData = function(e, r, i) {
      for (var a = i.scale, s = e.mapDimension(i.dim), o = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = e.rawIndexOf(s, a.getRawOrdinalNumber(l)), h = c < 0 ? Number.MIN_VALUE : r(e.indexOfRawIndex(c));
        if (h > o) return true;
        o = h;
      }
      return false;
    }, t.prototype._isOrderDifferentInView = function(e, r) {
      for (var i = r.scale, a = i.getExtent(), s = Math.max(0, a[0]), o = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); s <= o; ++s) if (e.ordinalNumbers[s] !== i.getRawOrdinalNumber(s)) return true;
    }, t.prototype._updateSortWithinSameData = function(e, r, i, a) {
      if (this._isOrderChangedWithinSameData(e, r, i)) {
        var s = this._dataSort(e, i, r);
        this._isOrderDifferentInView(s, i) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: s
        }));
      }
    }, t.prototype._dispatchInitSort = function(e, r, i) {
      var a = r.baseAxis, s = this._dataSort(e, a, function(o) {
        return e.get(e.mapDimension(r.otherAxis.dim), o);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: true,
        axisId: a.index,
        sortInfo: s
      });
    }, t.prototype.remove = function(e, r) {
      this._clear(this._model), this._removeOnRenderedListener(r);
    }, t.prototype.dispose = function(e, r) {
      this._removeOnRenderedListener(r);
    }, t.prototype._removeOnRenderedListener = function(e) {
      this._onRendered && (e.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, t.prototype._clear = function(e) {
      var r = this.group, i = this._data;
      e && e.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(a) {
        Bg(a, e, Ut(a).dataIndex);
      })) : r.removeAll(), this._data = null, this._isFirstFrame = true;
    }, t.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, t.type = "bar", t;
  }(qe), xO = {
    cartesian2d: function(n, t) {
      var e = t.width < 0 ? -1 : 1, r = t.height < 0 ? -1 : 1;
      e < 0 && (t.x += t.width, t.width = -t.width), r < 0 && (t.y += t.height, t.height = -t.height);
      var i = n.x + n.width, a = n.y + n.height, s = rC(t.x, n.x), o = iC(t.x + t.width, i), l = rC(t.y, n.y), u = iC(t.y + t.height, a), c = o < s, h = u < l;
      return t.x = c && s > i ? o : s, t.y = h && l > a ? u : l, t.width = c ? 0 : o - s, t.height = h ? 0 : u - l, e < 0 && (t.x += t.width, t.width = -t.width), r < 0 && (t.y += t.height, t.height = -t.height), c || h;
    },
    polar: function(n, t) {
      var e = t.r0 <= t.r ? 1 : -1;
      if (e < 0) {
        var r = t.r;
        t.r = t.r0, t.r0 = r;
      }
      var i = iC(t.r, n.r), a = rC(t.r0, n.r0);
      t.r = i, t.r0 = a;
      var s = i - a < 0;
      if (e < 0) {
        var r = t.r;
        t.r = t.r0, t.r0 = r;
      }
      return s;
    }
  }, bO = {
    cartesian2d: function(n, t, e, r, i, a, s, o, l) {
      var u = new ye({
        shape: rt({}, r),
        z2: 1
      });
      if (u.__dataIndex = e, u.name = "item", a) {
        var c = u.shape, h = i ? "height" : "width";
        c[h] = 0;
      }
      return u;
    },
    polar: function(n, t, e, r, i, a, s, o, l) {
      var u = !i && l ? cb : mi, c = new u({
        shape: r,
        z2: 1
      });
      c.name = "item";
      var h = E6(i);
      if (c.calculateTextPosition = _ct(h, {
        isRoundCap: u === cb
      }), a) {
        var f = c.shape, d = i ? "r" : "endAngle", p = {};
        f[d] = i ? r.r0 : r.startAngle, p[d] = r[d], (o ? Ie : dn)(c, {
          shape: p
        }, a);
      }
      return c;
    }
  };
  function Tct(n, t) {
    var e = n.get("realtimeSort", true), r = t.getBaseAxis();
    if (e && r.type === "category" && t.type === "cartesian2d") return {
      baseAxis: r,
      otherAxis: t.getOtherAxis(r)
    };
  }
  function _O(n, t, e, r, i, a, s, o) {
    var l, u;
    a ? (u = {
      x: r.x,
      width: r.width
    }, l = {
      y: r.y,
      height: r.height
    }) : (u = {
      y: r.y,
      height: r.height
    }, l = {
      x: r.x,
      width: r.width
    }), o || (s ? Ie : dn)(e, {
      shape: l
    }, t, i, null);
    var c = t ? n.baseAxis.model : null;
    (s ? Ie : dn)(e, {
      shape: u
    }, c, i);
  }
  function wO(n, t) {
    for (var e = 0; e < t.length; e++) if (!isFinite(n[t[e]])) return true;
    return false;
  }
  var Ict = [
    "x",
    "y",
    "width",
    "height"
  ], Act = [
    "cx",
    "cy",
    "r",
    "startAngle",
    "endAngle"
  ], SO = {
    cartesian2d: function(n) {
      return !wO(n, Ict);
    },
    polar: function(n) {
      return !wO(n, Act);
    }
  }, n0 = {
    cartesian2d: function(n, t, e) {
      var r = n.getItemLayout(t), i = e ? Dct(e, r) : 0, a = r.width > 0 ? 1 : -1, s = r.height > 0 ? 1 : -1;
      return {
        x: r.x + a * i / 2,
        y: r.y + s * i / 2,
        width: r.width - a * i,
        height: r.height - s * i
      };
    },
    polar: function(n, t, e) {
      var r = n.getItemLayout(t);
      return {
        cx: r.cx,
        cy: r.cy,
        r0: r.r0,
        r: r.r,
        startAngle: r.startAngle,
        endAngle: r.endAngle,
        clockwise: r.clockwise
      };
    }
  };
  function kct(n) {
    return n.startAngle != null && n.endAngle != null && n.startAngle === n.endAngle;
  }
  function E6(n) {
    return /* @__PURE__ */ function(t) {
      var e = t ? "Arc" : "Angle";
      return function(r) {
        switch (r) {
          case "start":
          case "insideStart":
          case "end":
          case "insideEnd":
            return r + e;
          default:
            return r;
        }
      };
    }(n);
  }
  function CO(n, t, e, r, i, a, s, o) {
    var l = t.getItemVisual(e, "style");
    if (o) {
      if (!a.get("roundCap")) {
        var c = n.shape, h = Sc(r.getModel("itemStyle"), c, true);
        rt(c, h), n.setShape(c);
      }
    } else {
      var u = r.get([
        "itemStyle",
        "borderRadius"
      ]) || 0;
      n.setShape("r", u);
    }
    n.useStyle(l);
    var f = r.getShallow("cursor");
    f && n.attr("cursor", f);
    var d = o ? s ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : s ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = ur(r);
    kr(n, p, {
      labelFetcher: a,
      labelDataIndex: e,
      defaultText: Xf(a.getData(), e),
      inheritColor: l.fill,
      defaultOpacity: l.opacity,
      defaultOutsidePosition: d
    });
    var g = n.getTextContent();
    if (o && g) {
      var v = r.get([
        "label",
        "position"
      ]);
      n.textConfig.inside = v === "middle" ? true : null, wct(n, v === "outside" ? d : v, E6(s), r.get([
        "label",
        "rotate"
      ]));
    }
    jU(g, p, a.getRawValue(e), function(y) {
      return _6(t, y);
    });
    var m = r.getModel([
      "emphasis"
    ]);
    bn(n, m.get("focus"), m.get("blurScope"), m.get("disabled")), Ar(n, r), kct(i) && (n.style.fill = "none", n.style.stroke = "none", P(n.states, function(y) {
      y.style && (y.style.fill = y.style.stroke = "none");
    }));
  }
  function Dct(n, t) {
    var e = n.get([
      "itemStyle",
      "borderColor"
    ]);
    if (!e || e === "none") return 0;
    var r = n.get([
      "itemStyle",
      "borderWidth"
    ]) || 0, i = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width), a = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height);
    return Math.min(r, i, a);
  }
  var Ect = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), TO = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "largeBar", r;
    }
    return t.prototype.getDefaultShape = function() {
      return new Ect();
    }, t.prototype.buildPath = function(e, r) {
      for (var i = r.points, a = this.baseDimIdx, s = 1 - this.baseDimIdx, o = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3) l[a] = u, l[s] = i[c + 2], o[a] = i[c + a], o[s] = i[c + s], e.rect(o[0], o[1], l[0], l[1]);
    }, t;
  }(le);
  function IO(n, t, e, r) {
    var i = n.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, s = i.getLayout("largeDataIndices"), o = i.getLayout("size"), l = n.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
    if (u) {
      var c = new TO({
        shape: {
          points: u
        },
        incremental: !!r,
        silent: true,
        z2: 0
      });
      c.baseDimIdx = a, c.largeDataIndices = s, c.barWidth = o, c.useStyle(l.getItemStyle()), t.add(c), e && e.push(c);
    }
    var h = new TO({
      shape: {
        points: i.getLayout("largePoints")
      },
      incremental: !!r,
      ignoreCoarsePointer: true,
      z2: 1
    });
    h.baseDimIdx = a, h.largeDataIndices = s, h.barWidth = o, t.add(h), h.useStyle(i.getVisual("style")), h.style.stroke = null, Ut(h).seriesIndex = n.seriesIndex, n.get("silent") || (h.on("mousedown", AO), h.on("mousemove", AO)), e && e.push(h);
  }
  var AO = yD(function(n) {
    var t = this, e = Mct(t, n.offsetX, n.offsetY);
    Ut(t).dataIndex = e >= 0 ? e : null;
  }, 30, false);
  function Mct(n, t, e) {
    for (var r = n.baseDimIdx, i = 1 - r, a = n.shape.points, s = n.largeDataIndices, o = [], l = [], u = n.barWidth, c = 0, h = a.length / 3; c < h; c++) {
      var f = c * 3;
      if (l[r] = u, l[i] = a[f + 2], o[r] = a[f + r], o[i] = a[f + i], l[i] < 0 && (o[i] += l[i], l[i] = -l[i]), t >= o[0] && t <= o[0] + l[0] && e >= o[1] && e <= o[1] + l[1]) return s[c];
    }
    return -1;
  }
  function M6(n, t, e) {
    if (mh(e, "cartesian2d")) {
      var r = t, i = e.getArea();
      return {
        x: n ? r.x : i.x,
        y: n ? i.y : r.y,
        width: n ? r.width : i.width,
        height: n ? i.height : r.height
      };
    } else {
      var i = e.getArea(), a = t;
      return {
        cx: i.cx,
        cy: i.cy,
        r0: n ? i.r0 : a.r0,
        r: n ? i.r : a.r,
        startAngle: n ? a.startAngle : 0,
        endAngle: n ? a.endAngle : Math.PI * 2
      };
    }
  }
  function Rct(n, t, e) {
    var r = n.type === "polar" ? mi : ye;
    return new r({
      shape: M6(t, e, n),
      silent: true,
      z2: 0
    });
  }
  function Nct(n) {
    n.registerChartView(Cct), n.registerSeriesModel(xct), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, qt($H, "bar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, OH("bar")), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, D6("bar")), n.registerAction({
      type: "changeAxisOrder",
      event: "changeAxisOrder",
      update: "update"
    }, function(t, e) {
      var r = t.componentType || "series";
      e.eachComponent({
        mainType: r,
        query: t
      }, function(i) {
        t.sortInfo && i.axis.setCategorySortInfo(t.sortInfo);
      });
    });
  }
  var kO = Math.PI * 2, r0 = Math.PI / 180;
  function R6(n, t) {
    return Zn(n.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    });
  }
  function N6(n, t) {
    var e = R6(n, t), r = n.get("center"), i = n.get("radius");
    ct(i) || (i = [
      0,
      i
    ]);
    var a = yt(e.width, t.getWidth()), s = yt(e.height, t.getHeight()), o = Math.min(a, s), l = yt(i[0], o / 2), u = yt(i[1], o / 2), c, h, f = n.coordinateSystem;
    if (f) {
      var d = f.dataToPoint(r);
      c = d[0] || 0, h = d[1] || 0;
    } else ct(r) || (r = [
      r,
      r
    ]), c = yt(r[0], a) + e.x, h = yt(r[1], s) + e.y;
    return {
      cx: c,
      cy: h,
      r0: l,
      r: u
    };
  }
  function Lct(n, t, e) {
    t.eachSeriesByType(n, function(r) {
      var i = r.getData(), a = i.mapDimension("value"), s = R6(r, e), o = N6(r, e), l = o.cx, u = o.cy, c = o.r, h = o.r0, f = -r.get("startAngle") * r0, d = r.get("endAngle"), p = r.get("padAngle") * r0;
      d = d === "auto" ? f - kO : -d * r0;
      var g = r.get("minAngle") * r0, v = g + p, m = 0;
      i.each(a, function(N) {
        !isNaN(N) && m++;
      });
      var y = i.getSum(a), x = Math.PI / (y || m) * 2, b = r.get("clockwise"), _ = r.get("roseType"), w = r.get("stillShowZeroSum"), S = i.getDataExtent(a);
      S[0] = 0;
      var I = b ? 1 : -1, T = [
        f,
        d
      ], A = I * p / 2;
      Yk(T, !b), f = T[0], d = T[1];
      var C = L6(r);
      C.startAngle = f, C.endAngle = d, C.clockwise = b;
      var D = Math.abs(d - f), E = D, M = 0, L = f;
      if (i.setLayout({
        viewRect: s,
        r: c
      }), i.each(a, function(N, R) {
        var $;
        if (isNaN(N)) {
          i.setItemLayout(R, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: b,
            cx: l,
            cy: u,
            r0: h,
            r: _ ? NaN : c
          });
          return;
        }
        _ !== "area" ? $ = y === 0 && w ? x : N * x : $ = D / m, $ < v ? ($ = v, E -= v) : M += N;
        var O = L + I * $, F = 0, z = 0;
        p > $ ? (F = L + I * $ / 2, z = F) : (F = L + A, z = O - A), i.setItemLayout(R, {
          angle: $,
          startAngle: F,
          endAngle: z,
          clockwise: b,
          cx: l,
          cy: u,
          r0: h,
          r: _ ? Pe(N, S, [
            h,
            c
          ]) : c
        }), L = O;
      }), E < kO && m) if (E <= 1e-3) {
        var k = D / m;
        i.each(a, function(N, R) {
          if (!isNaN(N)) {
            var $ = i.getItemLayout(R);
            $.angle = k;
            var O = 0, F = 0;
            k < p ? (O = f + I * (R + 1 / 2) * k, F = O) : (O = f + I * R * k + A, F = f + I * (R + 1) * k - A), $.startAngle = O, $.endAngle = F;
          }
        });
      } else x = E / M, L = f, i.each(a, function(N, R) {
        if (!isNaN(N)) {
          var $ = i.getItemLayout(R), O = $.angle === v ? v : N * x, F = 0, z = 0;
          O < p ? (F = L + I * O / 2, z = F) : (F = L + A, z = L + I * O - A), $.startAngle = F, $.endAngle = z, L += I * O;
        }
      });
    });
  }
  var L6 = xe();
  function Yv(n) {
    return {
      seriesType: n,
      reset: function(t, e) {
        var r = e.findComponents({
          mainType: "legend"
        });
        if (!(!r || !r.length)) {
          var i = t.getData();
          i.filterSelf(function(a) {
            for (var s = i.getName(a), o = 0; o < r.length; o++) if (!r[o].isSelected(s)) return false;
            return true;
          });
        }
      }
    };
  }
  var Pct = Math.PI / 180;
  function DO(n, t, e, r, i, a, s, o, l, u) {
    if (n.length < 2) return;
    function c(g) {
      for (var v = g.rB, m = v * v, y = 0; y < g.list.length; y++) {
        var x = g.list[y], b = Math.abs(x.label.y - e), _ = r + x.len, w = _ * _, S = Math.sqrt(Math.abs((1 - b * b / m) * w)), I = t + (S + x.len2) * i, T = I - x.label.x, A = x.targetTextWidth - T * i;
        P6(x, A, true), x.label.x = I;
      }
    }
    function h(g) {
      for (var v = {
        list: [],
        maxY: 0
      }, m = {
        list: [],
        maxY: 0
      }, y = 0; y < g.length; y++) if (g[y].labelAlignTo === "none") {
        var x = g[y], b = x.label.y > e ? m : v, _ = Math.abs(x.label.y - e);
        if (_ >= b.maxY) {
          var w = x.label.x - t - x.len2 * i, S = r + x.len, I = Math.abs(w) < S ? Math.sqrt(_ * _ / (1 - w * w / S / S)) : S;
          b.rB = I, b.maxY = _;
        }
        b.list.push(x);
      }
      c(v), c(m);
    }
    for (var f = n.length, d = 0; d < f; d++) if (n[d].position === "outer" && n[d].labelAlignTo === "labelLine") {
      var p = n[d].label.x - u;
      n[d].linePoints[1][0] += p, n[d].label.x = u;
    }
    i6(n, l, l + s) && h(n);
  }
  function $ct(n, t, e, r, i, a, s, o) {
    for (var l = [], u = [], c = Number.MAX_VALUE, h = -Number.MAX_VALUE, f = 0; f < n.length; f++) {
      var d = n[f].label;
      aC(n[f]) || (d.x < t ? (c = Math.min(c, d.x), l.push(n[f])) : (h = Math.max(h, d.x), u.push(n[f])));
    }
    for (var f = 0; f < n.length; f++) {
      var p = n[f];
      if (!aC(p) && p.linePoints) {
        if (p.labelStyleWidth != null) continue;
        var d = p.label, g = p.linePoints, v = void 0;
        p.labelAlignTo === "edge" ? d.x < t ? v = g[2][0] - p.labelDistance - s - p.edgeDistance : v = s + i - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? d.x < t ? v = c - s - p.bleedMargin : v = s + i - h - p.bleedMargin : d.x < t ? v = d.x - s - p.bleedMargin : v = s + i - d.x - p.bleedMargin, p.targetTextWidth = v, P6(p, v);
      }
    }
    DO(u, t, e, r, 1, i, a, s, o, h), DO(l, t, e, r, -1, i, a, s, o, c);
    for (var f = 0; f < n.length; f++) {
      var p = n[f];
      if (!aC(p) && p.linePoints) {
        var d = p.label, g = p.linePoints, m = p.labelAlignTo === "edge", y = d.style.padding, x = y ? y[1] + y[3] : 0, b = d.style.backgroundColor ? 0 : x, _ = p.rect.width + b, w = g[1][0] - g[2][0];
        m ? d.x < t ? g[2][0] = s + p.edgeDistance + _ + p.labelDistance : g[2][0] = s + i - p.edgeDistance - _ - p.labelDistance : (d.x < t ? g[2][0] = d.x + p.labelDistance : g[2][0] = d.x - p.labelDistance, g[1][0] = g[2][0] + w), g[1][1] = g[2][1] = d.y;
      }
    }
  }
  function P6(n, t, e) {
    if (e === void 0 && (e = false), n.labelStyleWidth == null) {
      var r = n.label, i = r.style, a = n.rect, s = i.backgroundColor, o = i.padding, l = o ? o[1] + o[3] : 0, u = i.overflow, c = a.width + (s ? 0 : l);
      if (t < c || e) {
        var h = a.height;
        if (u && u.match("break")) {
          r.setStyle("backgroundColor", null), r.setStyle("width", t - l);
          var f = r.getBoundingRect();
          r.setStyle("width", Math.ceil(f.width)), r.setStyle("backgroundColor", s);
        } else {
          var d = t - l, p = t < c ? d : e ? d > n.unconstrainedWidth ? null : d : null;
          r.setStyle("width", p);
        }
        var g = r.getBoundingRect();
        a.width = g.width;
        var v = (r.style.margin || 0) + 2.1;
        a.height = g.height + v, a.y -= (a.height - h) / 2;
      }
    }
  }
  function aC(n) {
    return n.position === "center";
  }
  function Oct(n) {
    var t = n.getData(), e = [], r, i, a = false, s = (n.get("minShowLabelAngle") || 0) * Pct, o = t.getLayout("viewRect"), l = t.getLayout("r"), u = o.width, c = o.x, h = o.y, f = o.height;
    function d(w) {
      w.ignore = true;
    }
    function p(w) {
      if (!w.ignore) return true;
      for (var S in w.states) if (w.states[S].ignore === false) return true;
      return false;
    }
    t.each(function(w) {
      var S = t.getItemGraphicEl(w), I = S.shape, T = S.getTextContent(), A = S.getTextGuideLine(), C = t.getItemModel(w), D = C.getModel("label"), E = D.get("position") || C.get([
        "emphasis",
        "label",
        "position"
      ]), M = D.get("distanceToLabelLine"), L = D.get("alignTo"), k = yt(D.get("edgeDistance"), u), N = D.get("bleedMargin"), R = C.getModel("labelLine"), $ = R.get("length");
      $ = yt($, u);
      var O = R.get("length2");
      if (O = yt(O, u), Math.abs(I.endAngle - I.startAngle) < s) {
        P(T.states, d), T.ignore = true, A && (P(A.states, d), A.ignore = true);
        return;
      }
      if (p(T)) {
        var F = (I.startAngle + I.endAngle) / 2, z = Math.cos(F), V = Math.sin(F), U, X, at, pt;
        r = I.cx, i = I.cy;
        var it = E === "inside" || E === "inner";
        if (E === "center") U = I.cx, X = I.cy, pt = "center";
        else {
          var et = (it ? (I.r + I.r0) / 2 * z : I.r * z) + r, ft = (it ? (I.r + I.r0) / 2 * V : I.r * V) + i;
          if (U = et + z * 3, X = ft + V * 3, !it) {
            var ut = et + z * ($ + l - I.r), gt = ft + V * ($ + l - I.r), kt = ut + (z < 0 ? -1 : 1) * O, At = gt;
            L === "edge" ? U = z < 0 ? c + k : c + u - k : U = kt + (z < 0 ? -M : M), X = At, at = [
              [
                et,
                ft
              ],
              [
                ut,
                gt
              ],
              [
                kt,
                At
              ]
            ];
          }
          pt = it ? "center" : L === "edge" ? z > 0 ? "right" : "left" : z > 0 ? "left" : "right";
        }
        var mt = Math.PI, _t = 0, ee = D.get("rotate");
        if (_e(ee)) _t = ee * (mt / 180);
        else if (E === "center") _t = 0;
        else if (ee === "radial" || ee === true) {
          var G = z < 0 ? -F + mt : -F;
          _t = G;
        } else if (ee === "tangential" && E !== "outside" && E !== "outer") {
          var H = Math.atan2(z, V);
          H < 0 && (H = mt * 2 + H);
          var dt = V > 0;
          dt && (H = mt + H), _t = H - mt;
        }
        if (a = !!_t, T.x = U, T.y = X, T.rotation = _t, T.setStyle({
          verticalAlign: "middle"
        }), it) {
          T.setStyle({
            align: pt
          });
          var ie = T.states.select;
          ie && (ie.x += T.x, ie.y += T.y);
        } else {
          var Mt = T.getBoundingRect().clone();
          Mt.applyTransform(T.getComputedTransform());
          var Ae = (T.style.margin || 0) + 2.1;
          Mt.y -= Ae / 2, Mt.height += Ae, e.push({
            label: T,
            labelLine: A,
            position: E,
            len: $,
            len2: O,
            minTurnAngle: R.get("minTurnAngle"),
            maxSurfaceAngle: R.get("maxSurfaceAngle"),
            surfaceNormal: new Qt(z, V),
            linePoints: at,
            textAlign: pt,
            labelDistance: M,
            labelAlignTo: L,
            edgeDistance: k,
            bleedMargin: N,
            rect: Mt,
            unconstrainedWidth: Mt.width,
            labelStyleWidth: T.style.width
          });
        }
        S.setTextConfig({
          inside: it
        });
      }
    }), !a && n.get("avoidLabelOverlap") && $ct(e, r, i, l, u, f, c, h);
    for (var g = 0; g < e.length; g++) {
      var v = e[g], m = v.label, y = v.labelLine, x = isNaN(m.x) || isNaN(m.y);
      if (m) {
        m.setStyle({
          align: v.textAlign
        }), x && (P(m.states, d), m.ignore = true);
        var b = m.states.select;
        b && (b.x += m.x, b.y += m.y);
      }
      if (y) {
        var _ = v.linePoints;
        x || !_ ? (P(y.states, d), y.ignore = true) : (e6(_, v.minTurnAngle), sut(_, v.surfaceNormal, v.maxSurfaceAngle), y.setShape({
          points: _
        }), m.__hostTarget.textGuideLineConfig = {
          anchor: new Qt(_[0][0], _[0][1])
        });
      }
    }
  }
  var Fct = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this) || this;
      a.z2 = 2;
      var s = new be();
      return a.setTextContent(s), a.updateData(e, r, i, true), a;
    }
    return t.prototype.updateData = function(e, r, i, a) {
      var s = this, o = e.hostModel, l = e.getItemModel(r), u = l.getModel("emphasis"), c = e.getItemLayout(r), h = rt(Sc(l.getModel("itemStyle"), c, true), c);
      if (isNaN(h.startAngle)) {
        s.setShape(h);
        return;
      }
      if (a) {
        s.setShape(h);
        var f = o.getShallow("animationType");
        o.ecModel.ssr ? (dn(s, {
          scaleX: 0,
          scaleY: 0
        }, o, {
          dataIndex: r,
          isFrom: true
        }), s.originX = h.cx, s.originY = h.cy) : f === "scale" ? (s.shape.r = c.r0, dn(s, {
          shape: {
            r: c.r
          }
        }, o, r)) : i != null ? (s.setShape({
          startAngle: i,
          endAngle: i
        }), dn(s, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, o, r)) : (s.shape.endAngle = c.startAngle, Ie(s, {
          shape: {
            endAngle: c.endAngle
          }
        }, o, r));
      } else os(s), Ie(s, {
        shape: h
      }, o, r);
      s.useStyle(e.getItemVisual(r, "style")), Ar(s, l);
      var d = (c.startAngle + c.endAngle) / 2, p = o.get("selectedOffset"), g = Math.cos(d) * p, v = Math.sin(d) * p, m = l.getShallow("cursor");
      m && s.attr("cursor", m), this._updateLabel(o, e, r), s.ensureState("emphasis").shape = rt({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, Sc(u.getModel("itemStyle"), c)), rt(s.ensureState("select"), {
        x: g,
        y: v,
        shape: Sc(l.getModel([
          "select",
          "itemStyle"
        ]), c)
      }), rt(s.ensureState("blur"), {
        shape: Sc(l.getModel([
          "blur",
          "itemStyle"
        ]), c)
      });
      var y = s.getTextGuideLine(), x = s.getTextContent();
      y && rt(y.ensureState("select"), {
        x: g,
        y: v
      }), rt(x.ensureState("select"), {
        x: g,
        y: v
      }), bn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e, r, i) {
      var a = this, s = r.getItemModel(i), o = s.getModel("labelLine"), l = r.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      kr(a, ur(s), {
        labelFetcher: r.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: e.getFormattedLabel(i, "normal") || r.getName(i)
      });
      var h = a.getTextContent();
      a.setTextConfig({
        position: null,
        rotation: null
      }), h.attr({
        z2: 10
      });
      var f = e.get([
        "label",
        "position"
      ]);
      if (f !== "outside" && f !== "outer") a.removeTextGuideLine();
      else {
        var d = this.getTextGuideLine();
        d || (d = new _i(), this.setTextGuideLine(d)), MD(this, RD(s), {
          stroke: u,
          opacity: Ws(o.get([
            "lineStyle",
            "opacity"
          ]), c, 1)
        });
      }
    }, t;
  }(mi), Bct = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.ignoreLabelLineUpdate = true, e;
    }
    return t.prototype.render = function(e, r, i, a) {
      var s = e.getData(), o = this._data, l = this.group, u;
      if (!o && s.count() > 0) {
        for (var c = s.getItemLayout(0), h = 1; isNaN(c && c.startAngle) && h < s.count(); ++h) c = s.getItemLayout(h);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), s.count() === 0 && e.get("showEmptyCircle")) {
        var f = L6(e), d = new mi({
          shape: rt(N6(e, i), f)
        });
        d.useStyle(e.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = d, l.add(d);
      }
      s.diff(o).add(function(p) {
        var g = new Fct(s, p, u);
        s.setItemGraphicEl(p, g), l.add(g);
      }).update(function(p, g) {
        var v = o.getItemGraphicEl(g);
        v.updateData(s, p, u), v.off("click"), l.add(v), s.setItemGraphicEl(p, v);
      }).remove(function(p) {
        var g = o.getItemGraphicEl(p);
        Bg(g, e, p);
      }).execute(), Oct(e), e.get("animationTypeUpdate") !== "expansion" && (this._data = s);
    }, t.prototype.dispose = function() {
    }, t.prototype.containPoint = function(e, r) {
      var i = r.getData(), a = i.getItemLayout(0);
      if (a) {
        var s = e[0] - a.cx, o = e[1] - a.cy, l = Math.sqrt(s * s + o * o);
        return l <= a.r && l >= a.r0;
      }
    }, t.type = "pie", t;
  }(qe);
  function Md(n, t, e) {
    t = ct(t) && {
      coordDimensions: t
    } || rt({
      encodeDefine: n.getEncode()
    }, t);
    var r = n.getSource(), i = Vv(r, t).dimensions, a = new fi(i, n);
    return a.initData(r, e), a;
  }
  var qv = function() {
    function n(t, e) {
      this._getDataWithEncodedVisual = t, this._getRawData = e;
    }
    return n.prototype.getAllNames = function() {
      var t = this._getRawData();
      return t.mapArray(t.getName);
    }, n.prototype.containName = function(t) {
      var e = this._getRawData();
      return e.indexOfName(t) >= 0;
    }, n.prototype.indexOfName = function(t) {
      var e = this._getDataWithEncodedVisual();
      return e.indexOfName(t);
    }, n.prototype.getItemVisual = function(t, e) {
      var r = this._getDataWithEncodedVisual();
      return r.getItemVisual(t, e);
    }, n;
  }(), zct = xe(), Vct = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.init = function(e) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new qv(St(this.getData, this), St(this.getRawData, this)), this._defaultLabelLine(e);
    }, t.prototype.mergeOption = function() {
      n.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.getInitialData = function() {
      return Md(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: qt(cD, this)
      });
    }, t.prototype.getDataParams = function(e) {
      var r = this.getData(), i = zct(r), a = i.seats;
      if (!a) {
        var s = [];
        r.each(r.mapDimension("value"), function(l) {
          s.push(l);
        }), a = i.seats = Mnt(s, r.hostModel.get("percentPrecision"));
      }
      var o = n.prototype.getDataParams.call(this, e);
      return o.percent = a[e] || 0, o.$vars.push("percent"), o;
    }, t.prototype._defaultLabelLine = function(e) {
      Wc(e, "labelLine", [
        "show"
      ]);
      var r = e.labelLine, i = e.emphasis.labelLine;
      r.show = r.show && e.label.show, i.show = i.show && e.emphasis.label.show;
    }, t.type = "series.pie", t.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      center: [
        "50%",
        "50%"
      ],
      radius: [
        0,
        "75%"
      ],
      clockwise: true,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      minAngle: 0,
      minShowLabelAngle: 0,
      selectedOffset: 10,
      percentPrecision: 2,
      stillShowZeroSum: true,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        rotate: 0,
        show: true,
        overflow: "truncate",
        position: "outer",
        alignTo: "none",
        edgeDistance: "25%",
        bleedMargin: 10,
        distanceToLabelLine: 5
      },
      labelLine: {
        show: true,
        length: 15,
        length2: 15,
        smooth: false,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: true,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        hideOverlap: true
      },
      emphasis: {
        scale: true,
        scaleSize: 5
      },
      avoidLabelOverlap: true,
      animationType: "expansion",
      animationDuration: 1e3,
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, t;
  }(an);
  function Gct(n) {
    return {
      seriesType: n,
      reset: function(t, e) {
        var r = t.getData();
        r.filterSelf(function(i) {
          var a = r.mapDimension("value"), s = r.get(a, i);
          return !(_e(s) && !isNaN(s) && s < 0);
        });
      }
    };
  }
  function Wct(n) {
    n.registerChartView(Bct), n.registerSeriesModel(Vct), eH("pie", n.registerAction), n.registerLayout(qt(Lct, "pie")), n.registerProcessor(Yv("pie")), n.registerProcessor(Gct("pie"));
  }
  var Uct = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = true, e;
    }
    return t.prototype.getInitialData = function(e, r) {
      return el(null, this, {
        useEncodeDefaulter: true
      });
    }, t.prototype.getProgressive = function() {
      var e = this.option.progressive;
      return e ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.option.progressiveThreshold;
      return e ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, t.prototype.brushSelector = function(e, r, i) {
      return i.point(r.getItemLayout(e));
    }, t.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, t.type = "series.scatter", t.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      symbolSize: 10,
      large: false,
      largeThreshold: 2e3,
      itemStyle: {
        opacity: 0.8
      },
      emphasis: {
        scale: true
      },
      clip: true,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
    }, t;
  }(an), $6 = 4, Hct = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), Xct = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r._off = 0, r.hoverDataIdx = -1, r;
    }
    return t.prototype.getDefaultShape = function() {
      return new Hct();
    }, t.prototype.reset = function() {
      this.notClear = false, this._off = 0;
    }, t.prototype.buildPath = function(e, r) {
      var i = r.points, a = r.size, s = this.symbolProxy, o = s.shape, l = e.getContext ? e.getContext() : e, u = l && a[0] < $6, c = this.softClipShape, h;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, h = this._off; h < i.length; ) {
        var f = i[h++], d = i[h++];
        isNaN(f) || isNaN(d) || c && !c.contain(f, d) || (o.x = f - a[0] / 2, o.y = d - a[1] / 2, o.width = a[0], o.height = a[1], s.buildPath(e, o, true));
      }
      this.incremental && (this._off = h, this.notClear = true);
    }, t.prototype.afterBrush = function() {
      var e = this.shape, r = e.points, i = e.size, a = this._ctx, s = this.softClipShape, o;
      if (a) {
        for (o = this._off; o < r.length; ) {
          var l = r[o++], u = r[o++];
          isNaN(l) || isNaN(u) || s && !s.contain(l, u) || a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = o, this.notClear = true);
      }
    }, t.prototype.findDataIndex = function(e, r) {
      for (var i = this.shape, a = i.points, s = i.size, o = Math.max(s[0], 4), l = Math.max(s[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, h = a[c] - o / 2, f = a[c + 1] - l / 2;
        if (e >= h && r >= f && e <= h + o && r <= f + l) return u;
      }
      return -1;
    }, t.prototype.contain = function(e, r) {
      var i = this.transformCoordToLocal(e, r), a = this.getBoundingRect();
      if (e = i[0], r = i[1], a.contain(e, r)) {
        var s = this.hoverDataIdx = this.findDataIndex(e, r);
        return s >= 0;
      }
      return this.hoverDataIdx = -1, false;
    }, t.prototype.getBoundingRect = function() {
      var e = this._rect;
      if (!e) {
        for (var r = this.shape, i = r.points, a = r.size, s = a[0], o = a[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, h = -1 / 0, f = 0; f < i.length; ) {
          var d = i[f++], p = i[f++];
          l = Math.min(d, l), c = Math.max(d, c), u = Math.min(p, u), h = Math.max(p, h);
        }
        e = this._rect = new te(l - s / 2, u - o / 2, c - l + s, h - u + o);
      }
      return e;
    }, t;
  }(le), Yct = function() {
    function n() {
      this.group = new Vt();
    }
    return n.prototype.updateData = function(t, e) {
      this._clear();
      var r = this._create();
      r.setShape({
        points: t.getLayout("points")
      }), this._setCommon(r, t, e);
    }, n.prototype.updateLayout = function(t) {
      var e = t.getLayout("points");
      this.group.eachChild(function(r) {
        if (r.startIndex != null) {
          var i = (r.endIndex - r.startIndex) * 2, a = r.startIndex * 4 * 2;
          e = new Float32Array(e.buffer, a, i);
        }
        r.setShape("points", e), r.reset();
      });
    }, n.prototype.incrementalPrepareUpdate = function(t) {
      this._clear();
    }, n.prototype.incrementalUpdate = function(t, e, r) {
      var i = this._newAdded[0], a = e.getLayout("points"), s = i && i.shape.points;
      if (s && s.length < 2e4) {
        var o = s.length, l = new Float32Array(o + a.length);
        l.set(s), l.set(a, o), i.endIndex = t.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = t.start, u.endIndex = t.end, u.incremental = true, u.setShape({
          points: a
        }), this._setCommon(u, e, r);
      }
    }, n.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, n.prototype._create = function() {
      var t = new Xct({
        cursor: "default"
      });
      return t.ignoreCoarsePointer = true, this.group.add(t), this._newAdded.push(t), t;
    }, n.prototype._setCommon = function(t, e, r) {
      var i = e.hostModel;
      r = r || {};
      var a = e.getVisual("symbolSize");
      t.setShape("size", a instanceof Array ? a : [
        a,
        a
      ]), t.softClipShape = r.clipShape || null, t.symbolProxy = Fn(e.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
      var s = t.shape.size[0] < $6;
      t.useStyle(i.getModel("itemStyle").getItemStyle(s ? [
        "color",
        "shadowBlur",
        "shadowColor"
      ] : [
        "color"
      ]));
      var o = e.getVisual("style"), l = o && o.fill;
      l && t.setColor(l);
      var u = Ut(t);
      u.seriesIndex = i.seriesIndex, t.on("mousemove", function(c) {
        u.dataIndex = null;
        var h = t.hoverDataIdx;
        h >= 0 && (u.dataIndex = h + (t.startIndex || 0));
      });
    }, n.prototype.remove = function() {
      this._clear();
    }, n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, n;
  }(), qct = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = e.getData(), s = this._updateSymbolDraw(a, e);
      s.updateData(a, {
        clipShape: this._getClipShape(e)
      }), this._finished = true;
    }, t.prototype.incrementalPrepareRender = function(e, r, i) {
      var a = e.getData(), s = this._updateSymbolDraw(a, e);
      s.incrementalPrepareUpdate(a), this._finished = false;
    }, t.prototype.incrementalRender = function(e, r, i) {
      this._symbolDraw.incrementalUpdate(e, r.getData(), {
        clipShape: this._getClipShape(r)
      }), this._finished = e.end === r.getData().count();
    }, t.prototype.updateTransform = function(e, r, i) {
      var a = e.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4) return {
        update: true
      };
      var s = Xv("").reset(e, r, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, t.prototype.eachRendered = function(e) {
      this._symbolDraw && this._symbolDraw.eachRendered(e);
    }, t.prototype._getClipShape = function(e) {
      if (e.get("clip", true)) {
        var r = e.coordinateSystem;
        return r && r.getArea && r.getArea(0.1);
      }
    }, t.prototype._updateSymbolDraw = function(e, r) {
      var i = this._symbolDraw, a = r.pipelineContext, s = a.large;
      return (!i || s !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = s ? new Yct() : new Uv(), this._isLargeDraw = s, this.group.removeAll()), this.group.add(i.group), i;
    }, t.prototype.remove = function(e, r) {
      this._symbolDraw && this._symbolDraw.remove(true), this._symbolDraw = null;
    }, t.prototype.dispose = function() {
    }, t.type = "scatter", t;
  }(qe), jct = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.type = "grid", t.dependencies = [
      "xAxis",
      "yAxis"
    ], t.layoutMode = "box", t.defaultOption = {
      show: false,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      containLabel: false,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, t;
  }(pe), wA = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", On).models[0];
    }, t.type = "cartesian2dAxis", t;
  }(pe);
  zn(wA, Gv);
  var O6 = {
    show: true,
    z: 0,
    inverse: false,
    name: "",
    nameLocation: "end",
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: "...",
      placeholder: "."
    },
    nameTextStyle: {},
    nameGap: 15,
    silent: false,
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: "#6E7079",
        width: 1,
        type: "solid"
      },
      symbol: [
        "none",
        "none"
      ],
      symbolSize: [
        10,
        15
      ]
    },
    axisTick: {
      show: true,
      inside: false,
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      inside: false,
      rotate: 0,
      showMinLabel: null,
      showMaxLabel: null,
      margin: 8,
      fontSize: 12
    },
    splitLine: {
      show: true,
      showMinLine: true,
      showMaxLine: true,
      lineStyle: {
        color: [
          "#E0E6F1"
        ],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: [
          "rgba(250,250,250,0.2)",
          "rgba(210,219,238,0.2)"
        ]
      }
    }
  }, Kct = Zt({
    boundaryGap: true,
    deduplication: null,
    splitLine: {
      show: false
    },
    axisTick: {
      alignWithLabel: false,
      interval: "auto"
    },
    axisLabel: {
      interval: "auto"
    }
  }, O6), BD = Zt({
    boundaryGap: [
      0,
      0
    ],
    axisLine: {
      show: "auto"
    },
    axisTick: {
      show: "auto"
    },
    splitNumber: 5,
    minorTick: {
      show: false,
      splitNumber: 5,
      length: 3,
      lineStyle: {}
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: "#F4F7FD",
        width: 1
      }
    }
  }, O6), Zct = Zt({
    splitNumber: 6,
    axisLabel: {
      showMinLabel: false,
      showMaxLabel: false,
      rich: {
        primary: {
          fontWeight: "bold"
        }
      }
    },
    splitLine: {
      show: false
    }
  }, BD), Jct = $t({
    logBase: 10
  }, BD);
  const F6 = {
    category: Kct,
    value: BD,
    time: Zct,
    log: Jct
  };
  var Qct = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
  };
  function Yf(n, t, e, r) {
    P(Qct, function(i, a) {
      var s = Zt(Zt({}, F6[a], true), r, true), o = function(l) {
        q(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = t + "Axis." + a, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, h) {
          var f = Vg(this), d = f ? Td(c) : {}, p = h.getTheme();
          Zt(c, p.get(a + "Axis")), Zt(c, this.getDefaultOption()), c.type = EO(c), f && jl(c, d, f);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = gA.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var h = this.option;
          if (h.type === "category") return c ? h.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = t + "Axis." + a, u.defaultOption = s, u;
      }(e);
      n.registerComponentModel(o);
    }), n.registerSubTypeDefaulter(t + "Axis", EO);
  }
  function EO(n) {
    return n.type || (n.data ? "category" : "value");
  }
  var tht = function() {
    function n(t) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || "";
    }
    return n.prototype.getAxis = function(t) {
      return this._axes[t];
    }, n.prototype.getAxes = function() {
      return ht(this._dimList, function(t) {
        return this._axes[t];
      }, this);
    }, n.prototype.getAxesByScale = function(t) {
      return t = t.toLowerCase(), Le(this.getAxes(), function(e) {
        return e.scale.type === t;
      });
    }, n.prototype.addAxis = function(t) {
      var e = t.dim;
      this._axes[e] = t, this._dimList.push(e);
    }, n;
  }(), SA = [
    "x",
    "y"
  ];
  function MO(n) {
    return n.type === "interval" || n.type === "time";
  }
  var eht = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = "cartesian2d", e.dimensions = SA, e;
    }
    return t.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var e = this.getAxis("x").scale, r = this.getAxis("y").scale;
      if (!(!MO(e) || !MO(r))) {
        var i = e.getExtent(), a = r.getExtent(), s = this.dataToPoint([
          i[0],
          a[0]
        ]), o = this.dataToPoint([
          i[1],
          a[1]
        ]), l = i[1] - i[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var c = (o[0] - s[0]) / l, h = (o[1] - s[1]) / u, f = s[0] - i[0] * c, d = s[1] - a[0] * h, p = this._transform = [
            c,
            0,
            0,
            h,
            f,
            d
          ];
          this._invTransform = yd([], p);
        }
      }
    }, t.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, t.prototype.containPoint = function(e) {
      var r = this.getAxis("x"), i = this.getAxis("y");
      return r.contain(r.toLocalCoord(e[0])) && i.contain(i.toLocalCoord(e[1]));
    }, t.prototype.containData = function(e) {
      return this.getAxis("x").containData(e[0]) && this.getAxis("y").containData(e[1]);
    }, t.prototype.containZone = function(e, r) {
      var i = this.dataToPoint(e), a = this.dataToPoint(r), s = this.getArea(), o = new te(i[0], i[1], a[0] - i[0], a[1] - i[1]);
      return s.intersect(o);
    }, t.prototype.dataToPoint = function(e, r, i) {
      i = i || [];
      var a = e[0], s = e[1];
      if (this._transform && a != null && isFinite(a) && s != null && isFinite(s)) return Tr(i, e, this._transform);
      var o = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = o.toGlobalCoord(o.dataToCoord(a, r)), i[1] = l.toGlobalCoord(l.dataToCoord(s, r)), i;
    }, t.prototype.clampData = function(e, r) {
      var i = this.getAxis("x").scale, a = this.getAxis("y").scale, s = i.getExtent(), o = a.getExtent(), l = i.parse(e[0]), u = a.parse(e[1]);
      return r = r || [], r[0] = Math.min(Math.max(Math.min(s[0], s[1]), l), Math.max(s[0], s[1])), r[1] = Math.min(Math.max(Math.min(o[0], o[1]), u), Math.max(o[0], o[1])), r;
    }, t.prototype.pointToData = function(e, r) {
      var i = [];
      if (this._invTransform) return Tr(i, e, this._invTransform);
      var a = this.getAxis("x"), s = this.getAxis("y");
      return i[0] = a.coordToData(a.toLocalCoord(e[0]), r), i[1] = s.coordToData(s.toLocalCoord(e[1]), r), i;
    }, t.prototype.getOtherAxis = function(e) {
      return this.getAxis(e.dim === "x" ? "y" : "x");
    }, t.prototype.getArea = function(e) {
      e = e || 0;
      var r = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(r[0], r[1]) - e, s = Math.min(i[0], i[1]) - e, o = Math.max(r[0], r[1]) - a + e, l = Math.max(i[0], i[1]) - s + e;
      return new te(a, s, o, l);
    }, t;
  }(tht), nht = function(n) {
    q(t, n);
    function t(e, r, i, a, s) {
      var o = n.call(this, e, r, i) || this;
      return o.index = 0, o.type = a || "value", o.position = s || "bottom", o;
    }
    return t.prototype.isHorizontal = function() {
      var e = this.position;
      return e === "top" || e === "bottom";
    }, t.prototype.getGlobalExtent = function(e) {
      var r = this.getExtent();
      return r[0] = this.toGlobalCoord(r[0]), r[1] = this.toGlobalCoord(r[1]), e && r[0] > r[1] && r.reverse(), r;
    }, t.prototype.pointToData = function(e, r) {
      return this.coordToData(this.toLocalCoord(e[this.dim === "x" ? 0 : 1]), r);
    }, t.prototype.setCategorySortInfo = function(e) {
      if (this.type !== "category") return false;
      this.model.option.categorySortInfo = e, this.scale.setSortInfo(e);
    }, t;
  }(ds);
  function CA(n, t, e) {
    e = e || {};
    var r = n.coordinateSystem, i = t.axis, a = {}, s = i.getAxesOnZeroOf()[0], o = i.position, l = s ? "onZero" : o, u = i.dim, c = r.getRect(), h = [
      c.x,
      c.x + c.width,
      c.y,
      c.y + c.height
    ], f = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    }, d = t.get("offset") || 0, p = u === "x" ? [
      h[2] - d,
      h[3] + d
    ] : [
      h[0] - d,
      h[1] + d
    ];
    if (s) {
      var g = s.toGlobalCoord(s.dataToCoord(0));
      p[f.onZero] = Math.max(Math.min(g, p[1]), p[0]);
    }
    a.position = [
      u === "y" ? p[f[l]] : h[0],
      u === "x" ? p[f[l]] : h[3]
    ], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
    var v = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    a.labelDirection = a.tickDirection = a.nameDirection = v[o], a.labelOffset = s ? p[f[o]] - p[f.onZero] : 0, t.get([
      "axisTick",
      "inside"
    ]) && (a.tickDirection = -a.tickDirection), mr(e.labelInside, t.get([
      "axisLabel",
      "inside"
    ])) && (a.labelDirection = -a.labelDirection);
    var m = t.get([
      "axisLabel",
      "rotate"
    ]);
    return a.labelRotate = l === "top" ? -m : m, a.z2 = 1, a;
  }
  function RO(n) {
    return n.get("coordinateSystem") === "cartesian2d";
  }
  function NO(n) {
    var t = {
      xAxisModel: null,
      yAxisModel: null
    };
    return P(t, function(e, r) {
      var i = r.replace(/Model$/, ""), a = n.getReferringComponents(i, On).models[0];
      t[r] = a;
    }), t;
  }
  var sC = Math.log;
  function B6(n, t, e) {
    var r = Uo.prototype, i = r.getTicks.call(e), a = r.getTicks.call(e, true), s = i.length - 1, o = r.getInterval.call(e), l = GH(n, t), u = l.extent, c = l.fixMin, h = l.fixMax;
    if (n.type === "log") {
      var f = sC(n.base);
      u = [
        sC(u[0]) / f,
        sC(u[1]) / f
      ];
    }
    n.setExtent(u[0], u[1]), n.calcNiceExtent({
      splitNumber: s,
      fixMin: c,
      fixMax: h
    });
    var d = r.getExtent.call(n);
    c && (u[0] = d[0]), h && (u[1] = d[1]);
    var p = r.getInterval.call(n), g = u[0], v = u[1];
    if (c && h) p = (v - g) / s;
    else if (c) for (v = u[0] + p * s; v < u[1] && isFinite(v) && isFinite(u[1]); ) p = HS(p), v = u[0] + p * s;
    else if (h) for (g = u[1] - p * s; g > u[0] && isFinite(g) && isFinite(u[0]); ) p = HS(p), g = u[1] - p * s;
    else {
      var m = n.getTicks().length - 1;
      m > s && (p = HS(p));
      var y = p * s;
      v = Math.ceil(u[1] / p) * p, g = Cn(v - y), g < 0 && u[0] >= 0 ? (g = 0, v = Cn(y)) : v > 0 && u[1] <= 0 && (v = 0, g = -Cn(y));
    }
    var x = (i[0].value - a[0].value) / o, b = (i[s].value - a[s].value) / o;
    r.setExtent.call(n, g + p * x, v + p * b), r.setInterval.call(n, p), (x || b) && r.setNiceExtent.call(n, g + p, v - p);
  }
  var rht = function() {
    function n(t, e, r) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = true, this.dimensions = SA, this._initCartesian(t, e, r), this.model = t;
    }
    return n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype.update = function(t, e) {
      var r = this._axesMap;
      this._updateScale(t, this.model);
      function i(s) {
        var o, l = ge(s), u = l.length;
        if (u) {
          for (var c = [], h = u - 1; h >= 0; h--) {
            var f = +l[h], d = s[f], p = d.model, g = d.scale;
            vA(g) && p.get("alignTicks") && p.get("interval") == null ? c.push(d) : (Hf(g, p), vA(g) && (o = d));
          }
          c.length && (o || (o = c.pop(), Hf(o.scale, o.model)), P(c, function(v) {
            B6(v.scale, v.model, o.scale);
          }));
        }
      }
      i(r.x), i(r.y);
      var a = {};
      P(r.x, function(s) {
        LO(r, "y", s, a);
      }), P(r.y, function(s) {
        LO(r, "x", s, a);
      }), this.resize(this.model, e);
    }, n.prototype.resize = function(t, e, r) {
      var i = t.getBoxLayoutParams(), a = !r && t.get("containLabel"), s = Zn(i, {
        width: e.getWidth(),
        height: e.getHeight()
      });
      this._rect = s;
      var o = this._axesList;
      l(), a && (P(o, function(u) {
        if (!u.model.get([
          "axisLabel",
          "inside"
        ])) {
          var c = Olt(u);
          if (c) {
            var h = u.isHorizontal() ? "height" : "width", f = u.model.get([
              "axisLabel",
              "margin"
            ]);
            s[h] -= c[h] + f, u.position === "top" ? s.y += c.height + f : u.position === "left" && (s.x += c.width + f);
          }
        }
      }), l()), P(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        P(o, function(u) {
          var c = u.isHorizontal(), h = c ? [
            0,
            s.width
          ] : [
            0,
            s.height
          ], f = u.inverse ? 1 : 0;
          u.setExtent(h[f], h[1 - f]), iht(u, c ? s.x : s.y);
        });
      }
    }, n.prototype.getAxis = function(t, e) {
      var r = this._axesMap[t];
      if (r != null) return r[e || 0];
    }, n.prototype.getAxes = function() {
      return this._axesList.slice();
    }, n.prototype.getCartesian = function(t, e) {
      if (t != null && e != null) {
        var r = "x" + t + "y" + e;
        return this._coordsMap[r];
      }
      Ft(t) && (e = t.yAxisIndex, t = t.xAxisIndex);
      for (var i = 0, a = this._coordsList; i < a.length; i++) if (a[i].getAxis("x").index === t || a[i].getAxis("y").index === e) return a[i];
    }, n.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, n.prototype.convertToPixel = function(t, e, r) {
      var i = this._findConvertTarget(e);
      return i.cartesian ? i.cartesian.dataToPoint(r) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(r)) : null;
    }, n.prototype.convertFromPixel = function(t, e, r) {
      var i = this._findConvertTarget(e);
      return i.cartesian ? i.cartesian.pointToData(r) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(r)) : null;
    }, n.prototype._findConvertTarget = function(t) {
      var e = t.seriesModel, r = t.xAxisModel || e && e.getReferringComponents("xAxis", On).models[0], i = t.yAxisModel || e && e.getReferringComponents("yAxis", On).models[0], a = t.gridModel, s = this._coordsList, o, l;
      if (e) o = e.coordinateSystem, ne(s, o) < 0 && (o = null);
      else if (r && i) o = this.getCartesian(r.componentIndex, i.componentIndex);
      else if (r) l = this.getAxis("x", r.componentIndex);
      else if (i) l = this.getAxis("y", i.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (o = this._coordsList[0]);
      }
      return {
        cartesian: o,
        axis: l
      };
    }, n.prototype.containPoint = function(t) {
      var e = this._coordsList[0];
      if (e) return e.containPoint(t);
    }, n.prototype._initCartesian = function(t, e, r) {
      var i = this, a = this, s = {
        left: false,
        right: false,
        top: false,
        bottom: false
      }, o = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (e.eachComponent("xAxis", u("x"), this), e.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = o, P(o.x, function(c, h) {
        P(o.y, function(f, d) {
          var p = "x" + h + "y" + d, g = new eht(p);
          g.master = i, g.model = t, i._coordsMap[p] = g, i._coordsList.push(g), g.addAxis(c), g.addAxis(f);
        });
      });
      function u(c) {
        return function(h, f) {
          if (oC(h, t)) {
            var d = h.get("position");
            c === "x" ? d !== "top" && d !== "bottom" && (d = s.bottom ? "top" : "bottom") : d !== "left" && d !== "right" && (d = s.left ? "right" : "left"), s[d] = true;
            var p = new nht(c, X1(h), [
              0,
              0
            ], h.get("type"), d), g = p.type === "category";
            p.onBand = g && h.get("boundaryGap"), p.inverse = h.get("inverse"), h.axis = p, p.model = h, p.grid = a, p.index = f, a._axesList.push(p), o[c][f] = p, l[c]++;
          }
        };
      }
    }, n.prototype._updateScale = function(t, e) {
      P(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var a = i.model.get("categorySortInfo");
          i.scale.setSortInfo(a);
        }
      }), t.eachSeries(function(i) {
        if (RO(i)) {
          var a = NO(i), s = a.xAxisModel, o = a.yAxisModel;
          if (!oC(s, e) || !oC(o, e)) return;
          var l = this.getCartesian(s.componentIndex, o.componentIndex), u = i.getData(), c = l.getAxis("x"), h = l.getAxis("y");
          r(u, c), r(u, h);
        }
      }, this);
      function r(i, a) {
        P(sb(i, a.dim), function(s) {
          a.scale.unionExtentFromData(i, s);
        });
      }
    }, n.prototype.getTooltipAxes = function(t) {
      var e = [], r = [];
      return P(this.getCartesians(), function(i) {
        var a = t != null && t !== "auto" ? i.getAxis(t) : i.getBaseAxis(), s = i.getOtherAxis(a);
        ne(e, a) < 0 && e.push(a), ne(r, s) < 0 && r.push(s);
      }), {
        baseAxes: e,
        otherAxes: r
      };
    }, n.create = function(t, e) {
      var r = [];
      return t.eachComponent("grid", function(i, a) {
        var s = new n(i, t, e);
        s.name = "grid_" + a, s.resize(i, e, true), i.coordinateSystem = s, r.push(s);
      }), t.eachSeries(function(i) {
        if (RO(i)) {
          var a = NO(i), s = a.xAxisModel, o = a.yAxisModel, l = s.getCoordSysModel(), u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(s.componentIndex, o.componentIndex);
        }
      }), r;
    }, n.dimensions = SA, n;
  }();
  function oC(n, t) {
    return n.getCoordSysModel() === t;
  }
  function LO(n, t, e, r) {
    e.getAxesOnZeroOf = function() {
      return a ? [
        a
      ] : [];
    };
    var i = n[t], a, s = e.model, o = s.get([
      "axisLine",
      "onZero"
    ]), l = s.get([
      "axisLine",
      "onZeroAxisIndex"
    ]);
    if (!o) return;
    if (l != null) PO(i[l]) && (a = i[l]);
    else for (var u in i) if (i.hasOwnProperty(u) && PO(i[u]) && !r[c(i[u])]) {
      a = i[u];
      break;
    }
    a && (r[c(a)] = true);
    function c(h) {
      return h.dim + "_" + h.index;
    }
  }
  function PO(n) {
    return n && n.type !== "category" && n.type !== "time" && $lt(n);
  }
  function iht(n, t) {
    var e = n.getExtent(), r = e[0] + e[1];
    n.toGlobalCoord = n.dim === "x" ? function(i) {
      return i + t;
    } : function(i) {
      return r - i + t;
    }, n.toLocalCoord = n.dim === "x" ? function(i) {
      return i - t;
    } : function(i) {
      return r - i + t;
    };
  }
  var Dl = Math.PI, di = function() {
    function n(t, e) {
      this.group = new Vt(), this.opt = e, this.axisModel = t, $t(e, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true,
        handleAutoShown: function() {
          return true;
        }
      });
      var r = new Vt({
        x: e.position[0],
        y: e.position[1],
        rotation: e.rotation
      });
      r.updateTransform(), this._transformGroup = r;
    }
    return n.prototype.hasBuilder = function(t) {
      return !!$O[t];
    }, n.prototype.add = function(t) {
      $O[t](this.opt, this.axisModel, this.group, this._transformGroup);
    }, n.prototype.getGroup = function() {
      return this.group;
    }, n.innerTextLayout = function(t, e, r) {
      var i = nU(e - t), a, s;
      return Pg(i) ? (s = r > 0 ? "top" : "bottom", a = "center") : Pg(i - Dl) ? (s = r > 0 ? "bottom" : "top", a = "center") : (s = "middle", i > 0 && i < Dl ? a = r > 0 ? "right" : "left" : a = r > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: a,
        textVerticalAlign: s
      };
    }, n.makeAxisEventDataBase = function(t) {
      var e = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return e[t.mainType + "Index"] = t.componentIndex, e;
    }, n.isLabelSilent = function(t) {
      var e = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || e && e.show);
    }, n;
  }(), $O = {
    axisLine: function(n, t, e, r) {
      var i = t.get([
        "axisLine",
        "show"
      ]);
      if (i === "auto" && n.handleAutoShown && (i = n.handleAutoShown("axisLine")), !!i) {
        var a = t.axis.getExtent(), s = r.transform, o = [
          a[0],
          0
        ], l = [
          a[1],
          0
        ], u = o[0] > l[0];
        s && (Tr(o, o, s), Tr(l, l, s));
        var c = rt({
          lineCap: "round"
        }, t.getModel([
          "axisLine",
          "lineStyle"
        ]).getLineStyle()), h = new ir({
          shape: {
            x1: o[0],
            y1: o[1],
            x2: l[0],
            y2: l[1]
          },
          style: c,
          strokeContainThreshold: n.strokeContainThreshold || 5,
          silent: true,
          z2: 1
        });
        Gf(h.shape, h.style.lineWidth), h.anid = "line", e.add(h);
        var f = t.get([
          "axisLine",
          "symbol"
        ]);
        if (f != null) {
          var d = t.get([
            "axisLine",
            "symbolSize"
          ]);
          wt(f) && (f = [
            f,
            f
          ]), (wt(d) || _e(d)) && (d = [
            d,
            d
          ]);
          var p = gh(t.get([
            "axisLine",
            "symbolOffset"
          ]) || 0, d), g = d[0], v = d[1];
          P([
            {
              rotate: n.rotation + Math.PI / 2,
              offset: p[0],
              r: 0
            },
            {
              rotate: n.rotation - Math.PI / 2,
              offset: p[1],
              r: Math.sqrt((o[0] - l[0]) * (o[0] - l[0]) + (o[1] - l[1]) * (o[1] - l[1]))
            }
          ], function(m, y) {
            if (f[y] !== "none" && f[y] != null) {
              var x = Fn(f[y], -g / 2, -v / 2, g, v, c.stroke, true), b = m.r + m.offset, _ = u ? l : o;
              x.attr({
                rotation: m.rotate,
                x: _[0] + b * Math.cos(n.rotation),
                y: _[1] - b * Math.sin(n.rotation),
                silent: true,
                z2: 11
              }), e.add(x);
            }
          });
        }
      }
    },
    axisTickLabel: function(n, t, e, r) {
      var i = oht(e, r, t, n), a = uht(e, r, t, n);
      if (sht(t, a, i), lht(e, r, t, n.tickDirection), t.get([
        "axisLabel",
        "hideOverlap"
      ])) {
        var s = n6(ht(a, function(o) {
          return {
            label: o,
            priority: o.z2,
            defaultAttr: {
              ignore: o.ignore
            }
          };
        }));
        a6(s);
      }
    },
    axisName: function(n, t, e, r) {
      var i = mr(n.axisName, t.get("name"));
      if (i) {
        var a = t.get("nameLocation"), s = n.nameDirection, o = t.getModel("nameTextStyle"), l = t.get("nameGap") || 0, u = t.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, h = [
          a === "start" ? u[0] - c * l : a === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
          FO(a) ? n.labelOffset + s * l : 0
        ], f, d = t.get("nameRotate");
        d != null && (d = d * Dl / 180);
        var p;
        FO(a) ? f = di.innerTextLayout(n.rotation, d ?? n.rotation, s) : (f = aht(n.rotation, a, d || 0, u), p = n.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(f.rotation)), !isFinite(p) && (p = null)));
        var g = o.getFont(), v = t.get("nameTruncate", true) || {}, m = v.ellipsis, y = mr(n.nameTruncateMaxWidth, v.maxWidth, p), x = new be({
          x: h[0],
          y: h[1],
          rotation: f.rotation,
          silent: di.isLabelSilent(t),
          style: nn(o, {
            text: i,
            font: g,
            overflow: "truncate",
            width: y,
            ellipsis: m,
            fill: o.getTextColor() || t.get([
              "axisLine",
              "lineStyle",
              "color"
            ]),
            align: o.get("align") || f.textAlign,
            verticalAlign: o.get("verticalAlign") || f.textVerticalAlign
          }),
          z2: 1
        });
        if (dh({
          el: x,
          componentModel: t,
          itemName: i
        }), x.__fullText = i, x.anid = "name", t.get("triggerEvent")) {
          var b = di.makeAxisEventDataBase(t);
          b.targetType = "axisName", b.name = i, Ut(x).eventData = b;
        }
        r.add(x), x.updateTransform(), e.add(x), x.decomposeTransform();
      }
    }
  };
  function aht(n, t, e, r) {
    var i = nU(e - n), a, s, o = r[0] > r[1], l = t === "start" && !o || t !== "start" && o;
    return Pg(i - Dl / 2) ? (s = l ? "bottom" : "top", a = "center") : Pg(i - Dl * 1.5) ? (s = l ? "top" : "bottom", a = "center") : (s = "middle", i < Dl * 1.5 && i > Dl / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
      rotation: i,
      textAlign: a,
      textVerticalAlign: s
    };
  }
  function sht(n, t, e) {
    if (!WH(n.axis)) {
      var r = n.get([
        "axisLabel",
        "showMinLabel"
      ]), i = n.get([
        "axisLabel",
        "showMaxLabel"
      ]);
      t = t || [], e = e || [];
      var a = t[0], s = t[1], o = t[t.length - 1], l = t[t.length - 2], u = e[0], c = e[1], h = e[e.length - 1], f = e[e.length - 2];
      r === false ? (ia(a), ia(u)) : OO(a, s) && (r ? (ia(s), ia(c)) : (ia(a), ia(u))), i === false ? (ia(o), ia(h)) : OO(l, o) && (i ? (ia(l), ia(f)) : (ia(o), ia(h)));
    }
  }
  function ia(n) {
    n && (n.ignore = true);
  }
  function OO(n, t) {
    var e = n && n.getBoundingRect().clone(), r = t && t.getBoundingRect().clone();
    if (!(!e || !r)) {
      var i = m1([]);
      return fh(i, i, -n.rotation), e.applyTransform(Ro([], i, n.getLocalTransform())), r.applyTransform(Ro([], i, t.getLocalTransform())), e.intersect(r);
    }
  }
  function FO(n) {
    return n === "middle" || n === "center";
  }
  function z6(n, t, e, r, i) {
    for (var a = [], s = [], o = [], l = 0; l < n.length; l++) {
      var u = n[l].coord;
      s[0] = u, s[1] = 0, o[0] = u, o[1] = e, t && (Tr(s, s, t), Tr(o, o, t));
      var c = new ir({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: o[0],
          y2: o[1]
        },
        style: r,
        z2: 2,
        autoBatch: true,
        silent: true
      });
      Gf(c.shape, c.style.lineWidth), c.anid = i + "_" + n[l].tickValue, a.push(c);
    }
    return a;
  }
  function oht(n, t, e, r) {
    var i = e.axis, a = e.getModel("axisTick"), s = a.get("show");
    if (s === "auto" && r.handleAutoShown && (s = r.handleAutoShown("axisTick")), !(!s || i.scale.isBlank())) {
      for (var o = a.getModel("lineStyle"), l = r.tickDirection * a.get("length"), u = i.getTicksCoords(), c = z6(u, t.transform, l, $t(o.getLineStyle(), {
        stroke: e.get([
          "axisLine",
          "lineStyle",
          "color"
        ])
      }), "ticks"), h = 0; h < c.length; h++) n.add(c[h]);
      return c;
    }
  }
  function lht(n, t, e, r) {
    var i = e.axis, a = e.getModel("minorTick");
    if (!(!a.get("show") || i.scale.isBlank())) {
      var s = i.getMinorTicksCoords();
      if (s.length) for (var o = a.getModel("lineStyle"), l = r * a.get("length"), u = $t(o.getLineStyle(), $t(e.getModel("axisTick").getLineStyle(), {
        stroke: e.get([
          "axisLine",
          "lineStyle",
          "color"
        ])
      })), c = 0; c < s.length; c++) for (var h = z6(s[c], t.transform, l, u, "minorticks_" + c), f = 0; f < h.length; f++) n.add(h[f]);
    }
  }
  function uht(n, t, e, r) {
    var i = e.axis, a = mr(r.axisLabelShow, e.get([
      "axisLabel",
      "show"
    ]));
    if (!(!a || i.scale.isBlank())) {
      var s = e.getModel("axisLabel"), o = s.get("margin"), l = i.getViewLabels(), u = (mr(r.labelRotate, s.get("rotate")) || 0) * Dl / 180, c = di.innerTextLayout(r.rotation, u, r.labelDirection), h = e.getCategories && e.getCategories(true), f = [], d = di.isLabelSilent(e), p = e.get("triggerEvent");
      return P(l, function(g, v) {
        var m = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(g.tickValue) : g.tickValue, y = g.formattedLabel, x = g.rawLabel, b = s;
        if (h && h[m]) {
          var _ = h[m];
          Ft(_) && _.textStyle && (b = new $e(_.textStyle, s, e.ecModel));
        }
        var w = b.getTextColor() || e.get([
          "axisLine",
          "lineStyle",
          "color"
        ]), S = i.dataToCoord(m), I = b.getShallow("align", true) || c.textAlign, T = Ht(b.getShallow("alignMinLabel", true), I), A = Ht(b.getShallow("alignMaxLabel", true), I), C = b.getShallow("verticalAlign", true) || b.getShallow("baseline", true) || c.textVerticalAlign, D = Ht(b.getShallow("verticalAlignMinLabel", true), C), E = Ht(b.getShallow("verticalAlignMaxLabel", true), C), M = new be({
          x: S,
          y: r.labelOffset + r.labelDirection * o,
          rotation: c.rotation,
          silent: d,
          z2: 10 + (g.level || 0),
          style: nn(b, {
            text: y,
            align: v === 0 ? T : v === l.length - 1 ? A : I,
            verticalAlign: v === 0 ? D : v === l.length - 1 ? E : C,
            fill: Nt(w) ? w(i.type === "category" ? x : i.type === "value" ? m + "" : m, v) : w
          })
        });
        if (M.anid = "label_" + m, dh({
          el: M,
          componentModel: e,
          itemName: y,
          formatterParamsExtra: {
            isTruncated: function() {
              return M.isTruncated;
            },
            value: x,
            tickIndex: v
          }
        }), p) {
          var L = di.makeAxisEventDataBase(e);
          L.targetType = "axisLabel", L.value = x, L.tickIndex = v, i.type === "category" && (L.dataIndex = m), Ut(M).eventData = L;
        }
        t.add(M), M.updateTransform(), f.push(M), n.add(M), M.decomposeTransform();
      }), f;
    }
  }
  function cht(n, t) {
    var e = {
      axesInfo: {},
      seriesInvolved: false,
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    return hht(e, n, t), e.seriesInvolved && dht(e, n), e;
  }
  function hht(n, t, e) {
    var r = t.getComponent("tooltip"), i = t.getComponent("axisPointer"), a = i.get("link", true) || [], s = [];
    P(e.getCoordinateSystems(), function(o) {
      if (!o.axisPointerEnabled) return;
      var l = Kg(o.model), u = n.coordSysAxesInfo[l] = {};
      n.coordSysMap[l] = o;
      var c = o.model, h = c.getModel("tooltip", r);
      if (P(o.getAxes(), qt(g, false, null)), o.getTooltipAxes && r && h.get("show")) {
        var f = h.get("trigger") === "axis", d = h.get([
          "axisPointer",
          "type"
        ]) === "cross", p = o.getTooltipAxes(h.get([
          "axisPointer",
          "axis"
        ]));
        (f || d) && P(p.baseAxes, qt(g, d ? "cross" : true, f)), d && P(p.otherAxes, qt(g, "cross", false));
      }
      function g(v, m, y) {
        var x = y.model.getModel("axisPointer", i), b = x.get("show");
        if (!(!b || b === "auto" && !v && !TA(x))) {
          m == null && (m = x.get("triggerTooltip")), x = v ? fht(y, h, i, t, v, m) : x;
          var _ = x.get("snap"), w = x.get("triggerEmphasis"), S = Kg(y.model), I = m || _ || y.type === "category", T = n.axesInfo[S] = {
            key: S,
            axis: y,
            coordSys: o,
            axisPointerModel: x,
            triggerTooltip: m,
            triggerEmphasis: w,
            involveSeries: I,
            snap: _,
            useHandle: TA(x),
            seriesModels: [],
            linkGroup: null
          };
          u[S] = T, n.seriesInvolved = n.seriesInvolved || I;
          var A = pht(a, y);
          if (A != null) {
            var C = s[A] || (s[A] = {
              axesInfo: {}
            });
            C.axesInfo[S] = T, C.mapper = a[A].mapper, T.linkGroup = C;
          }
        }
      }
    });
  }
  function fht(n, t, e, r, i, a) {
    var s = t.getModel("axisPointer"), o = [
      "type",
      "snap",
      "lineStyle",
      "shadowStyle",
      "label",
      "animation",
      "animationDurationUpdate",
      "animationEasingUpdate",
      "z"
    ], l = {};
    P(o, function(f) {
      l[f] = Bt(s.get(f));
    }), l.snap = n.type !== "category" && !!a, s.get("type") === "cross" && (l.type = "line");
    var u = l.label || (l.label = {});
    if (u.show == null && (u.show = false), i === "cross") {
      var c = s.get([
        "label",
        "show"
      ]);
      if (u.show = c ?? true, !a) {
        var h = l.lineStyle = s.get("crossStyle");
        h && $t(u, h.textStyle);
      }
    }
    return n.model.getModel("axisPointer", new $e(l, e, r));
  }
  function dht(n, t) {
    t.eachSeries(function(e) {
      var r = e.coordinateSystem, i = e.get([
        "tooltip",
        "trigger"
      ], true), a = e.get([
        "tooltip",
        "show"
      ], true);
      !r || i === "none" || i === false || i === "item" || a === false || e.get([
        "axisPointer",
        "show"
      ], true) === false || P(n.coordSysAxesInfo[Kg(r.model)], function(s) {
        var o = s.axis;
        r.getAxis(o.dim) === o && (s.seriesModels.push(e), s.seriesDataCount == null && (s.seriesDataCount = 0), s.seriesDataCount += e.getData().count());
      });
    });
  }
  function pht(n, t) {
    for (var e = t.model, r = t.dim, i = 0; i < n.length; i++) {
      var a = n[i] || {};
      if (lC(a[r + "AxisId"], e.id) || lC(a[r + "AxisIndex"], e.componentIndex) || lC(a[r + "AxisName"], e.name)) return i;
    }
  }
  function lC(n, t) {
    return n === "all" || ct(n) && ne(n, t) >= 0 || n === t;
  }
  function ght(n) {
    var t = zD(n);
    if (t) {
      var e = t.axisPointerModel, r = t.axis.scale, i = e.option, a = e.get("status"), s = e.get("value");
      s != null && (s = r.parse(s));
      var o = TA(e);
      a == null && (i.status = o ? "show" : "hide");
      var l = r.getExtent().slice();
      l[0] > l[1] && l.reverse(), (s == null || s > l[1]) && (s = l[1]), s < l[0] && (s = l[0]), i.value = s, o && (i.status = t.axis.scale.isBlank() ? "hide" : "show");
    }
  }
  function zD(n) {
    var t = (n.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return t && t.axesInfo[Kg(n)];
  }
  function vht(n) {
    var t = zD(n);
    return t && t.axisPointerModel;
  }
  function TA(n) {
    return !!n.get([
      "handle",
      "show"
    ]);
  }
  function Kg(n) {
    return n.type + "||" + n.id;
  }
  var BO = {}, yh = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i, a) {
      this.axisPointerClass && ght(e), n.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(e, i, true);
    }, t.prototype.updateAxisPointer = function(e, r, i, a) {
      this._doUpdateAxisPointerClass(e, i, false);
    }, t.prototype.remove = function(e, r) {
      var i = this._axisPointer;
      i && i.remove(r);
    }, t.prototype.dispose = function(e, r) {
      this._disposeAxisPointer(r), n.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(e, r, i) {
      var a = t.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var s = vht(e);
        s ? (this._axisPointer || (this._axisPointer = new a())).render(e, s, r, i) : this._disposeAxisPointer(r);
      }
    }, t.prototype._disposeAxisPointer = function(e) {
      this._axisPointer && this._axisPointer.dispose(e), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(e, r) {
      BO[e] = r;
    }, t.getAxisPointerClass = function(e) {
      return e && BO[e];
    }, t.type = "axis", t;
  }(vn), IA = xe();
  function V6(n, t, e, r) {
    var i = e.axis;
    if (!i.scale.isBlank()) {
      var a = e.getModel("splitArea"), s = a.getModel("areaStyle"), o = s.get("color"), l = r.coordinateSystem.getRect(), u = i.getTicksCoords({
        tickModel: a,
        clamp: true
      });
      if (u.length) {
        var c = o.length, h = IA(n).splitAreaColors, f = It(), d = 0;
        if (h) for (var p = 0; p < u.length; p++) {
          var g = h.get(u[p].tickValue);
          if (g != null) {
            d = (g + (c - 1) * p) % c;
            break;
          }
        }
        var v = i.toGlobalCoord(u[0].coord), m = s.getAreaStyle();
        o = ct(o) ? o : [
          o
        ];
        for (var p = 1; p < u.length; p++) {
          var y = i.toGlobalCoord(u[p].coord), x = void 0, b = void 0, _ = void 0, w = void 0;
          i.isHorizontal() ? (x = v, b = l.y, _ = y - x, w = l.height, v = x + _) : (x = l.x, b = v, _ = l.width, w = y - b, v = b + w);
          var S = u[p - 1].tickValue;
          S != null && f.set(S, d), t.add(new ye({
            anid: S != null ? "area_" + S : null,
            shape: {
              x,
              y: b,
              width: _,
              height: w
            },
            style: $t({
              fill: o[d]
            }, m),
            autoBatch: true,
            silent: true
          })), d = (d + 1) % c;
        }
        IA(n).splitAreaColors = f;
      }
    }
  }
  function G6(n) {
    IA(n).splitAreaColors = null;
  }
  var mht = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], yht = [
    "splitArea",
    "splitLine",
    "minorSplitLine"
  ], W6 = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "CartesianAxisPointer", e;
    }
    return t.prototype.render = function(e, r, i, a) {
      this.group.removeAll();
      var s = this._axisGroup;
      if (this._axisGroup = new Vt(), this.group.add(this._axisGroup), !!e.get("show")) {
        var o = e.getCoordSysModel(), l = CA(o, e), u = new di(e, rt({
          handleAutoShown: function(h) {
            for (var f = o.coordinateSystem.getCartesians(), d = 0; d < f.length; d++) if (vA(f[d].getOtherAxis(e.axis).scale)) return true;
            return false;
          }
        }, l));
        P(mht, u.add, u), this._axisGroup.add(u.getGroup()), P(yht, function(h) {
          e.get([
            h,
            "show"
          ]) && xht[h](this, this._axisGroup, e, o);
        }, this);
        var c = a && a.type === "changeAxisOrder" && a.isInitSort;
        c || Ov(s, this._axisGroup, e), n.prototype.render.call(this, e, r, i, a);
      }
    }, t.prototype.remove = function() {
      G6(this);
    }, t.type = "cartesianAxis", t;
  }(yh), xht = {
    splitLine: function(n, t, e, r) {
      var i = e.axis;
      if (!i.scale.isBlank()) {
        var a = e.getModel("splitLine"), s = a.getModel("lineStyle"), o = s.get("color"), l = a.get("showMinLine") !== false, u = a.get("showMaxLine") !== false;
        o = ct(o) ? o : [
          o
        ];
        for (var c = r.coordinateSystem.getRect(), h = i.isHorizontal(), f = 0, d = i.getTicksCoords({
          tickModel: a
        }), p = [], g = [], v = s.getLineStyle(), m = 0; m < d.length; m++) {
          var y = i.toGlobalCoord(d[m].coord);
          if (!(m === 0 && !l || m === d.length - 1 && !u)) {
            var x = d[m].tickValue;
            h ? (p[0] = y, p[1] = c.y, g[0] = y, g[1] = c.y + c.height) : (p[0] = c.x, p[1] = y, g[0] = c.x + c.width, g[1] = y);
            var b = f++ % o.length, _ = new ir({
              anid: x != null ? "line_" + x : null,
              autoBatch: true,
              shape: {
                x1: p[0],
                y1: p[1],
                x2: g[0],
                y2: g[1]
              },
              style: $t({
                stroke: o[b]
              }, v),
              silent: true
            });
            Gf(_.shape, v.lineWidth), t.add(_);
          }
        }
      }
    },
    minorSplitLine: function(n, t, e, r) {
      var i = e.axis, a = e.getModel("minorSplitLine"), s = a.getModel("lineStyle"), o = r.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
      if (u.length) for (var c = [], h = [], f = s.getLineStyle(), d = 0; d < u.length; d++) for (var p = 0; p < u[d].length; p++) {
        var g = i.toGlobalCoord(u[d][p].coord);
        l ? (c[0] = g, c[1] = o.y, h[0] = g, h[1] = o.y + o.height) : (c[0] = o.x, c[1] = g, h[0] = o.x + o.width, h[1] = g);
        var v = new ir({
          anid: "minor_line_" + u[d][p].tickValue,
          autoBatch: true,
          shape: {
            x1: c[0],
            y1: c[1],
            x2: h[0],
            y2: h[1]
          },
          style: f,
          silent: true
        });
        Gf(v.shape, f.lineWidth), t.add(v);
      }
    },
    splitArea: function(n, t, e, r) {
      V6(n, t, e, r);
    }
  }, U6 = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "xAxis", t;
  }(W6), bht = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = U6.type, e;
    }
    return t.type = "yAxis", t;
  }(W6), _ht = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = "grid", e;
    }
    return t.prototype.render = function(e, r) {
      this.group.removeAll(), e.get("show") && this.group.add(new ye({
        shape: e.coordinateSystem.getRect(),
        style: $t({
          fill: e.get("backgroundColor")
        }, e.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }, t.type = "grid", t;
  }(vn), zO = {
    offset: 0
  };
  function H6(n) {
    n.registerComponentView(_ht), n.registerComponentModel(jct), n.registerCoordinateSystem("cartesian2d", rht), Yf(n, "x", wA, zO), Yf(n, "y", wA, zO), n.registerComponentView(U6), n.registerComponentView(bht), n.registerPreprocessor(function(t) {
      t.xAxis && t.yAxis && !t.grid && (t.grid = {});
    });
  }
  function wht(n) {
    se(H6), n.registerSeriesModel(Uct), n.registerChartView(qct), n.registerLayout(Xv("scatter"));
  }
  function Sht(n) {
    n.eachSeriesByType("radar", function(t) {
      var e = t.getData(), r = [], i = t.coordinateSystem;
      if (i) {
        var a = i.getIndicatorAxes();
        P(a, function(s, o) {
          e.each(e.mapDimension(a[o].dim), function(l, u) {
            r[u] = r[u] || [];
            var c = i.dataToPoint(l, o);
            r[u][o] = VO(c) ? c : GO(i);
          });
        }), e.each(function(s) {
          var o = ret(r[s], function(l) {
            return VO(l);
          }) || GO(i);
          r[s].push(o.slice()), e.setItemLayout(s, r[s]);
        });
      }
    });
  }
  function VO(n) {
    return !isNaN(n[0]) && !isNaN(n[1]);
  }
  function GO(n) {
    return [
      n.cx,
      n.cy
    ];
  }
  function Cht(n) {
    var t = n.polar;
    if (t) {
      ct(t) || (t = [
        t
      ]);
      var e = [];
      P(t, function(r, i) {
        r.indicator ? (r.type && !r.shape && (r.shape = r.type), n.radar = n.radar || [], ct(n.radar) || (n.radar = [
          n.radar
        ]), n.radar.push(r)) : e.push(r);
      }), n.polar = e;
    }
    P(n.series, function(r) {
      r && r.type === "radar" && r.polarIndex && (r.radarIndex = r.polarIndex);
    });
  }
  var Tht = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = e.coordinateSystem, s = this.group, o = e.getData(), l = this._data;
      function u(f, d) {
        var p = f.getItemVisual(d, "symbol") || "circle";
        if (p !== "none") {
          var g = Dd(f.getItemVisual(d, "symbolSize")), v = Fn(p, -1, -1, 2, 2), m = f.getItemVisual(d, "symbolRotate") || 0;
          return v.attr({
            style: {
              strokeNoScale: true
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: m * Math.PI / 180 || 0
          }), v;
        }
      }
      function c(f, d, p, g, v, m) {
        p.removeAll();
        for (var y = 0; y < d.length - 1; y++) {
          var x = u(g, v);
          x && (x.__dimIdx = y, f[y] ? (x.setPosition(f[y]), ph[m ? "initProps" : "updateProps"](x, {
            x: d[y][0],
            y: d[y][1]
          }, e, v)) : x.setPosition(d[y]), p.add(x));
        }
      }
      function h(f) {
        return ht(f, function(d) {
          return [
            a.cx,
            a.cy
          ];
        });
      }
      o.diff(l).add(function(f) {
        var d = o.getItemLayout(f);
        if (d) {
          var p = new yi(), g = new _i(), v = {
            shape: {
              points: d
            }
          };
          p.shape.points = h(d), g.shape.points = h(d), dn(p, v, e, f), dn(g, v, e, f);
          var m = new Vt(), y = new Vt();
          m.add(g), m.add(p), m.add(y), c(g.shape.points, d, y, o, f, true), o.setItemGraphicEl(f, m);
        }
      }).update(function(f, d) {
        var p = l.getItemGraphicEl(d), g = p.childAt(0), v = p.childAt(1), m = p.childAt(2), y = {
          shape: {
            points: o.getItemLayout(f)
          }
        };
        y.shape.points && (c(g.shape.points, y.shape.points, m, o, f, false), os(v), os(g), Ie(g, y, e), Ie(v, y, e), o.setItemGraphicEl(f, p));
      }).remove(function(f) {
        s.remove(l.getItemGraphicEl(f));
      }).execute(), o.eachItemGraphicEl(function(f, d) {
        var p = o.getItemModel(d), g = f.childAt(0), v = f.childAt(1), m = f.childAt(2), y = o.getItemVisual(d, "style"), x = y.fill;
        s.add(f), g.useStyle($t(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: x
        })), Ar(g, p, "lineStyle"), Ar(v, p, "areaStyle");
        var b = p.getModel("areaStyle"), _ = b.isEmpty() && b.parentModel.isEmpty();
        v.ignore = _, P([
          "emphasis",
          "select",
          "blur"
        ], function(I) {
          var T = p.getModel([
            I,
            "areaStyle"
          ]), A = T.isEmpty() && T.parentModel.isEmpty();
          v.ensureState(I).ignore = A && _;
        }), v.useStyle($t(b.getAreaStyle(), {
          fill: x,
          opacity: 0.7,
          decal: y.decal
        }));
        var w = p.getModel("emphasis"), S = w.getModel("itemStyle").getItemStyle();
        m.eachChild(function(I) {
          if (I instanceof br) {
            var T = I.style;
            I.useStyle(rt({
              image: T.image,
              x: T.x,
              y: T.y,
              width: T.width,
              height: T.height
            }, y));
          } else I.useStyle(y), I.setColor(x), I.style.strokeNoScale = true;
          var A = I.ensureState("emphasis");
          A.style = Bt(S);
          var C = o.getStore().get(o.getDimensionIndex(I.__dimIdx), d);
          (C == null || isNaN(C)) && (C = ""), kr(I, ur(p), {
            labelFetcher: o.hostModel,
            labelDataIndex: d,
            labelDimIndex: I.__dimIdx,
            defaultText: C,
            inheritColor: x,
            defaultOpacity: y.opacity
          });
        }), bn(f, w.get("focus"), w.get("blurScope"), w.get("disabled"));
      }), this._data = o;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "radar", t;
  }(qe), Iht = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = true, e;
    }
    return t.prototype.init = function(e) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new qv(St(this.getData, this), St(this.getRawData, this));
    }, t.prototype.getInitialData = function(e, r) {
      return Md(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, t.prototype.formatTooltip = function(e, r, i) {
      var a = this.getData(), s = this.coordinateSystem, o = s.getIndicatorAxes(), l = this.getData().getName(e), u = l === "" ? this.name : l, c = W5(this, e);
      return cr("section", {
        header: u,
        sortBlocks: true,
        blocks: ht(o, function(h) {
          var f = a.get(a.mapDimension(h.dim), e);
          return cr("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: h.name,
            value: f,
            sortParam: f
          });
        })
      });
    }, t.prototype.getTooltipPosition = function(e) {
      if (e != null) {
        for (var r = this.getData(), i = this.coordinateSystem, a = r.getValues(ht(i.dimensions, function(u) {
          return r.mapDimension(u);
        }), e), s = 0, o = a.length; s < o; s++) if (!isNaN(a[s])) {
          var l = i.getIndicatorAxes();
          return i.coordToPoint(l[s].dataToCoord(a[s]), s);
        }
      }
    }, t.type = "series.radar", t.dependencies = [
      "radar"
    ], t.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: true,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      symbolSize: 8
    }, t;
  }(an), mp = F6.value;
  function i0(n, t) {
    return $t({
      show: t
    }, n);
  }
  var Aht = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      var e = this.get("boundaryGap"), r = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), s = this.get("axisTick"), o = this.get("axisLabel"), l = this.get("axisName"), u = this.get([
        "axisName",
        "show"
      ]), c = this.get([
        "axisName",
        "formatter"
      ]), h = this.get("axisNameGap"), f = this.get("triggerEvent"), d = ht(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = $t({
          color: p.color
        }, l));
        var v = Zt(Bt(p), {
          boundaryGap: e,
          splitNumber: r,
          scale: i,
          axisLine: a,
          axisTick: s,
          axisLabel: o,
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: h,
          nameTextStyle: g,
          triggerEvent: f
        }, false);
        if (wt(c)) {
          var m = v.name;
          v.name = c.replace("{value}", m ?? "");
        } else Nt(c) && (v.name = c(v.name, v));
        var y = new $e(v, null, this.ecModel);
        return zn(y, Gv.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = d;
    }, t.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, t.type = "radar", t.defaultOption = {
      z: 0,
      center: [
        "50%",
        "50%"
      ],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: true
      },
      boundaryGap: [
        0,
        0
      ],
      splitNumber: 5,
      axisNameGap: 15,
      scale: false,
      shape: "polygon",
      axisLine: Zt({
        lineStyle: {
          color: "#bbb"
        }
      }, mp.axisLine),
      axisLabel: i0(mp.axisLabel, false),
      axisTick: i0(mp.axisTick, false),
      splitLine: i0(mp.splitLine, true),
      splitArea: i0(mp.splitArea, true),
      indicator: []
    }, t;
  }(pe), kht = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], Dht = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = this.group;
      a.removeAll(), this._buildAxes(e), this._buildSplitLineAndArea(e);
    }, t.prototype._buildAxes = function(e) {
      var r = e.coordinateSystem, i = r.getIndicatorAxes(), a = ht(i, function(s) {
        var o = s.model.get("showName") ? s.name : "", l = new di(s.model, {
          axisName: o,
          position: [
            r.cx,
            r.cy
          ],
          rotation: s.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      P(a, function(s) {
        P(kht, s.add, s), this.group.add(s.getGroup());
      }, this);
    }, t.prototype._buildSplitLineAndArea = function(e) {
      var r = e.coordinateSystem, i = r.getIndicatorAxes();
      if (!i.length) return;
      var a = e.get("shape"), s = e.getModel("splitLine"), o = e.getModel("splitArea"), l = s.getModel("lineStyle"), u = o.getModel("areaStyle"), c = s.get("show"), h = o.get("show"), f = l.get("color"), d = u.get("color"), p = ct(f) ? f : [
        f
      ], g = ct(d) ? d : [
        d
      ], v = [], m = [];
      function y(L, k, N) {
        var R = N % k.length;
        return L[R] = L[R] || [], R;
      }
      if (a === "circle") for (var x = i[0].getTicksCoords(), b = r.cx, _ = r.cy, w = 0; w < x.length; w++) {
        if (c) {
          var S = y(v, p, w);
          v[S].push(new tl({
            shape: {
              cx: b,
              cy: _,
              r: x[w].coord
            }
          }));
        }
        if (h && w < x.length - 1) {
          var S = y(m, g, w);
          m[S].push(new Lv({
            shape: {
              cx: b,
              cy: _,
              r0: x[w].coord,
              r: x[w + 1].coord
            }
          }));
        }
      }
      else for (var I, T = ht(i, function(L, k) {
        var N = L.getTicksCoords();
        return I = I == null ? N.length - 1 : Math.min(N.length - 1, I), ht(N, function(R) {
          return r.coordToPoint(R.coord, k);
        });
      }), A = [], w = 0; w <= I; w++) {
        for (var C = [], D = 0; D < i.length; D++) C.push(T[D][w]);
        if (C[0] && C.push(C[0].slice()), c) {
          var S = y(v, p, w);
          v[S].push(new _i({
            shape: {
              points: C
            }
          }));
        }
        if (h && A) {
          var S = y(m, g, w - 1);
          m[S].push(new yi({
            shape: {
              points: C.concat(A)
            }
          }));
        }
        A = C.slice().reverse();
      }
      var E = l.getLineStyle(), M = u.getAreaStyle();
      P(m, function(L, k) {
        this.group.add(ya(L, {
          style: $t({
            stroke: "none",
            fill: g[k % g.length]
          }, M),
          silent: true
        }));
      }, this), P(v, function(L, k) {
        this.group.add(ya(L, {
          style: $t({
            fill: "none",
            stroke: p[k % p.length]
          }, E),
          silent: true
        }));
      }, this);
    }, t.type = "radar", t;
  }(vn), Eht = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this, e, r, i) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return t;
  }(ds), Mht = function() {
    function n(t, e, r) {
      this.dimensions = [], this._model = t, this._indicatorAxes = ht(t.getIndicatorModels(), function(i, a) {
        var s = "indicator_" + a, o = new Eht(s, new Uo());
        return o.name = i.get("name"), o.model = i, i.axis = o, this.dimensions.push(s), o;
      }, this), this.resize(t, r);
    }
    return n.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, n.prototype.dataToPoint = function(t, e) {
      var r = this._indicatorAxes[e];
      return this.coordToPoint(r.dataToCoord(t), e);
    }, n.prototype.coordToPoint = function(t, e) {
      var r = this._indicatorAxes[e], i = r.angle, a = this.cx + t * Math.cos(i), s = this.cy - t * Math.sin(i);
      return [
        a,
        s
      ];
    }, n.prototype.pointToData = function(t) {
      var e = t[0] - this.cx, r = t[1] - this.cy, i = Math.sqrt(e * e + r * r);
      e /= i, r /= i;
      for (var a = Math.atan2(-r, e), s = 1 / 0, o, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], h = Math.abs(a - c.angle);
        h < s && (o = c, l = u, s = h);
      }
      return [
        l,
        +(o && o.coordToData(i))
      ];
    }, n.prototype.resize = function(t, e) {
      var r = t.get("center"), i = e.getWidth(), a = e.getHeight(), s = Math.min(i, a) / 2;
      this.cx = yt(r[0], i), this.cy = yt(r[1], a), this.startAngle = t.get("startAngle") * Math.PI / 180;
      var o = t.get("radius");
      (wt(o) || _e(o)) && (o = [
        0,
        o
      ]), this.r0 = yt(o[0], s), this.r = yt(o[1], s), P(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, n.prototype.update = function(t, e) {
      var r = this._indicatorAxes, i = this._model;
      P(r, function(o) {
        o.scale.setExtent(1 / 0, -1 / 0);
      }), t.eachSeriesByType("radar", function(o, l) {
        if (!(o.get("coordinateSystem") !== "radar" || t.getComponent("radar", o.get("radarIndex")) !== i)) {
          var u = o.getData();
          P(r, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var a = i.get("splitNumber"), s = new Uo();
      s.setExtent(0, a), s.setInterval(1), P(r, function(o, l) {
        B6(o.scale, o.model, s);
      });
    }, n.prototype.convertToPixel = function(t, e, r) {
      return console.warn("Not implemented."), null;
    }, n.prototype.convertFromPixel = function(t, e, r) {
      return console.warn("Not implemented."), null;
    }, n.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), false;
    }, n.create = function(t, e) {
      var r = [];
      return t.eachComponent("radar", function(i) {
        var a = new n(i, t, e);
        r.push(a), i.coordinateSystem = a;
      }), t.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = r[i.get("radarIndex") || 0]);
      }), r;
    }, n.dimensions = [], n;
  }();
  function Rht(n) {
    n.registerCoordinateSystem("radar", Mht), n.registerComponentModel(Aht), n.registerComponentView(Dht), n.registerVisual({
      seriesType: "radar",
      reset: function(t) {
        var e = t.getData();
        e.each(function(r) {
          e.setItemVisual(r, "legendIcon", "roundRect");
        }), e.setVisual("legendIcon", "roundRect");
      }
    });
  }
  function Nht(n) {
    se(Rht), n.registerChartView(Tht), n.registerSeriesModel(Iht), n.registerLayout(Sht), n.registerProcessor(Yv("radar")), n.registerPreprocessor(Cht);
  }
  var WO = "\0_ec_interaction_mutex";
  function Lht(n, t, e) {
    var r = VD(n);
    r[t] = e;
  }
  function Pht(n, t, e) {
    var r = VD(n), i = r[t];
    i === e && (r[t] = null);
  }
  function UO(n, t) {
    return !!VD(n)[t];
  }
  function VD(n) {
    return n[WO] || (n[WO] = {});
  }
  co({
    type: "takeGlobalCursor",
    event: "globalCursorTaken",
    update: "update"
  }, Dn);
  var jv = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this) || this;
      r._zr = e;
      var i = St(r._mousedownHandler, r), a = St(r._mousemoveHandler, r), s = St(r._mouseupHandler, r), o = St(r._mousewheelHandler, r), l = St(r._pinchHandler, r);
      return r.enable = function(u, c) {
        this.disable(), this._opt = $t(Bt(c) || {}, {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: false,
          preventDefaultMouseMove: true
        }), u == null && (u = true), (u === true || u === "move" || u === "pan") && (e.on("mousedown", i), e.on("mousemove", a), e.on("mouseup", s)), (u === true || u === "scale" || u === "zoom") && (e.on("mousewheel", o), e.on("pinch", l));
      }, r.disable = function() {
        e.off("mousedown", i), e.off("mousemove", a), e.off("mouseup", s), e.off("mousewheel", o), e.off("pinch", l);
      }, r;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype.setPointerChecker = function(e) {
      this.pointerChecker = e;
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(e) {
      if (!xL(e)) {
        for (var r = e.target; r; ) {
          if (r.draggable) return;
          r = r.__hostTarget || r.parent;
        }
        var i = e.offsetX, a = e.offsetY;
        this.pointerChecker && this.pointerChecker(e, i, a) && (this._x = i, this._y = a, this._dragging = true);
      }
    }, t.prototype._mousemoveHandler = function(e) {
      if (!(!this._dragging || !vx("moveOnMouseMove", e, this._opt) || e.gestureEvent === "pinch" || UO(this._zr, "globalPan"))) {
        var r = e.offsetX, i = e.offsetY, a = this._x, s = this._y, o = r - a, l = i - s;
        this._x = r, this._y = i, this._opt.preventDefaultMouseMove && Bo(e.event), X6(this, "pan", "moveOnMouseMove", e, {
          dx: o,
          dy: l,
          oldX: a,
          oldY: s,
          newX: r,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(e) {
      xL(e) || (this._dragging = false);
    }, t.prototype._mousewheelHandler = function(e) {
      var r = vx("zoomOnMouseWheel", e, this._opt), i = vx("moveOnMouseWheel", e, this._opt), a = e.wheelDelta, s = Math.abs(a), o = e.offsetX, l = e.offsetY;
      if (!(a === 0 || !r && !i)) {
        if (r) {
          var u = s > 3 ? 1.4 : s > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
          uC(this, "zoom", "zoomOnMouseWheel", e, {
            scale: c,
            originX: o,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var h = Math.abs(a), f = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
          uC(this, "scrollMove", "moveOnMouseWheel", e, {
            scrollDelta: f,
            originX: o,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, t.prototype._pinchHandler = function(e) {
      if (!UO(this._zr, "globalPan")) {
        var r = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
        uC(this, "zoom", null, e, {
          scale: r,
          originX: e.pinchX,
          originY: e.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t;
  }(Da);
  function uC(n, t, e, r, i) {
    n.pointerChecker && n.pointerChecker(r, i.originX, i.originY) && (Bo(r.event), X6(n, t, e, r, i));
  }
  function X6(n, t, e, r, i) {
    i.isAvailableBehavior = St(vx, null, e, r), n.trigger(t, i);
  }
  function vx(n, t, e) {
    var r = e[n];
    return !n || r && (!wt(r) || t.event[r + "Key"]);
  }
  function GD(n, t, e) {
    var r = n.target;
    r.x += t, r.y += e, r.dirty();
  }
  function WD(n, t, e, r) {
    var i = n.target, a = n.zoomLimit, s = n.zoom = n.zoom || 1;
    if (s *= t, a) {
      var o = a.min || 0, l = a.max || 1 / 0;
      s = Math.max(Math.min(l, s), o);
    }
    var u = s / n.zoom;
    n.zoom = s, i.x -= (e - i.x) * (u - 1), i.y -= (r - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
  }
  var $ht = {
    axisPointer: 1,
    tooltip: 1,
    brush: 1
  };
  function q1(n, t, e) {
    var r = t.getComponentByElement(n.topTarget), i = r && r.coordinateSystem;
    return r && r !== e && !$ht.hasOwnProperty(r.mainType) && i && i.model !== e;
  }
  function Y6(n) {
    if (wt(n)) {
      var t = new DOMParser();
      n = t.parseFromString(n, "text/xml");
    }
    var e = n;
    for (e.nodeType === 9 && (e = e.firstChild); e.nodeName.toLowerCase() !== "svg" || e.nodeType !== 1; ) e = e.nextSibling;
    return e;
  }
  var cC, hb = {
    fill: "fill",
    stroke: "stroke",
    "stroke-width": "lineWidth",
    opacity: "opacity",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-miterlimit": "miterLimit",
    "font-family": "fontFamily",
    "font-size": "fontSize",
    "font-style": "fontStyle",
    "font-weight": "fontWeight",
    "text-anchor": "textAlign",
    visibility: "visibility",
    display: "display"
  }, HO = ge(hb), fb = {
    "alignment-baseline": "textBaseline",
    "stop-color": "stopColor"
  }, XO = ge(fb), Oht = function() {
    function n() {
      this._defs = {}, this._root = null;
    }
    return n.prototype.parse = function(t, e) {
      e = e || {};
      var r = Y6(t);
      this._defsUsePending = [];
      var i = new Vt();
      this._root = i;
      var a = [], s = r.getAttribute("viewBox") || "", o = parseFloat(r.getAttribute("width") || e.width), l = parseFloat(r.getAttribute("height") || e.height);
      isNaN(o) && (o = null), isNaN(l) && (l = null), Vi(r, i, null, true, false);
      for (var u = r.firstChild; u; ) this._parseNode(u, i, a, null, false, false), u = u.nextSibling;
      zht(this._defs, this._defsUsePending), this._defsUsePending = [];
      var c, h;
      if (s) {
        var f = j1(s);
        f.length >= 4 && (c = {
          x: parseFloat(f[0] || 0),
          y: parseFloat(f[1] || 0),
          width: parseFloat(f[2]),
          height: parseFloat(f[3])
        });
      }
      if (c && o != null && l != null && (h = j6(c, {
        x: 0,
        y: 0,
        width: o,
        height: l
      }), !e.ignoreViewBox)) {
        var d = i;
        i = new Vt(), i.add(d), d.scaleX = d.scaleY = h.scale, d.x = h.x, d.y = h.y;
      }
      return !e.ignoreRootClip && o != null && l != null && i.setClipPath(new ye({
        shape: {
          x: 0,
          y: 0,
          width: o,
          height: l
        }
      })), {
        root: i,
        width: o,
        height: l,
        viewBoxRect: c,
        viewBoxTransform: h,
        named: a
      };
    }, n.prototype._parseNode = function(t, e, r, i, a, s) {
      var o = t.nodeName.toLowerCase(), l, u = i;
      if (o === "defs" && (a = true), o === "text" && (s = true), o === "defs" || o === "switch") l = e;
      else {
        if (!a) {
          var c = cC[o];
          if (c && Ct(cC, o)) {
            l = c.call(this, t, e);
            var h = t.getAttribute("name");
            if (h) {
              var f = {
                name: h,
                namedFrom: null,
                svgNodeTagLower: o,
                el: l
              };
              r.push(f), o === "g" && (u = f);
            } else i && r.push({
              name: i.name,
              namedFrom: i,
              svgNodeTagLower: o,
              el: l
            });
            e.add(l);
          }
        }
        var d = YO[o];
        if (d && Ct(YO, o)) {
          var p = d.call(this, t), g = t.getAttribute("id");
          g && (this._defs[g] = p);
        }
      }
      if (l && l.isGroup) for (var v = t.firstChild; v; ) v.nodeType === 1 ? this._parseNode(v, l, r, u, a, s) : v.nodeType === 3 && s && this._parseText(v, l), v = v.nextSibling;
    }, n.prototype._parseText = function(t, e) {
      var r = new Vf({
        style: {
          text: t.textContent
        },
        silent: true,
        x: this._textX || 0,
        y: this._textY || 0
      });
      aa(e, r), Vi(t, r, this._defsUsePending, false, false), Fht(r, e);
      var i = r.style, a = i.fontSize;
      a && a < 9 && (i.fontSize = 9, r.scaleX *= a / 9, r.scaleY *= a / 9);
      var s = (i.fontSize || i.fontFamily) && [
        i.fontStyle,
        i.fontWeight,
        (i.fontSize || 12) + "px",
        i.fontFamily || "sans-serif"
      ].join(" ");
      i.font = s;
      var o = r.getBoundingRect();
      return this._textX += o.width, e.add(r), r;
    }, n.internalField = function() {
      cC = {
        g: function(t, e) {
          var r = new Vt();
          return aa(e, r), Vi(t, r, this._defsUsePending, false, false), r;
        },
        rect: function(t, e) {
          var r = new ye();
          return aa(e, r), Vi(t, r, this._defsUsePending, false, false), r.setShape({
            x: parseFloat(t.getAttribute("x") || "0"),
            y: parseFloat(t.getAttribute("y") || "0"),
            width: parseFloat(t.getAttribute("width") || "0"),
            height: parseFloat(t.getAttribute("height") || "0")
          }), r.silent = true, r;
        },
        circle: function(t, e) {
          var r = new tl();
          return aa(e, r), Vi(t, r, this._defsUsePending, false, false), r.setShape({
            cx: parseFloat(t.getAttribute("cx") || "0"),
            cy: parseFloat(t.getAttribute("cy") || "0"),
            r: parseFloat(t.getAttribute("r") || "0")
          }), r.silent = true, r;
        },
        line: function(t, e) {
          var r = new ir();
          return aa(e, r), Vi(t, r, this._defsUsePending, false, false), r.setShape({
            x1: parseFloat(t.getAttribute("x1") || "0"),
            y1: parseFloat(t.getAttribute("y1") || "0"),
            x2: parseFloat(t.getAttribute("x2") || "0"),
            y2: parseFloat(t.getAttribute("y2") || "0")
          }), r.silent = true, r;
        },
        ellipse: function(t, e) {
          var r = new A1();
          return aa(e, r), Vi(t, r, this._defsUsePending, false, false), r.setShape({
            cx: parseFloat(t.getAttribute("cx") || "0"),
            cy: parseFloat(t.getAttribute("cy") || "0"),
            rx: parseFloat(t.getAttribute("rx") || "0"),
            ry: parseFloat(t.getAttribute("ry") || "0")
          }), r.silent = true, r;
        },
        polygon: function(t, e) {
          var r = t.getAttribute("points"), i;
          r && (i = KO(r));
          var a = new yi({
            shape: {
              points: i || []
            },
            silent: true
          });
          return aa(e, a), Vi(t, a, this._defsUsePending, false, false), a;
        },
        polyline: function(t, e) {
          var r = t.getAttribute("points"), i;
          r && (i = KO(r));
          var a = new _i({
            shape: {
              points: i || []
            },
            silent: true
          });
          return aa(e, a), Vi(t, a, this._defsUsePending, false, false), a;
        },
        image: function(t, e) {
          var r = new br();
          return aa(e, r), Vi(t, r, this._defsUsePending, false, false), r.setStyle({
            image: t.getAttribute("xlink:href") || t.getAttribute("href"),
            x: +t.getAttribute("x"),
            y: +t.getAttribute("y"),
            width: +t.getAttribute("width"),
            height: +t.getAttribute("height")
          }), r.silent = true, r;
        },
        text: function(t, e) {
          var r = t.getAttribute("x") || "0", i = t.getAttribute("y") || "0", a = t.getAttribute("dx") || "0", s = t.getAttribute("dy") || "0";
          this._textX = parseFloat(r) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(s);
          var o = new Vt();
          return aa(e, o), Vi(t, o, this._defsUsePending, false, true), o;
        },
        tspan: function(t, e) {
          var r = t.getAttribute("x"), i = t.getAttribute("y");
          r != null && (this._textX = parseFloat(r)), i != null && (this._textY = parseFloat(i));
          var a = t.getAttribute("dx") || "0", s = t.getAttribute("dy") || "0", o = new Vt();
          return aa(e, o), Vi(t, o, this._defsUsePending, false, true), this._textX += parseFloat(a), this._textY += parseFloat(s), o;
        },
        path: function(t, e) {
          var r = t.getAttribute("d") || "", i = OU(r);
          return aa(e, i), Vi(t, i, this._defsUsePending, false, false), i.silent = true, i;
        }
      };
    }(), n;
  }(), YO = {
    lineargradient: function(n) {
      var t = parseInt(n.getAttribute("x1") || "0", 10), e = parseInt(n.getAttribute("y1") || "0", 10), r = parseInt(n.getAttribute("x2") || "10", 10), i = parseInt(n.getAttribute("y2") || "0", 10), a = new $v(t, e, r, i);
      return qO(n, a), jO(n, a), a;
    },
    radialgradient: function(n) {
      var t = parseInt(n.getAttribute("cx") || "0", 10), e = parseInt(n.getAttribute("cy") || "0", 10), r = parseInt(n.getAttribute("r") || "0", 10), i = new VU(t, e, r);
      return qO(n, i), jO(n, i), i;
    }
  };
  function qO(n, t) {
    var e = n.getAttribute("gradientUnits");
    e === "userSpaceOnUse" && (t.global = true);
  }
  function jO(n, t) {
    for (var e = n.firstChild; e; ) {
      if (e.nodeType === 1 && e.nodeName.toLocaleLowerCase() === "stop") {
        var r = e.getAttribute("offset"), i = void 0;
        r && r.indexOf("%") > 0 ? i = parseInt(r, 10) / 100 : r ? i = parseFloat(r) : i = 0;
        var a = {};
        q6(e, a, a);
        var s = a.stopColor || e.getAttribute("stop-color") || "#000000";
        t.colorStops.push({
          offset: i,
          color: s
        });
      }
      e = e.nextSibling;
    }
  }
  function aa(n, t) {
    n && n.__inheritedStyle && (t.__inheritedStyle || (t.__inheritedStyle = {}), $t(t.__inheritedStyle, n.__inheritedStyle));
  }
  function KO(n) {
    for (var t = j1(n), e = [], r = 0; r < t.length; r += 2) {
      var i = parseFloat(t[r]), a = parseFloat(t[r + 1]);
      e.push([
        i,
        a
      ]);
    }
    return e;
  }
  function Vi(n, t, e, r, i) {
    var a = t, s = a.__inheritedStyle = a.__inheritedStyle || {}, o = {};
    n.nodeType === 1 && (Wht(n, t), q6(n, s, o), r || Uht(n, s, o)), a.style = a.style || {}, s.fill != null && (a.style.fill = ZO(a, "fill", s.fill, e)), s.stroke != null && (a.style.stroke = ZO(a, "stroke", s.stroke, e)), P([
      "lineWidth",
      "opacity",
      "fillOpacity",
      "strokeOpacity",
      "miterLimit",
      "fontSize"
    ], function(l) {
      s[l] != null && (a.style[l] = parseFloat(s[l]));
    }), P([
      "lineDashOffset",
      "lineCap",
      "lineJoin",
      "fontWeight",
      "fontFamily",
      "fontStyle",
      "textAlign"
    ], function(l) {
      s[l] != null && (a.style[l] = s[l]);
    }), i && (a.__selfStyle = o), s.lineDash && (a.style.lineDash = ht(j1(s.lineDash), function(l) {
      return parseFloat(l);
    })), (s.visibility === "hidden" || s.visibility === "collapse") && (a.invisible = true), s.display === "none" && (a.ignore = true);
  }
  function Fht(n, t) {
    var e = t.__selfStyle;
    if (e) {
      var r = e.textBaseline, i = r;
      !r || r === "auto" || r === "baseline" ? i = "alphabetic" : r === "before-edge" || r === "text-before-edge" ? i = "top" : r === "after-edge" || r === "text-after-edge" ? i = "bottom" : (r === "central" || r === "mathematical") && (i = "middle"), n.style.textBaseline = i;
    }
    var a = t.__inheritedStyle;
    if (a) {
      var s = a.textAlign, o = s;
      s && (s === "middle" && (o = "center"), n.style.textAlign = o);
    }
  }
  var Bht = /^url\(\s*#(.*?)\)/;
  function ZO(n, t, e, r) {
    var i = e && e.match(Bht);
    if (i) {
      var a = ja(i[1]);
      r.push([
        n,
        t,
        a
      ]);
      return;
    }
    return e === "none" && (e = null), e;
  }
  function zht(n, t) {
    for (var e = 0; e < t.length; e++) {
      var r = t[e];
      r[0].style[r[1]] = n[r[2]];
    }
  }
  var Vht = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function j1(n) {
    return n.match(Vht) || [];
  }
  var Ght = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, hC = Math.PI / 180;
  function Wht(n, t) {
    var e = n.getAttribute("transform");
    if (e) {
      e = e.replace(/,/g, " ");
      var r = [], i = null;
      e.replace(Ght, function(h, f, d) {
        return r.push(f, d), "";
      });
      for (var a = r.length - 1; a > 0; a -= 2) {
        var s = r[a], o = r[a - 1], l = j1(s);
        switch (i = i || Xi(), o) {
          case "translate":
            to(i, i, [
              parseFloat(l[0]),
              parseFloat(l[1] || "0")
            ]);
            break;
          case "scale":
            Fk(i, i, [
              parseFloat(l[0]),
              parseFloat(l[1] || l[0])
            ]);
            break;
          case "rotate":
            fh(i, i, -parseFloat(l[0]) * hC, [
              parseFloat(l[1] || "0"),
              parseFloat(l[2] || "0")
            ]);
            break;
          case "skewX":
            var u = Math.tan(parseFloat(l[0]) * hC);
            Ro(i, [
              1,
              0,
              u,
              1,
              0,
              0
            ], i);
            break;
          case "skewY":
            var c = Math.tan(parseFloat(l[0]) * hC);
            Ro(i, [
              1,
              c,
              0,
              1,
              0,
              0
            ], i);
            break;
          case "matrix":
            i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
            break;
        }
      }
      t.setLocalTransform(i);
    }
  }
  var JO = /([^\s:;]+)\s*:\s*([^:;]+)/g;
  function q6(n, t, e) {
    var r = n.getAttribute("style");
    if (r) {
      JO.lastIndex = 0;
      for (var i; (i = JO.exec(r)) != null; ) {
        var a = i[1], s = Ct(hb, a) ? hb[a] : null;
        s && (t[s] = i[2]);
        var o = Ct(fb, a) ? fb[a] : null;
        o && (e[o] = i[2]);
      }
    }
  }
  function Uht(n, t, e) {
    for (var r = 0; r < HO.length; r++) {
      var i = HO[r], a = n.getAttribute(i);
      a != null && (t[hb[i]] = a);
    }
    for (var r = 0; r < XO.length; r++) {
      var i = XO[r], a = n.getAttribute(i);
      a != null && (e[fb[i]] = a);
    }
  }
  function j6(n, t) {
    var e = t.width / n.width, r = t.height / n.height, i = Math.min(e, r);
    return {
      scale: i,
      x: -(n.x + n.width / 2) * i + (t.x + t.width / 2),
      y: -(n.y + n.height / 2) * i + (t.y + t.height / 2)
    };
  }
  function Hht(n, t) {
    var e = new Oht();
    return e.parse(n, t);
  }
  var Xht = It([
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path",
    "text",
    "tspan",
    "g"
  ]), Yht = function() {
    function n(t, e) {
      this.type = "geoSVG", this._usedGraphicMap = It(), this._freedGraphics = [], this._mapName = t, this._parsedXML = Y6(e);
    }
    return n.prototype.load = function() {
      var t = this._firstGraphic;
      if (!t) {
        t = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(t), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var e = jht(t.named), r = e.regions, i = e.regionsMap;
        this._regions = r, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, n.prototype._buildGraphic = function(t) {
      var e, r;
      try {
        e = t && Hht(t, {
          ignoreViewBox: true,
          ignoreRootClip: true
        }) || {}, r = e.root, gi(r != null);
      } catch (v) {
        throw new Error(`Invalid svg format
` + v.message);
      }
      var i = new Vt();
      i.add(r), i.isGeoSVGGraphicRoot = true;
      var a = e.width, s = e.height, o = e.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, h = void 0, f = void 0;
        if (a != null ? (u = 0, h = a) : o && (u = o.x, h = o.width), s != null ? (c = 0, f = s) : o && (c = o.y, f = o.height), u == null || c == null) {
          var d = r.getBoundingRect();
          u == null && (u = d.x, h = d.width), c == null && (c = d.y, f = d.height);
        }
        l = this._boundingRect = new te(u, c, h, f);
      }
      if (o) {
        var p = j6(o, l);
        r.scaleX = r.scaleY = p.scale, r.x = p.x, r.y = p.y;
      }
      i.setClipPath(new ye({
        shape: l.plain()
      }));
      var g = [];
      return P(e.named, function(v) {
        Xht.get(v.svgNodeTagLower) != null && (g.push(v), qht(v.el));
      }), {
        root: i,
        boundingRect: l,
        named: g
      };
    }, n.prototype.useGraphic = function(t) {
      var e = this._usedGraphicMap, r = e.get(t);
      return r || (r = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), e.set(t, r), r);
    }, n.prototype.freeGraphic = function(t) {
      var e = this._usedGraphicMap, r = e.get(t);
      r && (e.removeKey(t), this._freedGraphics.push(r));
    }, n;
  }();
  function qht(n) {
    n.silent = false, n.isGroup && n.traverse(function(t) {
      t.silent = false;
    });
  }
  function jht(n) {
    var t = [], e = It();
    return P(n, function(r) {
      if (r.namedFrom == null) {
        var i = new Wlt(r.name, r.el);
        t.push(i), e.set(r.name, i);
      }
    }), {
      regions: t,
      regionsMap: e
    };
  }
  var AA = [
    126,
    25
  ], QO = "\u5357\u6D77\u8BF8\u5C9B", Qu = [
    [
      [
        0,
        3.5
      ],
      [
        7,
        11.2
      ],
      [
        15,
        11.9
      ],
      [
        30,
        7
      ],
      [
        42,
        0.7
      ],
      [
        52,
        0.7
      ],
      [
        56,
        7.7
      ],
      [
        59,
        0.7
      ],
      [
        64,
        0.7
      ],
      [
        64,
        0
      ],
      [
        5,
        0
      ],
      [
        0,
        3.5
      ]
    ],
    [
      [
        13,
        16.1
      ],
      [
        19,
        14.7
      ],
      [
        16,
        21.7
      ],
      [
        11,
        23.1
      ],
      [
        13,
        16.1
      ]
    ],
    [
      [
        12,
        32.2
      ],
      [
        14,
        38.5
      ],
      [
        15,
        38.5
      ],
      [
        13,
        32.2
      ],
      [
        12,
        32.2
      ]
    ],
    [
      [
        16,
        47.6
      ],
      [
        12,
        53.2
      ],
      [
        13,
        53.2
      ],
      [
        18,
        47.6
      ],
      [
        16,
        47.6
      ]
    ],
    [
      [
        6,
        64.4
      ],
      [
        8,
        70
      ],
      [
        9,
        70
      ],
      [
        8,
        64.4
      ],
      [
        6,
        64.4
      ]
    ],
    [
      [
        23,
        82.6
      ],
      [
        29,
        79.8
      ],
      [
        30,
        79.8
      ],
      [
        25,
        82.6
      ],
      [
        23,
        82.6
      ]
    ],
    [
      [
        37,
        70.7
      ],
      [
        43,
        62.3
      ],
      [
        44,
        62.3
      ],
      [
        39,
        70.7
      ],
      [
        37,
        70.7
      ]
    ],
    [
      [
        48,
        51.1
      ],
      [
        51,
        45.5
      ],
      [
        53,
        45.5
      ],
      [
        50,
        51.1
      ],
      [
        48,
        51.1
      ]
    ],
    [
      [
        51,
        35
      ],
      [
        51,
        28.7
      ],
      [
        53,
        28.7
      ],
      [
        53,
        35
      ],
      [
        51,
        35
      ]
    ],
    [
      [
        52,
        22.4
      ],
      [
        55,
        17.5
      ],
      [
        56,
        17.5
      ],
      [
        53,
        22.4
      ],
      [
        52,
        22.4
      ]
    ],
    [
      [
        58,
        12.6
      ],
      [
        62,
        7
      ],
      [
        63,
        7
      ],
      [
        60,
        12.6
      ],
      [
        58,
        12.6
      ]
    ],
    [
      [
        0,
        3.5
      ],
      [
        0,
        93.1
      ],
      [
        64,
        93.1
      ],
      [
        64,
        0
      ],
      [
        63,
        0
      ],
      [
        63,
        92.4
      ],
      [
        1,
        92.4
      ],
      [
        1,
        3.5
      ],
      [
        0,
        3.5
      ]
    ]
  ];
  for (var Hu = 0; Hu < Qu.length; Hu++) for (var Hh = 0; Hh < Qu[Hu].length; Hh++) Qu[Hu][Hh][0] /= 10.5, Qu[Hu][Hh][1] /= -10.5 / 0.75, Qu[Hu][Hh][0] += AA[0], Qu[Hu][Hh][1] += AA[1];
  function Kht(n, t) {
    if (n === "china") {
      for (var e = 0; e < t.length; e++) if (t[e].name === QO) return;
      t.push(new HH(QO, ht(Qu, function(r) {
        return {
          type: "polygon",
          exterior: r
        };
      }), AA));
    }
  }
  var Zht = {
    \u5357\u6D77\u8BF8\u5C9B: [
      32,
      80
    ],
    \u5E7F\u4E1C: [
      0,
      -10
    ],
    \u9999\u6E2F: [
      10,
      5
    ],
    \u6FB3\u95E8: [
      -10,
      10
    ],
    \u5929\u6D25: [
      5,
      5
    ]
  };
  function Jht(n, t) {
    if (n === "china") {
      var e = Zht[t.name];
      if (e) {
        var r = t.getCenter();
        r[0] += e[0] / 10.5, r[1] += -e[1] / (10.5 / 0.75), t.setCenter(r);
      }
    }
  }
  var Qht = [
    [
      [
        123.45165252685547,
        25.73527164402261
      ],
      [
        123.49731445312499,
        25.73527164402261
      ],
      [
        123.49731445312499,
        25.750734064600884
      ],
      [
        123.45165252685547,
        25.750734064600884
      ],
      [
        123.45165252685547,
        25.73527164402261
      ]
    ]
  ];
  function tft(n, t) {
    n === "china" && t.name === "\u53F0\u6E7E" && t.geometries.push({
      type: "polygon",
      exterior: Qht[0]
    });
  }
  var eft = "name", nft = function() {
    function n(t, e, r) {
      this.type = "geoJSON", this._parsedMap = It(), this._mapName = t, this._specialAreas = r, this._geoJSON = ift(e);
    }
    return n.prototype.load = function(t, e) {
      e = e || eft;
      var r = this._parsedMap.get(e);
      if (!r) {
        var i = this._parseToRegions(e);
        r = this._parsedMap.set(e, {
          regions: i,
          boundingRect: rft(i)
        });
      }
      var a = It(), s = [];
      return P(r.regions, function(o) {
        var l = o.name;
        t && Ct(t, l) && (o = o.cloneShallow(l = t[l])), s.push(o), a.set(l, o);
      }), {
        regions: s,
        boundingRect: r.boundingRect || new te(0, 0, 0, 0),
        regionsMap: a
      };
    }, n.prototype._parseToRegions = function(t) {
      var e = this._mapName, r = this._geoJSON, i;
      try {
        i = r ? Hlt(r, t) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return Kht(e, i), P(i, function(a) {
        var s = a.name;
        Jht(e, a), tft(e, a);
        var o = this._specialAreas && this._specialAreas[s];
        o && a.transformTo(o.left, o.top, o.width, o.height);
      }, this), i;
    }, n.prototype.getMapForUser = function() {
      return {
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, n;
  }();
  function rft(n) {
    for (var t, e = 0; e < n.length; e++) {
      var r = n[e].getBoundingRect();
      t = t || r.clone(), t.union(r);
    }
    return t;
  }
  function ift(n) {
    return wt(n) ? typeof JSON < "u" && JSON.parse ? JSON.parse(n) : new Function("return (" + n + ");")() : n;
  }
  var yp = It();
  const Ho = {
    registerMap: function(n, t, e) {
      if (t.svg) {
        var r = new Yht(n, t.svg);
        yp.set(n, r);
      } else {
        var i = t.geoJson || t.geoJSON;
        i && !t.features ? e = t.specialAreas : i = t;
        var r = new nft(n, i, e);
        yp.set(n, r);
      }
    },
    getGeoResource: function(n) {
      return yp.get(n);
    },
    getMapForUser: function(n) {
      var t = yp.get(n);
      return t && t.type === "geoJSON" && t.getMapForUser();
    },
    load: function(n, t, e) {
      var r = yp.get(n);
      if (r) return r.load(t, e);
    }
  };
  var UD = [
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path"
  ], aft = It(UD), sft = It(UD.concat([
    "g"
  ])), oft = It(UD.concat([
    "g"
  ])), K6 = xe();
  function a0(n) {
    var t = n.getItemStyle(), e = n.get("areaColor");
    return e != null && (t.fill = e), t;
  }
  function tF(n) {
    var t = n.style;
    t && (t.stroke = t.stroke || t.fill, t.fill = null);
  }
  var Z6 = function() {
    function n(t) {
      var e = new Vt();
      this.uid = Sd("ec_map_draw"), this._controller = new jv(t.getZr()), this._controllerHost = {
        target: e
      }, this.group = e, e.add(this._regionsGroup = new Vt()), e.add(this._svgGroup = new Vt());
    }
    return n.prototype.draw = function(t, e, r, i, a) {
      var s = t.mainType === "geo", o = t.getData && t.getData();
      s && e.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(m) {
        !o && m.getHostGeoModel() === t && (o = m.getData());
      });
      var l = t.coordinateSystem, u = this._regionsGroup, c = this.group, h = l.getTransformInfo(), f = h.raw, d = h.roam, p = !u.childAt(0) || a;
      p ? (c.x = d.x, c.y = d.y, c.scaleX = d.scaleX, c.scaleY = d.scaleY, c.dirty()) : Ie(c, d, t);
      var g = o && o.getVisual("visualMeta") && o.getVisual("visualMeta").length > 0, v = {
        api: r,
        geo: l,
        mapOrGeoModel: t,
        data: o,
        isVisualEncodedByVisualMap: g,
        isGeo: s,
        transformInfoRaw: f
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(v) : l.resourceType === "geoSVG" && this._buildSVG(v), this._updateController(t, e, r), this._updateMapSelectHandler(t, u, r, i);
    }, n.prototype._buildGeoJSON = function(t) {
      var e = this._regionsGroupByName = It(), r = It(), i = this._regionsGroup, a = t.transformInfoRaw, s = t.mapOrGeoModel, o = t.data, l = t.geo.projection, u = l && l.stream;
      function c(d, p) {
        return p && (d = p(d)), d && [
          d[0] * a.scaleX + a.x,
          d[1] * a.scaleY + a.y
        ];
      }
      function h(d) {
        for (var p = [], g = !u && l && l.project, v = 0; v < d.length; ++v) {
          var m = c(d[v], g);
          m && p.push(m);
        }
        return p;
      }
      function f(d) {
        return {
          shape: {
            points: h(d)
          }
        };
      }
      i.removeAll(), P(t.geo.regions, function(d) {
        var p = d.name, g = e.get(p), v = r.get(p) || {}, m = v.dataIdx, y = v.regionModel;
        if (!g) {
          g = e.set(p, new Vt()), i.add(g), m = o ? o.indexOfName(p) : null, y = t.isGeo ? s.getRegionModel(p) : o ? o.getItemModel(m) : null;
          var x = y.get("silent", true);
          x != null && (g.silent = x), r.set(p, {
            dataIdx: m,
            regionModel: y
          });
        }
        var b = [], _ = [];
        P(d.geometries, function(I) {
          if (I.type === "polygon") {
            var T = [
              I.exterior
            ].concat(I.interiors || []);
            u && (T = sF(T, u)), P(T, function(C) {
              b.push(new yi(f(C)));
            });
          } else {
            var A = I.points;
            u && (A = sF(A, u, true)), P(A, function(C) {
              _.push(new _i(f(C)));
            });
          }
        });
        var w = c(d.getCenter(), l && l.project);
        function S(I, T) {
          if (I.length) {
            var A = new tD({
              culling: true,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: I
              }
            });
            g.add(A), eF(t, A, m, y), nF(t, A, p, y, s, m, w), T && (tF(A), P(A.states, tF));
          }
        }
        S(b), S(_, true);
      }), e.each(function(d, p) {
        var g = r.get(p), v = g.dataIdx, m = g.regionModel;
        rF(t, d, p, m, s, v), iF(t, d, p, m, s), aF(t, d, p, m, s);
      }, this);
    }, n.prototype._buildSVG = function(t) {
      var e = t.geo.map, r = t.transformInfoRaw;
      this._svgGroup.x = r.x, this._svgGroup.y = r.y, this._svgGroup.scaleX = r.scaleX, this._svgGroup.scaleY = r.scaleY, this._svgResourceChanged(e) && (this._freeSVG(), this._useSVG(e));
      var i = this._svgDispatcherMap = It(), a = false;
      P(this._svgGraphicRecord.named, function(s) {
        var o = s.name, l = t.mapOrGeoModel, u = t.data, c = s.svgNodeTagLower, h = s.el, f = u ? u.indexOfName(o) : null, d = l.getRegionModel(o);
        aft.get(c) != null && h instanceof Ia && eF(t, h, f, d), h instanceof Ia && (h.culling = true);
        var p = d.get("silent", true);
        if (p != null && (h.silent = p), h.z2EmphasisLift = 0, !s.namedFrom && (oft.get(c) != null && nF(t, h, o, d, l, f, null), rF(t, h, o, d, l, f), iF(t, h, o, d, l), sft.get(c) != null)) {
          var g = aF(t, h, o, d, l);
          g === "self" && (a = true);
          var v = i.get(o) || i.set(o, []);
          v.push(h);
        }
      }, this), this._enableBlurEntireSVG(a, t);
    }, n.prototype._enableBlurEntireSVG = function(t, e) {
      if (t && e.isGeo) {
        var r = e.mapOrGeoModel.getModel([
          "blur",
          "itemStyle"
        ]).getItemStyle(), i = r.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            Xc(a);
            var s = a.ensureState("blur").style || {};
            s.opacity == null && i != null && (s.opacity = i), a.ensureState("emphasis");
          }
        });
      }
    }, n.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, n.prototype.findHighDownDispatchers = function(t, e) {
      if (t == null) return [];
      var r = e.coordinateSystem;
      if (r.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var a = i.get(t);
          return a ? [
            a
          ] : [];
        }
      } else if (r.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(t) || [];
    }, n.prototype._svgResourceChanged = function(t) {
      return this._svgMapName !== t;
    }, n.prototype._useSVG = function(t) {
      var e = Ho.getGeoResource(t);
      if (e && e.type === "geoSVG") {
        var r = e.useGraphic(this.uid);
        this._svgGroup.add(r.root), this._svgGraphicRecord = r, this._svgMapName = t;
      }
    }, n.prototype._freeSVG = function() {
      var t = this._svgMapName;
      if (t != null) {
        var e = Ho.getGeoResource(t);
        e && e.type === "geoSVG" && e.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, n.prototype._updateController = function(t, e, r) {
      var i = t.coordinateSystem, a = this._controller, s = this._controllerHost;
      s.zoomLimit = t.get("scaleLimit"), s.zoom = i.getZoom(), a.enable(t.get("roam") || false);
      var o = t.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: o
        };
        return u[o + "Id"] = t.id, u;
      }
      a.off("pan").on("pan", function(u) {
        this._mouseDownFlag = false, GD(s, u.dx, u.dy), r.dispatchAction(rt(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), a.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = false, WD(s, u.scale, u.originX, u.originY), r.dispatchAction(rt(l(), {
          totalZoom: s.zoom,
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), a.setPointerChecker(function(u, c, h) {
        return i.containPoint([
          c,
          h
        ]) && !q1(u, r, t);
      });
    }, n.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(t) {
        var e = t.getTextContent();
        e && (e.ignore = K6(e).ignore);
      });
    }, n.prototype._updateMapSelectHandler = function(t, e, r, i) {
      var a = this;
      e.off("mousedown"), e.off("click"), t.get("selectedMode") && (e.on("mousedown", function() {
        a._mouseDownFlag = true;
      }), e.on("click", function(s) {
        a._mouseDownFlag && (a._mouseDownFlag = false);
      }));
    }, n;
  }();
  function eF(n, t, e, r) {
    var i = r.getModel("itemStyle"), a = r.getModel([
      "emphasis",
      "itemStyle"
    ]), s = r.getModel([
      "blur",
      "itemStyle"
    ]), o = r.getModel([
      "select",
      "itemStyle"
    ]), l = a0(i), u = a0(a), c = a0(o), h = a0(s), f = n.data;
    if (f) {
      var d = f.getItemVisual(e, "style"), p = f.getItemVisual(e, "decal");
      n.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill), p && (l.decal = Uf(p, n.api));
    }
    t.setStyle(l), t.style.strokeNoScale = true, t.ensureState("emphasis").style = u, t.ensureState("select").style = c, t.ensureState("blur").style = h, Xc(t);
  }
  function nF(n, t, e, r, i, a, s) {
    var o = n.data, l = n.isGeo, u = o && isNaN(o.get(o.mapDimension("value"), a)), c = o && o.getItemLayout(a);
    if (l || u || c && c.showLabel) {
      var h = l ? e : a, f = void 0;
      (!o || a >= 0) && (f = i);
      var d = s ? {
        normal: {
          align: "center",
          verticalAlign: "middle"
        }
      } : null;
      kr(t, ur(r), {
        labelFetcher: f,
        labelDataIndex: h,
        defaultText: e
      }, d);
      var p = t.getTextContent();
      if (p && (K6(p).ignore = p.ignore, t.textConfig && s)) {
        var g = t.getBoundingRect().clone();
        t.textConfig.layoutRect = g, t.textConfig.position = [
          (s[0] - g.x) / g.width * 100 + "%",
          (s[1] - g.y) / g.height * 100 + "%"
        ];
      }
      t.disableLabelAnimation = true;
    } else t.removeTextContent(), t.removeTextConfig(), t.disableLabelAnimation = null;
  }
  function rF(n, t, e, r, i, a) {
    n.data ? n.data.setItemGraphicEl(a, t) : Ut(t).eventData = {
      componentType: "geo",
      componentIndex: i.componentIndex,
      geoIndex: i.componentIndex,
      name: e,
      region: r && r.option || {}
    };
  }
  function iF(n, t, e, r, i) {
    n.data || dh({
      el: t,
      componentModel: i,
      itemName: e,
      itemTooltipOption: r.get("tooltip")
    });
  }
  function aF(n, t, e, r, i) {
    t.highDownSilentOnTouch = !!i.get("selectedMode");
    var a = r.getModel("emphasis"), s = a.get("focus");
    return bn(t, s, a.get("blurScope"), a.get("disabled")), n.isGeo && iit(t, i, e), s;
  }
  function sF(n, t, e) {
    var r = [], i;
    function a() {
      i = [];
    }
    function s() {
      i.length && (r.push(i), i = []);
    }
    var o = t({
      polygonStart: a,
      polygonEnd: s,
      lineStart: a,
      lineEnd: s,
      point: function(l, u) {
        isFinite(l) && isFinite(u) && i.push([
          l,
          u
        ]);
      },
      sphere: function() {
      }
    });
    return !e && o.polygonStart(), P(n, function(l) {
      o.lineStart();
      for (var u = 0; u < l.length; u++) o.point(l[u][0], l[u][1]);
      o.lineEnd();
    }), !e && o.polygonEnd(), r;
  }
  var lft = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var s = this.group;
        if (s.removeAll(), !e.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === e.id) {
            var o = this._mapDraw;
            o && s.add(o.group);
          } else if (e.needsDrawMap) {
            var o = this._mapDraw || new Z6(i);
            s.add(o.group), o.draw(e, r, i, this, a), this._mapDraw = o;
          } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          e.get("showLegendSymbol") && r.getComponent("legend") && this._renderSymbols(e, r, i);
        }
      }
    }, t.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, t.prototype._renderSymbols = function(e, r, i) {
      var a = e.originalData, s = this.group;
      a.each(a.mapDimension("value"), function(o, l) {
        if (!isNaN(o)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, h = u.offset, f = new tl({
              style: {
                fill: e.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + h * 9,
                cy: c[1],
                r: 3
              },
              silent: true,
              z2: 8 + (h ? 0 : bd + 1)
            });
            if (!h) {
              var d = e.mainSeries.getData(), p = a.getName(l), g = d.indexOfName(p), v = a.getItemModel(l), m = v.getModel("label"), y = d.getItemGraphicEl(g);
              kr(f, ur(v), {
                labelFetcher: {
                  getFormattedLabel: function(x, b) {
                    return e.getFormattedLabel(g, b);
                  }
                },
                defaultText: p
              }), f.disableLabelAnimation = true, m.get("position") || f.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(x) {
                Hx(f, x);
              };
            }
            s.add(f);
          }
        }
      });
    }, t.type = "map", t;
  }(qe), uft = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.needsDrawMap = false, e.seriesGroup = [], e.getTooltipPosition = function(r) {
        if (r != null) {
          var i = this.getData().getName(r), a = this.coordinateSystem, s = a.getRegion(i);
          return s && a.dataToPoint(s.getCenter());
        }
      }, e;
    }
    return t.prototype.getInitialData = function(e) {
      for (var r = Md(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: qt(cD, this)
      }), i = It(), a = [], s = 0, o = r.count(); s < o; s++) {
        var l = r.getName(s);
        i.set(l, s);
      }
      var u = Ho.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return P(u.regions, function(c) {
        var h = c.name, f = i.get(h), d = c.properties && c.properties.echartsStyle, p;
        f == null ? (p = {
          name: h
        }, a.push(p)) : p = r.getRawDataItem(f), d && Zt(p, d);
      }), r.appendData(a), r;
    }, t.prototype.getHostGeoModel = function() {
      var e = this.option.geoIndex;
      return e != null ? this.ecModel.getComponent("geo", e) : null;
    }, t.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, t.prototype.getRawValue = function(e) {
      var r = this.getData();
      return r.get(r.mapDimension("value"), e);
    }, t.prototype.getRegionModel = function(e) {
      var r = this.getData();
      return r.getItemModel(r.indexOfName(e));
    }, t.prototype.formatTooltip = function(e, r, i) {
      for (var a = this.getData(), s = this.getRawValue(e), o = a.getName(e), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var h = l[c].originalData.indexOfName(o), f = a.mapDimension("value");
        isNaN(l[c].originalData.get(f, h)) || u.push(l[c].name);
      }
      return cr("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [
          cr("nameValue", {
            name: o,
            value: s
          })
        ]
      });
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.getLegendIcon = function(e) {
      var r = e.icon || "roundRect", i = Fn(r, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill);
      return i.setStyle(e.itemStyle), i.style.stroke = "none", r.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, t.type = "series.map", t.dependencies = [
      "geo"
    ], t.layoutMode = "box", t.defaultOption = {
      z: 2,
      coordinateSystem: "geo",
      map: "",
      left: "center",
      top: "center",
      aspectScale: null,
      showLegendSymbol: true,
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: true,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, t;
  }(an);
  function cft(n, t) {
    var e = {};
    return P(n, function(r) {
      r.each(r.mapDimension("value"), function(i, a) {
        var s = "ec-" + r.getName(a);
        e[s] = e[s] || [], isNaN(i) || e[s].push(i);
      });
    }), n[0].map(n[0].mapDimension("value"), function(r, i) {
      for (var a = "ec-" + n[0].getName(i), s = 0, o = 1 / 0, l = -1 / 0, u = e[a].length, c = 0; c < u; c++) o = Math.min(o, e[a][c]), l = Math.max(l, e[a][c]), s += e[a][c];
      var h;
      return t === "min" ? h = o : t === "max" ? h = l : t === "average" ? h = s / u : h = s, u === 0 ? NaN : h;
    });
  }
  function hft(n) {
    var t = {};
    n.eachSeriesByType("map", function(e) {
      var r = e.getHostGeoModel(), i = r ? "o" + r.id : "i" + e.getMapType();
      (t[i] = t[i] || []).push(e);
    }), P(t, function(e, r) {
      for (var i = cft(ht(e, function(s) {
        return s.getData();
      }), e[0].get("mapValueCalculation")), a = 0; a < e.length; a++) e[a].originalData = e[a].getData();
      for (var a = 0; a < e.length; a++) e[a].seriesGroup = e, e[a].needsDrawMap = a === 0 && !e[a].getHostGeoModel(), e[a].setData(i.cloneShallow()), e[a].mainSeries = e[0];
    });
  }
  function fft(n) {
    var t = {};
    n.eachSeriesByType("map", function(e) {
      var r = e.getMapType();
      if (!(e.getHostGeoModel() || t[r])) {
        var i = {};
        P(e.seriesGroup, function(s) {
          var o = s.coordinateSystem, l = s.originalData;
          s.get("showLegendSymbol") && n.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
            var h = l.getName(c), f = o.getRegion(h);
            if (!(!f || isNaN(u))) {
              var d = i[h] || 0, p = o.dataToPoint(f.getCenter());
              i[h] = d + 1, l.setItemLayout(c, {
                point: p,
                offset: d
              });
            }
          });
        });
        var a = e.getData();
        a.each(function(s) {
          var o = a.getName(s), l = a.getItemLayout(s) || {};
          l.showLabel = !i[o], a.setItemLayout(s, l);
        }), t[r] = true;
      }
    });
  }
  var oF = Tr, Kv = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this) || this;
      return r.type = "view", r.dimensions = [
        "x",
        "y"
      ], r._roamTransformable = new To(), r._rawTransformable = new To(), r.name = e, r;
    }
    return t.prototype.setBoundingRect = function(e, r, i, a) {
      return this._rect = new te(e, r, i, a), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(e, r, i, a) {
      this._transformTo(e, r, i, a), this._viewRect = new te(e, r, i, a);
    }, t.prototype._transformTo = function(e, r, i, a) {
      var s = this.getBoundingRect(), o = this._rawTransformable;
      o.transform = s.calculateTransform(new te(e, r, i, a));
      var l = o.parent;
      o.parent = null, o.decomposeTransform(), o.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(e, r) {
      e && (this._center = [
        yt(e[0], r.getWidth()),
        yt(e[1], r.getHeight())
      ], this._updateCenterAndZoom());
    }, t.prototype.setZoom = function(e) {
      e = e || 1;
      var r = this.zoomLimit;
      r && (r.max != null && (e = Math.min(r.max, e)), r.min != null && (e = Math.max(r.min, e))), this._zoom = e, this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var e = this.getBoundingRect(), r = e.x + e.width / 2, i = e.y + e.height / 2;
      return [
        r,
        i
      ];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var e = this._rawTransformable.getLocalTransform(), r = this._roamTransformable, i = this.getDefaultCenter(), a = this.getCenter(), s = this.getZoom();
      a = Tr([], a, e), i = Tr([], i, e), r.originX = a[0], r.originY = a[1], r.x = i[0] - a[0], r.y = i[1] - a[1], r.scaleX = r.scaleY = s, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var e = this._roamTransformable, r = this._rawTransformable;
      r.parent = e, e.updateTransform(), r.updateTransform(), Ok(this.transform || (this.transform = []), r.transform || Xi()), this._rawTransform = r.getLocalTransform(), this.invTransform = this.invTransform || [], yd(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var e = this._rawTransformable, r = this._roamTransformable, i = new To();
      return i.transform = r.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: e.x,
          y: e.y,
          scaleX: e.scaleX,
          scaleY: e.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var e = this.getBoundingRect().clone();
      return e.applyTransform(this.transform), e;
    }, t.prototype.dataToPoint = function(e, r, i) {
      var a = r ? this._rawTransform : this.transform;
      return i = i || [], a ? oF(i, e, a) : ri(i, e);
    }, t.prototype.pointToData = function(e) {
      var r = this.invTransform;
      return r ? oF([], e, r) : [
        e[0],
        e[1]
      ];
    }, t.prototype.convertToPixel = function(e, r, i) {
      var a = lF(r);
      return a === this ? a.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(e, r, i) {
      var a = lF(r);
      return a === this ? a.pointToData(i) : null;
    }, t.prototype.containPoint = function(e) {
      return this.getViewRectAfterRoam().contain(e[0], e[1]);
    }, t.dimensions = [
      "x",
      "y"
    ], t;
  }(To);
  function lF(n) {
    var t = n.seriesModel;
    return t ? t.coordinateSystem : null;
  }
  var dft = {
    geoJSON: {
      aspectScale: 0.75,
      invertLongitute: true
    },
    geoSVG: {
      aspectScale: 1,
      invertLongitute: false
    }
  }, J6 = [
    "lng",
    "lat"
  ], kA = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this, e) || this;
      a.dimensions = J6, a.type = "geo", a._nameCoordMap = It(), a.map = r;
      var s = i.projection, o = Ho.load(r, i.nameMap, i.nameProperty), l = Ho.getGeoResource(r);
      a.resourceType = l ? l.type : null;
      var u = a.regions = o.regions, c = dft[l.type];
      a._regionsMap = o.regionsMap, a.regions = o.regions, a.projection = s;
      var h;
      if (s) for (var f = 0; f < u.length; f++) {
        var d = u[f].getBoundingRect(s);
        h = h || d.clone(), h.union(d);
      }
      else h = o.boundingRect;
      return a.setBoundingRect(h.x, h.y, h.width, h.height), a.aspectScale = s ? 1 : Ht(i.aspectScale, c.aspectScale), a._invertLongitute = s ? false : c.invertLongitute, a;
    }
    return t.prototype._transformTo = function(e, r, i, a) {
      var s = this.getBoundingRect(), o = this._invertLongitute;
      s = s.clone(), o && (s.y = -s.y - s.height);
      var l = this._rawTransformable;
      l.transform = s.calculateTransform(new te(e, r, i, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, o && (l.scaleY = -l.scaleY), this._updateTransform();
    }, t.prototype.getRegion = function(e) {
      return this._regionsMap.get(e);
    }, t.prototype.getRegionByCoord = function(e) {
      for (var r = this.regions, i = 0; i < r.length; i++) {
        var a = r[i];
        if (a.type === "geoJSON" && a.contain(e)) return r[i];
      }
    }, t.prototype.addGeoCoord = function(e, r) {
      this._nameCoordMap.set(e, r);
    }, t.prototype.getGeoCoord = function(e) {
      var r = this._regionsMap.get(e);
      return this._nameCoordMap.get(e) || r && r.getCenter();
    }, t.prototype.dataToPoint = function(e, r, i) {
      if (wt(e) && (e = this.getGeoCoord(e)), e) {
        var a = this.projection;
        return a && (e = a.project(e)), e && this.projectedToPoint(e, r, i);
      }
    }, t.prototype.pointToData = function(e) {
      var r = this.projection;
      return r && (e = r.unproject(e)), e && this.pointToProjected(e);
    }, t.prototype.pointToProjected = function(e) {
      return n.prototype.pointToData.call(this, e);
    }, t.prototype.projectedToPoint = function(e, r, i) {
      return n.prototype.dataToPoint.call(this, e, r, i);
    }, t.prototype.convertToPixel = function(e, r, i) {
      var a = uF(r);
      return a === this ? a.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(e, r, i) {
      var a = uF(r);
      return a === this ? a.pointToData(i) : null;
    }, t;
  }(Kv);
  zn(kA, Kv);
  function uF(n) {
    var t = n.geoModel, e = n.seriesModel;
    return t ? t.coordinateSystem : e ? e.coordinateSystem || (e.getReferringComponents("geo", On).models[0] || {}).coordinateSystem : null;
  }
  function cF(n, t) {
    var e = n.get("boundingCoords");
    if (e != null) {
      var r = e[0], i = e[1];
      if (isFinite(r[0]) && isFinite(r[1]) && isFinite(i[0]) && isFinite(i[1])) {
        var a = this.projection;
        if (a) {
          var s = r[0], o = r[1], l = i[0], u = i[1];
          r = [
            1 / 0,
            1 / 0
          ], i = [
            -1 / 0,
            -1 / 0
          ];
          var c = function(w, S, I, T) {
            for (var A = I - w, C = T - S, D = 0; D <= 100; D++) {
              var E = D / 100, M = a.project([
                w + A * E,
                S + C * E
              ]);
              Cl(r, r, M), Tl(i, i, M);
            }
          };
          c(s, o, l, o), c(l, o, l, u), c(l, u, s, u), c(s, u, l, o);
        }
        this.setBoundingRect(r[0], r[1], i[0] - r[0], i[1] - r[1]);
      }
    }
    var h = this.getBoundingRect(), f = n.get("layoutCenter"), d = n.get("layoutSize"), p = t.getWidth(), g = t.getHeight(), v = h.width / h.height * this.aspectScale, m = false, y, x;
    f && d && (y = [
      yt(f[0], p),
      yt(f[1], g)
    ], x = yt(d, Math.min(p, g)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(x) && (m = true));
    var b;
    if (m) b = {}, v > 1 ? (b.width = x, b.height = x / v) : (b.height = x, b.width = x * v), b.y = y[1] - b.height / 2, b.x = y[0] - b.width / 2;
    else {
      var _ = n.getBoxLayoutParams();
      _.aspect = v, b = Zn(_, {
        width: p,
        height: g
      });
    }
    this.setViewRect(b.x, b.y, b.width, b.height), this.setCenter(n.get("center"), t), this.setZoom(n.get("zoom"));
  }
  function pft(n, t) {
    P(t.get("geoCoord"), function(e, r) {
      n.addGeoCoord(r, e);
    });
  }
  var gft = function() {
    function n() {
      this.dimensions = J6;
    }
    return n.prototype.create = function(t, e) {
      var r = [];
      function i(s) {
        return {
          nameProperty: s.get("nameProperty"),
          aspectScale: s.get("aspectScale"),
          projection: s.get("projection")
        };
      }
      t.eachComponent("geo", function(s, o) {
        var l = s.get("map"), u = new kA(l + o, l, rt({
          nameMap: s.get("nameMap")
        }, i(s)));
        u.zoomLimit = s.get("scaleLimit"), r.push(u), s.coordinateSystem = u, u.model = s, u.resize = cF, u.resize(s, e);
      }), t.eachSeries(function(s) {
        var o = s.get("coordinateSystem");
        if (o === "geo") {
          var l = s.get("geoIndex") || 0;
          s.coordinateSystem = r[l];
        }
      });
      var a = {};
      return t.eachSeriesByType("map", function(s) {
        if (!s.getHostGeoModel()) {
          var o = s.getMapType();
          a[o] = a[o] || [], a[o].push(s);
        }
      }), P(a, function(s, o) {
        var l = ht(s, function(c) {
          return c.get("nameMap");
        }), u = new kA(o, o, rt({
          nameMap: Nk(l)
        }, i(s[0])));
        u.zoomLimit = mr.apply(null, ht(s, function(c) {
          return c.get("scaleLimit");
        })), r.push(u), u.resize = cF, u.resize(s[0], e), P(s, function(c) {
          c.coordinateSystem = u, pft(u, c);
        });
      }), r;
    }, n.prototype.getFilledRegions = function(t, e, r, i) {
      for (var a = (t || []).slice(), s = It(), o = 0; o < a.length; o++) s.set(a[o].name, a[o]);
      var l = Ho.load(e, r, i);
      return P(l.regions, function(u) {
        var c = u.name, h = s.get(c), f = u.properties && u.properties.echartsStyle;
        h || (h = {
          name: c
        }, a.push(h)), f && Zt(h, f);
      }), a;
    }, n;
  }(), Q6 = new gft(), vft = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, r, i) {
      var a = Ho.getGeoResource(e.map);
      if (a && a.type === "geoJSON") {
        var s = e.itemStyle = e.itemStyle || {};
        "color" in s || (s.color = "#eee");
      }
      this.mergeDefaultAndTheme(e, i), Wc(e, "label", [
        "show"
      ]);
    }, t.prototype.optionUpdated = function() {
      var e = this, r = this.option;
      r.regions = Q6.getFilledRegions(r.regions, r.map, r.nameMap, r.nameProperty);
      var i = {};
      this._optionModelMap = Qs(r.regions || [], function(a, s) {
        var o = s.name;
        return o && (a.set(o, new $e(s, e, e.ecModel)), s.selected && (i[o] = true)), a;
      }, It()), r.selectedMap || (r.selectedMap = i);
    }, t.prototype.getRegionModel = function(e) {
      return this._optionModelMap.get(e) || new $e(null, this, this.ecModel);
    }, t.prototype.getFormattedLabel = function(e, r) {
      var i = this.getRegionModel(e), a = r === "normal" ? i.get([
        "label",
        "formatter"
      ]) : i.get([
        "emphasis",
        "label",
        "formatter"
      ]), s = {
        name: e
      };
      if (Nt(a)) return s.status = r, a(s);
      if (wt(a)) return a.replace("{a}", e ?? "");
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.select = function(e) {
      var r = this.option, i = r.selectedMode;
      if (i) {
        i !== "multiple" && (r.selectedMap = null);
        var a = r.selectedMap || (r.selectedMap = {});
        a[e] = true;
      }
    }, t.prototype.unSelect = function(e) {
      var r = this.option.selectedMap;
      r && (r[e] = false);
    }, t.prototype.toggleSelected = function(e) {
      this[this.isSelected(e) ? "unSelect" : "select"](e);
    }, t.prototype.isSelected = function(e) {
      var r = this.option.selectedMap;
      return !!(r && r[e]);
    }, t.type = "geo", t.layoutMode = "box", t.defaultOption = {
      z: 0,
      show: true,
      left: "center",
      top: "center",
      aspectScale: null,
      silent: false,
      map: "",
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
    }, t;
  }(pe);
  function hF(n, t) {
    return n.pointToProjected ? n.pointToProjected(t) : n.pointToData(t);
  }
  function HD(n, t, e, r) {
    var i = n.getZoom(), a = n.getCenter(), s = t.zoom, o = n.projectedToPoint ? n.projectedToPoint(a) : n.dataToPoint(a);
    if (t.dx != null && t.dy != null && (o[0] -= t.dx, o[1] -= t.dy, n.setCenter(hF(n, o), r)), s != null) {
      if (e) {
        var l = e.min || 0, u = e.max || 1 / 0;
        s = Math.max(Math.min(i * s, u), l) / i;
      }
      n.scaleX *= s, n.scaleY *= s;
      var c = (t.originX - n.x) * (s - 1), h = (t.originY - n.y) * (s - 1);
      n.x -= c, n.y -= h, n.updateTransform(), n.setCenter(hF(n, o), r), n.setZoom(s * i);
    }
    return {
      center: n.getCenter(),
      zoom: n.getZoom()
    };
  }
  var mft = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.focusBlurEnabled = true, e;
    }
    return t.prototype.init = function(e, r) {
      this._api = r;
    }, t.prototype.render = function(e, r, i, a) {
      if (this._model = e, !e.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new Z6(i));
      var s = this._mapDraw;
      s.draw(e, r, i, this, a), s.group.on("click", this._handleRegionClick, this), s.group.silent = e.get("silent"), this.group.add(s.group), this.updateSelectStatus(e, r, i);
    }, t.prototype._handleRegionClick = function(e) {
      var r;
      bc(e.target, function(i) {
        return (r = Ut(i).eventData) != null;
      }, true), r && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: r.name
      });
    }, t.prototype.updateSelectStatus = function(e, r, i) {
      var a = this;
      this._mapDraw.group.traverse(function(s) {
        var o = Ut(s).eventData;
        if (o) return a._model.isSelected(o.name) ? i.enterSelect(s) : i.leaveSelect(s), true;
      });
    }, t.prototype.findHighDownDispatchers = function(e) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(e, this._model);
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, t.type = "geo", t;
  }(vn);
  function yft(n, t, e) {
    Ho.registerMap(n, t, e);
  }
  function t8(n) {
    n.registerCoordinateSystem("geo", Q6), n.registerComponentModel(vft), n.registerComponentView(mft), n.registerImpl("registerMap", yft), n.registerImpl("getMap", function(e) {
      return Ho.getMapForUser(e);
    });
    function t(e, r) {
      r.update = "geo:updateSelectStatus", n.registerAction(r, function(i, a) {
        var s = {}, o = [];
        return a.eachComponent({
          mainType: "geo",
          query: i
        }, function(l) {
          l[e](i.name);
          var u = l.coordinateSystem;
          P(u.regions, function(h) {
            s[h.name] = l.isSelected(h.name) || false;
          });
          var c = [];
          P(s, function(h, f) {
            s[f] && c.push(f);
          }), o.push({
            geoIndex: l.componentIndex,
            name: c
          });
        }), {
          selected: s,
          allSelected: o,
          name: i.name
        };
      });
    }
    t("toggleSelected", {
      type: "geoToggleSelect",
      event: "geoselectchanged"
    }), t("select", {
      type: "geoSelect",
      event: "geoselected"
    }), t("unSelect", {
      type: "geoUnSelect",
      event: "geounselected"
    }), n.registerAction({
      type: "geoRoam",
      event: "geoRoam",
      update: "updateTransform"
    }, function(e, r, i) {
      var a = e.componentType || "series";
      r.eachComponent({
        mainType: a,
        query: e
      }, function(s) {
        var o = s.coordinateSystem;
        if (o.type === "geo") {
          var l = HD(o, e, s.get("scaleLimit"), i);
          s.setCenter && s.setCenter(l.center), s.setZoom && s.setZoom(l.zoom), a === "series" && P(s.seriesGroup, function(u) {
            u.setCenter(l.center), u.setZoom(l.zoom);
          });
        }
      });
    });
  }
  function xft(n) {
    se(t8), n.registerChartView(lft), n.registerSeriesModel(uft), n.registerLayout(fft), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, hft), eH("map", n.registerAction);
  }
  function bft(n) {
    var t = n;
    t.hierNode = {
      defaultAncestor: null,
      ancestor: t,
      prelim: 0,
      modifier: 0,
      change: 0,
      shift: 0,
      i: 0,
      thread: null
    };
    for (var e = [
      t
    ], r, i; r = e.pop(); ) if (i = r.children, r.isExpand && i.length) for (var a = i.length, s = a - 1; s >= 0; s--) {
      var o = i[s];
      o.hierNode = {
        defaultAncestor: null,
        ancestor: o,
        prelim: 0,
        modifier: 0,
        change: 0,
        shift: 0,
        i: s,
        thread: null
      }, e.push(o);
    }
  }
  function _ft(n, t) {
    var e = n.isExpand ? n.children : [], r = n.parentNode.children, i = n.hierNode.i ? r[n.hierNode.i - 1] : null;
    if (e.length) {
      Cft(n);
      var a = (e[0].hierNode.prelim + e[e.length - 1].hierNode.prelim) / 2;
      i ? (n.hierNode.prelim = i.hierNode.prelim + t(n, i), n.hierNode.modifier = n.hierNode.prelim - a) : n.hierNode.prelim = a;
    } else i && (n.hierNode.prelim = i.hierNode.prelim + t(n, i));
    n.parentNode.hierNode.defaultAncestor = Tft(n, i, n.parentNode.hierNode.defaultAncestor || r[0], t);
  }
  function wft(n) {
    var t = n.hierNode.prelim + n.parentNode.hierNode.modifier;
    n.setLayout({
      x: t
    }, true), n.hierNode.modifier += n.parentNode.hierNode.modifier;
  }
  function fF(n) {
    return arguments.length ? n : kft;
  }
  function Hp(n, t) {
    return n -= Math.PI / 2, {
      x: t * Math.cos(n),
      y: t * Math.sin(n)
    };
  }
  function Sft(n, t) {
    return Zn(n.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    });
  }
  function Cft(n) {
    for (var t = n.children, e = t.length, r = 0, i = 0; --e >= 0; ) {
      var a = t[e];
      a.hierNode.prelim += r, a.hierNode.modifier += r, i += a.hierNode.change, r += a.hierNode.shift + i;
    }
  }
  function Tft(n, t, e, r) {
    if (t) {
      for (var i = n, a = n, s = a.parentNode.children[0], o = t, l = i.hierNode.modifier, u = a.hierNode.modifier, c = s.hierNode.modifier, h = o.hierNode.modifier; o = fC(o), a = dC(a), o && a; ) {
        i = fC(i), s = dC(s), i.hierNode.ancestor = n;
        var f = o.hierNode.prelim + h - a.hierNode.prelim - u + r(o, a);
        f > 0 && (Aft(Ift(o, n, e), n, f), u += f, l += f), h += o.hierNode.modifier, u += a.hierNode.modifier, l += i.hierNode.modifier, c += s.hierNode.modifier;
      }
      o && !fC(i) && (i.hierNode.thread = o, i.hierNode.modifier += h - l), a && !dC(s) && (s.hierNode.thread = a, s.hierNode.modifier += u - c, e = n);
    }
    return e;
  }
  function fC(n) {
    var t = n.children;
    return t.length && n.isExpand ? t[t.length - 1] : n.hierNode.thread;
  }
  function dC(n) {
    var t = n.children;
    return t.length && n.isExpand ? t[0] : n.hierNode.thread;
  }
  function Ift(n, t, e) {
    return n.hierNode.ancestor.parentNode === t.parentNode ? n.hierNode.ancestor : e;
  }
  function Aft(n, t, e) {
    var r = e / (t.hierNode.i - n.hierNode.i);
    t.hierNode.change -= r, t.hierNode.shift += e, t.hierNode.modifier += e, t.hierNode.prelim += e, n.hierNode.change += r;
  }
  function kft(n, t) {
    return n.parentNode === t.parentNode ? 1 : 2;
  }
  var Dft = /* @__PURE__ */ function() {
    function n() {
      this.parentPoint = [], this.childPoints = [];
    }
    return n;
  }(), Eft = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new Dft();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.childPoints, a = i.length, s = r.parentPoint, o = i[0], l = i[a - 1];
      if (a === 1) {
        e.moveTo(s[0], s[1]), e.lineTo(o[0], o[1]);
        return;
      }
      var u = r.orient, c = u === "TB" || u === "BT" ? 0 : 1, h = 1 - c, f = yt(r.forkPosition, 1), d = [];
      d[c] = s[c], d[h] = s[h] + (l[h] - s[h]) * f, e.moveTo(s[0], s[1]), e.lineTo(d[0], d[1]), e.moveTo(o[0], o[1]), d[c] = o[c], e.lineTo(d[0], d[1]), d[c] = l[c], e.lineTo(d[0], d[1]), e.lineTo(l[0], l[1]);
      for (var p = 1; p < a - 1; p++) {
        var g = i[p];
        e.moveTo(g[0], g[1]), d[c] = g[c], e.lineTo(d[0], d[1]);
      }
    }, t;
  }(le), Mft = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._mainGroup = new Vt(), e;
    }
    return t.prototype.init = function(e, r) {
      this._controller = new jv(r.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(e, r, i) {
      var a = e.getData(), s = e.layoutInfo, o = this._mainGroup, l = e.get("layout");
      l === "radial" ? (o.x = s.x + s.width / 2, o.y = s.y + s.height / 2) : (o.x = s.x, o.y = s.y), this._updateViewCoordSys(e, i), this._updateController(e, r, i);
      var u = this._data;
      a.diff(u).add(function(c) {
        dF(a, c) && pF(a, c, null, o, e);
      }).update(function(c, h) {
        var f = u.getItemGraphicEl(h);
        if (!dF(a, c)) {
          f && vF(u, h, f, o, e);
          return;
        }
        pF(a, c, f, o, e);
      }).remove(function(c) {
        var h = u.getItemGraphicEl(c);
        h && vF(u, c, h, o, e);
      }).execute(), this._nodeScaleRatio = e.get("nodeScaleRatio"), this._updateNodeAndLinkScale(e), e.get("expandAndCollapse") === true && a.eachItemGraphicEl(function(c, h) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: e.id,
            dataIndex: h
          });
        });
      }), this._data = a;
    }, t.prototype._updateViewCoordSys = function(e, r) {
      var i = e.getData(), a = [];
      i.each(function(h) {
        var f = i.getItemLayout(h);
        f && !isNaN(f.x) && !isNaN(f.y) && a.push([
          +f.x,
          +f.y
        ]);
      });
      var s = [], o = [];
      C1(a, s, o);
      var l = this._min, u = this._max;
      o[0] - s[0] === 0 && (s[0] = l ? l[0] : s[0] - 1, o[0] = u ? u[0] : o[0] + 1), o[1] - s[1] === 0 && (s[1] = l ? l[1] : s[1] - 1, o[1] = u ? u[1] : o[1] + 1);
      var c = e.coordinateSystem = new Kv();
      c.zoomLimit = e.get("scaleLimit"), c.setBoundingRect(s[0], s[1], o[0] - s[0], o[1] - s[1]), c.setCenter(e.get("center"), r), c.setZoom(e.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = s, this._max = o;
    }, t.prototype._updateController = function(e, r, i) {
      var a = this, s = this._controller, o = this._controllerHost, l = this.group;
      s.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !q1(u, i, e);
      }), s.enable(e.get("roam")), o.zoomLimit = e.get("scaleLimit"), o.zoom = e.coordinateSystem.getZoom(), s.off("pan").off("zoom").on("pan", function(u) {
        GD(o, u.dx, u.dy), i.dispatchAction({
          seriesId: e.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        WD(o, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: e.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(e), i.updateLabelLayout();
      });
    }, t.prototype._updateNodeAndLinkScale = function(e) {
      var r = e.getData(), i = this._getNodeGlobalScale(e);
      r.eachItemGraphicEl(function(a, s) {
        a.setSymbolScale(i);
      });
    }, t.prototype._getNodeGlobalScale = function(e) {
      var r = e.coordinateSystem;
      if (r.type !== "view") return 1;
      var i = this._nodeScaleRatio, a = r.scaleX || 1, s = r.getZoom(), o = (s - 1) * i + 1;
      return o / a;
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, t.type = "tree", t;
  }(qe);
  function dF(n, t) {
    var e = n.getItemLayout(t);
    return e && !isNaN(e.x) && !isNaN(e.y);
  }
  function pF(n, t, e, r, i) {
    var a = !e, s = n.tree.getNodeByDataIndex(t), o = s.getModel(), l = s.getVisual("style").fill, u = s.isExpand === false && s.children.length !== 0 ? l : "#fff", c = n.tree.root, h = s.parentNode === c ? s : s.parentNode || s, f = n.getItemGraphicEl(h.dataIndex), d = h.getLayout(), p = f ? {
      x: f.__oldX,
      y: f.__oldY,
      rawX: f.__radialOldRawX,
      rawY: f.__radialOldRawY
    } : d, g = s.getLayout();
    a ? (e = new Wv(n, t, null, {
      symbolInnerColor: u,
      useNameLabel: true
    }), e.x = p.x, e.y = p.y) : e.updateData(n, t, null, {
      symbolInnerColor: u,
      useNameLabel: true
    }), e.__radialOldRawX = e.__radialRawX, e.__radialOldRawY = e.__radialRawY, e.__radialRawX = g.rawX, e.__radialRawY = g.rawY, r.add(e), n.setItemGraphicEl(t, e), e.__oldX = e.x, e.__oldY = e.y, Ie(e, {
      x: g.x,
      y: g.y
    }, i);
    var v = e.getSymbolPath();
    if (i.get("layout") === "radial") {
      var m = c.children[0], y = m.getLayout(), x = m.children.length, b = void 0, _ = void 0;
      if (g.x === y.x && s.isExpand === true && m.children.length) {
        var w = {
          x: (m.children[0].getLayout().x + m.children[x - 1].getLayout().x) / 2,
          y: (m.children[0].getLayout().y + m.children[x - 1].getLayout().y) / 2
        };
        b = Math.atan2(w.y - y.y, w.x - y.x), b < 0 && (b = Math.PI * 2 + b), _ = w.x < y.x, _ && (b = b - Math.PI);
      } else b = Math.atan2(g.y - y.y, g.x - y.x), b < 0 && (b = Math.PI * 2 + b), s.children.length === 0 || s.children.length !== 0 && s.isExpand === false ? (_ = g.x < y.x, _ && (b = b - Math.PI)) : (_ = g.x > y.x, _ || (b = b - Math.PI));
      var S = _ ? "left" : "right", I = o.getModel("label"), T = I.get("rotate"), A = T * (Math.PI / 180), C = v.getTextContent();
      C && (v.setTextConfig({
        position: I.get("position") || S,
        rotation: T == null ? -b : A,
        origin: "center"
      }), C.setStyle("verticalAlign", "middle"));
    }
    var D = o.get([
      "emphasis",
      "focus"
    ]), E = D === "relative" ? Mg(s.getAncestorsIndices(), s.getDescendantIndices()) : D === "ancestor" ? s.getAncestorsIndices() : D === "descendant" ? s.getDescendantIndices() : null;
    E && (Ut(e).focus = E), Rft(i, s, c, e, p, d, g, r), e.__edge && (e.onHoverStateChange = function(M) {
      if (M !== "blur") {
        var L = s.parentNode && n.getItemGraphicEl(s.parentNode.dataIndex);
        L && L.hoverState === Nv || Hx(e.__edge, M);
      }
    });
  }
  function Rft(n, t, e, r, i, a, s, o) {
    var l = t.getModel(), u = n.get("edgeShape"), c = n.get("layout"), h = n.getOrient(), f = n.get([
      "lineStyle",
      "curveness"
    ]), d = n.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = r.__edge;
    if (u === "curve") t.parentNode && t.parentNode !== e && (g || (g = r.__edge = new Pv({
      shape: DA(c, h, f, i, i)
    })), Ie(g, {
      shape: DA(c, h, f, a, s)
    }, n));
    else if (u === "polyline" && c === "orthogonal" && t !== e && t.children && t.children.length !== 0 && t.isExpand === true) {
      for (var v = t.children, m = [], y = 0; y < v.length; y++) {
        var x = v[y].getLayout();
        m.push([
          x.x,
          x.y
        ]);
      }
      g || (g = r.__edge = new Eft({
        shape: {
          parentPoint: [
            s.x,
            s.y
          ],
          childPoints: [
            [
              s.x,
              s.y
            ]
          ],
          orient: h,
          forkPosition: d
        }
      })), Ie(g, {
        shape: {
          parentPoint: [
            s.x,
            s.y
          ],
          childPoints: m
        }
      }, n);
    }
    g && !(u === "polyline" && !t.isExpand) && (g.useStyle($t({
      strokeNoScale: true,
      fill: null
    }, p)), Ar(g, l, "lineStyle"), Xc(g), o.add(g));
  }
  function gF(n, t, e, r, i) {
    var a = t.tree.root, s = e8(a, n), o = s.source, l = s.sourceLayout, u = t.getItemGraphicEl(n.dataIndex);
    if (u) {
      var c = t.getItemGraphicEl(o.dataIndex), h = c.__edge, f = u.__edge || (o.isExpand === false || o.children.length === 1 ? h : void 0), d = r.get("edgeShape"), p = r.get("layout"), g = r.get("orient"), v = r.get([
        "lineStyle",
        "curveness"
      ]);
      f && (d === "curve" ? ql(f, {
        shape: DA(p, g, v, l, l),
        style: {
          opacity: 0
        }
      }, r, {
        cb: function() {
          e.remove(f);
        },
        removeOpt: i
      }) : d === "polyline" && r.get("layout") === "orthogonal" && ql(f, {
        shape: {
          parentPoint: [
            l.x,
            l.y
          ],
          childPoints: [
            [
              l.x,
              l.y
            ]
          ]
        },
        style: {
          opacity: 0
        }
      }, r, {
        cb: function() {
          e.remove(f);
        },
        removeOpt: i
      }));
    }
  }
  function e8(n, t) {
    for (var e = t.parentNode === n ? t : t.parentNode || t, r; r = e.getLayout(), r == null; ) e = e.parentNode === n ? e : e.parentNode || e;
    return {
      source: e,
      sourceLayout: r
    };
  }
  function vF(n, t, e, r, i) {
    var a = n.tree.getNodeByDataIndex(t), s = n.tree.root, o = e8(s, a).sourceLayout, l = {
      duration: i.get("animationDurationUpdate"),
      easing: i.get("animationEasingUpdate")
    };
    ql(e, {
      x: o.x + 1,
      y: o.y + 1
    }, i, {
      cb: function() {
        r.remove(e), n.setItemGraphicEl(t, null);
      },
      removeOpt: l
    }), e.fadeOut(null, n.hostModel, {
      fadeLabel: true,
      animation: l
    }), a.children.forEach(function(u) {
      gF(u, n, r, i, l);
    }), gF(a, n, r, i, l);
  }
  function DA(n, t, e, r, i) {
    var a, s, o, l, u, c, h, f;
    if (n === "radial") {
      u = r.rawX, h = r.rawY, c = i.rawX, f = i.rawY;
      var d = Hp(u, h), p = Hp(u, h + (f - h) * e), g = Hp(c, f + (h - f) * e), v = Hp(c, f);
      return {
        x1: d.x || 0,
        y1: d.y || 0,
        x2: v.x || 0,
        y2: v.y || 0,
        cpx1: p.x || 0,
        cpy1: p.y || 0,
        cpx2: g.x || 0,
        cpy2: g.y || 0
      };
    } else u = r.x, h = r.y, c = i.x, f = i.y, (t === "LR" || t === "RL") && (a = u + (c - u) * e, s = h, o = c + (u - c) * e, l = f), (t === "TB" || t === "BT") && (a = u, s = h + (f - h) * e, o = c, l = f + (h - f) * e);
    return {
      x1: u,
      y1: h,
      x2: c,
      y2: f,
      cpx1: a,
      cpy1: s,
      cpx2: o,
      cpy2: l
    };
  }
  var Ta = xe();
  function n8(n) {
    var t = n.mainData, e = n.datas;
    e || (e = {
      main: t
    }, n.datasAttr = {
      main: "data"
    }), n.datas = n.mainData = null, r8(t, e, n), P(e, function(r) {
      P(t.TRANSFERABLE_METHODS, function(i) {
        r.wrapMethod(i, qt(Nft, n));
      });
    }), t.wrapMethod("cloneShallow", qt(Pft, n)), P(t.CHANGABLE_METHODS, function(r) {
      t.wrapMethod(r, qt(Lft, n));
    }), gi(e[t.dataType] === t);
  }
  function Nft(n, t) {
    if (Fft(this)) {
      var e = rt({}, Ta(this).datas);
      e[this.dataType] = t, r8(t, e, n);
    } else XD(t, this.dataType, Ta(this).mainData, n);
    return t;
  }
  function Lft(n, t) {
    return n.struct && n.struct.update(), t;
  }
  function Pft(n, t) {
    return P(Ta(t).datas, function(e, r) {
      e !== t && XD(e.cloneShallow(), r, t, n);
    }), t;
  }
  function $ft(n) {
    var t = Ta(this).mainData;
    return n == null || t == null ? t : Ta(t).datas[n];
  }
  function Oft() {
    var n = Ta(this).mainData;
    return n == null ? [
      {
        data: n
      }
    ] : ht(ge(Ta(n).datas), function(t) {
      return {
        type: t,
        data: Ta(n).datas[t]
      };
    });
  }
  function Fft(n) {
    return Ta(n).mainData === n;
  }
  function r8(n, t, e) {
    Ta(n).datas = {}, P(t, function(r, i) {
      XD(r, i, n, e);
    });
  }
  function XD(n, t, e, r) {
    Ta(e).datas[t] = n, Ta(n).mainData = e, n.dataType = t, r.struct && (n[r.structAttr] = r.struct, r.struct[r.datasAttr[t]] = n), n.getLinkedData = $ft, n.getLinkedDataAll = Oft;
  }
  var Bft = function() {
    function n(t, e) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = false, this.name = t || "", this.hostTree = e;
    }
    return n.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, n.prototype.eachNode = function(t, e, r) {
      Nt(t) && (r = e, e = t, t = null), t = t || {}, wt(t) && (t = {
        order: t
      });
      var i = t.order || "preorder", a = this[t.attr || "children"], s;
      i === "preorder" && (s = e.call(r, this));
      for (var o = 0; !s && o < a.length; o++) a[o].eachNode(t, e, r);
      i === "postorder" && e.call(r, this);
    }, n.prototype.updateDepthAndHeight = function(t) {
      var e = 0;
      this.depth = t;
      for (var r = 0; r < this.children.length; r++) {
        var i = this.children[r];
        i.updateDepthAndHeight(t + 1), i.height > e && (e = i.height);
      }
      this.height = e + 1;
    }, n.prototype.getNodeById = function(t) {
      if (this.getId() === t) return this;
      for (var e = 0, r = this.children, i = r.length; e < i; e++) {
        var a = r[e].getNodeById(t);
        if (a) return a;
      }
    }, n.prototype.contains = function(t) {
      if (t === this) return true;
      for (var e = 0, r = this.children, i = r.length; e < i; e++) {
        var a = r[e].contains(t);
        if (a) return a;
      }
    }, n.prototype.getAncestors = function(t) {
      for (var e = [], r = t ? this : this.parentNode; r; ) e.push(r), r = r.parentNode;
      return e.reverse(), e;
    }, n.prototype.getAncestorsIndices = function() {
      for (var t = [], e = this; e; ) t.push(e.dataIndex), e = e.parentNode;
      return t.reverse(), t;
    }, n.prototype.getDescendantIndices = function() {
      var t = [];
      return this.eachNode(function(e) {
        t.push(e.dataIndex);
      }), t;
    }, n.prototype.getValue = function(t) {
      var e = this.hostTree.data;
      return e.getStore().get(e.getDimensionIndex(t || "value"), this.dataIndex);
    }, n.prototype.setLayout = function(t, e) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
    }, n.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, n.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostTree, r = e.data.getItemModel(this.dataIndex);
        return r.getModel(t);
      }
    }, n.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, n.prototype.setVisual = function(t, e) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
    }, n.prototype.getVisual = function(t) {
      return this.hostTree.data.getItemVisual(this.dataIndex, t);
    }, n.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, n.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, n.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var t = this.parentNode.children, e = 0; e < t.length; ++e) if (t[e] === this) return e;
        return -1;
      }
      return -1;
    }, n.prototype.isAncestorOf = function(t) {
      for (var e = t.parentNode; e; ) {
        if (e === this) return true;
        e = e.parentNode;
      }
      return false;
    }, n.prototype.isDescendantOf = function(t) {
      return t !== this && t.isAncestorOf(this);
    }, n;
  }(), YD = function() {
    function n(t) {
      this.type = "tree", this._nodes = [], this.hostModel = t;
    }
    return n.prototype.eachNode = function(t, e, r) {
      this.root.eachNode(t, e, r);
    }, n.prototype.getNodeByDataIndex = function(t) {
      var e = this.data.getRawIndex(t);
      return this._nodes[e];
    }, n.prototype.getNodeById = function(t) {
      return this.root.getNodeById(t);
    }, n.prototype.update = function() {
      for (var t = this.data, e = this._nodes, r = 0, i = e.length; r < i; r++) e[r].dataIndex = -1;
      for (var r = 0, i = t.count(); r < i; r++) e[t.getRawIndex(r)].dataIndex = r;
    }, n.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, n.createTree = function(t, e, r) {
      var i = new n(e), a = [], s = 1;
      o(t);
      function o(c, h) {
        var f = c.value;
        s = Math.max(s, ct(f) ? f.length : 1), a.push(c);
        var d = new Bft(Un(c.name, ""), i);
        h ? zft(d, h) : i.root = d, i._nodes.push(d);
        var p = c.children;
        if (p) for (var g = 0; g < p.length; g++) o(p[g], d);
      }
      i.root.updateDepthAndHeight(0);
      var l = Vv(a, {
        coordDimensions: [
          "value"
        ],
        dimensionsCount: s
      }).dimensions, u = new fi(l, e);
      return u.initData(a), r && r(u), n8({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, n;
  }();
  function zft(n, t) {
    var e = t.children;
    n.parentNode !== t && (e.push(n), n.parentNode = t);
  }
  function Zg(n, t, e) {
    if (n && ne(t, n.type) >= 0) {
      var r = e.getData().tree.root, i = n.targetNode;
      if (wt(i) && (i = r.getNodeById(i)), i && r.contains(i)) return {
        node: i
      };
      var a = n.targetNodeId;
      if (a != null && (i = r.getNodeById(a))) return {
        node: i
      };
    }
  }
  function i8(n) {
    for (var t = []; n; ) n = n.parentNode, n && t.push(n);
    return t.reverse();
  }
  function qD(n, t) {
    var e = i8(n);
    return ne(e, t) >= 0;
  }
  function K1(n, t) {
    for (var e = []; n; ) {
      var r = n.dataIndex;
      e.push({
        name: n.name,
        dataIndex: r,
        value: t.getRawValue(r)
      }), n = n.parentNode;
    }
    return e.reverse(), e;
  }
  var Vft = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.hasSymbolVisual = true, e.ignoreStyleOnData = true, e;
    }
    return t.prototype.getInitialData = function(e) {
      var r = {
        name: e.name,
        children: e.data
      }, i = e.leaves || {}, a = new $e(i, this, this.ecModel), s = YD.createTree(r, this, o);
      function o(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = s.getNodeByDataIndex(d);
          return p && p.children.length && p.isExpand || (f.parentModel = a), f;
        });
      }
      var l = 0;
      s.eachNode("preorder", function(h) {
        h.depth > l && (l = h.depth);
      });
      var u = e.expandAndCollapse, c = u && e.initialTreeDepth >= 0 ? e.initialTreeDepth : l;
      return s.root.eachNode("preorder", function(h) {
        var f = h.hostTree.data.getRawDataItem(h.dataIndex);
        h.isExpand = f && f.collapsed != null ? !f.collapsed : h.depth <= c;
      }), s.data;
    }, t.prototype.getOrient = function() {
      var e = this.get("orient");
      return e === "horizontal" ? e = "LR" : e === "vertical" && (e = "TB"), e;
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.formatTooltip = function(e, r, i) {
      for (var a = this.getData().tree, s = a.root.children[0], o = a.getNodeByDataIndex(e), l = o.getValue(), u = o.name; o && o !== s; ) u = o.parentNode.name + "." + u, o = o.parentNode;
      return cr("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, t.prototype.getDataParams = function(e) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return r.treeAncestors = K1(i, this), r.collapsed = !i.isExpand, r;
    }, t.type = "series.tree", t.layoutMode = "box", t.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      layout: "orthogonal",
      edgeShape: "curve",
      edgeForkPosition: "50%",
      roam: false,
      nodeScaleRatio: 0.4,
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: true,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        borderWidth: 1.5
      },
      label: {
        show: true
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, t;
  }(an);
  function Gft(n, t, e) {
    for (var r = [
      n
    ], i = [], a; a = r.pop(); ) if (i.push(a), a.isExpand) {
      var s = a.children;
      if (s.length) for (var o = 0; o < s.length; o++) r.push(s[o]);
    }
    for (; a = i.pop(); ) t(a, e);
  }
  function xp(n, t) {
    for (var e = [
      n
    ], r; r = e.pop(); ) if (t(r), r.isExpand) {
      var i = r.children;
      if (i.length) for (var a = i.length - 1; a >= 0; a--) e.push(i[a]);
    }
  }
  function Wft(n, t) {
    n.eachSeriesByType("tree", function(e) {
      Uft(e, t);
    });
  }
  function Uft(n, t) {
    var e = Sft(n, t);
    n.layoutInfo = e;
    var r = n.get("layout"), i = 0, a = 0, s = null;
    r === "radial" ? (i = 2 * Math.PI, a = Math.min(e.height, e.width) / 2, s = fF(function(x, b) {
      return (x.parentNode === b.parentNode ? 1 : 2) / x.depth;
    })) : (i = e.width, a = e.height, s = fF());
    var o = n.getData().tree.root, l = o.children[0];
    if (l) {
      bft(o), Gft(l, _ft, s), o.hierNode.modifier = -l.hierNode.prelim, xp(l, wft);
      var u = l, c = l, h = l;
      xp(l, function(x) {
        var b = x.getLayout().x;
        b < u.getLayout().x && (u = x), b > c.getLayout().x && (c = x), x.depth > h.depth && (h = x);
      });
      var f = u === c ? 1 : s(u, c) / 2, d = f - u.getLayout().x, p = 0, g = 0, v = 0, m = 0;
      if (r === "radial") p = i / (c.getLayout().x + f + d), g = a / (h.depth - 1 || 1), xp(l, function(x) {
        v = (x.getLayout().x + d) * p, m = (x.depth - 1) * g;
        var b = Hp(v, m);
        x.setLayout({
          x: b.x,
          y: b.y,
          rawX: v,
          rawY: m
        }, true);
      });
      else {
        var y = n.getOrient();
        y === "RL" || y === "LR" ? (g = a / (c.getLayout().x + f + d), p = i / (h.depth - 1 || 1), xp(l, function(x) {
          m = (x.getLayout().x + d) * g, v = y === "LR" ? (x.depth - 1) * p : i - (x.depth - 1) * p, x.setLayout({
            x: v,
            y: m
          }, true);
        })) : (y === "TB" || y === "BT") && (p = i / (c.getLayout().x + f + d), g = a / (h.depth - 1 || 1), xp(l, function(x) {
          v = (x.getLayout().x + d) * p, m = y === "TB" ? (x.depth - 1) * g : a - (x.depth - 1) * g, x.setLayout({
            x: v,
            y: m
          }, true);
        }));
      }
    }
  }
  function Hft(n) {
    n.eachSeriesByType("tree", function(t) {
      var e = t.getData(), r = e.tree;
      r.eachNode(function(i) {
        var a = i.getModel(), s = a.getModel("itemStyle").getItemStyle(), o = e.ensureUniqueItemVisual(i.dataIndex, "style");
        rt(o, s);
      });
    });
  }
  function Xft(n) {
    n.registerAction({
      type: "treeExpandAndCollapse",
      event: "treeExpandAndCollapse",
      update: "update"
    }, function(t, e) {
      e.eachComponent({
        mainType: "series",
        subType: "tree",
        query: t
      }, function(r) {
        var i = t.dataIndex, a = r.getData().tree, s = a.getNodeByDataIndex(i);
        s.isExpand = !s.isExpand;
      });
    }), n.registerAction({
      type: "treeRoam",
      event: "treeRoam",
      update: "none"
    }, function(t, e, r) {
      e.eachComponent({
        mainType: "series",
        subType: "tree",
        query: t
      }, function(i) {
        var a = i.coordinateSystem, s = HD(a, t, void 0, r);
        i.setCenter && i.setCenter(s.center), i.setZoom && i.setZoom(s.zoom);
      });
    });
  }
  function Yft(n) {
    n.registerChartView(Mft), n.registerSeriesModel(Vft), n.registerLayout(Wft), n.registerVisual(Hft), Xft(n);
  }
  var mF = [
    "treemapZoomToNode",
    "treemapRender",
    "treemapMove"
  ];
  function qft(n) {
    for (var t = 0; t < mF.length; t++) n.registerAction({
      type: mF[t],
      update: "updateView"
    }, Dn);
    n.registerAction({
      type: "treemapRootToNode",
      update: "updateView"
    }, function(e, r) {
      r.eachComponent({
        mainType: "series",
        subType: "treemap",
        query: e
      }, i);
      function i(a, s) {
        var o = [
          "treemapZoomToNode",
          "treemapRootToNode"
        ], l = Zg(e, o, a);
        if (l) {
          var u = a.getViewRoot();
          u && (e.direction = qD(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
        }
      }
    });
  }
  function a8(n) {
    var t = n.getData(), e = t.tree, r = {};
    e.eachNode(function(i) {
      for (var a = i; a && a.depth > 1; ) a = a.parentNode;
      var s = rA(n.ecModel, a.name || a.dataIndex + "", r);
      i.setVisual("decal", s);
    });
  }
  var jft = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.preventUsingHoverLayer = true, e;
    }
    return t.prototype.getInitialData = function(e, r) {
      var i = {
        name: e.name,
        children: e.data
      };
      s8(i);
      var a = e.levels || [], s = this.designatedVisualItemStyle = {}, o = new $e({
        itemStyle: s
      }, this, r);
      a = e.levels = Kft(a, r);
      var l = ht(a || [], function(h) {
        return new $e(h, o, r);
      }, this), u = YD.createTree(i, this, c);
      function c(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = u.getNodeByDataIndex(d), g = p ? l[p.depth] : null;
          return f.parentModel = g || o, f;
        });
      }
      return u.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.formatTooltip = function(e, r, i) {
      var a = this.getData(), s = this.getRawValue(e), o = a.getName(e);
      return cr("nameValue", {
        name: o,
        value: s
      });
    }, t.prototype.getDataParams = function(e) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return r.treeAncestors = K1(i, this), r.treePathInfo = r.treeAncestors, r;
    }, t.prototype.setLayoutInfo = function(e) {
      this.layoutInfo = this.layoutInfo || {}, rt(this.layoutInfo, e);
    }, t.prototype.mapIdToIndex = function(e) {
      var r = this._idIndexMap;
      r || (r = this._idIndexMap = It(), this._idIndexMapCount = 0);
      var i = r.get(e);
      return i == null && r.set(e, i = this._idIndexMapCount++), i;
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(e) {
      e ? this._viewRoot = e : e = this._viewRoot;
      var r = this.getRawData().tree.root;
      (!e || e !== r && !r.contains(e)) && (this._viewRoot = r);
    }, t.prototype.enableAriaDecal = function() {
      a8(this);
    }, t.type = "series.treemap", t.layoutMode = "box", t.defaultOption = {
      progressive: 0,
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: true,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "\u25B6",
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: true,
      nodeClick: "zoomToNode",
      animation: true,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: true,
        height: 22,
        left: "center",
        top: "bottom",
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
          }
        }
      },
      label: {
        show: true,
        distance: 0,
        padding: 5,
        position: "inside",
        color: "#fff",
        overflow: "truncate"
      },
      upperLabel: {
        show: false,
        position: [
          0,
          "50%"
        ],
        height: 20,
        overflow: "truncate",
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
      },
      emphasis: {
        upperLabel: {
          show: true,
          position: [
            0,
            "50%"
          ],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: []
    }, t;
  }(an);
  function s8(n) {
    var t = 0;
    P(n.children, function(r) {
      s8(r);
      var i = r.value;
      ct(i) && (i = i[0]), t += i;
    });
    var e = n.value;
    ct(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), ct(n.value) ? n.value[0] = e : n.value = e;
  }
  function Kft(n, t) {
    var e = He(t.get("color")), r = He(t.get([
      "aria",
      "decal",
      "decals"
    ]));
    if (e) {
      n = n || [];
      var i, a;
      P(n, function(o) {
        var l = new $e(o), u = l.get("color"), c = l.get("decal");
        (l.get([
          "itemStyle",
          "color"
        ]) || u && u !== "none") && (i = true), (l.get([
          "itemStyle",
          "decal"
        ]) || c && c !== "none") && (a = true);
      });
      var s = n[0] || (n[0] = {});
      return i || (s.color = e.slice()), !a && r && (s.decal = r.slice()), n;
    }
  }
  var Zft = 8, yF = 8, pC = 5, Jft = function() {
    function n(t) {
      this.group = new Vt(), t.add(this.group);
    }
    return n.prototype.render = function(t, e, r, i) {
      var a = t.getModel("breadcrumb"), s = this.group;
      if (s.removeAll(), !(!a.get("show") || !r)) {
        var o = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = o.getModel("textStyle"), c = l.getModel([
          "itemStyle",
          "textStyle"
        ]), h = {
          pos: {
            left: a.get("left"),
            right: a.get("right"),
            top: a.get("top"),
            bottom: a.get("bottom")
          },
          box: {
            width: e.getWidth(),
            height: e.getHeight()
          },
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(r, h, u), this._renderContent(t, h, o, l, u, c, i), O1(s, h.pos, h.box);
      }
    }, n.prototype._prepare = function(t, e, r) {
      for (var i = t; i; i = i.parentNode) {
        var a = Un(i.getModel().get("name"), ""), s = r.getTextRect(a), o = Math.max(s.width + Zft * 2, e.emptyItemWidth);
        e.totalWidth += o + yF, e.renderList.push({
          node: i,
          text: a,
          width: o
        });
      }
    }, n.prototype._renderContent = function(t, e, r, i, a, s, o) {
      for (var l = 0, u = e.emptyItemWidth, c = t.get([
        "breadcrumb",
        "height"
      ]), h = sat(e.pos, e.box), f = e.totalWidth, d = e.renderList, p = i.getModel("itemStyle").getItemStyle(), g = d.length - 1; g >= 0; g--) {
        var v = d[g], m = v.node, y = v.width, x = v.text;
        f > h.width && (f -= y - u, y = u, x = null);
        var b = new yi({
          shape: {
            points: Qft(l, 0, y, c, g === d.length - 1, g === 0)
          },
          style: $t(r.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new be({
            style: nn(a, {
              text: x
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: bd * 1e4,
          onclick: qt(o, m)
        });
        b.disableLabelAnimation = true, b.getTextContent().ensureState("emphasis").style = nn(s, {
          text: x
        }), b.ensureState("emphasis").style = p, bn(b, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(b), tdt(b, t, m), l += y + yF;
      }
    }, n.prototype.remove = function() {
      this.group.removeAll();
    }, n;
  }();
  function Qft(n, t, e, r, i, a) {
    var s = [
      [
        i ? n : n - pC,
        t
      ],
      [
        n + e,
        t
      ],
      [
        n + e,
        t + r
      ],
      [
        i ? n : n - pC,
        t + r
      ]
    ];
    return !a && s.splice(2, 0, [
      n + e + pC,
      t + r / 2
    ]), !i && s.push([
      n,
      t + r / 2
    ]), s;
  }
  function tdt(n, t, e) {
    Ut(n).eventData = {
      componentType: "series",
      componentSubType: "treemap",
      componentIndex: t.componentIndex,
      seriesIndex: t.seriesIndex,
      seriesName: t.name,
      seriesType: "treemap",
      selfType: "breadcrumb",
      nodeData: {
        dataIndex: e && e.dataIndex,
        name: e && e.name
      },
      treePathInfo: e && K1(e, t)
    };
  }
  var edt = function() {
    function n() {
      this._storage = [], this._elExistsMap = {};
    }
    return n.prototype.add = function(t, e, r, i, a) {
      return this._elExistsMap[t.id] ? false : (this._elExistsMap[t.id] = true, this._storage.push({
        el: t,
        target: e,
        duration: r,
        delay: i,
        easing: a
      }), true);
    }, n.prototype.finished = function(t) {
      return this._finishedCallback = t, this;
    }, n.prototype.start = function() {
      for (var t = this, e = this._storage.length, r = function() {
        e--, e <= 0 && (t._storage.length = 0, t._elExistsMap = {}, t._finishedCallback && t._finishedCallback());
      }, i = 0, a = this._storage.length; i < a; i++) {
        var s = this._storage[i];
        s.el.animateTo(s.target, {
          duration: s.duration,
          delay: s.delay,
          easing: s.easing,
          setToFinal: true,
          done: r,
          aborted: r
        });
      }
      return this;
    }, n;
  }();
  function ndt() {
    return new edt();
  }
  var EA = Vt, xF = ye, bF = 3, _F = "label", wF = "upperLabel", rdt = bd * 10, idt = bd * 2, adt = bd * 3, tc = Hc([
    [
      "fill",
      "color"
    ],
    [
      "stroke",
      "strokeColor"
    ],
    [
      "lineWidth",
      "strokeWidth"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ]
  ]), SF = function(n) {
    var t = tc(n);
    return t.stroke = t.fill = t.lineWidth = null, t;
  }, db = xe(), sdt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._state = "ready", e._storage = bp(), e;
    }
    return t.prototype.render = function(e, r, i, a) {
      var s = r.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(ne(s, e) < 0)) {
        this.seriesModel = e, this.api = i, this.ecModel = r;
        var o = [
          "treemapZoomToNode",
          "treemapRootToNode"
        ], l = Zg(a, o, e), u = a && a.type, c = e.layoutInfo, h = !this._oldTree, f = this._storage, d = u === "treemapRootToNode" && l && f ? {
          rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, p = this._giveContainerGroup(c), g = e.get("animation"), v = this._doRender(p, e, d);
        g && !h && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, v, e, d) : v.renderFinally(), this._resetController(i), this._renderBreadcrumb(e, i, l);
      }
    }, t.prototype._giveContainerGroup = function(e) {
      var r = this._containerGroup;
      return r || (r = this._containerGroup = new EA(), this._initEvents(r), this.group.add(r)), r.x = e.x, r.y = e.y, r;
    }, t.prototype._doRender = function(e, r, i) {
      var a = r.getData().tree, s = this._oldTree, o = bp(), l = bp(), u = this._storage, c = [];
      function h(y, x, b, _) {
        return odt(r, l, u, i, o, c, y, x, b, _);
      }
      g(a.root ? [
        a.root
      ] : [], s && s.root ? [
        s.root
      ] : [], e, a === s || !s, 0);
      var f = v(u);
      if (this._oldTree = a, this._storage = l, this._controllerHost) {
        var d = this.seriesModel.layoutInfo, p = a.root.getLayout();
        p.width === d.width && p.height === d.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: o,
        willDeleteEls: f,
        renderFinally: m
      };
      function g(y, x, b, _, w) {
        _ ? (x = y, P(y, function(T, A) {
          !T.isRemoved() && I(A, A);
        })) : new Wo(x, y, S, S).add(I).update(I).remove(qt(I, null)).execute();
        function S(T) {
          return T.getId();
        }
        function I(T, A) {
          var C = T != null ? y[T] : null, D = A != null ? x[A] : null, E = h(C, D, b, w);
          E && g(C && C.viewChildren || [], D && D.viewChildren || [], E, _, w + 1);
        }
      }
      function v(y) {
        var x = bp();
        return y && P(y, function(b, _) {
          var w = x[_];
          P(b, function(S) {
            S && (w.push(S), db(S).willDelete = true);
          });
        }), x;
      }
      function m() {
        P(f, function(y) {
          P(y, function(x) {
            x.parent && x.parent.remove(x);
          });
        }), P(c, function(y) {
          y.invisible = true, y.dirty();
        });
      }
    }, t.prototype._doAnimation = function(e, r, i, a) {
      var s = i.get("animationDurationUpdate"), o = i.get("animationEasing"), l = (Nt(s) ? 0 : s) || 0, u = (Nt(o) ? null : o) || "cubicOut", c = ndt();
      P(r.willDeleteEls, function(h, f) {
        P(h, function(d, p) {
          if (!d.invisible) {
            var g = d.parent, v, m = db(g);
            if (a && a.direction === "drillDown") v = g === a.rootNodeGroup ? {
              shape: {
                x: 0,
                y: 0,
                width: m.nodeWidth,
                height: m.nodeHeight
              },
              style: {
                opacity: 0
              }
            } : {
              style: {
                opacity: 0
              }
            };
            else {
              var y = 0, x = 0;
              m.willDelete || (y = m.nodeWidth / 2, x = m.nodeHeight / 2), v = f === "nodeGroup" ? {
                x: y,
                y: x,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: x,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            v && c.add(d, v, l, 0, u);
          }
        });
      }), P(this._storage, function(h, f) {
        P(h, function(d, p) {
          var g = r.lastsForAnimation[f][p], v = {};
          g && (d instanceof Vt ? g.oldX != null && (v.x = d.x, v.y = d.y, d.x = g.oldX, d.y = g.oldY) : (g.oldShape && (v.shape = rt({}, d.shape), d.setShape(g.oldShape)), g.fadein ? (d.setStyle("opacity", 0), v.style = {
            opacity: 1
          }) : d.style.opacity !== 1 && (v.style = {
            opacity: 1
          })), c.add(d, v, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(St(function() {
        this._state = "ready", r.renderFinally();
      }, this)).start();
    }, t.prototype._resetController = function(e) {
      var r = this._controller, i = this._controllerHost;
      i || (this._controllerHost = {
        target: this.group
      }, i = this._controllerHost), r || (r = this._controller = new jv(e.getZr()), r.enable(this.seriesModel.get("roam")), i.zoomLimit = this.seriesModel.get("scaleLimit"), i.zoom = this.seriesModel.get("zoom"), r.on("pan", St(this._onPan, this)), r.on("zoom", St(this._onZoom, this)));
      var a = new te(0, 0, e.getWidth(), e.getHeight());
      r.setPointerChecker(function(s, o, l) {
        return a.contain(o, l);
      });
    }, t.prototype._clearController = function() {
      var e = this._controller;
      this._controllerHost = null, e && (e.dispose(), e = null);
    }, t.prototype._onPan = function(e) {
      if (this._state !== "animating" && (Math.abs(e.dx) > bF || Math.abs(e.dy) > bF)) {
        var r = this.seriesModel.getData().tree.root;
        if (!r) return;
        var i = r.getLayout();
        if (!i) return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + e.dx,
            y: i.y + e.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, t.prototype._onZoom = function(e) {
      var r = e.originX, i = e.originY, a = e.scale;
      if (this._state !== "animating") {
        var s = this.seriesModel.getData().tree.root;
        if (!s) return;
        var o = s.getLayout();
        if (!o) return;
        var l = new te(o.x, o.y, o.width, o.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var h = c.zoom = c.zoom || 1;
        if (h *= a, u) {
          var f = u.min || 0, d = u.max || 1 / 0;
          h = Math.max(Math.min(d, h), f);
        }
        var p = h / c.zoom;
        c.zoom = h;
        var g = this.seriesModel.layoutInfo;
        r -= g.x, i -= g.y;
        var v = Xi();
        to(v, v, [
          -r,
          -i
        ]), Fk(v, v, [
          p,
          p
        ]), to(v, v, [
          r,
          i
        ]), l.applyTransform(v), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, t.prototype._initEvents = function(e) {
      var r = this;
      e.on("click", function(i) {
        if (r._state === "ready") {
          var a = r.seriesModel.get("nodeClick", true);
          if (a) {
            var s = r.findTarget(i.offsetX, i.offsetY);
            if (s) {
              var o = s.node;
              if (o.getLayout().isLeafRoot) r._rootToNode(s);
              else if (a === "zoomToNode") r._zoomToNode(s);
              else if (a === "link") {
                var l = o.hostTree.data.getItemModel(o.dataIndex), u = l.get("link", true), c = l.get("target", true) || "blank";
                u && Zx(u, c);
              }
            }
          }
        }
      }, this);
    }, t.prototype._renderBreadcrumb = function(e, r, i) {
      var a = this;
      i || (i = e.get("leafDepth", true) != null ? {
        node: e.getViewRoot()
      } : this.findTarget(r.getWidth() / 2, r.getHeight() / 2), i || (i = {
        node: e.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new Jft(this.group))).render(e, r, i.node, function(s) {
        a._state !== "animating" && (qD(e.getViewRoot(), s) ? a._rootToNode({
          node: s
        }) : a._zoomToNode({
          node: s
        }));
      });
    }, t.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = bp(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, t.prototype.dispose = function() {
      this._clearController();
    }, t.prototype._zoomToNode = function(e) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e.node
      });
    }, t.prototype._rootToNode = function(e) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e.node
      });
    }, t.prototype.findTarget = function(e, r) {
      var i, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(s) {
        var o = this._storage.background[s.getRawIndex()];
        if (o) {
          var l = o.transformCoordToLocal(e, r), u = o.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height) i = {
            node: s,
            offsetX: l[0],
            offsetY: l[1]
          };
          else return false;
        }
      }, this), i;
    }, t.type = "treemap", t;
  }(qe);
  function bp() {
    return {
      nodeGroup: [],
      background: [],
      content: []
    };
  }
  function odt(n, t, e, r, i, a, s, o, l, u) {
    if (!s) return;
    var c = s.getLayout(), h = n.getData(), f = s.getModel();
    if (h.setItemGraphicEl(s.dataIndex, null), !c || !c.isInView) return;
    var d = c.width, p = c.height, g = c.borderWidth, v = c.invisible, m = s.getRawIndex(), y = o && o.getRawIndex(), x = s.viewChildren, b = c.upperHeight, _ = x && x.length, w = f.getModel("itemStyle"), S = f.getModel([
      "emphasis",
      "itemStyle"
    ]), I = f.getModel([
      "blur",
      "itemStyle"
    ]), T = f.getModel([
      "select",
      "itemStyle"
    ]), A = w.get("borderRadius") || 0, C = X("nodeGroup", EA);
    if (!C) return;
    if (l.add(C), C.x = c.x || 0, C.y = c.y || 0, C.markRedraw(), db(C).nodeWidth = d, db(C).nodeHeight = p, c.isAboveViewRoot) return C;
    var D = X("background", xF, u, idt);
    D && O(C, D, _ && c.upperLabelHeight);
    var E = f.getModel("emphasis"), M = E.get("focus"), L = E.get("blurScope"), k = E.get("disabled"), N = M === "ancestor" ? s.getAncestorsIndices() : M === "descendant" ? s.getDescendantIndices() : M;
    if (_) Fg(C) && yc(C, false), D && (yc(D, !k), h.setItemGraphicEl(s.dataIndex, D), jI(D, N, L));
    else {
      var R = X("content", xF, u, adt);
      R && F(C, R), D.disableMorphing = true, D && Fg(D) && yc(D, false), yc(C, !k), h.setItemGraphicEl(s.dataIndex, C);
      var $ = f.getShallow("cursor");
      $ && R.attr("cursor", $), jI(C, N, L);
    }
    return C;
    function O(it, et, ft) {
      var ut = Ut(et);
      if (ut.dataIndex = s.dataIndex, ut.seriesIndex = n.seriesIndex, et.setShape({
        x: 0,
        y: 0,
        width: d,
        height: p,
        r: A
      }), v) z(et);
      else {
        et.invisible = false;
        var gt = s.getVisual("style"), kt = gt.stroke, At = SF(w);
        At.fill = kt;
        var mt = tc(S);
        mt.fill = S.get("borderColor");
        var _t = tc(I);
        _t.fill = I.get("borderColor");
        var ee = tc(T);
        if (ee.fill = T.get("borderColor"), ft) {
          var G = d - 2 * g;
          V(et, kt, gt.opacity, {
            x: g,
            y: 0,
            width: G,
            height: b
          });
        } else et.removeTextContent();
        et.setStyle(At), et.ensureState("emphasis").style = mt, et.ensureState("blur").style = _t, et.ensureState("select").style = ee, Xc(et);
      }
      it.add(et);
    }
    function F(it, et) {
      var ft = Ut(et);
      ft.dataIndex = s.dataIndex, ft.seriesIndex = n.seriesIndex;
      var ut = Math.max(d - 2 * g, 0), gt = Math.max(p - 2 * g, 0);
      if (et.culling = true, et.setShape({
        x: g,
        y: g,
        width: ut,
        height: gt,
        r: A
      }), v) z(et);
      else {
        et.invisible = false;
        var kt = s.getVisual("style"), At = kt.fill, mt = SF(w);
        mt.fill = At, mt.decal = kt.decal;
        var _t = tc(S), ee = tc(I), G = tc(T);
        V(et, At, kt.opacity, null), et.setStyle(mt), et.ensureState("emphasis").style = _t, et.ensureState("blur").style = ee, et.ensureState("select").style = G, Xc(et);
      }
      it.add(et);
    }
    function z(it) {
      !it.invisible && a.push(it);
    }
    function V(it, et, ft, ut) {
      var gt = f.getModel(ut ? wF : _F), kt = Un(f.get("name"), null), At = gt.getShallow("show");
      kr(it, ur(f, ut ? wF : _F), {
        defaultText: At ? kt : null,
        inheritColor: et,
        defaultOpacity: ft,
        labelFetcher: n,
        labelDataIndex: s.dataIndex
      });
      var mt = it.getTextContent();
      if (mt) {
        var _t = mt.style, ee = Pk(_t.padding || 0);
        ut && (it.setTextConfig({
          layoutRect: ut
        }), mt.disableLabelLayout = true), mt.beforeUpdate = function() {
          var H = Math.max((ut ? ut.width : it.shape.width) - ee[1] - ee[3], 0), dt = Math.max((ut ? ut.height : it.shape.height) - ee[0] - ee[2], 0);
          (_t.width !== H || _t.height !== dt) && mt.setStyle({
            width: H,
            height: dt
          });
        }, _t.truncateMinChar = 2, _t.lineOverflow = "truncate", U(_t, ut, c);
        var G = mt.getState("emphasis");
        U(G ? G.style : null, ut, c);
      }
    }
    function U(it, et, ft) {
      var ut = it ? it.text : null;
      if (!et && ft.isLeafRoot && ut != null) {
        var gt = n.get("drillDownIcon", true);
        it.text = gt ? gt + " " + ut : ut;
      }
    }
    function X(it, et, ft, ut) {
      var gt = y != null && e[it][y], kt = i[it];
      return gt ? (e[it][y] = null, at(kt, gt)) : v || (gt = new et(), gt instanceof Ia && (gt.z2 = ldt(ft, ut)), pt(kt, gt)), t[it][m] = gt;
    }
    function at(it, et) {
      var ft = it[m] = {};
      et instanceof EA ? (ft.oldX = et.x, ft.oldY = et.y) : ft.oldShape = rt({}, et.shape);
    }
    function pt(it, et) {
      var ft = it[m] = {}, ut = s.parentNode, gt = et instanceof Vt;
      if (ut && (!r || r.direction === "drillDown")) {
        var kt = 0, At = 0, mt = i.background[ut.getRawIndex()];
        !r && mt && mt.oldShape && (kt = mt.oldShape.width, At = mt.oldShape.height), gt ? (ft.oldX = 0, ft.oldY = At) : ft.oldShape = {
          x: kt,
          y: At,
          width: 0,
          height: 0
        };
      }
      ft.fadein = !gt;
    }
  }
  function ldt(n, t) {
    return n * rdt + t;
  }
  var Jg = P, udt = Ft, pb = -1, or = function() {
    function n(t) {
      var e = t.mappingMethod, r = t.type, i = this.option = Bt(t);
      this.type = r, this.mappingMethod = e, this._normalizeData = fdt[e];
      var a = n.visualHandlers[r];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[e], e === "piecewise" ? (gC(i), cdt(i)) : e === "category" ? i.categories ? hdt(i) : gC(i, true) : (gi(e !== "linear" || i.dataExtent), gC(i));
    }
    return n.prototype.mapValueToVisual = function(t) {
      var e = this._normalizeData(t);
      return this._normalizedToVisual(e, t);
    }, n.prototype.getNormalizer = function() {
      return St(this._normalizeData, this);
    }, n.listVisualTypes = function() {
      return ge(n.visualHandlers);
    }, n.isValidType = function(t) {
      return n.visualHandlers.hasOwnProperty(t);
    }, n.eachVisual = function(t, e, r) {
      Ft(t) ? P(t, e, r) : e.call(r, t);
    }, n.mapVisual = function(t, e, r) {
      var i, a = ct(t) ? [] : Ft(t) ? {} : (i = true, null);
      return n.eachVisual(t, function(s, o) {
        var l = e.call(r, s, o);
        i ? a = l : a[o] = l;
      }), a;
    }, n.retrieveVisuals = function(t) {
      var e = {}, r;
      return t && Jg(n.visualHandlers, function(i, a) {
        t.hasOwnProperty(a) && (e[a] = t[a], r = true);
      }), r ? e : null;
    }, n.prepareVisualTypes = function(t) {
      if (ct(t)) t = t.slice();
      else if (udt(t)) {
        var e = [];
        Jg(t, function(r, i) {
          e.push(i);
        }), t = e;
      } else return [];
      return t.sort(function(r, i) {
        return i === "color" && r !== "color" && r.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, n.dependsOn = function(t, e) {
      return e === "color" ? !!(t && t.indexOf(e) === 0) : t === e;
    }, n.findPieceIndex = function(t, e, r) {
      for (var i, a = 1 / 0, s = 0, o = e.length; s < o; s++) {
        var l = e[s].value;
        if (l != null) {
          if (l === t || wt(l) && l === t + "") return s;
          r && f(l, s);
        }
      }
      for (var s = 0, o = e.length; s < o; s++) {
        var u = e[s], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (o0(h[1], t, c[1])) return s;
          } else if (c[1] === 1 / 0) {
            if (o0(h[0], c[0], t)) return s;
          } else if (o0(h[0], c[0], t) && o0(h[1], t, c[1])) return s;
          r && f(c[0], s), r && f(c[1], s);
        }
      }
      if (r) return t === 1 / 0 ? e.length - 1 : t === -1 / 0 ? 0 : i;
      function f(d, p) {
        var g = Math.abs(d - t);
        g < a && (a = g, i = p);
      }
    }, n.visualHandlers = {
      color: {
        applyVisual: _p("color"),
        getColorMapper: function() {
          var t = this.option;
          return St(t.mappingMethod === "category" ? function(e, r) {
            return !r && (e = this._normalizeData(e)), Xp.call(this, e);
          } : function(e, r, i) {
            var a = !!i;
            return !r && (e = this._normalizeData(e)), i = jw(e, t.parsedVisual, i), a ? i : No(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return No(jw(t, this.option.parsedVisual), "rgba");
          },
          category: Xp,
          piecewise: function(t, e) {
            var r = RA.call(this, e);
            return r == null && (r = No(jw(t, this.option.parsedVisual), "rgba")), r;
          },
          fixed: ec
        }
      },
      colorHue: s0(function(t, e) {
        return lg(t, e);
      }),
      colorSaturation: s0(function(t, e) {
        return lg(t, null, e);
      }),
      colorLightness: s0(function(t, e) {
        return lg(t, null, null, e);
      }),
      colorAlpha: s0(function(t, e) {
        return Bx(t, e);
      }),
      decal: {
        applyVisual: _p("decal"),
        _normalizedToVisual: {
          linear: null,
          category: Xp,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: _p("opacity"),
        _normalizedToVisual: MA([
          0,
          1
        ])
      },
      liftZ: {
        applyVisual: _p("liftZ"),
        _normalizedToVisual: {
          linear: ec,
          category: ec,
          piecewise: ec,
          fixed: ec
        }
      },
      symbol: {
        applyVisual: function(t, e, r) {
          var i = this.mapValueToVisual(t);
          r("symbol", i);
        },
        _normalizedToVisual: {
          linear: CF,
          category: Xp,
          piecewise: function(t, e) {
            var r = RA.call(this, e);
            return r == null && (r = CF.call(this, t)), r;
          },
          fixed: ec
        }
      },
      symbolSize: {
        applyVisual: _p("symbolSize"),
        _normalizedToVisual: MA([
          0,
          1
        ])
      }
    }, n;
  }();
  function cdt(n) {
    var t = n.pieceList;
    n.hasSpecialVisual = false, P(t, function(e, r) {
      e.originIndex = r, e.visual != null && (n.hasSpecialVisual = true);
    });
  }
  function hdt(n) {
    var t = n.categories, e = n.categoryMap = {}, r = n.visual;
    if (Jg(t, function(s, o) {
      e[s] = o;
    }), !ct(r)) {
      var i = [];
      Ft(r) ? Jg(r, function(s, o) {
        var l = e[o];
        i[l ?? pb] = s;
      }) : i[pb] = r, r = o8(n, i);
    }
    for (var a = t.length - 1; a >= 0; a--) r[a] == null && (delete e[t[a]], t.pop());
  }
  function gC(n, t) {
    var e = n.visual, r = [];
    Ft(e) ? Jg(e, function(a) {
      r.push(a);
    }) : e != null && r.push(e);
    var i = {
      color: 1,
      symbol: 1
    };
    !t && r.length === 1 && !i.hasOwnProperty(n.type) && (r[1] = r[0]), o8(n, r);
  }
  function s0(n) {
    return {
      applyVisual: function(t, e, r) {
        var i = this.mapValueToVisual(t);
        r("color", n(e("color"), i));
      },
      _normalizedToVisual: MA([
        0,
        1
      ])
    };
  }
  function CF(n) {
    var t = this.option.visual;
    return t[Math.round(Pe(n, [
      0,
      1
    ], [
      0,
      t.length - 1
    ], true))] || {};
  }
  function _p(n) {
    return function(t, e, r) {
      r(n, this.mapValueToVisual(t));
    };
  }
  function Xp(n) {
    var t = this.option.visual;
    return t[this.option.loop && n !== pb ? n % t.length : n];
  }
  function ec() {
    return this.option.visual[0];
  }
  function MA(n) {
    return {
      linear: function(t) {
        return Pe(t, n, this.option.visual, true);
      },
      category: Xp,
      piecewise: function(t, e) {
        var r = RA.call(this, e);
        return r == null && (r = Pe(t, n, this.option.visual, true)), r;
      },
      fixed: ec
    };
  }
  function RA(n) {
    var t = this.option, e = t.pieceList;
    if (t.hasSpecialVisual) {
      var r = or.findPieceIndex(n, e), i = e[r];
      if (i && i.visual) return i.visual[this.type];
    }
  }
  function o8(n, t) {
    return n.visual = t, n.type === "color" && (n.parsedVisual = ht(t, function(e) {
      var r = Yi(e);
      return r || [
        0,
        0,
        0,
        1
      ];
    })), t;
  }
  var fdt = {
    linear: function(n) {
      return Pe(n, this.option.dataExtent, [
        0,
        1
      ], true);
    },
    piecewise: function(n) {
      var t = this.option.pieceList, e = or.findPieceIndex(n, t, true);
      if (e != null) return Pe(e, [
        0,
        t.length - 1
      ], [
        0,
        1
      ], true);
    },
    category: function(n) {
      var t = this.option.categories ? this.option.categoryMap[n] : n;
      return t ?? pb;
    },
    fixed: Dn
  };
  function o0(n, t, e) {
    return n ? t <= e : t < e;
  }
  var ddt = "itemStyle", l8 = xe();
  const pdt = {
    seriesType: "treemap",
    reset: function(n) {
      var t = n.getData().tree, e = t.root;
      e.isRemoved() || u8(e, {}, n.getViewRoot().getAncestors(), n);
    }
  };
  function u8(n, t, e, r) {
    var i = n.getModel(), a = n.getLayout(), s = n.hostTree.data;
    if (!(!a || a.invisible || !a.isInView)) {
      var o = i.getModel(ddt), l = gdt(o, t, r), u = s.ensureUniqueItemVisual(n.dataIndex, "style"), c = o.get("borderColor"), h = o.get("borderColorSaturation"), f;
      h != null && (f = TF(l), c = vdt(h, f)), u.stroke = c;
      var d = n.viewChildren;
      if (!d || !d.length) f = TF(l), u.fill = f;
      else {
        var p = mdt(n, i, a, o, l, d);
        P(d, function(g, v) {
          if (g.depth >= e.length || g === e[g.depth]) {
            var m = ydt(i, l, g, v, p, r);
            u8(g, m, e, r);
          }
        });
      }
    }
  }
  function gdt(n, t, e) {
    var r = rt({}, t), i = e.designatedVisualItemStyle;
    return P([
      "color",
      "colorAlpha",
      "colorSaturation"
    ], function(a) {
      i[a] = t[a];
      var s = n.get(a);
      i[a] = null, s != null && (r[a] = s);
    }), r;
  }
  function TF(n) {
    var t = vC(n, "color");
    if (t) {
      var e = vC(n, "colorAlpha"), r = vC(n, "colorSaturation");
      return r && (t = lg(t, null, null, r)), e && (t = Bx(t, e)), t;
    }
  }
  function vdt(n, t) {
    return t != null ? lg(t, null, null, n) : null;
  }
  function vC(n, t) {
    var e = n[t];
    if (e != null && e !== "none") return e;
  }
  function mdt(n, t, e, r, i, a) {
    if (!(!a || !a.length)) {
      var s = mC(t, "color") || i.color != null && i.color !== "none" && (mC(t, "colorAlpha") || mC(t, "colorSaturation"));
      if (s) {
        var o = t.get("visualMin"), l = t.get("visualMax"), u = e.dataExtent.slice();
        o != null && o < u[0] && (u[0] = o), l != null && l > u[1] && (u[1] = l);
        var c = t.get("colorMappingBy"), h = {
          type: s.name,
          dataExtent: u,
          visual: s.range
        };
        h.type === "color" && (c === "index" || c === "id") ? (h.mappingMethod = "category", h.loop = true) : h.mappingMethod = "linear";
        var f = new or(h);
        return l8(f).drColorMappingBy = c, f;
      }
    }
  }
  function mC(n, t) {
    var e = n.get(t);
    return ct(e) && e.length ? {
      name: t,
      range: e
    } : null;
  }
  function ydt(n, t, e, r, i, a) {
    var s = rt({}, t);
    if (i) {
      var o = i.type, l = o === "color" && l8(i).drColorMappingBy, u = l === "index" ? r : l === "id" ? a.mapIdToIndex(e.getId()) : e.getValue(n.get("visualDimension"));
      s[o] = i.mapValueToVisual(u);
    }
    return s;
  }
  var Qg = Math.max, gb = Math.min, IF = mr, jD = P, c8 = [
    "itemStyle",
    "borderWidth"
  ], xdt = [
    "itemStyle",
    "gapWidth"
  ], bdt = [
    "upperLabel",
    "show"
  ], _dt = [
    "upperLabel",
    "height"
  ];
  const wdt = {
    seriesType: "treemap",
    reset: function(n, t, e, r) {
      var i = e.getWidth(), a = e.getHeight(), s = n.option, o = Zn(n.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight()
      }), l = s.size || [], u = yt(IF(o.width, l[0]), i), c = yt(IF(o.height, l[1]), a), h = r && r.type, f = [
        "treemapZoomToNode",
        "treemapRootToNode"
      ], d = Zg(r, f, n), p = h === "treemapRender" || h === "treemapMove" ? r.rootRect : null, g = n.getViewRoot(), v = i8(g);
      if (h !== "treemapMove") {
        var m = h === "treemapZoomToNode" ? kdt(n, d, g, u, c) : p ? [
          p.width,
          p.height
        ] : [
          u,
          c
        ], y = s.sort;
        y && y !== "asc" && y !== "desc" && (y = "desc");
        var x = {
          squareRatio: s.squareRatio,
          sort: y,
          leafDepth: s.leafDepth
        };
        g.hostTree.clearLayouts();
        var b = {
          x: 0,
          y: 0,
          width: m[0],
          height: m[1],
          area: m[0] * m[1]
        };
        g.setLayout(b), h8(g, x, false, 0), b = g.getLayout(), jD(v, function(w, S) {
          var I = (v[S + 1] || g).getValue();
          w.setLayout(rt({
            dataExtent: [
              I,
              I
            ],
            borderWidth: 0,
            upperHeight: 0
          }, b));
        });
      }
      var _ = n.getData().tree.root;
      _.setLayout(Ddt(o, p, d), true), n.setLayoutInfo(o), f8(_, new te(-o.x, -o.y, i, a), v, g, 0);
    }
  };
  function h8(n, t, e, r) {
    var i, a;
    if (!n.isRemoved()) {
      var s = n.getLayout();
      i = s.width, a = s.height;
      var o = n.getModel(), l = o.get(c8), u = o.get(xdt) / 2, c = d8(o), h = Math.max(l, c), f = l - u, d = h - u;
      n.setLayout({
        borderWidth: l,
        upperHeight: h,
        upperLabelHeight: c
      }, true), i = Qg(i - 2 * f, 0), a = Qg(a - f - d, 0);
      var p = i * a, g = Sdt(n, o, p, t, e, r);
      if (g.length) {
        var v = {
          x: f,
          y: d,
          width: i,
          height: a
        }, m = gb(i, a), y = 1 / 0, x = [];
        x.area = 0;
        for (var b = 0, _ = g.length; b < _; ) {
          var w = g[b];
          x.push(w), x.area += w.getLayout().area;
          var S = Adt(x, m, t.squareRatio);
          S <= y ? (b++, y = S) : (x.area -= x.pop().getLayout().area, AF(x, m, v, u, false), m = gb(v.width, v.height), x.length = x.area = 0, y = 1 / 0);
        }
        if (x.length && AF(x, m, v, u, true), !e) {
          var I = o.get("childrenVisibleMin");
          I != null && p < I && (e = true);
        }
        for (var b = 0, _ = g.length; b < _; b++) h8(g[b], t, e, r + 1);
      }
    }
  }
  function Sdt(n, t, e, r, i, a) {
    var s = n.children || [], o = r.sort;
    o !== "asc" && o !== "desc" && (o = null);
    var l = r.leafDepth != null && r.leafDepth <= a;
    if (i && !l) return n.viewChildren = [];
    s = Le(s, function(d) {
      return !d.isRemoved();
    }), Tdt(s, o);
    var u = Idt(t, s, o);
    if (u.sum === 0) return n.viewChildren = [];
    if (u.sum = Cdt(t, e, u.sum, o, s), u.sum === 0) return n.viewChildren = [];
    for (var c = 0, h = s.length; c < h; c++) {
      var f = s[c].getValue() / u.sum * e;
      s[c].setLayout({
        area: f
      });
    }
    return l && (s.length && n.setLayout({
      isLeafRoot: true
    }, true), s.length = 0), n.viewChildren = s, n.setLayout({
      dataExtent: u.dataExtent
    }, true), s;
  }
  function Cdt(n, t, e, r, i) {
    if (!r) return e;
    for (var a = n.get("visibleMin"), s = i.length, o = s, l = s - 1; l >= 0; l--) {
      var u = i[r === "asc" ? s - l - 1 : l].getValue();
      u / e * t < a && (o = l, e -= u);
    }
    return r === "asc" ? i.splice(0, s - o) : i.splice(o, s - o), e;
  }
  function Tdt(n, t) {
    return t && n.sort(function(e, r) {
      var i = t === "asc" ? e.getValue() - r.getValue() : r.getValue() - e.getValue();
      return i === 0 ? t === "asc" ? e.dataIndex - r.dataIndex : r.dataIndex - e.dataIndex : i;
    }), n;
  }
  function Idt(n, t, e) {
    for (var r = 0, i = 0, a = t.length; i < a; i++) r += t[i].getValue();
    var s = n.get("visualDimension"), o;
    return !t || !t.length ? o = [
      NaN,
      NaN
    ] : s === "value" && e ? (o = [
      t[t.length - 1].getValue(),
      t[0].getValue()
    ], e === "asc" && o.reverse()) : (o = [
      1 / 0,
      -1 / 0
    ], jD(t, function(l) {
      var u = l.getValue(s);
      u < o[0] && (o[0] = u), u > o[1] && (o[1] = u);
    })), {
      sum: r,
      dataExtent: o
    };
  }
  function Adt(n, t, e) {
    for (var r = 0, i = 1 / 0, a = 0, s = void 0, o = n.length; a < o; a++) s = n[a].getLayout().area, s && (s < i && (i = s), s > r && (r = s));
    var l = n.area * n.area, u = t * t * e;
    return l ? Qg(u * r / l, l / (u * i)) : 1 / 0;
  }
  function AF(n, t, e, r, i) {
    var a = t === e.width ? 0 : 1, s = 1 - a, o = [
      "x",
      "y"
    ], l = [
      "width",
      "height"
    ], u = e[o[a]], c = t ? n.area / t : 0;
    (i || c > e[l[s]]) && (c = e[l[s]]);
    for (var h = 0, f = n.length; h < f; h++) {
      var d = n[h], p = {}, g = c ? d.getLayout().area / c : 0, v = p[l[s]] = Qg(c - 2 * r, 0), m = e[o[a]] + e[l[a]] - u, y = h === f - 1 || m < g ? m : g, x = p[l[a]] = Qg(y - 2 * r, 0);
      p[o[s]] = e[o[s]] + gb(r, v / 2), p[o[a]] = u + gb(r, x / 2), u += y, d.setLayout(p, true);
    }
    e[o[s]] += c, e[l[s]] -= c;
  }
  function kdt(n, t, e, r, i) {
    var a = (t || {}).node, s = [
      r,
      i
    ];
    if (!a || a === e) return s;
    for (var o, l = r * i, u = l * n.option.zoomToNodeRatio; o = a.parentNode; ) {
      for (var c = 0, h = o.children, f = 0, d = h.length; f < d; f++) c += h[f].getValue();
      var p = a.getValue();
      if (p === 0) return s;
      u *= c / p;
      var g = o.getModel(), v = g.get(c8), m = Math.max(v, d8(g));
      u += 4 * v * v + (3 * v + m) * Math.pow(u, 0.5), u > zL && (u = zL), a = o;
    }
    u < l && (u = l);
    var y = Math.pow(u / l, 0.5);
    return [
      r * y,
      i * y
    ];
  }
  function Ddt(n, t, e) {
    if (t) return {
      x: t.x,
      y: t.y
    };
    var r = {
      x: 0,
      y: 0
    };
    if (!e) return r;
    var i = e.node, a = i.getLayout();
    if (!a) return r;
    for (var s = [
      a.width / 2,
      a.height / 2
    ], o = i; o; ) {
      var l = o.getLayout();
      s[0] += l.x, s[1] += l.y, o = o.parentNode;
    }
    return {
      x: n.width / 2 - s[0],
      y: n.height / 2 - s[1]
    };
  }
  function f8(n, t, e, r, i) {
    var a = n.getLayout(), s = e[i], o = s && s === n;
    if (!(s && !o || i === e.length && n !== r)) {
      n.setLayout({
        isInView: true,
        invisible: !o && !t.intersect(a),
        isAboveViewRoot: o
      }, true);
      var l = new te(t.x - a.x, t.y - a.y, t.width, t.height);
      jD(n.viewChildren || [], function(u) {
        f8(u, l, e, r, i + 1);
      });
    }
  }
  function d8(n) {
    return n.get(bdt) ? n.get(_dt) : 0;
  }
  function Edt(n) {
    n.registerSeriesModel(jft), n.registerChartView(sdt), n.registerVisual(pdt), n.registerLayout(wdt), qft(n);
  }
  function Mdt(n) {
    var t = n.findComponents({
      mainType: "legend"
    });
    !t || !t.length || n.eachSeriesByType("graph", function(e) {
      var r = e.getCategoriesData(), i = e.getGraph(), a = i.data, s = r.mapArray(r.getName);
      a.filterSelf(function(o) {
        var l = a.getItemModel(o), u = l.getShallow("category");
        if (u != null) {
          _e(u) && (u = s[u]);
          for (var c = 0; c < t.length; c++) if (!t[c].isSelected(u)) return false;
        }
        return true;
      });
    });
  }
  function Rdt(n) {
    var t = {};
    n.eachSeriesByType("graph", function(e) {
      var r = e.getCategoriesData(), i = e.getData(), a = {};
      r.each(function(s) {
        var o = r.getName(s);
        a["ec-" + o] = s;
        var l = r.getItemModel(s), u = l.getModel("itemStyle").getItemStyle();
        u.fill || (u.fill = e.getColorFromPalette(o, t)), r.setItemVisual(s, "style", u);
        for (var c = [
          "symbol",
          "symbolSize",
          "symbolKeepAspect"
        ], h = 0; h < c.length; h++) {
          var f = l.getShallow(c[h], true);
          f != null && r.setItemVisual(s, c[h], f);
        }
      }), r.count() && i.each(function(s) {
        var o = i.getItemModel(s), l = o.getShallow("category");
        if (l != null) {
          wt(l) && (l = a["ec-" + l]);
          var u = r.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(s, "style");
          rt(c, u);
          for (var h = [
            "symbol",
            "symbolSize",
            "symbolKeepAspect"
          ], f = 0; f < h.length; f++) i.setItemVisual(s, h[f], r.getItemVisual(l, h[f]));
        }
      });
    });
  }
  function l0(n) {
    return n instanceof Array || (n = [
      n,
      n
    ]), n;
  }
  function Ndt(n) {
    n.eachSeriesByType("graph", function(t) {
      var e = t.getGraph(), r = t.getEdgeData(), i = l0(t.get("edgeSymbol")), a = l0(t.get("edgeSymbolSize"));
      r.setVisual("fromSymbol", i && i[0]), r.setVisual("toSymbol", i && i[1]), r.setVisual("fromSymbolSize", a && a[0]), r.setVisual("toSymbolSize", a && a[1]), r.setVisual("style", t.getModel("lineStyle").getLineStyle()), r.each(function(s) {
        var o = r.getItemModel(s), l = e.getEdgeByIndex(s), u = l0(o.getShallow("symbol", true)), c = l0(o.getShallow("symbolSize", true)), h = o.getModel("lineStyle").getLineStyle(), f = r.ensureUniqueItemVisual(s, "style");
        switch (rt(f, h), f.stroke) {
          case "source": {
            var d = l.node1.getVisual("style");
            f.stroke = d && d.fill;
            break;
          }
          case "target": {
            var d = l.node2.getVisual("style");
            f.stroke = d && d.fill;
            break;
          }
        }
        u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
      });
    });
  }
  var NA = "-->", Z1 = function(n) {
    return n.get("autoCurveness") || null;
  }, p8 = function(n, t) {
    var e = Z1(n), r = 20, i = [];
    if (_e(e)) r = e;
    else if (ct(e)) {
      n.__curvenessList = e;
      return;
    }
    t > r && (r = t);
    var a = r % 2 ? r + 2 : r + 3;
    i = [];
    for (var s = 0; s < a; s++) i.push((s % 2 ? s + 1 : s) / 10 * (s % 2 ? -1 : 1));
    n.__curvenessList = i;
  }, tv = function(n, t, e) {
    var r = [
      n.id,
      n.dataIndex
    ].join("."), i = [
      t.id,
      t.dataIndex
    ].join(".");
    return [
      e.uid,
      r,
      i
    ].join(NA);
  }, g8 = function(n) {
    var t = n.split(NA);
    return [
      t[0],
      t[2],
      t[1]
    ].join(NA);
  }, Ldt = function(n, t) {
    var e = tv(n.node1, n.node2, t);
    return t.__edgeMap[e];
  }, Pdt = function(n, t) {
    var e = LA(tv(n.node1, n.node2, t), t), r = LA(tv(n.node2, n.node1, t), t);
    return e + r;
  }, LA = function(n, t) {
    var e = t.__edgeMap;
    return e[n] ? e[n].length : 0;
  };
  function $dt(n) {
    Z1(n) && (n.__curvenessList = [], n.__edgeMap = {}, p8(n));
  }
  function Odt(n, t, e, r) {
    if (Z1(e)) {
      var i = tv(n, t, e), a = e.__edgeMap, s = a[g8(i)];
      a[i] && !s ? a[i].isForward = true : s && a[i] && (s.isForward = true, a[i].isForward = false), a[i] = a[i] || [], a[i].push(r);
    }
  }
  function KD(n, t, e, r) {
    var i = Z1(t), a = ct(i);
    if (!i) return null;
    var s = Ldt(n, t);
    if (!s) return null;
    for (var o = -1, l = 0; l < s.length; l++) if (s[l] === e) {
      o = l;
      break;
    }
    var u = Pdt(n, t);
    p8(t, u), n.lineStyle = n.lineStyle || {};
    var c = tv(n.node1, n.node2, t), h = t.__curvenessList, f = a || u % 2 ? 0 : 1;
    if (s.isForward) return h[f + o];
    var d = g8(c), p = LA(d, t), g = h[o + p + f];
    return r ? a ? i && i[0] === 0 ? (p + f) % 2 ? g : -g : ((p % 2 ? 0 : 1) + f) % 2 ? g : -g : (p + f) % 2 ? g : -g : h[o + p + f];
  }
  function v8(n) {
    var t = n.coordinateSystem;
    if (!(t && t.type !== "view")) {
      var e = n.getGraph();
      e.eachNode(function(r) {
        var i = r.getModel();
        r.setLayout([
          +i.get("x"),
          +i.get("y")
        ]);
      }), ZD(e, n);
    }
  }
  function ZD(n, t) {
    n.eachEdge(function(e, r) {
      var i = Ws(e.getModel().get([
        "lineStyle",
        "curveness"
      ]), -KD(e, t, r, true), 0), a = Mo(e.node1.getLayout()), s = Mo(e.node2.getLayout()), o = [
        a,
        s
      ];
      +i && o.push([
        (a[0] + s[0]) / 2 - (a[1] - s[1]) * i,
        (a[1] + s[1]) / 2 - (s[0] - a[0]) * i
      ]), e.setLayout(o);
    });
  }
  function Fdt(n, t) {
    n.eachSeriesByType("graph", function(e) {
      var r = e.get("layout"), i = e.coordinateSystem;
      if (i && i.type !== "view") {
        var a = e.getData(), s = [];
        P(i.dimensions, function(f) {
          s = s.concat(a.mapDimensionsAll(f));
        });
        for (var o = 0; o < a.count(); o++) {
          for (var l = [], u = false, c = 0; c < s.length; c++) {
            var h = a.get(s[c], o);
            isNaN(h) || (u = true), l.push(h);
          }
          u ? a.setItemLayout(o, i.dataToPoint(l)) : a.setItemLayout(o, [
            NaN,
            NaN
          ]);
        }
        ZD(a.graph, e);
      } else (!r || r === "none") && v8(e);
    });
  }
  function Yp(n) {
    var t = n.coordinateSystem;
    if (t.type !== "view") return 1;
    var e = n.option.nodeScaleRatio, r = t.scaleX, i = t.getZoom(), a = (i - 1) * e + 1;
    return a / r;
  }
  function qp(n) {
    var t = n.getVisual("symbolSize");
    return t instanceof Array && (t = (t[0] + t[1]) / 2), +t;
  }
  var kF = Math.PI, yC = [];
  function JD(n, t, e, r) {
    var i = n.coordinateSystem;
    if (!(i && i.type !== "view")) {
      var a = i.getBoundingRect(), s = n.getData(), o = s.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, c = Math.min(a.width, a.height) / 2, h = s.count();
      if (s.setLayout({
        cx: l,
        cy: u
      }), !!h) {
        if (e) {
          var f = i.pointToData(r), d = f[0], p = f[1], g = [
            d - l,
            p - u
          ];
          md(g, g), ex(g, g, c), e.setLayout([
            l + g[0],
            u + g[1]
          ], true);
          var v = n.get([
            "circular",
            "rotateLabel"
          ]);
          m8(e, v, l, u);
        }
        Bdt[t](n, o, s, c, l, u, h), o.eachEdge(function(m, y) {
          var x = Ws(m.getModel().get([
            "lineStyle",
            "curveness"
          ]), KD(m, n, y), 0), b = Mo(m.node1.getLayout()), _ = Mo(m.node2.getLayout()), w, S = (b[0] + _[0]) / 2, I = (b[1] + _[1]) / 2;
          +x && (x *= 3, w = [
            l * x + S * (1 - x),
            u * x + I * (1 - x)
          ]), m.setLayout([
            b,
            _,
            w
          ]);
        });
      }
    }
  }
  var Bdt = {
    value: function(n, t, e, r, i, a, s) {
      var o = 0, l = e.getSum("value"), u = Math.PI * 2 / (l || s);
      t.eachNode(function(c) {
        var h = c.getValue("value"), f = u * (l ? h : 1) / 2;
        o += f, c.setLayout([
          r * Math.cos(o) + i,
          r * Math.sin(o) + a
        ]), o += f;
      });
    },
    symbolSize: function(n, t, e, r, i, a, s) {
      var o = 0;
      yC.length = s;
      var l = Yp(n);
      t.eachNode(function(h) {
        var f = qp(h);
        isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
        var d = Math.asin(f / 2 / r);
        isNaN(d) && (d = kF / 2), yC[h.dataIndex] = d, o += d * 2;
      });
      var u = (2 * kF - o) / s / 2, c = 0;
      t.eachNode(function(h) {
        var f = u + yC[h.dataIndex];
        c += f, (!h.getLayout() || !h.getLayout().fixed) && h.setLayout([
          r * Math.cos(c) + i,
          r * Math.sin(c) + a
        ]), c += f;
      });
    }
  };
  function m8(n, t, e, r) {
    var i = n.getGraphicEl();
    if (i) {
      var a = n.getModel(), s = a.get([
        "label",
        "rotate"
      ]) || 0, o = i.getSymbolPath();
      if (t) {
        var l = n.getLayout(), u = Math.atan2(l[1] - r, l[0] - e);
        u < 0 && (u = Math.PI * 2 + u);
        var c = l[0] < e;
        c && (u = u - Math.PI);
        var h = c ? "left" : "right";
        o.setTextConfig({
          rotation: -u,
          position: h,
          origin: "center"
        });
        var f = o.ensureState("emphasis");
        rt(f.textConfig || (f.textConfig = {}), {
          position: h
        });
      } else o.setTextConfig({
        rotation: s *= Math.PI / 180
      });
    }
  }
  function zdt(n) {
    n.eachSeriesByType("graph", function(t) {
      t.get("layout") === "circular" && JD(t, "symbolSize");
    });
  }
  var Xh = bI;
  function Vdt(n, t, e) {
    for (var r = n, i = t, a = e.rect, s = a.width, o = a.height, l = [
      a.x + s / 2,
      a.y + o / 2
    ], u = e.gravity == null ? 0.1 : e.gravity, c = 0; c < r.length; c++) {
      var h = r[c];
      h.p || (h.p = hh(s * (Math.random() - 0.5) + l[0], o * (Math.random() - 0.5) + l[1])), h.pp = Mo(h.p), h.edges = null;
    }
    var f = e.friction == null ? 0.6 : e.friction, d = f, p, g;
    return {
      warmUp: function() {
        d = f * 0.8;
      },
      setFixed: function(v) {
        r[v].fixed = true;
      },
      setUnfixed: function(v) {
        r[v].fixed = false;
      },
      beforeStep: function(v) {
        p = v;
      },
      afterStep: function(v) {
        g = v;
      },
      step: function(v) {
        p && p(r, i);
        for (var m = [], y = r.length, x = 0; x < i.length; x++) {
          var b = i[x];
          if (!b.ignoreForceLayout) {
            var _ = b.n1, w = b.n2;
            vc(m, w.p, _.p);
            var S = _I(m) - b.d, I = w.w / (_.w + w.w);
            isNaN(I) && (I = 0), md(m, m), !_.fixed && Xh(_.p, _.p, m, I * S * d), !w.fixed && Xh(w.p, w.p, m, -(1 - I) * S * d);
          }
        }
        for (var x = 0; x < y; x++) {
          var T = r[x];
          T.fixed || (vc(m, l, T.p), Xh(T.p, T.p, m, u * d));
        }
        for (var x = 0; x < y; x++) for (var _ = r[x], A = x + 1; A < y; A++) {
          var w = r[A];
          vc(m, w.p, _.p);
          var S = _I(m);
          S === 0 && (het(m, Math.random() - 0.5, Math.random() - 0.5), S = 1);
          var C = (_.rep + w.rep) / S / S;
          !_.fixed && Xh(_.pp, _.pp, m, C), !w.fixed && Xh(w.pp, w.pp, m, -C);
        }
        for (var D = [], x = 0; x < y; x++) {
          var T = r[x];
          T.fixed || (vc(D, T.p, T.pp), Xh(T.p, T.p, D, d), ri(T.pp, T.p));
        }
        d = d * 0.992;
        var E = d < 0.01;
        g && g(r, i, E), v && v(E);
      }
    };
  }
  function Gdt(n) {
    n.eachSeriesByType("graph", function(t) {
      var e = t.coordinateSystem;
      if (!(e && e.type !== "view")) if (t.get("layout") === "force") {
        var r = t.preservedPoints || {}, i = t.getGraph(), a = i.data, s = i.edgeData, o = t.getModel("force"), l = o.get("initLayout");
        t.preservedPoints ? a.each(function(x) {
          var b = a.getId(x);
          a.setItemLayout(x, r[b] || [
            NaN,
            NaN
          ]);
        }) : !l || l === "none" ? v8(t) : l === "circular" && JD(t, "value");
        var u = a.getDataExtent("value"), c = s.getDataExtent("value"), h = o.get("repulsion"), f = o.get("edgeLength"), d = ct(h) ? h : [
          h,
          h
        ], p = ct(f) ? f : [
          f,
          f
        ];
        p = [
          p[1],
          p[0]
        ];
        var g = a.mapArray("value", function(x, b) {
          var _ = a.getItemLayout(b), w = Pe(x, u, d);
          return isNaN(w) && (w = (d[0] + d[1]) / 2), {
            w,
            rep: w,
            fixed: a.getItemModel(b).get("fixed"),
            p: !_ || isNaN(_[0]) || isNaN(_[1]) ? null : _
          };
        }), v = s.mapArray("value", function(x, b) {
          var _ = i.getEdgeByIndex(b), w = Pe(x, c, p);
          isNaN(w) && (w = (p[0] + p[1]) / 2);
          var S = _.getModel(), I = Ws(_.getModel().get([
            "lineStyle",
            "curveness"
          ]), -KD(_, t, b, true), 0);
          return {
            n1: g[_.node1.dataIndex],
            n2: g[_.node2.dataIndex],
            d: w,
            curveness: I,
            ignoreForceLayout: S.get("ignoreForceLayout")
          };
        }), m = e.getBoundingRect(), y = Vdt(g, v, {
          rect: m,
          gravity: o.get("gravity"),
          friction: o.get("friction")
        });
        y.beforeStep(function(x, b) {
          for (var _ = 0, w = x.length; _ < w; _++) x[_].fixed && ri(x[_].p, i.getNodeByIndex(_).getLayout());
        }), y.afterStep(function(x, b, _) {
          for (var w = 0, S = x.length; w < S; w++) x[w].fixed || i.getNodeByIndex(w).setLayout(x[w].p), r[a.getId(w)] = x[w].p;
          for (var w = 0, S = b.length; w < S; w++) {
            var I = b[w], T = i.getEdgeByIndex(w), A = I.n1.p, C = I.n2.p, D = T.getLayout();
            D = D ? D.slice() : [], D[0] = D[0] || [], D[1] = D[1] || [], ri(D[0], A), ri(D[1], C), +I.curveness && (D[2] = [
              (A[0] + C[0]) / 2 - (A[1] - C[1]) * I.curveness,
              (A[1] + C[1]) / 2 - (C[0] - A[0]) * I.curveness
            ]), T.setLayout(D);
          }
        }), t.forceLayout = y, t.preservedPoints = r, y.step();
      } else t.forceLayout = null;
    });
  }
  function Wdt(n, t, e) {
    var r = rt(n.getBoxLayoutParams(), {
      aspect: e
    });
    return Zn(r, {
      width: t.getWidth(),
      height: t.getHeight()
    });
  }
  function Udt(n, t) {
    var e = [];
    return n.eachSeriesByType("graph", function(r) {
      var i = r.get("coordinateSystem");
      if (!i || i === "view") {
        var a = r.getData(), s = a.mapArray(function(v) {
          var m = a.getItemModel(v);
          return [
            +m.get("x"),
            +m.get("y")
          ];
        }), o = [], l = [];
        C1(s, o, l), l[0] - o[0] === 0 && (l[0] += 1, o[0] -= 1), l[1] - o[1] === 0 && (l[1] += 1, o[1] -= 1);
        var u = (l[0] - o[0]) / (l[1] - o[1]), c = Wdt(r, t, u);
        isNaN(u) && (o = [
          c.x,
          c.y
        ], l = [
          c.x + c.width,
          c.y + c.height
        ]);
        var h = l[0] - o[0], f = l[1] - o[1], d = c.width, p = c.height, g = r.coordinateSystem = new Kv();
        g.zoomLimit = r.get("scaleLimit"), g.setBoundingRect(o[0], o[1], h, f), g.setViewRect(c.x, c.y, d, p), g.setCenter(r.get("center"), t), g.setZoom(r.get("zoom")), e.push(g);
      }
    }), e;
  }
  var DF = ir.prototype, xC = Pv.prototype, y8 = /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return n;
  }();
  (function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t;
  })(y8);
  function bC(n) {
    return isNaN(+n.cpx1) || isNaN(+n.cpy1);
  }
  var Hdt = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "ec-line", r;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new y8();
    }, t.prototype.buildPath = function(e, r) {
      bC(r) ? DF.buildPath.call(this, e, r) : xC.buildPath.call(this, e, r);
    }, t.prototype.pointAt = function(e) {
      return bC(this.shape) ? DF.pointAt.call(this, e) : xC.pointAt.call(this, e);
    }, t.prototype.tangentAt = function(e) {
      var r = this.shape, i = bC(r) ? [
        r.x2 - r.x1,
        r.y2 - r.y1
      ] : xC.tangentAt.call(this, e);
      return md(i, i);
    }, t;
  }(le), _C = [
    "fromSymbol",
    "toSymbol"
  ];
  function EF(n) {
    return "_" + n + "Type";
  }
  function MF(n, t, e) {
    var r = t.getItemVisual(e, n);
    if (!r || r === "none") return r;
    var i = t.getItemVisual(e, n + "Size"), a = t.getItemVisual(e, n + "Rotate"), s = t.getItemVisual(e, n + "Offset"), o = t.getItemVisual(e, n + "KeepAspect"), l = Dd(i), u = gh(s || 0, l);
    return r + l + u + (a || "") + (o || "");
  }
  function RF(n, t, e) {
    var r = t.getItemVisual(e, n);
    if (!(!r || r === "none")) {
      var i = t.getItemVisual(e, n + "Size"), a = t.getItemVisual(e, n + "Rotate"), s = t.getItemVisual(e, n + "Offset"), o = t.getItemVisual(e, n + "KeepAspect"), l = Dd(i), u = gh(s || 0, l), c = Fn(r, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, o);
      return c.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, c.name = n, c;
    }
  }
  function Xdt(n) {
    var t = new Hdt({
      name: "line",
      subPixelOptimize: true
    });
    return PA(t.shape, n), t;
  }
  function PA(n, t) {
    n.x1 = t[0][0], n.y1 = t[0][1], n.x2 = t[1][0], n.y2 = t[1][1], n.percent = 1;
    var e = t[2];
    e ? (n.cpx1 = e[0], n.cpy1 = e[1]) : (n.cpx1 = NaN, n.cpy1 = NaN);
  }
  var QD = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this) || this;
      return a._createLine(e, r, i), a;
    }
    return t.prototype._createLine = function(e, r, i) {
      var a = e.hostModel, s = e.getItemLayout(r), o = Xdt(s);
      o.shape.percent = 0, dn(o, {
        shape: {
          percent: 1
        }
      }, a, r), this.add(o), P(_C, function(l) {
        var u = RF(l, e, r);
        this.add(u), this[EF(l)] = MF(l, e, r);
      }, this), this._updateCommonStl(e, r, i);
    }, t.prototype.updateData = function(e, r, i) {
      var a = e.hostModel, s = this.childOfName("line"), o = e.getItemLayout(r), l = {
        shape: {}
      };
      PA(l.shape, o), Ie(s, l, a, r), P(_C, function(u) {
        var c = MF(u, e, r), h = EF(u);
        if (this[h] !== c) {
          this.remove(this.childOfName(u));
          var f = RF(u, e, r);
          this.add(f);
        }
        this[h] = c;
      }, this), this._updateCommonStl(e, r, i);
    }, t.prototype.getLinePath = function() {
      return this.childAt(0);
    }, t.prototype._updateCommonStl = function(e, r, i) {
      var a = e.hostModel, s = this.childOfName("line"), o = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, h = i && i.emphasisDisabled, f = i && i.focus, d = i && i.blurScope;
      if (!i || e.hasItemOption) {
        var p = e.getItemModel(r), g = p.getModel("emphasis");
        o = g.getModel("lineStyle").getLineStyle(), l = p.getModel([
          "blur",
          "lineStyle"
        ]).getLineStyle(), u = p.getModel([
          "select",
          "lineStyle"
        ]).getLineStyle(), h = g.get("disabled"), f = g.get("focus"), d = g.get("blurScope"), c = ur(p);
      }
      var v = e.getItemVisual(r, "style"), m = v.stroke;
      s.useStyle(v), s.style.fill = null, s.style.strokeNoScale = true, s.ensureState("emphasis").style = o, s.ensureState("blur").style = l, s.ensureState("select").style = u, P(_C, function(w) {
        var S = this.childOfName(w);
        if (S) {
          S.setColor(m), S.style.opacity = v.opacity;
          for (var I = 0; I < vi.length; I++) {
            var T = vi[I], A = s.getState(T);
            if (A) {
              var C = A.style || {}, D = S.ensureState(T), E = D.style || (D.style = {});
              C.stroke != null && (E[S.__isEmptyBrush ? "stroke" : "fill"] = C.stroke), C.opacity != null && (E.opacity = C.opacity);
            }
          }
          S.markRedraw();
        }
      }, this);
      var y = a.getRawValue(r);
      kr(this, c, {
        labelDataIndex: r,
        labelFetcher: {
          getFormattedLabel: function(w, S) {
            return a.getFormattedLabel(w, S, e.dataType);
          }
        },
        inheritColor: m || "#000",
        defaultOpacity: v.opacity,
        defaultText: (y == null ? e.getName(r) : isFinite(y) ? Cn(y) : y) + ""
      });
      var x = this.getTextContent();
      if (x) {
        var b = c.normal;
        x.__align = x.style.align, x.__verticalAlign = x.style.verticalAlign, x.__position = b.get("position") || "middle";
        var _ = b.get("distance");
        ct(_) || (_ = [
          _,
          _
        ]), x.__labelDistance = _;
      }
      this.setTextConfig({
        position: null,
        local: true,
        inside: false
      }), bn(this, f, d, h);
    }, t.prototype.highlight = function() {
      Vo(this);
    }, t.prototype.downplay = function() {
      Go(this);
    }, t.prototype.updateLayout = function(e, r) {
      this.setLinePoints(e.getItemLayout(r));
    }, t.prototype.setLinePoints = function(e) {
      var r = this.childOfName("line");
      PA(r.shape, e), r.dirty();
    }, t.prototype.beforeUpdate = function() {
      var e = this, r = e.childOfName("fromSymbol"), i = e.childOfName("toSymbol"), a = e.getTextContent();
      if (!r && !i && (!a || a.ignore)) return;
      for (var s = 1, o = this.parent; o; ) o.scaleX && (s /= o.scaleX), o = o.parent;
      var l = e.childOfName("line");
      if (!this.__dirty && !l.__dirty) return;
      var u = l.shape.percent, c = l.pointAt(0), h = l.pointAt(u), f = vc([], h, c);
      md(f, f);
      function d(A, C) {
        var D = A.__specifiedRotation;
        if (D == null) {
          var E = l.tangentAt(C);
          A.attr("rotation", (C === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(E[1], E[0]));
        } else A.attr("rotation", D);
      }
      if (r && (r.setPosition(c), d(r, 0), r.scaleX = r.scaleY = s * u, r.markRedraw()), i && (i.setPosition(h), d(i, 1), i.scaleX = i.scaleY = s * u, i.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var p = void 0, g = void 0, v = a.__labelDistance, m = v[0] * s, y = v[1] * s, x = u / 2, b = l.tangentAt(x), _ = [
          b[1],
          -b[0]
        ], w = l.pointAt(x);
        _[1] > 0 && (_[0] = -_[0], _[1] = -_[1]);
        var S = b[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var I = -Math.atan2(b[1], b[0]);
          h[0] < c[0] && (I = Math.PI + I), a.rotation = I;
        }
        var T = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            T = -y, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            T = y, g = "top";
            break;
          default:
            T = 0, g = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = f[0] * m + h[0], a.y = f[1] * y + h[1], p = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", g = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -f[0] * m + c[0], a.y = -f[1] * y + c[1], p = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", g = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = m * S + c[0], a.y = c[1] + T, p = b[0] < 0 ? "right" : "left", a.originX = -m * S, a.originY = -T;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = w[0], a.y = w[1] + T, p = "center", a.originY = -T;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -m * S + h[0], a.y = h[1] + T, p = b[0] >= 0 ? "right" : "left", a.originX = m * S, a.originY = -T;
            break;
        }
        a.scaleX = a.scaleY = s, a.setStyle({
          verticalAlign: a.__verticalAlign || g,
          align: a.__align || p
        });
      }
    }, t;
  }(Vt), tE = function() {
    function n(t) {
      this.group = new Vt(), this._LineCtor = t || QD;
    }
    return n.prototype.updateData = function(t) {
      var e = this;
      this._progressiveEls = null;
      var r = this, i = r.group, a = r._lineData;
      r._lineData = t, a || i.removeAll();
      var s = NF(t);
      t.diff(a).add(function(o) {
        e._doAdd(t, o, s);
      }).update(function(o, l) {
        e._doUpdate(a, t, l, o, s);
      }).remove(function(o) {
        i.remove(a.getItemGraphicEl(o));
      }).execute();
    }, n.prototype.updateLayout = function() {
      var t = this._lineData;
      t && t.eachItemGraphicEl(function(e, r) {
        e.updateLayout(t, r);
      }, this);
    }, n.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = NF(t), this._lineData = null, this.group.removeAll();
    }, n.prototype.incrementalUpdate = function(t, e) {
      this._progressiveEls = [];
      function r(o) {
        !o.isGroup && !Ydt(o) && (o.incremental = true, o.ensureState("emphasis").hoverLayer = true);
      }
      for (var i = t.start; i < t.end; i++) {
        var a = e.getItemLayout(i);
        if (wC(a)) {
          var s = new this._LineCtor(e, i, this._seriesScope);
          s.traverse(r), this.group.add(s), e.setItemGraphicEl(i, s), this._progressiveEls.push(s);
        }
      }
    }, n.prototype.remove = function() {
      this.group.removeAll();
    }, n.prototype.eachRendered = function(t) {
      su(this._progressiveEls || this.group, t);
    }, n.prototype._doAdd = function(t, e, r) {
      var i = t.getItemLayout(e);
      if (wC(i)) {
        var a = new this._LineCtor(t, e, r);
        t.setItemGraphicEl(e, a), this.group.add(a);
      }
    }, n.prototype._doUpdate = function(t, e, r, i, a) {
      var s = t.getItemGraphicEl(r);
      if (!wC(e.getItemLayout(i))) {
        this.group.remove(s);
        return;
      }
      s ? s.updateData(e, i, a) : s = new this._LineCtor(e, i, a), e.setItemGraphicEl(i, s), this.group.add(s);
    }, n;
  }();
  function Ydt(n) {
    return n.animators && n.animators.length > 0;
  }
  function NF(n) {
    var t = n.hostModel, e = t.getModel("emphasis");
    return {
      lineStyle: t.getModel("lineStyle").getLineStyle(),
      emphasisLineStyle: e.getModel([
        "lineStyle"
      ]).getLineStyle(),
      blurLineStyle: t.getModel([
        "blur",
        "lineStyle"
      ]).getLineStyle(),
      selectLineStyle: t.getModel([
        "select",
        "lineStyle"
      ]).getLineStyle(),
      emphasisDisabled: e.get("disabled"),
      blurScope: e.get("blurScope"),
      focus: e.get("focus"),
      labelStatesModels: ur(t)
    };
  }
  function LF(n) {
    return isNaN(n[0]) || isNaN(n[1]);
  }
  function wC(n) {
    return n && !LF(n[0]) && !LF(n[1]);
  }
  var SC = [], CC = [], TC = [], Yh = pr, IC = Dc, PF = Math.abs;
  function $F(n, t, e) {
    for (var r = n[0], i = n[1], a = n[2], s = 1 / 0, o, l = e * e, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
      SC[0] = Yh(r[0], i[0], a[0], c), SC[1] = Yh(r[1], i[1], a[1], c);
      var h = PF(IC(SC, t) - l);
      h < s && (s = h, o = c);
    }
    for (var f = 0; f < 32; f++) {
      var d = o + u;
      CC[0] = Yh(r[0], i[0], a[0], o), CC[1] = Yh(r[1], i[1], a[1], o), TC[0] = Yh(r[0], i[0], a[0], d), TC[1] = Yh(r[1], i[1], a[1], d);
      var h = IC(CC, t) - l;
      if (PF(h) < 0.01) break;
      var p = IC(TC, t) - l;
      u /= 2, h < 0 ? p >= 0 ? o = o + u : o = o - u : p >= 0 ? o = o - u : o = o + u;
    }
    return o;
  }
  function AC(n, t) {
    var e = [], r = Rg, i = [
      [],
      [],
      []
    ], a = [
      [],
      []
    ], s = [];
    t /= 2, n.eachEdge(function(o, l) {
      var u = o.getLayout(), c = o.getVisual("fromSymbol"), h = o.getVisual("toSymbol");
      u.__original || (u.__original = [
        Mo(u[0]),
        Mo(u[1])
      ], u[2] && u.__original.push(Mo(u[2])));
      var f = u.__original;
      if (u[2] != null) {
        if (ri(i[0], f[0]), ri(i[1], f[2]), ri(i[2], f[1]), c && c !== "none") {
          var d = qp(o.node1), p = $F(i, f[0], d * t);
          r(i[0][0], i[1][0], i[2][0], p, e), i[0][0] = e[3], i[1][0] = e[4], r(i[0][1], i[1][1], i[2][1], p, e), i[0][1] = e[3], i[1][1] = e[4];
        }
        if (h && h !== "none") {
          var d = qp(o.node2), p = $F(i, f[1], d * t);
          r(i[0][0], i[1][0], i[2][0], p, e), i[1][0] = e[1], i[2][0] = e[2], r(i[0][1], i[1][1], i[2][1], p, e), i[1][1] = e[1], i[2][1] = e[2];
        }
        ri(u[0], i[0]), ri(u[1], i[2]), ri(u[2], i[1]);
      } else {
        if (ri(a[0], f[0]), ri(a[1], f[1]), vc(s, a[1], a[0]), md(s, s), c && c !== "none") {
          var d = qp(o.node1);
          bI(a[0], a[0], s, d * t);
        }
        if (h && h !== "none") {
          var d = qp(o.node2);
          bI(a[1], a[1], s, -d * t);
        }
        ri(u[0], a[0]), ri(u[1], a[1]);
      }
    });
  }
  function OF(n) {
    return n.type === "view";
  }
  var qdt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, r) {
      var i = new Uv(), a = new tE(), s = this.group;
      this._controller = new jv(r.getZr()), this._controllerHost = {
        target: s
      }, s.add(i.group), s.add(a.group), this._symbolDraw = i, this._lineDraw = a, this._firstRender = true;
    }, t.prototype.render = function(e, r, i) {
      var a = this, s = e.coordinateSystem;
      this._model = e;
      var o = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (OF(s)) {
        var c = {
          x: s.x,
          y: s.y,
          scaleX: s.scaleX,
          scaleY: s.scaleY
        };
        this._firstRender ? u.attr(c) : Ie(u, c, e);
      }
      AC(e.getGraph(), Yp(e));
      var h = e.getData();
      o.updateData(h);
      var f = e.getEdgeData();
      l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(e, r, i), clearTimeout(this._layoutTimeout);
      var d = e.forceLayout, p = e.get([
        "force",
        "layoutAnimation"
      ]);
      d && this._startForceLayoutIteration(d, p);
      var g = e.get("layout");
      h.graph.eachNode(function(x) {
        var b = x.dataIndex, _ = x.getGraphicEl(), w = x.getModel();
        if (_) {
          _.off("drag").off("dragend");
          var S = w.get("draggable");
          S && _.on("drag", function(T) {
            switch (g) {
              case "force":
                d.warmUp(), !a._layouting && a._startForceLayoutIteration(d, p), d.setFixed(b), h.setItemLayout(b, [
                  _.x,
                  _.y
                ]);
                break;
              case "circular":
                h.setItemLayout(b, [
                  _.x,
                  _.y
                ]), x.setLayout({
                  fixed: true
                }, true), JD(e, "symbolSize", x, [
                  T.offsetX,
                  T.offsetY
                ]), a.updateLayout(e);
                break;
              case "none":
              default:
                h.setItemLayout(b, [
                  _.x,
                  _.y
                ]), ZD(e.getGraph(), e), a.updateLayout(e);
                break;
            }
          }).on("dragend", function() {
            d && d.setUnfixed(b);
          }), _.setDraggable(S, !!w.get("cursor"));
          var I = w.get([
            "emphasis",
            "focus"
          ]);
          I === "adjacency" && (Ut(_).focus = x.getAdjacentDataIndices());
        }
      }), h.graph.eachEdge(function(x) {
        var b = x.getGraphicEl(), _ = x.getModel().get([
          "emphasis",
          "focus"
        ]);
        b && _ === "adjacency" && (Ut(b).focus = {
          edge: [
            x.dataIndex
          ],
          node: [
            x.node1.dataIndex,
            x.node2.dataIndex
          ]
        });
      });
      var v = e.get("layout") === "circular" && e.get([
        "circular",
        "rotateLabel"
      ]), m = h.getLayout("cx"), y = h.getLayout("cy");
      h.graph.eachNode(function(x) {
        m8(x, v, m, y);
      }), this._firstRender = false;
    }, t.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._startForceLayoutIteration = function(e, r) {
      var i = this;
      (function a() {
        e.step(function(s) {
          i.updateLayout(i._model), (i._layouting = !s) && (r ? i._layoutTimeout = setTimeout(a, 16) : a());
        });
      })();
    }, t.prototype._updateController = function(e, r, i) {
      var a = this, s = this._controller, o = this._controllerHost, l = this.group;
      if (s.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !q1(u, i, e);
      }), !OF(e.coordinateSystem)) {
        s.disable();
        return;
      }
      s.enable(e.get("roam")), o.zoomLimit = e.get("scaleLimit"), o.zoom = e.coordinateSystem.getZoom(), s.off("pan").off("zoom").on("pan", function(u) {
        GD(o, u.dx, u.dy), i.dispatchAction({
          seriesId: e.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        WD(o, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: e.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(), AC(e.getGraph(), Yp(e)), a._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, t.prototype._updateNodeAndLinkScale = function() {
      var e = this._model, r = e.getData(), i = Yp(e);
      r.eachItemGraphicEl(function(a, s) {
        a && a.setSymbolScale(i);
      });
    }, t.prototype.updateLayout = function(e) {
      AC(e.getGraph(), Yp(e)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, t.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = false, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, t.type = "graph", t;
  }(qe);
  function qh(n) {
    return "_EC_" + n;
  }
  var jdt = function() {
    function n(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || false;
    }
    return n.prototype.isDirected = function() {
      return this._directed;
    }, n.prototype.addNode = function(t, e) {
      t = t == null ? "" + e : "" + t;
      var r = this._nodesMap;
      if (!r[qh(t)]) {
        var i = new nc(t, e);
        return i.hostGraph = this, this.nodes.push(i), r[qh(t)] = i, i;
      }
    }, n.prototype.getNodeByIndex = function(t) {
      var e = this.data.getRawIndex(t);
      return this.nodes[e];
    }, n.prototype.getNodeById = function(t) {
      return this._nodesMap[qh(t)];
    }, n.prototype.addEdge = function(t, e, r) {
      var i = this._nodesMap, a = this._edgesMap;
      if (_e(t) && (t = this.nodes[t]), _e(e) && (e = this.nodes[e]), t instanceof nc || (t = i[qh(t)]), e instanceof nc || (e = i[qh(e)]), !(!t || !e)) {
        var s = t.id + "-" + e.id, o = new x8(t, e, r);
        return o.hostGraph = this, this._directed && (t.outEdges.push(o), e.inEdges.push(o)), t.edges.push(o), t !== e && e.edges.push(o), this.edges.push(o), a[s] = o, o;
      }
    }, n.prototype.getEdgeByIndex = function(t) {
      var e = this.edgeData.getRawIndex(t);
      return this.edges[e];
    }, n.prototype.getEdge = function(t, e) {
      t instanceof nc && (t = t.id), e instanceof nc && (e = e.id);
      var r = this._edgesMap;
      return this._directed ? r[t + "-" + e] : r[t + "-" + e] || r[e + "-" + t];
    }, n.prototype.eachNode = function(t, e) {
      for (var r = this.nodes, i = r.length, a = 0; a < i; a++) r[a].dataIndex >= 0 && t.call(e, r[a], a);
    }, n.prototype.eachEdge = function(t, e) {
      for (var r = this.edges, i = r.length, a = 0; a < i; a++) r[a].dataIndex >= 0 && r[a].node1.dataIndex >= 0 && r[a].node2.dataIndex >= 0 && t.call(e, r[a], a);
    }, n.prototype.breadthFirstTraverse = function(t, e, r, i) {
      if (e instanceof nc || (e = this._nodesMap[qh(e)]), !!e) {
        for (var a = r === "out" ? "outEdges" : r === "in" ? "inEdges" : "edges", s = 0; s < this.nodes.length; s++) this.nodes[s].__visited = false;
        if (!t.call(i, e, null)) for (var o = [
          e
        ]; o.length; ) for (var l = o.shift(), u = l[a], s = 0; s < u.length; s++) {
          var c = u[s], h = c.node1 === l ? c.node2 : c.node1;
          if (!h.__visited) {
            if (t.call(i, h, l)) return;
            o.push(h), h.__visited = true;
          }
        }
      }
    }, n.prototype.update = function() {
      for (var t = this.data, e = this.edgeData, r = this.nodes, i = this.edges, a = 0, s = r.length; a < s; a++) r[a].dataIndex = -1;
      for (var a = 0, s = t.count(); a < s; a++) r[t.getRawIndex(a)].dataIndex = a;
      e.filterSelf(function(o) {
        var l = i[e.getRawIndex(o)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, s = i.length; a < s; a++) i[a].dataIndex = -1;
      for (var a = 0, s = e.count(); a < s; a++) i[e.getRawIndex(a)].dataIndex = a;
    }, n.prototype.clone = function() {
      for (var t = new n(this._directed), e = this.nodes, r = this.edges, i = 0; i < e.length; i++) t.addNode(e[i].id, e[i].dataIndex);
      for (var i = 0; i < r.length; i++) {
        var a = r[i];
        t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return t;
    }, n;
  }(), nc = function() {
    function n(t, e) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = e ?? -1;
    }
    return n.prototype.degree = function() {
      return this.edges.length;
    }, n.prototype.inDegree = function() {
      return this.inEdges.length;
    }, n.prototype.outDegree = function() {
      return this.outEdges.length;
    }, n.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostGraph, r = e.data.getItemModel(this.dataIndex);
        return r.getModel(t);
      }
    }, n.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, e = 0; e < this.edges.length; e++) {
        var r = this.edges[e];
        r.dataIndex < 0 || (t.edge.push(r.dataIndex), t.node.push(r.node1.dataIndex, r.node2.dataIndex));
      }
      return t;
    }, n.prototype.getTrajectoryDataIndices = function() {
      for (var t = It(), e = It(), r = 0; r < this.edges.length; r++) {
        var i = this.edges[r];
        if (!(i.dataIndex < 0)) {
          t.set(i.dataIndex, true);
          for (var a = [
            i.node1
          ], s = [
            i.node2
          ], o = 0; o < a.length; ) {
            var l = a[o];
            o++, e.set(l.dataIndex, true);
            for (var u = 0; u < l.inEdges.length; u++) t.set(l.inEdges[u].dataIndex, true), a.push(l.inEdges[u].node1);
          }
          for (o = 0; o < s.length; ) {
            var c = s[o];
            o++, e.set(c.dataIndex, true);
            for (var u = 0; u < c.outEdges.length; u++) t.set(c.outEdges[u].dataIndex, true), s.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: t.keys(),
        node: e.keys()
      };
    }, n;
  }(), x8 = function() {
    function n(t, e, r) {
      this.dataIndex = -1, this.node1 = t, this.node2 = e, this.dataIndex = r ?? -1;
    }
    return n.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostGraph, r = e.edgeData.getItemModel(this.dataIndex);
        return r.getModel(t);
      }
    }, n.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [
          this.dataIndex
        ],
        node: [
          this.node1.dataIndex,
          this.node2.dataIndex
        ]
      };
    }, n.prototype.getTrajectoryDataIndices = function() {
      var t = It(), e = It();
      t.set(this.dataIndex, true);
      for (var r = [
        this.node1
      ], i = [
        this.node2
      ], a = 0; a < r.length; ) {
        var s = r[a];
        a++, e.set(s.dataIndex, true);
        for (var o = 0; o < s.inEdges.length; o++) t.set(s.inEdges[o].dataIndex, true), r.push(s.inEdges[o].node1);
      }
      for (a = 0; a < i.length; ) {
        var l = i[a];
        a++, e.set(l.dataIndex, true);
        for (var o = 0; o < l.outEdges.length; o++) t.set(l.outEdges[o].dataIndex, true), i.push(l.outEdges[o].node2);
      }
      return {
        edge: t.keys(),
        node: e.keys()
      };
    }, n;
  }();
  function b8(n, t) {
    return {
      getValue: function(e) {
        var r = this[n][t];
        return r.getStore().get(r.getDimensionIndex(e || "value"), this.dataIndex);
      },
      setVisual: function(e, r) {
        this.dataIndex >= 0 && this[n][t].setItemVisual(this.dataIndex, e, r);
      },
      getVisual: function(e) {
        return this[n][t].getItemVisual(this.dataIndex, e);
      },
      setLayout: function(e, r) {
        this.dataIndex >= 0 && this[n][t].setItemLayout(this.dataIndex, e, r);
      },
      getLayout: function() {
        return this[n][t].getItemLayout(this.dataIndex);
      },
      getGraphicEl: function() {
        return this[n][t].getItemGraphicEl(this.dataIndex);
      },
      getRawIndex: function() {
        return this[n][t].getRawIndex(this.dataIndex);
      }
    };
  }
  zn(nc, b8("hostGraph", "data"));
  zn(x8, b8("hostGraph", "edgeData"));
  function _8(n, t, e, r, i) {
    for (var a = new jdt(r), s = 0; s < n.length; s++) a.addNode(mr(n[s].id, n[s].name, s), s);
    for (var o = [], l = [], u = 0, s = 0; s < t.length; s++) {
      var c = t[s], h = c.source, f = c.target;
      a.addEdge(h, f, u) && (l.push(c), o.push(mr(Un(c.id, null), h + " > " + f)), u++);
    }
    var d = e.get("coordinateSystem"), p;
    if (d === "cartesian2d" || d === "polar") p = el(n, e);
    else {
      var g = Bv.get(d), v = g ? g.dimensions || [] : [];
      ne(v, "value") < 0 && v.concat([
        "value"
      ]);
      var m = Vv(n, {
        coordDimensions: v,
        encodeDefine: e.getEncode()
      }).dimensions;
      p = new fi(m, e), p.initData(n);
    }
    var y = new fi([
      "value"
    ], e);
    return y.initData(l, o), i && i(p, y), n8({
      mainData: p,
      struct: a,
      structAttr: "graph",
      datas: {
        node: p,
        edge: y
      },
      datasAttr: {
        node: "data",
        edge: "edgeData"
      }
    }), a.update(), a;
  }
  var Kdt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = true, e;
    }
    return t.prototype.init = function(e) {
      n.prototype.init.apply(this, arguments);
      var r = this;
      function i() {
        return r._categoriesData;
      }
      this.legendVisualProvider = new qv(i, i), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
    }, t.prototype.mergeOption = function(e) {
      n.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
    }, t.prototype.mergeDefaultAndTheme = function(e) {
      n.prototype.mergeDefaultAndTheme.apply(this, arguments), Wc(e, "edgeLabel", [
        "show"
      ]);
    }, t.prototype.getInitialData = function(e, r) {
      var i = e.edges || e.links || [], a = e.data || e.nodes || [], s = this;
      if (a && i) {
        $dt(this);
        var o = _8(a, i, this, true, l);
        return P(o.edges, function(u) {
          Odt(u.node1, u.node2, this, u.dataIndex);
        }, this), o.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var g = s._categoriesModels, v = p.getShallow("category"), m = g[v];
          return m && (m.parentModel = p.parentModel, p.parentModel = m), p;
        });
        var h = $e.prototype.getModel;
        function f(p, g) {
          var v = h.call(this, p, g);
          return v.resolveParentPath = d, v;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = d, p.getModel = f, p;
        });
        function d(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, t.prototype.formatTooltip = function(e, r, i) {
      if (i === "edge") {
        var a = this.getData(), s = this.getDataParams(e, i), o = a.graph.getEdgeByIndex(e), l = a.getName(o.node1.dataIndex), u = a.getName(o.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), cr("nameValue", {
          name: c.join(" > "),
          value: s.value,
          noValue: s.value == null
        });
      }
      var h = H5({
        series: this,
        dataIndex: e,
        multipleSeries: r
      });
      return h;
    }, t.prototype._updateCategoriesData = function() {
      var e = ht(this.option.categories || [], function(i) {
        return i.value != null ? i : rt({
          value: 0
        }, i);
      }), r = new fi([
        "value"
      ], this);
      r.initData(e), this._categoriesData = r, this._categoriesModels = r.mapArray(function(i) {
        return r.getItemModel(i);
      });
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.isAnimationEnabled = function() {
      return n.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get([
        "force",
        "layoutAnimation"
      ]));
    }, t.type = "series.graph", t.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], t.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      legendHoverLink: true,
      layout: null,
      circular: {
        rotateLabel: false
      },
      force: {
        initLayout: null,
        repulsion: [
          0,
          50
        ],
        gravity: 0.1,
        friction: 0.6,
        edgeLength: 30,
        layoutAnimation: true
      },
      left: "center",
      top: "center",
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: [
        "none",
        "none"
      ],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: false,
      roam: false,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: {
        show: false,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: true,
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(an), Zdt = {
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  };
  function Jdt(n) {
    n.registerChartView(qdt), n.registerSeriesModel(Kdt), n.registerProcessor(Mdt), n.registerVisual(Rdt), n.registerVisual(Ndt), n.registerLayout(Fdt), n.registerLayout(n.PRIORITY.VISUAL.POST_CHART_LAYOUT, zdt), n.registerLayout(Gdt), n.registerCoordinateSystem("graphView", {
      dimensions: Kv.dimensions,
      create: Udt
    }), n.registerAction({
      type: "focusNodeAdjacency",
      event: "focusNodeAdjacency",
      update: "series:focusNodeAdjacency"
    }, Dn), n.registerAction({
      type: "unfocusNodeAdjacency",
      event: "unfocusNodeAdjacency",
      update: "series:unfocusNodeAdjacency"
    }, Dn), n.registerAction(Zdt, function(t, e, r) {
      e.eachComponent({
        mainType: "series",
        query: t
      }, function(i) {
        var a = i.coordinateSystem, s = HD(a, t, void 0, r);
        i.setCenter && i.setCenter(s.center), i.setZoom && i.setZoom(s.zoom);
      });
    });
  }
  var Qdt = /* @__PURE__ */ function() {
    function n() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return n;
  }(), tpt = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "pointer", r;
    }
    return t.prototype.getDefaultShape = function() {
      return new Qdt();
    }, t.prototype.buildPath = function(e, r) {
      var i = Math.cos, a = Math.sin, s = r.r, o = r.width, l = r.angle, u = r.x - i(l) * o * (o >= s / 3 ? 1 : 2), c = r.y - a(l) * o * (o >= s / 3 ? 1 : 2);
      l = r.angle - Math.PI / 2, e.moveTo(u, c), e.lineTo(r.x + i(l) * o, r.y + a(l) * o), e.lineTo(r.x + i(r.angle) * s, r.y + a(r.angle) * s), e.lineTo(r.x - i(l) * o, r.y - a(l) * o), e.lineTo(u, c);
    }, t;
  }(le);
  function ept(n, t) {
    var e = n.get("center"), r = t.getWidth(), i = t.getHeight(), a = Math.min(r, i), s = yt(e[0], t.getWidth()), o = yt(e[1], t.getHeight()), l = yt(n.get("radius"), a / 2);
    return {
      cx: s,
      cy: o,
      r: l
    };
  }
  function u0(n, t) {
    var e = n == null ? "" : n + "";
    return t && (wt(t) ? e = t.replace("{value}", e) : Nt(t) && (e = t(n))), e;
  }
  var npt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      this.group.removeAll();
      var a = e.get([
        "axisLine",
        "lineStyle",
        "color"
      ]), s = ept(e, i);
      this._renderMain(e, r, i, a, s), this._data = e.getData();
    }, t.prototype.dispose = function() {
    }, t.prototype._renderMain = function(e, r, i, a, s) {
      var o = this.group, l = e.get("clockwise"), u = -e.get("startAngle") / 180 * Math.PI, c = -e.get("endAngle") / 180 * Math.PI, h = e.getModel("axisLine"), f = h.get("roundCap"), d = f ? cb : mi, p = h.get("show"), g = h.getModel("lineStyle"), v = g.get("width"), m = [
        u,
        c
      ];
      Yk(m, !l), u = m[0], c = m[1];
      for (var y = c - u, x = u, b = [], _ = 0; p && _ < a.length; _++) {
        var w = Math.min(Math.max(a[_][0], 0), 1);
        c = u + y * w;
        var S = new d({
          shape: {
            startAngle: x,
            endAngle: c,
            cx: s.cx,
            cy: s.cy,
            clockwise: l,
            r0: s.r - v,
            r: s.r
          },
          silent: true
        });
        S.setStyle({
          fill: a[_][1]
        }), S.setStyle(g.getLineStyle([
          "color",
          "width"
        ])), b.push(S), x = c;
      }
      b.reverse(), P(b, function(T) {
        return o.add(T);
      });
      var I = function(T) {
        if (T <= 0) return a[0][1];
        var A;
        for (A = 0; A < a.length; A++) if (a[A][0] >= T && (A === 0 ? 0 : a[A - 1][0]) < T) return a[A][1];
        return a[A - 1][1];
      };
      this._renderTicks(e, r, i, I, s, u, c, l, v), this._renderTitleAndDetail(e, r, i, I, s), this._renderAnchor(e, s), this._renderPointer(e, r, i, I, s, u, c, l, v);
    }, t.prototype._renderTicks = function(e, r, i, a, s, o, l, u, c) {
      for (var h = this.group, f = s.cx, d = s.cy, p = s.r, g = +e.get("min"), v = +e.get("max"), m = e.getModel("splitLine"), y = e.getModel("axisTick"), x = e.getModel("axisLabel"), b = e.get("splitNumber"), _ = y.get("splitNumber"), w = yt(m.get("length"), p), S = yt(y.get("length"), p), I = o, T = (l - o) / b, A = T / _, C = m.getModel("lineStyle").getLineStyle(), D = y.getModel("lineStyle").getLineStyle(), E = m.get("distance"), M, L, k = 0; k <= b; k++) {
        if (M = Math.cos(I), L = Math.sin(I), m.get("show")) {
          var N = E ? E + c : c, R = new ir({
            shape: {
              x1: M * (p - N) + f,
              y1: L * (p - N) + d,
              x2: M * (p - w - N) + f,
              y2: L * (p - w - N) + d
            },
            style: C,
            silent: true
          });
          C.stroke === "auto" && R.setStyle({
            stroke: a(k / b)
          }), h.add(R);
        }
        if (x.get("show")) {
          var N = x.get("distance") + E, $ = u0(Cn(k / b * (v - g) + g), x.get("formatter")), O = a(k / b), F = M * (p - w - N) + f, z = L * (p - w - N) + d, V = x.get("rotate"), U = 0;
          V === "radial" ? (U = -I + 2 * Math.PI, U > Math.PI / 2 && (U += Math.PI)) : V === "tangential" ? U = -I - Math.PI / 2 : _e(V) && (U = V * Math.PI / 180), U === 0 ? h.add(new be({
            style: nn(x, {
              text: $,
              x: F,
              y: z,
              verticalAlign: L < -0.8 ? "top" : L > 0.8 ? "bottom" : "middle",
              align: M < -0.4 ? "left" : M > 0.4 ? "right" : "center"
            }, {
              inheritColor: O
            }),
            silent: true
          })) : h.add(new be({
            style: nn(x, {
              text: $,
              x: F,
              y: z,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: O
            }),
            silent: true,
            originX: F,
            originY: z,
            rotation: U
          }));
        }
        if (y.get("show") && k !== b) {
          var N = y.get("distance");
          N = N ? N + c : c;
          for (var X = 0; X <= _; X++) {
            M = Math.cos(I), L = Math.sin(I);
            var at = new ir({
              shape: {
                x1: M * (p - N) + f,
                y1: L * (p - N) + d,
                x2: M * (p - S - N) + f,
                y2: L * (p - S - N) + d
              },
              silent: true,
              style: D
            });
            D.stroke === "auto" && at.setStyle({
              stroke: a((k + X / _) / b)
            }), h.add(at), I += A;
          }
          I -= A;
        } else I += T;
      }
    }, t.prototype._renderPointer = function(e, r, i, a, s, o, l, u, c) {
      var h = this.group, f = this._data, d = this._progressEls, p = [], g = e.get([
        "pointer",
        "show"
      ]), v = e.getModel("progress"), m = v.get("show"), y = e.getData(), x = y.mapDimension("value"), b = +e.get("min"), _ = +e.get("max"), w = [
        b,
        _
      ], S = [
        o,
        l
      ];
      function I(A, C) {
        var D = y.getItemModel(A), E = D.getModel("pointer"), M = yt(E.get("width"), s.r), L = yt(E.get("length"), s.r), k = e.get([
          "pointer",
          "icon"
        ]), N = E.get("offsetCenter"), R = yt(N[0], s.r), $ = yt(N[1], s.r), O = E.get("keepAspect"), F;
        return k ? F = Fn(k, R - M / 2, $ - L, M, L, null, O) : F = new tpt({
          shape: {
            angle: -Math.PI / 2,
            width: M,
            r: L,
            x: R,
            y: $
          }
        }), F.rotation = -(C + Math.PI / 2), F.x = s.cx, F.y = s.cy, F;
      }
      function T(A, C) {
        var D = v.get("roundCap"), E = D ? cb : mi, M = v.get("overlap"), L = M ? v.get("width") : c / y.count(), k = M ? s.r - L : s.r - (A + 1) * L, N = M ? s.r : s.r - A * L, R = new E({
          shape: {
            startAngle: o,
            endAngle: C,
            cx: s.cx,
            cy: s.cy,
            clockwise: u,
            r0: k,
            r: N
          }
        });
        return M && (R.z2 = Pe(y.get(x, A), [
          b,
          _
        ], [
          100,
          0
        ], true)), R;
      }
      (m || g) && (y.diff(f).add(function(A) {
        var C = y.get(x, A);
        if (g) {
          var D = I(A, o);
          dn(D, {
            rotation: -((isNaN(+C) ? S[0] : Pe(C, w, S, true)) + Math.PI / 2)
          }, e), h.add(D), y.setItemGraphicEl(A, D);
        }
        if (m) {
          var E = T(A, o), M = v.get("clip");
          dn(E, {
            shape: {
              endAngle: Pe(C, w, S, M)
            }
          }, e), h.add(E), XI(e.seriesIndex, y.dataType, A, E), p[A] = E;
        }
      }).update(function(A, C) {
        var D = y.get(x, A);
        if (g) {
          var E = f.getItemGraphicEl(C), M = E ? E.rotation : o, L = I(A, M);
          L.rotation = M, Ie(L, {
            rotation: -((isNaN(+D) ? S[0] : Pe(D, w, S, true)) + Math.PI / 2)
          }, e), h.add(L), y.setItemGraphicEl(A, L);
        }
        if (m) {
          var k = d[C], N = k ? k.shape.endAngle : o, R = T(A, N), $ = v.get("clip");
          Ie(R, {
            shape: {
              endAngle: Pe(D, w, S, $)
            }
          }, e), h.add(R), XI(e.seriesIndex, y.dataType, A, R), p[A] = R;
        }
      }).execute(), y.each(function(A) {
        var C = y.getItemModel(A), D = C.getModel("emphasis"), E = D.get("focus"), M = D.get("blurScope"), L = D.get("disabled");
        if (g) {
          var k = y.getItemGraphicEl(A), N = y.getItemVisual(A, "style"), R = N.fill;
          if (k instanceof br) {
            var $ = k.style;
            k.useStyle(rt({
              image: $.image,
              x: $.x,
              y: $.y,
              width: $.width,
              height: $.height
            }, N));
          } else k.useStyle(N), k.type !== "pointer" && k.setColor(R);
          k.setStyle(C.getModel([
            "pointer",
            "itemStyle"
          ]).getItemStyle()), k.style.fill === "auto" && k.setStyle("fill", a(Pe(y.get(x, A), w, [
            0,
            1
          ], true))), k.z2EmphasisLift = 0, Ar(k, C), bn(k, E, M, L);
        }
        if (m) {
          var O = p[A];
          O.useStyle(y.getItemVisual(A, "style")), O.setStyle(C.getModel([
            "progress",
            "itemStyle"
          ]).getItemStyle()), O.z2EmphasisLift = 0, Ar(O, C), bn(O, E, M, L);
        }
      }), this._progressEls = p);
    }, t.prototype._renderAnchor = function(e, r) {
      var i = e.getModel("anchor"), a = i.get("show");
      if (a) {
        var s = i.get("size"), o = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = Fn(o, r.cx - s / 2 + yt(l[0], r.r), r.cy - s / 2 + yt(l[1], r.r), s, s, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, t.prototype._renderTitleAndDetail = function(e, r, i, a, s) {
      var o = this, l = e.getData(), u = l.mapDimension("value"), c = +e.get("min"), h = +e.get("max"), f = new Vt(), d = [], p = [], g = e.isAnimationEnabled(), v = e.get([
        "pointer",
        "showAbove"
      ]);
      l.diff(this._data).add(function(m) {
        d[m] = new be({
          silent: true
        }), p[m] = new be({
          silent: true
        });
      }).update(function(m, y) {
        d[m] = o._titleEls[y], p[m] = o._detailEls[y];
      }).execute(), l.each(function(m) {
        var y = l.getItemModel(m), x = l.get(u, m), b = new Vt(), _ = a(Pe(x, [
          c,
          h
        ], [
          0,
          1
        ], true)), w = y.getModel("title");
        if (w.get("show")) {
          var S = w.get("offsetCenter"), I = s.cx + yt(S[0], s.r), T = s.cy + yt(S[1], s.r), A = d[m];
          A.attr({
            z2: v ? 0 : 2,
            style: nn(w, {
              x: I,
              y: T,
              text: l.getName(m),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: _
            })
          }), b.add(A);
        }
        var C = y.getModel("detail");
        if (C.get("show")) {
          var D = C.get("offsetCenter"), E = s.cx + yt(D[0], s.r), M = s.cy + yt(D[1], s.r), L = yt(C.get("width"), s.r), k = yt(C.get("height"), s.r), N = e.get([
            "progress",
            "show"
          ]) ? l.getItemVisual(m, "style").fill : _, A = p[m], R = C.get("formatter");
          A.attr({
            z2: v ? 0 : 2,
            style: nn(C, {
              x: E,
              y: M,
              text: u0(x, R),
              width: isNaN(L) ? null : L,
              height: isNaN(k) ? null : k,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: N
            })
          }), jU(A, {
            normal: C
          }, x, function(O) {
            return u0(O, R);
          }), g && KU(A, m, l, e, {
            getFormattedLabel: function(O, F, z, V, U, X) {
              return u0(X ? X.interpolatedValue : x, R);
            }
          }), b.add(A);
        }
        f.add(b);
      }), this.group.add(f), this._titleEls = d, this._detailEls = p;
    }, t.type = "gauge", t;
  }(qe), rpt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "itemStyle", e;
    }
    return t.prototype.getInitialData = function(e, r) {
      return Md(this, [
        "value"
      ]);
    }, t.type = "series.gauge", t.defaultOption = {
      z: 2,
      colorBy: "data",
      center: [
        "50%",
        "50%"
      ],
      legendHoverLink: true,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: true,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        show: true,
        roundCap: false,
        lineStyle: {
          color: [
            [
              1,
              "#E6EBF8"
            ]
          ],
          width: 10
        }
      },
      progress: {
        show: false,
        overlap: true,
        width: 10,
        roundCap: false,
        clip: true
      },
      splitLine: {
        show: true,
        length: 10,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      axisTick: {
        show: true,
        splitNumber: 5,
        length: 6,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: true,
        distance: 15,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [
          0,
          0
        ],
        show: true,
        showAbove: true,
        length: "60%",
        width: 6,
        keepAspect: false
      },
      anchor: {
        show: false,
        showAbove: false,
        size: 6,
        icon: "circle",
        offsetCenter: [
          0,
          0
        ],
        keepAspect: false,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: true,
        offsetCenter: [
          0,
          "20%"
        ],
        color: "#464646",
        fontSize: 16,
        valueAnimation: false
      },
      detail: {
        show: true,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [
          5,
          10
        ],
        offsetCenter: [
          0,
          "40%"
        ],
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: false
      }
    }, t;
  }(an);
  function ipt(n) {
    n.registerChartView(npt), n.registerSeriesModel(rpt);
  }
  var apt = [
    "itemStyle",
    "opacity"
  ], spt = function(n) {
    q(t, n);
    function t(e, r) {
      var i = n.call(this) || this, a = i, s = new _i(), o = new be();
      return a.setTextContent(o), i.setTextGuideLine(s), i.updateData(e, r, true), i;
    }
    return t.prototype.updateData = function(e, r, i) {
      var a = this, s = e.hostModel, o = e.getItemModel(r), l = e.getItemLayout(r), u = o.getModel("emphasis"), c = o.get(apt);
      c = c ?? 1, i || os(a), a.useStyle(e.getItemVisual(r, "style")), a.style.lineJoin = "round", i ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, dn(a, {
        style: {
          opacity: c
        }
      }, s, r)) : Ie(a, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, s, r), Ar(a, o), this._updateLabel(e, r), bn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e, r) {
      var i = this, a = this.getTextGuideLine(), s = i.getTextContent(), o = e.hostModel, l = e.getItemModel(r), u = e.getItemLayout(r), c = u.label, h = e.getItemVisual(r, "style"), f = h.fill;
      kr(s, ur(l), {
        labelFetcher: e.hostModel,
        labelDataIndex: r,
        defaultOpacity: h.opacity,
        defaultText: e.getName(r)
      }, {
        normal: {
          align: c.textAlign,
          verticalAlign: c.verticalAlign
        }
      }), i.setTextConfig({
        local: true,
        inside: !!c.inside,
        insideStroke: f,
        outsideFill: f
      });
      var d = c.linePoints;
      a.setShape({
        points: d
      }), i.textGuideLineConfig = {
        anchor: d ? new Qt(d[0][0], d[0][1]) : null
      }, Ie(s, {
        style: {
          x: c.x,
          y: c.y
        }
      }, o, r), s.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), MD(i, RD(l), {
        stroke: f
      });
    }, t;
  }(yi), opt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.ignoreLabelLineUpdate = true, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = e.getData(), s = this._data, o = this.group;
      a.diff(s).add(function(l) {
        var u = new spt(a, l);
        a.setItemGraphicEl(l, u), o.add(u);
      }).update(function(l, u) {
        var c = s.getItemGraphicEl(u);
        c.updateData(a, l), o.add(c), a.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = s.getItemGraphicEl(l);
        Bg(u, e, l);
      }).execute(), this._data = a;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.prototype.dispose = function() {
    }, t.type = "funnel", t;
  }(qe), lpt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new qv(St(this.getData, this), St(this.getRawData, this)), this._defaultLabelLine(e);
    }, t.prototype.getInitialData = function(e, r) {
      return Md(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: qt(cD, this)
      });
    }, t.prototype._defaultLabelLine = function(e) {
      Wc(e, "labelLine", [
        "show"
      ]);
      var r = e.labelLine, i = e.emphasis.labelLine;
      r.show = r.show && e.label.show, i.show = i.show && e.emphasis.label.show;
    }, t.prototype.getDataParams = function(e) {
      var r = this.getData(), i = n.prototype.getDataParams.call(this, e), a = r.mapDimension("value"), s = r.getSum(a);
      return i.percent = s ? +(r.get(a, e) / s * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, t.type = "series.funnel", t.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: true,
        position: "outer"
      },
      labelLine: {
        show: true,
        length: 20,
        lineStyle: {
          width: 1
        }
      },
      itemStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(an);
  function upt(n, t) {
    return Zn(n.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    });
  }
  function cpt(n, t) {
    for (var e = n.mapDimension("value"), r = n.mapArray(e, function(l) {
      return l;
    }), i = [], a = t === "ascending", s = 0, o = n.count(); s < o; s++) i[s] = s;
    return Nt(t) ? i.sort(t) : t !== "none" && i.sort(function(l, u) {
      return a ? r[l] - r[u] : r[u] - r[l];
    }), i;
  }
  function hpt(n) {
    var t = n.hostModel, e = t.get("orient");
    n.each(function(r) {
      var i = n.getItemModel(r), a = i.getModel("label"), s = a.get("position"), o = i.getModel("labelLine"), l = n.getItemLayout(r), u = l.points, c = s === "inner" || s === "inside" || s === "center" || s === "insideLeft" || s === "insideRight", h, f, d, p;
      if (c) s === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, d = (u[0][1] + u[3][1]) / 2, h = "left") : s === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, d = (u[1][1] + u[2][1]) / 2, h = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, h = "center"), p = [
        [
          f,
          d
        ],
        [
          f,
          d
        ]
      ];
      else {
        var g = void 0, v = void 0, m = void 0, y = void 0, x = o.get("length");
        s === "left" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, m = g - x, f = m - 5, h = "right") : s === "right" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, m = g + x, f = m + 5, h = "left") : s === "top" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, y = v - x, d = y - 5, h = "center") : s === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, y = v + x, d = y + 5, h = "center") : s === "rightTop" ? (g = e === "horizontal" ? u[3][0] : u[1][0], v = e === "horizontal" ? u[3][1] : u[1][1], e === "horizontal" ? (y = v - x, d = y - 5, h = "center") : (m = g + x, f = m + 5, h = "top")) : s === "rightBottom" ? (g = u[2][0], v = u[2][1], e === "horizontal" ? (y = v + x, d = y + 5, h = "center") : (m = g + x, f = m + 5, h = "bottom")) : s === "leftTop" ? (g = u[0][0], v = e === "horizontal" ? u[0][1] : u[1][1], e === "horizontal" ? (y = v - x, d = y - 5, h = "center") : (m = g - x, f = m - 5, h = "right")) : s === "leftBottom" ? (g = e === "horizontal" ? u[1][0] : u[3][0], v = e === "horizontal" ? u[1][1] : u[2][1], e === "horizontal" ? (y = v + x, d = y + 5, h = "center") : (m = g - x, f = m - 5, h = "right")) : (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, e === "horizontal" ? (y = v + x, d = y + 5, h = "center") : (m = g + x, f = m + 5, h = "left")), e === "horizontal" ? (m = g, f = m) : (y = v, d = y), p = [
          [
            g,
            v
          ],
          [
            m,
            y
          ]
        ];
      }
      l.label = {
        linePoints: p,
        x: f,
        y: d,
        verticalAlign: "middle",
        textAlign: h,
        inside: c
      };
    });
  }
  function fpt(n, t) {
    n.eachSeriesByType("funnel", function(e) {
      var r = e.getData(), i = r.mapDimension("value"), a = e.get("sort"), s = upt(e, t), o = e.get("orient"), l = s.width, u = s.height, c = cpt(r, a), h = s.x, f = s.y, d = o === "horizontal" ? [
        yt(e.get("minSize"), u),
        yt(e.get("maxSize"), u)
      ] : [
        yt(e.get("minSize"), l),
        yt(e.get("maxSize"), l)
      ], p = r.getDataExtent(i), g = e.get("min"), v = e.get("max");
      g == null && (g = Math.min(p[0], 0)), v == null && (v = p[1]);
      var m = e.get("funnelAlign"), y = e.get("gap"), x = o === "horizontal" ? l : u, b = (x - y * (r.count() - 1)) / r.count(), _ = function(M, L) {
        if (o === "horizontal") {
          var k = r.get(i, M) || 0, N = Pe(k, [
            g,
            v
          ], d, true), R = void 0;
          switch (m) {
            case "top":
              R = f;
              break;
            case "center":
              R = f + (u - N) / 2;
              break;
            case "bottom":
              R = f + (u - N);
              break;
          }
          return [
            [
              L,
              R
            ],
            [
              L,
              R + N
            ]
          ];
        }
        var $ = r.get(i, M) || 0, O = Pe($, [
          g,
          v
        ], d, true), F;
        switch (m) {
          case "left":
            F = h;
            break;
          case "center":
            F = h + (l - O) / 2;
            break;
          case "right":
            F = h + l - O;
            break;
        }
        return [
          [
            F,
            L
          ],
          [
            F + O,
            L
          ]
        ];
      };
      a === "ascending" && (b = -b, y = -y, o === "horizontal" ? h += l : f += u, c = c.reverse());
      for (var w = 0; w < c.length; w++) {
        var S = c[w], I = c[w + 1], T = r.getItemModel(S);
        if (o === "horizontal") {
          var A = T.get([
            "itemStyle",
            "width"
          ]);
          A == null ? A = b : (A = yt(A, l), a === "ascending" && (A = -A));
          var C = _(S, h), D = _(I, h + A);
          h += A + y, r.setItemLayout(S, {
            points: C.concat(D.slice().reverse())
          });
        } else {
          var E = T.get([
            "itemStyle",
            "height"
          ]);
          E == null ? E = b : (E = yt(E, u), a === "ascending" && (E = -E));
          var C = _(S, f), D = _(I, f + E);
          f += E + y, r.setItemLayout(S, {
            points: C.concat(D.slice().reverse())
          });
        }
      }
      hpt(r);
    });
  }
  function dpt(n) {
    n.registerChartView(opt), n.registerSeriesModel(lpt), n.registerLayout(fpt), n.registerProcessor(Yv("funnel"));
  }
  var ppt = 0.3, gpt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._dataGroup = new Vt(), e._initialized = false, e;
    }
    return t.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, t.prototype.render = function(e, r, i, a) {
      this._progressiveEls = null;
      var s = this._dataGroup, o = e.getData(), l = this._data, u = e.coordinateSystem, c = u.dimensions, h = BF(e);
      o.diff(l).add(f).update(d).remove(p).execute();
      function f(v) {
        var m = FF(o, s, v, c, u);
        kC(m, o, v, h);
      }
      function d(v, m) {
        var y = l.getItemGraphicEl(m), x = w8(o, v, c, u);
        o.setItemGraphicEl(v, y), Ie(y, {
          shape: {
            points: x
          }
        }, e, v), os(y), kC(y, o, v, h);
      }
      function p(v) {
        var m = l.getItemGraphicEl(v);
        s.remove(m);
      }
      if (!this._initialized) {
        this._initialized = true;
        var g = vpt(u, e, function() {
          setTimeout(function() {
            s.removeClipPath();
          });
        });
        s.setClipPath(g);
      }
      this._data = o;
    }, t.prototype.incrementalPrepareRender = function(e, r, i) {
      this._initialized = true, this._data = null, this._dataGroup.removeAll();
    }, t.prototype.incrementalRender = function(e, r, i) {
      for (var a = r.getData(), s = r.coordinateSystem, o = s.dimensions, l = BF(r), u = this._progressiveEls = [], c = e.start; c < e.end; c++) {
        var h = FF(a, this._dataGroup, c, o, s);
        h.incremental = true, kC(h, a, c, l), u.push(h);
      }
    }, t.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, t.type = "parallel", t;
  }(qe);
  function vpt(n, t, e) {
    var r = n.model, i = n.getRect(), a = new ye({
      shape: {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      }
    }), s = r.get("layout") === "horizontal" ? "width" : "height";
    return a.setShape(s, 0), dn(a, {
      shape: {
        width: i.width,
        height: i.height
      }
    }, t, e), a;
  }
  function w8(n, t, e, r) {
    for (var i = [], a = 0; a < e.length; a++) {
      var s = e[a], o = n.get(n.mapDimension(s), t);
      mpt(o, r.getAxis(s).type) || i.push(r.dataToPoint(o, s));
    }
    return i;
  }
  function FF(n, t, e, r, i) {
    var a = w8(n, e, r, i), s = new _i({
      shape: {
        points: a
      },
      z2: 10
    });
    return t.add(s), n.setItemGraphicEl(e, s), s;
  }
  function BF(n) {
    var t = n.get("smooth", true);
    return t === true && (t = ppt), t = zo(t), Eg(t) && (t = 0), {
      smooth: t
    };
  }
  function kC(n, t, e, r) {
    n.useStyle(t.getItemVisual(e, "style")), n.style.fill = null, n.setShape("smooth", r.smooth);
    var i = t.getItemModel(e), a = i.getModel("emphasis");
    Ar(n, i, "lineStyle"), bn(n, a.get("focus"), a.get("blurScope"), a.get("disabled"));
  }
  function mpt(n, t) {
    return t === "category" ? n == null : n == null || isNaN(n);
  }
  var ypt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
    }
    return t.prototype.getInitialData = function(e, r) {
      return el(null, this, {
        useEncodeDefaulter: St(xpt, null, this)
      });
    }, t.prototype.getRawIndicesByActiveState = function(e) {
      var r = this.coordinateSystem, i = this.getData(), a = [];
      return r.eachActiveState(i, function(s, o) {
        e === s && a.push(i.getRawIndex(o));
      }), a;
    }, t.type = "series.parallel", t.dependencies = [
      "parallel"
    ], t.defaultOption = {
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: false
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: false
        }
      },
      progressive: 500,
      smooth: false,
      animationEasing: "linear"
    }, t;
  }(an);
  function xpt(n) {
    var t = n.ecModel.getComponent("parallel", n.get("parallelIndex"));
    if (t) {
      var e = {};
      return P(t.dimensions, function(r) {
        var i = bpt(r);
        e[r] = i;
      }), e;
    }
  }
  function bpt(n) {
    return +n.replace("dim", "");
  }
  var _pt = [
    "lineStyle",
    "opacity"
  ], wpt = {
    seriesType: "parallel",
    reset: function(n, t) {
      var e = n.coordinateSystem, r = {
        normal: n.get([
          "lineStyle",
          "opacity"
        ]),
        active: n.get("activeOpacity"),
        inactive: n.get("inactiveOpacity")
      };
      return {
        progress: function(i, a) {
          e.eachActiveState(a, function(s, o) {
            var l = r[s];
            if (s === "normal" && a.hasItemOption) {
              var u = a.getItemModel(o).get(_pt, true);
              u != null && (l = u);
            }
            var c = a.ensureUniqueItemVisual(o, "style");
            c.opacity = l;
          }, i.start, i.end);
        }
      };
    }
  };
  function Spt(n) {
    Cpt(n), Tpt(n);
  }
  function Cpt(n) {
    if (!n.parallel) {
      var t = false;
      P(n.series, function(e) {
        e && e.type === "parallel" && (t = true);
      }), t && (n.parallel = [
        {}
      ]);
    }
  }
  function Tpt(n) {
    var t = He(n.parallelAxis);
    P(t, function(e) {
      if (Ft(e)) {
        var r = e.parallelIndex || 0, i = He(n.parallel)[r];
        i && i.parallelAxisDefault && Zt(e, i.parallelAxisDefault, false);
      }
    });
  }
  var Ipt = 5, Apt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      this._model = e, this._api = i, this._handlers || (this._handlers = {}, P(kpt, function(a, s) {
        i.getZr().on(s, this._handlers[s] = St(a, this));
      }, this)), kd(this, "_throttledDispatchExpand", e.get("axisExpandRate"), "fixRate");
    }, t.prototype.dispose = function(e, r) {
      Wg(this, "_throttledDispatchExpand"), P(this._handlers, function(i, a) {
        r.getZr().off(a, i);
      }), this._handlers = null;
    }, t.prototype._throttledDispatchExpand = function(e) {
      this._dispatchExpand(e);
    }, t.prototype._dispatchExpand = function(e) {
      e && this._api.dispatchAction(rt({
        type: "parallelAxisExpand"
      }, e));
    }, t.type = "parallel", t;
  }(vn), kpt = {
    mousedown: function(n) {
      DC(this, "click") && (this._mouseDownPoint = [
        n.offsetX,
        n.offsetY
      ]);
    },
    mouseup: function(n) {
      var t = this._mouseDownPoint;
      if (DC(this, "click") && t) {
        var e = [
          n.offsetX,
          n.offsetY
        ], r = Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
        if (r > Ipt) return;
        var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([
          n.offsetX,
          n.offsetY
        ]);
        i.behavior !== "none" && this._dispatchExpand({
          axisExpandWindow: i.axisExpandWindow
        });
      }
      this._mouseDownPoint = null;
    },
    mousemove: function(n) {
      if (!(this._mouseDownPoint || !DC(this, "mousemove"))) {
        var t = this._model, e = t.coordinateSystem.getSlidedAxisExpandWindow([
          n.offsetX,
          n.offsetY
        ]), r = e.behavior;
        r === "jump" && this._throttledDispatchExpand.debounceNextCall(t.get("axisExpandDebounce")), this._throttledDispatchExpand(r === "none" ? null : {
          axisExpandWindow: e.axisExpandWindow,
          animation: r === "jump" ? null : {
            duration: 0
          }
        });
      }
    }
  };
  function DC(n, t) {
    var e = n._model;
    return e.get("axisExpandable") && e.get("axisExpandTriggerOn") === t;
  }
  var Dpt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      n.prototype.init.apply(this, arguments), this.mergeOption({});
    }, t.prototype.mergeOption = function(e) {
      var r = this.option;
      e && Zt(r, e, true), this._initDimensions();
    }, t.prototype.contains = function(e, r) {
      var i = e.get("parallelIndex");
      return i != null && r.getComponent("parallel", i) === this;
    }, t.prototype.setAxisExpand = function(e) {
      P([
        "axisExpandable",
        "axisExpandCenter",
        "axisExpandCount",
        "axisExpandWidth",
        "axisExpandWindow"
      ], function(r) {
        e.hasOwnProperty(r) && (this.option[r] = e[r]);
      }, this);
    }, t.prototype._initDimensions = function() {
      var e = this.dimensions = [], r = this.parallelAxisIndex = [], i = Le(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      P(i, function(a) {
        e.push("dim" + a.get("dim")), r.push(a.componentIndex);
      });
    }, t.type = "parallel", t.dependencies = [
      "parallelAxis"
    ], t.layoutMode = "box", t.defaultOption = {
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      layout: "horizontal",
      axisExpandable: false,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      axisExpandSlideTriggerArea: [
        -0.15,
        0.05,
        0.4
      ],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, t;
  }(pe), Ept = function(n) {
    q(t, n);
    function t(e, r, i, a, s) {
      var o = n.call(this, e, r, i) || this;
      return o.type = a || "value", o.axisIndex = s, o;
    }
    return t.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, t;
  }(ds);
  function xh(n, t, e, r, i, a) {
    n = n || 0;
    var s = e[1] - e[0];
    if (i != null && (i = jh(i, [
      0,
      s
    ])), a != null && (a = Math.max(a, i ?? 0)), r === "all") {
      var o = Math.abs(t[1] - t[0]);
      o = jh(o, [
        0,
        s
      ]), i = a = jh(o, [
        i,
        a
      ]), r = 0;
    }
    t[0] = jh(t[0], e), t[1] = jh(t[1], e);
    var l = EC(t, r);
    t[r] += n;
    var u = i || 0, c = e.slice();
    l.sign < 0 ? c[0] += u : c[1] -= u, t[r] = jh(t[r], c);
    var h;
    return h = EC(t, r), i != null && (h.sign !== l.sign || h.span < i) && (t[1 - r] = t[r] + l.sign * i), h = EC(t, r), a != null && h.span > a && (t[1 - r] = t[r] + h.sign * a), t;
  }
  function EC(n, t) {
    var e = n[t] - n[1 - t];
    return {
      span: Math.abs(e),
      sign: e > 0 ? -1 : e < 0 ? 1 : t ? -1 : 1
    };
  }
  function jh(n, t) {
    return Math.min(t[1] != null ? t[1] : 1 / 0, Math.max(t[0] != null ? t[0] : -1 / 0, n));
  }
  var MC = P, S8 = Math.min, C8 = Math.max, zF = Math.floor, Mpt = Math.ceil, VF = Cn, Rpt = Math.PI, Npt = function() {
    function n(t, e, r) {
      this.type = "parallel", this._axesMap = It(), this._axesLayout = {}, this.dimensions = t.dimensions, this._model = t, this._init(t, e, r);
    }
    return n.prototype._init = function(t, e, r) {
      var i = t.dimensions, a = t.parallelAxisIndex;
      MC(i, function(s, o) {
        var l = a[o], u = e.getComponent("parallelAxis", l), c = this._axesMap.set(s, new Ept(s, X1(u), [
          0,
          0
        ], u.get("type"), l)), h = c.type === "category";
        c.onBand = h && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, n.prototype.update = function(t, e) {
      this._updateAxesFromSeries(this._model, t);
    }, n.prototype.containPoint = function(t) {
      var e = this._makeLayoutInfo(), r = e.axisBase, i = e.layoutBase, a = e.pixelDimIndex, s = t[1 - a], o = t[a];
      return s >= r && s <= r + e.axisLength && o >= i && o <= i + e.layoutLength;
    }, n.prototype.getModel = function() {
      return this._model;
    }, n.prototype._updateAxesFromSeries = function(t, e) {
      e.eachSeries(function(r) {
        if (t.contains(r, e)) {
          var i = r.getData();
          MC(this.dimensions, function(a) {
            var s = this._axesMap.get(a);
            s.scale.unionExtentFromData(i, i.mapDimension(a)), Hf(s.scale, s.model);
          }, this);
        }
      }, this);
    }, n.prototype.resize = function(t, e) {
      this._rect = Zn(t.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight()
      }), this._layoutAxes();
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype._makeLayoutInfo = function() {
      var t = this._model, e = this._rect, r = [
        "x",
        "y"
      ], i = [
        "width",
        "height"
      ], a = t.get("layout"), s = a === "horizontal" ? 0 : 1, o = e[i[s]], l = [
        0,
        o
      ], u = this.dimensions.length, c = c0(t.get("axisExpandWidth"), l), h = c0(t.get("axisExpandCount") || 0, [
        0,
        u
      ]), f = t.get("axisExpandable") && u > 3 && u > h && h > 1 && c > 0 && o > 0, d = t.get("axisExpandWindow"), p;
      if (d) p = c0(d[1] - d[0], l), d[1] = d[0] + p;
      else {
        p = c0(c * (h - 1), l);
        var g = t.get("axisExpandCenter") || zF(u / 2);
        d = [
          c * g - p / 2
        ], d[1] = d[0] + p;
      }
      var v = (o - p) / (u - h);
      v < 3 && (v = 0);
      var m = [
        zF(VF(d[0] / c, 1)) + 1,
        Mpt(VF(d[1] / c, 1)) - 1
      ], y = v / c * d[0];
      return {
        layout: a,
        pixelDimIndex: s,
        layoutBase: e[r[s]],
        layoutLength: o,
        axisBase: e[r[1 - s]],
        axisLength: e[i[1 - s]],
        axisExpandable: f,
        axisExpandWidth: c,
        axisCollapseWidth: v,
        axisExpandWindow: d,
        axisCount: u,
        winInnerIndices: m,
        axisExpandWindow0Pos: y
      };
    }, n.prototype._layoutAxes = function() {
      var t = this._rect, e = this._axesMap, r = this.dimensions, i = this._makeLayoutInfo(), a = i.layout;
      e.each(function(s) {
        var o = [
          0,
          i.axisLength
        ], l = s.inverse ? 1 : 0;
        s.setExtent(o[l], o[1 - l]);
      }), MC(r, function(s, o) {
        var l = (i.axisExpandable ? Ppt : Lpt)(o, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: Rpt / 2,
          vertical: 0
        }, h = [
          u[a].x + t.x,
          u[a].y + t.y
        ], f = c[a], d = Xi();
        fh(d, d, f), to(d, d, h), this._axesLayout[s] = {
          position: h,
          rotation: f,
          transform: d,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, n.prototype.getAxis = function(t) {
      return this._axesMap.get(t);
    }, n.prototype.dataToPoint = function(t, e) {
      return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
    }, n.prototype.eachActiveState = function(t, e, r, i) {
      r == null && (r = 0), i == null && (i = t.count());
      var a = this._axesMap, s = this.dimensions, o = [], l = [];
      P(s, function(v) {
        o.push(t.mapDimension(v)), l.push(a.get(v).model);
      });
      for (var u = this.hasAxisBrushed(), c = r; c < i; c++) {
        var h = void 0;
        if (!u) h = "normal";
        else {
          h = "active";
          for (var f = t.getValues(o, c), d = 0, p = s.length; d < p; d++) {
            var g = l[d].getActiveState(f[d]);
            if (g === "inactive") {
              h = "inactive";
              break;
            }
          }
        }
        e(h, c);
      }
    }, n.prototype.hasAxisBrushed = function() {
      for (var t = this.dimensions, e = this._axesMap, r = false, i = 0, a = t.length; i < a; i++) e.get(t[i]).model.getActiveState() !== "normal" && (r = true);
      return r;
    }, n.prototype.axisCoordToPoint = function(t, e) {
      var r = this._axesLayout[e];
      return es([
        t,
        0
      ], r.transform);
    }, n.prototype.getAxisLayout = function(t) {
      return Bt(this._axesLayout[t]);
    }, n.prototype.getSlidedAxisExpandWindow = function(t) {
      var e = this._makeLayoutInfo(), r = e.pixelDimIndex, i = e.axisExpandWindow.slice(), a = i[1] - i[0], s = [
        0,
        e.axisExpandWidth * (e.axisCount - 1)
      ];
      if (!this.containPoint(t)) return {
        behavior: "none",
        axisExpandWindow: i
      };
      var o = t[r] - e.layoutBase - e.axisExpandWindow0Pos, l, u = "slide", c = e.axisCollapseWidth, h = this._model.get("axisExpandSlideTriggerArea"), f = h[0] != null;
      if (c) f && c && o < a * h[0] ? (u = "jump", l = o - a * h[2]) : f && c && o > a * (1 - h[0]) ? (u = "jump", l = o - a * (1 - h[2])) : (l = o - a * h[1]) >= 0 && (l = o - a * (1 - h[1])) <= 0 && (l = 0), l *= e.axisExpandWidth / c, l ? xh(l, i, s, "all") : u = "none";
      else {
        var d = i[1] - i[0], p = s[1] * o / d;
        i = [
          C8(0, p - d / 2)
        ], i[1] = S8(s[1], i[0] + d), i[0] = i[1] - d;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, n;
  }();
  function c0(n, t) {
    return S8(C8(n, t[0]), t[1]);
  }
  function Lpt(n, t) {
    var e = t.layoutLength / (t.axisCount - 1);
    return {
      position: e * n,
      axisNameAvailableWidth: e,
      axisLabelShow: true
    };
  }
  function Ppt(n, t) {
    var e = t.layoutLength, r = t.axisExpandWidth, i = t.axisCount, a = t.axisCollapseWidth, s = t.winInnerIndices, o, l = a, u = false, c;
    return n < s[0] ? (o = n * a, c = a) : n <= s[1] ? (o = t.axisExpandWindow0Pos + n * r - t.axisExpandWindow[0], l = r, u = true) : (o = e - (i - 1 - n) * a, c = a), {
      position: o,
      axisNameAvailableWidth: l,
      axisLabelShow: u,
      nameTruncateMaxWidth: c
    };
  }
  function $pt(n, t) {
    var e = [];
    return n.eachComponent("parallel", function(r, i) {
      var a = new Npt(r, n, t);
      a.name = "parallel_" + i, a.resize(r, t), r.coordinateSystem = a, a.model = r, e.push(a);
    }), n.eachSeries(function(r) {
      if (r.get("coordinateSystem") === "parallel") {
        var i = r.getReferringComponents("parallel", On).models[0];
        r.coordinateSystem = i.coordinateSystem;
      }
    }), e;
  }
  var Opt = {
    create: $pt
  }, $A = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.activeIntervals = [], e;
    }
    return t.prototype.getAreaSelectStyle = function() {
      return Hc([
        [
          "fill",
          "color"
        ],
        [
          "lineWidth",
          "borderWidth"
        ],
        [
          "stroke",
          "borderColor"
        ],
        [
          "width",
          "width"
        ],
        [
          "opacity",
          "opacity"
        ]
      ])(this.getModel("areaSelectStyle"));
    }, t.prototype.setActiveIntervals = function(e) {
      var r = this.activeIntervals = Bt(e);
      if (r) for (var i = r.length - 1; i >= 0; i--) _a(r[i]);
    }, t.prototype.getActiveState = function(e) {
      var r = this.activeIntervals;
      if (!r.length) return "normal";
      if (e == null || isNaN(+e)) return "inactive";
      if (r.length === 1) {
        var i = r[0];
        if (i[0] <= e && e <= i[1]) return "active";
      } else for (var a = 0, s = r.length; a < s; a++) if (r[a][0] <= e && e <= r[a][1]) return "active";
      return "inactive";
    }, t;
  }(pe);
  zn($A, Gv);
  var qc = true, ev = Math.min, qf = Math.max, Fpt = Math.pow, Bpt = 1e4, zpt = 6, Vpt = 6, GF = "globalPan", Gpt = {
    w: [
      0,
      0
    ],
    e: [
      0,
      1
    ],
    n: [
      1,
      0
    ],
    s: [
      1,
      1
    ]
  }, Wpt = {
    w: "ew",
    e: "ew",
    n: "ns",
    s: "ns",
    ne: "nesw",
    sw: "nesw",
    nw: "nwse",
    se: "nwse"
  }, WF = {
    brushStyle: {
      lineWidth: 2,
      stroke: "rgba(210,219,238,0.3)",
      fill: "#D2DBEE"
    },
    transformable: true,
    brushMode: "single",
    removeOnClick: false
  }, Upt = 0, eE = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this) || this;
      return r._track = [], r._covers = [], r._handlers = {}, r._zr = e, r.group = new Vt(), r._uid = "brushController_" + Upt++, P(Zpt, function(i, a) {
        this._handlers[a] = St(i, this);
      }, r), r;
    }
    return t.prototype.enableBrush = function(e) {
      return this._brushType && this._doDisableBrush(), e.brushType && this._doEnableBrush(e), this;
    }, t.prototype._doEnableBrush = function(e) {
      var r = this._zr;
      this._enableGlobalPan || Lht(r, GF, this._uid), P(this._handlers, function(i, a) {
        r.on(a, i);
      }), this._brushType = e.brushType, this._brushOption = Zt(Bt(WF), e, true);
    }, t.prototype._doDisableBrush = function() {
      var e = this._zr;
      Pht(e, GF, this._uid), P(this._handlers, function(r, i) {
        e.off(i, r);
      }), this._brushType = this._brushOption = null;
    }, t.prototype.setPanels = function(e) {
      if (e && e.length) {
        var r = this._panels = {};
        P(e, function(i) {
          r[i.panelId] = Bt(i);
        });
      } else this._panels = null;
      return this;
    }, t.prototype.mount = function(e) {
      e = e || {}, this._enableGlobalPan = e.enableGlobalPan;
      var r = this.group;
      return this._zr.add(r), r.attr({
        x: e.x || 0,
        y: e.y || 0,
        rotation: e.rotation || 0,
        scaleX: e.scaleX || 1,
        scaleY: e.scaleY || 1
      }), this._transform = r.getLocalTransform(), this;
    }, t.prototype.updateCovers = function(e) {
      e = ht(e, function(f) {
        return Zt(Bt(WF), f, true);
      });
      var r = "\0-brush-index-", i = this._covers, a = this._covers = [], s = this, o = this._creatingCover;
      return new Wo(i, e, u, l).add(c).update(c).remove(h).execute(), this;
      function l(f, d) {
        return (f.id != null ? f.id : r + d) + "-" + f.brushType;
      }
      function u(f, d) {
        return l(f.__brushOption, d);
      }
      function c(f, d) {
        var p = e[f];
        if (d != null && i[d] === o) a[f] = i[d];
        else {
          var g = a[f] = d != null ? (i[d].__brushOption = p, i[d]) : I8(s, T8(s, p));
          nE(s, g);
        }
      }
      function h(f) {
        i[f] !== o && s.group.remove(i[f]);
      }
    }, t.prototype.unmount = function() {
      return this.enableBrush(false), OA(this), this._zr.remove(this.group), this;
    }, t.prototype.dispose = function() {
      this.unmount(), this.off();
    }, t;
  }(Da);
  function T8(n, t) {
    var e = J1[t.brushType].createCover(n, t);
    return e.__brushOption = t, k8(e, t), n.group.add(e), e;
  }
  function I8(n, t) {
    var e = rE(t);
    return e.endCreating && (e.endCreating(n, t), k8(t, t.__brushOption)), t;
  }
  function A8(n, t) {
    var e = t.__brushOption;
    rE(t).updateCoverShape(n, t, e.range, e);
  }
  function k8(n, t) {
    var e = t.z;
    e == null && (e = Bpt), n.traverse(function(r) {
      r.z = e, r.z2 = e;
    });
  }
  function nE(n, t) {
    rE(t).updateCommon(n, t), A8(n, t);
  }
  function rE(n) {
    return J1[n.__brushOption.brushType];
  }
  function iE(n, t, e) {
    var r = n._panels;
    if (!r) return qc;
    var i, a = n._transform;
    return P(r, function(s) {
      s.isTargetByCursor(t, e, a) && (i = s);
    }), i;
  }
  function D8(n, t) {
    var e = n._panels;
    if (!e) return qc;
    var r = t.__brushOption.panelId;
    return r != null ? e[r] : qc;
  }
  function OA(n) {
    var t = n._covers, e = t.length;
    return P(t, function(r) {
      n.group.remove(r);
    }, n), t.length = 0, !!e;
  }
  function jc(n, t) {
    var e = ht(n._covers, function(r) {
      var i = r.__brushOption, a = Bt(i.range);
      return {
        brushType: i.brushType,
        panelId: i.panelId,
        range: a
      };
    });
    n.trigger("brush", {
      areas: e,
      isEnd: !!t.isEnd,
      removeOnClick: !!t.removeOnClick
    });
  }
  function Hpt(n) {
    var t = n._track;
    if (!t.length) return false;
    var e = t[t.length - 1], r = t[0], i = e[0] - r[0], a = e[1] - r[1], s = Fpt(i * i + a * a, 0.5);
    return s > zpt;
  }
  function E8(n) {
    var t = n.length - 1;
    return t < 0 && (t = 0), [
      n[0],
      n[t]
    ];
  }
  function M8(n, t, e, r) {
    var i = new Vt();
    return i.add(new ye({
      name: "main",
      style: aE(e),
      silent: true,
      draggable: true,
      cursor: "move",
      drift: qt(UF, n, t, i, [
        "n",
        "s",
        "w",
        "e"
      ]),
      ondragend: qt(jc, t, {
        isEnd: true
      })
    })), P(r, function(a) {
      i.add(new ye({
        name: a.join(""),
        style: {
          opacity: 0
        },
        draggable: true,
        silent: true,
        invisible: true,
        drift: qt(UF, n, t, i, a),
        ondragend: qt(jc, t, {
          isEnd: true
        })
      }));
    }), i;
  }
  function R8(n, t, e, r) {
    var i = r.brushStyle.lineWidth || 0, a = qf(i, Vpt), s = e[0][0], o = e[1][0], l = s - i / 2, u = o - i / 2, c = e[0][1], h = e[1][1], f = c - a + i / 2, d = h - a + i / 2, p = c - s, g = h - o, v = p + i, m = g + i;
    mo(n, t, "main", s, o, p, g), r.transformable && (mo(n, t, "w", l, u, a, m), mo(n, t, "e", f, u, a, m), mo(n, t, "n", l, u, v, a), mo(n, t, "s", l, d, v, a), mo(n, t, "nw", l, u, a, a), mo(n, t, "ne", f, u, a, a), mo(n, t, "sw", l, d, a, a), mo(n, t, "se", f, d, a, a));
  }
  function FA(n, t) {
    var e = t.__brushOption, r = e.transformable, i = t.childAt(0);
    i.useStyle(aE(e)), i.attr({
      silent: !r,
      cursor: r ? "move" : "default"
    }), P([
      [
        "w"
      ],
      [
        "e"
      ],
      [
        "n"
      ],
      [
        "s"
      ],
      [
        "s",
        "e"
      ],
      [
        "s",
        "w"
      ],
      [
        "n",
        "e"
      ],
      [
        "n",
        "w"
      ]
    ], function(a) {
      var s = t.childOfName(a.join("")), o = a.length === 1 ? BA(n, a[0]) : Ypt(n, a);
      s && s.attr({
        silent: !r,
        invisible: !r,
        cursor: r ? Wpt[o] + "-resize" : null
      });
    });
  }
  function mo(n, t, e, r, i, a, s) {
    var o = t.childOfName(e);
    o && o.setShape(jpt(sE(n, t, [
      [
        r,
        i
      ],
      [
        r + a,
        i + s
      ]
    ])));
  }
  function aE(n) {
    return $t({
      strokeNoScale: true
    }, n.brushStyle);
  }
  function N8(n, t, e, r) {
    var i = [
      ev(n, e),
      ev(t, r)
    ], a = [
      qf(n, e),
      qf(t, r)
    ];
    return [
      [
        i[0],
        a[0]
      ],
      [
        i[1],
        a[1]
      ]
    ];
  }
  function Xpt(n) {
    return Lc(n.group);
  }
  function BA(n, t) {
    var e = {
      w: "left",
      e: "right",
      n: "top",
      s: "bottom"
    }, r = {
      left: "w",
      right: "e",
      top: "n",
      bottom: "s"
    }, i = E1(e[t], Xpt(n));
    return r[i];
  }
  function Ypt(n, t) {
    var e = [
      BA(n, t[0]),
      BA(n, t[1])
    ];
    return (e[0] === "e" || e[0] === "w") && e.reverse(), e.join("");
  }
  function UF(n, t, e, r, i, a) {
    var s = e.__brushOption, o = n.toRectRange(s.range), l = L8(t, i, a);
    P(r, function(u) {
      var c = Gpt[u];
      o[c[0]][c[1]] += l[c[0]];
    }), s.range = n.fromRectRange(N8(o[0][0], o[1][0], o[0][1], o[1][1])), nE(t, e), jc(t, {
      isEnd: false
    });
  }
  function qpt(n, t, e, r) {
    var i = t.__brushOption.range, a = L8(n, e, r);
    P(i, function(s) {
      s[0] += a[0], s[1] += a[1];
    }), nE(n, t), jc(n, {
      isEnd: false
    });
  }
  function L8(n, t, e) {
    var r = n.group, i = r.transformCoordToLocal(t, e), a = r.transformCoordToLocal(0, 0);
    return [
      i[0] - a[0],
      i[1] - a[1]
    ];
  }
  function sE(n, t, e) {
    var r = D8(n, t);
    return r && r !== qc ? r.clipPath(e, n._transform) : Bt(e);
  }
  function jpt(n) {
    var t = ev(n[0][0], n[1][0]), e = ev(n[0][1], n[1][1]), r = qf(n[0][0], n[1][0]), i = qf(n[0][1], n[1][1]);
    return {
      x: t,
      y: e,
      width: r - t,
      height: i - e
    };
  }
  function Kpt(n, t, e) {
    if (!(!n._brushType || Jpt(n, t.offsetX, t.offsetY))) {
      var r = n._zr, i = n._covers, a = iE(n, t, e);
      if (!n._dragging) for (var s = 0; s < i.length; s++) {
        var o = i[s].__brushOption;
        if (a && (a === qc || o.panelId === a.panelId) && J1[o.brushType].contain(i[s], e[0], e[1])) return;
      }
      a && r.setCursorStyle("crosshair");
    }
  }
  function zA(n) {
    var t = n.event;
    t.preventDefault && t.preventDefault();
  }
  function VA(n, t, e) {
    return n.childOfName("main").contain(t, e);
  }
  function P8(n, t, e, r) {
    var i = n._creatingCover, a = n._creatingPanel, s = n._brushOption, o;
    if (n._track.push(e.slice()), Hpt(n) || i) {
      if (a && !i) {
        s.brushMode === "single" && OA(n);
        var l = Bt(s);
        l.brushType = HF(l.brushType, a), l.panelId = a === qc ? null : a.panelId, i = n._creatingCover = T8(n, l), n._covers.push(i);
      }
      if (i) {
        var u = J1[HF(n._brushType, a)], c = i.__brushOption;
        c.range = u.getCreatingRange(sE(n, i, n._track)), r && (I8(n, i), u.updateCommon(n, i)), A8(n, i), o = {
          isEnd: r
        };
      }
    } else r && s.brushMode === "single" && s.removeOnClick && iE(n, t, e) && OA(n) && (o = {
      isEnd: r,
      removeOnClick: true
    });
    return o;
  }
  function HF(n, t) {
    return n === "auto" ? t.defaultBrushType : n;
  }
  var Zpt = {
    mousedown: function(n) {
      if (this._dragging) XF(this, n);
      else if (!n.target || !n.target.draggable) {
        zA(n);
        var t = this.group.transformCoordToLocal(n.offsetX, n.offsetY);
        this._creatingCover = null;
        var e = this._creatingPanel = iE(this, n, t);
        e && (this._dragging = true, this._track = [
          t.slice()
        ]);
      }
    },
    mousemove: function(n) {
      var t = n.offsetX, e = n.offsetY, r = this.group.transformCoordToLocal(t, e);
      if (Kpt(this, n, r), this._dragging) {
        zA(n);
        var i = P8(this, n, r, false);
        i && jc(this, i);
      }
    },
    mouseup: function(n) {
      XF(this, n);
    }
  };
  function XF(n, t) {
    if (n._dragging) {
      zA(t);
      var e = t.offsetX, r = t.offsetY, i = n.group.transformCoordToLocal(e, r), a = P8(n, t, i, true);
      n._dragging = false, n._track = [], n._creatingCover = null, a && jc(n, a);
    }
  }
  function Jpt(n, t, e) {
    var r = n._zr;
    return t < 0 || t > r.getWidth() || e < 0 || e > r.getHeight();
  }
  var J1 = {
    lineX: YF(0),
    lineY: YF(1),
    rect: {
      createCover: function(n, t) {
        function e(r) {
          return r;
        }
        return M8({
          toRectRange: e,
          fromRectRange: e
        }, n, t, [
          [
            "w"
          ],
          [
            "e"
          ],
          [
            "n"
          ],
          [
            "s"
          ],
          [
            "s",
            "e"
          ],
          [
            "s",
            "w"
          ],
          [
            "n",
            "e"
          ],
          [
            "n",
            "w"
          ]
        ]);
      },
      getCreatingRange: function(n) {
        var t = E8(n);
        return N8(t[1][0], t[1][1], t[0][0], t[0][1]);
      },
      updateCoverShape: function(n, t, e, r) {
        R8(n, t, e, r);
      },
      updateCommon: FA,
      contain: VA
    },
    polygon: {
      createCover: function(n, t) {
        var e = new Vt();
        return e.add(new _i({
          name: "main",
          style: aE(t),
          silent: true
        })), e;
      },
      getCreatingRange: function(n) {
        return n;
      },
      endCreating: function(n, t) {
        t.remove(t.childAt(0)), t.add(new yi({
          name: "main",
          draggable: true,
          drift: qt(qpt, n, t),
          ondragend: qt(jc, n, {
            isEnd: true
          })
        }));
      },
      updateCoverShape: function(n, t, e, r) {
        t.childAt(0).setShape({
          points: sE(n, t, e)
        });
      },
      updateCommon: FA,
      contain: VA
    }
  };
  function YF(n) {
    return {
      createCover: function(t, e) {
        return M8({
          toRectRange: function(r) {
            var i = [
              r,
              [
                0,
                100
              ]
            ];
            return n && i.reverse(), i;
          },
          fromRectRange: function(r) {
            return r[n];
          }
        }, t, e, [
          [
            [
              "w"
            ],
            [
              "e"
            ]
          ],
          [
            [
              "n"
            ],
            [
              "s"
            ]
          ]
        ][n]);
      },
      getCreatingRange: function(t) {
        var e = E8(t), r = ev(e[0][n], e[1][n]), i = qf(e[0][n], e[1][n]);
        return [
          r,
          i
        ];
      },
      updateCoverShape: function(t, e, r, i) {
        var a, s = D8(t, e);
        if (s !== qc && s.getLinearBrushOtherExtent) a = s.getLinearBrushOtherExtent(n);
        else {
          var o = t._zr;
          a = [
            0,
            [
              o.getWidth(),
              o.getHeight()
            ][1 - n]
          ];
        }
        var l = [
          r,
          a
        ];
        n && l.reverse(), R8(t, e, l, i);
      },
      updateCommon: FA,
      contain: VA
    };
  }
  function $8(n) {
    return n = oE(n), function(t) {
      return XU(t, n);
    };
  }
  function O8(n, t) {
    return n = oE(n), function(e) {
      var r = t ?? e, i = r ? n.width : n.height, a = r ? n.x : n.y;
      return [
        a,
        a + (i || 0)
      ];
    };
  }
  function F8(n, t, e) {
    var r = oE(n);
    return function(i, a) {
      return r.contain(a[0], a[1]) && !q1(i, t, e);
    };
  }
  function oE(n) {
    return te.create(n);
  }
  var Qpt = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], tgt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, r) {
      n.prototype.init.apply(this, arguments), (this._brushController = new eE(r.getZr())).on("brush", St(this._onBrush, this));
    }, t.prototype.render = function(e, r, i, a) {
      if (!egt(e, r, a)) {
        this.axisModel = e, this.api = i, this.group.removeAll();
        var s = this._axisGroup;
        if (this._axisGroup = new Vt(), this.group.add(this._axisGroup), !!e.get("show")) {
          var o = rgt(e, r), l = o.coordinateSystem, u = e.getAreaSelectStyle(), c = u.width, h = e.axis.dim, f = l.getAxisLayout(h), d = rt({
            strokeContainThreshold: c
          }, f), p = new di(e, d);
          P(Qpt, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(d, u, e, o, c, i), Ov(s, this._axisGroup, e);
        }
      }
    }, t.prototype._refreshBrushController = function(e, r, i, a, s, o) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), h = te.create({
        x: l[0],
        y: -s / 2,
        width: u,
        height: s
      });
      h.x -= c, h.width += 2 * c, this._brushController.mount({
        enableGlobalPan: true,
        rotation: e.rotation,
        x: e.position[0],
        y: e.position[1]
      }).setPanels([
        {
          panelId: "pl",
          clipPath: $8(h),
          isTargetByCursor: F8(h, o, a),
          getLinearBrushOtherExtent: O8(h, 0)
        }
      ]).enableBrush({
        brushType: "lineX",
        brushStyle: r,
        removeOnClick: true
      }).updateCovers(ngt(i));
    }, t.prototype._onBrush = function(e) {
      var r = e.areas, i = this.axisModel, a = i.axis, s = ht(r, function(o) {
        return [
          a.coordToData(o.range[0], true),
          a.coordToData(o.range[1], true)
        ];
      });
      (!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: s
      });
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.type = "parallelAxis", t;
  }(vn);
  function egt(n, t, e) {
    return e && e.type === "axisAreaSelect" && t.findComponents({
      mainType: "parallelAxis",
      query: e
    })[0] === n;
  }
  function ngt(n) {
    var t = n.axis;
    return ht(n.activeIntervals, function(e) {
      return {
        brushType: "lineX",
        panelId: "pl",
        range: [
          t.dataToCoord(e[0], true),
          t.dataToCoord(e[1], true)
        ]
      };
    });
  }
  function rgt(n, t) {
    return t.getComponent("parallel", n.get("parallelIndex"));
  }
  var igt = {
    type: "axisAreaSelect",
    event: "axisAreaSelected"
  };
  function agt(n) {
    n.registerAction(igt, function(t, e) {
      e.eachComponent({
        mainType: "parallelAxis",
        query: t
      }, function(r) {
        r.axis.model.setActiveIntervals(t.intervals);
      });
    }), n.registerAction("parallelAxisExpand", function(t, e) {
      e.eachComponent({
        mainType: "parallel",
        query: t
      }, function(r) {
        r.setAxisExpand(t);
      });
    });
  }
  var sgt = {
    type: "value",
    areaSelectStyle: {
      width: 20,
      borderWidth: 1,
      borderColor: "rgba(160,197,232)",
      color: "rgba(160,197,232)",
      opacity: 0.3
    },
    realtime: true,
    z: 10
  };
  function B8(n) {
    n.registerComponentView(Apt), n.registerComponentModel(Dpt), n.registerCoordinateSystem("parallel", Opt), n.registerPreprocessor(Spt), n.registerComponentModel($A), n.registerComponentView(tgt), Yf(n, "parallel", $A, sgt), agt(n);
  }
  function ogt(n) {
    se(B8), n.registerChartView(gpt), n.registerSeriesModel(ypt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, wpt);
  }
  var lgt = /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return n;
  }(), ugt = function(n) {
    q(t, n);
    function t(e) {
      return n.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new lgt();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.extent;
      e.moveTo(r.x1, r.y1), e.bezierCurveTo(r.cpx1, r.cpy1, r.cpx2, r.cpy2, r.x2, r.y2), r.orient === "vertical" ? (e.lineTo(r.x2 + i, r.y2), e.bezierCurveTo(r.cpx2 + i, r.cpy2, r.cpx1 + i, r.cpy1, r.x1 + i, r.y1)) : (e.lineTo(r.x2, r.y2 + i), e.bezierCurveTo(r.cpx2, r.cpy2 + i, r.cpx1, r.cpy1 + i, r.x1, r.y1 + i)), e.closePath();
    }, t.prototype.highlight = function() {
      Vo(this);
    }, t.prototype.downplay = function() {
      Go(this);
    }, t;
  }(le), cgt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._focusAdjacencyDisabled = false, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = this, s = e.getGraph(), o = this.group, l = e.layoutInfo, u = l.width, c = l.height, h = e.getData(), f = e.getData("edge"), d = e.get("orient");
      this._model = e, o.removeAll(), o.x = l.x, o.y = l.y, s.eachEdge(function(p) {
        var g = new ugt(), v = Ut(g);
        v.dataIndex = p.dataIndex, v.seriesIndex = e.seriesIndex, v.dataType = "edge";
        var m = p.getModel(), y = m.getModel("lineStyle"), x = y.get("curveness"), b = p.node1.getLayout(), _ = p.node1.getModel(), w = _.get("localX"), S = _.get("localY"), I = p.node2.getLayout(), T = p.node2.getModel(), A = T.get("localX"), C = T.get("localY"), D = p.getLayout(), E, M, L, k, N, R, $, O;
        g.shape.extent = Math.max(1, D.dy), g.shape.orient = d, d === "vertical" ? (E = (w != null ? w * u : b.x) + D.sy, M = (S != null ? S * c : b.y) + b.dy, L = (A != null ? A * u : I.x) + D.ty, k = C != null ? C * c : I.y, N = E, R = M * (1 - x) + k * x, $ = L, O = M * x + k * (1 - x)) : (E = (w != null ? w * u : b.x) + b.dx, M = (S != null ? S * c : b.y) + D.sy, L = A != null ? A * u : I.x, k = (C != null ? C * c : I.y) + D.ty, N = E * (1 - x) + L * x, R = M, $ = E * x + L * (1 - x), O = k), g.setShape({
          x1: E,
          y1: M,
          x2: L,
          y2: k,
          cpx1: N,
          cpy1: R,
          cpx2: $,
          cpy2: O
        }), g.useStyle(y.getItemStyle()), qF(g.style, d, p);
        var F = "" + m.get("value"), z = ur(m, "edgeLabel");
        kr(g, z, {
          labelFetcher: {
            getFormattedLabel: function(X, at, pt, it, et, ft) {
              return e.getFormattedLabel(X, at, "edge", it, Ws(et, z.normal && z.normal.get("formatter"), F), ft);
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: F
        }), g.setTextConfig({
          position: "inside"
        });
        var V = m.getModel("emphasis");
        Ar(g, m, "lineStyle", function(X) {
          var at = X.getItemStyle();
          return qF(at, d, p), at;
        }), o.add(g), f.setItemGraphicEl(p.dataIndex, g);
        var U = V.get("focus");
        bn(g, U === "adjacency" ? p.getAdjacentDataIndices() : U === "trajectory" ? p.getTrajectoryDataIndices() : U, V.get("blurScope"), V.get("disabled"));
      }), s.eachNode(function(p) {
        var g = p.getLayout(), v = p.getModel(), m = v.get("localX"), y = v.get("localY"), x = v.getModel("emphasis"), b = v.get([
          "itemStyle",
          "borderRadius"
        ]) || 0, _ = new ye({
          shape: {
            x: m != null ? m * u : g.x,
            y: y != null ? y * c : g.y,
            width: g.dx,
            height: g.dy,
            r: b
          },
          style: v.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        kr(_, ur(v), {
          labelFetcher: {
            getFormattedLabel: function(S, I) {
              return e.getFormattedLabel(S, I, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), _.disableLabelAnimation = true, _.setStyle("fill", p.getVisual("color")), _.setStyle("decal", p.getVisual("style").decal), Ar(_, v), o.add(_), h.setItemGraphicEl(p.dataIndex, _), Ut(_).dataType = "node";
        var w = x.get("focus");
        bn(_, w === "adjacency" ? p.getAdjacentDataIndices() : w === "trajectory" ? p.getTrajectoryDataIndices() : w, x.get("blurScope"), x.get("disabled"));
      }), h.eachItemGraphicEl(function(p, g) {
        var v = h.getItemModel(g);
        v.get("draggable") && (p.drift = function(m, y) {
          a._focusAdjacencyDisabled = true, this.shape.x += m, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: e.id,
            dataIndex: h.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          a._focusAdjacencyDisabled = false;
        }, p.draggable = true, p.cursor = "move");
      }), !this._data && e.isAnimationEnabled() && o.setClipPath(hgt(o.getBoundingRect(), e, function() {
        o.removeClipPath();
      })), this._data = e.getData();
    }, t.prototype.dispose = function() {
    }, t.type = "sankey", t;
  }(qe);
  function qF(n, t, e) {
    switch (n.fill) {
      case "source":
        n.fill = e.node1.getVisual("color"), n.decal = e.node1.getVisual("style").decal;
        break;
      case "target":
        n.fill = e.node2.getVisual("color"), n.decal = e.node2.getVisual("style").decal;
        break;
      case "gradient":
        var r = e.node1.getVisual("color"), i = e.node2.getVisual("color");
        wt(r) && wt(i) && (n.fill = new $v(0, 0, +(t === "horizontal"), +(t === "vertical"), [
          {
            color: r,
            offset: 0
          },
          {
            color: i,
            offset: 1
          }
        ]));
    }
  }
  function hgt(n, t, e) {
    var r = new ye({
      shape: {
        x: n.x - 10,
        y: n.y - 10,
        width: 0,
        height: n.height + 20
      }
    });
    return dn(r, {
      shape: {
        width: n.width + 20
      }
    }, t, e), r;
  }
  var fgt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, r) {
      var i = e.edges || e.links || [], a = e.data || e.nodes || [], s = e.levels || [];
      this.levelModels = [];
      for (var o = this.levelModels, l = 0; l < s.length; l++) s[l].depth != null && s[l].depth >= 0 && (o[s[l].depth] = new $e(s[l], this, r));
      var u = _8(a, i, this, true, c);
      return u.data;
      function c(h, f) {
        h.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getData().getItemLayout(p);
          if (v) {
            var m = v.depth, y = g.levelModels[m];
            y && (d.parentModel = y);
          }
          return d;
        }), f.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getGraph().getEdgeByIndex(p), m = v.node1.getLayout();
          if (m) {
            var y = m.depth, x = g.levelModels[y];
            x && (d.parentModel = x);
          }
          return d;
        });
      }
    }, t.prototype.setNodePosition = function(e, r) {
      var i = this.option.data || this.option.nodes, a = i[e];
      a.localX = r[0], a.localY = r[1];
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(e, r, i) {
      function a(d) {
        return isNaN(d) || d == null;
      }
      if (i === "edge") {
        var s = this.getDataParams(e, i), o = s.data, l = s.value, u = o.source + " -- " + o.target;
        return cr("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(e), h = c.getLayout().value, f = this.getDataParams(e, i).data.name;
        return cr("nameValue", {
          name: f != null ? f + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(e, r) {
      var i = n.prototype.getDataParams.call(this, e, r);
      if (i.value == null && r === "node") {
        var a = this.getGraph().getNodeByIndex(e), s = a.getLayout().value;
        i.value = s;
      }
      return i;
    }, t.type = "series.sankey", t.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: true,
      layoutIterations: 32,
      label: {
        show: true,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: false,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  }(an);
  function dgt(n, t) {
    n.eachSeriesByType("sankey", function(e) {
      var r = e.get("nodeWidth"), i = e.get("nodeGap"), a = pgt(e, t);
      e.layoutInfo = a;
      var s = a.width, o = a.height, l = e.getGraph(), u = l.nodes, c = l.edges;
      vgt(u);
      var h = Le(u, function(g) {
        return g.getLayout().value === 0;
      }), f = h.length !== 0 ? 0 : e.get("layoutIterations"), d = e.get("orient"), p = e.get("nodeAlign");
      ggt(u, c, r, i, s, o, f, d, p);
    });
  }
  function pgt(n, t) {
    return Zn(n.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    });
  }
  function ggt(n, t, e, r, i, a, s, o, l) {
    mgt(n, t, e, i, a, o, l), _gt(n, t, a, i, r, s, o), Egt(n, o);
  }
  function vgt(n) {
    P(n, function(t) {
      var e = Bl(t.outEdges, vb), r = Bl(t.inEdges, vb), i = t.getValue() || 0, a = Math.max(e, r, i);
      t.setLayout({
        value: a
      }, true);
    });
  }
  function mgt(n, t, e, r, i, a, s) {
    for (var o = [], l = [], u = [], c = [], h = 0, f = 0; f < t.length; f++) o[f] = 1;
    for (var f = 0; f < n.length; f++) l[f] = n[f].inEdges.length, l[f] === 0 && u.push(n[f]);
    for (var d = -1; u.length; ) {
      for (var p = 0; p < u.length; p++) {
        var g = u[p], v = g.hostGraph.data.getRawDataItem(g.dataIndex), m = v.depth != null && v.depth >= 0;
        m && v.depth > d && (d = v.depth), g.setLayout({
          depth: m ? v.depth : h
        }, true), a === "vertical" ? g.setLayout({
          dy: e
        }, true) : g.setLayout({
          dx: e
        }, true);
        for (var y = 0; y < g.outEdges.length; y++) {
          var x = g.outEdges[y], b = t.indexOf(x);
          o[b] = 0;
          var _ = x.node2, w = n.indexOf(_);
          --l[w] === 0 && c.indexOf(_) < 0 && c.push(_);
        }
      }
      ++h, u = c, c = [];
    }
    for (var f = 0; f < o.length; f++) if (o[f] === 1) throw new Error("Sankey is a DAG, the original data has cycle!");
    var S = d > h - 1 ? d : h - 1;
    s && s !== "left" && ygt(n, s, a, S);
    var I = a === "vertical" ? (i - e) / S : (r - e) / S;
    bgt(n, I, a);
  }
  function z8(n) {
    var t = n.hostGraph.data.getRawDataItem(n.dataIndex);
    return t.depth != null && t.depth >= 0;
  }
  function ygt(n, t, e, r) {
    if (t === "right") {
      for (var i = [], a = n, s = 0; a.length; ) {
        for (var o = 0; o < a.length; o++) {
          var l = a[o];
          l.setLayout({
            skNodeHeight: s
          }, true);
          for (var u = 0; u < l.inEdges.length; u++) {
            var c = l.inEdges[u];
            i.indexOf(c.node1) < 0 && i.push(c.node1);
          }
        }
        a = i, i = [], ++s;
      }
      P(n, function(h) {
        z8(h) || h.setLayout({
          depth: Math.max(0, r - h.getLayout().skNodeHeight)
        }, true);
      });
    } else t === "justify" && xgt(n, r);
  }
  function xgt(n, t) {
    P(n, function(e) {
      !z8(e) && !e.outEdges.length && e.setLayout({
        depth: t
      }, true);
    });
  }
  function bgt(n, t, e) {
    P(n, function(r) {
      var i = r.getLayout().depth * t;
      e === "vertical" ? r.setLayout({
        y: i
      }, true) : r.setLayout({
        x: i
      }, true);
    });
  }
  function _gt(n, t, e, r, i, a, s) {
    var o = wgt(n, s);
    Sgt(o, t, e, r, i, s), RC(o, i, e, r, s);
    for (var l = 1; a > 0; a--) l *= 0.99, Cgt(o, l, s), RC(o, i, e, r, s), Dgt(o, l, s), RC(o, i, e, r, s);
  }
  function wgt(n, t) {
    var e = [], r = t === "vertical" ? "y" : "x", i = GI(n, function(a) {
      return a.getLayout()[r];
    });
    return i.keys.sort(function(a, s) {
      return a - s;
    }), P(i.keys, function(a) {
      e.push(i.buckets.get(a));
    }), e;
  }
  function Sgt(n, t, e, r, i, a) {
    var s = 1 / 0;
    P(n, function(o) {
      var l = o.length, u = 0;
      P(o, function(h) {
        u += h.getLayout().value;
      });
      var c = a === "vertical" ? (r - (l - 1) * i) / u : (e - (l - 1) * i) / u;
      c < s && (s = c);
    }), P(n, function(o) {
      P(o, function(l, u) {
        var c = l.getLayout().value * s;
        a === "vertical" ? (l.setLayout({
          x: u
        }, true), l.setLayout({
          dx: c
        }, true)) : (l.setLayout({
          y: u
        }, true), l.setLayout({
          dy: c
        }, true));
      });
    }), P(t, function(o) {
      var l = +o.getValue() * s;
      o.setLayout({
        dy: l
      }, true);
    });
  }
  function RC(n, t, e, r, i) {
    var a = i === "vertical" ? "x" : "y";
    P(n, function(s) {
      s.sort(function(g, v) {
        return g.getLayout()[a] - v.getLayout()[a];
      });
      for (var o, l, u, c = 0, h = s.length, f = i === "vertical" ? "dx" : "dy", d = 0; d < h; d++) l = s[d], u = c - l.getLayout()[a], u > 0 && (o = l.getLayout()[a] + u, i === "vertical" ? l.setLayout({
        x: o
      }, true) : l.setLayout({
        y: o
      }, true)), c = l.getLayout()[a] + l.getLayout()[f] + t;
      var p = i === "vertical" ? r : e;
      if (u = c - t - p, u > 0) {
        o = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: o
        }, true) : l.setLayout({
          y: o
        }, true), c = o;
        for (var d = h - 2; d >= 0; --d) l = s[d], u = l.getLayout()[a] + l.getLayout()[f] + t - c, u > 0 && (o = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: o
        }, true) : l.setLayout({
          y: o
        }, true)), c = l.getLayout()[a];
      }
    });
  }
  function Cgt(n, t, e) {
    P(n.slice().reverse(), function(r) {
      P(r, function(i) {
        if (i.outEdges.length) {
          var a = Bl(i.outEdges, Tgt, e) / Bl(i.outEdges, vb);
          if (isNaN(a)) {
            var s = i.outEdges.length;
            a = s ? Bl(i.outEdges, Igt, e) / s : 0;
          }
          if (e === "vertical") {
            var o = i.getLayout().x + (a - Zl(i, e)) * t;
            i.setLayout({
              x: o
            }, true);
          } else {
            var l = i.getLayout().y + (a - Zl(i, e)) * t;
            i.setLayout({
              y: l
            }, true);
          }
        }
      });
    });
  }
  function Tgt(n, t) {
    return Zl(n.node2, t) * n.getValue();
  }
  function Igt(n, t) {
    return Zl(n.node2, t);
  }
  function Agt(n, t) {
    return Zl(n.node1, t) * n.getValue();
  }
  function kgt(n, t) {
    return Zl(n.node1, t);
  }
  function Zl(n, t) {
    return t === "vertical" ? n.getLayout().x + n.getLayout().dx / 2 : n.getLayout().y + n.getLayout().dy / 2;
  }
  function vb(n) {
    return n.getValue();
  }
  function Bl(n, t, e) {
    for (var r = 0, i = n.length, a = -1; ++a < i; ) {
      var s = +t(n[a], e);
      isNaN(s) || (r += s);
    }
    return r;
  }
  function Dgt(n, t, e) {
    P(n, function(r) {
      P(r, function(i) {
        if (i.inEdges.length) {
          var a = Bl(i.inEdges, Agt, e) / Bl(i.inEdges, vb);
          if (isNaN(a)) {
            var s = i.inEdges.length;
            a = s ? Bl(i.inEdges, kgt, e) / s : 0;
          }
          if (e === "vertical") {
            var o = i.getLayout().x + (a - Zl(i, e)) * t;
            i.setLayout({
              x: o
            }, true);
          } else {
            var l = i.getLayout().y + (a - Zl(i, e)) * t;
            i.setLayout({
              y: l
            }, true);
          }
        }
      });
    });
  }
  function Egt(n, t) {
    var e = t === "vertical" ? "x" : "y";
    P(n, function(r) {
      r.outEdges.sort(function(i, a) {
        return i.node2.getLayout()[e] - a.node2.getLayout()[e];
      }), r.inEdges.sort(function(i, a) {
        return i.node1.getLayout()[e] - a.node1.getLayout()[e];
      });
    }), P(n, function(r) {
      var i = 0, a = 0;
      P(r.outEdges, function(s) {
        s.setLayout({
          sy: i
        }, true), i += s.getLayout().dy;
      }), P(r.inEdges, function(s) {
        s.setLayout({
          ty: a
        }, true), a += s.getLayout().dy;
      });
    });
  }
  function Mgt(n) {
    n.eachSeriesByType("sankey", function(t) {
      var e = t.getGraph(), r = e.nodes, i = e.edges;
      if (r.length) {
        var a = 1 / 0, s = -1 / 0;
        P(r, function(o) {
          var l = o.getLayout().value;
          l < a && (a = l), l > s && (s = l);
        }), P(r, function(o) {
          var l = new or({
            type: "color",
            mappingMethod: "linear",
            dataExtent: [
              a,
              s
            ],
            visual: t.get("color")
          }), u = l.mapValueToVisual(o.getLayout().value), c = o.getModel().get([
            "itemStyle",
            "color"
          ]);
          c != null ? (o.setVisual("color", c), o.setVisual("style", {
            fill: c
          })) : (o.setVisual("color", u), o.setVisual("style", {
            fill: u
          }));
        });
      }
      i.length && P(i, function(o) {
        var l = o.getModel().get("lineStyle");
        o.setVisual("style", l);
      });
    });
  }
  function Rgt(n) {
    n.registerChartView(cgt), n.registerSeriesModel(fgt), n.registerLayout(dgt), n.registerVisual(Mgt), n.registerAction({
      type: "dragNode",
      event: "dragnode",
      update: "update"
    }, function(t, e) {
      e.eachComponent({
        mainType: "series",
        subType: "sankey",
        query: t
      }, function(r) {
        r.setNodePosition(t.dataIndex, [
          t.localX,
          t.localY
        ]);
      });
    });
  }
  var V8 = function() {
    function n() {
    }
    return n.prototype._hasEncodeRule = function(t) {
      var e = this.getEncode();
      return e && e.get(t) != null;
    }, n.prototype.getInitialData = function(t, e) {
      var r, i = e.getComponent("xAxis", this.get("xAxisIndex")), a = e.getComponent("yAxis", this.get("yAxisIndex")), s = i.get("type"), o = a.get("type"), l;
      s === "category" ? (t.layout = "horizontal", r = i.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : o === "category" ? (t.layout = "vertical", r = a.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : t.layout = t.layout || "horizontal";
      var u = [
        "x",
        "y"
      ], c = t.layout === "horizontal" ? 0 : 1, h = this._baseAxisDim = u[c], f = u[1 - c], d = [
        i,
        a
      ], p = d[c].get("type"), g = d[1 - c].get("type"), v = t.data;
      if (v && l) {
        var m = [];
        P(v, function(b, _) {
          var w;
          ct(b) ? (w = b.slice(), b.unshift(_)) : ct(b.value) ? (w = rt({}, b), w.value = w.value.slice(), b.value.unshift(_)) : w = b, m.push(w);
        }), t.data = m;
      }
      var y = this.defaultValueDimensions, x = [
        {
          name: h,
          type: ab(p),
          ordinalMeta: r,
          otherDims: {
            tooltip: false,
            itemName: 0
          },
          dimsDef: [
            "base"
          ]
        },
        {
          name: f,
          type: ab(g),
          dimsDef: y.slice()
        }
      ];
      return Md(this, {
        coordDimensions: x,
        dimensionsCount: y.length + 1,
        encodeDefaulter: qt(y5, x, this)
      });
    }, n.prototype.getBaseAxis = function() {
      var t = this._baseAxisDim;
      return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
    }, n;
  }(), G8 = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.defaultValueDimensions = [
        {
          name: "min",
          defaultTooltip: true
        },
        {
          name: "Q1",
          defaultTooltip: true
        },
        {
          name: "median",
          defaultTooltip: true
        },
        {
          name: "Q3",
          defaultTooltip: true
        },
        {
          name: "max",
          defaultTooltip: true
        }
      ], e.visualDrawType = "stroke", e;
    }
    return t.type = "series.boxplot", t.dependencies = [
      "xAxis",
      "yAxis",
      "grid"
    ], t.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      boxWidth: [
        7,
        50
      ],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: true,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, t;
  }(an);
  zn(G8, V8, true);
  var Ngt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = e.getData(), s = this.group, o = this._data;
      this._data || s.removeAll();
      var l = e.get("layout") === "horizontal" ? 1 : 0;
      a.diff(o).add(function(u) {
        if (a.hasValue(u)) {
          var c = a.getItemLayout(u), h = jF(c, a, u, l, true);
          a.setItemGraphicEl(u, h), s.add(h);
        }
      }).update(function(u, c) {
        var h = o.getItemGraphicEl(c);
        if (!a.hasValue(u)) {
          s.remove(h);
          return;
        }
        var f = a.getItemLayout(u);
        h ? (os(h), W8(f, h, a, u)) : h = jF(f, a, u, l), s.add(h), a.setItemGraphicEl(u, h);
      }).remove(function(u) {
        var c = o.getItemGraphicEl(u);
        c && s.remove(c);
      }).execute(), this._data = a;
    }, t.prototype.remove = function(e) {
      var r = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(a) {
        a && r.remove(a);
      });
    }, t.type = "boxplot", t;
  }(qe), Lgt = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), Pgt = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "boxplotBoxPath", r;
    }
    return t.prototype.getDefaultShape = function() {
      return new Lgt();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.points, a = 0;
      for (e.moveTo(i[a][0], i[a][1]), a++; a < 4; a++) e.lineTo(i[a][0], i[a][1]);
      for (e.closePath(); a < i.length; a++) e.moveTo(i[a][0], i[a][1]), a++, e.lineTo(i[a][0], i[a][1]);
    }, t;
  }(le);
  function jF(n, t, e, r, i) {
    var a = n.ends, s = new Pgt({
      shape: {
        points: i ? $gt(a, r, n) : a
      }
    });
    return W8(n, s, t, e, i), s;
  }
  function W8(n, t, e, r, i) {
    var a = e.hostModel, s = ph[i ? "initProps" : "updateProps"];
    s(t, {
      shape: {
        points: n.ends
      }
    }, a, r), t.useStyle(e.getItemVisual(r, "style")), t.style.strokeNoScale = true, t.z2 = 100;
    var o = e.getItemModel(r), l = o.getModel("emphasis");
    Ar(t, o), bn(t, l.get("focus"), l.get("blurScope"), l.get("disabled"));
  }
  function $gt(n, t, e) {
    return ht(n, function(r) {
      return r = r.slice(), r[t] = e.initBaseline, r;
    });
  }
  var bg = P;
  function Ogt(n) {
    var t = Fgt(n);
    bg(t, function(e) {
      var r = e.seriesModels;
      r.length && (Bgt(e), bg(r, function(i, a) {
        zgt(i, e.boxOffsetList[a], e.boxWidthList[a]);
      }));
    });
  }
  function Fgt(n) {
    var t = [], e = [];
    return n.eachSeriesByType("boxplot", function(r) {
      var i = r.getBaseAxis(), a = ne(e, i);
      a < 0 && (a = e.length, e[a] = i, t[a] = {
        axis: i,
        seriesModels: []
      }), t[a].seriesModels.push(r);
    }), t;
  }
  function Bgt(n) {
    var t = n.axis, e = n.seriesModels, r = e.length, i = n.boxWidthList = [], a = n.boxOffsetList = [], s = [], o;
    if (t.type === "category") o = t.getBandWidth();
    else {
      var l = 0;
      bg(e, function(p) {
        l = Math.max(l, p.getData().count());
      });
      var u = t.getExtent();
      o = Math.abs(u[1] - u[0]) / l;
    }
    bg(e, function(p) {
      var g = p.get("boxWidth");
      ct(g) || (g = [
        g,
        g
      ]), s.push([
        yt(g[0], o) || 0,
        yt(g[1], o) || 0
      ]);
    });
    var c = o * 0.8 - 2, h = c / r * 0.3, f = (c - h * (r - 1)) / r, d = f / 2 - c / 2;
    bg(e, function(p, g) {
      a.push(d), d += h + f, i.push(Math.min(Math.max(f, s[g][0]), s[g][1]));
    });
  }
  function zgt(n, t, e) {
    var r = n.coordinateSystem, i = n.getData(), a = e / 2, s = n.get("layout") === "horizontal" ? 0 : 1, o = 1 - s, l = [
      "x",
      "y"
    ], u = i.mapDimension(l[s]), c = i.mapDimensionsAll(l[o]);
    if (u == null || c.length < 5) return;
    for (var h = 0; h < i.count(); h++) {
      var f = i.get(u, h), d = x(f, c[2], h), p = x(f, c[0], h), g = x(f, c[1], h), v = x(f, c[3], h), m = x(f, c[4], h), y = [];
      b(y, g, false), b(y, v, true), y.push(p, g, m, v), _(y, p), _(y, m), _(y, d), i.setItemLayout(h, {
        initBaseline: d[o],
        ends: y
      });
    }
    function x(w, S, I) {
      var T = i.get(S, I), A = [];
      A[s] = w, A[o] = T;
      var C;
      return isNaN(w) || isNaN(T) ? C = [
        NaN,
        NaN
      ] : (C = r.dataToPoint(A), C[s] += t), C;
    }
    function b(w, S, I) {
      var T = S.slice(), A = S.slice();
      T[s] += a, A[s] -= a, I ? w.push(T, A) : w.push(A, T);
    }
    function _(w, S) {
      var I = S.slice(), T = S.slice();
      I[s] -= a, T[s] += a, w.push(I, T);
    }
  }
  function Vgt(n, t) {
    t = t || {};
    for (var e = [], r = [], i = t.boundIQR, a = i === "none" || i === 0, s = 0; s < n.length; s++) {
      var o = _a(n[s].slice()), l = oS(o, 0.25), u = oS(o, 0.5), c = oS(o, 0.75), h = o[0], f = o[o.length - 1], d = (i ?? 1.5) * (c - l), p = a ? h : Math.max(h, l - d), g = a ? f : Math.min(f, c + d), v = t.itemNameFormatter, m = Nt(v) ? v({
        value: s
      }) : wt(v) ? v.replace("{value}", s + "") : s + "";
      e.push([
        m,
        p,
        l,
        u,
        c,
        g
      ]);
      for (var y = 0; y < o.length; y++) {
        var x = o[y];
        if (x < p || x > g) {
          var b = [
            m,
            x
          ];
          r.push(b);
        }
      }
    }
    return {
      boxData: e,
      outliers: r
    };
  }
  var Ggt = {
    type: "echarts:boxplot",
    transform: function(t) {
      var e = t.upstream;
      if (e.sourceFormat !== Zr) {
        var r = "";
        Ne(r);
      }
      var i = Vgt(e.getRawData(), t.config);
      return [
        {
          dimensions: [
            "ItemName",
            "Low",
            "Q1",
            "Q2",
            "Q3",
            "High"
          ],
          data: i.boxData
        },
        {
          data: i.outliers
        }
      ];
    }
  };
  function Wgt(n) {
    n.registerSeriesModel(G8), n.registerChartView(Ngt), n.registerLayout(Ogt), n.registerTransform(Ggt);
  }
  var Ugt = [
    "itemStyle",
    "borderColor"
  ], Hgt = [
    "itemStyle",
    "borderColor0"
  ], Xgt = [
    "itemStyle",
    "borderColorDoji"
  ], Ygt = [
    "itemStyle",
    "color"
  ], qgt = [
    "itemStyle",
    "color0"
  ];
  function lE(n, t) {
    return t.get(n > 0 ? Ygt : qgt);
  }
  function uE(n, t) {
    return t.get(n === 0 ? Xgt : n > 0 ? Ugt : Hgt);
  }
  var jgt = {
    seriesType: "candlestick",
    plan: Ad(),
    performRawSeries: true,
    reset: function(n, t) {
      if (!t.isSeriesFiltered(n)) {
        var e = n.pipelineContext.large;
        return !e && {
          progress: function(r, i) {
            for (var a; (a = r.next()) != null; ) {
              var s = i.getItemModel(a), o = i.getItemLayout(a).sign, l = s.getItemStyle();
              l.fill = lE(o, s), l.stroke = uE(o, s) || l.fill;
              var u = i.ensureUniqueItemVisual(a, "style");
              rt(u, l);
            }
          }
        };
      }
    }
  }, Kgt = [
    "color",
    "borderColor"
  ], Zgt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(e), this._isLargeDraw ? this._renderLarge(e) : this._renderNormal(e);
    }, t.prototype.incrementalPrepareRender = function(e, r, i) {
      this._clear(), this._updateDrawMode(e);
    }, t.prototype.incrementalRender = function(e, r, i, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(e, r) : this._incrementalRenderNormal(e, r);
    }, t.prototype.eachRendered = function(e) {
      su(this._progressiveEls || this.group, e);
    }, t.prototype._updateDrawMode = function(e) {
      var r = e.pipelineContext.large;
      (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear());
    }, t.prototype._renderNormal = function(e) {
      var r = e.getData(), i = this._data, a = this.group, s = r.getLayout("isSimpleBox"), o = e.get("clip", true), l = e.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), r.diff(i).add(function(c) {
        if (r.hasValue(c)) {
          var h = r.getItemLayout(c);
          if (o && KF(u, h)) return;
          var f = NC(h, c, true);
          dn(f, {
            shape: {
              points: h.ends
            }
          }, e, c), LC(f, r, c, s), a.add(f), r.setItemGraphicEl(c, f);
        }
      }).update(function(c, h) {
        var f = i.getItemGraphicEl(h);
        if (!r.hasValue(c)) {
          a.remove(f);
          return;
        }
        var d = r.getItemLayout(c);
        if (o && KF(u, d)) {
          a.remove(f);
          return;
        }
        f ? (Ie(f, {
          shape: {
            points: d.ends
          }
        }, e, c), os(f)) : f = NC(d), LC(f, r, c, s), a.add(f), r.setItemGraphicEl(c, f);
      }).remove(function(c) {
        var h = i.getItemGraphicEl(c);
        h && a.remove(h);
      }).execute(), this._data = r;
    }, t.prototype._renderLarge = function(e) {
      this._clear(), ZF(e, this.group);
      var r = e.get("clip", true) ? Hv(e.coordinateSystem, false, e) : null;
      r ? this.group.setClipPath(r) : this.group.removeClipPath();
    }, t.prototype._incrementalRenderNormal = function(e, r) {
      for (var i = r.getData(), a = i.getLayout("isSimpleBox"), s; (s = e.next()) != null; ) {
        var o = i.getItemLayout(s), l = NC(o);
        LC(l, i, s, a), l.incremental = true, this.group.add(l), this._progressiveEls.push(l);
      }
    }, t.prototype._incrementalRenderLarge = function(e, r) {
      ZF(r, this.group, this._progressiveEls, true);
    }, t.prototype.remove = function(e) {
      this._clear();
    }, t.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "candlestick", t;
  }(qe), Jgt = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), Qgt = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "normalCandlestickBox", r;
    }
    return t.prototype.getDefaultShape = function() {
      return new Jgt();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.points;
      this.__simpleBox ? (e.moveTo(i[4][0], i[4][1]), e.lineTo(i[6][0], i[6][1])) : (e.moveTo(i[0][0], i[0][1]), e.lineTo(i[1][0], i[1][1]), e.lineTo(i[2][0], i[2][1]), e.lineTo(i[3][0], i[3][1]), e.closePath(), e.moveTo(i[4][0], i[4][1]), e.lineTo(i[5][0], i[5][1]), e.moveTo(i[6][0], i[6][1]), e.lineTo(i[7][0], i[7][1]));
    }, t;
  }(le);
  function NC(n, t, e) {
    var r = n.ends;
    return new Qgt({
      shape: {
        points: e ? tvt(r, n) : r
      },
      z2: 100
    });
  }
  function KF(n, t) {
    for (var e = true, r = 0; r < t.ends.length; r++) if (n.contain(t.ends[r][0], t.ends[r][1])) {
      e = false;
      break;
    }
    return e;
  }
  function LC(n, t, e, r) {
    var i = t.getItemModel(e);
    n.useStyle(t.getItemVisual(e, "style")), n.style.strokeNoScale = true, n.__simpleBox = r, Ar(n, i);
    var a = t.getItemLayout(e).sign;
    P(n.states, function(o, l) {
      var u = i.getModel(l), c = lE(a, u), h = uE(a, u) || c, f = o.style || (o.style = {});
      c && (f.fill = c), h && (f.stroke = h);
    });
    var s = i.getModel("emphasis");
    bn(n, s.get("focus"), s.get("blurScope"), s.get("disabled"));
  }
  function tvt(n, t) {
    return ht(n, function(e) {
      return e = e.slice(), e[1] = t.initBaseline, e;
    });
  }
  var evt = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), PC = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r.type = "largeCandlestickBox", r;
    }
    return t.prototype.getDefaultShape = function() {
      return new evt();
    }, t.prototype.buildPath = function(e, r) {
      for (var i = r.points, a = 0; a < i.length; ) if (this.__sign === i[a++]) {
        var s = i[a++];
        e.moveTo(s, i[a++]), e.lineTo(s, i[a++]);
      } else a += 3;
    }, t;
  }(le);
  function ZF(n, t, e, r) {
    var i = n.getData(), a = i.getLayout("largePoints"), s = new PC({
      shape: {
        points: a
      },
      __sign: 1,
      ignoreCoarsePointer: true
    });
    t.add(s);
    var o = new PC({
      shape: {
        points: a
      },
      __sign: -1,
      ignoreCoarsePointer: true
    });
    t.add(o);
    var l = new PC({
      shape: {
        points: a
      },
      __sign: 0,
      ignoreCoarsePointer: true
    });
    t.add(l), $C(1, s, n), $C(-1, o, n), $C(0, l, n), r && (s.incremental = true, o.incremental = true), e && e.push(s, o);
  }
  function $C(n, t, e, r) {
    var i = uE(n, e) || lE(n, e), a = e.getModel("itemStyle").getItemStyle(Kgt);
    t.useStyle(a), t.style.fill = null, t.style.stroke = i;
  }
  var U8 = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.defaultValueDimensions = [
        {
          name: "open",
          defaultTooltip: true
        },
        {
          name: "close",
          defaultTooltip: true
        },
        {
          name: "lowest",
          defaultTooltip: true
        },
        {
          name: "highest",
          defaultTooltip: true
        }
      ], e;
    }
    return t.prototype.getShadowDim = function() {
      return "open";
    }, t.prototype.brushSelector = function(e, r, i) {
      var a = r.getItemLayout(e);
      return a && i.rect(a.brushRect);
    }, t.type = "series.candlestick", t.dependencies = [
      "xAxis",
      "yAxis",
      "grid"
    ], t.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      clip: true,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: true,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, t;
  }(an);
  zn(U8, V8, true);
  function nvt(n) {
    !n || !ct(n.series) || P(n.series, function(t) {
      Ft(t) && t.type === "k" && (t.type = "candlestick");
    });
  }
  var rvt = {
    seriesType: "candlestick",
    plan: Ad(),
    reset: function(n) {
      var t = n.coordinateSystem, e = n.getData(), r = ivt(n, e), i = 0, a = 1, s = [
        "x",
        "y"
      ], o = e.getDimensionIndex(e.mapDimension(s[i])), l = ht(e.mapDimensionsAll(s[a]), e.getDimensionIndex, e), u = l[0], c = l[1], h = l[2], f = l[3];
      if (e.setLayout({
        candleWidth: r,
        isSimpleBox: r <= 1.3
      }), o < 0 || l.length < 4) return;
      return {
        progress: n.pipelineContext.large ? p : d
      };
      function d(g, v) {
        for (var m, y = v.getStore(); (m = g.next()) != null; ) {
          var x = y.get(o, m), b = y.get(u, m), _ = y.get(c, m), w = y.get(h, m), S = y.get(f, m), I = Math.min(b, _), T = Math.max(b, _), A = N(I, x), C = N(T, x), D = N(w, x), E = N(S, x), M = [];
          R(M, C, 0), R(M, A, 1), M.push(O(E), O(C), O(D), O(A));
          var L = v.getItemModel(m), k = !!L.get([
            "itemStyle",
            "borderColorDoji"
          ]);
          v.setItemLayout(m, {
            sign: JF(y, m, b, _, c, k),
            initBaseline: b > _ ? C[a] : A[a],
            ends: M,
            brushRect: $(w, S, x)
          });
        }
        function N(F, z) {
          var V = [];
          return V[i] = z, V[a] = F, isNaN(z) || isNaN(F) ? [
            NaN,
            NaN
          ] : t.dataToPoint(V);
        }
        function R(F, z, V) {
          var U = z.slice(), X = z.slice();
          U[i] = hx(U[i] + r / 2, 1, false), X[i] = hx(X[i] - r / 2, 1, true), V ? F.push(U, X) : F.push(X, U);
        }
        function $(F, z, V) {
          var U = N(F, V), X = N(z, V);
          return U[i] -= r / 2, X[i] -= r / 2, {
            x: U[0],
            y: U[1],
            width: r,
            height: X[1] - U[1]
          };
        }
        function O(F) {
          return F[i] = hx(F[i], 1), F;
        }
      }
      function p(g, v) {
        for (var m = zs(g.count * 4), y = 0, x, b = [], _ = [], w, S = v.getStore(), I = !!n.get([
          "itemStyle",
          "borderColorDoji"
        ]); (w = g.next()) != null; ) {
          var T = S.get(o, w), A = S.get(u, w), C = S.get(c, w), D = S.get(h, w), E = S.get(f, w);
          if (isNaN(T) || isNaN(D) || isNaN(E)) {
            m[y++] = NaN, y += 3;
            continue;
          }
          m[y++] = JF(S, w, A, C, c, I), b[i] = T, b[a] = D, x = t.dataToPoint(b, null, _), m[y++] = x ? x[0] : NaN, m[y++] = x ? x[1] : NaN, b[a] = E, x = t.dataToPoint(b, null, _), m[y++] = x ? x[1] : NaN;
        }
        v.setLayout("largePoints", m);
      }
    }
  };
  function JF(n, t, e, r, i, a) {
    var s;
    return e > r ? s = -1 : e < r ? s = 1 : s = a ? 0 : t > 0 ? n.get(i, t - 1) <= r ? 1 : -1 : 1, s;
  }
  function ivt(n, t) {
    var e = n.getBaseAxis(), r, i = e.type === "category" ? e.getBandWidth() : (r = e.getExtent(), Math.abs(r[1] - r[0]) / t.count()), a = yt(Ht(n.get("barMaxWidth"), i), i), s = yt(Ht(n.get("barMinWidth"), 1), i), o = n.get("barWidth");
    return o != null ? yt(o, i) : Math.max(Math.min(i / 2, a), s);
  }
  function avt(n) {
    n.registerChartView(Zgt), n.registerSeriesModel(U8), n.registerPreprocessor(nvt), n.registerVisual(jgt), n.registerLayout(rvt);
  }
  function QF(n, t) {
    var e = t.rippleEffectColor || t.color;
    n.eachChild(function(r) {
      r.attr({
        z: t.z,
        zlevel: t.zlevel,
        style: {
          stroke: t.brushType === "stroke" ? e : null,
          fill: t.brushType === "fill" ? e : null
        }
      });
    });
  }
  var svt = function(n) {
    q(t, n);
    function t(e, r) {
      var i = n.call(this) || this, a = new Wv(e, r), s = new Vt();
      return i.add(a), i.add(s), i.updateData(e, r), i;
    }
    return t.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, t.prototype.startEffectAnimation = function(e) {
      for (var r = e.symbolType, i = e.color, a = e.rippleNumber, s = this.childAt(1), o = 0; o < a; o++) {
        var l = Fn(r, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: true
          },
          z2: 99,
          silent: true,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -o / a * e.period + e.effectOffset;
        l.animate("", true).when(e.period, {
          scaleX: e.rippleScale / 2,
          scaleY: e.rippleScale / 2
        }).delay(u).start(), l.animateStyle(true).when(e.period, {
          opacity: 0
        }).delay(u).start(), s.add(l);
      }
      QF(s, e);
    }, t.prototype.updateEffectAnimation = function(e) {
      for (var r = this._effectCfg, i = this.childAt(1), a = [
        "symbolType",
        "period",
        "rippleScale",
        "rippleNumber"
      ], s = 0; s < a.length; s++) {
        var o = a[s];
        if (r[o] !== e[o]) {
          this.stopEffectAnimation(), this.startEffectAnimation(e);
          return;
        }
      }
      QF(i, e);
    }, t.prototype.highlight = function() {
      Vo(this);
    }, t.prototype.downplay = function() {
      Go(this);
    }, t.prototype.getSymbolType = function() {
      var e = this.childAt(0);
      return e && e.getSymbolType();
    }, t.prototype.updateData = function(e, r) {
      var i = this, a = e.hostModel;
      this.childAt(0).updateData(e, r);
      var s = this.childAt(1), o = e.getItemModel(r), l = e.getItemVisual(r, "symbol"), u = Dd(e.getItemVisual(r, "symbolSize")), c = e.getItemVisual(r, "style"), h = c && c.fill, f = o.getModel("emphasis");
      s.setScale(u), s.traverse(function(v) {
        v.setStyle("fill", h);
      });
      var d = gh(e.getItemVisual(r, "symbolOffset"), u);
      d && (s.x = d[0], s.y = d[1]);
      var p = e.getItemVisual(r, "symbolRotate");
      s.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = a.get("showEffectOn"), g.rippleScale = o.get([
        "rippleEffect",
        "scale"
      ]), g.brushType = o.get([
        "rippleEffect",
        "brushType"
      ]), g.period = o.get([
        "rippleEffect",
        "period"
      ]) * 1e3, g.effectOffset = r / e.count(), g.z = a.getShallow("z") || 0, g.zlevel = a.getShallow("zlevel") || 0, g.symbolType = l, g.color = h, g.rippleEffectColor = o.get([
        "rippleEffect",
        "color"
      ]), g.rippleNumber = o.get([
        "rippleEffect",
        "number"
      ]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(v) {
        v === "emphasis" ? g.showEffectOn !== "render" && i.startEffectAnimation(g) : v === "normal" && g.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = g, bn(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
    }, t.prototype.fadeOut = function(e) {
      e && e();
    }, t;
  }(Vt), ovt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this._symbolDraw = new Uv(svt);
    }, t.prototype.render = function(e, r, i) {
      var a = e.getData(), s = this._symbolDraw;
      s.updateData(a, {
        clipShape: this._getClipShape(e)
      }), this.group.add(s.group);
    }, t.prototype._getClipShape = function(e) {
      var r = e.coordinateSystem, i = r && r.getArea && r.getArea();
      return e.get("clip", true) ? i : null;
    }, t.prototype.updateTransform = function(e, r, i) {
      var a = e.getData();
      this.group.dirty();
      var s = Xv("").reset(e, r, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, t.prototype._updateGroupTransform = function(e) {
      var r = e.coordinateSystem;
      r && r.getRoamTransform && (this.group.transform = ket(r.getRoamTransform()), this.group.decomposeTransform());
    }, t.prototype.remove = function(e, r) {
      this._symbolDraw && this._symbolDraw.remove(true);
    }, t.type = "effectScatter", t;
  }(qe), lvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = true, e;
    }
    return t.prototype.getInitialData = function(e, r) {
      return el(null, this, {
        useEncodeDefaulter: true
      });
    }, t.prototype.brushSelector = function(e, r, i) {
      return i.point(r.getItemLayout(e));
    }, t.type = "series.effectScatter", t.dependencies = [
      "grid",
      "polar"
    ], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      effectType: "ripple",
      progressive: 0,
      showEffectOn: "render",
      clip: true,
      rippleEffect: {
        period: 4,
        scale: 2.5,
        brushType: "fill",
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      symbolSize: 10
    }, t;
  }(an);
  function uvt(n) {
    n.registerChartView(ovt), n.registerSeriesModel(lvt), n.registerLayout(Xv("effectScatter"));
  }
  var H8 = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this) || this;
      return a.add(a.createLine(e, r, i)), a._updateEffectSymbol(e, r), a;
    }
    return t.prototype.createLine = function(e, r, i) {
      return new QD(e, r, i);
    }, t.prototype._updateEffectSymbol = function(e, r) {
      var i = e.getItemModel(r), a = i.getModel("effect"), s = a.get("symbolSize"), o = a.get("symbol");
      ct(s) || (s = [
        s,
        s
      ]);
      var l = e.getItemVisual(r, "style"), u = a.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== o && (this.remove(c), c = Fn(o, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = true, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(a.getItemStyle([
        "color"
      ])), c.scaleX = s[0], c.scaleY = s[1], c.setColor(u), this._symbolType = o, this._symbolScale = s, this._updateEffectAnimation(e, a, r));
    }, t.prototype._updateEffectAnimation = function(e, r, i) {
      var a = this.childAt(1);
      if (a) {
        var s = e.getItemLayout(i), o = r.get("period") * 1e3, l = r.get("loop"), u = r.get("roundTrip"), c = r.get("constantSpeed"), h = mr(r.get("delay"), function(d) {
          return d / e.count() * o / 3;
        });
        if (a.ignore = true, this._updateAnimationPoints(a, s), c > 0 && (o = this._getLineLength(a) / c * 1e3), o !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var f = void 0;
          Nt(h) ? f = h(i) : f = h, a.__t > 0 && (f = -o * a.__t), this._animateSymbol(a, o, f, l, u);
        }
        this._period = o, this._loop = l, this._roundTrip = u;
      }
    }, t.prototype._animateSymbol = function(e, r, i, a, s) {
      if (r > 0) {
        e.__t = 0;
        var o = this, l = e.animate("", a).when(s ? r * 2 : r, {
          __t: s ? 2 : 1
        }).delay(i).during(function() {
          o._updateSymbolPosition(e);
        });
        a || l.done(function() {
          o.remove(e);
        }), l.start();
      }
    }, t.prototype._getLineLength = function(e) {
      return Sl(e.__p1, e.__cp1) + Sl(e.__cp1, e.__p2);
    }, t.prototype._updateAnimationPoints = function(e, r) {
      e.__p1 = r[0], e.__p2 = r[1], e.__cp1 = r[2] || [
        (r[0][0] + r[1][0]) / 2,
        (r[0][1] + r[1][1]) / 2
      ];
    }, t.prototype.updateData = function(e, r, i) {
      this.childAt(0).updateData(e, r, i), this._updateEffectSymbol(e, r);
    }, t.prototype._updateSymbolPosition = function(e) {
      var r = e.__p1, i = e.__p2, a = e.__cp1, s = e.__t < 1 ? e.__t : 2 - e.__t, o = [
        e.x,
        e.y
      ], l = o.slice(), u = pr, c = AI;
      o[0] = u(r[0], a[0], i[0], s), o[1] = u(r[1], a[1], i[1], s);
      var h = e.__t < 1 ? c(r[0], a[0], i[0], s) : c(i[0], a[0], r[0], 1 - s), f = e.__t < 1 ? c(r[1], a[1], i[1], s) : c(i[1], a[1], r[1], 1 - s);
      e.rotation = -Math.atan2(f, h) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (e.__lastT !== void 0 && e.__lastT < e.__t ? (e.scaleY = Sl(l, o) * 1.05, s === 1 && (o[0] = l[0] + (o[0] - l[0]) / 2, o[1] = l[1] + (o[1] - l[1]) / 2)) : e.__lastT === 1 ? e.scaleY = 2 * Sl(r, o) : e.scaleY = this._symbolScale[1]), e.__lastT = e.__t, e.ignore = false, e.x = o[0], e.y = o[1];
    }, t.prototype.updateLayout = function(e, r) {
      this.childAt(0).updateLayout(e, r);
      var i = e.getItemModel(r).getModel("effect");
      this._updateEffectAnimation(e, i, r);
    }, t;
  }(Vt), X8 = function(n) {
    q(t, n);
    function t(e, r, i) {
      var a = n.call(this) || this;
      return a._createPolyline(e, r, i), a;
    }
    return t.prototype._createPolyline = function(e, r, i) {
      var a = e.getItemLayout(r), s = new _i({
        shape: {
          points: a
        }
      });
      this.add(s), this._updateCommonStl(e, r, i);
    }, t.prototype.updateData = function(e, r, i) {
      var a = e.hostModel, s = this.childAt(0), o = {
        shape: {
          points: e.getItemLayout(r)
        }
      };
      Ie(s, o, a, r), this._updateCommonStl(e, r, i);
    }, t.prototype._updateCommonStl = function(e, r, i) {
      var a = this.childAt(0), s = e.getItemModel(r), o = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || e.hasItemOption) {
        var h = s.getModel("emphasis");
        o = h.getModel("lineStyle").getLineStyle(), c = h.get("disabled"), l = h.get("focus"), u = h.get("blurScope");
      }
      a.useStyle(e.getItemVisual(r, "style")), a.style.fill = null, a.style.strokeNoScale = true;
      var f = a.ensureState("emphasis");
      f.style = o, bn(this, l, u, c);
    }, t.prototype.updateLayout = function(e, r) {
      var i = this.childAt(0);
      i.setShape("points", e.getItemLayout(r));
    }, t;
  }(Vt), cvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e._lastFrame = 0, e._lastFramePercent = 0, e;
    }
    return t.prototype.createLine = function(e, r, i) {
      return new X8(e, r, i);
    }, t.prototype._updateAnimationPoints = function(e, r) {
      this._points = r;
      for (var i = [
        0
      ], a = 0, s = 1; s < r.length; s++) {
        var o = r[s - 1], l = r[s];
        a += Sl(o, l), i.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var s = 0; s < i.length; s++) i[s] /= a;
      this._offsets = i, this._length = a;
    }, t.prototype._getLineLength = function() {
      return this._length;
    }, t.prototype._updateSymbolPosition = function(e) {
      var r = e.__t < 1 ? e.__t : 2 - e.__t, i = this._points, a = this._offsets, s = i.length;
      if (a) {
        var o = this._lastFrame, l;
        if (r < this._lastFramePercent) {
          var u = Math.min(o + 1, s - 1);
          for (l = u; l >= 0 && !(a[l] <= r); l--) ;
          l = Math.min(l, s - 2);
        } else {
          for (l = o; l < s && !(a[l] > r); l++) ;
          l = Math.min(l - 1, s - 2);
        }
        var c = (r - a[l]) / (a[l + 1] - a[l]), h = i[l], f = i[l + 1];
        e.x = h[0] * (1 - c) + c * f[0], e.y = h[1] * (1 - c) + c * f[1];
        var d = e.__t < 1 ? f[0] - h[0] : h[0] - f[0], p = e.__t < 1 ? f[1] - h[1] : h[1] - f[1];
        e.rotation = -Math.atan2(p, d) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = r, e.ignore = false;
      }
    }, t;
  }(H8), hvt = /* @__PURE__ */ function() {
    function n() {
      this.polyline = false, this.curveness = 0, this.segs = [];
    }
    return n;
  }(), fvt = function(n) {
    q(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return r._off = 0, r.hoverDataIdx = -1, r;
    }
    return t.prototype.reset = function() {
      this.notClear = false, this._off = 0;
    }, t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new hvt();
    }, t.prototype.buildPath = function(e, r) {
      var i = r.segs, a = r.curveness, s;
      if (r.polyline) for (s = this._off; s < i.length; ) {
        var o = i[s++];
        if (o > 0) {
          e.moveTo(i[s++], i[s++]);
          for (var l = 1; l < o; l++) e.lineTo(i[s++], i[s++]);
        }
      }
      else for (s = this._off; s < i.length; ) {
        var u = i[s++], c = i[s++], h = i[s++], f = i[s++];
        if (e.moveTo(u, c), a > 0) {
          var d = (u + h) / 2 - (c - f) * a, p = (c + f) / 2 - (h - u) * a;
          e.quadraticCurveTo(d, p, h, f);
        } else e.lineTo(h, f);
      }
      this.incremental && (this._off = s, this.notClear = true);
    }, t.prototype.findDataIndex = function(e, r) {
      var i = this.shape, a = i.segs, s = i.curveness, o = this.style.lineWidth;
      if (i.polyline) for (var l = 0, u = 0; u < a.length; ) {
        var c = a[u++];
        if (c > 0) for (var h = a[u++], f = a[u++], d = 1; d < c; d++) {
          var p = a[u++], g = a[u++];
          if (bl(h, f, p, g, o, e, r)) return l;
        }
        l++;
      }
      else for (var l = 0, u = 0; u < a.length; ) {
        var h = a[u++], f = a[u++], p = a[u++], g = a[u++];
        if (s > 0) {
          var v = (h + p) / 2 - (f - g) * s, m = (f + g) / 2 - (p - h) * s;
          if (yU(h, f, v, m, p, g, o, e, r)) return l;
        } else if (bl(h, f, p, g, o, e, r)) return l;
        l++;
      }
      return -1;
    }, t.prototype.contain = function(e, r) {
      var i = this.transformCoordToLocal(e, r), a = this.getBoundingRect();
      if (e = i[0], r = i[1], a.contain(e, r)) {
        var s = this.hoverDataIdx = this.findDataIndex(e, r);
        return s >= 0;
      }
      return this.hoverDataIdx = -1, false;
    }, t.prototype.getBoundingRect = function() {
      var e = this._rect;
      if (!e) {
        for (var r = this.shape, i = r.segs, a = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], h = i[u++];
          a = Math.min(c, a), o = Math.max(c, o), s = Math.min(h, s), l = Math.max(h, l);
        }
        e = this._rect = new te(a, s, o, l);
      }
      return e;
    }, t;
  }(le), dvt = function() {
    function n() {
      this.group = new Vt();
    }
    return n.prototype.updateData = function(t) {
      this._clear();
      var e = this._create();
      e.setShape({
        segs: t.getLayout("linesPoints")
      }), this._setCommon(e, t);
    }, n.prototype.incrementalPrepareUpdate = function(t) {
      this.group.removeAll(), this._clear();
    }, n.prototype.incrementalUpdate = function(t, e) {
      var r = this._newAdded[0], i = e.getLayout("linesPoints"), a = r && r.shape.segs;
      if (a && a.length < 2e4) {
        var s = a.length, o = new Float32Array(s + i.length);
        o.set(a), o.set(i, s), r.setShape({
          segs: o
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = true, l.setShape({
          segs: i
        }), this._setCommon(l, e), l.__startIndex = t.start;
      }
    }, n.prototype.remove = function() {
      this._clear();
    }, n.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, n.prototype._create = function() {
      var t = new fvt({
        cursor: "default",
        ignoreCoarsePointer: true
      });
      return this._newAdded.push(t), this.group.add(t), t;
    }, n.prototype._setCommon = function(t, e, r) {
      var i = e.hostModel;
      t.setShape({
        polyline: i.get("polyline"),
        curveness: i.get([
          "lineStyle",
          "curveness"
        ])
      }), t.useStyle(i.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = true;
      var a = e.getVisual("style");
      a && a.stroke && t.setStyle("stroke", a.stroke), t.setStyle("fill", null);
      var s = Ut(t);
      s.seriesIndex = i.seriesIndex, t.on("mousemove", function(o) {
        s.dataIndex = null;
        var l = t.hoverDataIdx;
        l > 0 && (s.dataIndex = l + t.__startIndex);
      });
    }, n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, n;
  }(), Y8 = {
    seriesType: "lines",
    plan: Ad(),
    reset: function(n) {
      var t = n.coordinateSystem;
      if (t) {
        var e = n.get("polyline"), r = n.pipelineContext.large;
        return {
          progress: function(i, a) {
            var s = [];
            if (r) {
              var o = void 0, l = i.end - i.start;
              if (e) {
                for (var u = 0, c = i.start; c < i.end; c++) u += n.getLineCoordsCount(c);
                o = new Float32Array(l + u * 2);
              } else o = new Float32Array(l * 4);
              for (var h = 0, f = [], c = i.start; c < i.end; c++) {
                var d = n.getLineCoords(c, s);
                e && (o[h++] = d);
                for (var p = 0; p < d; p++) f = t.dataToPoint(s[p], false, f), o[h++] = f[0], o[h++] = f[1];
              }
              a.setLayout("linesPoints", o);
            } else for (var c = i.start; c < i.end; c++) {
              var g = a.getItemModel(c), d = n.getLineCoords(c, s), v = [];
              if (e) for (var m = 0; m < d; m++) v.push(t.dataToPoint(s[m]));
              else {
                v[0] = t.dataToPoint(s[0]), v[1] = t.dataToPoint(s[1]);
                var y = g.get([
                  "lineStyle",
                  "curveness"
                ]);
                +y && (v[2] = [
                  (v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * y,
                  (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * y
                ]);
              }
              a.setItemLayout(c, v);
            }
          }
        };
      }
    }
  }, pvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = e.getData(), s = this._updateLineDraw(a, e), o = e.get("zlevel"), l = e.get([
        "effect",
        "trailLength"
      ]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(o).clear(true), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: false
      }), this._showEffect(e) && l > 0 && (c || u.configLayer(o, {
        motionBlur: true,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), s.updateData(a);
      var h = e.get("clip", true) && Hv(e.coordinateSystem, false, e);
      h ? this.group.setClipPath(h) : this.group.removeClipPath(), this._lastZlevel = o, this._finished = true;
    }, t.prototype.incrementalPrepareRender = function(e, r, i) {
      var a = e.getData(), s = this._updateLineDraw(a, e);
      s.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = false;
    }, t.prototype.incrementalRender = function(e, r, i) {
      this._lineDraw.incrementalUpdate(e, r.getData()), this._finished = e.end === r.getData().count();
    }, t.prototype.eachRendered = function(e) {
      this._lineDraw && this._lineDraw.eachRendered(e);
    }, t.prototype.updateTransform = function(e, r, i) {
      var a = e.getData(), s = e.pipelineContext;
      if (!this._finished || s.large || s.progressiveRender) return {
        update: true
      };
      var o = Y8.reset(e, r, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, t.prototype._updateLineDraw = function(e, r) {
      var i = this._lineDraw, a = this._showEffect(r), s = !!r.get("polyline"), o = r.pipelineContext, l = o.large;
      return (!i || a !== this._hasEffet || s !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new dvt() : new tE(s ? a ? cvt : X8 : a ? H8 : QD), this._hasEffet = a, this._isPolyline = s, this._isLargeDraw = l), this.group.add(i.group), i;
    }, t.prototype._showEffect = function(e) {
      return !!e.get([
        "effect",
        "show"
      ]);
    }, t.prototype._clearLayer = function(e) {
      var r = e.getZr(), i = r.painter.getType() === "svg";
      !i && this._lastZlevel != null && r.painter.getLayer(this._lastZlevel).clear(true);
    }, t.prototype.remove = function(e, r) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(r);
    }, t.prototype.dispose = function(e, r) {
      this.remove(e, r);
    }, t.type = "lines", t;
  }(qe), gvt = typeof Uint32Array > "u" ? Array : Uint32Array, vvt = typeof Float64Array > "u" ? Array : Float64Array;
  function tB(n) {
    var t = n.data;
    t && t[0] && t[0][0] && t[0][0].coord && (n.data = ht(t, function(e) {
      var r = [
        e[0].coord,
        e[1].coord
      ], i = {
        coords: r
      };
      return e[0].name && (i.fromName = e[0].name), e[1].name && (i.toName = e[1].name), Nk([
        i,
        e[0],
        e[1]
      ]);
    }));
  }
  var mvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
    }
    return t.prototype.init = function(e) {
      e.data = e.data || [], tB(e);
      var r = this._processFlatCoordsArray(e.data);
      this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (e.data = new Float32Array(r.count)), n.prototype.init.apply(this, arguments);
    }, t.prototype.mergeOption = function(e) {
      if (tB(e), e.data) {
        var r = this._processFlatCoordsArray(e.data);
        this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (e.data = new Float32Array(r.count));
      }
      n.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.appendData = function(e) {
      var r = this._processFlatCoordsArray(e.data);
      r.flatCoords && (this._flatCoords ? (this._flatCoords = Mg(this._flatCoords, r.flatCoords), this._flatCoordsOffset = Mg(this._flatCoordsOffset, r.flatCoordsOffset)) : (this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset), e.data = new Float32Array(r.count)), this.getRawData().appendData(e.data);
    }, t.prototype._getCoordsFromItemModel = function(e) {
      var r = this.getData().getItemModel(e), i = r.option instanceof Array ? r.option : r.getShallow("coords");
      return i;
    }, t.prototype.getLineCoordsCount = function(e) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[e * 2 + 1] : this._getCoordsFromItemModel(e).length;
    }, t.prototype.getLineCoords = function(e, r) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[e * 2], a = this._flatCoordsOffset[e * 2 + 1], s = 0; s < a; s++) r[s] = r[s] || [], r[s][0] = this._flatCoords[i + s * 2], r[s][1] = this._flatCoords[i + s * 2 + 1];
        return a;
      } else {
        for (var o = this._getCoordsFromItemModel(e), s = 0; s < o.length; s++) r[s] = r[s] || [], r[s][0] = o[s][0], r[s][1] = o[s][1];
        return o.length;
      }
    }, t.prototype._processFlatCoordsArray = function(e) {
      var r = 0;
      if (this._flatCoords && (r = this._flatCoords.length), _e(e[0])) {
        for (var i = e.length, a = new gvt(i), s = new vvt(i), o = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var h = e[c++];
          a[l++] = o + r, a[l++] = h;
          for (var f = 0; f < h; f++) {
            var d = e[c++], p = e[c++];
            s[o++] = d, s[o++] = p;
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: s,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: e.length
      };
    }, t.prototype.getInitialData = function(e, r) {
      var i = new fi([
        "value"
      ], this);
      return i.hasItemOption = false, i.initData(e.data, [], function(a, s, o, l) {
        if (a instanceof Array) return NaN;
        i.hasItemOption = true;
        var u = a.value;
        if (u != null) return u instanceof Array ? u[l] : u;
      }), i;
    }, t.prototype.formatTooltip = function(e, r, i) {
      var a = this.getData(), s = a.getItemModel(e), o = s.get("name");
      if (o) return o;
      var l = s.get("fromName"), u = s.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), cr("nameValue", {
        name: c.join(" > ")
      });
    }, t.prototype.preventIncremental = function() {
      return !!this.get([
        "effect",
        "show"
      ]);
    }, t.prototype.getProgressive = function() {
      var e = this.option.progressive;
      return e ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.option.progressiveThreshold;
      return e ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, t.prototype.getZLevelKey = function() {
      var e = this.getModel("effect"), r = e.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : e.get("show") && r > 0 ? r + "" : "";
    }, t.type = "series.lines", t.dependencies = [
      "grid",
      "polar",
      "geo",
      "calendar"
    ], t.defaultOption = {
      coordinateSystem: "geo",
      z: 2,
      legendHoverLink: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: [
        "none",
        "none"
      ],
      symbolSize: [
        10,
        10
      ],
      geoIndex: 0,
      effect: {
        show: false,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: true,
        trailLength: 0.2
      },
      large: false,
      largeThreshold: 2e3,
      polyline: false,
      clip: true,
      label: {
        show: false,
        position: "end"
      },
      lineStyle: {
        opacity: 0.5
      }
    }, t;
  }(an);
  function h0(n) {
    return n instanceof Array || (n = [
      n,
      n
    ]), n;
  }
  var yvt = {
    seriesType: "lines",
    reset: function(n) {
      var t = h0(n.get("symbol")), e = h0(n.get("symbolSize")), r = n.getData();
      r.setVisual("fromSymbol", t && t[0]), r.setVisual("toSymbol", t && t[1]), r.setVisual("fromSymbolSize", e && e[0]), r.setVisual("toSymbolSize", e && e[1]);
      function i(a, s) {
        var o = a.getItemModel(s), l = h0(o.getShallow("symbol", true)), u = h0(o.getShallow("symbolSize", true));
        l[0] && a.setItemVisual(s, "fromSymbol", l[0]), l[1] && a.setItemVisual(s, "toSymbol", l[1]), u[0] && a.setItemVisual(s, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(s, "toSymbolSize", u[1]);
      }
      return {
        dataEach: r.hasItemOption ? i : null
      };
    }
  };
  function xvt(n) {
    n.registerChartView(pvt), n.registerSeriesModel(mvt), n.registerLayout(Y8), n.registerVisual(yvt);
  }
  var bvt = 256, _vt = function() {
    function n() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var t = Xl.createCanvas();
      this.canvas = t;
    }
    return n.prototype.update = function(t, e, r, i, a, s) {
      var o = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), c = this.pointSize + this.blurSize, h = this.canvas, f = h.getContext("2d"), d = t.length;
      h.width = e, h.height = r;
      for (var p = 0; p < d; ++p) {
        var g = t[p], v = g[0], m = g[1], y = g[2], x = i(y);
        f.globalAlpha = x, f.drawImage(o, v - c, m - c);
      }
      if (!h.width || !h.height) return h;
      for (var b = f.getImageData(0, 0, h.width, h.height), _ = b.data, w = 0, S = _.length, I = this.minOpacity, T = this.maxOpacity, A = T - I; w < S; ) {
        var x = _[w + 3] / 256, C = Math.floor(x * (bvt - 1)) * 4;
        if (x > 0) {
          var D = s(x) ? l : u;
          x > 0 && (x = x * A + I), _[w++] = D[C], _[w++] = D[C + 1], _[w++] = D[C + 2], _[w++] = D[C + 3] * x * 256;
        } else w += 4;
      }
      return f.putImageData(b, 0, 0), h;
    }, n.prototype._getBrush = function() {
      var t = this._brushCanvas || (this._brushCanvas = Xl.createCanvas()), e = this.pointSize + this.blurSize, r = e * 2;
      t.width = r, t.height = r;
      var i = t.getContext("2d");
      return i.clearRect(0, 0, r, r), i.shadowOffsetX = r, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-e, e, this.pointSize, 0, Math.PI * 2, true), i.closePath(), i.fill(), t;
    }, n.prototype._getGradient = function(t, e) {
      for (var r = this._gradientPixels, i = r[e] || (r[e] = new Uint8ClampedArray(256 * 4)), a = [
        0,
        0,
        0,
        0
      ], s = 0, o = 0; o < 256; o++) t[e](o / 255, true, a), i[s++] = a[0], i[s++] = a[1], i[s++] = a[2], i[s++] = a[3];
      return i;
    }, n;
  }();
  function wvt(n, t, e) {
    var r = n[1] - n[0];
    t = ht(t, function(s) {
      return {
        interval: [
          (s.interval[0] - n[0]) / r,
          (s.interval[1] - n[0]) / r
        ]
      };
    });
    var i = t.length, a = 0;
    return function(s) {
      var o;
      for (o = a; o < i; o++) {
        var l = t[o].interval;
        if (l[0] <= s && s <= l[1]) {
          a = o;
          break;
        }
      }
      if (o === i) for (o = a - 1; o >= 0; o--) {
        var l = t[o].interval;
        if (l[0] <= s && s <= l[1]) {
          a = o;
          break;
        }
      }
      return o >= 0 && o < i && e[o];
    };
  }
  function Svt(n, t) {
    var e = n[1] - n[0];
    return t = [
      (t[0] - n[0]) / e,
      (t[1] - n[0]) / e
    ], function(r) {
      return r >= t[0] && r <= t[1];
    };
  }
  function eB(n) {
    var t = n.dimensions;
    return t[0] === "lng" && t[1] === "lat";
  }
  var Cvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a;
      r.eachComponent("visualMap", function(o) {
        o.eachTargetSeries(function(l) {
          l === e && (a = o);
        });
      }), this._progressiveEls = null, this.group.removeAll();
      var s = e.coordinateSystem;
      s.type === "cartesian2d" || s.type === "calendar" ? this._renderOnCartesianAndCalendar(e, i, 0, e.getData().count()) : eB(s) && this._renderOnGeo(s, e, a, i);
    }, t.prototype.incrementalPrepareRender = function(e, r, i) {
      this.group.removeAll();
    }, t.prototype.incrementalRender = function(e, r, i, a) {
      var s = r.coordinateSystem;
      s && (eB(s) ? this.render(r, i, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(r, a, e.start, e.end, true)));
    }, t.prototype.eachRendered = function(e) {
      su(this._progressiveEls || this.group, e);
    }, t.prototype._renderOnCartesianAndCalendar = function(e, r, i, a, s) {
      var o = e.coordinateSystem, l = mh(o, "cartesian2d"), u, c, h, f;
      if (l) {
        var d = o.getAxis("x"), p = o.getAxis("y");
        u = d.getBandWidth() + 0.5, c = p.getBandWidth() + 0.5, h = d.scale.getExtent(), f = p.scale.getExtent();
      }
      for (var g = this.group, v = e.getData(), m = e.getModel([
        "emphasis",
        "itemStyle"
      ]).getItemStyle(), y = e.getModel([
        "blur",
        "itemStyle"
      ]).getItemStyle(), x = e.getModel([
        "select",
        "itemStyle"
      ]).getItemStyle(), b = e.get([
        "itemStyle",
        "borderRadius"
      ]), _ = ur(e), w = e.getModel("emphasis"), S = w.get("focus"), I = w.get("blurScope"), T = w.get("disabled"), A = l ? [
        v.mapDimension("x"),
        v.mapDimension("y"),
        v.mapDimension("value")
      ] : [
        v.mapDimension("time"),
        v.mapDimension("value")
      ], C = i; C < a; C++) {
        var D = void 0, E = v.getItemVisual(C, "style");
        if (l) {
          var M = v.get(A[0], C), L = v.get(A[1], C);
          if (isNaN(v.get(A[2], C)) || isNaN(M) || isNaN(L) || M < h[0] || M > h[1] || L < f[0] || L > f[1]) continue;
          var k = o.dataToPoint([
            M,
            L
          ]);
          D = new ye({
            shape: {
              x: k[0] - u / 2,
              y: k[1] - c / 2,
              width: u,
              height: c
            },
            style: E
          });
        } else {
          if (isNaN(v.get(A[1], C))) continue;
          D = new ye({
            z2: 1,
            shape: o.dataToRect([
              v.get(A[0], C)
            ]).contentShape,
            style: E
          });
        }
        if (v.hasItemOption) {
          var N = v.getItemModel(C), R = N.getModel("emphasis");
          m = R.getModel("itemStyle").getItemStyle(), y = N.getModel([
            "blur",
            "itemStyle"
          ]).getItemStyle(), x = N.getModel([
            "select",
            "itemStyle"
          ]).getItemStyle(), b = N.get([
            "itemStyle",
            "borderRadius"
          ]), S = R.get("focus"), I = R.get("blurScope"), T = R.get("disabled"), _ = ur(N);
        }
        D.shape.r = b;
        var $ = e.getRawValue(C), O = "-";
        $ && $[2] != null && (O = $[2] + ""), kr(D, _, {
          labelFetcher: e,
          labelDataIndex: C,
          defaultOpacity: E.opacity,
          defaultText: O
        }), D.ensureState("emphasis").style = m, D.ensureState("blur").style = y, D.ensureState("select").style = x, bn(D, S, I, T), D.incremental = s, s && (D.states.emphasis.hoverLayer = true), g.add(D), v.setItemGraphicEl(C, D), this._progressiveEls && this._progressiveEls.push(D);
      }
    }, t.prototype._renderOnGeo = function(e, r, i, a) {
      var s = i.targetVisuals.inRange, o = i.targetVisuals.outOfRange, l = r.getData(), u = this._hmLayer || this._hmLayer || new _vt();
      u.blurSize = r.get("blurSize"), u.pointSize = r.get("pointSize"), u.minOpacity = r.get("minOpacity"), u.maxOpacity = r.get("maxOpacity");
      var c = e.getViewRect().clone(), h = e.getRoamTransform();
      c.applyTransform(h);
      var f = Math.max(c.x, 0), d = Math.max(c.y, 0), p = Math.min(c.width + c.x, a.getWidth()), g = Math.min(c.height + c.y, a.getHeight()), v = p - f, m = g - d, y = [
        l.mapDimension("lng"),
        l.mapDimension("lat"),
        l.mapDimension("value")
      ], x = l.mapArray(y, function(S, I, T) {
        var A = e.dataToPoint([
          S,
          I
        ]);
        return A[0] -= f, A[1] -= d, A.push(T), A;
      }), b = i.getExtent(), _ = i.type === "visualMap.continuous" ? Svt(b, i.option.range) : wvt(b, i.getPieceList(), i.option.selected);
      u.update(x, v, m, s.color.getNormalizer(), {
        inRange: s.color.getColorMapper(),
        outOfRange: o.color.getColorMapper()
      }, _);
      var w = new br({
        style: {
          width: v,
          height: m,
          x: f,
          y: d,
          image: u.canvas
        },
        silent: true
      });
      this.group.add(w);
    }, t.type = "heatmap", t;
  }(qe), Tvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, r) {
      return el(null, this, {
        generateCoord: "value"
      });
    }, t.prototype.preventIncremental = function() {
      var e = Bv.get(this.get("coordinateSystem"));
      if (e && e.dimensions) return e.dimensions[0] === "lng" && e.dimensions[1] === "lat";
    }, t.type = "series.heatmap", t.dependencies = [
      "grid",
      "geo",
      "calendar"
    ], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(an);
  function Ivt(n) {
    n.registerChartView(Cvt), n.registerSeriesModel(Tvt);
  }
  var Avt = [
    "itemStyle",
    "borderWidth"
  ], nB = [
    {
      xy: "x",
      wh: "width",
      index: 0,
      posDesc: [
        "left",
        "right"
      ]
    },
    {
      xy: "y",
      wh: "height",
      index: 1,
      posDesc: [
        "top",
        "bottom"
      ]
    }
  ], OC = new tl(), kvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = this.group, s = e.getData(), o = this._data, l = e.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), h = l.master.getRect(), f = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: e,
        coordSys: l,
        coordSysExtent: [
          [
            h.x,
            h.x + h.width
          ],
          [
            h.y,
            h.y + h.height
          ]
        ],
        isHorizontal: c,
        valueDim: nB[+c],
        categoryDim: nB[1 - +c]
      };
      s.diff(o).add(function(p) {
        if (s.hasValue(p)) {
          var g = iB(s, p), v = rB(s, p, g, f), m = aB(s, f, v);
          s.setItemGraphicEl(p, m), a.add(m), oB(m, f, v);
        }
      }).update(function(p, g) {
        var v = o.getItemGraphicEl(g);
        if (!s.hasValue(p)) {
          a.remove(v);
          return;
        }
        var m = iB(s, p), y = rB(s, p, m, f), x = Q8(s, y);
        v && x !== v.__pictorialShapeStr && (a.remove(v), s.setItemGraphicEl(p, null), v = null), v ? Pvt(v, f, y) : v = aB(s, f, y, true), s.setItemGraphicEl(p, v), v.__pictorialSymbolMeta = y, a.add(v), oB(v, f, y);
      }).remove(function(p) {
        var g = o.getItemGraphicEl(p);
        g && sB(o, p, g.__pictorialSymbolMeta.animationModel, g);
      }).execute();
      var d = e.get("clip", true) ? Hv(e.coordinateSystem, false, e) : null;
      return d ? a.setClipPath(d) : a.removeClipPath(), this._data = s, this.group;
    }, t.prototype.remove = function(e, r) {
      var i = this.group, a = this._data;
      e.get("animation") ? a && a.eachItemGraphicEl(function(s) {
        sB(a, Ut(s).dataIndex, e, s);
      }) : i.removeAll();
    }, t.type = "pictorialBar", t;
  }(qe);
  function rB(n, t, e, r) {
    var i = n.getItemLayout(t), a = e.get("symbolRepeat"), s = e.get("symbolClip"), o = e.get("symbolPosition") || "start", l = e.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = e.get("symbolPatternSize") || 2, h = e.isAnimationEnabled(), f = {
      dataIndex: t,
      layout: i,
      itemModel: e,
      symbolType: n.getItemVisual(t, "symbol") || "circle",
      style: n.getItemVisual(t, "style"),
      symbolClip: s,
      symbolRepeat: a,
      symbolRepeatDirection: e.get("symbolRepeatDirection"),
      symbolPatternSize: c,
      rotation: u,
      animationModel: h ? e : null,
      hoverScale: h && e.get([
        "emphasis",
        "scale"
      ]),
      z2: e.getShallow("z", true) || 0
    };
    Dvt(e, a, i, r, f), Evt(n, t, i, a, s, f.boundingLength, f.pxSign, c, r, f), Mvt(e, f.symbolScale, u, r, f);
    var d = f.symbolSize, p = gh(e.get("symbolOffset"), d);
    return Rvt(e, d, i, a, s, p, o, f.valueLineWidth, f.boundingLength, f.repeatCutLength, r, f), f;
  }
  function Dvt(n, t, e, r, i) {
    var a = r.valueDim, s = n.get("symbolBoundingData"), o = r.coordSys.getOtherAxis(r.coordSys.getBaseAxis()), l = o.toGlobalCoord(o.dataToCoord(0)), u = 1 - +(e[a.wh] <= 0), c;
    if (ct(s)) {
      var h = [
        FC(o, s[0]) - l,
        FC(o, s[1]) - l
      ];
      h[1] < h[0] && h.reverse(), c = h[u];
    } else s != null ? c = FC(o, s) - l : t ? c = r.coordSysExtent[a.index][u] - l : c = e[a.wh];
    i.boundingLength = c, t && (i.repeatCutLength = e[a.wh]);
    var f = a.xy === "x", d = o.inverse;
    i.pxSign = f && !d || !f && d ? c >= 0 ? 1 : -1 : c > 0 ? 1 : -1;
  }
  function FC(n, t) {
    return n.toGlobalCoord(n.dataToCoord(n.scale.parse(t)));
  }
  function Evt(n, t, e, r, i, a, s, o, l, u) {
    var c = l.valueDim, h = l.categoryDim, f = Math.abs(e[h.wh]), d = n.getItemVisual(t, "symbolSize"), p;
    ct(d) ? p = d.slice() : d == null ? p = [
      "100%",
      "100%"
    ] : p = [
      d,
      d
    ], p[h.index] = yt(p[h.index], f), p[c.index] = yt(p[c.index], r ? f : Math.abs(a)), u.symbolSize = p;
    var g = u.symbolScale = [
      p[0] / o,
      p[1] / o
    ];
    g[c.index] *= (l.isHorizontal ? -1 : 1) * s;
  }
  function Mvt(n, t, e, r, i) {
    var a = n.get(Avt) || 0;
    a && (OC.attr({
      scaleX: t[0],
      scaleY: t[1],
      rotation: e
    }), OC.updateTransform(), a /= OC.getLineScale(), a *= t[r.valueDim.index]), i.valueLineWidth = a || 0;
  }
  function Rvt(n, t, e, r, i, a, s, o, l, u, c, h) {
    var f = c.categoryDim, d = c.valueDim, p = h.pxSign, g = Math.max(t[d.index] + o, 0), v = g;
    if (r) {
      var m = Math.abs(l), y = mr(n.get("symbolMargin"), "15%") + "", x = false;
      y.lastIndexOf("!") === y.length - 1 && (x = true, y = y.slice(0, y.length - 1));
      var b = yt(y, t[d.index]), _ = Math.max(g + b * 2, 0), w = x ? 0 : b * 2, S = iU(r), I = S ? r : lB((m + w) / _), T = m - I * g;
      b = T / 2 / (x ? I : Math.max(I - 1, 1)), _ = g + b * 2, w = x ? 0 : b * 2, !S && r !== "fixed" && (I = u ? lB((Math.abs(u) + w) / _) : 0), v = I * _ - w, h.repeatTimes = I, h.symbolMargin = b;
    }
    var A = p * (v / 2), C = h.pathPosition = [];
    C[f.index] = e[f.wh] / 2, C[d.index] = s === "start" ? A : s === "end" ? l - A : l / 2, a && (C[0] += a[0], C[1] += a[1]);
    var D = h.bundlePosition = [];
    D[f.index] = e[f.xy], D[d.index] = e[d.xy];
    var E = h.barRectShape = rt({}, e);
    E[d.wh] = p * Math.max(Math.abs(e[d.wh]), Math.abs(C[d.index] + A)), E[f.wh] = e[f.wh];
    var M = h.clipShape = {};
    M[f.xy] = -e[f.xy], M[f.wh] = c.ecSize[f.wh], M[d.xy] = 0, M[d.wh] = e[d.wh];
  }
  function q8(n) {
    var t = n.symbolPatternSize, e = Fn(n.symbolType, -t / 2, -t / 2, t, t);
    return e.attr({
      culling: true
    }), e.type !== "image" && e.setStyle({
      strokeNoScale: true
    }), e;
  }
  function j8(n, t, e, r) {
    var i = n.__pictorialBundle, a = e.symbolSize, s = e.valueLineWidth, o = e.pathPosition, l = t.valueDim, u = e.repeatTimes || 0, c = 0, h = a[t.valueDim.index] + s + e.symbolMargin * 2;
    for (cE(n, function(g) {
      g.__pictorialAnimationIndex = c, g.__pictorialRepeatTimes = u, c < u ? Nf(g, null, p(c), e, r) : Nf(g, null, {
        scaleX: 0,
        scaleY: 0
      }, e, r, function() {
        i.remove(g);
      }), c++;
    }); c < u; c++) {
      var f = q8(e);
      f.__pictorialAnimationIndex = c, f.__pictorialRepeatTimes = u, i.add(f);
      var d = p(c);
      Nf(f, {
        x: d.x,
        y: d.y,
        scaleX: 0,
        scaleY: 0
      }, {
        scaleX: d.scaleX,
        scaleY: d.scaleY,
        rotation: d.rotation
      }, e, r);
    }
    function p(g) {
      var v = o.slice(), m = e.pxSign, y = g;
      return (e.symbolRepeatDirection === "start" ? m > 0 : m < 0) && (y = u - 1 - g), v[l.index] = h * (y - u / 2 + 0.5) + o[l.index], {
        x: v[0],
        y: v[1],
        scaleX: e.symbolScale[0],
        scaleY: e.symbolScale[1],
        rotation: e.rotation
      };
    }
  }
  function K8(n, t, e, r) {
    var i = n.__pictorialBundle, a = n.__pictorialMainPath;
    a ? Nf(a, null, {
      x: e.pathPosition[0],
      y: e.pathPosition[1],
      scaleX: e.symbolScale[0],
      scaleY: e.symbolScale[1],
      rotation: e.rotation
    }, e, r) : (a = n.__pictorialMainPath = q8(e), i.add(a), Nf(a, {
      x: e.pathPosition[0],
      y: e.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: e.rotation
    }, {
      scaleX: e.symbolScale[0],
      scaleY: e.symbolScale[1]
    }, e, r));
  }
  function Z8(n, t, e) {
    var r = rt({}, t.barRectShape), i = n.__pictorialBarRect;
    i ? Nf(i, null, {
      shape: r
    }, t, e) : (i = n.__pictorialBarRect = new ye({
      z2: 2,
      shape: r,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    }), i.disableMorphing = true, n.add(i));
  }
  function J8(n, t, e, r) {
    if (e.symbolClip) {
      var i = n.__pictorialClipPath, a = rt({}, e.clipShape), s = t.valueDim, o = e.animationModel, l = e.dataIndex;
      if (i) Ie(i, {
        shape: a
      }, o, l);
      else {
        a[s.wh] = 0, i = new ye({
          shape: a
        }), n.__pictorialBundle.setClipPath(i), n.__pictorialClipPath = i;
        var u = {};
        u[s.wh] = e.clipShape[s.wh], ph[r ? "updateProps" : "initProps"](i, {
          shape: u
        }, o, l);
      }
    }
  }
  function iB(n, t) {
    var e = n.getItemModel(t);
    return e.getAnimationDelayParams = Nvt, e.isAnimationEnabled = Lvt, e;
  }
  function Nvt(n) {
    return {
      index: n.__pictorialAnimationIndex,
      count: n.__pictorialRepeatTimes
    };
  }
  function Lvt() {
    return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
  }
  function aB(n, t, e, r) {
    var i = new Vt(), a = new Vt();
    return i.add(a), i.__pictorialBundle = a, a.x = e.bundlePosition[0], a.y = e.bundlePosition[1], e.symbolRepeat ? j8(i, t, e) : K8(i, t, e), Z8(i, e, r), J8(i, t, e, r), i.__pictorialShapeStr = Q8(n, e), i.__pictorialSymbolMeta = e, i;
  }
  function Pvt(n, t, e) {
    var r = e.animationModel, i = e.dataIndex, a = n.__pictorialBundle;
    Ie(a, {
      x: e.bundlePosition[0],
      y: e.bundlePosition[1]
    }, r, i), e.symbolRepeat ? j8(n, t, e, true) : K8(n, t, e, true), Z8(n, e, true), J8(n, t, e, true);
  }
  function sB(n, t, e, r) {
    var i = r.__pictorialBarRect;
    i && i.removeTextContent();
    var a = [];
    cE(r, function(s) {
      a.push(s);
    }), r.__pictorialMainPath && a.push(r.__pictorialMainPath), r.__pictorialClipPath && (e = null), P(a, function(s) {
      ql(s, {
        scaleX: 0,
        scaleY: 0
      }, e, t, function() {
        r.parent && r.parent.remove(r);
      });
    }), n.setItemGraphicEl(t, null);
  }
  function Q8(n, t) {
    return [
      n.getItemVisual(t.dataIndex, "symbol") || "none",
      !!t.symbolRepeat,
      !!t.symbolClip
    ].join(":");
  }
  function cE(n, t, e) {
    P(n.__pictorialBundle.children(), function(r) {
      r !== n.__pictorialBarRect && t.call(e, r);
    });
  }
  function Nf(n, t, e, r, i, a) {
    t && n.attr(t), r.symbolClip && !i ? e && n.attr(e) : e && ph[i ? "updateProps" : "initProps"](n, e, r.animationModel, r.dataIndex, a);
  }
  function oB(n, t, e) {
    var r = e.dataIndex, i = e.itemModel, a = i.getModel("emphasis"), s = a.getModel("itemStyle").getItemStyle(), o = i.getModel([
      "blur",
      "itemStyle"
    ]).getItemStyle(), l = i.getModel([
      "select",
      "itemStyle"
    ]).getItemStyle(), u = i.getShallow("cursor"), c = a.get("focus"), h = a.get("blurScope"), f = a.get("scale");
    cE(n, function(g) {
      if (g instanceof br) {
        var v = g.style;
        g.useStyle(rt({
          image: v.image,
          x: v.x,
          y: v.y,
          width: v.width,
          height: v.height
        }, e.style));
      } else g.useStyle(e.style);
      var m = g.ensureState("emphasis");
      m.style = s, f && (m.scaleX = g.scaleX * 1.1, m.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = o, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = e.z2;
    });
    var d = t.valueDim.posDesc[+(e.boundingLength > 0)], p = n.__pictorialBarRect;
    p.ignoreClip = true, kr(p, ur(i), {
      labelFetcher: t.seriesModel,
      labelDataIndex: r,
      defaultText: Xf(t.seriesModel.getData(), r),
      inheritColor: e.style.fill,
      defaultOpacity: e.style.opacity,
      defaultOutsidePosition: d
    }), bn(n, c, h, a.get("disabled"));
  }
  function lB(n) {
    var t = Math.round(n);
    return Math.abs(n - t) < 1e-4 ? t : Math.ceil(n);
  }
  var $vt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = true, e.defaultSymbol = "roundRect", e;
    }
    return t.prototype.getInitialData = function(e) {
      return e.stack = null, n.prototype.getInitialData.apply(this, arguments);
    }, t.type = "series.pictorialBar", t.dependencies = [
      "grid"
    ], t.defaultOption = ou(jg.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: false,
      symbolRepeatDirection: "end",
      symbolClip: false,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      clip: false,
      progressive: 0,
      emphasis: {
        scale: false
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), t;
  }(jg);
  function Ovt(n) {
    n.registerChartView(kvt), n.registerSeriesModel($vt), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, qt($H, "pictorialBar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, OH("pictorialBar"));
  }
  var Fvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._layers = [], e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = e.getData(), s = this, o = this.group, l = e.getLayerSeries(), u = a.getLayout("layoutInfo"), c = u.rect, h = u.boundaryGap;
      o.x = 0, o.y = c.y + h[0];
      function f(v) {
        return v.name;
      }
      var d = new Wo(this._layersSeries || [], l, f, f), p = [];
      d.add(St(g, this, "add")).update(St(g, this, "update")).remove(St(g, this, "remove")).execute();
      function g(v, m, y) {
        var x = s._layers;
        if (v === "remove") {
          o.remove(x[m]);
          return;
        }
        for (var b = [], _ = [], w, S = l[m].indices, I = 0; I < S.length; I++) {
          var T = a.getItemLayout(S[I]), A = T.x, C = T.y0, D = T.y;
          b.push(A, C), _.push(A, C + D), w = a.getItemVisual(S[I], "style");
        }
        var E, M = a.getItemLayout(S[0]), L = e.getModel("label"), k = L.get("margin"), N = e.getModel("emphasis");
        if (v === "add") {
          var R = p[m] = new Vt();
          E = new T6({
            shape: {
              points: b,
              stackedOnPoints: _,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: false
            },
            z2: 0
          }), R.add(E), o.add(R), e.isAnimationEnabled() && E.setClipPath(Bvt(E.getBoundingRect(), e, function() {
            E.removeClipPath();
          }));
        } else {
          var R = x[y];
          E = R.childAt(0), o.add(R), p[m] = R, Ie(E, {
            shape: {
              points: b,
              stackedOnPoints: _
            }
          }, e), os(E);
        }
        kr(E, ur(e), {
          labelDataIndex: S[I - 1],
          defaultText: a.getName(S[I - 1]),
          inheritColor: w.fill
        }, {
          normal: {
            verticalAlign: "middle"
          }
        }), E.setTextConfig({
          position: null,
          local: true
        });
        var $ = E.getTextContent();
        $ && ($.x = M.x - k, $.y = M.y0 + M.y / 2), E.useStyle(w), a.setItemGraphicEl(m, E), Ar(E, e), bn(E, N.get("focus"), N.get("blurScope"), N.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, t.type = "themeRiver", t;
  }(qe);
  function Bvt(n, t, e) {
    var r = new ye({
      shape: {
        x: n.x - 10,
        y: n.y - 10,
        width: 0,
        height: n.height + 20
      }
    });
    return dn(r, {
      shape: {
        x: n.x - 50,
        width: n.width + 100,
        height: n.height + 20
      }
    }, t, e), r;
  }
  var BC = 2, zvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new qv(St(this.getData, this), St(this.getRawData, this));
    }, t.prototype.fixData = function(e) {
      var r = e.length, i = {}, a = GI(e, function(f) {
        return i.hasOwnProperty(f[0] + "") || (i[f[0] + ""] = -1), f[2];
      }), s = [];
      a.buckets.each(function(f, d) {
        s.push({
          name: d,
          dataList: f
        });
      });
      for (var o = s.length, l = 0; l < o; ++l) {
        for (var u = s[l].name, c = 0; c < s[l].dataList.length; ++c) {
          var h = s[l].dataList[c][0] + "";
          i[h] = l;
        }
        for (var h in i) i.hasOwnProperty(h) && i[h] !== l && (i[h] = l, e[r] = [
          h,
          0,
          u
        ], r++);
      }
      return e;
    }, t.prototype.getInitialData = function(e, r) {
      for (var i = this.getReferringComponents("singleAxis", On).models[0], a = i.get("type"), s = Le(e.data, function(p) {
        return p[2] !== void 0;
      }), o = this.fixData(s || []), l = [], u = this.nameMap = It(), c = 0, h = 0; h < o.length; ++h) l.push(o[h][BC]), u.get(o[h][BC]) || (u.set(o[h][BC], c), c++);
      var f = Vv(o, {
        coordDimensions: [
          "single"
        ],
        dimensionsDefine: [
          {
            name: "time",
            type: ab(a)
          },
          {
            name: "value",
            type: "float"
          },
          {
            name: "name",
            type: "ordinal"
          }
        ],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, d = new fi(f, this);
      return d.initData(o), d;
    }, t.prototype.getLayerSeries = function() {
      for (var e = this.getData(), r = e.count(), i = [], a = 0; a < r; ++a) i[a] = a;
      var s = e.mapDimension("single"), o = GI(i, function(u) {
        return e.get("name", u);
      }), l = [];
      return o.buckets.each(function(u, c) {
        u.sort(function(h, f) {
          return e.get(s, h) - e.get(s, f);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, t.prototype.getAxisTooltipData = function(e, r, i) {
      ct(e) || (e = e ? [
        e
      ] : []);
      for (var a = this.getData(), s = this.getLayerSeries(), o = [], l = s.length, u, c = 0; c < l; ++c) {
        for (var h = Number.MAX_VALUE, f = -1, d = s[c].indices.length, p = 0; p < d; ++p) {
          var g = a.get(e[0], s[c].indices[p]), v = Math.abs(g - r);
          v <= h && (u = g, h = v, f = s[c].indices[p]);
        }
        o.push(f);
      }
      return {
        dataIndices: o,
        nestestValue: u
      };
    }, t.prototype.formatTooltip = function(e, r, i) {
      var a = this.getData(), s = a.getName(e), o = a.get(a.mapDimension("value"), e);
      return cr("nameValue", {
        name: s,
        value: o
      });
    }, t.type = "series.themeRiver", t.dependencies = [
      "singleAxis"
    ], t.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      boundaryGap: [
        "10%",
        "10%"
      ],
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: true,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }, t;
  }(an);
  function Vvt(n, t) {
    n.eachSeriesByType("themeRiver", function(e) {
      var r = e.getData(), i = e.coordinateSystem, a = {}, s = i.getRect();
      a.rect = s;
      var o = e.get("boundaryGap"), l = i.getAxis();
      if (a.boundaryGap = o, l.orient === "horizontal") {
        o[0] = yt(o[0], s.height), o[1] = yt(o[1], s.height);
        var u = s.height - o[0] - o[1];
        uB(r, e, u);
      } else {
        o[0] = yt(o[0], s.width), o[1] = yt(o[1], s.width);
        var c = s.width - o[0] - o[1];
        uB(r, e, c);
      }
      r.setLayout("layoutInfo", a);
    });
  }
  function uB(n, t, e) {
    if (n.count()) for (var r = t.coordinateSystem, i = t.getLayerSeries(), a = n.mapDimension("single"), s = n.mapDimension("value"), o = ht(i, function(v) {
      return ht(v.indices, function(m) {
        var y = r.dataToPoint(n.get(a, m));
        return y[1] = n.get(s, m), y;
      });
    }), l = Gvt(o), u = l.y0, c = e / l.max, h = i.length, f = i[0].indices.length, d, p = 0; p < f; ++p) {
      d = u[p] * c, n.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: o[0][p][0],
        y0: d,
        y: o[0][p][1] * c
      });
      for (var g = 1; g < h; ++g) d += o[g - 1][p][1] * c, n.setItemLayout(i[g].indices[p], {
        layerIndex: g,
        x: o[g][p][0],
        y0: d,
        y: o[g][p][1] * c
      });
    }
  }
  function Gvt(n) {
    for (var t = n.length, e = n[0].length, r = [], i = [], a = 0, s = 0; s < e; ++s) {
      for (var o = 0, l = 0; l < t; ++l) o += n[l][s][1];
      o > a && (a = o), r.push(o);
    }
    for (var u = 0; u < e; ++u) i[u] = (a - r[u]) / 2;
    a = 0;
    for (var c = 0; c < e; ++c) {
      var h = r[c] + i[c];
      h > a && (a = h);
    }
    return {
      y0: i,
      max: a
    };
  }
  function Wvt(n) {
    n.registerChartView(Fvt), n.registerSeriesModel(zvt), n.registerLayout(Vvt), n.registerProcessor(Yv("themeRiver"));
  }
  var Uvt = 2, Hvt = 4, cB = function(n) {
    q(t, n);
    function t(e, r, i, a) {
      var s = n.call(this) || this;
      s.z2 = Uvt, s.textConfig = {
        inside: true
      }, Ut(s).seriesIndex = r.seriesIndex;
      var o = new be({
        z2: Hvt,
        silent: e.getModel().get([
          "label",
          "silent"
        ])
      });
      return s.setTextContent(o), s.updateData(true, e, r, i, a), s;
    }
    return t.prototype.updateData = function(e, r, i, a, s) {
      this.node = r, r.piece = this, i = i || this._seriesModel, a = a || this._ecModel;
      var o = this;
      Ut(o).dataIndex = r.dataIndex;
      var l = r.getModel(), u = l.getModel("emphasis"), c = r.getLayout(), h = rt({}, c);
      h.label = null;
      var f = r.getVisual("style");
      f.lineJoin = "bevel";
      var d = r.getVisual("decal");
      d && (f.decal = Uf(d, s));
      var p = Sc(l.getModel("itemStyle"), h, true);
      rt(h, p), P(vi, function(y) {
        var x = o.ensureState(y), b = l.getModel([
          y,
          "itemStyle"
        ]);
        x.style = b.getItemStyle();
        var _ = Sc(b, h);
        _ && (x.shape = _);
      }), e ? (o.setShape(h), o.shape.r = c.r0, dn(o, {
        shape: {
          r: c.r
        }
      }, i, r.dataIndex)) : (Ie(o, {
        shape: h
      }, i), os(o)), o.useStyle(f), this._updateLabel(i);
      var g = l.getShallow("cursor");
      g && o.attr("cursor", g), this._seriesModel = i || this._seriesModel, this._ecModel = a || this._ecModel;
      var v = u.get("focus"), m = v === "relative" ? Mg(r.getAncestorsIndices(), r.getDescendantIndices()) : v === "ancestor" ? r.getAncestorsIndices() : v === "descendant" ? r.getDescendantIndices() : v;
      bn(this, m, u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e) {
      var r = this, i = this.node.getModel(), a = i.getModel("label"), s = this.node.getLayout(), o = s.endAngle - s.startAngle, l = (s.startAngle + s.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), h = this, f = h.getTextContent(), d = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, g = a.get("show") && !(p != null && Math.abs(o) < p);
      f.ignore = !g, P(Og, function(m) {
        var y = m === "normal" ? i.getModel("label") : i.getModel([
          m,
          "label"
        ]), x = m === "normal", b = x ? f : f.ensureState(m), _ = e.getFormattedLabel(d, m);
        x && (_ = _ || r.node.name), b.style = nn(y, {}, null, m !== "normal", true), _ && (b.style.text = _);
        var w = y.get("show");
        w != null && !x && (b.ignore = !w);
        var S = v(y, "position"), I = x ? h : h.states[m], T = I.style.fill;
        I.textConfig = {
          outsideFill: y.get("color") === "inherit" ? T : null,
          inside: S !== "outside"
        };
        var A, C = v(y, "distance") || 0, D = v(y, "align"), E = v(y, "rotate"), M = Math.PI * 0.5, L = Math.PI * 1.5, k = Ui(E === "tangential" ? Math.PI / 2 - l : l), N = k > M && !Pg(k - M) && k < L;
        S === "outside" ? (A = s.r + C, D = N ? "right" : "left") : !D || D === "center" ? (o === 2 * Math.PI && s.r0 === 0 ? A = 0 : A = (s.r + s.r0) / 2, D = "center") : D === "left" ? (A = s.r0 + C, D = N ? "right" : "left") : D === "right" && (A = s.r - C, D = N ? "left" : "right"), b.style.align = D, b.style.verticalAlign = v(y, "verticalAlign") || "middle", b.x = A * u + s.cx, b.y = A * c + s.cy;
        var R = 0;
        E === "radial" ? R = Ui(-l) + (N ? Math.PI : 0) : E === "tangential" ? R = Ui(Math.PI / 2 - l) + (N ? Math.PI : 0) : _e(E) && (R = E * Math.PI / 180), b.rotation = Ui(R);
      });
      function v(m, y) {
        var x = m.get(y);
        return x ?? a.get(y);
      }
      f.dirtyStyle();
    }, t;
  }(mi), GA = "sunburstRootToNode", hB = "sunburstHighlight", Xvt = "sunburstUnhighlight";
  function Yvt(n) {
    n.registerAction({
      type: GA,
      update: "updateView"
    }, function(t, e) {
      e.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: t
      }, r);
      function r(i, a) {
        var s = Zg(t, [
          GA
        ], i);
        if (s) {
          var o = i.getViewRoot();
          o && (t.direction = qD(o, s.node) ? "rollUp" : "drillDown"), i.resetViewRoot(s.node);
        }
      }
    }), n.registerAction({
      type: hB,
      update: "none"
    }, function(t, e, r) {
      t = rt({}, t), e.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: t
      }, i);
      function i(a) {
        var s = Zg(t, [
          hB
        ], a);
        s && (t.dataIndex = s.node.dataIndex);
      }
      r.dispatchAction(rt(t, {
        type: "highlight"
      }));
    }), n.registerAction({
      type: Xvt,
      update: "updateView"
    }, function(t, e, r) {
      t = rt({}, t), r.dispatchAction(rt(t, {
        type: "downplay"
      }));
    });
  }
  var qvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i, a) {
      var s = this;
      this.seriesModel = e, this.api = i, this.ecModel = r;
      var o = e.getData(), l = o.tree.root, u = e.getViewRoot(), c = this.group, h = e.get("renderLabelForZeroData"), f = [];
      u.eachNode(function(y) {
        f.push(y);
      });
      var d = this._oldChildren || [];
      p(f, d), m(l, u), this._initEvents(), this._oldChildren = f;
      function p(y, x) {
        if (y.length === 0 && x.length === 0) return;
        new Wo(x, y, b, b).add(_).update(_).remove(qt(_, null)).execute();
        function b(w) {
          return w.getId();
        }
        function _(w, S) {
          var I = w == null ? null : y[w], T = S == null ? null : x[S];
          g(I, T);
        }
      }
      function g(y, x) {
        if (!h && y && !y.getValue() && (y = null), y !== l && x !== l) {
          if (x && x.piece) y ? (x.piece.updateData(false, y, e, r, i), o.setItemGraphicEl(y.dataIndex, x.piece)) : v(x);
          else if (y) {
            var b = new cB(y, e, r, i);
            c.add(b), o.setItemGraphicEl(y.dataIndex, b);
          }
        }
      }
      function v(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function m(y, x) {
        x.depth > 0 ? (s.virtualPiece ? s.virtualPiece.updateData(false, y, e, r, i) : (s.virtualPiece = new cB(y, e, r, i), c.add(s.virtualPiece)), x.piece.off("click"), s.virtualPiece.on("click", function(b) {
          s._rootToNode(x.parentNode);
        })) : s.virtualPiece && (c.remove(s.virtualPiece), s.virtualPiece = null);
      }
    }, t.prototype._initEvents = function() {
      var e = this;
      this.group.off("click"), this.group.on("click", function(r) {
        var i = false, a = e.seriesModel.getViewRoot();
        a.eachNode(function(s) {
          if (!i && s.piece && s.piece === r.target) {
            var o = s.getModel().get("nodeClick");
            if (o === "rootToNode") e._rootToNode(s);
            else if (o === "link") {
              var l = s.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", true) || "_blank";
                Zx(u, c);
              }
            }
            i = true;
          }
        });
      });
    }, t.prototype._rootToNode = function(e) {
      e !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: GA,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e
      });
    }, t.prototype.containPoint = function(e, r) {
      var i = r.getData(), a = i.getItemLayout(0);
      if (a) {
        var s = e[0] - a.cx, o = e[1] - a.cy, l = Math.sqrt(s * s + o * o);
        return l <= a.r && l >= a.r0;
      }
    }, t.type = "sunburst", t;
  }(qe), jvt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.ignoreStyleOnData = true, e;
    }
    return t.prototype.getInitialData = function(e, r) {
      var i = {
        name: e.name,
        children: e.data
      };
      tX(i);
      var a = this._levelModels = ht(e.levels || [], function(l) {
        return new $e(l, this, r);
      }, this), s = YD.createTree(i, this, o);
      function o(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var h = s.getNodeByDataIndex(c), f = a[h.depth];
          return f && (u.parentModel = f), u;
        });
      }
      return s.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.getDataParams = function(e) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return r.treePathInfo = K1(i, this), r;
    }, t.prototype.getLevelModel = function(e) {
      return this._levelModels && this._levelModels[e.depth];
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(e) {
      e ? this._viewRoot = e : e = this._viewRoot;
      var r = this.getRawData().tree.root;
      (!e || e !== r && !r.contains(e)) && (this._viewRoot = r);
    }, t.prototype.enableAriaDecal = function() {
      a8(this);
    }, t.type = "series.sunburst", t.defaultOption = {
      z: 2,
      center: [
        "50%",
        "50%"
      ],
      radius: [
        0,
        "75%"
      ],
      clockwise: true,
      startAngle: 90,
      minAngle: 0,
      stillShowZeroSum: true,
      nodeClick: "rootToNode",
      renderLabelForZeroData: false,
      label: {
        rotate: "radial",
        show: true,
        opacity: 1,
        align: "center",
        position: "inside",
        distance: 5,
        silent: true
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      sort: "desc"
    }, t;
  }(an);
  function tX(n) {
    var t = 0;
    P(n.children, function(r) {
      tX(r);
      var i = r.value;
      ct(i) && (i = i[0]), t += i;
    });
    var e = n.value;
    ct(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), ct(n.value) ? n.value[0] = e : n.value = e;
  }
  var fB = Math.PI / 180;
  function Kvt(n, t, e) {
    t.eachSeriesByType(n, function(r) {
      var i = r.get("center"), a = r.get("radius");
      ct(a) || (a = [
        0,
        a
      ]), ct(i) || (i = [
        i,
        i
      ]);
      var s = e.getWidth(), o = e.getHeight(), l = Math.min(s, o), u = yt(i[0], s), c = yt(i[1], o), h = yt(a[0], l / 2), f = yt(a[1], l / 2), d = -r.get("startAngle") * fB, p = r.get("minAngle") * fB, g = r.getData().tree.root, v = r.getViewRoot(), m = v.depth, y = r.get("sort");
      y != null && eX(v, y);
      var x = 0;
      P(v.children, function(k) {
        !isNaN(k.getValue()) && x++;
      });
      var b = v.getValue(), _ = Math.PI / (b || x) * 2, w = v.depth > 0, S = v.height - (w ? -1 : 1), I = (f - h) / (S || 1), T = r.get("clockwise"), A = r.get("stillShowZeroSum"), C = T ? 1 : -1, D = function(k, N) {
        if (k) {
          var R = N;
          if (k !== g) {
            var $ = k.getValue(), O = b === 0 && A ? _ : $ * _;
            O < p && (O = p), R = N + C * O;
            var F = k.depth - m - (w ? -1 : 1), z = h + I * F, V = h + I * (F + 1), U = r.getLevelModel(k);
            if (U) {
              var X = U.get("r0", true), at = U.get("r", true), pt = U.get("radius", true);
              pt != null && (X = pt[0], at = pt[1]), X != null && (z = yt(X, l / 2)), at != null && (V = yt(at, l / 2));
            }
            k.setLayout({
              angle: O,
              startAngle: N,
              endAngle: R,
              clockwise: T,
              cx: u,
              cy: c,
              r0: z,
              r: V
            });
          }
          if (k.children && k.children.length) {
            var it = 0;
            P(k.children, function(et) {
              it += D(et, N + it);
            });
          }
          return R - N;
        }
      };
      if (w) {
        var E = h, M = h + I, L = Math.PI * 2;
        g.setLayout({
          angle: L,
          startAngle: d,
          endAngle: d + L,
          clockwise: T,
          cx: u,
          cy: c,
          r0: E,
          r: M
        });
      }
      D(v, d);
    });
  }
  function eX(n, t) {
    var e = n.children || [];
    n.children = Zvt(e, t), e.length && P(n.children, function(r) {
      eX(r, t);
    });
  }
  function Zvt(n, t) {
    if (Nt(t)) {
      var e = ht(n, function(i, a) {
        var s = i.getValue();
        return {
          params: {
            depth: i.depth,
            height: i.height,
            dataIndex: i.dataIndex,
            getValue: function() {
              return s;
            }
          },
          index: a
        };
      });
      return e.sort(function(i, a) {
        return t(i.params, a.params);
      }), ht(e, function(i) {
        return n[i.index];
      });
    } else {
      var r = t === "asc";
      return n.sort(function(i, a) {
        var s = (i.getValue() - a.getValue()) * (r ? 1 : -1);
        return s === 0 ? (i.dataIndex - a.dataIndex) * (r ? -1 : 1) : s;
      });
    }
  }
  function Jvt(n) {
    var t = {};
    function e(r, i, a) {
      for (var s = r; s && s.depth > 1; ) s = s.parentNode;
      var o = i.getColorFromPalette(s.name || s.dataIndex + "", t);
      return r.depth > 1 && wt(o) && (o = EI(o, (r.depth - 1) / (a - 1) * 0.5)), o;
    }
    n.eachSeriesByType("sunburst", function(r) {
      var i = r.getData(), a = i.tree;
      a.eachNode(function(s) {
        var o = s.getModel(), l = o.getModel("itemStyle").getItemStyle();
        l.fill || (l.fill = e(s, r, a.root.height));
        var u = i.ensureUniqueItemVisual(s.dataIndex, "style");
        rt(u, l);
      });
    });
  }
  function Qvt(n) {
    n.registerChartView(qvt), n.registerSeriesModel(jvt), n.registerLayout(qt(Kvt, "sunburst")), n.registerProcessor(qt(Yv, "sunburst")), n.registerVisual(Jvt), Yvt(n);
  }
  var dB = {
    color: "fill",
    borderColor: "stroke"
  }, tmt = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1
  }, Lo = xe(), emt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", true), this.currentZ = this.get("z", true);
    }, t.prototype.getInitialData = function(e, r) {
      return el(null, this);
    }, t.prototype.getDataParams = function(e, r, i) {
      var a = n.prototype.getDataParams.call(this, e, r);
      return i && (a.info = Lo(i).info), a;
    }, t.type = "series.custom", t.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      clip: false
    }, t;
  }(an);
  function nmt(n, t) {
    return t = t || [
      0,
      0
    ], ht([
      "x",
      "y"
    ], function(e, r) {
      var i = this.getAxis(e), a = t[r], s = n[r] / 2;
      return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(a - s) - i.dataToCoord(a + s));
    }, this);
  }
  function rmt(n) {
    var t = n.master.getRect();
    return {
      coordSys: {
        type: "cartesian2d",
        x: t.x,
        y: t.y,
        width: t.width,
        height: t.height
      },
      api: {
        coord: function(e) {
          return n.dataToPoint(e);
        },
        size: St(nmt, n)
      }
    };
  }
  function imt(n, t) {
    return t = t || [
      0,
      0
    ], ht([
      0,
      1
    ], function(e) {
      var r = t[e], i = n[e] / 2, a = [], s = [];
      return a[e] = r - i, s[e] = r + i, a[1 - e] = s[1 - e] = t[1 - e], Math.abs(this.dataToPoint(a)[e] - this.dataToPoint(s)[e]);
    }, this);
  }
  function amt(n) {
    var t = n.getBoundingRect();
    return {
      coordSys: {
        type: "geo",
        x: t.x,
        y: t.y,
        width: t.width,
        height: t.height,
        zoom: n.getZoom()
      },
      api: {
        coord: function(e) {
          return n.dataToPoint(e);
        },
        size: St(imt, n)
      }
    };
  }
  function smt(n, t) {
    var e = this.getAxis(), r = t instanceof Array ? t[0] : t, i = (n instanceof Array ? n[0] : n) / 2;
    return e.type === "category" ? e.getBandWidth() : Math.abs(e.dataToCoord(r - i) - e.dataToCoord(r + i));
  }
  function omt(n) {
    var t = n.getRect();
    return {
      coordSys: {
        type: "singleAxis",
        x: t.x,
        y: t.y,
        width: t.width,
        height: t.height
      },
      api: {
        coord: function(e) {
          return n.dataToPoint(e);
        },
        size: St(smt, n)
      }
    };
  }
  function lmt(n, t) {
    return t = t || [
      0,
      0
    ], ht([
      "Radius",
      "Angle"
    ], function(e, r) {
      var i = "get" + e + "Axis", a = this[i](), s = t[r], o = n[r] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(s - o) - a.dataToCoord(s + o));
      return e === "Angle" && (l = l * Math.PI / 180), l;
    }, this);
  }
  function umt(n) {
    var t = n.getRadiusAxis(), e = n.getAngleAxis(), r = t.getExtent();
    return r[0] > r[1] && r.reverse(), {
      coordSys: {
        type: "polar",
        cx: n.cx,
        cy: n.cy,
        r: r[1],
        r0: r[0]
      },
      api: {
        coord: function(i) {
          var a = t.dataToRadius(i[0]), s = e.dataToAngle(i[1]), o = n.coordToPoint([
            a,
            s
          ]);
          return o.push(a, s * Math.PI / 180), o;
        },
        size: St(lmt, n)
      }
    };
  }
  function cmt(n) {
    var t = n.getRect(), e = n.getRangeInfo();
    return {
      coordSys: {
        type: "calendar",
        x: t.x,
        y: t.y,
        width: t.width,
        height: t.height,
        cellWidth: n.getCellWidth(),
        cellHeight: n.getCellHeight(),
        rangeInfo: {
          start: e.start,
          end: e.end,
          weeks: e.weeks,
          dayCount: e.allDay
        }
      },
      api: {
        coord: function(r, i) {
          return n.dataToPoint(r, i);
        }
      }
    };
  }
  function nX(n, t, e, r) {
    return n && (n.legacy || n.legacy !== false && !e && !r && t !== "tspan" && (t === "text" || Ct(n, "text")));
  }
  function rX(n, t, e) {
    var r = n, i, a, s;
    if (t === "text") s = r;
    else {
      s = {}, Ct(r, "text") && (s.text = r.text), Ct(r, "rich") && (s.rich = r.rich), Ct(r, "textFill") && (s.fill = r.textFill), Ct(r, "textStroke") && (s.stroke = r.textStroke), Ct(r, "fontFamily") && (s.fontFamily = r.fontFamily), Ct(r, "fontSize") && (s.fontSize = r.fontSize), Ct(r, "fontStyle") && (s.fontStyle = r.fontStyle), Ct(r, "fontWeight") && (s.fontWeight = r.fontWeight), a = {
        type: "text",
        style: s,
        silent: true
      }, i = {};
      var o = Ct(r, "textPosition");
      e ? i.position = o ? r.textPosition : "inside" : o && (i.position = r.textPosition), Ct(r, "textPosition") && (i.position = r.textPosition), Ct(r, "textOffset") && (i.offset = r.textOffset), Ct(r, "textRotation") && (i.rotation = r.textRotation), Ct(r, "textDistance") && (i.distance = r.textDistance);
    }
    return pB(s, n), P(s.rich, function(l) {
      pB(l, l);
    }), {
      textConfig: i,
      textContent: a
    };
  }
  function pB(n, t) {
    t && (t.font = t.textFont || t.font, Ct(t, "textStrokeWidth") && (n.lineWidth = t.textStrokeWidth), Ct(t, "textAlign") && (n.align = t.textAlign), Ct(t, "textVerticalAlign") && (n.verticalAlign = t.textVerticalAlign), Ct(t, "textLineHeight") && (n.lineHeight = t.textLineHeight), Ct(t, "textWidth") && (n.width = t.textWidth), Ct(t, "textHeight") && (n.height = t.textHeight), Ct(t, "textBackgroundColor") && (n.backgroundColor = t.textBackgroundColor), Ct(t, "textPadding") && (n.padding = t.textPadding), Ct(t, "textBorderColor") && (n.borderColor = t.textBorderColor), Ct(t, "textBorderWidth") && (n.borderWidth = t.textBorderWidth), Ct(t, "textBorderRadius") && (n.borderRadius = t.textBorderRadius), Ct(t, "textBoxShadowColor") && (n.shadowColor = t.textBoxShadowColor), Ct(t, "textBoxShadowBlur") && (n.shadowBlur = t.textBoxShadowBlur), Ct(t, "textBoxShadowOffsetX") && (n.shadowOffsetX = t.textBoxShadowOffsetX), Ct(t, "textBoxShadowOffsetY") && (n.shadowOffsetY = t.textBoxShadowOffsetY));
  }
  function gB(n, t, e) {
    var r = n;
    r.textPosition = r.textPosition || e.position || "inside", e.offset != null && (r.textOffset = e.offset), e.rotation != null && (r.textRotation = e.rotation), e.distance != null && (r.textDistance = e.distance);
    var i = r.textPosition.indexOf("inside") >= 0, a = n.fill || "#000";
    vB(r, t);
    var s = r.textFill == null;
    return i ? s && (r.textFill = e.insideFill || "#fff", !r.textStroke && e.insideStroke && (r.textStroke = e.insideStroke), !r.textStroke && (r.textStroke = a), r.textStrokeWidth == null && (r.textStrokeWidth = 2)) : (s && (r.textFill = n.fill || e.outsideFill || "#000"), !r.textStroke && e.outsideStroke && (r.textStroke = e.outsideStroke)), r.text = t.text, r.rich = t.rich, P(t.rich, function(o) {
      vB(o, o);
    }), r;
  }
  function vB(n, t) {
    t && (Ct(t, "fill") && (n.textFill = t.fill), Ct(t, "stroke") && (n.textStroke = t.fill), Ct(t, "lineWidth") && (n.textStrokeWidth = t.lineWidth), Ct(t, "font") && (n.font = t.font), Ct(t, "fontStyle") && (n.fontStyle = t.fontStyle), Ct(t, "fontWeight") && (n.fontWeight = t.fontWeight), Ct(t, "fontSize") && (n.fontSize = t.fontSize), Ct(t, "fontFamily") && (n.fontFamily = t.fontFamily), Ct(t, "align") && (n.textAlign = t.align), Ct(t, "verticalAlign") && (n.textVerticalAlign = t.verticalAlign), Ct(t, "lineHeight") && (n.textLineHeight = t.lineHeight), Ct(t, "width") && (n.textWidth = t.width), Ct(t, "height") && (n.textHeight = t.height), Ct(t, "backgroundColor") && (n.textBackgroundColor = t.backgroundColor), Ct(t, "padding") && (n.textPadding = t.padding), Ct(t, "borderColor") && (n.textBorderColor = t.borderColor), Ct(t, "borderWidth") && (n.textBorderWidth = t.borderWidth), Ct(t, "borderRadius") && (n.textBorderRadius = t.borderRadius), Ct(t, "shadowColor") && (n.textBoxShadowColor = t.shadowColor), Ct(t, "shadowBlur") && (n.textBoxShadowBlur = t.shadowBlur), Ct(t, "shadowOffsetX") && (n.textBoxShadowOffsetX = t.shadowOffsetX), Ct(t, "shadowOffsetY") && (n.textBoxShadowOffsetY = t.shadowOffsetY), Ct(t, "textShadowColor") && (n.textShadowColor = t.textShadowColor), Ct(t, "textShadowBlur") && (n.textShadowBlur = t.textShadowBlur), Ct(t, "textShadowOffsetX") && (n.textShadowOffsetX = t.textShadowOffsetX), Ct(t, "textShadowOffsetY") && (n.textShadowOffsetY = t.textShadowOffsetY));
  }
  var iX = {
    position: [
      "x",
      "y"
    ],
    scale: [
      "scaleX",
      "scaleY"
    ],
    origin: [
      "originX",
      "originY"
    ]
  }, mB = ge(iX);
  Qs(eo, function(n, t) {
    return n[t] = 1, n;
  }, {});
  eo.join(", ");
  var mb = [
    "",
    "style",
    "shape",
    "extra"
  ], jf = xe();
  function hE(n, t, e, r, i) {
    var a = n + "Animation", s = _d(n, r, i) || {}, o = jf(t).userDuring;
    return s.duration > 0 && (s.during = o ? St(gmt, {
      el: t,
      userDuring: o
    }) : null, s.setToFinal = true, s.scope = n), rt(s, e[a]), s;
  }
  function mx(n, t, e, r) {
    r = r || {};
    var i = r.dataIndex, a = r.isInit, s = r.clearStyle, o = e.isAnimationEnabled(), l = jf(n), u = t.style;
    l.userDuring = t.during;
    var c = {}, h = {};
    if (mmt(n, t, h), xB("shape", t, h), xB("extra", t, h), !a && o && (vmt(n, t, c), yB("shape", n, t, c), yB("extra", n, t, c), ymt(n, t, u, c)), h.style = u, hmt(n, h, s), dmt(n, t), o) if (a) {
      var f = {};
      P(mb, function(p) {
        var g = p ? t[p] : t;
        g && g.enterFrom && (p && (f[p] = f[p] || {}), rt(p ? f[p] : f, g.enterFrom));
      });
      var d = hE("enter", n, t, e, i);
      d.duration > 0 && n.animateFrom(f, d);
    } else fmt(n, t, i || 0, e, c);
    aX(n, t), u ? n.dirty() : n.markRedraw();
  }
  function aX(n, t) {
    for (var e = jf(n).leaveToProps, r = 0; r < mb.length; r++) {
      var i = mb[r], a = i ? t[i] : t;
      a && a.leaveTo && (e || (e = jf(n).leaveToProps = {}), i && (e[i] = e[i] || {}), rt(i ? e[i] : e, a.leaveTo));
    }
  }
  function Q1(n, t, e, r) {
    if (n) {
      var i = n.parent, a = jf(n).leaveToProps;
      if (a) {
        var s = hE("update", n, t, e, 0);
        s.done = function() {
          i.remove(n);
        }, n.animateTo(a, s);
      } else i.remove(n);
    }
  }
  function Oc(n) {
    return n === "all";
  }
  function hmt(n, t, e) {
    var r = t.style;
    if (!n.isGroup && r) {
      if (e) {
        n.useStyle({});
        for (var i = n.animators, a = 0; a < i.length; a++) {
          var s = i[a];
          s.targetName === "style" && s.changeTarget(n.style);
        }
      }
      n.setStyle(r);
    }
    t && (t.style = null, t && n.attr(t), t.style = r);
  }
  function fmt(n, t, e, r, i) {
    if (i) {
      var a = hE("update", n, t, r, e);
      a.duration > 0 && n.animateFrom(i, a);
    }
  }
  function dmt(n, t) {
    Ct(t, "silent") && (n.silent = t.silent), Ct(t, "ignore") && (n.ignore = t.ignore), n instanceof Ia && Ct(t, "invisible") && (n.invisible = t.invisible), n instanceof le && Ct(t, "autoBatch") && (n.autoBatch = t.autoBatch);
  }
  var Ts = {}, pmt = {
    setTransform: function(n, t) {
      return Ts.el[n] = t, this;
    },
    getTransform: function(n) {
      return Ts.el[n];
    },
    setShape: function(n, t) {
      var e = Ts.el, r = e.shape || (e.shape = {});
      return r[n] = t, e.dirtyShape && e.dirtyShape(), this;
    },
    getShape: function(n) {
      var t = Ts.el.shape;
      if (t) return t[n];
    },
    setStyle: function(n, t) {
      var e = Ts.el, r = e.style;
      return r && (r[n] = t, e.dirtyStyle && e.dirtyStyle()), this;
    },
    getStyle: function(n) {
      var t = Ts.el.style;
      if (t) return t[n];
    },
    setExtra: function(n, t) {
      var e = Ts.el.extra || (Ts.el.extra = {});
      return e[n] = t, this;
    },
    getExtra: function(n) {
      var t = Ts.el.extra;
      if (t) return t[n];
    }
  };
  function gmt() {
    var n = this, t = n.el;
    if (t) {
      var e = jf(t).userDuring, r = n.userDuring;
      if (e !== r) {
        n.el = n.userDuring = null;
        return;
      }
      Ts.el = t, r(pmt);
    }
  }
  function yB(n, t, e, r) {
    var i = e[n];
    if (i) {
      var a = t[n], s;
      if (a) {
        var o = e.transition, l = i.transition;
        if (l) if (!s && (s = r[n] = {}), Oc(l)) rt(s, a);
        else for (var u = He(l), c = 0; c < u.length; c++) {
          var h = u[c], f = a[h];
          s[h] = f;
        }
        else if (Oc(o) || ne(o, n) >= 0) {
          !s && (s = r[n] = {});
          for (var d = ge(a), c = 0; c < d.length; c++) {
            var h = d[c], f = a[h];
            xmt(i[h], f) && (s[h] = f);
          }
        }
      }
    }
  }
  function xB(n, t, e) {
    var r = t[n];
    if (r) for (var i = e[n] = {}, a = ge(r), s = 0; s < a.length; s++) {
      var o = a[s];
      i[o] = ug(r[o]);
    }
  }
  function vmt(n, t, e) {
    for (var r = t.transition, i = Oc(r) ? eo : He(r || []), a = 0; a < i.length; a++) {
      var s = i[a];
      if (!(s === "style" || s === "shape" || s === "extra")) {
        var o = n[s];
        e[s] = o;
      }
    }
  }
  function mmt(n, t, e) {
    for (var r = 0; r < mB.length; r++) {
      var i = mB[r], a = iX[i], s = t[i];
      s && (e[a[0]] = s[0], e[a[1]] = s[1]);
    }
    for (var r = 0; r < eo.length; r++) {
      var o = eo[r];
      t[o] != null && (e[o] = t[o]);
    }
  }
  function ymt(n, t, e, r) {
    if (e) {
      var i = n.style, a;
      if (i) {
        var s = e.transition, o = t.transition;
        if (s && !Oc(s)) {
          var l = He(s);
          !a && (a = r.style = {});
          for (var u = 0; u < l.length; u++) {
            var c = l[u], h = i[c];
            a[c] = h;
          }
        } else if (n.getAnimationStyleProps && (Oc(o) || Oc(s) || ne(o, "style") >= 0)) {
          var f = n.getAnimationStyleProps(), d = f ? f.style : null;
          if (d) {
            !a && (a = r.style = {});
            for (var p = ge(e), u = 0; u < p.length; u++) {
              var c = p[u];
              if (d[c]) {
                var h = i[c];
                a[c] = h;
              }
            }
          }
        }
      }
    }
  }
  function xmt(n, t) {
    return Kr(n) ? n !== t : n != null && isFinite(n);
  }
  var sX = xe(), bmt = [
    "percent",
    "easing",
    "shape",
    "style",
    "extra"
  ];
  function oX(n) {
    n.stopAnimation("keyframe"), n.attr(sX(n));
  }
  function yb(n, t, e) {
    if (!(!e.isAnimationEnabled() || !t)) {
      if (ct(t)) {
        P(t, function(o) {
          yb(n, o, e);
        });
        return;
      }
      var r = t.keyframes, i = t.duration;
      if (e && i == null) {
        var a = _d("enter", e, 0);
        i = a && a.duration;
      }
      if (!(!r || !i)) {
        var s = sX(n);
        P(mb, function(o) {
          if (!(o && !n[o])) {
            var l;
            r.sort(function(u, c) {
              return u.percent - c.percent;
            }), P(r, function(u) {
              var c = n.animators, h = o ? u[o] : u;
              if (h) {
                var f = ge(h);
                if (o || (f = Le(f, function(g) {
                  return ne(bmt, g) < 0;
                })), !!f.length) {
                  l || (l = n.animate(o, t.loop, true), l.scope = "keyframe");
                  for (var d = 0; d < c.length; d++) c[d] !== l && c[d].targetName === l.targetName && c[d].stopTracks(f);
                  o && (s[o] = s[o] || {});
                  var p = o ? s[o] : s;
                  P(f, function(g) {
                    p[g] = ((o ? n[o] : n) || {})[g];
                  }), l.whenWithKeys(i * u.percent, h, f, u.easing);
                }
              }
            }), l && l.delay(t.delay || 0).duration(i).start(t.easing);
          }
        });
      }
    }
  }
  var Po = "emphasis", El = "normal", fE = "blur", dE = "select", Jl = [
    El,
    Po,
    fE,
    dE
  ], zC = {
    normal: [
      "itemStyle"
    ],
    emphasis: [
      Po,
      "itemStyle"
    ],
    blur: [
      fE,
      "itemStyle"
    ],
    select: [
      dE,
      "itemStyle"
    ]
  }, VC = {
    normal: [
      "label"
    ],
    emphasis: [
      Po,
      "label"
    ],
    blur: [
      fE,
      "label"
    ],
    select: [
      dE,
      "label"
    ]
  }, _mt = [
    "x",
    "y"
  ], wmt = "e\0\0", sa = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {}
  }, Smt = {
    cartesian2d: rmt,
    geo: amt,
    single: omt,
    polar: umt,
    calendar: cmt
  };
  function WA(n) {
    return n instanceof le;
  }
  function UA(n) {
    return n instanceof Ia;
  }
  function Cmt(n, t) {
    t.copyTransform(n), UA(t) && UA(n) && (t.setStyle(n.style), t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel, t.invisible = n.invisible, t.ignore = n.ignore, WA(t) && WA(n) && t.setShape(n.shape));
  }
  var Tmt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i, a) {
      this._progressiveEls = null;
      var s = this._data, o = e.getData(), l = this.group, u = bB(e, o, r, i);
      s || l.removeAll(), o.diff(s).add(function(h) {
        GC(i, null, h, u(h, a), e, l, o);
      }).remove(function(h) {
        var f = s.getItemGraphicEl(h);
        f && Q1(f, Lo(f).option, e);
      }).update(function(h, f) {
        var d = s.getItemGraphicEl(f);
        GC(i, d, h, u(h, a), e, l, o);
      }).execute();
      var c = e.get("clip", true) ? Hv(e.coordinateSystem, false, e) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = o;
    }, t.prototype.incrementalPrepareRender = function(e, r, i) {
      this.group.removeAll(), this._data = null;
    }, t.prototype.incrementalRender = function(e, r, i, a, s) {
      var o = r.getData(), l = bB(r, o, i, a), u = this._progressiveEls = [];
      function c(d) {
        d.isGroup || (d.incremental = true, d.ensureState("emphasis").hoverLayer = true);
      }
      for (var h = e.start; h < e.end; h++) {
        var f = GC(null, null, h, l(h, s), r, this.group, o);
        f && (f.traverse(c), u.push(f));
      }
    }, t.prototype.eachRendered = function(e) {
      su(this._progressiveEls || this.group, e);
    }, t.prototype.filterForExposedEvent = function(e, r, i, a) {
      var s = r.element;
      if (s == null || i.name === s) return true;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; ) if (i.name === s) return true;
      return false;
    }, t.type = "custom", t;
  }(qe);
  function pE(n) {
    var t = n.type, e;
    if (t === "path") {
      var r = n.shape, i = r.width != null && r.height != null ? {
        x: r.x || 0,
        y: r.y || 0,
        width: r.width,
        height: r.height
      } : null, a = cX(r);
      e = D1(a, null, i, r.layout || "center"), Lo(e).customPathData = a;
    } else if (t === "image") e = new br({}), Lo(e).customImagePath = n.style.image;
    else if (t === "text") e = new be({});
    else if (t === "group") e = new Vt();
    else {
      if (t === "compoundPath") throw new Error('"compoundPath" is not supported yet.');
      var s = nD(t);
      if (!s) {
        var o = "";
        Ne(o);
      }
      e = new s();
    }
    return Lo(e).customGraphicType = t, e.name = n.name, e.z2EmphasisLift = 1, e.z2SelectLift = 1, e;
  }
  function gE(n, t, e, r, i, a, s) {
    oX(t);
    var o = i && i.normal.cfg;
    o && t.setTextConfig(o), r && r.transition == null && (r.transition = _mt);
    var l = r && r.style;
    if (l) {
      if (t.type === "text") {
        var u = l;
        Ct(u, "textFill") && (u.fill = u.textFill), Ct(u, "textStroke") && (u.stroke = u.textStroke);
      }
      var c = void 0, h = WA(t) ? l.decal : null;
      n && h && (h.dirty = true, c = Uf(h, n)), l.__decalPattern = c;
    }
    if (UA(t) && l) {
      var c = l.__decalPattern;
      c && (l.decal = c);
    }
    mx(t, r, a, {
      dataIndex: e,
      isInit: s,
      clearStyle: true
    }), yb(t, r.keyframeAnimation, a);
  }
  function lX(n, t, e, r, i) {
    var a = t.isGroup ? null : t, s = i && i[n].cfg;
    if (a) {
      var o = a.ensureState(n);
      if (r === false) {
        var l = a.getState(n);
        l && (l.style = null);
      } else o.style = r || null;
      s && (o.textConfig = s), Xc(a);
    }
  }
  function Imt(n, t, e) {
    if (!n.isGroup) {
      var r = n, i = e.currentZ, a = e.currentZLevel;
      r.z = i, r.zlevel = a;
      var s = t.z2;
      s != null && (r.z2 = s || 0);
      for (var o = 0; o < Jl.length; o++) Amt(r, t, Jl[o]);
    }
  }
  function Amt(n, t, e) {
    var r = e === El, i = r ? t : xb(t, e), a = i ? i.z2 : null, s;
    a != null && (s = r ? n : n.ensureState(e), s.z2 = a || 0);
  }
  function bB(n, t, e, r) {
    var i = n.get("renderItem"), a = n.coordinateSystem, s = {};
    a && (s = a.prepareCustoms ? a.prepareCustoms(a) : Smt[a.type](a));
    for (var o = $t({
      getWidth: r.getWidth,
      getHeight: r.getHeight,
      getZr: r.getZr,
      getDevicePixelRatio: r.getDevicePixelRatio,
      value: b,
      style: w,
      ordinalRawValue: _,
      styleEmphasis: S,
      visual: A,
      barLayout: C,
      currentSeriesIndices: D,
      font: E
    }, s.api || {}), l = {
      context: {},
      seriesId: n.id,
      seriesName: n.name,
      seriesIndex: n.seriesIndex,
      coordSys: s.coordSys,
      dataInsideLength: t.count(),
      encode: kmt(n.getData())
    }, u, c, h = {}, f = {}, d = {}, p = {}, g = 0; g < Jl.length; g++) {
      var v = Jl[g];
      d[v] = n.getModel(zC[v]), p[v] = n.getModel(VC[v]);
    }
    function m(M) {
      return M === u ? c || (c = t.getItemModel(M)) : t.getItemModel(M);
    }
    function y(M, L) {
      return t.hasItemOption ? M === u ? h[L] || (h[L] = m(M).getModel(zC[L])) : m(M).getModel(zC[L]) : d[L];
    }
    function x(M, L) {
      return t.hasItemOption ? M === u ? f[L] || (f[L] = m(M).getModel(VC[L])) : m(M).getModel(VC[L]) : p[L];
    }
    return function(M, L) {
      return u = M, c = null, h = {}, f = {}, i && i($t({
        dataIndexInside: M,
        dataIndex: t.getRawIndex(M),
        actionType: L ? L.type : null
      }, l), o);
    };
    function b(M, L) {
      return L == null && (L = u), t.getStore().get(t.getDimensionIndex(M || 0), L);
    }
    function _(M, L) {
      L == null && (L = u), M = M || 0;
      var k = t.getDimensionInfo(M);
      if (!k) {
        var N = t.getDimensionIndex(M);
        return N >= 0 ? t.getStore().get(N, L) : void 0;
      }
      var R = t.get(k.name, L), $ = k && k.ordinalMeta;
      return $ ? $.categories[R] : R;
    }
    function w(M, L) {
      L == null && (L = u);
      var k = t.getItemVisual(L, "style"), N = k && k.fill, R = k && k.opacity, $ = y(L, El).getItemStyle();
      N != null && ($.fill = N), R != null && ($.opacity = R);
      var O = {
        inheritColor: wt(N) ? N : "#000"
      }, F = x(L, El), z = nn(F, null, O, false, true);
      z.text = F.getShallow("show") ? Ht(n.getFormattedLabel(L, El), Xf(t, L)) : null;
      var V = jx(F, O, false);
      return T(M, $), $ = gB($, z, V), M && I($, M), $.legacy = true, $;
    }
    function S(M, L) {
      L == null && (L = u);
      var k = y(L, Po).getItemStyle(), N = x(L, Po), R = nn(N, null, null, true, true);
      R.text = N.getShallow("show") ? Ws(n.getFormattedLabel(L, Po), n.getFormattedLabel(L, El), Xf(t, L)) : null;
      var $ = jx(N, null, true);
      return T(M, k), k = gB(k, R, $), M && I(k, M), k.legacy = true, k;
    }
    function I(M, L) {
      for (var k in L) Ct(L, k) && (M[k] = L[k]);
    }
    function T(M, L) {
      M && (M.textFill && (L.textFill = M.textFill), M.textPosition && (L.textPosition = M.textPosition));
    }
    function A(M, L) {
      if (L == null && (L = u), Ct(dB, M)) {
        var k = t.getItemVisual(L, "style");
        return k ? k[dB[M]] : null;
      }
      if (Ct(tmt, M)) return t.getItemVisual(L, M);
    }
    function C(M) {
      if (a.type === "cartesian2d") {
        var L = a.getBaseAxis();
        return mlt($t({
          axis: L
        }, M));
      }
    }
    function D() {
      return e.getCurrentSeriesIndices();
    }
    function E(M) {
      return rD(M, e);
    }
  }
  function kmt(n) {
    var t = {};
    return P(n.dimensions, function(e) {
      var r = n.getDimensionInfo(e);
      if (!r.isExtraCoord) {
        var i = r.coordDim, a = t[i] = t[i] || [];
        a[r.coordDimIndex] = n.getDimensionIndex(e);
      }
    }), t;
  }
  function GC(n, t, e, r, i, a, s) {
    if (!r) {
      a.remove(t);
      return;
    }
    var o = vE(n, t, e, r, i, a);
    return o && s.setItemGraphicEl(e, o), o && bn(o, r.focus, r.blurScope, r.emphasisDisabled), o;
  }
  function vE(n, t, e, r, i, a) {
    var s = -1, o = t;
    t && uX(t, r, i) && (s = ne(a.childrenRef(), t), t = null);
    var l = !t, u = t;
    u ? u.clearStates() : (u = pE(r), o && Cmt(o, u)), r.morph === false ? u.disableMorphing = true : u.disableMorphing && (u.disableMorphing = false), sa.normal.cfg = sa.normal.conOpt = sa.emphasis.cfg = sa.emphasis.conOpt = sa.blur.cfg = sa.blur.conOpt = sa.select.cfg = sa.select.conOpt = null, sa.isLegacy = false, Emt(u, e, r, i, l, sa), Dmt(u, e, r, i, l), gE(n, u, e, r, sa, i, l), Ct(r, "info") && (Lo(u).info = r.info);
    for (var c = 0; c < Jl.length; c++) {
      var h = Jl[c];
      if (h !== El) {
        var f = xb(r, h), d = mE(r, f, h);
        lX(h, u, f, d, sa);
      }
    }
    return Imt(u, r, i), r.type === "group" && Mmt(n, u, e, r, i), s >= 0 ? a.replaceAt(u, s) : a.add(u), u;
  }
  function uX(n, t, e) {
    var r = Lo(n), i = t.type, a = t.shape, s = t.style;
    return e.isUniversalTransitionEnabled() || i != null && i !== r.customGraphicType || i === "path" && Pmt(a) && cX(a) !== r.customPathData || i === "image" && Ct(s, "image") && s.image !== r.customImagePath;
  }
  function Dmt(n, t, e, r, i) {
    var a = e.clipPath;
    if (a === false) n && n.getClipPath() && n.removeClipPath();
    else if (a) {
      var s = n.getClipPath();
      s && uX(s, a, r) && (s = null), s || (s = pE(a), n.setClipPath(s)), gE(null, s, t, a, null, r, i);
    }
  }
  function Emt(n, t, e, r, i, a) {
    if (!n.isGroup) {
      _B(e, null, a), _B(e, Po, a);
      var s = a.normal.conOpt, o = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
      if (s != null || o != null || u != null || l != null) {
        var c = n.getTextContent();
        if (s === false) c && n.removeTextContent();
        else {
          s = a.normal.conOpt = s || {
            type: "text"
          }, c ? c.clearStates() : (c = pE(s), n.setTextContent(c)), gE(null, c, t, s, null, r, i);
          for (var h = s && s.style, f = 0; f < Jl.length; f++) {
            var d = Jl[f];
            if (d !== El) {
              var p = a[d].conOpt;
              lX(d, c, p, mE(s, p, d), null);
            }
          }
          h ? c.dirty() : c.markRedraw();
        }
      }
    }
  }
  function _B(n, t, e) {
    var r = t ? xb(n, t) : n, i = t ? mE(n, r, Po) : n.style, a = n.type, s = r ? r.textConfig : null, o = n.textContent, l = o ? t ? xb(o, t) : o : null;
    if (i && (e.isLegacy || nX(i, a, !!s, !!l))) {
      e.isLegacy = true;
      var u = rX(i, a, !t);
      !s && u.textConfig && (s = u.textConfig), !l && u.textContent && (l = u.textContent);
    }
    if (!t && l) {
      var c = l;
      !c.type && (c.type = "text");
    }
    var h = t ? e[t] : e.normal;
    h.cfg = s, h.conOpt = l;
  }
  function xb(n, t) {
    return t ? n ? n[t] : null : n;
  }
  function mE(n, t, e) {
    var r = t && t.style;
    return r == null && e === Po && n && (r = n.styleEmphasis), r;
  }
  function Mmt(n, t, e, r, i) {
    var a = r.children, s = a ? a.length : 0, o = r.$mergeChildren, l = o === "byName" || r.diffChildrenByName, u = o === false;
    if (!(!s && !l && !u)) {
      if (l) {
        Nmt({
          api: n,
          oldChildren: t.children() || [],
          newChildren: a || [],
          dataIndex: e,
          seriesModel: i,
          group: t
        });
        return;
      }
      u && t.removeAll();
      for (var c = 0; c < s; c++) {
        var h = a[c], f = t.childAt(c);
        h ? (h.ignore == null && (h.ignore = false), vE(n, f, e, h, i, t)) : f.ignore = true;
      }
      for (var d = t.childCount() - 1; d >= c; d--) {
        var p = t.childAt(d);
        Rmt(t, p, i);
      }
    }
  }
  function Rmt(n, t, e) {
    t && Q1(t, Lo(n).option, e);
  }
  function Nmt(n) {
    new Wo(n.oldChildren, n.newChildren, wB, wB, n).add(SB).update(SB).remove(Lmt).execute();
  }
  function wB(n, t) {
    var e = n && n.name;
    return e ?? wmt + t;
  }
  function SB(n, t) {
    var e = this.context, r = n != null ? e.newChildren[n] : null, i = t != null ? e.oldChildren[t] : null;
    vE(e.api, i, e.dataIndex, r, e.seriesModel, e.group);
  }
  function Lmt(n) {
    var t = this.context, e = t.oldChildren[n];
    e && Q1(e, Lo(e).option, t.seriesModel);
  }
  function cX(n) {
    return n && (n.pathData || n.d);
  }
  function Pmt(n) {
    return n && (Ct(n, "pathData") || Ct(n, "d"));
  }
  function $mt(n) {
    n.registerChartView(Tmt), n.registerSeriesModel(emt);
  }
  var hc = xe(), CB = Bt, WC = St, yE = function() {
    function n() {
      this._dragging = false, this.animationThreshold = 15;
    }
    return n.prototype.render = function(t, e, r, i) {
      var a = e.get("value"), s = e.get("status");
      if (this._axisModel = t, this._axisPointerModel = e, this._api = r, !(!i && this._lastValue === a && this._lastStatus === s)) {
        this._lastValue = a, this._lastStatus = s;
        var o = this._group, l = this._handle;
        if (!s || s === "hide") {
          o && o.hide(), l && l.hide();
          return;
        }
        o && o.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, t, e, r);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(r), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(t, e);
        if (!o) o = this._group = new Vt(), this.createPointerEl(o, u, t, e), this.createLabelEl(o, u, t, e), r.getZr().add(o);
        else {
          var f = qt(TB, e, h);
          this.updatePointerEl(o, u, f), this.updateLabelEl(o, u, f, e);
        }
        AB(o, e, true), this._renderHandle(a);
      }
    }, n.prototype.remove = function(t) {
      this.clear(t);
    }, n.prototype.dispose = function(t) {
      this.clear(t);
    }, n.prototype.determineAnimation = function(t, e) {
      var r = e.get("animation"), i = t.axis, a = i.type === "category", s = e.get("snap");
      if (!s && !a) return false;
      if (r === "auto" || r == null) {
        var o = this.animationThreshold;
        if (a && i.getBandWidth() > o) return true;
        if (s) {
          var l = zD(t).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > o;
        }
        return false;
      }
      return r === true;
    }, n.prototype.makeElOption = function(t, e, r, i, a) {
    }, n.prototype.createPointerEl = function(t, e, r, i) {
      var a = e.pointer;
      if (a) {
        var s = hc(t).pointerEl = new ph[a.type](CB(e.pointer));
        t.add(s);
      }
    }, n.prototype.createLabelEl = function(t, e, r, i) {
      if (e.label) {
        var a = hc(t).labelEl = new be(CB(e.label));
        t.add(a), IB(a, i);
      }
    }, n.prototype.updatePointerEl = function(t, e, r) {
      var i = hc(t).pointerEl;
      i && e.pointer && (i.setStyle(e.pointer.style), r(i, {
        shape: e.pointer.shape
      }));
    }, n.prototype.updateLabelEl = function(t, e, r, i) {
      var a = hc(t).labelEl;
      a && (a.setStyle(e.label.style), r(a, {
        x: e.label.x,
        y: e.label.y
      }), IB(a, i));
    }, n.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var e = this._axisPointerModel, r = this._api.getZr(), i = this._handle, a = e.getModel("handle"), s = e.get("status");
        if (!a.get("show") || !s || s === "hide") {
          i && r.remove(i), this._handle = null;
          return;
        }
        var o;
        this._handle || (o = true, i = this._handle = Fv(a.get("icon"), {
          cursor: "move",
          draggable: true,
          onmousemove: function(u) {
            Bo(u.event);
          },
          onmousedown: WC(this._onHandleDragMove, this, 0, 0),
          drift: WC(this._onHandleDragMove, this),
          ondragend: WC(this._onHandleDragEnd, this)
        }), r.add(i)), AB(i, e, false), i.setStyle(a.getItemStyle(null, [
          "color",
          "borderColor",
          "borderWidth",
          "opacity",
          "shadowColor",
          "shadowBlur",
          "shadowOffsetX",
          "shadowOffsetY"
        ]));
        var l = a.get("size");
        ct(l) || (l = [
          l,
          l
        ]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, kd(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, o);
      }
    }, n.prototype._moveHandleToValue = function(t, e) {
      TB(this._axisPointerModel, !e && this._moveAnimation, this._handle, UC(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, n.prototype._onHandleDragMove = function(t, e) {
      var r = this._handle;
      if (r) {
        this._dragging = true;
        var i = this.updateHandleTransform(UC(r), [
          t,
          e
        ], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, r.stopAnimation(), r.attr(UC(i)), hc(r).lastProp = null, this._doDispatchAxisPointer();
      }
    }, n.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var e = this._payloadInfo, r = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: e.cursorPoint[0],
          y: e.cursorPoint[1],
          tooltipOption: e.tooltipOption,
          axesInfo: [
            {
              axisDim: r.axis.dim,
              axisIndex: r.componentIndex
            }
          ]
        });
      }
    }, n.prototype._onHandleDragEnd = function() {
      this._dragging = false;
      var t = this._handle;
      if (t) {
        var e = this._axisPointerModel.get("value");
        this._moveHandleToValue(e), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, n.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var e = t.getZr(), r = this._group, i = this._handle;
      e && r && (this._lastGraphicKey = null, r && e.remove(r), i && e.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), Wg(this, "_doDispatchAxisPointer");
    }, n.prototype.doClear = function() {
    }, n.prototype.buildLabel = function(t, e, r) {
      return r = r || 0, {
        x: t[r],
        y: t[1 - r],
        width: e[r],
        height: e[1 - r]
      };
    }, n;
  }();
  function TB(n, t, e, r) {
    hX(hc(e).lastProp, r) || (hc(e).lastProp = r, t ? Ie(e, r, n) : (e.stopAnimation(), e.attr(r)));
  }
  function hX(n, t) {
    if (Ft(n) && Ft(t)) {
      var e = true;
      return P(t, function(r, i) {
        e = e && hX(n[i], r);
      }), !!e;
    } else return n === t;
  }
  function IB(n, t) {
    n[t.get([
      "label",
      "show"
    ]) ? "show" : "hide"]();
  }
  function UC(n) {
    return {
      x: n.x || 0,
      y: n.y || 0,
      rotation: n.rotation || 0
    };
  }
  function AB(n, t, e) {
    var r = t.get("z"), i = t.get("zlevel");
    n && n.traverse(function(a) {
      a.type !== "group" && (r != null && (a.z = r), i != null && (a.zlevel = i), a.silent = e);
    });
  }
  function xE(n) {
    var t = n.get("type"), e = n.getModel(t + "Style"), r;
    return t === "line" ? (r = e.getLineStyle(), r.fill = null) : t === "shadow" && (r = e.getAreaStyle(), r.stroke = null), r;
  }
  function fX(n, t, e, r, i) {
    var a = e.get("value"), s = dX(a, t.axis, t.ecModel, e.get("seriesDataIndices"), {
      precision: e.get([
        "label",
        "precision"
      ]),
      formatter: e.get([
        "label",
        "formatter"
      ])
    }), o = e.getModel("label"), l = Cd(o.get("padding") || 0), u = o.getFont(), c = Mv(s, u), h = i.position, f = c.width + l[1] + l[3], d = c.height + l[0] + l[2], p = i.align;
    p === "right" && (h[0] -= f), p === "center" && (h[0] -= f / 2);
    var g = i.verticalAlign;
    g === "bottom" && (h[1] -= d), g === "middle" && (h[1] -= d / 2), Omt(h, f, d, r);
    var v = o.get("backgroundColor");
    (!v || v === "auto") && (v = t.get([
      "axisLine",
      "lineStyle",
      "color"
    ])), n.label = {
      x: h[0],
      y: h[1],
      style: nn(o, {
        text: s,
        font: u,
        fill: o.getTextColor(),
        padding: l,
        backgroundColor: v
      }),
      z2: 10
    };
  }
  function Omt(n, t, e, r) {
    var i = r.getWidth(), a = r.getHeight();
    n[0] = Math.min(n[0] + t, i) - t, n[1] = Math.min(n[1] + e, a) - e, n[0] = Math.max(n[0], 0), n[1] = Math.max(n[1], 0);
  }
  function dX(n, t, e, r, i) {
    n = t.scale.parse(n);
    var a = t.scale.getLabel({
      value: n
    }, {
      precision: i.precision
    }), s = i.formatter;
    if (s) {
      var o = {
        value: DD(t, {
          value: n
        }),
        axisDimension: t.dim,
        axisIndex: t.index,
        seriesData: []
      };
      P(r, function(l) {
        var u = e.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
        h && o.seriesData.push(h);
      }), wt(s) ? a = s.replace("{value}", a) : Nt(s) && (a = s(o));
    }
    return a;
  }
  function bE(n, t, e) {
    var r = Xi();
    return fh(r, r, e.rotation), to(r, r, e.position), es([
      n.dataToCoord(t),
      (e.labelOffset || 0) + (e.labelDirection || 1) * (e.labelMargin || 0)
    ], r);
  }
  function pX(n, t, e, r, i, a) {
    var s = di.innerTextLayout(e.rotation, 0, e.labelDirection);
    e.labelMargin = i.get([
      "label",
      "margin"
    ]), fX(t, r, i, a, {
      position: bE(r.axis, n, e),
      align: s.textAlign,
      verticalAlign: s.textVerticalAlign
    });
  }
  function _E(n, t, e) {
    return e = e || 0, {
      x1: n[e],
      y1: n[1 - e],
      x2: t[e],
      y2: t[1 - e]
    };
  }
  function gX(n, t, e) {
    return e = e || 0, {
      x: n[e],
      y: n[1 - e],
      width: t[e],
      height: t[1 - e]
    };
  }
  function kB(n, t, e, r, i, a) {
    return {
      cx: n,
      cy: t,
      r0: e,
      r,
      startAngle: i,
      endAngle: a,
      clockwise: true
    };
  }
  var Fmt = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, r, i, a, s) {
      var o = i.axis, l = o.grid, u = a.get("type"), c = DB(l, o).getOtherAxis(o).getGlobalExtent(), h = o.toGlobalCoord(o.dataToCoord(r, true));
      if (u && u !== "none") {
        var f = xE(a), d = Bmt[u](o, h, c);
        d.style = f, e.graphicKey = d.type, e.pointer = d;
      }
      var p = CA(l.model, i);
      pX(r, e, p, i, a, s);
    }, t.prototype.getHandleTransform = function(e, r, i) {
      var a = CA(r.axis.grid.model, r, {
        labelInside: false
      });
      a.labelMargin = i.get([
        "handle",
        "margin"
      ]);
      var s = bE(r.axis, e, a);
      return {
        x: s[0],
        y: s[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(e, r, i, a) {
      var s = i.axis, o = s.grid, l = s.getGlobalExtent(true), u = DB(o, s).getOtherAxis(s).getGlobalExtent(), c = s.dim === "x" ? 0 : 1, h = [
        e.x,
        e.y
      ];
      h[c] += r[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var f = (u[1] + u[0]) / 2, d = [
        f,
        f
      ];
      d[c] = h[c];
      var p = [
        {
          verticalAlign: "middle"
        },
        {
          align: "center"
        }
      ];
      return {
        x: h[0],
        y: h[1],
        rotation: e.rotation,
        cursorPoint: d,
        tooltipOption: p[c]
      };
    }, t;
  }(yE);
  function DB(n, t) {
    var e = {};
    return e[t.dim + "AxisIndex"] = t.index, n.getCartesian(e);
  }
  var Bmt = {
    line: function(n, t, e) {
      var r = _E([
        t,
        e[0]
      ], [
        t,
        e[1]
      ], EB(n));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: r
      };
    },
    shadow: function(n, t, e) {
      var r = Math.max(1, n.getBandWidth()), i = e[1] - e[0];
      return {
        type: "Rect",
        shape: gX([
          t - r / 2,
          e[0]
        ], [
          r,
          i
        ], EB(n))
      };
    }
  };
  function EB(n) {
    return n.dim === "x" ? 0 : 1;
  }
  var zmt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "axisPointer", t.defaultOption = {
      show: "auto",
      z: 50,
      type: "line",
      snap: false,
      triggerTooltip: true,
      triggerEmphasis: true,
      value: null,
      status: null,
      link: [],
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: true,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [
          5,
          7,
          5,
          7
        ],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: false,
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        margin: 50,
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        throttle: 40
      }
    }, t;
  }(pe), Io = xe(), Vmt = P;
  function vX(n, t, e) {
    if (!ce.node) {
      var r = t.getZr();
      Io(r).records || (Io(r).records = {}), Gmt(r, t);
      var i = Io(r).records[n] || (Io(r).records[n] = {});
      i.handler = e;
    }
  }
  function Gmt(n, t) {
    if (Io(n).initialized) return;
    Io(n).initialized = true, e("click", qt(MB, "click")), e("mousemove", qt(MB, "mousemove")), e("globalout", Umt);
    function e(r, i) {
      n.on(r, function(a) {
        var s = Hmt(t);
        Vmt(Io(n).records, function(o) {
          o && i(o, a, s.dispatchAction);
        }), Wmt(s.pendings, t);
      });
    }
  }
  function Wmt(n, t) {
    var e = n.showTip.length, r = n.hideTip.length, i;
    e ? i = n.showTip[e - 1] : r && (i = n.hideTip[r - 1]), i && (i.dispatchAction = null, t.dispatchAction(i));
  }
  function Umt(n, t, e) {
    n.handler("leave", null, e);
  }
  function MB(n, t, e, r) {
    t.handler(n, e, r);
  }
  function Hmt(n) {
    var t = {
      showTip: [],
      hideTip: []
    }, e = function(r) {
      var i = t[r.type];
      i ? i.push(r) : (r.dispatchAction = e, n.dispatchAction(r));
    };
    return {
      dispatchAction: e,
      pendings: t
    };
  }
  function HA(n, t) {
    if (!ce.node) {
      var e = t.getZr(), r = (Io(e).records || {})[n];
      r && (Io(e).records[n] = null);
    }
  }
  var Xmt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = r.getComponent("tooltip"), s = e.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      vX("axisPointer", i, function(o, l, u) {
        s !== "none" && (o === "leave" || s.indexOf(o) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: o,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(e, r) {
      HA("axisPointer", r);
    }, t.prototype.dispose = function(e, r) {
      HA("axisPointer", r);
    }, t.type = "axisPointer", t;
  }(vn);
  function mX(n, t) {
    var e = [], r = n.seriesIndex, i;
    if (r == null || !(i = t.getSeriesByIndex(r))) return {
      point: []
    };
    var a = i.getData(), s = Uc(a, n);
    if (s == null || s < 0 || ct(s)) return {
      point: []
    };
    var o = a.getItemGraphicEl(s), l = i.coordinateSystem;
    if (i.getTooltipPosition) e = i.getTooltipPosition(s) || [];
    else if (l && l.dataToPoint) if (n.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, f = u.dim, d = h === "x" || h === "radius" ? 1 : 0, p = a.mapDimension(f), g = [];
      g[d] = a.get(p, s), g[1 - d] = a.get(a.getCalculationInfo("stackResultDimension"), s), e = l.dataToPoint(g) || [];
    } else e = l.dataToPoint(a.getValues(ht(l.dimensions, function(m) {
      return a.mapDimension(m);
    }), s)) || [];
    else if (o) {
      var v = o.getBoundingRect().clone();
      v.applyTransform(o.transform), e = [
        v.x + v.width / 2,
        v.y + v.height / 2
      ];
    }
    return {
      point: e,
      el: o
    };
  }
  var RB = xe();
  function Ymt(n, t, e) {
    var r = n.currTrigger, i = [
      n.x,
      n.y
    ], a = n, s = n.dispatchAction || St(e.dispatchAction, e), o = t.getComponent("axisPointer").coordSysAxesInfo;
    if (o) {
      yx(i) && (i = mX({
        seriesIndex: a.seriesIndex,
        dataIndex: a.dataIndex
      }, t).point);
      var l = yx(i), u = a.axesInfo, c = o.axesInfo, h = r === "leave" || yx(i), f = {}, d = {}, p = {
        list: [],
        map: {}
      }, g = {
        showPointer: qt(jmt, d),
        showTooltip: qt(Kmt, p)
      };
      P(o.coordSysMap, function(m, y) {
        var x = l || m.containPoint(i);
        P(o.coordSysAxesInfo[y], function(b, _) {
          var w = b.axis, S = tyt(u, b);
          if (!h && x && (!u || S)) {
            var I = S && S.value;
            I == null && !l && (I = w.pointToData(i)), I != null && NB(b, I, g, false, f);
          }
        });
      });
      var v = {};
      return P(c, function(m, y) {
        var x = m.linkGroup;
        x && !d[y] && P(x.axesInfo, function(b, _) {
          var w = d[_];
          if (b !== m && w) {
            var S = w.value;
            x.mapper && (S = m.axis.scale.parse(x.mapper(S, LB(b), LB(m)))), v[m.key] = S;
          }
        });
      }), P(v, function(m, y) {
        NB(c[y], m, g, true, f);
      }), Zmt(d, c, f), Jmt(p, i, n, s), Qmt(c, s, e), f;
    }
  }
  function NB(n, t, e, r, i) {
    var a = n.axis;
    if (!(a.scale.isBlank() || !a.containData(t))) {
      if (!n.involveSeries) {
        e.showPointer(n, t);
        return;
      }
      var s = qmt(t, n), o = s.payloadBatch, l = s.snapToValue;
      o[0] && i.seriesIndex == null && rt(i, o[0]), !r && n.snap && a.containData(l) && l != null && (t = l), e.showPointer(n, t, o), e.showTooltip(n, s, l);
    }
  }
  function qmt(n, t) {
    var e = t.axis, r = e.dim, i = n, a = [], s = Number.MAX_VALUE, o = -1;
    return P(t.seriesModels, function(l, u) {
      var c = l.getData().mapDimensionsAll(r), h, f;
      if (l.getAxisTooltipData) {
        var d = l.getAxisTooltipData(c, n, e);
        f = d.dataIndices, h = d.nestestValue;
      } else {
        if (f = l.getData().indicesOfNearest(c[0], n, e.type === "category" ? 0.5 : null), !f.length) return;
        h = l.getData().get(c[0], f[0]);
      }
      if (!(h == null || !isFinite(h))) {
        var p = n - h, g = Math.abs(p);
        g <= s && ((g < s || p >= 0 && o < 0) && (s = g, o = p, i = h, a.length = 0), P(f, function(v) {
          a.push({
            seriesIndex: l.seriesIndex,
            dataIndexInside: v,
            dataIndex: l.getData().getRawIndex(v)
          });
        }));
      }
    }), {
      payloadBatch: a,
      snapToValue: i
    };
  }
  function jmt(n, t, e, r) {
    n[t.key] = {
      value: e,
      payloadBatch: r
    };
  }
  function Kmt(n, t, e, r) {
    var i = e.payloadBatch, a = t.axis, s = a.model, o = t.axisPointerModel;
    if (!(!t.triggerTooltip || !i.length)) {
      var l = t.coordSys.model, u = Kg(l), c = n.map[u];
      c || (c = n.map[u] = {
        coordSysId: l.id,
        coordSysIndex: l.componentIndex,
        coordSysType: l.type,
        coordSysMainType: l.mainType,
        dataByAxis: []
      }, n.list.push(c)), c.dataByAxis.push({
        axisDim: a.dim,
        axisIndex: s.componentIndex,
        axisType: s.type,
        axisId: s.id,
        value: r,
        valueLabelOpt: {
          precision: o.get([
            "label",
            "precision"
          ]),
          formatter: o.get([
            "label",
            "formatter"
          ])
        },
        seriesDataIndices: i.slice()
      });
    }
  }
  function Zmt(n, t, e) {
    var r = e.axesInfo = [];
    P(t, function(i, a) {
      var s = i.axisPointerModel.option, o = n[a];
      o ? (!i.useHandle && (s.status = "show"), s.value = o.value, s.seriesDataIndices = (o.payloadBatch || []).slice()) : !i.useHandle && (s.status = "hide"), s.status === "show" && r.push({
        axisDim: i.axis.dim,
        axisIndex: i.axis.model.componentIndex,
        value: s.value
      });
    });
  }
  function Jmt(n, t, e, r) {
    if (yx(t) || !n.list.length) {
      r({
        type: "hideTip"
      });
      return;
    }
    var i = ((n.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    r({
      type: "showTip",
      escapeConnect: true,
      x: t[0],
      y: t[1],
      tooltipOption: e.tooltipOption,
      position: e.position,
      dataIndexInside: i.dataIndexInside,
      dataIndex: i.dataIndex,
      seriesIndex: i.seriesIndex,
      dataByCoordSys: n.list
    });
  }
  function Qmt(n, t, e) {
    var r = e.getZr(), i = "axisPointerLastHighlights", a = RB(r)[i] || {}, s = RB(r)[i] = {};
    P(n, function(u, c) {
      var h = u.axisPointerModel.option;
      h.status === "show" && u.triggerEmphasis && P(h.seriesDataIndices, function(f) {
        var d = f.seriesIndex + " | " + f.dataIndex;
        s[d] = f;
      });
    });
    var o = [], l = [];
    P(a, function(u, c) {
      !s[c] && l.push(u);
    }), P(s, function(u, c) {
      !a[c] && o.push(u);
    }), l.length && e.dispatchAction({
      type: "downplay",
      escapeConnect: true,
      notBlur: true,
      batch: l
    }), o.length && e.dispatchAction({
      type: "highlight",
      escapeConnect: true,
      notBlur: true,
      batch: o
    });
  }
  function tyt(n, t) {
    for (var e = 0; e < (n || []).length; e++) {
      var r = n[e];
      if (t.axis.dim === r.axisDim && t.axis.model.componentIndex === r.axisIndex) return r;
    }
  }
  function LB(n) {
    var t = n.axis.model, e = {}, r = e.axisDim = n.axis.dim;
    return e.axisIndex = e[r + "AxisIndex"] = t.componentIndex, e.axisName = e[r + "AxisName"] = t.name, e.axisId = e[r + "AxisId"] = t.id, e;
  }
  function yx(n) {
    return !n || n[0] == null || isNaN(n[0]) || n[1] == null || isNaN(n[1]);
  }
  function Zv(n) {
    yh.registerAxisPointerClass("CartesianAxisPointer", Fmt), n.registerComponentModel(zmt), n.registerComponentView(Xmt), n.registerPreprocessor(function(t) {
      if (t) {
        (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
        var e = t.axisPointer.link;
        e && !ct(e) && (t.axisPointer.link = [
          e
        ]);
      }
    }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function(t, e) {
      t.getComponent("axisPointer").coordSysAxesInfo = cht(t, e);
    }), n.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, Ymt);
  }
  function eyt(n) {
    se(H6), se(Zv);
  }
  var nyt = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, r, i, a, s) {
      var o = i.axis;
      o.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = o.polar, u = l.getOtherAxis(o), c = u.getExtent(), h = o.dataToCoord(r), f = a.get("type");
      if (f && f !== "none") {
        var d = xE(a), p = iyt[f](o, l, h, c);
        p.style = d, e.graphicKey = p.type, e.pointer = p;
      }
      var g = a.get([
        "label",
        "margin"
      ]), v = ryt(r, i, a, l, g);
      fX(e, i, a, s, v);
    }, t;
  }(yE);
  function ryt(n, t, e, r, i) {
    var a = t.axis, s = a.dataToCoord(n), o = r.getAngleAxis().getExtent()[0];
    o = o / 180 * Math.PI;
    var l = r.getRadiusAxis().getExtent(), u, c, h;
    if (a.dim === "radius") {
      var f = Xi();
      fh(f, f, o), to(f, f, [
        r.cx,
        r.cy
      ]), u = es([
        s,
        -i
      ], f);
      var d = t.getModel("axisLabel").get("rotate") || 0, p = di.innerTextLayout(o, d * Math.PI / 180, -1);
      c = p.textAlign, h = p.textVerticalAlign;
    } else {
      var g = l[1];
      u = r.coordToPoint([
        g + i,
        s
      ]);
      var v = r.cx, m = r.cy;
      c = Math.abs(u[0] - v) / g < 0.3 ? "center" : u[0] > v ? "left" : "right", h = Math.abs(u[1] - m) / g < 0.3 ? "middle" : u[1] > m ? "top" : "bottom";
    }
    return {
      position: u,
      align: c,
      verticalAlign: h
    };
  }
  var iyt = {
    line: function(n, t, e, r) {
      return n.dim === "angle" ? {
        type: "Line",
        shape: _E(t.coordToPoint([
          r[0],
          e
        ]), t.coordToPoint([
          r[1],
          e
        ]))
      } : {
        type: "Circle",
        shape: {
          cx: t.cx,
          cy: t.cy,
          r: e
        }
      };
    },
    shadow: function(n, t, e, r) {
      var i = Math.max(1, n.getBandWidth()), a = Math.PI / 180;
      return n.dim === "angle" ? {
        type: "Sector",
        shape: kB(t.cx, t.cy, r[0], r[1], (-e - i / 2) * a, (-e + i / 2) * a)
      } : {
        type: "Sector",
        shape: kB(t.cx, t.cy, e - i / 2, e + i / 2, 0, Math.PI * 2)
      };
    }
  }, ayt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.findAxisModel = function(e) {
      var r, i = this.ecModel;
      return i.eachComponent(e, function(a) {
        a.getCoordSysModel() === this && (r = a);
      }, this), r;
    }, t.type = "polar", t.dependencies = [
      "radiusAxis",
      "angleAxis"
    ], t.defaultOption = {
      z: 0,
      center: [
        "50%",
        "50%"
      ],
      radius: "80%"
    }, t;
  }(pe), wE = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", On).models[0];
    }, t.type = "polarAxis", t;
  }(pe);
  zn(wE, Gv);
  var syt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "angleAxis", t;
  }(wE), oyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "radiusAxis", t;
  }(wE), SE = function(n) {
    q(t, n);
    function t(e, r) {
      return n.call(this, "radius", e, r) || this;
    }
    return t.prototype.pointToData = function(e, r) {
      return this.polar.pointToData(e, r)[this.dim === "radius" ? 0 : 1];
    }, t;
  }(ds);
  SE.prototype.dataToRadius = ds.prototype.dataToCoord;
  SE.prototype.radiusToData = ds.prototype.coordToData;
  var lyt = xe(), CE = function(n) {
    q(t, n);
    function t(e, r) {
      return n.call(this, "angle", e, r || [
        0,
        360
      ]) || this;
    }
    return t.prototype.pointToData = function(e, r) {
      return this.polar.pointToData(e, r)[this.dim === "radius" ? 0 : 1];
    }, t.prototype.calculateCategoryInterval = function() {
      var e = this, r = e.getLabelModel(), i = e.scale, a = i.getExtent(), s = i.count();
      if (a[1] - a[0] < 1) return 0;
      var o = a[0], l = e.dataToCoord(o + 1) - e.dataToCoord(o), u = Math.abs(l), c = Mv(o == null ? "" : o + "", r.getFont(), "center", "top"), h = Math.max(c.height, 7), f = h / u;
      isNaN(f) && (f = 1 / 0);
      var d = Math.max(0, Math.floor(f)), p = lyt(e.model), g = p.lastAutoInterval, v = p.lastTickCount;
      return g != null && v != null && Math.abs(g - d) <= 1 && Math.abs(v - s) <= 1 && g > d ? d = g : (p.lastTickCount = s, p.lastAutoInterval = d), d;
    }, t;
  }(ds);
  CE.prototype.dataToAngle = ds.prototype.dataToCoord;
  CE.prototype.angleToData = ds.prototype.coordToData;
  var yX = [
    "radius",
    "angle"
  ], uyt = function() {
    function n(t) {
      this.dimensions = yX, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new SE(), this._angleAxis = new CE(), this.axisPointerEnabled = true, this.name = t || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return n.prototype.containPoint = function(t) {
      var e = this.pointToCoord(t);
      return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
    }, n.prototype.containData = function(t) {
      return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
    }, n.prototype.getAxis = function(t) {
      var e = "_" + t + "Axis";
      return this[e];
    }, n.prototype.getAxes = function() {
      return [
        this._radiusAxis,
        this._angleAxis
      ];
    }, n.prototype.getAxesByScale = function(t) {
      var e = [], r = this._angleAxis, i = this._radiusAxis;
      return r.scale.type === t && e.push(r), i.scale.type === t && e.push(i), e;
    }, n.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, n.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, n.prototype.getOtherAxis = function(t) {
      var e = this._angleAxis;
      return t === e ? this._radiusAxis : e;
    }, n.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, n.prototype.getTooltipAxes = function(t) {
      var e = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis();
      return {
        baseAxes: [
          e
        ],
        otherAxes: [
          this.getOtherAxis(e)
        ]
      };
    }, n.prototype.dataToPoint = function(t, e) {
      return this.coordToPoint([
        this._radiusAxis.dataToRadius(t[0], e),
        this._angleAxis.dataToAngle(t[1], e)
      ]);
    }, n.prototype.pointToData = function(t, e) {
      var r = this.pointToCoord(t);
      return [
        this._radiusAxis.radiusToData(r[0], e),
        this._angleAxis.angleToData(r[1], e)
      ];
    }, n.prototype.pointToCoord = function(t) {
      var e = t[0] - this.cx, r = t[1] - this.cy, i = this.getAngleAxis(), a = i.getExtent(), s = Math.min(a[0], a[1]), o = Math.max(a[0], a[1]);
      i.inverse ? s = o - 360 : o = s + 360;
      var l = Math.sqrt(e * e + r * r);
      e /= l, r /= l;
      for (var u = Math.atan2(-r, e) / Math.PI * 180, c = u < s ? 1 : -1; u < s || u > o; ) u += c * 360;
      return [
        l,
        u
      ];
    }, n.prototype.coordToPoint = function(t) {
      var e = t[0], r = t[1] / 180 * Math.PI, i = Math.cos(r) * e + this.cx, a = -Math.sin(r) * e + this.cy;
      return [
        i,
        a
      ];
    }, n.prototype.getArea = function() {
      var t = this.getAngleAxis(), e = this.getRadiusAxis(), r = e.getExtent().slice();
      r[0] > r[1] && r.reverse();
      var i = t.getExtent(), a = Math.PI / 180, s = 1e-4;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: r[0],
        r: r[1],
        startAngle: -i[0] * a,
        endAngle: -i[1] * a,
        clockwise: t.inverse,
        contain: function(o, l) {
          var u = o - this.cx, c = l - this.cy, h = u * u + c * c, f = this.r, d = this.r0;
          return f !== d && h - s <= f * f && h + s >= d * d;
        }
      };
    }, n.prototype.convertToPixel = function(t, e, r) {
      var i = PB(e);
      return i === this ? this.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(t, e, r) {
      var i = PB(e);
      return i === this ? this.pointToData(r) : null;
    }, n;
  }();
  function PB(n) {
    var t = n.seriesModel, e = n.polarModel;
    return e && e.coordinateSystem || t && t.coordinateSystem;
  }
  function cyt(n, t, e) {
    var r = t.get("center"), i = e.getWidth(), a = e.getHeight();
    n.cx = yt(r[0], i), n.cy = yt(r[1], a);
    var s = n.getRadiusAxis(), o = Math.min(i, a) / 2, l = t.get("radius");
    l == null ? l = [
      0,
      "100%"
    ] : ct(l) || (l = [
      0,
      l
    ]);
    var u = [
      yt(l[0], o),
      yt(l[1], o)
    ];
    s.inverse ? s.setExtent(u[1], u[0]) : s.setExtent(u[0], u[1]);
  }
  function hyt(n, t) {
    var e = this, r = e.getAngleAxis(), i = e.getRadiusAxis();
    if (r.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), n.eachSeries(function(o) {
      if (o.coordinateSystem === e) {
        var l = o.getData();
        P(sb(l, "radius"), function(u) {
          i.scale.unionExtentFromData(l, u);
        }), P(sb(l, "angle"), function(u) {
          r.scale.unionExtentFromData(l, u);
        });
      }
    }), Hf(r.scale, r.model), Hf(i.scale, i.model), r.type === "category" && !r.onBand) {
      var a = r.getExtent(), s = 360 / r.scale.count();
      r.inverse ? a[1] += s : a[1] -= s, r.setExtent(a[0], a[1]);
    }
  }
  function fyt(n) {
    return n.mainType === "angleAxis";
  }
  function $B(n, t) {
    var e;
    if (n.type = t.get("type"), n.scale = X1(t), n.onBand = t.get("boundaryGap") && n.type === "category", n.inverse = t.get("inverse"), fyt(t)) {
      n.inverse = n.inverse !== t.get("clockwise");
      var r = t.get("startAngle"), i = (e = t.get("endAngle")) !== null && e !== void 0 ? e : r + (n.inverse ? -360 : 360);
      n.setExtent(r, i);
    }
    t.axis = n, n.model = t;
  }
  var dyt = {
    dimensions: yX,
    create: function(n, t) {
      var e = [];
      return n.eachComponent("polar", function(r, i) {
        var a = new uyt(i + "");
        a.update = hyt;
        var s = a.getRadiusAxis(), o = a.getAngleAxis(), l = r.findAxisModel("radiusAxis"), u = r.findAxisModel("angleAxis");
        $B(s, l), $B(o, u), cyt(a, r, t), e.push(a), r.coordinateSystem = a, a.model = r;
      }), n.eachSeries(function(r) {
        if (r.get("coordinateSystem") === "polar") {
          var i = r.getReferringComponents("polar", On).models[0];
          r.coordinateSystem = i.coordinateSystem;
        }
      }), e;
    }
  }, pyt = [
    "axisLine",
    "axisLabel",
    "axisTick",
    "minorTick",
    "splitLine",
    "minorSplitLine",
    "splitArea"
  ];
  function f0(n, t, e) {
    t[1] > t[0] && (t = t.slice().reverse());
    var r = n.coordToPoint([
      t[0],
      e
    ]), i = n.coordToPoint([
      t[1],
      e
    ]);
    return {
      x1: r[0],
      y1: r[1],
      x2: i[0],
      y2: i[1]
    };
  }
  function d0(n) {
    var t = n.getRadiusAxis();
    return t.inverse ? 0 : 1;
  }
  function OB(n) {
    var t = n[0], e = n[n.length - 1];
    t && e && Math.abs(Math.abs(t.coord - e.coord) - 360) < 1e-4 && n.pop();
  }
  var gyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
    }
    return t.prototype.render = function(e, r) {
      if (this.group.removeAll(), !!e.get("show")) {
        var i = e.axis, a = i.polar, s = a.getRadiusAxis().getExtent(), o = i.getTicksCoords(), l = i.getMinorTicksCoords(), u = ht(i.getViewLabels(), function(c) {
          c = Bt(c);
          var h = i.scale, f = h.type === "ordinal" ? h.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(f), c;
        });
        OB(u), OB(o), P(pyt, function(c) {
          e.get([
            c,
            "show"
          ]) && (!i.scale.isBlank() || c === "axisLine") && vyt[c](this.group, e, a, o, l, s, u);
        }, this);
      }
    }, t.type = "angleAxis", t;
  }(yh), vyt = {
    axisLine: function(n, t, e, r, i, a) {
      var s = t.getModel([
        "axisLine",
        "lineStyle"
      ]), o = e.getAngleAxis(), l = Math.PI / 180, u = o.getExtent(), c = d0(e), h = c ? 0 : 1, f, d = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
      a[h] === 0 ? f = new ph[d]({
        shape: {
          cx: e.cx,
          cy: e.cy,
          r: a[c],
          startAngle: -u[0] * l,
          endAngle: -u[1] * l,
          clockwise: o.inverse
        },
        style: s.getLineStyle(),
        z2: 1,
        silent: true
      }) : f = new Lv({
        shape: {
          cx: e.cx,
          cy: e.cy,
          r: a[c],
          r0: a[h]
        },
        style: s.getLineStyle(),
        z2: 1,
        silent: true
      }), f.style.fill = null, n.add(f);
    },
    axisTick: function(n, t, e, r, i, a) {
      var s = t.getModel("axisTick"), o = (s.get("inside") ? -1 : 1) * s.get("length"), l = a[d0(e)], u = ht(r, function(c) {
        return new ir({
          shape: f0(e, [
            l,
            l + o
          ], c.coord)
        });
      });
      n.add(ya(u, {
        style: $t(s.getModel("lineStyle").getLineStyle(), {
          stroke: t.get([
            "axisLine",
            "lineStyle",
            "color"
          ])
        })
      }));
    },
    minorTick: function(n, t, e, r, i, a) {
      if (i.length) {
        for (var s = t.getModel("axisTick"), o = t.getModel("minorTick"), l = (s.get("inside") ? -1 : 1) * o.get("length"), u = a[d0(e)], c = [], h = 0; h < i.length; h++) for (var f = 0; f < i[h].length; f++) c.push(new ir({
          shape: f0(e, [
            u,
            u + l
          ], i[h][f].coord)
        }));
        n.add(ya(c, {
          style: $t(o.getModel("lineStyle").getLineStyle(), $t(s.getLineStyle(), {
            stroke: t.get([
              "axisLine",
              "lineStyle",
              "color"
            ])
          }))
        }));
      }
    },
    axisLabel: function(n, t, e, r, i, a, s) {
      var o = t.getCategories(true), l = t.getModel("axisLabel"), u = l.get("margin"), c = t.get("triggerEvent");
      P(s, function(h, f) {
        var d = l, p = h.tickValue, g = a[d0(e)], v = e.coordToPoint([
          g + u,
          h.coord
        ]), m = e.cx, y = e.cy, x = Math.abs(v[0] - m) / g < 0.3 ? "center" : v[0] > m ? "left" : "right", b = Math.abs(v[1] - y) / g < 0.3 ? "middle" : v[1] > y ? "top" : "bottom";
        if (o && o[p]) {
          var _ = o[p];
          Ft(_) && _.textStyle && (d = new $e(_.textStyle, l, l.ecModel));
        }
        var w = new be({
          silent: di.isLabelSilent(t),
          style: nn(d, {
            x: v[0],
            y: v[1],
            fill: d.getTextColor() || t.get([
              "axisLine",
              "lineStyle",
              "color"
            ]),
            text: h.formattedLabel,
            align: x,
            verticalAlign: b
          })
        });
        if (n.add(w), c) {
          var S = di.makeAxisEventDataBase(t);
          S.targetType = "axisLabel", S.value = h.rawLabel, Ut(w).eventData = S;
        }
      }, this);
    },
    splitLine: function(n, t, e, r, i, a) {
      var s = t.getModel("splitLine"), o = s.getModel("lineStyle"), l = o.get("color"), u = 0;
      l = l instanceof Array ? l : [
        l
      ];
      for (var c = [], h = 0; h < r.length; h++) {
        var f = u++ % l.length;
        c[f] = c[f] || [], c[f].push(new ir({
          shape: f0(e, a, r[h].coord)
        }));
      }
      for (var h = 0; h < c.length; h++) n.add(ya(c[h], {
        style: $t({
          stroke: l[h % l.length]
        }, o.getLineStyle()),
        silent: true,
        z: t.get("z")
      }));
    },
    minorSplitLine: function(n, t, e, r, i, a) {
      if (i.length) {
        for (var s = t.getModel("minorSplitLine"), o = s.getModel("lineStyle"), l = [], u = 0; u < i.length; u++) for (var c = 0; c < i[u].length; c++) l.push(new ir({
          shape: f0(e, a, i[u][c].coord)
        }));
        n.add(ya(l, {
          style: o.getLineStyle(),
          silent: true,
          z: t.get("z")
        }));
      }
    },
    splitArea: function(n, t, e, r, i, a) {
      if (r.length) {
        var s = t.getModel("splitArea"), o = s.getModel("areaStyle"), l = o.get("color"), u = 0;
        l = l instanceof Array ? l : [
          l
        ];
        for (var c = [], h = Math.PI / 180, f = -r[0].coord * h, d = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), g = t.get("clockwise"), v = 1, m = r.length; v <= m; v++) {
          var y = v === m ? r[0].coord : r[v].coord, x = u++ % l.length;
          c[x] = c[x] || [], c[x].push(new mi({
            shape: {
              cx: e.cx,
              cy: e.cy,
              r0: d,
              r: p,
              startAngle: f,
              endAngle: -y * h,
              clockwise: g
            },
            silent: true
          })), f = -y * h;
        }
        for (var v = 0; v < c.length; v++) n.add(ya(c[v], {
          style: $t({
            fill: l[v % l.length]
          }, o.getAreaStyle()),
          silent: true
        }));
      }
    }
  }, myt = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], yyt = [
    "splitLine",
    "splitArea",
    "minorSplitLine"
  ], xyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
    }
    return t.prototype.render = function(e, r) {
      if (this.group.removeAll(), !!e.get("show")) {
        var i = this._axisGroup, a = this._axisGroup = new Vt();
        this.group.add(a);
        var s = e.axis, o = s.polar, l = o.getAngleAxis(), u = s.getTicksCoords(), c = s.getMinorTicksCoords(), h = l.getExtent()[0], f = s.getExtent(), d = _yt(o, e, h), p = new di(e, d);
        P(myt, p.add, p), a.add(p.getGroup()), Ov(i, a, e), P(yyt, function(g) {
          e.get([
            g,
            "show"
          ]) && !s.scale.isBlank() && byt[g](this.group, e, o, h, f, u, c);
        }, this);
      }
    }, t.type = "radiusAxis", t;
  }(yh), byt = {
    splitLine: function(n, t, e, r, i, a) {
      var s = t.getModel("splitLine"), o = s.getModel("lineStyle"), l = o.get("color"), u = 0, c = e.getAngleAxis(), h = Math.PI / 180, f = c.getExtent(), d = Math.abs(f[1] - f[0]) === 360 ? "Circle" : "Arc";
      l = l instanceof Array ? l : [
        l
      ];
      for (var p = [], g = 0; g < a.length; g++) {
        var v = u++ % l.length;
        p[v] = p[v] || [], p[v].push(new ph[d]({
          shape: {
            cx: e.cx,
            cy: e.cy,
            r: Math.max(a[g].coord, 0),
            startAngle: -f[0] * h,
            endAngle: -f[1] * h,
            clockwise: c.inverse
          }
        }));
      }
      for (var g = 0; g < p.length; g++) n.add(ya(p[g], {
        style: $t({
          stroke: l[g % l.length],
          fill: null
        }, o.getLineStyle()),
        silent: true
      }));
    },
    minorSplitLine: function(n, t, e, r, i, a, s) {
      if (s.length) {
        for (var o = t.getModel("minorSplitLine"), l = o.getModel("lineStyle"), u = [], c = 0; c < s.length; c++) for (var h = 0; h < s[c].length; h++) u.push(new tl({
          shape: {
            cx: e.cx,
            cy: e.cy,
            r: s[c][h].coord
          }
        }));
        n.add(ya(u, {
          style: $t({
            fill: null
          }, l.getLineStyle()),
          silent: true
        }));
      }
    },
    splitArea: function(n, t, e, r, i, a) {
      if (a.length) {
        var s = t.getModel("splitArea"), o = s.getModel("areaStyle"), l = o.get("color"), u = 0;
        l = l instanceof Array ? l : [
          l
        ];
        for (var c = [], h = a[0].coord, f = 1; f < a.length; f++) {
          var d = u++ % l.length;
          c[d] = c[d] || [], c[d].push(new mi({
            shape: {
              cx: e.cx,
              cy: e.cy,
              r0: h,
              r: a[f].coord,
              startAngle: 0,
              endAngle: Math.PI * 2
            },
            silent: true
          })), h = a[f].coord;
        }
        for (var f = 0; f < c.length; f++) n.add(ya(c[f], {
          style: $t({
            fill: l[f % l.length]
          }, o.getAreaStyle()),
          silent: true
        }));
      }
    }
  };
  function _yt(n, t, e) {
    return {
      position: [
        n.cx,
        n.cy
      ],
      rotation: e / 180 * Math.PI,
      labelDirection: -1,
      tickDirection: -1,
      nameDirection: 1,
      labelRotate: t.getModel("axisLabel").get("rotate"),
      z2: 1
    };
  }
  function xX(n) {
    return n.get("stack") || "__ec_stack_" + n.seriesIndex;
  }
  function bX(n, t) {
    return t.dim + n.model.componentIndex;
  }
  function wyt(n, t, e) {
    var r = {}, i = Syt(Le(t.getSeriesByType(n), function(a) {
      return !t.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
    }));
    t.eachSeriesByType(n, function(a) {
      if (a.coordinateSystem.type === "polar") {
        var s = a.getData(), o = a.coordinateSystem, l = o.getBaseAxis(), u = bX(o, l), c = xX(a), h = i[u][c], f = h.offset, d = h.width, p = o.getOtherAxis(l), g = a.coordinateSystem.cx, v = a.coordinateSystem.cy, m = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
        r[c] = r[c] || [];
        for (var x = s.mapDimension(p.dim), b = s.mapDimension(l.dim), _ = Kl(s, x), w = l.dim !== "radius" || !a.get("roundCap", true), S = p.model, I = S.get("startValue"), T = p.dataToCoord(I || 0), A = 0, C = s.count(); A < C; A++) {
          var D = s.get(x, A), E = s.get(b, A), M = D >= 0 ? "p" : "n", L = T;
          _ && (r[c][E] || (r[c][E] = {
            p: T,
            n: T
          }), L = r[c][E][M]);
          var k = void 0, N = void 0, R = void 0, $ = void 0;
          if (p.dim === "radius") {
            var O = p.dataToCoord(D) - T, F = l.dataToCoord(E);
            Math.abs(O) < m && (O = (O < 0 ? -1 : 1) * m), k = L, N = L + O, R = F - f, $ = R - d, _ && (r[c][E][M] = N);
          } else {
            var z = p.dataToCoord(D, w) - T, V = l.dataToCoord(E);
            Math.abs(z) < y && (z = (z < 0 ? -1 : 1) * y), k = V + f, N = k + d, R = L, $ = L + z, _ && (r[c][E][M] = $);
          }
          s.setItemLayout(A, {
            cx: g,
            cy: v,
            r0: k,
            r: N,
            startAngle: -R * Math.PI / 180,
            endAngle: -$ * Math.PI / 180,
            clockwise: R >= $
          });
        }
      }
    });
  }
  function Syt(n) {
    var t = {};
    P(n, function(r, i) {
      var a = r.getData(), s = r.coordinateSystem, o = s.getBaseAxis(), l = bX(s, o), u = o.getExtent(), c = o.type === "category" ? o.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), h = t[l] || {
        bandWidth: c,
        remainedWidth: c,
        autoWidthCount: 0,
        categoryGap: "20%",
        gap: "30%",
        stacks: {}
      }, f = h.stacks;
      t[l] = h;
      var d = xX(r);
      f[d] || h.autoWidthCount++, f[d] = f[d] || {
        width: 0,
        maxWidth: 0
      };
      var p = yt(r.get("barWidth"), c), g = yt(r.get("barMaxWidth"), c), v = r.get("barGap"), m = r.get("barCategoryGap");
      p && !f[d].width && (p = Math.min(h.remainedWidth, p), f[d].width = p, h.remainedWidth -= p), g && (f[d].maxWidth = g), v != null && (h.gap = v), m != null && (h.categoryGap = m);
    });
    var e = {};
    return P(t, function(r, i) {
      e[i] = {};
      var a = r.stacks, s = r.bandWidth, o = yt(r.categoryGap, s), l = yt(r.gap, 1), u = r.remainedWidth, c = r.autoWidthCount, h = (u - o) / (c + (c - 1) * l);
      h = Math.max(h, 0), P(a, function(g, v) {
        var m = g.maxWidth;
        m && m < h && (m = Math.min(m, u), g.width && (m = Math.min(m, g.width)), u -= m, g.width = m, c--);
      }), h = (u - o) / (c + (c - 1) * l), h = Math.max(h, 0);
      var f = 0, d;
      P(a, function(g, v) {
        g.width || (g.width = h), d = g, f += g.width * (1 + l);
      }), d && (f -= d.width * l);
      var p = -f / 2;
      P(a, function(g, v) {
        e[i][v] = e[i][v] || {
          offset: p,
          width: g.width
        }, p += g.width * (1 + l);
      });
    }), e;
  }
  var Cyt = {
    startAngle: 90,
    clockwise: true,
    splitNumber: 12,
    axisLabel: {
      rotate: 0
    }
  }, Tyt = {
    splitNumber: 5
  }, Iyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "polar", t;
  }(vn);
  function Ayt(n) {
    se(Zv), yh.registerAxisPointerClass("PolarAxisPointer", nyt), n.registerCoordinateSystem("polar", dyt), n.registerComponentModel(ayt), n.registerComponentView(Iyt), Yf(n, "angle", syt, Cyt), Yf(n, "radius", oyt, Tyt), n.registerComponentView(gyt), n.registerComponentView(xyt), n.registerLayout(qt(wyt, "bar"));
  }
  function XA(n, t) {
    t = t || {};
    var e = n.coordinateSystem, r = n.axis, i = {}, a = r.position, s = r.orient, o = e.getRect(), l = [
      o.x,
      o.x + o.width,
      o.y,
      o.y + o.height
    ], u = {
      horizontal: {
        top: l[2],
        bottom: l[3]
      },
      vertical: {
        left: l[0],
        right: l[1]
      }
    };
    i.position = [
      s === "vertical" ? u.vertical[a] : l[0],
      s === "horizontal" ? u.horizontal[a] : l[3]
    ];
    var c = {
      horizontal: 0,
      vertical: 1
    };
    i.rotation = Math.PI / 2 * c[s];
    var h = {
      top: -1,
      bottom: 1,
      right: 1,
      left: -1
    };
    i.labelDirection = i.tickDirection = i.nameDirection = h[a], n.get([
      "axisTick",
      "inside"
    ]) && (i.tickDirection = -i.tickDirection), mr(t.labelInside, n.get([
      "axisLabel",
      "inside"
    ])) && (i.labelDirection = -i.labelDirection);
    var f = t.rotate;
    return f == null && (f = n.get([
      "axisLabel",
      "rotate"
    ])), i.labelRotation = a === "top" ? -f : f, i.z2 = 1, i;
  }
  var kyt = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], Dyt = [
    "splitArea",
    "splitLine"
  ], Eyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "SingleAxisPointer", e;
    }
    return t.prototype.render = function(e, r, i, a) {
      var s = this.group;
      s.removeAll();
      var o = this._axisGroup;
      this._axisGroup = new Vt();
      var l = XA(e), u = new di(e, l);
      P(kyt, u.add, u), s.add(this._axisGroup), s.add(u.getGroup()), P(Dyt, function(c) {
        e.get([
          c,
          "show"
        ]) && Myt[c](this, this.group, this._axisGroup, e);
      }, this), Ov(o, this._axisGroup, e), n.prototype.render.call(this, e, r, i, a);
    }, t.prototype.remove = function() {
      G6(this);
    }, t.type = "singleAxis", t;
  }(yh), Myt = {
    splitLine: function(n, t, e, r) {
      var i = r.axis;
      if (!i.scale.isBlank()) {
        var a = r.getModel("splitLine"), s = a.getModel("lineStyle"), o = s.get("color");
        o = o instanceof Array ? o : [
          o
        ];
        for (var l = s.get("width"), u = r.coordinateSystem.getRect(), c = i.isHorizontal(), h = [], f = 0, d = i.getTicksCoords({
          tickModel: a
        }), p = [], g = [], v = 0; v < d.length; ++v) {
          var m = i.toGlobalCoord(d[v].coord);
          c ? (p[0] = m, p[1] = u.y, g[0] = m, g[1] = u.y + u.height) : (p[0] = u.x, p[1] = m, g[0] = u.x + u.width, g[1] = m);
          var y = new ir({
            shape: {
              x1: p[0],
              y1: p[1],
              x2: g[0],
              y2: g[1]
            },
            silent: true
          });
          Gf(y.shape, l);
          var x = f++ % o.length;
          h[x] = h[x] || [], h[x].push(y);
        }
        for (var b = s.getLineStyle([
          "color"
        ]), v = 0; v < h.length; ++v) t.add(ya(h[v], {
          style: $t({
            stroke: o[v % o.length]
          }, b),
          silent: true
        }));
      }
    },
    splitArea: function(n, t, e, r) {
      V6(n, e, r, r);
    }
  }, xx = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getCoordSysModel = function() {
      return this;
    }, t.type = "singleAxis", t.layoutMode = "box", t.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: true,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      tooltip: {
        show: true
      },
      axisTick: {
        show: true,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        interval: "auto"
      },
      splitLine: {
        show: true,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, t;
  }(pe);
  zn(xx, Gv.prototype);
  var Ryt = function(n) {
    q(t, n);
    function t(e, r, i, a, s) {
      var o = n.call(this, e, r, i) || this;
      return o.type = a || "value", o.position = s || "bottom", o;
    }
    return t.prototype.isHorizontal = function() {
      var e = this.position;
      return e === "top" || e === "bottom";
    }, t.prototype.pointToData = function(e, r) {
      return this.coordinateSystem.pointToData(e)[0];
    }, t;
  }(ds), _X = [
    "single"
  ], Nyt = function() {
    function n(t, e, r) {
      this.type = "single", this.dimension = "single", this.dimensions = _X, this.axisPointerEnabled = true, this.model = t, this._init(t, e, r);
    }
    return n.prototype._init = function(t, e, r) {
      var i = this.dimension, a = new Ryt(i, X1(t), [
        0,
        0
      ], t.get("type"), t.get("position")), s = a.type === "category";
      a.onBand = s && t.get("boundaryGap"), a.inverse = t.get("inverse"), a.orient = t.get("orient"), t.axis = a, a.model = t, a.coordinateSystem = this, this._axis = a;
    }, n.prototype.update = function(t, e) {
      t.eachSeries(function(r) {
        if (r.coordinateSystem === this) {
          var i = r.getData();
          P(i.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(i, a);
          }, this), Hf(this._axis.scale, this._axis.model);
        }
      }, this);
    }, n.prototype.resize = function(t, e) {
      this._rect = Zn({
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      }, {
        width: e.getWidth(),
        height: e.getHeight()
      }), this._adjustAxis();
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype._adjustAxis = function() {
      var t = this._rect, e = this._axis, r = e.isHorizontal(), i = r ? [
        0,
        t.width
      ] : [
        0,
        t.height
      ], a = e.inverse ? 1 : 0;
      e.setExtent(i[a], i[1 - a]), this._updateAxisTransform(e, r ? t.x : t.y);
    }, n.prototype._updateAxisTransform = function(t, e) {
      var r = t.getExtent(), i = r[0] + r[1], a = t.isHorizontal();
      t.toGlobalCoord = a ? function(s) {
        return s + e;
      } : function(s) {
        return i - s + e;
      }, t.toLocalCoord = a ? function(s) {
        return s - e;
      } : function(s) {
        return i - s + e;
      };
    }, n.prototype.getAxis = function() {
      return this._axis;
    }, n.prototype.getBaseAxis = function() {
      return this._axis;
    }, n.prototype.getAxes = function() {
      return [
        this._axis
      ];
    }, n.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [
          this.getAxis()
        ],
        otherAxes: []
      };
    }, n.prototype.containPoint = function(t) {
      var e = this.getRect(), r = this.getAxis(), i = r.orient;
      return i === "horizontal" ? r.contain(r.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : r.contain(r.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
    }, n.prototype.pointToData = function(t) {
      var e = this.getAxis();
      return [
        e.coordToData(e.toLocalCoord(t[e.orient === "horizontal" ? 0 : 1]))
      ];
    }, n.prototype.dataToPoint = function(t) {
      var e = this.getAxis(), r = this.getRect(), i = [], a = e.orient === "horizontal" ? 0 : 1;
      return t instanceof Array && (t = t[0]), i[a] = e.toGlobalCoord(e.dataToCoord(+t)), i[1 - a] = a === 0 ? r.y + r.height / 2 : r.x + r.width / 2, i;
    }, n.prototype.convertToPixel = function(t, e, r) {
      var i = FB(e);
      return i === this ? this.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(t, e, r) {
      var i = FB(e);
      return i === this ? this.pointToData(r) : null;
    }, n;
  }();
  function FB(n) {
    var t = n.seriesModel, e = n.singleAxisModel;
    return e && e.coordinateSystem || t && t.coordinateSystem;
  }
  function Lyt(n, t) {
    var e = [];
    return n.eachComponent("singleAxis", function(r, i) {
      var a = new Nyt(r, n, t);
      a.name = "single_" + i, a.resize(r, t), r.coordinateSystem = a, e.push(a);
    }), n.eachSeries(function(r) {
      if (r.get("coordinateSystem") === "singleAxis") {
        var i = r.getReferringComponents("singleAxis", On).models[0];
        r.coordinateSystem = i && i.coordinateSystem;
      }
    }), e;
  }
  var Pyt = {
    create: Lyt,
    dimensions: _X
  }, BB = [
    "x",
    "y"
  ], $yt = [
    "width",
    "height"
  ], Oyt = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, r, i, a, s) {
      var o = i.axis, l = o.coordinateSystem, u = HC(l, 1 - bb(o)), c = l.dataToPoint(r)[0], h = a.get("type");
      if (h && h !== "none") {
        var f = xE(a), d = Fyt[h](o, c, u);
        d.style = f, e.graphicKey = d.type, e.pointer = d;
      }
      var p = XA(i);
      pX(r, e, p, i, a, s);
    }, t.prototype.getHandleTransform = function(e, r, i) {
      var a = XA(r, {
        labelInside: false
      });
      a.labelMargin = i.get([
        "handle",
        "margin"
      ]);
      var s = bE(r.axis, e, a);
      return {
        x: s[0],
        y: s[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(e, r, i, a) {
      var s = i.axis, o = s.coordinateSystem, l = bb(s), u = HC(o, l), c = [
        e.x,
        e.y
      ];
      c[l] += r[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var h = HC(o, 1 - l), f = (h[1] + h[0]) / 2, d = [
        f,
        f
      ];
      return d[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: e.rotation,
        cursorPoint: d,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, t;
  }(yE), Fyt = {
    line: function(n, t, e) {
      var r = _E([
        t,
        e[0]
      ], [
        t,
        e[1]
      ], bb(n));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: r
      };
    },
    shadow: function(n, t, e) {
      var r = n.getBandWidth(), i = e[1] - e[0];
      return {
        type: "Rect",
        shape: gX([
          t - r / 2,
          e[0]
        ], [
          r,
          i
        ], bb(n))
      };
    }
  };
  function bb(n) {
    return n.isHorizontal() ? 0 : 1;
  }
  function HC(n, t) {
    var e = n.getRect();
    return [
      e[BB[t]],
      e[BB[t]] + e[$yt[t]]
    ];
  }
  var Byt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "single", t;
  }(vn);
  function zyt(n) {
    se(Zv), yh.registerAxisPointerClass("SingleAxisPointer", Oyt), n.registerComponentView(Byt), n.registerComponentView(Eyt), n.registerComponentModel(xx), Yf(n, "single", xx, xx.defaultOption), n.registerCoordinateSystem("single", Pyt);
  }
  var Vyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, r, i) {
      var a = Td(e);
      n.prototype.init.apply(this, arguments), zB(e, a);
    }, t.prototype.mergeOption = function(e) {
      n.prototype.mergeOption.apply(this, arguments), zB(this.option, e);
    }, t.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, t.type = "calendar", t.defaultOption = {
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: "horizontal",
      splitLine: {
        show: true,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      dayLabel: {
        show: true,
        firstDay: 0,
        position: "start",
        margin: "50%",
        color: "#000"
      },
      monthLabel: {
        show: true,
        position: "start",
        margin: 5,
        align: "center",
        formatter: null,
        color: "#000"
      },
      yearLabel: {
        show: true,
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, t;
  }(pe);
  function zB(n, t) {
    var e = n.cellSize, r;
    ct(e) ? r = e : r = n.cellSize = [
      e,
      e
    ], r.length === 1 && (r[1] = r[0]);
    var i = ht([
      0,
      1
    ], function(a) {
      return oat(t, a) && (r[a] = "auto"), r[a] != null && r[a] !== "auto";
    });
    jl(n, t, {
      type: "box",
      ignoreSize: i
    });
  }
  var Gyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      var a = this.group;
      a.removeAll();
      var s = e.coordinateSystem, o = s.getRangeInfo(), l = s.getOrient(), u = r.getLocaleModel();
      this._renderDayRect(e, o, a), this._renderLines(e, o, l, a), this._renderYearText(e, o, l, a), this._renderMonthText(e, u, l, a), this._renderWeekText(e, u, o, l, a);
    }, t.prototype._renderDayRect = function(e, r, i) {
      for (var a = e.coordinateSystem, s = e.getModel("itemStyle").getItemStyle(), o = a.getCellWidth(), l = a.getCellHeight(), u = r.start.time; u <= r.end.time; u = a.getNextNDay(u, 1).time) {
        var c = a.dataToRect([
          u
        ], false).tl, h = new ye({
          shape: {
            x: c[0],
            y: c[1],
            width: o,
            height: l
          },
          cursor: "default",
          style: s
        });
        i.add(h);
      }
    }, t.prototype._renderLines = function(e, r, i, a) {
      var s = this, o = e.coordinateSystem, l = e.getModel([
        "splitLine",
        "lineStyle"
      ]).getLineStyle(), u = e.get([
        "splitLine",
        "show"
      ]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var h = r.start, f = 0; h.time <= r.end.time; f++) {
        p(h.formatedDate), f === 0 && (h = o.getDateInfo(r.start.y + "-" + r.start.m));
        var d = h.date;
        d.setMonth(d.getMonth() + 1), h = o.getDateInfo(d);
      }
      p(o.getNextNDay(r.end.time, 1).formatedDate);
      function p(g) {
        s._firstDayOfMonth.push(o.getDateInfo(g)), s._firstDayPoints.push(o.dataToRect([
          g
        ], false).tl);
        var v = s._getLinePointsOfOneWeek(e, g, i);
        s._tlpoints.push(v[0]), s._blpoints.push(v[v.length - 1]), u && s._drawSplitline(v, l, a);
      }
      u && this._drawSplitline(s._getEdgesPoints(s._tlpoints, c, i), l, a), u && this._drawSplitline(s._getEdgesPoints(s._blpoints, c, i), l, a);
    }, t.prototype._getEdgesPoints = function(e, r, i) {
      var a = [
        e[0].slice(),
        e[e.length - 1].slice()
      ], s = i === "horizontal" ? 0 : 1;
      return a[0][s] = a[0][s] - r / 2, a[1][s] = a[1][s] + r / 2, a;
    }, t.prototype._drawSplitline = function(e, r, i) {
      var a = new _i({
        z2: 20,
        shape: {
          points: e
        },
        style: r
      });
      i.add(a);
    }, t.prototype._getLinePointsOfOneWeek = function(e, r, i) {
      for (var a = e.coordinateSystem, s = a.getDateInfo(r), o = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(s.time, l), c = a.dataToRect([
          u.time
        ], false);
        o[2 * u.day] = c.tl, o[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return o;
    }, t.prototype._formatterLabel = function(e, r) {
      return wt(e) && e ? iat(e, r) : Nt(e) ? e(r) : r.nameMap;
    }, t.prototype._yearTextPositionControl = function(e, r, i, a, s) {
      var o = r[0], l = r[1], u = [
        "center",
        "bottom"
      ];
      a === "bottom" ? (l += s, u = [
        "center",
        "top"
      ]) : a === "left" ? o -= s : a === "right" ? (o += s, u = [
        "center",
        "top"
      ]) : l -= s;
      var c = 0;
      return (a === "left" || a === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: o,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, t.prototype._renderYearText = function(e, r, i, a) {
      var s = e.getModel("yearLabel");
      if (s.get("show")) {
        var o = s.get("margin"), l = s.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [
          this._tlpoints[this._tlpoints.length - 1],
          this._blpoints[0]
        ], c = (u[0][0] + u[1][0]) / 2, h = (u[0][1] + u[1][1]) / 2, f = i === "horizontal" ? 0 : 1, d = {
          top: [
            c,
            u[f][1]
          ],
          bottom: [
            c,
            u[1 - f][1]
          ],
          left: [
            u[1 - f][0],
            h
          ],
          right: [
            u[f][0],
            h
          ]
        }, p = r.start.y;
        +r.end.y > +r.start.y && (p = p + "-" + r.end.y);
        var g = s.get("formatter"), v = {
          start: r.start.y,
          end: r.end.y,
          nameMap: p
        }, m = this._formatterLabel(g, v), y = new be({
          z2: 30,
          style: nn(s, {
            text: m
          }),
          silent: s.get("silent")
        });
        y.attr(this._yearTextPositionControl(y, d[l], i, l, o)), a.add(y);
      }
    }, t.prototype._monthTextPositionControl = function(e, r, i, a, s) {
      var o = "left", l = "top", u = e[0], c = e[1];
      return i === "horizontal" ? (c = c + s, r && (o = "center"), a === "start" && (l = "bottom")) : (u = u + s, r && (l = "middle"), a === "start" && (o = "right")), {
        x: u,
        y: c,
        align: o,
        verticalAlign: l
      };
    }, t.prototype._renderMonthText = function(e, r, i, a) {
      var s = e.getModel("monthLabel");
      if (s.get("show")) {
        var o = s.get("nameMap"), l = s.get("margin"), u = s.get("position"), c = s.get("align"), h = [
          this._tlpoints,
          this._blpoints
        ];
        (!o || wt(o)) && (o && (r = tA(o) || r), o = r.get([
          "time",
          "monthAbbr"
        ]) || []);
        var f = u === "start" ? 0 : 1, d = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", g = s.get("silent"), v = 0; v < h[f].length - 1; v++) {
          var m = h[f][v].slice(), y = this._firstDayOfMonth[v];
          if (p) {
            var x = this._firstDayPoints[v];
            m[d] = (x[d] + h[0][v + 1][d]) / 2;
          }
          var b = s.get("formatter"), _ = o[+y.m - 1], w = {
            yyyy: y.y,
            yy: (y.y + "").slice(2),
            MM: y.m,
            M: +y.m,
            nameMap: _
          }, S = this._formatterLabel(b, w), I = new be({
            z2: 30,
            style: rt(nn(s, {
              text: S
            }), this._monthTextPositionControl(m, p, i, u, l)),
            silent: g
          });
          a.add(I);
        }
      }
    }, t.prototype._weekTextPositionControl = function(e, r, i, a, s) {
      var o = "center", l = "middle", u = e[0], c = e[1], h = i === "start";
      return r === "horizontal" ? (u = u + a + (h ? 1 : -1) * s[0] / 2, o = h ? "right" : "left") : (c = c + a + (h ? 1 : -1) * s[1] / 2, l = h ? "bottom" : "top"), {
        x: u,
        y: c,
        align: o,
        verticalAlign: l
      };
    }, t.prototype._renderWeekText = function(e, r, i, a, s) {
      var o = e.getModel("dayLabel");
      if (o.get("show")) {
        var l = e.coordinateSystem, u = o.get("position"), c = o.get("nameMap"), h = o.get("margin"), f = l.getFirstDayOfWeek();
        if (!c || wt(c)) {
          c && (r = tA(c) || r);
          var d = r.get([
            "time",
            "dayOfWeekShort"
          ]);
          c = d || ht(r.get([
            "time",
            "dayOfWeekAbbr"
          ]), function(w) {
            return w[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, g = [
          l.getCellWidth(),
          l.getCellHeight()
        ];
        h = yt(h, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, h = -h);
        for (var v = o.get("silent"), m = 0; m < 7; m++) {
          var y = l.getNextNDay(p, m), x = l.dataToRect([
            y.time
          ], false).center, b = m;
          b = Math.abs((m + f) % 7);
          var _ = new be({
            z2: 30,
            style: rt(nn(o, {
              text: c[b]
            }), this._weekTextPositionControl(x, a, u, h, g)),
            silent: v
          });
          s.add(_);
        }
      }
    }, t.type = "calendar", t;
  }(vn), XC = 864e5, Wyt = function() {
    function n(t, e, r) {
      this.type = "calendar", this.dimensions = n.dimensions, this.getDimensionsInfo = n.getDimensionsInfo, this._model = t;
    }
    return n.getDimensionsInfo = function() {
      return [
        {
          name: "time",
          type: "time"
        },
        "value"
      ];
    }, n.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, n.prototype.getModel = function() {
      return this._model;
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype.getCellWidth = function() {
      return this._sw;
    }, n.prototype.getCellHeight = function() {
      return this._sh;
    }, n.prototype.getOrient = function() {
      return this._orient;
    }, n.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, n.prototype.getDateInfo = function(t) {
      t = no(t);
      var e = t.getFullYear(), r = t.getMonth() + 1, i = r < 10 ? "0" + r : "" + r, a = t.getDate(), s = a < 10 ? "0" + a : "" + a, o = t.getDay();
      return o = Math.abs((o + 7 - this.getFirstDayOfWeek()) % 7), {
        y: e + "",
        m: i,
        d: s,
        day: o,
        time: t.getTime(),
        formatedDate: e + "-" + i + "-" + s,
        date: t
      };
    }, n.prototype.getNextNDay = function(t, e) {
      return e = e || 0, e === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + e), this.getDateInfo(t));
    }, n.prototype.update = function(t, e) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var r = this._rangeInfo.weeks || 1, i = [
        "width",
        "height"
      ], a = this._model.getCellSize().slice(), s = this._model.getBoxLayoutParams(), o = this._orient === "horizontal" ? [
        r,
        7
      ] : [
        7,
        r
      ];
      P([
        0,
        1
      ], function(h) {
        c(a, h) && (s[i[h]] = a[h] * o[h]);
      });
      var l = {
        width: e.getWidth(),
        height: e.getHeight()
      }, u = this._rect = Zn(s, l);
      P([
        0,
        1
      ], function(h) {
        c(a, h) || (a[h] = u[i[h]] / o[h]);
      });
      function c(h, f) {
        return h[f] != null && h[f] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, n.prototype.dataToPoint = function(t, e) {
      ct(t) && (t = t[0]), e == null && (e = true);
      var r = this.getDateInfo(t), i = this._rangeInfo, a = r.formatedDate;
      if (e && !(r.time >= i.start.time && r.time < i.end.time + XC)) return [
        NaN,
        NaN
      ];
      var s = r.day, o = this._getRangeInfo([
        i.start.time,
        a
      ]).nthWeek;
      return this._orient === "vertical" ? [
        this._rect.x + s * this._sw + this._sw / 2,
        this._rect.y + o * this._sh + this._sh / 2
      ] : [
        this._rect.x + o * this._sw + this._sw / 2,
        this._rect.y + s * this._sh + this._sh / 2
      ];
    }, n.prototype.pointToData = function(t) {
      var e = this.pointToDate(t);
      return e && e.time;
    }, n.prototype.dataToRect = function(t, e) {
      var r = this.dataToPoint(t, e);
      return {
        contentShape: {
          x: r[0] - (this._sw - this._lineWidth) / 2,
          y: r[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: r,
        tl: [
          r[0] - this._sw / 2,
          r[1] - this._sh / 2
        ],
        tr: [
          r[0] + this._sw / 2,
          r[1] - this._sh / 2
        ],
        br: [
          r[0] + this._sw / 2,
          r[1] + this._sh / 2
        ],
        bl: [
          r[0] - this._sw / 2,
          r[1] + this._sh / 2
        ]
      };
    }, n.prototype.pointToDate = function(t) {
      var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1, r = Math.floor((t[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(r, e - 1, i) : this._getDateByWeeksAndDay(e, r - 1, i);
    }, n.prototype.convertToPixel = function(t, e, r) {
      var i = VB(e);
      return i === this ? i.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(t, e, r) {
      var i = VB(e);
      return i === this ? i.pointToData(r) : null;
    }, n.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), false;
    }, n.prototype._initRangeOption = function() {
      var t = this._model.get("range"), e;
      if (ct(t) && t.length === 1 && (t = t[0]), ct(t)) e = t;
      else {
        var r = t.toString();
        if (/^\d{4}$/.test(r) && (e = [
          r + "-01-01",
          r + "-12-31"
        ]), /^\d{4}[\/|-]\d{1,2}$/.test(r)) {
          var i = this.getDateInfo(r), a = i.date;
          a.setMonth(a.getMonth() + 1);
          var s = this.getNextNDay(a, -1);
          e = [
            i.formatedDate,
            s.formatedDate
          ];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(r) && (e = [
          r,
          r
        ]);
      }
      if (!e) return t;
      var o = this._getRangeInfo(e);
      return o.start.time > o.end.time && e.reverse(), e;
    }, n.prototype._getRangeInfo = function(t) {
      var e = [
        this.getDateInfo(t[0]),
        this.getDateInfo(t[1])
      ], r;
      e[0].time > e[1].time && (r = true, e.reverse());
      var i = Math.floor(e[1].time / XC) - Math.floor(e[0].time / XC) + 1, a = new Date(e[0].time), s = a.getDate(), o = e[1].date.getDate();
      a.setDate(s + i - 1);
      var l = a.getDate();
      if (l !== o) for (var u = a.getTime() - e[1].time > 0 ? 1 : -1; (l = a.getDate()) !== o && (a.getTime() - e[1].time) * u > 0; ) i -= u, a.setDate(l - u);
      var c = Math.floor((i + e[0].day + 6) / 7), h = r ? -c + 1 : c - 1;
      return r && e.reverse(), {
        range: [
          e[0].formatedDate,
          e[1].formatedDate
        ],
        start: e[0],
        end: e[1],
        allDay: i,
        weeks: c,
        nthWeek: h,
        fweek: e[0].day,
        lweek: e[1].day
      };
    }, n.prototype._getDateByWeeksAndDay = function(t, e, r) {
      var i = this._getRangeInfo(r);
      if (t > i.weeks || t === 0 && e < i.fweek || t === i.weeks && e > i.lweek) return null;
      var a = (t - 1) * 7 - i.fweek + e, s = new Date(i.start.time);
      return s.setDate(+i.start.d + a), this.getDateInfo(s);
    }, n.create = function(t, e) {
      var r = [];
      return t.eachComponent("calendar", function(i) {
        var a = new n(i);
        r.push(a), i.coordinateSystem = a;
      }), t.eachSeries(function(i) {
        i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = r[i.get("calendarIndex") || 0]);
      }), r;
    }, n.dimensions = [
      "time",
      "value"
    ], n;
  }();
  function VB(n) {
    var t = n.calendarModel, e = n.seriesModel, r = t ? t.coordinateSystem : e ? e.coordinateSystem : null;
    return r;
  }
  function Uyt(n) {
    n.registerComponentModel(Vyt), n.registerComponentView(Gyt), n.registerCoordinateSystem("calendar", Wyt);
  }
  function Hyt(n, t) {
    var e = n.existing;
    if (t.id = n.keyInfo.id, !t.type && e && (t.type = e.type), t.parentId == null) {
      var r = t.parentOption;
      r ? t.parentId = r.id : e && (t.parentId = e.parentId);
    }
    t.parentOption = null;
  }
  function GB(n, t) {
    var e;
    return P(t, function(r) {
      n[r] != null && n[r] !== "auto" && (e = true);
    }), e;
  }
  function Xyt(n, t, e) {
    var r = rt({}, e), i = n[t], a = e.$action || "merge";
    a === "merge" ? i ? (Zt(i, r, true), jl(i, r, {
      ignoreSize: true
    }), d5(e, i), p0(e, i), p0(e, i, "shape"), p0(e, i, "style"), p0(e, i, "extra"), e.clipPath = i.clipPath) : n[t] = r : a === "replace" ? n[t] = r : a === "remove" && i && (n[t] = null);
  }
  var wX = [
    "transition",
    "enterFrom",
    "leaveTo"
  ], Yyt = wX.concat([
    "enterAnimation",
    "updateAnimation",
    "leaveAnimation"
  ]);
  function p0(n, t, e) {
    if (e && (!n[e] && t[e] && (n[e] = {}), n = n[e], t = t[e]), !(!n || !t)) for (var r = e ? wX : Yyt, i = 0; i < r.length; i++) {
      var a = r[i];
      n[a] == null && t[a] != null && (n[a] = t[a]);
    }
  }
  function qyt(n, t) {
    if (n && (n.hv = t.hv = [
      GB(t, [
        "left",
        "right"
      ]),
      GB(t, [
        "top",
        "bottom"
      ])
    ], n.type === "group")) {
      var e = n, r = t;
      e.width == null && (e.width = r.width = 0), e.height == null && (e.height = r.height = 0);
    }
  }
  var jyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.preventAutoZ = true, e;
    }
    return t.prototype.mergeOption = function(e, r) {
      var i = this.option.elements;
      this.option.elements = null, n.prototype.mergeOption.call(this, e, r), this.option.elements = i;
    }, t.prototype.optionUpdated = function(e, r) {
      var i = this.option, a = (r ? i : e).elements, s = i.elements = r ? [] : i.elements, o = [];
      this._flatten(a, o, null);
      var l = uU(s, o, "normalMerge"), u = this._elOptionsToUpdate = [];
      P(l, function(c, h) {
        var f = c.newOption;
        f && (u.push(f), Hyt(c, f), Xyt(s, h, f), qyt(s[h], f));
      }, this), i.elements = Le(s, function(c) {
        return c && delete c.$action, c != null;
      });
    }, t.prototype._flatten = function(e, r, i) {
      P(e, function(a) {
        if (a) {
          i && (a.parentOption = i), r.push(a);
          var s = a.children;
          s && s.length && this._flatten(s, r, a), delete a.children;
        }
      }, this);
    }, t.prototype.useElOptionsToUpdate = function() {
      var e = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, e;
    }, t.type = "graphic", t.defaultOption = {
      elements: []
    }, t;
  }(pe), WB = {
    path: null,
    compoundPath: null,
    group: Vt,
    image: br,
    text: be
  }, pa = xe(), Kyt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this._elMap = It();
    }, t.prototype.render = function(e, r, i) {
      e !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = e, this._updateElements(e), this._relocate(e, i);
    }, t.prototype._updateElements = function(e) {
      var r = e.useElOptionsToUpdate();
      if (r) {
        var i = this._elMap, a = this.group, s = e.get("z"), o = e.get("zlevel");
        P(r, function(l) {
          var u = Un(l.id, null), c = u != null ? i.get(u) : null, h = Un(l.parentId, null), f = h != null ? i.get(h) : a, d = l.type, p = l.style;
          d === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, v = l.textConfig;
          if (p && nX(p, d, !!v, !!g)) {
            var m = rX(p, d, true);
            !v && m.textConfig && (v = l.textConfig = m.textConfig), !g && m.textContent && (g = m.textContent);
          }
          var y = Zyt(l), x = l.$action || "merge", b = x === "merge", _ = x === "replace";
          if (b) {
            var w = !c, S = c;
            w ? S = UB(u, f, l.type, i) : (S && (pa(S).isNew = false), oX(S)), S && (mx(S, y, e, {
              isInit: w
            }), HB(S, l, s, o));
          } else if (_) {
            bx(c, l, i, e);
            var I = UB(u, f, l.type, i);
            I && (mx(I, y, e, {
              isInit: true
            }), HB(I, l, s, o));
          } else x === "remove" && (aX(c, l), bx(c, l, i, e));
          var T = i.get(u);
          if (T && g) if (b) {
            var A = T.getTextContent();
            A ? A.attr(g) : T.setTextContent(new be(g));
          } else _ && T.setTextContent(new be(g));
          if (T) {
            var C = l.clipPath;
            if (C) {
              var D = C.type, E = void 0, w = false;
              if (b) {
                var M = T.getClipPath();
                w = !M || pa(M).type !== D, E = w ? YA(D) : M;
              } else _ && (w = true, E = YA(D));
              T.setClipPath(E), mx(E, C, e, {
                isInit: w
              }), yb(E, C.keyframeAnimation, e);
            }
            var L = pa(T);
            T.setTextConfig(v), L.option = l, Jyt(T, e, l), dh({
              el: T,
              componentModel: e,
              itemName: T.name,
              itemTooltipOption: l.tooltip
            }), yb(T, l.keyframeAnimation, e);
          }
        });
      }
    }, t.prototype._relocate = function(e, r) {
      for (var i = e.option.elements, a = this.group, s = this._elMap, o = r.getWidth(), l = r.getHeight(), u = [
        "x",
        "y"
      ], c = 0; c < i.length; c++) {
        var h = i[c], f = Un(h.id, null), d = f != null ? s.get(f) : null;
        if (!(!d || !d.isGroup)) {
          var p = d.parent, g = p === a, v = pa(d), m = pa(p);
          v.width = yt(v.option.width, g ? o : m.width) || 0, v.height = yt(v.option.height, g ? l : m.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var h = i[c], f = Un(h.id, null), d = f != null ? s.get(f) : null;
        if (d) {
          var p = d.parent, m = pa(p), y = p === a ? {
            width: o,
            height: l
          } : {
            width: m.width,
            height: m.height
          }, x = {}, b = O1(d, h, y, null, {
            hv: h.hv,
            boundingMode: h.bounding
          }, x);
          if (!pa(d).isNew && b) {
            for (var _ = h.transition, w = {}, S = 0; S < u.length; S++) {
              var I = u[S], T = x[I];
              _ && (Oc(_) || ne(_, I) >= 0) ? w[I] = T : d[I] = T;
            }
            Ie(d, w, e, 0);
          } else d.attr(x);
        }
      }
    }, t.prototype._clear = function() {
      var e = this, r = this._elMap;
      r.each(function(i) {
        bx(i, pa(i).option, r, e._lastGraphicModel);
      }), this._elMap = It();
    }, t.prototype.dispose = function() {
      this._clear();
    }, t.type = "graphic", t;
  }(vn);
  function YA(n) {
    var t = Ct(WB, n) ? WB[n] : nD(n), e = new t({});
    return pa(e).type = n, e;
  }
  function UB(n, t, e, r) {
    var i = YA(e);
    return t.add(i), r.set(n, i), pa(i).id = n, pa(i).isNew = true, i;
  }
  function bx(n, t, e, r) {
    var i = n && n.parent;
    i && (n.type === "group" && n.traverse(function(a) {
      bx(a, t, e, r);
    }), Q1(n, t, r), e.removeKey(pa(n).id));
  }
  function HB(n, t, e, r) {
    n.isGroup || P([
      [
        "cursor",
        Ia.prototype.cursor
      ],
      [
        "zlevel",
        r || 0
      ],
      [
        "z",
        e || 0
      ],
      [
        "z2",
        0
      ]
    ], function(i) {
      var a = i[0];
      Ct(t, a) ? n[a] = Ht(t[a], i[1]) : n[a] == null && (n[a] = i[1]);
    }), P(ge(t), function(i) {
      if (i.indexOf("on") === 0) {
        var a = t[i];
        n[i] = Nt(a) ? a : null;
      }
    }), Ct(t, "draggable") && (n.draggable = t.draggable), t.name != null && (n.name = t.name), t.id != null && (n.id = t.id);
  }
  function Zyt(n) {
    return n = rt({}, n), P([
      "id",
      "parentId",
      "$action",
      "hv",
      "bounding",
      "textContent",
      "clipPath"
    ].concat(f5), function(t) {
      delete n[t];
    }), n;
  }
  function Jyt(n, t, e) {
    var r = Ut(n).eventData;
    !n.silent && !n.ignore && !r && (r = Ut(n).eventData = {
      componentType: "graphic",
      componentIndex: t.componentIndex,
      name: n.name
    }), r && (r.info = e.info);
  }
  function Qyt(n) {
    n.registerComponentModel(jyt), n.registerComponentView(Kyt), n.registerPreprocessor(function(t) {
      var e = t.graphic;
      ct(e) ? !e[0] || !e[0].elements ? t.graphic = [
        {
          elements: e
        }
      ] : t.graphic = [
        t.graphic[0]
      ] : e && !e.elements && (t.graphic = [
        {
          elements: [
            e
          ]
        }
      ]);
    });
  }
  var XB = [
    "x",
    "y",
    "radius",
    "angle",
    "single"
  ], t0t = [
    "cartesian2d",
    "polar",
    "singleAxis"
  ];
  function e0t(n) {
    var t = n.get("coordinateSystem");
    return ne(t0t, t) >= 0;
  }
  function Ml(n) {
    return n + "Axis";
  }
  function n0t(n, t) {
    var e = It(), r = [], i = It();
    n.eachComponent({
      mainType: "dataZoom",
      query: t
    }, function(c) {
      i.get(c.uid) || o(c);
    });
    var a;
    do
      a = false, n.eachComponent("dataZoom", s);
    while (a);
    function s(c) {
      !i.get(c.uid) && l(c) && (o(c), a = true);
    }
    function o(c) {
      i.set(c.uid, true), r.push(c), u(c);
    }
    function l(c) {
      var h = false;
      return c.eachTargetAxis(function(f, d) {
        var p = e.get(f);
        p && p[d] && (h = true);
      }), h;
    }
    function u(c) {
      c.eachTargetAxis(function(h, f) {
        (e.get(h) || e.set(h, []))[f] = true;
      });
    }
    return r;
  }
  function SX(n) {
    var t = n.ecModel, e = {
      infoList: [],
      infoMap: It()
    };
    return n.eachTargetAxis(function(r, i) {
      var a = t.getComponent(Ml(r), i);
      if (a) {
        var s = a.getCoordSysModel();
        if (s) {
          var o = s.uid, l = e.infoMap.get(o);
          l || (l = {
            model: s,
            axisModels: []
          }, e.infoList.push(l), e.infoMap.set(o, l)), l.axisModels.push(a);
        }
      }
    }), e;
  }
  var YC = function() {
    function n() {
      this.indexList = [], this.indexMap = [];
    }
    return n.prototype.add = function(t) {
      this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = true);
    }, n;
  }(), nv = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._autoThrottle = true, e._noTarget = true, e._rangePropMode = [
        "percent",
        "percent"
      ], e;
    }
    return t.prototype.init = function(e, r, i) {
      var a = YB(e);
      this.settledOption = a, this.mergeDefaultAndTheme(e, i), this._doInit(a);
    }, t.prototype.mergeOption = function(e) {
      var r = YB(e);
      Zt(this.option, e, true), Zt(this.settledOption, r, true), this._doInit(r);
    }, t.prototype._doInit = function(e) {
      var r = this.option;
      this._setDefaultThrottle(e), this._updateRangeUse(e);
      var i = this.settledOption;
      P([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a, s) {
        this._rangePropMode[s] === "value" && (r[a[0]] = i[a[0]] = null);
      }, this), this._resetTarget();
    }, t.prototype._resetTarget = function() {
      var e = this.get("orient", true), r = this._targetAxisInfoMap = It(), i = this._fillSpecifiedTargetAxis(r);
      i ? this._orient = e || this._makeAutoOrientByTargetAxis() : (this._orient = e || "horizontal", this._fillAutoTargetAxisByOrient(r, this._orient)), this._noTarget = true, r.each(function(a) {
        a.indexList.length && (this._noTarget = false);
      }, this);
    }, t.prototype._fillSpecifiedTargetAxis = function(e) {
      var r = false;
      return P(XB, function(i) {
        var a = this.getReferringComponents(Ml(i), Ynt);
        if (a.specified) {
          r = true;
          var s = new YC();
          P(a.models, function(o) {
            s.add(o.componentIndex);
          }), e.set(i, s);
        }
      }, this), r;
    }, t.prototype._fillAutoTargetAxisByOrient = function(e, r) {
      var i = this.ecModel, a = true;
      if (a) {
        var s = r === "vertical" ? "y" : "x", o = i.findComponents({
          mainType: s + "Axis"
        });
        l(o, s);
      }
      if (a) {
        var o = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", true) === r;
          }
        });
        l(o, "single");
      }
      function l(u, c) {
        var h = u[0];
        if (h) {
          var f = new YC();
          if (f.add(h.componentIndex), e.set(c, f), a = false, c === "x" || c === "y") {
            var d = h.getReferringComponents("grid", On).models[0];
            d && P(u, function(p) {
              h.componentIndex !== p.componentIndex && d === p.getReferringComponents("grid", On).models[0] && f.add(p.componentIndex);
            });
          }
        }
      }
      a && P(XB, function(u) {
        if (a) {
          var c = i.findComponents({
            mainType: Ml(u),
            filter: function(f) {
              return f.get("type", true) === "category";
            }
          });
          if (c[0]) {
            var h = new YC();
            h.add(c[0].componentIndex), e.set(u, h), a = false;
          }
        }
      }, this);
    }, t.prototype._makeAutoOrientByTargetAxis = function() {
      var e;
      return this.eachTargetAxis(function(r) {
        !e && (e = r);
      }, this), e === "y" ? "vertical" : "horizontal";
    }, t.prototype._setDefaultThrottle = function(e) {
      if (e.hasOwnProperty("throttle") && (this._autoThrottle = false), this._autoThrottle) {
        var r = this.ecModel.option;
        this.option.throttle = r.animation && r.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, t.prototype._updateRangeUse = function(e) {
      var r = this._rangePropMode, i = this.get("rangeMode");
      P([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a, s) {
        var o = e[a[0]] != null, l = e[a[1]] != null;
        o && !l ? r[s] = "percent" : !o && l ? r[s] = "value" : i ? r[s] = i[s] : o && (r[s] = "percent");
      });
    }, t.prototype.noTarget = function() {
      return this._noTarget;
    }, t.prototype.getFirstTargetAxisModel = function() {
      var e;
      return this.eachTargetAxis(function(r, i) {
        e == null && (e = this.ecModel.getComponent(Ml(r), i));
      }, this), e;
    }, t.prototype.eachTargetAxis = function(e, r) {
      this._targetAxisInfoMap.each(function(i, a) {
        P(i.indexList, function(s) {
          e.call(r, a, s);
        });
      });
    }, t.prototype.getAxisProxy = function(e, r) {
      var i = this.getAxisModel(e, r);
      if (i) return i.__dzAxisProxy;
    }, t.prototype.getAxisModel = function(e, r) {
      var i = this._targetAxisInfoMap.get(e);
      if (i && i.indexMap[r]) return this.ecModel.getComponent(Ml(e), r);
    }, t.prototype.setRawRange = function(e) {
      var r = this.option, i = this.settledOption;
      P([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a) {
        (e[a[0]] != null || e[a[1]] != null) && (r[a[0]] = i[a[0]] = e[a[0]], r[a[1]] = i[a[1]] = e[a[1]]);
      }, this), this._updateRangeUse(e);
    }, t.prototype.setCalculatedRange = function(e) {
      var r = this.option;
      P([
        "start",
        "startValue",
        "end",
        "endValue"
      ], function(i) {
        r[i] = e[i];
      });
    }, t.prototype.getPercentRange = function() {
      var e = this.findRepresentativeAxisProxy();
      if (e) return e.getDataPercentWindow();
    }, t.prototype.getValueRange = function(e, r) {
      if (e == null && r == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i) return i.getDataValueWindow();
      } else return this.getAxisProxy(e, r).getDataValueWindow();
    }, t.prototype.findRepresentativeAxisProxy = function(e) {
      if (e) return e.__dzAxisProxy;
      for (var r, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++) for (var s = i[a], o = this._targetAxisInfoMap.get(s), l = 0; l < o.indexList.length; l++) {
        var u = this.getAxisProxy(s, o.indexList[l]);
        if (u.hostedBy(this)) return u;
        r || (r = u);
      }
      return r;
    }, t.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, t.prototype.getOrient = function() {
      return this._orient;
    }, t.type = "dataZoom", t.dependencies = [
      "xAxis",
      "yAxis",
      "radiusAxis",
      "angleAxis",
      "singleAxis",
      "series",
      "toolbox"
    ], t.defaultOption = {
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, t;
  }(pe);
  function YB(n) {
    var t = {};
    return P([
      "start",
      "end",
      "startValue",
      "endValue",
      "throttle"
    ], function(e) {
      n.hasOwnProperty(e) && (t[e] = n[e]);
    }), t;
  }
  var r0t = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.select", t;
  }(nv), TE = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i, a) {
      this.dataZoomModel = e, this.ecModel = r, this.api = i;
    }, t.type = "dataZoom", t;
  }(vn), i0t = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.select", t;
  }(TE), ff = P, qB = _a, a0t = function() {
    function n(t, e, r, i) {
      this._dimName = t, this._axisIndex = e, this.ecModel = i, this._dataZoomModel = r;
    }
    return n.prototype.hostedBy = function(t) {
      return this._dataZoomModel === t;
    }, n.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, n.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, n.prototype.getTargetSeriesModels = function() {
      var t = [];
      return this.ecModel.eachSeries(function(e) {
        if (e0t(e)) {
          var r = Ml(this._dimName), i = e.getReferringComponents(r, On).models[0];
          i && this._axisIndex === i.componentIndex && t.push(e);
        }
      }, this), t;
    }, n.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, n.prototype.getMinMaxSpan = function() {
      return Bt(this._minMaxSpan);
    }, n.prototype.calculateDataWindow = function(t) {
      var e = this._dataExtent, r = this.getAxisModel(), i = r.axis.scale, a = this._dataZoomModel.getRangePropMode(), s = [
        0,
        100
      ], o = [], l = [], u;
      ff([
        "start",
        "end"
      ], function(f, d) {
        var p = t[f], g = t[f + "Value"];
        a[d] === "percent" ? (p == null && (p = s[d]), g = i.parse(Pe(p, s, e))) : (u = true, g = g == null ? e[d] : i.parse(g), p = Pe(g, e, s)), l[d] = g == null || isNaN(g) ? e[d] : g, o[d] = p == null || isNaN(p) ? s[d] : p;
      }), qB(l), qB(o);
      var c = this._minMaxSpan;
      u ? h(l, o, e, s, false) : h(o, l, s, e, true);
      function h(f, d, p, g, v) {
        var m = v ? "Span" : "ValueSpan";
        xh(0, f, p, "all", c["min" + m], c["max" + m]);
        for (var y = 0; y < 2; y++) d[y] = Pe(f[y], p, g, true), v && (d[y] = i.parse(d[y]));
      }
      return {
        valueWindow: l,
        percentWindow: o
      };
    }, n.prototype.reset = function(t) {
      if (t === this._dataZoomModel) {
        var e = this.getTargetSeriesModels();
        this._dataExtent = s0t(this, this._dimName, e), this._updateMinMaxSpan();
        var r = this.calculateDataWindow(t.settledOption);
        this._valueWindow = r.valueWindow, this._percentWindow = r.percentWindow, this._setAxisModel();
      }
    }, n.prototype.filterData = function(t, e) {
      if (t !== this._dataZoomModel) return;
      var r = this._dimName, i = this.getTargetSeriesModels(), a = t.get("filterMode"), s = this._valueWindow;
      if (a === "none") return;
      ff(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(r);
        if (c.length) {
          if (a === "weakFilter") {
            var h = u.getStore(), f = ht(c, function(d) {
              return u.getDimensionIndex(d);
            }, u);
            u.filterSelf(function(d) {
              for (var p, g, v, m = 0; m < c.length; m++) {
                var y = h.get(f[m], d), x = !isNaN(y), b = y < s[0], _ = y > s[1];
                if (x && !b && !_) return true;
                x && (v = true), b && (p = true), _ && (g = true);
              }
              return v && p && g;
            });
          } else ff(c, function(d) {
            if (a === "empty") l.setData(u = u.map(d, function(g) {
              return o(g) ? g : NaN;
            }));
            else {
              var p = {};
              p[d] = s, u.selectRange(p);
            }
          });
          ff(c, function(d) {
            u.setApproximateExtent(s, d);
          });
        }
      });
      function o(l) {
        return l >= s[0] && l <= s[1];
      }
    }, n.prototype._updateMinMaxSpan = function() {
      var t = this._minMaxSpan = {}, e = this._dataZoomModel, r = this._dataExtent;
      ff([
        "min",
        "max"
      ], function(i) {
        var a = e.get(i + "Span"), s = e.get(i + "ValueSpan");
        s != null && (s = this.getAxisModel().axis.scale.parse(s)), s != null ? a = Pe(r[0] + s, r, [
          0,
          100
        ], true) : a != null && (s = Pe(a, [
          0,
          100
        ], r, true) - r[0]), t[i + "Span"] = a, t[i + "ValueSpan"] = s;
      }, this);
    }, n.prototype._setAxisModel = function() {
      var t = this.getAxisModel(), e = this._percentWindow, r = this._valueWindow;
      if (e) {
        var i = eU(r, [
          0,
          500
        ]);
        i = Math.min(i, 20);
        var a = t.axis.scale.rawExtentInfo;
        e[0] !== 0 && a.setDeterminedMinMax("min", +r[0].toFixed(i)), e[1] !== 100 && a.setDeterminedMinMax("max", +r[1].toFixed(i)), a.freeze();
      }
    }, n;
  }();
  function s0t(n, t, e) {
    var r = [
      1 / 0,
      -1 / 0
    ];
    ff(e, function(s) {
      Blt(r, s.getData(), t);
    });
    var i = n.getAxisModel(), a = VH(i.axis.scale, i, r).calculate();
    return [
      a.min,
      a.max
    ];
  }
  var o0t = {
    getTargetSeries: function(n) {
      function t(i) {
        n.eachComponent("dataZoom", function(a) {
          a.eachTargetAxis(function(s, o) {
            var l = n.getComponent(Ml(s), o);
            i(s, o, l, a);
          });
        });
      }
      t(function(i, a, s, o) {
        s.__dzAxisProxy = null;
      });
      var e = [];
      t(function(i, a, s, o) {
        s.__dzAxisProxy || (s.__dzAxisProxy = new a0t(i, a, o, n), e.push(s.__dzAxisProxy));
      });
      var r = It();
      return P(e, function(i) {
        P(i.getTargetSeriesModels(), function(a) {
          r.set(a.uid, a);
        });
      }), r;
    },
    overallReset: function(n, t) {
      n.eachComponent("dataZoom", function(e) {
        e.eachTargetAxis(function(r, i) {
          e.getAxisProxy(r, i).reset(e);
        }), e.eachTargetAxis(function(r, i) {
          e.getAxisProxy(r, i).filterData(e, t);
        });
      }), n.eachComponent("dataZoom", function(e) {
        var r = e.findRepresentativeAxisProxy();
        if (r) {
          var i = r.getDataPercentWindow(), a = r.getDataValueWindow();
          e.setCalculatedRange({
            start: i[0],
            end: i[1],
            startValue: a[0],
            endValue: a[1]
          });
        }
      });
    }
  };
  function l0t(n) {
    n.registerAction("dataZoom", function(t, e) {
      var r = n0t(e, t);
      P(r, function(i) {
        i.setRawRange({
          start: t.start,
          end: t.end,
          startValue: t.startValue,
          endValue: t.endValue
        });
      });
    });
  }
  var jB = false;
  function IE(n) {
    jB || (jB = true, n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, o0t), l0t(n), n.registerSubTypeDefaulter("dataZoom", function() {
      return "slider";
    }));
  }
  function u0t(n) {
    n.registerComponentModel(r0t), n.registerComponentView(i0t), IE(n);
  }
  var va = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), CX = {};
  function df(n, t) {
    CX[n] = t;
  }
  function TX(n) {
    return CX[n];
  }
  var c0t = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      n.prototype.optionUpdated.apply(this, arguments);
      var e = this.ecModel;
      P(this.option.feature, function(r, i) {
        var a = TX(i);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(e)), Zt(r, a.defaultOption));
      });
    }, t.type = "toolbox", t.layoutMode = {
      type: "box",
      ignoreSize: true
    }, t.defaultOption = {
      show: true,
      z: 6,
      orient: "horizontal",
      left: "right",
      top: "top",
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: true,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      tooltip: {
        show: false,
        position: "bottom"
      }
    }, t;
  }(pe);
  function h0t(n, t, e) {
    var r = t.getBoxLayoutParams(), i = t.get("padding"), a = {
      width: e.getWidth(),
      height: e.getHeight()
    }, s = Zn(r, a, i);
    Pc(t.get("orient"), n, t.get("itemGap"), s.width, s.height), O1(n, r, a, i);
  }
  function IX(n, t) {
    var e = Cd(t.get("padding")), r = t.getItemStyle([
      "color",
      "opacity"
    ]);
    return r.fill = t.get("backgroundColor"), n = new ye({
      shape: {
        x: n.x - e[3],
        y: n.y - e[0],
        width: n.width + e[1] + e[3],
        height: n.height + e[0] + e[2],
        r: t.get("borderRadius")
      },
      style: r,
      silent: true,
      z2: -1
    }), n;
  }
  var f0t = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, r, i, a) {
      var s = this.group;
      if (s.removeAll(), !e.get("show")) return;
      var o = +e.get("itemSize"), l = e.get("orient") === "vertical", u = e.get("feature") || {}, c = this._features || (this._features = {}), h = [];
      P(u, function(p, g) {
        h.push(g);
      }), new Wo(this._featureNames || [], h).add(f).update(f).remove(qt(f, null)).execute(), this._featureNames = h;
      function f(p, g) {
        var v = h[p], m = h[g], y = u[v], x = new $e(y, e, e.ecModel), b;
        if (a && a.newTitle != null && a.featureName === v && (y.title = a.newTitle), v && !m) {
          if (d0t(v)) b = {
            onclick: x.option.onclick,
            featureName: v
          };
          else {
            var _ = TX(v);
            if (!_) return;
            b = new _();
          }
          c[v] = b;
        } else if (b = c[m], !b) return;
        b.uid = Sd("toolbox-feature"), b.model = x, b.ecModel = r, b.api = i;
        var w = b instanceof va;
        if (!v && m) {
          w && b.dispose && b.dispose(r, i);
          return;
        }
        if (!x.get("show") || w && b.unusable) {
          w && b.remove && b.remove(r, i);
          return;
        }
        d(x, b, v), x.setIconStatus = function(S, I) {
          var T = this.option, A = this.iconPaths;
          T.iconStatus = T.iconStatus || {}, T.iconStatus[S] = I, A[S] && (I === "emphasis" ? Vo : Go)(A[S]);
        }, b instanceof va && b.render && b.render(x, r, i, a);
      }
      function d(p, g, v) {
        var m = p.getModel("iconStyle"), y = p.getModel([
          "emphasis",
          "iconStyle"
        ]), x = g instanceof va && g.getIcons ? g.getIcons() : p.get("icon"), b = p.get("title") || {}, _, w;
        wt(x) ? (_ = {}, _[v] = x) : _ = x, wt(b) ? (w = {}, w[v] = b) : w = b;
        var S = p.iconPaths = {};
        P(_, function(I, T) {
          var A = Fv(I, {}, {
            x: -o / 2,
            y: -o / 2,
            width: o,
            height: o
          });
          A.setStyle(m.getItemStyle());
          var C = A.ensureState("emphasis");
          C.style = y.getItemStyle();
          var D = new be({
            style: {
              text: w[T],
              align: y.get("textAlign"),
              borderRadius: y.get("textBorderRadius"),
              padding: y.get("textPadding"),
              fill: null,
              font: rD({
                fontStyle: y.get("textFontStyle"),
                fontFamily: y.get("textFontFamily"),
                fontSize: y.get("textFontSize"),
                fontWeight: y.get("textFontWeight")
              }, r)
            },
            ignore: true
          });
          A.setTextContent(D), dh({
            el: A,
            componentModel: e,
            itemName: T,
            formatterParamsExtra: {
              title: w[T]
            }
          }), A.__title = w[T], A.on("mouseover", function() {
            var E = y.getItemStyle(), M = l ? e.get("right") == null && e.get("left") !== "right" ? "right" : "left" : e.get("bottom") == null && e.get("top") !== "bottom" ? "bottom" : "top";
            D.setStyle({
              fill: y.get("textFill") || E.fill || E.stroke || "#000",
              backgroundColor: y.get("textBackgroundColor")
            }), A.setTextConfig({
              position: y.get("textPosition") || M
            }), D.ignore = !e.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get([
              "iconStatus",
              T
            ]) !== "emphasis" && i.leaveEmphasis(this), D.hide();
          }), (p.get([
            "iconStatus",
            T
          ]) === "emphasis" ? Vo : Go)(A), s.add(A), A.on("click", St(g.onclick, g, r, i, T)), S[T] = A;
        });
      }
      h0t(s, e, i), s.add(IX(s.getBoundingRect(), e)), l || s.eachChild(function(p) {
        var g = p.__title, v = p.ensureState("emphasis"), m = v.textConfig || (v.textConfig = {}), y = p.getTextContent(), x = y && y.ensureState("emphasis");
        if (x && !Nt(x) && g) {
          var b = x.style || (x.style = {}), _ = Mv(g, be.makeFont(b)), w = p.x + s.x, S = p.y + s.y + o, I = false;
          S + _.height > i.getHeight() && (m.position = "top", I = true);
          var T = I ? -5 - _.height : o + 10;
          w + _.width / 2 > i.getWidth() ? (m.position = [
            "100%",
            T
          ], b.align = "right") : w - _.width / 2 < 0 && (m.position = [
            0,
            T
          ], b.align = "left");
        }
      });
    }, t.prototype.updateView = function(e, r, i, a) {
      P(this._features, function(s) {
        s instanceof va && s.updateView && s.updateView(s.model, r, i, a);
      });
    }, t.prototype.remove = function(e, r) {
      P(this._features, function(i) {
        i instanceof va && i.remove && i.remove(e, r);
      }), this.group.removeAll();
    }, t.prototype.dispose = function(e, r) {
      P(this._features, function(i) {
        i instanceof va && i.dispose && i.dispose(e, r);
      });
    }, t.type = "toolbox", t;
  }(vn);
  function d0t(n) {
    return n.indexOf("my") === 0;
  }
  var p0t = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, r) {
      var i = this.model, a = i.get("name") || e.get("title.0.text") || "echarts", s = r.getZr().painter.getType() === "svg", o = s ? "svg" : i.get("type", true) || "png", l = r.getConnectedDataURL({
        type: o,
        backgroundColor: i.get("backgroundColor", true) || e.get("backgroundColor") || "#fff",
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = ce.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = a + "." + o, c.target = "_blank", c.href = l;
        var h = new MouseEvent("click", {
          view: document.defaultView,
          bubbles: true,
          cancelable: false
        });
        c.dispatchEvent(h);
      } else if (window.navigator.msSaveOrOpenBlob || s) {
        var f = l.split(","), d = f[0].indexOf("base64") > -1, p = s ? decodeURIComponent(f[1]) : f[1];
        d && (p = window.atob(p));
        var g = a + "." + o;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, m = new Uint8Array(v); v--; ) m[v] = p.charCodeAt(v);
          var y = new Blob([
            m
          ]);
          window.navigator.msSaveOrOpenBlob(y, g);
        } else {
          var x = document.createElement("iframe");
          document.body.appendChild(x);
          var b = x.contentWindow, _ = b.document;
          _.open("image/svg+xml", "replace"), _.write(p), _.close(), b.focus(), _.execCommand("SaveAs", true, g), document.body.removeChild(x);
        }
      } else {
        var w = i.get("lang"), S = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (w && w[0] || "") + '" /></body>', I = window.open();
        I.document.write(S), I.document.title = a;
      }
    }, t.getDefaultOption = function(e) {
      var r = {
        show: true,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: e.getLocaleModel().get([
          "toolbox",
          "saveAsImage",
          "title"
        ]),
        type: "png",
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: [
          "toolbox"
        ],
        lang: e.getLocaleModel().get([
          "toolbox",
          "saveAsImage",
          "lang"
        ])
      };
      return r;
    }, t;
  }(va), KB = "__ec_magicType_stack__", g0t = [
    [
      "line",
      "bar"
    ],
    [
      "stack"
    ]
  ], v0t = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.getIcons = function() {
      var e = this.model, r = e.get("icon"), i = {};
      return P(e.get("type"), function(a) {
        r[a] && (i[a] = r[a]);
      }), i;
    }, t.getDefaultOption = function(e) {
      var r = {
        show: true,
        type: [],
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
        },
        title: e.getLocaleModel().get([
          "toolbox",
          "magicType",
          "title"
        ]),
        option: {},
        seriesIndex: {}
      };
      return r;
    }, t.prototype.onclick = function(e, r, i) {
      var a = this.model, s = a.get([
        "seriesIndex",
        i
      ]);
      if (ZB[i]) {
        var o = {
          series: []
        }, l = function(h) {
          var f = h.subType, d = h.id, p = ZB[i](f, d, h, a);
          p && ($t(p, h.option), o.series.push(p));
          var g = h.coordinateSystem;
          if (g && g.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var v = g.getAxesByScale("ordinal")[0];
            if (v) {
              var m = v.dim, y = m + "Axis", x = h.getReferringComponents(y, On).models[0], b = x.componentIndex;
              o[y] = o[y] || [];
              for (var _ = 0; _ <= b; _++) o[y][b] = o[y][b] || {};
              o[y][b].boundaryGap = i === "bar";
            }
          }
        };
        P(g0t, function(h) {
          ne(h, i) >= 0 && P(h, function(f) {
            a.setIconStatus(f, "normal");
          });
        }), a.setIconStatus(i, "emphasis"), e.eachComponent({
          mainType: "series",
          query: s == null ? null : {
            seriesIndex: s
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = Zt({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get([
          "iconStatus",
          i
        ]) !== "emphasis" && (c = "tiled")), r.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: o,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, t;
  }(va), ZB = {
    line: function(n, t, e, r) {
      if (n === "bar") return Zt({
        id: t,
        type: "line",
        data: e.get("data"),
        stack: e.get("stack"),
        markPoint: e.get("markPoint"),
        markLine: e.get("markLine")
      }, r.get([
        "option",
        "line"
      ]) || {}, true);
    },
    bar: function(n, t, e, r) {
      if (n === "line") return Zt({
        id: t,
        type: "bar",
        data: e.get("data"),
        stack: e.get("stack"),
        markPoint: e.get("markPoint"),
        markLine: e.get("markLine")
      }, r.get([
        "option",
        "bar"
      ]) || {}, true);
    },
    stack: function(n, t, e, r) {
      var i = e.get("stack") === KB;
      if (n === "line" || n === "bar") return r.setIconStatus("stack", i ? "normal" : "emphasis"), Zt({
        id: t,
        stack: i ? "" : KB
      }, r.get([
        "option",
        "stack"
      ]) || {}, true);
    }
  };
  co({
    type: "changeMagicType",
    event: "magicTypeChanged",
    update: "prepareAndUpdate"
  }, function(n, t) {
    t.mergeOption(n.newOption);
  });
  var t_ = new Array(60).join("-"), Kf = "	";
  function m0t(n) {
    var t = {}, e = [], r = [];
    return n.eachRawSeries(function(i) {
      var a = i.coordinateSystem;
      if (a && (a.type === "cartesian2d" || a.type === "polar")) {
        var s = a.getBaseAxis();
        if (s.type === "category") {
          var o = s.dim + "_" + s.index;
          t[o] || (t[o] = {
            categoryAxis: s,
            valueAxis: a.getOtherAxis(s),
            series: []
          }, r.push({
            axisDim: s.dim,
            axisIndex: s.index
          })), t[o].series.push(i);
        } else e.push(i);
      } else e.push(i);
    }), {
      seriesGroupByCategoryAxis: t,
      other: e,
      meta: r
    };
  }
  function y0t(n) {
    var t = [];
    return P(n, function(e, r) {
      var i = e.categoryAxis, a = e.valueAxis, s = a.dim, o = [
        " "
      ].concat(ht(e.series, function(d) {
        return d.name;
      })), l = [
        i.model.getCategories()
      ];
      P(e.series, function(d) {
        var p = d.getRawData();
        l.push(d.getRawData().mapArray(p.mapDimension(s), function(g) {
          return g;
        }));
      });
      for (var u = [
        o.join(Kf)
      ], c = 0; c < l[0].length; c++) {
        for (var h = [], f = 0; f < l.length; f++) h.push(l[f][c]);
        u.push(h.join(Kf));
      }
      t.push(u.join(`
`));
    }), t.join(`

` + t_ + `

`);
  }
  function x0t(n) {
    return ht(n, function(t) {
      var e = t.getRawData(), r = [
        t.name
      ], i = [];
      return e.each(e.dimensions, function() {
        for (var a = arguments.length, s = arguments[a - 1], o = e.getName(s), l = 0; l < a - 1; l++) i[l] = arguments[l];
        r.push((o ? o + Kf : "") + i.join(Kf));
      }), r.join(`
`);
    }).join(`

` + t_ + `

`);
  }
  function b0t(n) {
    var t = m0t(n);
    return {
      value: Le([
        y0t(t.seriesGroupByCategoryAxis),
        x0t(t.other)
      ], function(e) {
        return !!e.replace(/[\n\t\s]/g, "");
      }).join(`

` + t_ + `

`),
      meta: t.meta
    };
  }
  function _b(n) {
    return n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function _0t(n) {
    var t = n.slice(0, n.indexOf(`
`));
    if (t.indexOf(Kf) >= 0) return true;
  }
  var qA = new RegExp("[" + Kf + "]+", "g");
  function w0t(n) {
    for (var t = n.split(/\n+/g), e = _b(t.shift()).split(qA), r = [], i = ht(e, function(l) {
      return {
        name: l,
        data: []
      };
    }), a = 0; a < t.length; a++) {
      var s = _b(t[a]).split(qA);
      r.push(s.shift());
      for (var o = 0; o < s.length; o++) i[o] && (i[o].data[a] = s[o]);
    }
    return {
      series: i,
      categories: r
    };
  }
  function S0t(n) {
    for (var t = n.split(/\n+/g), e = _b(t.shift()), r = [], i = 0; i < t.length; i++) {
      var a = _b(t[i]);
      if (a) {
        var s = a.split(qA), o = "", l = void 0, u = false;
        isNaN(s[0]) ? (u = true, o = s[0], s = s.slice(1), r[i] = {
          name: o,
          value: []
        }, l = r[i].value) : l = r[i] = [];
        for (var c = 0; c < s.length; c++) l.push(+s[c]);
        l.length === 1 && (u ? r[i].value = l[0] : r[i] = l[0]);
      }
    }
    return {
      name: e,
      data: r
    };
  }
  function C0t(n, t) {
    var e = n.split(new RegExp(`
*` + t_ + `
*`, "g")), r = {
      series: []
    };
    return P(e, function(i, a) {
      if (_0t(i)) {
        var s = w0t(i), o = t[a], l = o.axisDim + "Axis";
        o && (r[l] = r[l] || [], r[l][o.axisIndex] = {
          data: s.categories
        }, r.series = r.series.concat(s.series));
      } else {
        var s = S0t(i);
        r.series.push(s);
      }
    }), r;
  }
  var T0t = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, r) {
      setTimeout(function() {
        r.dispatchAction({
          type: "hideTip"
        });
      });
      var i = r.getDom(), a = this.model;
      this._dom && i.removeChild(this._dom);
      var s = document.createElement("div");
      s.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", s.style.backgroundColor = a.get("backgroundColor") || "#fff";
      var o = document.createElement("h4"), l = a.get("lang") || [];
      o.innerHTML = l[0] || a.get("title"), o.style.cssText = "margin:10px 20px", o.style.color = a.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var h = a.get("optionToContent"), f = a.get("contentToOption"), d = b0t(e);
      if (Nt(h)) {
        var p = h(r.getOption());
        wt(p) ? u.innerHTML = p : zf(p) && u.appendChild(p);
      } else {
        c.readOnly = a.get("readOnly");
        var g = c.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = a.get("textColor"), g.borderColor = a.get("textareaBorderColor"), g.backgroundColor = a.get("textareaColor"), c.value = d.value, u.appendChild(c);
      }
      var v = d.meta, m = document.createElement("div");
      m.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", x = document.createElement("div"), b = document.createElement("div");
      y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
      var _ = this;
      function w() {
        i.removeChild(s), _._dom = null;
      }
      II(x, "click", w), II(b, "click", function() {
        if (f == null && h != null || f != null && h == null) {
          w();
          return;
        }
        var S;
        try {
          Nt(f) ? S = f(u, r.getOption()) : S = C0t(c.value, v);
        } catch (I) {
          throw w(), new Error("Data view format error " + I);
        }
        S && r.dispatchAction({
          type: "changeDataView",
          newOption: S
        }), w();
      }), x.innerHTML = l[1], b.innerHTML = l[2], b.style.cssText = x.style.cssText = y, !a.get("readOnly") && m.appendChild(b), m.appendChild(x), s.appendChild(o), s.appendChild(u), s.appendChild(m), u.style.height = i.clientHeight - 80 + "px", i.appendChild(s), this._dom = s;
    }, t.prototype.remove = function(e, r) {
      this._dom && r.getDom().removeChild(this._dom);
    }, t.prototype.dispose = function(e, r) {
      this.remove(e, r);
    }, t.getDefaultOption = function(e) {
      var r = {
        show: true,
        readOnly: false,
        optionToContent: null,
        contentToOption: null,
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: e.getLocaleModel().get([
          "toolbox",
          "dataView",
          "title"
        ]),
        lang: e.getLocaleModel().get([
          "toolbox",
          "dataView",
          "lang"
        ]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return r;
    }, t;
  }(va);
  function I0t(n, t) {
    return ht(n, function(e, r) {
      var i = t && t[r];
      if (Ft(i) && !ct(i)) {
        var a = Ft(e) && !ct(e);
        a || (e = {
          value: e
        });
        var s = i.name != null && e.name == null;
        return e = $t(e, i), s && delete e.name, e;
      } else return e;
    });
  }
  co({
    type: "changeDataView",
    event: "dataViewChanged",
    update: "prepareAndUpdate"
  }, function(n, t) {
    var e = [];
    P(n.newOption.series, function(r) {
      var i = t.getSeriesByName(r.name)[0];
      if (!i) e.push(rt({
        type: "scatter"
      }, r));
      else {
        var a = i.get("data");
        e.push({
          name: r.name,
          data: I0t(r.data, a)
        });
      }
    }), t.mergeOption($t({
      series: e
    }, n.newOption));
  });
  var AX = P, kX = xe();
  function A0t(n, t) {
    var e = AE(n);
    AX(t, function(r, i) {
      for (var a = e.length - 1; a >= 0; a--) {
        var s = e[a];
        if (s[i]) break;
      }
      if (a < 0) {
        var o = n.queryComponents({
          mainType: "dataZoom",
          subType: "select",
          id: i
        })[0];
        if (o) {
          var l = o.getPercentRange();
          e[0][i] = {
            dataZoomId: i,
            start: l[0],
            end: l[1]
          };
        }
      }
    }), e.push(t);
  }
  function k0t(n) {
    var t = AE(n), e = t[t.length - 1];
    t.length > 1 && t.pop();
    var r = {};
    return AX(e, function(i, a) {
      for (var s = t.length - 1; s >= 0; s--) if (i = t[s][a], i) {
        r[a] = i;
        break;
      }
    }), r;
  }
  function D0t(n) {
    kX(n).snapshots = null;
  }
  function E0t(n) {
    return AE(n).length;
  }
  function AE(n) {
    var t = kX(n);
    return t.snapshots || (t.snapshots = [
      {}
    ]), t.snapshots;
  }
  var M0t = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, r) {
      D0t(e), r.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, t.getDefaultOption = function(e) {
      var r = {
        show: true,
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: e.getLocaleModel().get([
          "toolbox",
          "restore",
          "title"
        ])
      };
      return r;
    }, t;
  }(va);
  co({
    type: "restore",
    event: "restore",
    update: "prepareAndUpdate"
  }, function(n, t) {
    t.resetOption("recreate");
  });
  var R0t = [
    "grid",
    "xAxis",
    "yAxis",
    "geo",
    "graph",
    "polar",
    "radiusAxis",
    "angleAxis",
    "bmap"
  ], kE = function() {
    function n(t, e, r) {
      var i = this;
      this._targetInfoList = [];
      var a = JB(e, t);
      P(N0t, function(s, o) {
        (!r || !r.include || ne(r.include, o) >= 0) && s(a, i._targetInfoList);
      });
    }
    return n.prototype.setOutputRanges = function(t, e) {
      return this.matchOutputRanges(t, e, function(r, i, a) {
        if ((r.coordRanges || (r.coordRanges = [])).push(i), !r.coordRange) {
          r.coordRange = i;
          var s = qC[r.brushType](0, a, i);
          r.__rangeOffset = {
            offset: n3[r.brushType](s.values, r.range, [
              1,
              1
            ]),
            xyMinMax: s.xyMinMax
          };
        }
      }), t;
    }, n.prototype.matchOutputRanges = function(t, e, r) {
      P(t, function(i) {
        var a = this.findTargetInfo(i, e);
        a && a !== true && P(a.coordSyses, function(s) {
          var o = qC[i.brushType](1, s, i.range, true);
          r(i, o.values, s, e);
        });
      }, this);
    }, n.prototype.setInputRanges = function(t, e) {
      P(t, function(r) {
        var i = this.findTargetInfo(r, e);
        if (r.range = r.range || [], i && i !== true) {
          r.panelId = i.panelId;
          var a = qC[r.brushType](0, i.coordSys, r.coordRange), s = r.__rangeOffset;
          r.range = s ? n3[r.brushType](a.values, s.offset, L0t(a.xyMinMax, s.xyMinMax)) : a.values;
        }
      }, this);
    }, n.prototype.makePanelOpts = function(t, e) {
      return ht(this._targetInfoList, function(r) {
        var i = r.getPanelRect();
        return {
          panelId: r.panelId,
          defaultBrushType: e ? e(r) : null,
          clipPath: $8(i),
          isTargetByCursor: F8(i, t, r.coordSysModel),
          getLinearBrushOtherExtent: O8(i)
        };
      });
    }, n.prototype.controlSeries = function(t, e, r) {
      var i = this.findTargetInfo(t, r);
      return i === true || i && ne(i.coordSyses, e.coordinateSystem) >= 0;
    }, n.prototype.findTargetInfo = function(t, e) {
      for (var r = this._targetInfoList, i = JB(e, t), a = 0; a < r.length; a++) {
        var s = r[a], o = t.panelId;
        if (o) {
          if (s.panelId === o) return s;
        } else for (var l = 0; l < QB.length; l++) if (QB[l](i, s)) return s;
      }
      return true;
    }, n;
  }();
  function jA(n) {
    return n[0] > n[1] && n.reverse(), n;
  }
  function JB(n, t) {
    return hg(n, t, {
      includeMainTypes: R0t
    });
  }
  var N0t = {
    grid: function(n, t) {
      var e = n.xAxisModels, r = n.yAxisModels, i = n.gridModels, a = It(), s = {}, o = {};
      !e && !r && !i || (P(e, function(l) {
        var u = l.axis.grid.model;
        a.set(u.id, u), s[u.id] = true;
      }), P(r, function(l) {
        var u = l.axis.grid.model;
        a.set(u.id, u), o[u.id] = true;
      }), P(i, function(l) {
        a.set(l.id, l), s[l.id] = true, o[l.id] = true;
      }), a.each(function(l) {
        var u = l.coordinateSystem, c = [];
        P(u.getCartesians(), function(h, f) {
          (ne(e, h.getAxis("x").model) >= 0 || ne(r, h.getAxis("y").model) >= 0) && c.push(h);
        }), t.push({
          panelId: "grid--" + l.id,
          gridModel: l,
          coordSysModel: l,
          coordSys: c[0],
          coordSyses: c,
          getPanelRect: t3.grid,
          xAxisDeclared: s[l.id],
          yAxisDeclared: o[l.id]
        });
      }));
    },
    geo: function(n, t) {
      P(n.geoModels, function(e) {
        var r = e.coordinateSystem;
        t.push({
          panelId: "geo--" + e.id,
          geoModel: e,
          coordSysModel: e,
          coordSys: r,
          coordSyses: [
            r
          ],
          getPanelRect: t3.geo
        });
      });
    }
  }, QB = [
    function(n, t) {
      var e = n.xAxisModel, r = n.yAxisModel, i = n.gridModel;
      return !i && e && (i = e.axis.grid.model), !i && r && (i = r.axis.grid.model), i && i === t.gridModel;
    },
    function(n, t) {
      var e = n.geoModel;
      return e && e === t.geoModel;
    }
  ], t3 = {
    grid: function() {
      return this.coordSys.master.getRect().clone();
    },
    geo: function() {
      var n = this.coordSys, t = n.getBoundingRect().clone();
      return t.applyTransform(Lc(n)), t;
    }
  }, qC = {
    lineX: qt(e3, 0),
    lineY: qt(e3, 1),
    rect: function(n, t, e, r) {
      var i = n ? t.pointToData([
        e[0][0],
        e[1][0]
      ], r) : t.dataToPoint([
        e[0][0],
        e[1][0]
      ], r), a = n ? t.pointToData([
        e[0][1],
        e[1][1]
      ], r) : t.dataToPoint([
        e[0][1],
        e[1][1]
      ], r), s = [
        jA([
          i[0],
          a[0]
        ]),
        jA([
          i[1],
          a[1]
        ])
      ];
      return {
        values: s,
        xyMinMax: s
      };
    },
    polygon: function(n, t, e, r) {
      var i = [
        [
          1 / 0,
          -1 / 0
        ],
        [
          1 / 0,
          -1 / 0
        ]
      ], a = ht(e, function(s) {
        var o = n ? t.pointToData(s, r) : t.dataToPoint(s, r);
        return i[0][0] = Math.min(i[0][0], o[0]), i[1][0] = Math.min(i[1][0], o[1]), i[0][1] = Math.max(i[0][1], o[0]), i[1][1] = Math.max(i[1][1], o[1]), o;
      });
      return {
        values: a,
        xyMinMax: i
      };
    }
  };
  function e3(n, t, e, r) {
    var i = e.getAxis([
      "x",
      "y"
    ][n]), a = jA(ht([
      0,
      1
    ], function(o) {
      return t ? i.coordToData(i.toLocalCoord(r[o]), true) : i.toGlobalCoord(i.dataToCoord(r[o]));
    })), s = [];
    return s[n] = a, s[1 - n] = [
      NaN,
      NaN
    ], {
      values: a,
      xyMinMax: s
    };
  }
  var n3 = {
    lineX: qt(r3, 0),
    lineY: qt(r3, 1),
    rect: function(n, t, e) {
      return [
        [
          n[0][0] - e[0] * t[0][0],
          n[0][1] - e[0] * t[0][1]
        ],
        [
          n[1][0] - e[1] * t[1][0],
          n[1][1] - e[1] * t[1][1]
        ]
      ];
    },
    polygon: function(n, t, e) {
      return ht(n, function(r, i) {
        return [
          r[0] - e[0] * t[i][0],
          r[1] - e[1] * t[i][1]
        ];
      });
    }
  };
  function r3(n, t, e, r) {
    return [
      t[0] - r[n] * e[0],
      t[1] - r[n] * e[1]
    ];
  }
  function L0t(n, t) {
    var e = i3(n), r = i3(t), i = [
      e[0] / r[0],
      e[1] / r[1]
    ];
    return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
  }
  function i3(n) {
    return n ? [
      n[0][1] - n[0][0],
      n[1][1] - n[1][0]
    ] : [
      NaN,
      NaN
    ];
  }
  var KA = P, P0t = Gnt("toolbox-dataZoom_"), $0t = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, r, i, a) {
      this._brushController || (this._brushController = new eE(i.getZr()), this._brushController.on("brush", St(this._onBrush, this)).mount()), B0t(e, r, this, a, i), F0t(e, r);
    }, t.prototype.onclick = function(e, r, i) {
      O0t[i].call(this);
    }, t.prototype.remove = function(e, r) {
      this._brushController && this._brushController.unmount();
    }, t.prototype.dispose = function(e, r) {
      this._brushController && this._brushController.dispose();
    }, t.prototype._onBrush = function(e) {
      var r = e.areas;
      if (!e.isEnd || !r.length) return;
      var i = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var s = new kE(DE(this.model), a, {
        include: [
          "grid"
        ]
      });
      s.matchOutputRanges(r, a, function(u, c, h) {
        if (h.type === "cartesian2d") {
          var f = u.brushType;
          f === "rect" ? (o("x", h, c[0]), o("y", h, c[1])) : o({
            lineX: "x",
            lineY: "y"
          }[f], h, c);
        }
      }), A0t(a, i), this._dispatchZoomAction(i);
      function o(u, c, h) {
        var f = c.getAxis(u), d = f.model, p = l(u, d, a), g = p.findRepresentativeAxisProxy(d).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (h = xh(0, h.slice(), f.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: h[0],
          endValue: h[1]
        });
      }
      function l(u, c, h) {
        var f;
        return h.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(d) {
          var p = d.getAxisModel(u, c.componentIndex);
          p && (f = d);
        }), f;
      }
    }, t.prototype._dispatchZoomAction = function(e) {
      var r = [];
      KA(e, function(i, a) {
        r.push(Bt(i));
      }), r.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: r
      });
    }, t.getDefaultOption = function(e) {
      var r = {
        show: true,
        filterMode: "filter",
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        title: e.getLocaleModel().get([
          "toolbox",
          "dataZoom",
          "title"
        ]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return r;
    }, t;
  }(va), O0t = {
    zoom: function() {
      var n = !this._isZoomActive;
      this.api.dispatchAction({
        type: "takeGlobalCursor",
        key: "dataZoomSelect",
        dataZoomSelectActive: n
      });
    },
    back: function() {
      this._dispatchZoomAction(k0t(this.ecModel));
    }
  };
  function DE(n) {
    var t = {
      xAxisIndex: n.get("xAxisIndex", true),
      yAxisIndex: n.get("yAxisIndex", true),
      xAxisId: n.get("xAxisId", true),
      yAxisId: n.get("yAxisId", true)
    };
    return t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = "all"), t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = "all"), t;
  }
  function F0t(n, t) {
    n.setIconStatus("back", E0t(t) > 1 ? "emphasis" : "normal");
  }
  function B0t(n, t, e, r, i) {
    var a = e._isZoomActive;
    r && r.type === "takeGlobalCursor" && (a = r.key === "dataZoomSelect" ? r.dataZoomSelectActive : false), e._isZoomActive = a, n.setIconStatus("zoom", a ? "emphasis" : "normal");
    var s = new kE(DE(n), t, {
      include: [
        "grid"
      ]
    }), o = s.makePanelOpts(i, function(l) {
      return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
    });
    e._brushController.setPanels(o).enableBrush(a && o.length ? {
      brushType: "auto",
      brushStyle: n.getModel("brushStyle").getItemStyle()
    } : false);
  }
  dat("dataZoom", function(n) {
    var t = n.getComponent("toolbox", 0), e = [
      "feature",
      "dataZoom"
    ];
    if (!t || t.get(e) == null) return;
    var r = t.getModel(e), i = [], a = DE(r), s = hg(n, a);
    KA(s.xAxisModels, function(l) {
      return o(l, "xAxis", "xAxisIndex");
    }), KA(s.yAxisModels, function(l) {
      return o(l, "yAxis", "yAxisIndex");
    });
    function o(l, u, c) {
      var h = l.componentIndex, f = {
        type: "select",
        $fromToolbox: true,
        filterMode: r.get("filterMode", true) || "filter",
        id: P0t + u + h
      };
      f[c] = h, i.push(f);
    }
    return i;
  });
  function z0t(n) {
    n.registerComponentModel(c0t), n.registerComponentView(f0t), df("saveAsImage", p0t), df("magicType", v0t), df("dataView", T0t), df("dataZoom", $0t), df("restore", M0t), se(u0t);
  }
  var V0t = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "tooltip", t.dependencies = [
      "axisPointer"
    ], t.defaultOption = {
      z: 60,
      show: true,
      showContent: true,
      trigger: "item",
      triggerOn: "mousemove|click",
      alwaysShowContent: false,
      displayMode: "single",
      renderMode: "auto",
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: false,
      backgroundColor: "#fff",
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      borderRadius: 4,
      borderWidth: 1,
      padding: null,
      extraCssText: "",
      axisPointer: {
        type: "line",
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          textStyle: {}
        }
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, t;
  }(pe);
  function DX(n) {
    var t = n.get("confine");
    return t != null ? !!t : n.get("renderMode") === "richText";
  }
  function EX(n) {
    if (ce.domSupported) {
      for (var t = document.documentElement.style, e = 0, r = n.length; e < r; e++) if (n[e] in t) return n[e];
    }
  }
  var MX = EX([
    "transform",
    "webkitTransform",
    "OTransform",
    "MozTransform",
    "msTransform"
  ]), G0t = EX([
    "webkitTransition",
    "transition",
    "OTransition",
    "MozTransition",
    "msTransition"
  ]);
  function RX(n, t) {
    if (!n) return t;
    t = c5(t, true);
    var e = n.indexOf(t);
    return n = e === -1 ? t : "-" + n.slice(0, e) + "-" + t, n.toLowerCase();
  }
  function W0t(n, t) {
    var e = n.currentStyle || document.defaultView && document.defaultView.getComputedStyle(n);
    return e ? e[t] : null;
  }
  var U0t = RX(G0t, "transition"), EE = RX(MX, "transform"), H0t = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (ce.transform3dSupported ? "will-change:transform;" : "");
  function X0t(n) {
    return n = n === "left" ? "right" : n === "right" ? "left" : n === "top" ? "bottom" : "top", n;
  }
  function Y0t(n, t, e) {
    if (!wt(e) || e === "inside") return "";
    var r = n.get("backgroundColor"), i = n.get("borderWidth");
    t = Yc(t);
    var a = X0t(e), s = Math.max(Math.round(i) * 1.5, 6), o = "", l = EE + ":", u;
    ne([
      "left",
      "right"
    ], a) > -1 ? (o += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (o += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
    var c = u * Math.PI / 180, h = s + i, f = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), d = Math.round(((f - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (f - h) / 2) * 100) / 100;
    o += ";" + a + ":-" + d + "px";
    var p = t + " solid " + i + "px;", g = [
      "position:absolute;width:" + s + "px;height:" + s + "px;z-index:-1;",
      o + ";" + l + ";",
      "border-bottom:" + p,
      "border-right:" + p,
      "background-color:" + r + ";"
    ];
    return '<div style="' + g.join("") + '"></div>';
  }
  function q0t(n, t) {
    var e = "cubic-bezier(0.23,1,0.32,1)", r = " " + n / 2 + "s " + e, i = "opacity" + r + ",visibility" + r;
    return t || (r = " " + n + "s " + e, i += ce.transformSupported ? "," + EE + r : ",left" + r + ",top" + r), U0t + ":" + i;
  }
  function a3(n, t, e) {
    var r = n.toFixed(0) + "px", i = t.toFixed(0) + "px";
    if (!ce.transformSupported) return e ? "top:" + i + ";left:" + r + ";" : [
      [
        "top",
        i
      ],
      [
        "left",
        r
      ]
    ];
    var a = ce.transform3dSupported, s = "translate" + (a ? "3d" : "") + "(" + r + "," + i + (a ? ",0" : "") + ")";
    return e ? "top:0;left:0;" + EE + ":" + s + ";" : [
      [
        "top",
        0
      ],
      [
        "left",
        0
      ],
      [
        MX,
        s
      ]
    ];
  }
  function j0t(n) {
    var t = [], e = n.get("fontSize"), r = n.getTextColor();
    r && t.push("color:" + r), t.push("font:" + n.getFont());
    var i = Ht(n.get("lineHeight"), Math.round(e * 3 / 2));
    e && t.push("line-height:" + i + "px");
    var a = n.get("textShadowColor"), s = n.get("textShadowBlur") || 0, o = n.get("textShadowOffsetX") || 0, l = n.get("textShadowOffsetY") || 0;
    return a && s && t.push("text-shadow:" + o + "px " + l + "px " + s + "px " + a), P([
      "decoration",
      "align"
    ], function(u) {
      var c = n.get(u);
      c && t.push("text-" + u + ":" + c);
    }), t.join(";");
  }
  function K0t(n, t, e) {
    var r = [], i = n.get("transitionDuration"), a = n.get("backgroundColor"), s = n.get("shadowBlur"), o = n.get("shadowColor"), l = n.get("shadowOffsetX"), u = n.get("shadowOffsetY"), c = n.getModel("textStyle"), h = U5(n, "html"), f = l + "px " + u + "px " + s + "px " + o;
    return r.push("box-shadow:" + f), t && i && r.push(q0t(i, e)), a && r.push("background-color:" + a), P([
      "width",
      "color",
      "radius"
    ], function(d) {
      var p = "border-" + d, g = c5(p), v = n.get(g);
      v != null && r.push(p + ":" + v + (d === "color" ? "" : "px"));
    }), r.push(j0t(c)), h != null && r.push("padding:" + Cd(h).join("px ") + "px"), r.join(";") + ";";
  }
  function s3(n, t, e, r, i) {
    var a = t && t.painter;
    if (e) {
      var s = a && a.getViewportRoot();
      s && vet(n, s, e, r, i);
    } else {
      n[0] = r, n[1] = i;
      var o = a && a.getViewportRootOffset();
      o && (n[0] += o.offsetLeft, n[1] += o.offsetTop);
    }
    n[2] = n[0] / t.getWidth(), n[3] = n[1] / t.getHeight();
  }
  var Z0t = function() {
    function n(t, e) {
      if (this._show = false, this._styleCoord = [
        0,
        0,
        0,
        0
      ], this._enterable = true, this._alwaysShowContent = false, this._firstShow = true, this._longHide = true, ce.wxa) return null;
      var r = document.createElement("div");
      r.domBelongToZr = true, this.el = r;
      var i = this._zr = t.getZr(), a = e.appendTo, s = a && (wt(a) ? document.querySelector(a) : zf(a) ? a : Nt(a) && a(t.getDom()));
      s3(this._styleCoord, i, s, t.getWidth() / 2, t.getHeight() / 2), (s || t.getDom()).appendChild(r), this._api = t, this._container = s;
      var o = this;
      r.onmouseenter = function() {
        o._enterable && (clearTimeout(o._hideTimeout), o._show = true), o._inContent = true;
      }, r.onmousemove = function(l) {
        if (l = l || window.event, !o._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          ca(c, l, true), u.dispatch("mousemove", l);
        }
      }, r.onmouseleave = function() {
        o._inContent = false, o._enterable && o._show && o.hideLater(o._hideDelay);
      };
    }
    return n.prototype.update = function(t) {
      if (!this._container) {
        var e = this._api.getDom(), r = W0t(e, "position"), i = e.style;
        i.position !== "absolute" && r !== "absolute" && (i.position = "relative");
      }
      var a = t.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = t.get("className") || "";
    }, n.prototype.show = function(t, e) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var r = this.el, i = r.style, a = this._styleCoord;
      r.innerHTML ? i.cssText = H0t + K0t(t, !this._firstShow, this._longHide) + a3(a[0], a[1], true) + ("border-color:" + Yc(e) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = true, this._firstShow = false, this._longHide = false;
    }, n.prototype.setContent = function(t, e, r, i, a) {
      var s = this.el;
      if (t == null) {
        s.innerHTML = "";
        return;
      }
      var o = "";
      if (wt(a) && r.get("trigger") === "item" && !DX(r) && (o = Y0t(r, i, a)), wt(t)) s.innerHTML = t + o;
      else if (t) {
        s.innerHTML = "", ct(t) || (t = [
          t
        ]);
        for (var l = 0; l < t.length; l++) zf(t[l]) && t[l].parentNode !== s && s.appendChild(t[l]);
        if (o && s.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = o, s.appendChild(u);
        }
      }
    }, n.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, n.prototype.getSize = function() {
      var t = this.el;
      return t ? [
        t.offsetWidth,
        t.offsetHeight
      ] : [
        0,
        0
      ];
    }, n.prototype.moveTo = function(t, e) {
      if (this.el) {
        var r = this._styleCoord;
        if (s3(r, this._zr, this._container, t, e), r[0] != null && r[1] != null) {
          var i = this.el.style, a = a3(r[0], r[1]);
          P(a, function(s) {
            i[s[0]] = s[1];
          });
        }
      }
    }, n.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], e = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
    }, n.prototype.hide = function() {
      var t = this, e = this.el.style;
      e.visibility = "hidden", e.opacity = "0", ce.transform3dSupported && (e.willChange = ""), this._show = false, this._longHideTimeout = setTimeout(function() {
        return t._longHide = true;
      }, 500);
    }, n.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = false, this._hideTimeout = setTimeout(St(this.hide, this), t)) : this.hide());
    }, n.prototype.isShow = function() {
      return this._show;
    }, n.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this.el.parentNode;
      t && t.removeChild(this.el), this.el = this._container = null;
    }, n;
  }(), J0t = function() {
    function n(t) {
      this._show = false, this._styleCoord = [
        0,
        0,
        0,
        0
      ], this._alwaysShowContent = false, this._enterable = true, this._zr = t.getZr(), l3(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return n.prototype.update = function(t) {
      var e = t.get("alwaysShowContent");
      e && this._moveIfResized(), this._alwaysShowContent = e;
    }, n.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = true;
    }, n.prototype.setContent = function(t, e, r, i, a) {
      var s = this;
      Ft(t) && Ne(""), this.el && this._zr.remove(this.el);
      var o = r.getModel("textStyle");
      this.el = new be({
        style: {
          rich: e.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: o.get("textShadowColor"),
          fill: r.get([
            "textStyle",
            "color"
          ]),
          padding: U5(r, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: r.get("z")
      }), P([
        "backgroundColor",
        "borderRadius",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY"
      ], function(u) {
        s.el.style[u] = r.get(u);
      }), P([
        "textShadowBlur",
        "textShadowOffsetX",
        "textShadowOffsetY"
      ], function(u) {
        s.el.style[u] = o.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = true), l._inContent = true;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = false;
      });
    }, n.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, n.prototype.getSize = function() {
      var t = this.el, e = this.el.getBoundingRect(), r = o3(t.style);
      return [
        e.width + r.left + r.right,
        e.height + r.top + r.bottom
      ];
    }, n.prototype.moveTo = function(t, e) {
      var r = this.el;
      if (r) {
        var i = this._styleCoord;
        l3(i, this._zr, t, e), t = i[0], e = i[1];
        var a = r.style, s = yl(a.borderWidth || 0), o = o3(a);
        r.x = t + s + o.left, r.y = e + s + o.top, r.markRedraw();
      }
    }, n.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], e = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
    }, n.prototype.hide = function() {
      this.el && this.el.hide(), this._show = false;
    }, n.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = false, this._hideTimeout = setTimeout(St(this.hide, this), t)) : this.hide());
    }, n.prototype.isShow = function() {
      return this._show;
    }, n.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, n;
  }();
  function yl(n) {
    return Math.max(0, n);
  }
  function o3(n) {
    var t = yl(n.shadowBlur || 0), e = yl(n.shadowOffsetX || 0), r = yl(n.shadowOffsetY || 0);
    return {
      left: yl(t - e),
      right: yl(t + e),
      top: yl(t - r),
      bottom: yl(t + r)
    };
  }
  function l3(n, t, e, r) {
    n[0] = e, n[1] = r, n[2] = n[0] / t.getWidth(), n[3] = n[1] / t.getHeight();
  }
  var Q0t = new ye({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  }), txt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, r) {
      if (!(ce.node || !r.getDom())) {
        var i = e.getComponent("tooltip"), a = this._renderMode = jnt(i.get("renderMode"));
        this._tooltipContent = a === "richText" ? new J0t(r) : new Z0t(r, {
          appendTo: i.get("appendToBody", true) ? "body" : i.get("appendTo", true)
        });
      }
    }, t.prototype.render = function(e, r, i) {
      if (!(ce.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = e, this._ecModel = r, this._api = i;
        var a = this._tooltipContent;
        a.update(e), a.setEnterable(e.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && e.get("transitionDuration") ? kd(this, "_updatePosition", 50, "fixRate") : Wg(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var e = this._tooltipModel, r = e.get("triggerOn");
      vX("itemTooltip", this._api, St(function(i, a, s) {
        r !== "none" && (r.indexOf(i) >= 0 ? this._tryShow(a, s) : i === "leave" && this._hide(s));
      }, this));
    }, t.prototype._keepShow = function() {
      var e = this._tooltipModel, r = this._ecModel, i = this._api, a = e.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var s = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && s.manuallyShowTip(e, r, i, {
            x: s._lastX,
            y: s._lastY,
            dataByCoordSys: s._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(e, r, i, a) {
      if (!(a.from === this.uid || ce.node || !i.getDom())) {
        var s = u3(a, i);
        this._ticket = "";
        var o = a.dataByCoordSys, l = ixt(a, r, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            positionDefault: "bottom"
          }, s);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = Q0t;
          c.x = a.x, c.y = a.y, c.update(), Ut(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, s);
        } else if (o) this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          dataByCoordSys: o,
          tooltipOption: a.tooltipOption
        }, s);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(e, r, i, a)) return;
          var h = mX(a, r), f = h.point[0], d = h.point[1];
          f != null && d != null && this._tryShow({
            offsetX: f,
            offsetY: d,
            target: h.el,
            position: a.position,
            positionDefault: "bottom"
          }, s);
        } else a.x != null && a.y != null && (i.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: i.getZr().findHover(a.x, a.y).target
        }, s));
      }
    }, t.prototype.manuallyHideTip = function(e, r, i, a) {
      var s = this._tooltipContent;
      this._tooltipModel && s.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(u3(a, i));
    }, t.prototype._manuallyAxisShowTip = function(e, r, i, a) {
      var s = a.seriesIndex, o = a.dataIndex, l = r.getComponent("axisPointer").coordSysAxesInfo;
      if (!(s == null || o == null || l == null)) {
        var u = r.getSeriesByIndex(s);
        if (u) {
          var c = u.getData(), h = wp([
            c.getItemModel(o),
            u,
            (u.coordinateSystem || {}).model
          ], this._tooltipModel);
          if (h.get("trigger") === "axis") return i.dispatchAction({
            type: "updateAxisPointer",
            seriesIndex: s,
            dataIndex: o,
            position: a.position
          }), true;
        }
      }
    }, t.prototype._tryShow = function(e, r) {
      var i = e.target, a = this._tooltipModel;
      if (a) {
        this._lastX = e.offsetX, this._lastY = e.offsetY;
        var s = e.dataByCoordSys;
        if (s && s.length) this._showAxisTooltip(s, e);
        else if (i) {
          var o = Ut(i);
          if (o.ssrType === "legend") return;
          this._lastDataByCoordSys = null;
          var l, u;
          bc(i, function(c) {
            if (Ut(c).dataIndex != null) return l = c, true;
            if (Ut(c).tooltipConfig != null) return u = c, true;
          }, true), l ? this._showSeriesItemTooltip(e, l, r) : u ? this._showComponentItemTooltip(e, u, r) : this._hide(r);
        } else this._lastDataByCoordSys = null, this._hide(r);
      }
    }, t.prototype._showOrMove = function(e, r) {
      var i = e.get("showDelay");
      r = St(r, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(r, i) : r();
    }, t.prototype._showAxisTooltip = function(e, r) {
      var i = this._ecModel, a = this._tooltipModel, s = [
        r.offsetX,
        r.offsetY
      ], o = wp([
        r.tooltipOption
      ], a), l = this._renderMode, u = [], c = cr("section", {
        blocks: [],
        noHeader: true
      }), h = [], f = new NS();
      P(e, function(y) {
        P(y.dataByAxis, function(x) {
          var b = i.getComponent(x.axisDim + "Axis", x.axisIndex), _ = x.value;
          if (!(!b || _ == null)) {
            var w = dX(_, b.axis, i, x.seriesDataIndices, x.valueLabelOpt), S = cr("section", {
              header: w,
              noHeader: !ja(w),
              sortBlocks: true,
              blocks: []
            });
            c.blocks.push(S), P(x.seriesDataIndices, function(I) {
              var T = i.getSeriesByIndex(I.seriesIndex), A = I.dataIndexInside, C = T.getDataParams(A);
              if (!(C.dataIndex < 0)) {
                C.axisDim = x.axisDim, C.axisIndex = x.axisIndex, C.axisType = x.axisType, C.axisId = x.axisId, C.axisValue = DD(b.axis, {
                  value: _
                }), C.axisValueLabel = w, C.marker = f.makeTooltipMarker("item", Yc(C.color), l);
                var D = jP(T.formatTooltip(A, true, null)), E = D.frag;
                if (E) {
                  var M = wp([
                    T
                  ], a).get("valueFormatter");
                  S.blocks.push(M ? rt({
                    valueFormatter: M
                  }, E) : E);
                }
                D.text && h.push(D.text), u.push(C);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var d = r.position, p = o.get("order"), g = e$(c, f, l, p, i.get("useUTC"), o.get("textStyle"));
      g && h.unshift(g);
      var v = l === "richText" ? `

` : "<br/>", m = h.join(v);
      this._showOrMove(o, function() {
        this._updateContentNotChangedOnAxis(e, u) ? this._updatePosition(o, d, s[0], s[1], this._tooltipContent, u) : this._showTooltipContent(o, m, u, Math.random() + "", s[0], s[1], d, null, f);
      });
    }, t.prototype._showSeriesItemTooltip = function(e, r, i) {
      var a = this._ecModel, s = Ut(r), o = s.seriesIndex, l = a.getSeriesByIndex(o), u = s.dataModel || l, c = s.dataIndex, h = s.dataType, f = u.getData(h), d = this._renderMode, p = e.positionDefault, g = wp([
        f.getItemModel(c),
        u,
        l && (l.coordinateSystem || {}).model
      ], this._tooltipModel, p ? {
        position: p
      } : null), v = g.get("trigger");
      if (!(v != null && v !== "item")) {
        var m = u.getDataParams(c, h), y = new NS();
        m.marker = y.makeTooltipMarker("item", Yc(m.color), d);
        var x = jP(u.formatTooltip(c, false, h)), b = g.get("order"), _ = g.get("valueFormatter"), w = x.frag, S = w ? e$(_ ? rt({
          valueFormatter: _
        }, w) : w, y, d, b, a.get("useUTC"), g.get("textStyle")) : x.text, I = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, S, m, I, e.offsetX, e.offsetY, e.position, e.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: f.getRawIndex(c),
          seriesIndex: o,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(e, r, i) {
      var a = this._renderMode === "html", s = Ut(r), o = s.tooltipConfig, l = o.option || {}, u = l.encodeHTMLContent;
      if (wt(l)) {
        var c = l;
        l = {
          content: c,
          formatter: c
        }, u = true;
      }
      u && a && l.content && (l = Bt(l), l.content = oi(l.content));
      var h = [
        l
      ], f = this._ecModel.getComponent(s.componentMainType, s.componentIndex);
      f && h.push(f), h.push({
        formatter: l.content
      });
      var d = e.positionDefault, p = wp(h, this._tooltipModel, d ? {
        position: d
      } : null), g = p.get("content"), v = Math.random() + "", m = new NS();
      this._showOrMove(p, function() {
        var y = Bt(p.get("formatterParams") || {});
        this._showTooltipContent(p, g, y, v, e.offsetX, e.offsetY, e.position, r, m);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(e, r, i, a, s, o, l, u, c) {
      if (this._ticket = "", !(!e.get("showContent") || !e.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(e.get("enterable"));
        var f = e.get("formatter");
        l = l || e.get("position");
        var d = r, p = this._getNearestPoint([
          s,
          o
        ], i, e.get("trigger"), e.get("borderColor")), g = p.color;
        if (f) if (wt(f)) {
          var v = e.ecModel.get("useUTC"), m = ct(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
          d = f, y && (d = R1(m.axisValue, d, v)), d = h5(d, i, true);
        } else if (Nt(f)) {
          var x = St(function(b, _) {
            b === this._ticket && (h.setContent(_, c, e, g, l), this._updatePosition(e, l, s, o, h, i, u));
          }, this);
          this._ticket = a, d = f(i, a, x);
        } else d = f;
        h.setContent(d, c, e, g, l), h.show(e, g), this._updatePosition(e, l, s, o, h, i, u);
      }
    }, t.prototype._getNearestPoint = function(e, r, i, a) {
      if (i === "axis" || ct(r)) return {
        color: a || (this._renderMode === "html" ? "#fff" : "none")
      };
      if (!ct(r)) return {
        color: a || r.color || r.borderColor
      };
    }, t.prototype._updatePosition = function(e, r, i, a, s, o, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      r = r || e.get("position");
      var h = s.getSize(), f = e.get("align"), d = e.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), Nt(r) && (r = r([
        i,
        a
      ], o, s.el, p, {
        viewSize: [
          u,
          c
        ],
        contentSize: h.slice()
      })), ct(r)) i = yt(r[0], u), a = yt(r[1], c);
      else if (Ft(r)) {
        var g = r;
        g.width = h[0], g.height = h[1];
        var v = Zn(g, {
          width: u,
          height: c
        });
        i = v.x, a = v.y, f = null, d = null;
      } else if (wt(r) && l) {
        var m = rxt(r, p, h, e.get("borderWidth"));
        i = m[0], a = m[1];
      } else {
        var m = ext(i, a, s, u, c, f ? null : 20, d ? null : 20);
        i = m[0], a = m[1];
      }
      if (f && (i -= c3(f) ? h[0] / 2 : f === "right" ? h[0] : 0), d && (a -= c3(d) ? h[1] / 2 : d === "bottom" ? h[1] : 0), DX(e)) {
        var m = nxt(i, a, s, u, c);
        i = m[0], a = m[1];
      }
      s.moveTo(i, a);
    }, t.prototype._updateContentNotChangedOnAxis = function(e, r) {
      var i = this._lastDataByCoordSys, a = this._cbParamsList, s = !!i && i.length === e.length;
      return s && P(i, function(o, l) {
        var u = o.dataByAxis || [], c = e[l] || {}, h = c.dataByAxis || [];
        s = s && u.length === h.length, s && P(u, function(f, d) {
          var p = h[d] || {}, g = f.seriesDataIndices || [], v = p.seriesDataIndices || [];
          s = s && f.value === p.value && f.axisType === p.axisType && f.axisId === p.axisId && g.length === v.length, s && P(g, function(m, y) {
            var x = v[y];
            s = s && m.seriesIndex === x.seriesIndex && m.dataIndex === x.dataIndex;
          }), a && P(f.seriesDataIndices, function(m) {
            var y = m.seriesIndex, x = r[y], b = a[y];
            x && b && b.data !== x.data && (s = false);
          });
        });
      }), this._lastDataByCoordSys = e, this._cbParamsList = r, !!s;
    }, t.prototype._hide = function(e) {
      this._lastDataByCoordSys = null, e({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(e, r) {
      ce.node || !r.getDom() || (Wg(this, "_updatePosition"), this._tooltipContent.dispose(), HA("itemTooltip", r));
    }, t.type = "tooltip", t;
  }(vn);
  function wp(n, t, e) {
    var r = t.ecModel, i;
    e ? (i = new $e(e, r, r), i = new $e(t.option, i, r)) : i = t;
    for (var a = n.length - 1; a >= 0; a--) {
      var s = n[a];
      s && (s instanceof $e && (s = s.get("tooltip", true)), wt(s) && (s = {
        formatter: s
      }), s && (i = new $e(s, i, r)));
    }
    return i;
  }
  function u3(n, t) {
    return n.dispatchAction || St(t.dispatchAction, t);
  }
  function ext(n, t, e, r, i, a, s) {
    var o = e.getSize(), l = o[0], u = o[1];
    return a != null && (n + l + a + 2 > r ? n -= l + a : n += a), s != null && (t + u + s > i ? t -= u + s : t += s), [
      n,
      t
    ];
  }
  function nxt(n, t, e, r, i) {
    var a = e.getSize(), s = a[0], o = a[1];
    return n = Math.min(n + s, r) - s, t = Math.min(t + o, i) - o, n = Math.max(n, 0), t = Math.max(t, 0), [
      n,
      t
    ];
  }
  function rxt(n, t, e, r) {
    var i = e[0], a = e[1], s = Math.ceil(Math.SQRT2 * r) + 8, o = 0, l = 0, u = t.width, c = t.height;
    switch (n) {
      case "inside":
        o = t.x + u / 2 - i / 2, l = t.y + c / 2 - a / 2;
        break;
      case "top":
        o = t.x + u / 2 - i / 2, l = t.y - a - s;
        break;
      case "bottom":
        o = t.x + u / 2 - i / 2, l = t.y + c + s;
        break;
      case "left":
        o = t.x - i - s, l = t.y + c / 2 - a / 2;
        break;
      case "right":
        o = t.x + u + s, l = t.y + c / 2 - a / 2;
    }
    return [
      o,
      l
    ];
  }
  function c3(n) {
    return n === "center" || n === "middle";
  }
  function ixt(n, t, e) {
    var r = Uk(n).queryOptionMap, i = r.keys()[0];
    if (!(!i || i === "series")) {
      var a = Rv(t, i, r.get(i), {
        useDefault: false,
        enableAll: false,
        enableNone: false
      }), s = a.models[0];
      if (s) {
        var o = e.getViewOfComponentModel(s), l;
        if (o.group.traverse(function(u) {
          var c = Ut(u).tooltipConfig;
          if (c && c.name === n.name) return l = u, true;
        }), l) return {
          componentMainType: i,
          componentIndex: s.componentIndex,
          el: l
        };
      }
    }
  }
  function axt(n) {
    se(Zv), n.registerComponentModel(V0t), n.registerComponentView(txt), n.registerAction({
      type: "showTip",
      event: "showTip",
      update: "tooltip:manuallyShowTip"
    }, Dn), n.registerAction({
      type: "hideTip",
      event: "hideTip",
      update: "tooltip:manuallyHideTip"
    }, Dn);
  }
  var sxt = [
    "rect",
    "polygon",
    "keep",
    "clear"
  ];
  function oxt(n, t) {
    var e = He(n ? n.brush : []);
    if (e.length) {
      var r = [];
      P(e, function(l) {
        var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
        u instanceof Array && (r = r.concat(u));
      });
      var i = n && n.toolbox;
      ct(i) && (i = i[0]), i || (i = {
        feature: {}
      }, n.toolbox = [
        i
      ]);
      var a = i.feature || (i.feature = {}), s = a.brush || (a.brush = {}), o = s.type || (s.type = []);
      o.push.apply(o, r), lxt(o), t && !o.length && o.push.apply(o, sxt);
    }
  }
  function lxt(n) {
    var t = {};
    P(n, function(e) {
      t[e] = 1;
    }), n.length = 0, P(t, function(e, r) {
      n.push(r);
    });
  }
  var h3 = P;
  function f3(n) {
    if (n) {
      for (var t in n) if (n.hasOwnProperty(t)) return true;
    }
  }
  function ZA(n, t, e) {
    var r = {};
    return h3(t, function(a) {
      var s = r[a] = i();
      h3(n[a], function(o, l) {
        if (or.isValidType(l)) {
          var u = {
            type: l,
            visual: o
          };
          e && e(u, a), s[l] = new or(u), l === "opacity" && (u = Bt(u), u.type = "colorAlpha", s.__hidden.__alphaForOpacity = new or(u));
        }
      });
    }), r;
    function i() {
      var a = function() {
      };
      a.prototype.__hidden = a.prototype;
      var s = new a();
      return s;
    }
  }
  function NX(n, t, e) {
    var r;
    P(e, function(i) {
      t.hasOwnProperty(i) && f3(t[i]) && (r = true);
    }), r && P(e, function(i) {
      t.hasOwnProperty(i) && f3(t[i]) ? n[i] = Bt(t[i]) : delete n[i];
    });
  }
  function uxt(n, t, e, r, i, a) {
    var s = {};
    P(n, function(h) {
      var f = or.prepareVisualTypes(t[h]);
      s[h] = f;
    });
    var o;
    function l(h) {
      return xD(e, o, h);
    }
    function u(h, f) {
      tH(e, o, h, f);
    }
    e.each(c);
    function c(h, f) {
      o = h;
      var d = e.getRawDataItem(o);
      if (!(d && d.visualMap === false)) for (var p = r.call(i, h), g = t[p], v = s[p], m = 0, y = v.length; m < y; m++) {
        var x = v[m];
        g[x] && g[x].applyVisual(h, l, u);
      }
    }
  }
  function cxt(n, t, e, r) {
    var i = {};
    return P(n, function(a) {
      var s = or.prepareVisualTypes(t[a]);
      i[a] = s;
    }), {
      progress: function(s, o) {
        var l;
        r != null && (l = o.getDimensionIndex(r));
        function u(_) {
          return xD(o, h, _);
        }
        function c(_, w) {
          tH(o, h, _, w);
        }
        for (var h, f = o.getStore(); (h = s.next()) != null; ) {
          var d = o.getRawDataItem(h);
          if (!(d && d.visualMap === false)) for (var p = r != null ? f.get(l, h) : h, g = e(p), v = t[g], m = i[g], y = 0, x = m.length; y < x; y++) {
            var b = m[y];
            v[b] && v[b].applyVisual(p, u, c);
          }
        }
      }
    };
  }
  function hxt(n) {
    var t = n.brushType, e = {
      point: function(r) {
        return d3[t].point(r, e, n);
      },
      rect: function(r) {
        return d3[t].rect(r, e, n);
      }
    };
    return e;
  }
  var d3 = {
    lineX: p3(0),
    lineY: p3(1),
    rect: {
      point: function(n, t, e) {
        return n && e.boundingRect.contain(n[0], n[1]);
      },
      rect: function(n, t, e) {
        return n && e.boundingRect.intersect(n);
      }
    },
    polygon: {
      point: function(n, t, e) {
        return n && e.boundingRect.contain(n[0], n[1]) && uc(e.range, n[0], n[1]);
      },
      rect: function(n, t, e) {
        var r = e.range;
        if (!n || r.length <= 1) return false;
        var i = n.x, a = n.y, s = n.width, o = n.height, l = r[0];
        if (uc(r, i, a) || uc(r, i + s, a) || uc(r, i, a + o) || uc(r, i + s, a + o) || te.create(n).contain(l[0], l[1]) || Vp(i, a, i + s, a, r) || Vp(i, a, i, a + o, r) || Vp(i + s, a, i + s, a + o, r) || Vp(i, a + o, i + s, a + o, r)) return true;
      }
    }
  };
  function p3(n) {
    var t = [
      "x",
      "y"
    ], e = [
      "width",
      "height"
    ];
    return {
      point: function(r, i, a) {
        if (r) {
          var s = a.range, o = r[n];
          return Sp(o, s);
        }
      },
      rect: function(r, i, a) {
        if (r) {
          var s = a.range, o = [
            r[t[n]],
            r[t[n]] + r[e[n]]
          ];
          return o[1] < o[0] && o.reverse(), Sp(o[0], s) || Sp(o[1], s) || Sp(s[0], o) || Sp(s[1], o);
        }
      }
    };
  }
  function Sp(n, t) {
    return t[0] <= n && n <= t[1];
  }
  var g3 = [
    "inBrush",
    "outOfBrush"
  ], jC = "__ecBrushSelect", JA = "__ecInBrushSelectEvent";
  function LX(n) {
    n.eachComponent({
      mainType: "brush"
    }, function(t) {
      var e = t.brushTargetManager = new kE(t.option, n);
      e.setInputRanges(t.areas, n);
    });
  }
  function fxt(n, t, e) {
    var r = [], i, a;
    n.eachComponent({
      mainType: "brush"
    }, function(s) {
      e && e.type === "takeGlobalCursor" && s.setBrushOption(e.key === "brush" ? e.brushOption : {
        brushType: false
      });
    }), LX(n), n.eachComponent({
      mainType: "brush"
    }, function(s, o) {
      var l = {
        brushId: s.id,
        brushIndex: o,
        brushName: s.name,
        areas: Bt(s.areas),
        selected: []
      };
      r.push(l);
      var u = s.option, c = u.brushLink, h = [], f = [], d = [], p = false;
      o || (i = u.throttleType, a = u.throttleDelay);
      var g = ht(s.areas, function(_) {
        var w = vxt[_.brushType], S = $t({
          boundingRect: w ? w(_) : void 0
        }, _);
        return S.selectors = hxt(S), S;
      }), v = ZA(s.option, g3, function(_) {
        _.mappingMethod = "fixed";
      });
      ct(c) && P(c, function(_) {
        h[_] = 1;
      });
      function m(_) {
        return c === "all" || !!h[_];
      }
      function y(_) {
        return !!_.length;
      }
      n.eachSeries(function(_, w) {
        var S = d[w] = [];
        _.subType === "parallel" ? x(_, w) : b(_, w, S);
      });
      function x(_, w) {
        var S = _.coordinateSystem;
        p = p || S.hasAxisBrushed(), m(w) && S.eachActiveState(_.getData(), function(I, T) {
          I === "active" && (f[T] = 1);
        });
      }
      function b(_, w, S) {
        if (!(!_.brushSelector || gxt(s, w)) && (P(g, function(T) {
          s.brushTargetManager.controlSeries(T, _, n) && S.push(T), p = p || y(S);
        }), m(w) && y(S))) {
          var I = _.getData();
          I.each(function(T) {
            v3(_, S, I, T) && (f[T] = 1);
          });
        }
      }
      n.eachSeries(function(_, w) {
        var S = {
          seriesId: _.id,
          seriesIndex: w,
          seriesName: _.name,
          dataIndex: []
        };
        l.selected.push(S);
        var I = d[w], T = _.getData(), A = m(w) ? function(C) {
          return f[C] ? (S.dataIndex.push(T.getRawIndex(C)), "inBrush") : "outOfBrush";
        } : function(C) {
          return v3(_, I, T, C) ? (S.dataIndex.push(T.getRawIndex(C)), "inBrush") : "outOfBrush";
        };
        (m(w) ? p : y(I)) && uxt(g3, v, T, A);
      });
    }), dxt(t, i, a, r, e);
  }
  function dxt(n, t, e, r, i) {
    if (i) {
      var a = n.getZr();
      if (!a[JA]) {
        a[jC] || (a[jC] = pxt);
        var s = kd(a, jC, e, t);
        s(n, r);
      }
    }
  }
  function pxt(n, t) {
    if (!n.isDisposed()) {
      var e = n.getZr();
      e[JA] = true, n.dispatchAction({
        type: "brushSelect",
        batch: t
      }), e[JA] = false;
    }
  }
  function v3(n, t, e, r) {
    for (var i = 0, a = t.length; i < a; i++) {
      var s = t[i];
      if (n.brushSelector(r, e, s.selectors, s)) return true;
    }
  }
  function gxt(n, t) {
    var e = n.option.seriesIndex;
    return e != null && e !== "all" && (ct(e) ? ne(e, t) < 0 : t !== e);
  }
  var vxt = {
    rect: function(n) {
      return m3(n.range);
    },
    polygon: function(n) {
      for (var t, e = n.range, r = 0, i = e.length; r < i; r++) {
        t = t || [
          [
            1 / 0,
            -1 / 0
          ],
          [
            1 / 0,
            -1 / 0
          ]
        ];
        var a = e[r];
        a[0] < t[0][0] && (t[0][0] = a[0]), a[0] > t[0][1] && (t[0][1] = a[0]), a[1] < t[1][0] && (t[1][0] = a[1]), a[1] > t[1][1] && (t[1][1] = a[1]);
      }
      return t && m3(t);
    }
  };
  function m3(n) {
    return new te(n[0][0], n[1][0], n[0][1] - n[0][0], n[1][1] - n[1][0]);
  }
  var mxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, r) {
      this.ecModel = e, this.api = r, this.model, (this._brushController = new eE(r.getZr())).on("brush", St(this._onBrush, this)).mount();
    }, t.prototype.render = function(e, r, i, a) {
      this.model = e, this._updateController(e, r, i, a);
    }, t.prototype.updateTransform = function(e, r, i, a) {
      LX(r), this._updateController(e, r, i, a);
    }, t.prototype.updateVisual = function(e, r, i, a) {
      this.updateTransform(e, r, i, a);
    }, t.prototype.updateView = function(e, r, i, a) {
      this._updateController(e, r, i, a);
    }, t.prototype._updateController = function(e, r, i, a) {
      (!a || a.$from !== e.id) && this._brushController.setPanels(e.brushTargetManager.makePanelOpts(i)).enableBrush(e.brushOption).updateCovers(e.areas.slice());
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.prototype._onBrush = function(e) {
      var r = this.model.id, i = this.model.brushTargetManager.setOutputRanges(e.areas, this.ecModel);
      (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: r,
        areas: Bt(i),
        $from: r
      }), e.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: r,
        areas: Bt(i),
        $from: r
      });
    }, t.type = "brush", t;
  }(vn), yxt = "#ddd", xxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.areas = [], e.brushOption = {}, e;
    }
    return t.prototype.optionUpdated = function(e, r) {
      var i = this.option;
      !r && NX(i, e, [
        "inBrush",
        "outOfBrush"
      ]);
      var a = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: yxt
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, t.prototype.setAreas = function(e) {
      e && (this.areas = ht(e, function(r) {
        return y3(this.option, r);
      }, this));
    }, t.prototype.setBrushOption = function(e) {
      this.brushOption = y3(this.option, e), this.brushType = this.brushOption.brushType;
    }, t.type = "brush", t.dependencies = [
      "geo",
      "grid",
      "xAxis",
      "yAxis",
      "parallel",
      "series"
    ], t.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: true,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: true,
      z: 1e4
    }, t;
  }(pe);
  function y3(n, t) {
    return Zt({
      brushType: n.brushType,
      brushMode: n.brushMode,
      transformable: n.transformable,
      brushStyle: new $e(n.brushStyle).getItemStyle(),
      removeOnClick: n.removeOnClick,
      z: n.z
    }, t, true);
  }
  var bxt = [
    "rect",
    "polygon",
    "lineX",
    "lineY",
    "keep",
    "clear"
  ], _xt = function(n) {
    q(t, n);
    function t() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, r, i) {
      var a, s, o;
      r.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, s = l.brushOption.brushMode || "single", o = o || !!l.areas.length;
      }), this._brushType = a, this._brushMode = s, P(e.get("type", true), function(l) {
        e.setIconStatus(l, (l === "keep" ? s === "multiple" : l === "clear" ? o : l === a) ? "emphasis" : "normal");
      });
    }, t.prototype.updateView = function(e, r, i) {
      this.render(e, r, i);
    }, t.prototype.getIcons = function() {
      var e = this.model, r = e.get("icon", true), i = {};
      return P(e.get("type", true), function(a) {
        r[a] && (i[a] = r[a]);
      }), i;
    }, t.prototype.onclick = function(e, r, i) {
      var a = this._brushType, s = this._brushMode;
      i === "clear" ? (r.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), r.dispatchAction({
        type: "brush",
        command: "clear",
        areas: []
      })) : r.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? a : a === i ? false : i,
          brushMode: i === "keep" ? s === "multiple" ? "single" : "multiple" : s
        }
      });
    }, t.getDefaultOption = function(e) {
      var r = {
        show: true,
        type: bxt.slice(),
        icon: {
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        },
        title: e.getLocaleModel().get([
          "toolbox",
          "brush",
          "title"
        ])
      };
      return r;
    }, t;
  }(va);
  function wxt(n) {
    n.registerComponentView(mxt), n.registerComponentModel(xxt), n.registerPreprocessor(oxt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, fxt), n.registerAction({
      type: "brush",
      event: "brush",
      update: "updateVisual"
    }, function(t, e) {
      e.eachComponent({
        mainType: "brush",
        query: t
      }, function(r) {
        r.setAreas(t.areas);
      });
    }), n.registerAction({
      type: "brushSelect",
      event: "brushSelected",
      update: "none"
    }, Dn), n.registerAction({
      type: "brushEnd",
      event: "brushEnd",
      update: "none"
    }, Dn), df("brush", _xt);
  }
  var Sxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = {
        type: "box",
        ignoreSize: true
      }, e;
    }
    return t.type = "title", t.defaultOption = {
      z: 6,
      show: true,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, t;
  }(pe), Cxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, r, i) {
      if (this.group.removeAll(), !!e.get("show")) {
        var a = this.group, s = e.getModel("textStyle"), o = e.getModel("subtextStyle"), l = e.get("textAlign"), u = Ht(e.get("textBaseline"), e.get("textVerticalAlign")), c = new be({
          style: nn(s, {
            text: e.get("text"),
            fill: s.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        }), h = c.getBoundingRect(), f = e.get("subtext"), d = new be({
          style: nn(o, {
            text: f,
            fill: o.getTextColor(),
            y: h.height + e.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: true
          }),
          z2: 10
        }), p = e.get("link"), g = e.get("sublink"), v = e.get("triggerEvent", true);
        c.silent = !p && !v, d.silent = !g && !v, p && c.on("click", function() {
          Zx(p, "_" + e.get("target"));
        }), g && d.on("click", function() {
          Zx(g, "_" + e.get("subtarget"));
        }), Ut(c).eventData = Ut(d).eventData = v ? {
          componentType: "title",
          componentIndex: e.componentIndex
        } : null, a.add(c), f && a.add(d);
        var m = a.getBoundingRect(), y = e.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var x = Zn(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, e.get("padding"));
        l || (l = e.get("left") || e.get("right"), l === "middle" && (l = "center"), l === "right" ? x.x += x.width : l === "center" && (x.x += x.width / 2)), u || (u = e.get("top") || e.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? x.y += x.height : u === "middle" && (x.y += x.height / 2), u = u || "top"), a.x = x.x, a.y = x.y, a.markRedraw();
        var b = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(b), d.setStyle(b), m = a.getBoundingRect();
        var _ = x.margin, w = e.getItemStyle([
          "color",
          "opacity"
        ]);
        w.fill = e.get("backgroundColor");
        var S = new ye({
          shape: {
            x: m.x - _[3],
            y: m.y - _[0],
            width: m.width + _[1] + _[3],
            height: m.height + _[0] + _[2],
            r: e.get("borderRadius")
          },
          style: w,
          subPixelOptimize: true,
          silent: true
        });
        a.add(S);
      }
    }, t.type = "title", t;
  }(vn);
  function Txt(n) {
    n.registerComponentModel(Sxt), n.registerComponentView(Cxt);
  }
  var x3 = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = "box", e;
    }
    return t.prototype.init = function(e, r, i) {
      this.mergeDefaultAndTheme(e, i), this._initData();
    }, t.prototype.mergeOption = function(e) {
      n.prototype.mergeOption.apply(this, arguments), this._initData();
    }, t.prototype.setCurrentIndex = function(e) {
      e == null && (e = this.option.currentIndex);
      var r = this._data.count();
      this.option.loop ? e = (e % r + r) % r : (e >= r && (e = r - 1), e < 0 && (e = 0)), this.option.currentIndex = e;
    }, t.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, t.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, t.prototype.setPlayState = function(e) {
      this.option.autoPlay = !!e;
    }, t.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, t.prototype._initData = function() {
      var e = this.option, r = e.data || [], i = e.axisType, a = this._names = [], s;
      i === "category" ? (s = [], P(r, function(u, c) {
        var h = Un(xd(u), ""), f;
        Ft(u) ? (f = Bt(u), f.value = c) : f = c, s.push(f), a.push(h);
      })) : s = r;
      var o = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new fi([
        {
          name: "value",
          type: o
        }
      ], this);
      l.initData(s, a);
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.getCategories = function() {
      if (this.get("axisType") === "category") return this._names.slice();
    }, t.type = "timeline", t.defaultOption = {
      z: 4,
      show: true,
      axisType: "time",
      realtime: true,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: false,
      rewind: false,
      loop: true,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, t;
  }(pe), PX = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "timeline.slider", t.defaultOption = ou(x3.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: false,
      tooltip: {
        trigger: "item"
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: true,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        show: true,
        interval: "auto",
        rotate: 0,
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        animation: true,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: true,
        showPlayBtn: true,
        showPrevBtn: true,
        showNextBtn: true,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true,
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), t;
  }(x3);
  zn(PX, B1.prototype);
  var Ixt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "timeline", t;
  }(vn), Axt = function(n) {
    q(t, n);
    function t(e, r, i, a) {
      var s = n.call(this, e, r, i) || this;
      return s.type = a || "value", s;
    }
    return t.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, t.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, t;
  }(ds), KC = Math.PI, b3 = xe(), kxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, r) {
      this.api = r;
    }, t.prototype.render = function(e, r, i) {
      if (this.model = e, this.api = i, this.ecModel = r, this.group.removeAll(), e.get("show", true)) {
        var a = this._layout(e, i), s = this._createGroup("_mainGroup"), o = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, e);
        e.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return cr("nameValue", {
            noName: true,
            value: c
          });
        }, P([
          "AxisLine",
          "AxisTick",
          "Control",
          "CurrentPointer"
        ], function(u) {
          this["_render" + u](a, s, l, e);
        }, this), this._renderAxisLabel(a, o, l, e), this._position(a, e);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, t.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._clearTimer();
    }, t.prototype._layout = function(e, r) {
      var i = e.get([
        "label",
        "position"
      ]), a = e.get("orient"), s = Ext(e, r), o;
      i == null || i === "auto" ? o = a === "horizontal" ? s.y + s.height / 2 < r.getHeight() / 2 ? "-" : "+" : s.x + s.width / 2 < r.getWidth() / 2 ? "+" : "-" : wt(i) ? o = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][i] : o = i;
      var l = {
        horizontal: "center",
        vertical: o >= 0 || o === "+" ? "left" : "right"
      }, u = {
        horizontal: o >= 0 || o === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: KC / 2
      }, h = a === "vertical" ? s.height : s.width, f = e.getModel("controlStyle"), d = f.get("show", true), p = d ? f.get("itemSize") : 0, g = d ? f.get("itemGap") : 0, v = p + g, m = e.get([
        "label",
        "rotate"
      ]) || 0;
      m = m * KC / 180;
      var y, x, b, _ = f.get("position", true), w = d && f.get("showPlayBtn", true), S = d && f.get("showPrevBtn", true), I = d && f.get("showNextBtn", true), T = 0, A = h;
      _ === "left" || _ === "bottom" ? (w && (y = [
        0,
        0
      ], T += v), S && (x = [
        T,
        0
      ], T += v), I && (b = [
        A - p,
        0
      ], A -= v)) : (w && (y = [
        A - p,
        0
      ], A -= v), S && (x = [
        0,
        0
      ], T += v), I && (b = [
        A - p,
        0
      ], A -= v));
      var C = [
        T,
        A
      ];
      return e.get("inverse") && C.reverse(), {
        viewRect: s,
        mainLength: h,
        orient: a,
        rotation: c[a],
        labelRotation: m,
        labelPosOpt: o,
        labelAlign: e.get([
          "label",
          "align"
        ]) || l[a],
        labelBaseline: e.get([
          "label",
          "verticalAlign"
        ]) || e.get([
          "label",
          "baseline"
        ]) || u[a],
        playPosition: y,
        prevBtnPosition: x,
        nextBtnPosition: b,
        axisExtent: C,
        controlSize: p,
        controlGap: g
      };
    }, t.prototype._position = function(e, r) {
      var i = this._mainGroup, a = this._labelGroup, s = e.viewRect;
      if (e.orient === "vertical") {
        var o = Xi(), l = s.x, u = s.y + s.height;
        to(o, o, [
          -l,
          -u
        ]), fh(o, o, -KC / 2), to(o, o, [
          l,
          u
        ]), s = s.clone(), s.applyTransform(o);
      }
      var c = y(s), h = y(i.getBoundingRect()), f = y(a.getBoundingRect()), d = [
        i.x,
        i.y
      ], p = [
        a.x,
        a.y
      ];
      p[0] = d[0] = c[0][0];
      var g = e.labelPosOpt;
      if (g == null || wt(g)) {
        var v = g === "+" ? 0 : 1;
        x(d, h, c, 1, v), x(p, f, c, 1, 1 - v);
      } else {
        var v = g >= 0 ? 0 : 1;
        x(d, h, c, 1, v), p[1] = d[1] + g;
      }
      i.setPosition(d), a.setPosition(p), i.rotation = a.rotation = e.rotation, m(i), m(a);
      function m(b) {
        b.originX = c[0][0] - b.x, b.originY = c[1][0] - b.y;
      }
      function y(b) {
        return [
          [
            b.x,
            b.x + b.width
          ],
          [
            b.y,
            b.y + b.height
          ]
        ];
      }
      function x(b, _, w, S, I) {
        b[S] += w[S][I] - _[S][I];
      }
    }, t.prototype._createAxis = function(e, r) {
      var i = r.getData(), a = r.get("axisType"), s = Dxt(r, a);
      s.getTicks = function() {
        return i.mapArray([
          "value"
        ], function(u) {
          return {
            value: u
          };
        });
      };
      var o = i.getDataExtent("value");
      s.setExtent(o[0], o[1]), s.calcNiceTicks();
      var l = new Axt("value", s, e.axisExtent, a);
      return l.model = r, l;
    }, t.prototype._createGroup = function(e) {
      var r = this[e] = new Vt();
      return this.group.add(r), r;
    }, t.prototype._renderAxisLine = function(e, r, i, a) {
      var s = i.getExtent();
      if (a.get([
        "lineStyle",
        "show"
      ])) {
        var o = new ir({
          shape: {
            x1: s[0],
            y1: 0,
            x2: s[1],
            y2: 0
          },
          style: rt({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: true,
          z2: 1
        });
        r.add(o);
        var l = this._progressLine = new ir({
          shape: {
            x1: s[0],
            x2: this._currentPointer ? this._currentPointer.x : s[0],
            y1: 0,
            y2: 0
          },
          style: $t({
            lineCap: "round",
            lineWidth: o.style.lineWidth
          }, a.getModel([
            "progress",
            "lineStyle"
          ]).getLineStyle()),
          silent: true,
          z2: 1
        });
        r.add(l);
      }
    }, t.prototype._renderAxisTick = function(e, r, i, a) {
      var s = this, o = a.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], P(l, function(u) {
        var c = i.dataToCoord(u.value), h = o.getItemModel(u.value), f = h.getModel("itemStyle"), d = h.getModel([
          "emphasis",
          "itemStyle"
        ]), p = h.getModel([
          "progress",
          "itemStyle"
        ]), g = {
          x: c,
          y: 0,
          onclick: St(s._changeTimeline, s, u.value)
        }, v = _3(h, f, r, g);
        v.ensureState("emphasis").style = d.getItemStyle(), v.ensureState("progress").style = p.getItemStyle(), Nc(v);
        var m = Ut(v);
        h.get("tooltip") ? (m.dataIndex = u.value, m.dataModel = a) : m.dataIndex = m.dataModel = null, s._tickSymbols.push(v);
      });
    }, t.prototype._renderAxisLabel = function(e, r, i, a) {
      var s = this, o = i.getLabelModel();
      if (o.get("show")) {
        var l = a.getData(), u = i.getViewLabels();
        this._tickLabels = [], P(u, function(c) {
          var h = c.tickValue, f = l.getItemModel(h), d = f.getModel("label"), p = f.getModel([
            "emphasis",
            "label"
          ]), g = f.getModel([
            "progress",
            "label"
          ]), v = i.dataToCoord(c.tickValue), m = new be({
            x: v,
            y: 0,
            rotation: e.labelRotation - e.rotation,
            onclick: St(s._changeTimeline, s, h),
            silent: false,
            style: nn(d, {
              text: c.formattedLabel,
              align: e.labelAlign,
              verticalAlign: e.labelBaseline
            })
          });
          m.ensureState("emphasis").style = nn(p), m.ensureState("progress").style = nn(g), r.add(m), Nc(m), b3(m).dataIndex = h, s._tickLabels.push(m);
        });
      }
    }, t.prototype._renderControl = function(e, r, i, a) {
      var s = e.controlSize, o = e.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel([
        "emphasis",
        "controlStyle"
      ]).getItemStyle(), c = a.getPlayState(), h = a.get("inverse", true);
      f(e.nextBtnPosition, "next", St(this._changeTimeline, this, h ? "-" : "+")), f(e.prevBtnPosition, "prev", St(this._changeTimeline, this, h ? "+" : "-")), f(e.playPosition, c ? "stop" : "play", St(this._handlePlayClick, this, !c), true);
      function f(d, p, g, v) {
        if (d) {
          var m = ss(Ht(a.get([
            "controlStyle",
            p + "BtnSize"
          ]), s), s), y = [
            0,
            -m / 2,
            m,
            m
          ], x = Mxt(a, p + "Icon", y, {
            x: d[0],
            y: d[1],
            originX: s / 2,
            originY: 0,
            rotation: v ? -o : 0,
            rectHover: true,
            style: l,
            onclick: g
          });
          x.ensureState("emphasis").style = u, r.add(x), Nc(x);
        }
      }
    }, t.prototype._renderCurrentPointer = function(e, r, i, a) {
      var s = a.getData(), o = a.getCurrentIndex(), l = s.getItemModel(o).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(h) {
          h.draggable = true, h.drift = St(u._handlePointerDrag, u), h.ondragend = St(u._handlePointerDragend, u), w3(h, u._progressLine, o, i, a, true);
        },
        onUpdate: function(h) {
          w3(h, u._progressLine, o, i, a);
        }
      };
      this._currentPointer = _3(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, t.prototype._handlePlayClick = function(e) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: e,
        from: this.uid
      });
    }, t.prototype._handlePointerDrag = function(e, r, i) {
      this._clearTimer(), this._pointerChangeTimeline([
        i.offsetX,
        i.offsetY
      ]);
    }, t.prototype._handlePointerDragend = function(e) {
      this._pointerChangeTimeline([
        e.offsetX,
        e.offsetY
      ], true);
    }, t.prototype._pointerChangeTimeline = function(e, r) {
      var i = this._toAxisCoord(e)[0], a = this._axis, s = _a(a.getExtent().slice());
      i > s[1] && (i = s[1]), i < s[0] && (i = s[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var o = this._progressLine;
      o && (o.shape.x2 = i, o.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (r || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, t.prototype._doPlayStop = function() {
      var e = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var r = e.model;
        e._changeTimeline(r.getCurrentIndex() + (r.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, t.prototype._toAxisCoord = function(e) {
      var r = this._mainGroup.getLocalTransform();
      return es(e, r, true);
    }, t.prototype._findNearestTick = function(e) {
      var r = this.model.getData(), i = 1 / 0, a, s = this._axis;
      return r.each([
        "value"
      ], function(o, l) {
        var u = s.dataToCoord(o), c = Math.abs(u - e);
        c < i && (i = c, a = l);
      }), a;
    }, t.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, t.prototype._changeTimeline = function(e) {
      var r = this.model.getCurrentIndex();
      e === "+" ? e = r + 1 : e === "-" && (e = r - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: e,
        from: this.uid
      });
    }, t.prototype._updateTicksStatus = function() {
      var e = this.model.getCurrentIndex(), r = this._tickSymbols, i = this._tickLabels;
      if (r) for (var a = 0; a < r.length; a++) r && r[a] && r[a].toggleState("progress", a < e);
      if (i) for (var a = 0; a < i.length; a++) i && i[a] && i[a].toggleState("progress", b3(i[a]).dataIndex <= e);
    }, t.type = "timeline.slider", t;
  }(Ixt);
  function Dxt(n, t) {
    if (t = t || n.get("type"), t) switch (t) {
      case "category":
        return new H1({
          ordinalMeta: n.getCategories(),
          extent: [
            1 / 0,
            -1 / 0
          ]
        });
      case "time":
        return new AD({
          locale: n.ecModel.getLocaleModel(),
          useUTC: n.ecModel.get("useUTC")
        });
      default:
        return new Uo();
    }
  }
  function Ext(n, t) {
    return Zn(n.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    }, n.get("padding"));
  }
  function Mxt(n, t, e, r) {
    var i = r.style, a = Fv(n.get([
      "controlStyle",
      t
    ]), r || {}, new te(e[0], e[1], e[2], e[3]));
    return i && a.setStyle(i), a;
  }
  function _3(n, t, e, r, i, a) {
    var s = t.get("color");
    if (i) i.setColor(s), e.add(i), a && a.onUpdate(i);
    else {
      var o = n.get("symbol");
      i = Fn(o, -1, -1, 2, 2, s), i.setStyle("strokeNoScale", true), e.add(i), a && a.onCreate(i);
    }
    var l = t.getItemStyle([
      "color"
    ]);
    i.setStyle(l), r = Zt({
      rectHover: true,
      z2: 100
    }, r, true);
    var u = Dd(n.get("symbolSize"));
    r.scaleX = u[0] / 2, r.scaleY = u[1] / 2;
    var c = gh(n.get("symbolOffset"), u);
    c && (r.x = (r.x || 0) + c[0], r.y = (r.y || 0) + c[1]);
    var h = n.get("symbolRotate");
    return r.rotation = (h || 0) * Math.PI / 180 || 0, i.attr(r), i.updateTransform(), i;
  }
  function w3(n, t, e, r, i, a) {
    if (!n.dragging) {
      var s = i.getModel("checkpointStyle"), o = r.dataToCoord(i.getData().get("value", e));
      if (a || !s.get("animation", true)) n.attr({
        x: o,
        y: 0
      }), t && t.attr({
        shape: {
          x2: o
        }
      });
      else {
        var l = {
          duration: s.get("animationDuration", true),
          easing: s.get("animationEasing", true)
        };
        n.stopAnimation(null, true), n.animateTo({
          x: o,
          y: 0
        }, l), t && t.animateTo({
          shape: {
            x2: o
          }
        }, l);
      }
    }
  }
  function Rxt(n) {
    n.registerAction({
      type: "timelineChange",
      event: "timelineChanged",
      update: "prepareAndUpdate"
    }, function(t, e, r) {
      var i = e.getComponent("timeline");
      return i && t.currentIndex != null && (i.setCurrentIndex(t.currentIndex), !i.get("loop", true) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(false), r.dispatchAction({
        type: "timelinePlayChange",
        playState: false,
        from: t.from
      }))), e.resetOption("timeline", {
        replaceMerge: i.get("replaceMerge", true)
      }), $t({
        currentIndex: i.option.currentIndex
      }, t);
    }), n.registerAction({
      type: "timelinePlayChange",
      event: "timelinePlayChanged",
      update: "update"
    }, function(t, e) {
      var r = e.getComponent("timeline");
      r && t.playState != null && r.setPlayState(t.playState);
    });
  }
  function Nxt(n) {
    var t = n && n.timeline;
    ct(t) || (t = t ? [
      t
    ] : []), P(t, function(e) {
      e && Lxt(e);
    });
  }
  function Lxt(n) {
    var t = n.type, e = {
      number: "value",
      time: "time"
    };
    if (e[t] && (n.axisType = e[t], delete n.type), S3(n), fc(n, "controlPosition")) {
      var r = n.controlStyle || (n.controlStyle = {});
      fc(r, "position") || (r.position = n.controlPosition), r.position === "none" && !fc(r, "show") && (r.show = false, delete r.position), delete n.controlPosition;
    }
    P(n.data || [], function(i) {
      Ft(i) && !ct(i) && (!fc(i, "value") && fc(i, "name") && (i.value = i.name), S3(i));
    });
  }
  function S3(n) {
    var t = n.itemStyle || (n.itemStyle = {}), e = t.emphasis || (t.emphasis = {}), r = n.label || n.label || {}, i = r.normal || (r.normal = {}), a = {
      normal: 1,
      emphasis: 1
    };
    P(r, function(s, o) {
      !a[o] && !fc(i, o) && (i[o] = s);
    }), e.label && !fc(r, "emphasis") && (r.emphasis = e.label, delete e.label);
  }
  function fc(n, t) {
    return n.hasOwnProperty(t);
  }
  function Pxt(n) {
    n.registerComponentModel(PX), n.registerComponentView(kxt), n.registerSubTypeDefaulter("timeline", function() {
      return "slider";
    }), Rxt(n), n.registerPreprocessor(Nxt);
  }
  function ME(n, t) {
    if (!n) return false;
    for (var e = ct(n) ? n : [
      n
    ], r = 0; r < e.length; r++) if (e[r] && e[r][t]) return true;
    return false;
  }
  function g0(n) {
    Wc(n, "label", [
      "show"
    ]);
  }
  var v0 = xe(), Xo = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.createdBySelf = false, e;
    }
    return t.prototype.init = function(e, r, i) {
      this.mergeDefaultAndTheme(e, i), this._mergeOption(e, i, false, true);
    }, t.prototype.isAnimationEnabled = function() {
      if (ce.node) return false;
      var e = this.__hostSeries;
      return this.getShallow("animation") && e && e.isAnimationEnabled();
    }, t.prototype.mergeOption = function(e, r) {
      this._mergeOption(e, r, false, false);
    }, t.prototype._mergeOption = function(e, r, i, a) {
      var s = this.mainType;
      i || r.eachSeries(function(o) {
        var l = o.get(this.mainType, true), u = v0(o)[s];
        if (!l || !l.data) {
          v0(o)[s] = null;
          return;
        }
        u ? u._mergeOption(l, r, true) : (a && g0(l), P(l.data, function(c) {
          c instanceof Array ? (g0(c[0]), g0(c[1])) : g0(c);
        }), u = this.createMarkerModelFromSeries(l, this, r), rt(u, {
          mainType: this.mainType,
          seriesIndex: o.seriesIndex,
          name: o.name,
          createdBySelf: true
        }), u.__hostSeries = o), v0(o)[s] = u;
      }, this);
    }, t.prototype.formatTooltip = function(e, r, i) {
      var a = this.getData(), s = this.getRawValue(e), o = a.getName(e);
      return cr("section", {
        header: this.name,
        blocks: [
          cr("nameValue", {
            name: o,
            value: s,
            noName: !o,
            noValue: s == null
          })
        ]
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.setData = function(e) {
      this._data = e;
    }, t.prototype.getDataParams = function(e, r) {
      var i = B1.prototype.getDataParams.call(this, e, r), a = this.__hostSeries;
      return a && (i.seriesId = a.id, i.seriesName = a.name, i.seriesType = a.subType), i;
    }, t.getMarkerModelFromSeries = function(e, r) {
      return v0(e)[r];
    }, t.type = "marker", t.dependencies = [
      "series",
      "grid",
      "polar",
      "geo"
    ], t;
  }(pe);
  zn(Xo, B1.prototype);
  var $xt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, r, i) {
      return new t(e, r, i);
    }, t.type = "markPoint", t.defaultOption = {
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }, t;
  }(Xo);
  function QA(n) {
    return !(isNaN(parseFloat(n.x)) && isNaN(parseFloat(n.y)));
  }
  function Oxt(n) {
    return !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
  }
  function m0(n, t, e, r, i, a) {
    var s = [], o = Kl(t, r), l = o ? t.getCalculationInfo("stackResultDimension") : r, u = RE(t, l, n), c = t.indicesOfNearest(l, u)[0];
    s[i] = t.get(e, c), s[a] = t.get(l, c);
    var h = t.get(r, c), f = Fs(t.get(r, c));
    return f = Math.min(f, 20), f >= 0 && (s[a] = +s[a].toFixed(f)), [
      s,
      h
    ];
  }
  var ZC = {
    min: qt(m0, "min"),
    max: qt(m0, "max"),
    average: qt(m0, "average"),
    median: qt(m0, "median")
  };
  function rv(n, t) {
    if (t) {
      var e = n.getData(), r = n.coordinateSystem, i = r && r.dimensions;
      if (!Oxt(t) && !ct(t.coord) && ct(i)) {
        var a = $X(t, e, r, n);
        if (t = Bt(t), t.type && ZC[t.type] && a.baseAxis && a.valueAxis) {
          var s = ne(i, a.baseAxis.dim), o = ne(i, a.valueAxis.dim), l = ZC[t.type](e, a.baseDataDim, a.valueDataDim, s, o);
          t.coord = l[0], t.value = l[1];
        } else t.coord = [
          t.xAxis != null ? t.xAxis : t.radiusAxis,
          t.yAxis != null ? t.yAxis : t.angleAxis
        ];
      }
      if (t.coord == null || !ct(i)) t.coord = [];
      else for (var u = t.coord, c = 0; c < 2; c++) ZC[u[c]] && (u[c] = RE(e, e.mapDimension(i[c]), u[c]));
      return t;
    }
  }
  function $X(n, t, e, r) {
    var i = {};
    return n.valueIndex != null || n.valueDim != null ? (i.valueDataDim = n.valueIndex != null ? t.getDimension(n.valueIndex) : n.valueDim, i.valueAxis = e.getAxis(Fxt(r, i.valueDataDim)), i.baseAxis = e.getOtherAxis(i.valueAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim)) : (i.baseAxis = r.getBaseAxis(), i.valueAxis = e.getOtherAxis(i.baseAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim), i.valueDataDim = t.mapDimension(i.valueAxis.dim)), i;
  }
  function Fxt(n, t) {
    var e = n.getData().getDimensionInfo(t);
    return e && e.coordDim;
  }
  function iv(n, t) {
    return n && n.containData && t.coord && !QA(t) ? n.containData(t.coord) : true;
  }
  function Bxt(n, t, e) {
    return n && n.containZone && t.coord && e.coord && !QA(t) && !QA(e) ? n.containZone(t.coord, e.coord) : true;
  }
  function OX(n, t) {
    return n ? function(e, r, i, a) {
      var s = a < 2 ? e.coord && e.coord[a] : e.value;
      return Fl(s, t[a]);
    } : function(e, r, i, a) {
      return Fl(e.value, t[a]);
    };
  }
  function RE(n, t, e) {
    if (e === "average") {
      var r = 0, i = 0;
      return n.each(t, function(a, s) {
        isNaN(a) || (r += a, i++);
      }), r / i;
    } else return e === "median" ? n.getMedian(t) : n.getDataExtent(t)[e === "max" ? 1 : 0];
  }
  var JC = xe(), NE = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this.markerGroupMap = It();
    }, t.prototype.render = function(e, r, i) {
      var a = this, s = this.markerGroupMap;
      s.each(function(o) {
        JC(o).keep = false;
      }), r.eachSeries(function(o) {
        var l = Xo.getMarkerModelFromSeries(o, a.type);
        l && a.renderSeries(o, l, r, i);
      }), s.each(function(o) {
        !JC(o).keep && a.group.remove(o.group);
      });
    }, t.prototype.markKeep = function(e) {
      JC(e).keep = true;
    }, t.prototype.toggleBlurSeries = function(e, r) {
      var i = this;
      P(e, function(a) {
        var s = Xo.getMarkerModelFromSeries(a, i.type);
        if (s) {
          var o = s.getData();
          o.eachItemGraphicEl(function(l) {
            l && (r ? kU(l) : Zk(l));
          });
        }
      });
    }, t.type = "marker", t;
  }(vn);
  function C3(n, t, e) {
    var r = t.coordinateSystem;
    n.each(function(i) {
      var a = n.getItemModel(i), s, o = yt(a.get("x"), e.getWidth()), l = yt(a.get("y"), e.getHeight());
      if (!isNaN(o) && !isNaN(l)) s = [
        o,
        l
      ];
      else if (t.getMarkerPosition) s = t.getMarkerPosition(n.getValues(n.dimensions, i));
      else if (r) {
        var u = n.get(r.dimensions[0], i), c = n.get(r.dimensions[1], i);
        s = r.dataToPoint([
          u,
          c
        ]);
      }
      isNaN(o) || (s[0] = o), isNaN(l) || (s[1] = l), n.setItemLayout(i, s);
    });
  }
  var zxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, r, i) {
      r.eachSeries(function(a) {
        var s = Xo.getMarkerModelFromSeries(a, "markPoint");
        s && (C3(s.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, t.prototype.renderSeries = function(e, r, i, a) {
      var s = e.coordinateSystem, o = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(o) || u.set(o, new Uv()), h = Vxt(s, e, r);
      r.setData(h), C3(r.getData(), e, a), h.each(function(f) {
        var d = h.getItemModel(f), p = d.getShallow("symbol"), g = d.getShallow("symbolSize"), v = d.getShallow("symbolRotate"), m = d.getShallow("symbolOffset"), y = d.getShallow("symbolKeepAspect");
        if (Nt(p) || Nt(g) || Nt(v) || Nt(m)) {
          var x = r.getRawValue(f), b = r.getDataParams(f);
          Nt(p) && (p = p(x, b)), Nt(g) && (g = g(x, b)), Nt(v) && (v = v(x, b)), Nt(m) && (m = m(x, b));
        }
        var _ = d.getModel("itemStyle").getItemStyle(), w = zv(l, "color");
        _.fill || (_.fill = w), h.setItemVisual(f, {
          symbol: p,
          symbolSize: g,
          symbolRotate: v,
          symbolOffset: m,
          symbolKeepAspect: y,
          style: _
        });
      }), c.updateData(h), this.group.add(c.group), h.eachItemGraphicEl(function(f) {
        f.traverse(function(d) {
          Ut(d).dataModel = r;
        });
      }), this.markKeep(c), c.group.silent = r.get("silent") || e.get("silent");
    }, t.type = "markPoint", t;
  }(NE);
  function Vxt(n, t, e) {
    var r;
    n ? r = ht(n && n.dimensions, function(o) {
      var l = t.getData().getDimensionInfo(t.getData().mapDimension(o)) || {};
      return rt(rt({}, l), {
        name: o,
        ordinalMeta: null
      });
    }) : r = [
      {
        name: "value",
        type: "float"
      }
    ];
    var i = new fi(r, e), a = ht(e.get("data"), qt(rv, t));
    n && (a = Le(a, qt(iv, n)));
    var s = OX(!!n, r);
    return i.initData(a, null, s), i;
  }
  function Gxt(n) {
    n.registerComponentModel($xt), n.registerComponentView(zxt), n.registerPreprocessor(function(t) {
      ME(t.series, "markPoint") && (t.markPoint = t.markPoint || {});
    });
  }
  var Wxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, r, i) {
      return new t(e, r, i);
    }, t.type = "markLine", t.defaultOption = {
      z: 5,
      symbol: [
        "circle",
        "arrow"
      ],
      symbolSize: [
        8,
        16
      ],
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, t;
  }(Xo), y0 = xe(), Uxt = function(n, t, e, r) {
    var i = n.getData(), a;
    if (ct(r)) a = r;
    else {
      var s = r.type;
      if (s === "min" || s === "max" || s === "average" || s === "median" || r.xAxis != null || r.yAxis != null) {
        var o = void 0, l = void 0;
        if (r.yAxis != null || r.xAxis != null) o = t.getAxis(r.yAxis != null ? "y" : "x"), l = mr(r.yAxis, r.xAxis);
        else {
          var u = $X(r, i, t, n);
          o = u.valueAxis;
          var c = DH(i, u.valueDataDim);
          l = RE(i, c, s);
        }
        var h = o.dim === "x" ? 0 : 1, f = 1 - h, d = Bt(r), p = {
          coord: []
        };
        d.type = null, d.coord = [], d.coord[f] = -1 / 0, p.coord[f] = 1 / 0;
        var g = e.get("precision");
        g >= 0 && _e(l) && (l = +l.toFixed(Math.min(g, 20))), d.coord[h] = p.coord[h] = l, a = [
          d,
          p,
          {
            type: s,
            valueIndex: r.valueIndex,
            value: l
          }
        ];
      } else a = [];
    }
    var v = [
      rv(n, a[0]),
      rv(n, a[1]),
      rt({}, a[2])
    ];
    return v[2].type = v[2].type || null, Zt(v[2], v[0]), Zt(v[2], v[1]), v;
  };
  function wb(n) {
    return !isNaN(n) && !isFinite(n);
  }
  function T3(n, t, e, r) {
    var i = 1 - n, a = r.dimensions[n];
    return wb(t[i]) && wb(e[i]) && t[n] === e[n] && r.getAxis(a).containData(t[n]);
  }
  function Hxt(n, t) {
    if (n.type === "cartesian2d") {
      var e = t[0].coord, r = t[1].coord;
      if (e && r && (T3(1, e, r, n) || T3(0, e, r, n))) return true;
    }
    return iv(n, t[0]) && iv(n, t[1]);
  }
  function QC(n, t, e, r, i) {
    var a = r.coordinateSystem, s = n.getItemModel(t), o, l = yt(s.get("x"), i.getWidth()), u = yt(s.get("y"), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) o = [
      l,
      u
    ];
    else {
      if (r.getMarkerPosition) o = r.getMarkerPosition(n.getValues(n.dimensions, t));
      else {
        var c = a.dimensions, h = n.get(c[0], t), f = n.get(c[1], t);
        o = a.dataToPoint([
          h,
          f
        ]);
      }
      if (mh(a, "cartesian2d")) {
        var d = a.getAxis("x"), p = a.getAxis("y"), c = a.dimensions;
        wb(n.get(c[0], t)) ? o[0] = d.toGlobalCoord(d.getExtent()[e ? 0 : 1]) : wb(n.get(c[1], t)) && (o[1] = p.toGlobalCoord(p.getExtent()[e ? 0 : 1]));
      }
      isNaN(l) || (o[0] = l), isNaN(u) || (o[1] = u);
    }
    n.setItemLayout(t, o);
  }
  var Xxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, r, i) {
      r.eachSeries(function(a) {
        var s = Xo.getMarkerModelFromSeries(a, "markLine");
        if (s) {
          var o = s.getData(), l = y0(s).from, u = y0(s).to;
          l.each(function(c) {
            QC(l, c, true, a, i), QC(u, c, false, a, i);
          }), o.each(function(c) {
            o.setItemLayout(c, [
              l.getItemLayout(c),
              u.getItemLayout(c)
            ]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, t.prototype.renderSeries = function(e, r, i, a) {
      var s = e.coordinateSystem, o = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(o) || u.set(o, new tE());
      this.group.add(c.group);
      var h = Yxt(s, e, r), f = h.from, d = h.to, p = h.line;
      y0(r).from = f, y0(r).to = d, r.setData(p);
      var g = r.get("symbol"), v = r.get("symbolSize"), m = r.get("symbolRotate"), y = r.get("symbolOffset");
      ct(g) || (g = [
        g,
        g
      ]), ct(v) || (v = [
        v,
        v
      ]), ct(m) || (m = [
        m,
        m
      ]), ct(y) || (y = [
        y,
        y
      ]), h.from.each(function(b) {
        x(f, b, true), x(d, b, false);
      }), p.each(function(b) {
        var _ = p.getItemModel(b).getModel("lineStyle").getLineStyle();
        p.setItemLayout(b, [
          f.getItemLayout(b),
          d.getItemLayout(b)
        ]), _.stroke == null && (_.stroke = f.getItemVisual(b, "style").fill), p.setItemVisual(b, {
          fromSymbolKeepAspect: f.getItemVisual(b, "symbolKeepAspect"),
          fromSymbolOffset: f.getItemVisual(b, "symbolOffset"),
          fromSymbolRotate: f.getItemVisual(b, "symbolRotate"),
          fromSymbolSize: f.getItemVisual(b, "symbolSize"),
          fromSymbol: f.getItemVisual(b, "symbol"),
          toSymbolKeepAspect: d.getItemVisual(b, "symbolKeepAspect"),
          toSymbolOffset: d.getItemVisual(b, "symbolOffset"),
          toSymbolRotate: d.getItemVisual(b, "symbolRotate"),
          toSymbolSize: d.getItemVisual(b, "symbolSize"),
          toSymbol: d.getItemVisual(b, "symbol"),
          style: _
        });
      }), c.updateData(p), h.line.eachItemGraphicEl(function(b) {
        Ut(b).dataModel = r, b.traverse(function(_) {
          Ut(_).dataModel = r;
        });
      });
      function x(b, _, w) {
        var S = b.getItemModel(_);
        QC(b, _, w, e, a);
        var I = S.getModel("itemStyle").getItemStyle();
        I.fill == null && (I.fill = zv(l, "color")), b.setItemVisual(_, {
          symbolKeepAspect: S.get("symbolKeepAspect"),
          symbolOffset: Ht(S.get("symbolOffset", true), y[w ? 0 : 1]),
          symbolRotate: Ht(S.get("symbolRotate", true), m[w ? 0 : 1]),
          symbolSize: Ht(S.get("symbolSize"), v[w ? 0 : 1]),
          symbol: Ht(S.get("symbol", true), g[w ? 0 : 1]),
          style: I
        });
      }
      this.markKeep(c), c.group.silent = r.get("silent") || e.get("silent");
    }, t.type = "markLine", t;
  }(NE);
  function Yxt(n, t, e) {
    var r;
    n ? r = ht(n && n.dimensions, function(u) {
      var c = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {};
      return rt(rt({}, c), {
        name: u,
        ordinalMeta: null
      });
    }) : r = [
      {
        name: "value",
        type: "float"
      }
    ];
    var i = new fi(r, e), a = new fi(r, e), s = new fi([], e), o = ht(e.get("data"), qt(Uxt, t, n, e));
    n && (o = Le(o, qt(Hxt, n)));
    var l = OX(!!n, r);
    return i.initData(ht(o, function(u) {
      return u[0];
    }), null, l), a.initData(ht(o, function(u) {
      return u[1];
    }), null, l), s.initData(ht(o, function(u) {
      return u[2];
    })), s.hasItemOption = true, {
      from: i,
      to: a,
      line: s
    };
  }
  function qxt(n) {
    n.registerComponentModel(Wxt), n.registerComponentView(Xxt), n.registerPreprocessor(function(t) {
      ME(t.series, "markLine") && (t.markLine = t.markLine || {});
    });
  }
  var jxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, r, i) {
      return new t(e, r, i);
    }, t.type = "markArea", t.defaultOption = {
      z: 1,
      tooltip: {
        trigger: "item"
      },
      animation: false,
      label: {
        show: true,
        position: "top"
      },
      itemStyle: {
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: true,
          position: "top"
        }
      }
    }, t;
  }(Xo), x0 = xe(), Kxt = function(n, t, e, r) {
    var i = r[0], a = r[1];
    if (!(!i || !a)) {
      var s = rv(n, i), o = rv(n, a), l = s.coord, u = o.coord;
      l[0] = mr(l[0], -1 / 0), l[1] = mr(l[1], -1 / 0), u[0] = mr(u[0], 1 / 0), u[1] = mr(u[1], 1 / 0);
      var c = Nk([
        {},
        s,
        o
      ]);
      return c.coord = [
        s.coord,
        o.coord
      ], c.x0 = s.x, c.y0 = s.y, c.x1 = o.x, c.y1 = o.y, c;
    }
  };
  function Sb(n) {
    return !isNaN(n) && !isFinite(n);
  }
  function I3(n, t, e, r) {
    var i = 1 - n;
    return Sb(t[i]) && Sb(e[i]);
  }
  function Zxt(n, t) {
    var e = t.coord[0], r = t.coord[1], i = {
      coord: e,
      x: t.x0,
      y: t.y0
    }, a = {
      coord: r,
      x: t.x1,
      y: t.y1
    };
    return mh(n, "cartesian2d") ? e && r && (I3(1, e, r) || I3(0, e, r)) ? true : Bxt(n, i, a) : iv(n, i) || iv(n, a);
  }
  function A3(n, t, e, r, i) {
    var a = r.coordinateSystem, s = n.getItemModel(t), o, l = yt(s.get(e[0]), i.getWidth()), u = yt(s.get(e[1]), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) o = [
      l,
      u
    ];
    else {
      if (r.getMarkerPosition) {
        var c = n.getValues([
          "x0",
          "y0"
        ], t), h = n.getValues([
          "x1",
          "y1"
        ], t), f = a.clampData(c), d = a.clampData(h), p = [];
        e[0] === "x0" ? p[0] = f[0] > d[0] ? h[0] : c[0] : p[0] = f[0] > d[0] ? c[0] : h[0], e[1] === "y0" ? p[1] = f[1] > d[1] ? h[1] : c[1] : p[1] = f[1] > d[1] ? c[1] : h[1], o = r.getMarkerPosition(p, e, true);
      } else {
        var g = n.get(e[0], t), v = n.get(e[1], t), m = [
          g,
          v
        ];
        a.clampData && a.clampData(m, m), o = a.dataToPoint(m, true);
      }
      if (mh(a, "cartesian2d")) {
        var y = a.getAxis("x"), x = a.getAxis("y"), g = n.get(e[0], t), v = n.get(e[1], t);
        Sb(g) ? o[0] = y.toGlobalCoord(y.getExtent()[e[0] === "x0" ? 0 : 1]) : Sb(v) && (o[1] = x.toGlobalCoord(x.getExtent()[e[1] === "y0" ? 0 : 1]));
      }
      isNaN(l) || (o[0] = l), isNaN(u) || (o[1] = u);
    }
    return o;
  }
  var k3 = [
    [
      "x0",
      "y0"
    ],
    [
      "x1",
      "y0"
    ],
    [
      "x1",
      "y1"
    ],
    [
      "x0",
      "y1"
    ]
  ], Jxt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, r, i) {
      r.eachSeries(function(a) {
        var s = Xo.getMarkerModelFromSeries(a, "markArea");
        if (s) {
          var o = s.getData();
          o.each(function(l) {
            var u = ht(k3, function(h) {
              return A3(o, l, h, a, i);
            });
            o.setItemLayout(l, u);
            var c = o.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, t.prototype.renderSeries = function(e, r, i, a) {
      var s = e.coordinateSystem, o = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(o) || u.set(o, {
        group: new Vt()
      });
      this.group.add(c.group), this.markKeep(c);
      var h = Qxt(s, e, r);
      r.setData(h), h.each(function(f) {
        var d = ht(k3, function(I) {
          return A3(h, f, I, e, a);
        }), p = s.getAxis("x").scale, g = s.getAxis("y").scale, v = p.getExtent(), m = g.getExtent(), y = [
          p.parse(h.get("x0", f)),
          p.parse(h.get("x1", f))
        ], x = [
          g.parse(h.get("y0", f)),
          g.parse(h.get("y1", f))
        ];
        _a(y), _a(x);
        var b = !(v[0] > y[1] || v[1] < y[0] || m[0] > x[1] || m[1] < x[0]), _ = !b;
        h.setItemLayout(f, {
          points: d,
          allClipped: _
        });
        var w = h.getItemModel(f).getModel("itemStyle").getItemStyle(), S = zv(l, "color");
        w.fill || (w.fill = S, wt(w.fill) && (w.fill = Bx(w.fill, 0.4))), w.stroke || (w.stroke = S), h.setItemVisual(f, "style", w);
      }), h.diff(x0(c).data).add(function(f) {
        var d = h.getItemLayout(f);
        if (!d.allClipped) {
          var p = new yi({
            shape: {
              points: d.points
            }
          });
          h.setItemGraphicEl(f, p), c.group.add(p);
        }
      }).update(function(f, d) {
        var p = x0(c).data.getItemGraphicEl(d), g = h.getItemLayout(f);
        g.allClipped ? p && c.group.remove(p) : (p ? Ie(p, {
          shape: {
            points: g.points
          }
        }, r, f) : p = new yi({
          shape: {
            points: g.points
          }
        }), h.setItemGraphicEl(f, p), c.group.add(p));
      }).remove(function(f) {
        var d = x0(c).data.getItemGraphicEl(f);
        c.group.remove(d);
      }).execute(), h.eachItemGraphicEl(function(f, d) {
        var p = h.getItemModel(d), g = h.getItemVisual(d, "style");
        f.useStyle(h.getItemVisual(d, "style")), kr(f, ur(p), {
          labelFetcher: r,
          labelDataIndex: d,
          defaultText: h.getName(d) || "",
          inheritColor: wt(g.fill) ? Bx(g.fill, 1) : "#000"
        }), Ar(f, p), bn(f, null, null, p.get([
          "emphasis",
          "disabled"
        ])), Ut(f).dataModel = r;
      }), x0(c).data = h, c.group.silent = r.get("silent") || e.get("silent");
    }, t.type = "markArea", t;
  }(NE);
  function Qxt(n, t, e) {
    var r, i, a = [
      "x0",
      "y0",
      "x1",
      "y1"
    ];
    if (n) {
      var s = ht(n && n.dimensions, function(u) {
        var c = t.getData(), h = c.getDimensionInfo(c.mapDimension(u)) || {};
        return rt(rt({}, h), {
          name: u,
          ordinalMeta: null
        });
      });
      i = ht(a, function(u, c) {
        return {
          name: u,
          type: s[c % 2].type
        };
      }), r = new fi(i, e);
    } else i = [
      {
        name: "value",
        type: "float"
      }
    ], r = new fi(i, e);
    var o = ht(e.get("data"), qt(Kxt, t, n, e));
    n && (o = Le(o, qt(Zxt, n)));
    var l = n ? function(u, c, h, f) {
      var d = u.coord[Math.floor(f / 2)][f % 2];
      return Fl(d, i[f]);
    } : function(u, c, h, f) {
      return Fl(u.value, i[f]);
    };
    return r.initData(o, null, l), r.hasItemOption = true, r;
  }
  function tbt(n) {
    n.registerComponentModel(jxt), n.registerComponentView(Jxt), n.registerPreprocessor(function(t) {
      ME(t.series, "markArea") && (t.markArea = t.markArea || {});
    });
  }
  var ebt = function(n, t) {
    if (t === "all") return {
      type: "all",
      title: n.getLocaleModel().get([
        "legend",
        "selector",
        "all"
      ])
    };
    if (t === "inverse") return {
      type: "inverse",
      title: n.getLocaleModel().get([
        "legend",
        "selector",
        "inverse"
      ])
    };
  }, t2 = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = {
        type: "box",
        ignoreSize: true
      }, e;
    }
    return t.prototype.init = function(e, r, i) {
      this.mergeDefaultAndTheme(e, i), e.selected = e.selected || {}, this._updateSelector(e);
    }, t.prototype.mergeOption = function(e, r) {
      n.prototype.mergeOption.call(this, e, r), this._updateSelector(e);
    }, t.prototype._updateSelector = function(e) {
      var r = e.selector, i = this.ecModel;
      r === true && (r = e.selector = [
        "all",
        "inverse"
      ]), ct(r) && P(r, function(a, s) {
        wt(a) && (a = {
          type: a
        }), r[s] = Zt(a, ebt(i, a.type));
      });
    }, t.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var e = this._data;
      if (e[0] && this.get("selectedMode") === "single") {
        for (var r = false, i = 0; i < e.length; i++) {
          var a = e[i].get("name");
          if (this.isSelected(a)) {
            this.select(a), r = true;
            break;
          }
        }
        !r && this.select(e[0].get("name"));
      }
    }, t.prototype._updateData = function(e) {
      var r = [], i = [];
      e.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var h = l.legendVisualProvider, f = h.getAllNames();
          e.isSeriesFiltered(l) || (i = i.concat(f)), f.length ? r = r.concat(f) : c = true;
        } else c = true;
        c && Wk(l) && r.push(l.name);
      }), this._availableNames = i;
      var a = this.get("data") || r, s = It(), o = ht(a, function(l) {
        return (wt(l) || _e(l)) && (l = {
          name: l
        }), s.get(l.name) ? null : (s.set(l.name, true), new $e(l, this, this.ecModel));
      }, this);
      this._data = Le(o, function(l) {
        return !!l;
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.select = function(e) {
      var r = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var a = this._data;
        P(a, function(s) {
          r[s.get("name")] = false;
        });
      }
      r[e] = true;
    }, t.prototype.unSelect = function(e) {
      this.get("selectedMode") !== "single" && (this.option.selected[e] = false);
    }, t.prototype.toggleSelected = function(e) {
      var r = this.option.selected;
      r.hasOwnProperty(e) || (r[e] = true), this[r[e] ? "unSelect" : "select"](e);
    }, t.prototype.allSelect = function() {
      var e = this._data, r = this.option.selected;
      P(e, function(i) {
        r[i.get("name", true)] = true;
      });
    }, t.prototype.inverseSelect = function() {
      var e = this._data, r = this.option.selected;
      P(e, function(i) {
        var a = i.get("name", true);
        r.hasOwnProperty(a) || (r[a] = true), r[a] = !r[a];
      });
    }, t.prototype.isSelected = function(e) {
      var r = this.option.selected;
      return !(r.hasOwnProperty(e) && !r[e]) && ne(this._availableNames, e) >= 0;
    }, t.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, t.type = "legend.plain", t.dependencies = [
      "series"
    ], t.defaultOption = {
      z: 4,
      show: true,
      orient: "horizontal",
      left: "center",
      top: 0,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: true,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: true,
      selector: false,
      selectorLabel: {
        show: true,
        borderRadius: 10,
        padding: [
          3,
          5,
          3,
          5
        ],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: true,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: false
      }
    }, t;
  }(pe), Kh = qt, e2 = P, b0 = Vt, FX = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.newlineDisabled = false, e;
    }
    return t.prototype.init = function() {
      this.group.add(this._contentGroup = new b0()), this.group.add(this._selectorGroup = new b0()), this._isFirstRender = true;
    }, t.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, t.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, t.prototype.render = function(e, r, i) {
      var a = this._isFirstRender;
      if (this._isFirstRender = false, this.resetInner(), !!e.get("show", true)) {
        var s = e.get("align"), o = e.get("orient");
        (!s || s === "auto") && (s = e.get("left") === "right" && o === "vertical" ? "right" : "left");
        var l = e.get("selector", true), u = e.get("selectorPosition", true);
        l && (!u || u === "auto") && (u = o === "horizontal" ? "end" : "start"), this.renderInner(s, e, r, i, l, o, u);
        var c = e.getBoxLayoutParams(), h = {
          width: i.getWidth(),
          height: i.getHeight()
        }, f = e.get("padding"), d = Zn(c, h, f), p = this.layoutInner(e, s, d, a, l, u), g = Zn($t({
          width: p.width,
          height: p.height
        }, c), h, f);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = IX(p, e));
      }
    }, t.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, t.prototype.renderInner = function(e, r, i, a, s, o, l) {
      var u = this.getContentGroup(), c = It(), h = r.get("selectedMode"), f = [];
      i.eachRawSeries(function(d) {
        !d.get("legendHoverLink") && f.push(d.id);
      }), e2(r.getData(), function(d, p) {
        var g = d.get("name");
        if (!this.newlineDisabled && (g === "" || g === `
`)) {
          var v = new b0();
          v.newline = true, u.add(v);
          return;
        }
        var m = i.getSeriesByName(g)[0];
        if (!c.get(g)) if (m) {
          var y = m.getData(), x = y.getVisual("legendLineStyle") || {}, b = y.getVisual("legendIcon"), _ = y.getVisual("style"), w = this._createItem(m, g, p, d, r, e, x, _, b, h, a);
          w.on("click", Kh(D3, g, null, a, f)).on("mouseover", Kh(n2, m.name, null, a, f)).on("mouseout", Kh(r2, m.name, null, a, f)), i.ssr && w.eachChild(function(S) {
            var I = Ut(S);
            I.seriesIndex = m.seriesIndex, I.dataIndex = p, I.ssrType = "legend";
          }), c.set(g, true);
        } else i.eachRawSeries(function(S) {
          if (!c.get(g) && S.legendVisualProvider) {
            var I = S.legendVisualProvider;
            if (!I.containName(g)) return;
            var T = I.indexOfName(g), A = I.getItemVisual(T, "style"), C = I.getItemVisual(T, "legendIcon"), D = Yi(A.fill);
            D && D[3] === 0 && (D[3] = 0.2, A = rt(rt({}, A), {
              fill: No(D, "rgba")
            }));
            var E = this._createItem(S, g, p, d, r, e, {}, A, C, h, a);
            E.on("click", Kh(D3, null, g, a, f)).on("mouseover", Kh(n2, null, g, a, f)).on("mouseout", Kh(r2, null, g, a, f)), i.ssr && E.eachChild(function(M) {
              var L = Ut(M);
              L.seriesIndex = S.seriesIndex, L.dataIndex = p, L.ssrType = "legend";
            }), c.set(g, true);
          }
        }, this);
      }, this), s && this._createSelector(s, r, a, o, l);
    }, t.prototype._createSelector = function(e, r, i, a, s) {
      var o = this.getSelectorGroup();
      e2(e, function(u) {
        var c = u.type, h = new be({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect",
              legendId: r.id
            });
          }
        });
        o.add(h);
        var f = r.getModel("selectorLabel"), d = r.getModel([
          "emphasis",
          "selectorLabel"
        ]);
        kr(h, {
          normal: f,
          emphasis: d
        }, {
          defaultText: u.title
        }), Nc(h);
      });
    }, t.prototype._createItem = function(e, r, i, a, s, o, l, u, c, h, f) {
      var d = e.visualDrawType, p = s.get("itemWidth"), g = s.get("itemHeight"), v = s.isSelected(r), m = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), x = a.get("icon");
      c = x || c || "roundRect";
      var b = nbt(c, a, l, u, d, v, f), _ = new b0(), w = a.getModel("textStyle");
      if (Nt(e.getLegendIcon) && (!x || x === "inherit")) _.add(e.getLegendIcon({
        itemWidth: p,
        itemHeight: g,
        icon: c,
        iconRotate: m,
        itemStyle: b.itemStyle,
        lineStyle: b.lineStyle,
        symbolKeepAspect: y
      }));
      else {
        var S = x === "inherit" && e.getData().getVisual("symbol") ? m === "inherit" ? e.getData().getVisual("symbolRotate") : m : 0;
        _.add(rbt({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: S,
          itemStyle: b.itemStyle,
          symbolKeepAspect: y
        }));
      }
      var I = o === "left" ? p + 5 : -5, T = o, A = s.get("formatter"), C = r;
      wt(A) && A ? C = A.replace("{name}", r ?? "") : Nt(A) && (C = A(r));
      var D = v ? w.getTextColor() : a.get("inactiveColor");
      _.add(new be({
        style: nn(w, {
          text: C,
          x: I,
          y: g / 2,
          fill: D,
          align: T,
          verticalAlign: "middle"
        }, {
          inheritColor: D
        })
      }));
      var E = new ye({
        shape: _.getBoundingRect(),
        style: {
          fill: "transparent"
        }
      }), M = a.getModel("tooltip");
      return M.get("show") && dh({
        el: E,
        componentModel: s,
        itemName: r,
        itemTooltipOption: M.option
      }), _.add(E), _.eachChild(function(L) {
        L.silent = true;
      }), E.silent = !h, this.getContentGroup().add(_), Nc(_), _.__legendDataIndex = i, _;
    }, t.prototype.layoutInner = function(e, r, i, a, s, o) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      Pc(e.get("orient"), l, e.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), h = [
        -c.x,
        -c.y
      ];
      if (u.markRedraw(), l.markRedraw(), s) {
        Pc("horizontal", u, e.get("selectorItemGap", true));
        var f = u.getBoundingRect(), d = [
          -f.x,
          -f.y
        ], p = e.get("selectorButtonGap", true), g = e.getOrient().index, v = g === 0 ? "width" : "height", m = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
        o === "end" ? d[g] += c[v] + p : h[g] += f[v] + p, d[1 - g] += c[m] / 2 - f[m] / 2, u.x = d[0], u.y = d[1], l.x = h[0], l.y = h[1];
        var x = {
          x: 0,
          y: 0
        };
        return x[v] = c[v] + p + f[v], x[m] = Math.max(c[m], f[m]), x[y] = Math.min(0, f[y] + d[1 - g]), x;
      } else return l.x = h[0], l.y = h[1], this.group.getBoundingRect();
    }, t.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = true;
    }, t.type = "legend.plain", t;
  }(vn);
  function nbt(n, t, e, r, i, a, s) {
    function o(v, m) {
      v.lineWidth === "auto" && (v.lineWidth = m.lineWidth > 0 ? 2 : 0), e2(v, function(y, x) {
        v[x] === "inherit" && (v[x] = m[x]);
      });
    }
    var l = t.getModel("itemStyle"), u = l.getItemStyle(), c = n.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", h = l.getShallow("decal");
    u.decal = !h || h === "inherit" ? r.decal : Uf(h, s), u.fill === "inherit" && (u.fill = r[i]), u.stroke === "inherit" && (u.stroke = r[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? r : e).opacity), o(u, r);
    var f = t.getModel("lineStyle"), d = f.getLineStyle();
    if (o(d, e), u.fill === "auto" && (u.fill = r.fill), u.stroke === "auto" && (u.stroke = r.fill), d.stroke === "auto" && (d.stroke = r.fill), !a) {
      var p = t.get("inactiveBorderWidth"), g = u[c];
      u.lineWidth = p === "auto" ? r.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = t.get("inactiveColor"), u.stroke = t.get("inactiveBorderColor"), d.stroke = f.get("inactiveColor"), d.lineWidth = f.get("inactiveWidth");
    }
    return {
      itemStyle: u,
      lineStyle: d
    };
  }
  function rbt(n) {
    var t = n.icon || "roundRect", e = Fn(t, 0, 0, n.itemWidth, n.itemHeight, n.itemStyle.fill, n.symbolKeepAspect);
    return e.setStyle(n.itemStyle), e.rotation = (n.iconRotate || 0) * Math.PI / 180, e.setOrigin([
      n.itemWidth / 2,
      n.itemHeight / 2
    ]), t.indexOf("empty") > -1 && (e.style.stroke = e.style.fill, e.style.fill = "#fff", e.style.lineWidth = 2), e;
  }
  function D3(n, t, e, r) {
    r2(n, t, e, r), e.dispatchAction({
      type: "legendToggleSelect",
      name: n ?? t
    }), n2(n, t, e, r);
  }
  function BX(n) {
    for (var t = n.getZr().storage.getDisplayList(), e, r = 0, i = t.length; r < i && !(e = t[r].states.emphasis); ) r++;
    return e && e.hoverLayer;
  }
  function n2(n, t, e, r) {
    BX(e) || e.dispatchAction({
      type: "highlight",
      seriesName: n,
      name: t,
      excludeSeriesId: r
    });
  }
  function r2(n, t, e, r) {
    BX(e) || e.dispatchAction({
      type: "downplay",
      seriesName: n,
      name: t,
      excludeSeriesId: r
    });
  }
  function ibt(n) {
    var t = n.findComponents({
      mainType: "legend"
    });
    t && t.length && n.filterSeries(function(e) {
      for (var r = 0; r < t.length; r++) if (!t[r].isSelected(e.name)) return false;
      return true;
    });
  }
  function Cp(n, t, e) {
    var r = n === "allSelect" || n === "inverseSelect", i = {}, a = [];
    e.eachComponent({
      mainType: "legend",
      query: t
    }, function(o) {
      r ? o[n]() : o[n](t.name), E3(o, i), a.push(o.componentIndex);
    });
    var s = {};
    return e.eachComponent("legend", function(o) {
      P(i, function(l, u) {
        o[l ? "select" : "unSelect"](u);
      }), E3(o, s);
    }), r ? {
      selected: s,
      legendIndex: a
    } : {
      name: t.name,
      selected: s
    };
  }
  function E3(n, t) {
    var e = t || {};
    return P(n.getData(), function(r) {
      var i = r.get("name");
      if (!(i === `
` || i === "")) {
        var a = n.isSelected(i);
        Ct(e, i) ? e[i] = e[i] && a : e[i] = a;
      }
    }), e;
  }
  function abt(n) {
    n.registerAction("legendToggleSelect", "legendselectchanged", qt(Cp, "toggleSelected")), n.registerAction("legendAllSelect", "legendselectall", qt(Cp, "allSelect")), n.registerAction("legendInverseSelect", "legendinverseselect", qt(Cp, "inverseSelect")), n.registerAction("legendSelect", "legendselected", qt(Cp, "select")), n.registerAction("legendUnSelect", "legendunselected", qt(Cp, "unSelect"));
  }
  function zX(n) {
    n.registerComponentModel(t2), n.registerComponentView(FX), n.registerProcessor(n.PRIORITY.PROCESSOR.SERIES_FILTER, ibt), n.registerSubTypeDefaulter("legend", function() {
      return "plain";
    }), abt(n);
  }
  var sbt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.setScrollDataIndex = function(e) {
      this.option.scrollDataIndex = e;
    }, t.prototype.init = function(e, r, i) {
      var a = Td(e);
      n.prototype.init.call(this, e, r, i), M3(this, e, a);
    }, t.prototype.mergeOption = function(e, r) {
      n.prototype.mergeOption.call(this, e, r), M3(this, this.option, e);
    }, t.type = "legend.scroll", t.defaultOption = ou(t2.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: [
          "M0,0L12,-10L12,10z",
          "M0,0L-12,-10L-12,10z"
        ],
        vertical: [
          "M0,0L20,0L10,-20z",
          "M0,0L20,0L10,20z"
        ]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), t;
  }(t2);
  function M3(n, t, e) {
    var r = n.getOrient(), i = [
      1,
      1
    ];
    i[r.index] = 0, jl(t, e, {
      type: "box",
      ignoreSize: !!i
    });
  }
  var R3 = Vt, tT = [
    "width",
    "height"
  ], eT = [
    "x",
    "y"
  ], obt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.newlineDisabled = true, e._currentIndex = 0, e;
    }
    return t.prototype.init = function() {
      n.prototype.init.call(this), this.group.add(this._containerGroup = new R3()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new R3());
    }, t.prototype.resetInner = function() {
      n.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, t.prototype.renderInner = function(e, r, i, a, s, o, l) {
      var u = this;
      n.prototype.renderInner.call(this, e, r, i, a, s, o, l);
      var c = this._controllerGroup, h = r.get("pageIconSize", true), f = ct(h) ? h : [
        h,
        h
      ];
      p("pagePrev", 0);
      var d = r.getModel("pageTextStyle");
      c.add(new be({
        name: "pageText",
        style: {
          text: "xx/xx",
          fill: d.getTextColor(),
          font: d.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: true
      })), p("pageNext", 1);
      function p(g, v) {
        var m = g + "DataIndex", y = Fv(r.get("pageIcons", true)[r.getOrient().name][v], {
          onclick: St(u._pageGo, u, m, r, a)
        }, {
          x: -f[0] / 2,
          y: -f[1] / 2,
          width: f[0],
          height: f[1]
        });
        y.name = g, c.add(y);
      }
    }, t.prototype.layoutInner = function(e, r, i, a, s, o) {
      var l = this.getSelectorGroup(), u = e.getOrient().index, c = tT[u], h = eT[u], f = tT[1 - u], d = eT[1 - u];
      s && Pc("horizontal", l, e.get("selectorItemGap", true));
      var p = e.get("selectorButtonGap", true), g = l.getBoundingRect(), v = [
        -g.x,
        -g.y
      ], m = Bt(i);
      s && (m[c] = i[c] - g[c] - p);
      var y = this._layoutContentAndController(e, a, m, u, c, f, d, h);
      if (s) {
        if (o === "end") v[u] += y[c] + p;
        else {
          var x = g[c] + p;
          v[u] -= x, y[h] -= x;
        }
        y[c] += g[c] + p, v[1 - u] += y[d] + y[f] / 2 - g[f] / 2, y[f] = Math.max(y[f], g[f]), y[d] = Math.min(y[d], g[d] + v[1 - u]), l.x = v[0], l.y = v[1], l.markRedraw();
      }
      return y;
    }, t.prototype._layoutContentAndController = function(e, r, i, a, s, o, l, u) {
      var c = this.getContentGroup(), h = this._containerGroup, f = this._controllerGroup;
      Pc(e.get("orient"), c, e.get("itemGap"), a ? i.width : null, a ? null : i.height), Pc("horizontal", f, e.get("pageButtonItemGap", true));
      var d = c.getBoundingRect(), p = f.getBoundingRect(), g = this._showController = d[s] > i[s], v = [
        -d.x,
        -d.y
      ];
      r || (v[a] = c[u]);
      var m = [
        0,
        0
      ], y = [
        -p.x,
        -p.y
      ], x = Ht(e.get("pageButtonGap", true), e.get("itemGap", true));
      if (g) {
        var b = e.get("pageButtonPosition", true);
        b === "end" ? y[a] += i[s] - p[s] : m[a] += p[s] + x;
      }
      y[1 - a] += d[o] / 2 - p[o] / 2, c.setPosition(v), h.setPosition(m), f.setPosition(y);
      var _ = {
        x: 0,
        y: 0
      };
      if (_[s] = g ? i[s] : d[s], _[o] = Math.max(d[o], p[o]), _[l] = Math.min(0, p[l] + y[1 - a]), h.__rectSize = i[s], g) {
        var w = {
          x: 0,
          y: 0
        };
        w[s] = Math.max(i[s] - p[s] - x, 0), w[o] = _[o], h.setClipPath(new ye({
          shape: w
        })), h.__rectSize = w[s];
      } else f.eachChild(function(I) {
        I.attr({
          invisible: true,
          silent: true
        });
      });
      var S = this._getPageInfo(e);
      return S.pageIndex != null && Ie(c, {
        x: S.contentPosition[0],
        y: S.contentPosition[1]
      }, g ? e : null), this._updatePageInfoView(e, S), _;
    }, t.prototype._pageGo = function(e, r, i) {
      var a = this._getPageInfo(r)[e];
      a != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: r.id
      });
    }, t.prototype._updatePageInfoView = function(e, r) {
      var i = this._controllerGroup;
      P([
        "pagePrev",
        "pageNext"
      ], function(c) {
        var h = c + "DataIndex", f = r[h] != null, d = i.childOfName(c);
        d && (d.setStyle("fill", f ? e.get("pageIconColor", true) : e.get("pageIconInactiveColor", true)), d.cursor = f ? "pointer" : "default");
      });
      var a = i.childOfName("pageText"), s = e.get("pageFormatter"), o = r.pageIndex, l = o != null ? o + 1 : 0, u = r.pageCount;
      a && s && a.setStyle("text", wt(s) ? s.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : s({
        current: l,
        total: u
      }));
    }, t.prototype._getPageInfo = function(e) {
      var r = e.get("scrollDataIndex", true), i = this.getContentGroup(), a = this._containerGroup.__rectSize, s = e.getOrient().index, o = tT[s], l = eT[s], u = this._findTargetItemIndex(r), c = i.children(), h = c[u], f = c.length, d = f ? 1 : 0, p = {
        contentPosition: [
          i.x,
          i.y
        ],
        pageCount: d,
        pageIndex: d - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!h) return p;
      var g = b(h);
      p.contentPosition[s] = -g.s;
      for (var v = u + 1, m = g, y = g, x = null; v <= f; ++v) x = b(c[v]), (!x && y.e > m.s + a || x && !_(x, m.s)) && (y.i > m.i ? m = y : m = x, m && (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = x;
      for (var v = u - 1, m = g, y = g, x = null; v >= -1; --v) x = b(c[v]), (!x || !_(y, x.s)) && m.i < y.i && (y = m, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = x;
      return p;
      function b(w) {
        if (w) {
          var S = w.getBoundingRect(), I = S[l] + w[l];
          return {
            s: I,
            e: I + S[o],
            i: w.__legendDataIndex
          };
        }
      }
      function _(w, S) {
        return w.e >= S && w.s <= S + a;
      }
    }, t.prototype._findTargetItemIndex = function(e) {
      if (!this._showController) return 0;
      var r, i = this.getContentGroup(), a;
      return i.eachChild(function(s, o) {
        var l = s.__legendDataIndex;
        a == null && l != null && (a = o), l === e && (r = o);
      }), r ?? a;
    }, t.type = "legend.scroll", t;
  }(FX);
  function lbt(n) {
    n.registerAction("legendScroll", "legendscroll", function(t, e) {
      var r = t.scrollDataIndex;
      r != null && e.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: t
      }, function(i) {
        i.setScrollDataIndex(r);
      });
    });
  }
  function ubt(n) {
    se(zX), n.registerComponentModel(sbt), n.registerComponentView(obt), lbt(n);
  }
  function cbt(n) {
    se(zX), se(ubt);
  }
  var hbt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.inside", t.defaultOption = ou(nv.defaultOption, {
      disabled: false,
      zoomLock: false,
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: false,
      preventDefaultMouseMove: true
    }), t;
  }(nv), LE = xe();
  function fbt(n, t, e) {
    LE(n).coordSysRecordMap.each(function(r) {
      var i = r.dataZoomInfoMap.get(t.uid);
      i && (i.getRange = e);
    });
  }
  function dbt(n, t) {
    for (var e = LE(n).coordSysRecordMap, r = e.keys(), i = 0; i < r.length; i++) {
      var a = r[i], s = e.get(a), o = s.dataZoomInfoMap;
      if (o) {
        var l = t.uid, u = o.get(l);
        u && (o.removeKey(l), o.keys().length || VX(e, s));
      }
    }
  }
  function VX(n, t) {
    if (t) {
      n.removeKey(t.model.uid);
      var e = t.controller;
      e && e.dispose();
    }
  }
  function pbt(n, t) {
    var e = {
      model: t,
      containsPoint: qt(vbt, t),
      dispatchAction: qt(gbt, n),
      dataZoomInfoMap: null,
      controller: null
    }, r = e.controller = new jv(n.getZr());
    return P([
      "pan",
      "zoom",
      "scrollMove"
    ], function(i) {
      r.on(i, function(a) {
        var s = [];
        e.dataZoomInfoMap.each(function(o) {
          if (a.isAvailableBehavior(o.model.option)) {
            var l = (o.getRange || {})[i], u = l && l(o.dzReferCoordSysInfo, e.model.mainType, e.controller, a);
            !o.model.get("disabled", true) && u && s.push({
              dataZoomId: o.model.id,
              start: u[0],
              end: u[1]
            });
          }
        }), s.length && e.dispatchAction(s);
      });
    }), e;
  }
  function gbt(n, t) {
    n.isDisposed() || n.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch: t
    });
  }
  function vbt(n, t, e, r) {
    return n.coordinateSystem.containPoint([
      e,
      r
    ]);
  }
  function mbt(n) {
    var t, e = "type_", r = {
      type_true: 2,
      type_move: 1,
      type_false: 0,
      type_undefined: -1
    }, i = true;
    return n.each(function(a) {
      var s = a.model, o = s.get("disabled", true) ? false : s.get("zoomLock", true) ? "move" : true;
      r[e + o] > r[e + t] && (t = o), i = i && s.get("preventDefaultMouseMove", true);
    }), {
      controlType: t,
      opt: {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: true,
        preventDefaultMouseMove: !!i
      }
    };
  }
  function ybt(n) {
    n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, function(t, e) {
      var r = LE(e), i = r.coordSysRecordMap || (r.coordSysRecordMap = It());
      i.each(function(a) {
        a.dataZoomInfoMap = null;
      }), t.eachComponent({
        mainType: "dataZoom",
        subType: "inside"
      }, function(a) {
        var s = SX(a);
        P(s.infoList, function(o) {
          var l = o.model.uid, u = i.get(l) || i.set(l, pbt(e, o.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = It());
          c.set(a.uid, {
            dzReferCoordSysInfo: o,
            model: a,
            getRange: null
          });
        });
      }), i.each(function(a) {
        var s = a.controller, o, l = a.dataZoomInfoMap;
        if (l) {
          var u = l.keys()[0];
          u != null && (o = l.get(u));
        }
        if (!o) {
          VX(i, a);
          return;
        }
        var c = mbt(l);
        s.enable(c.controlType, c.opt), s.setPointerChecker(a.containsPoint), kd(a, "dispatchAction", o.model.get("throttle", true), "fixRate");
      });
    });
  }
  var xbt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = "dataZoom.inside", e;
    }
    return t.prototype.render = function(e, r, i) {
      if (n.prototype.render.apply(this, arguments), e.noTarget()) {
        this._clear();
        return;
      }
      this.range = e.getPercentRange(), fbt(i, e, {
        pan: St(nT.pan, this),
        zoom: St(nT.zoom, this),
        scrollMove: St(nT.scrollMove, this)
      });
    }, t.prototype.dispose = function() {
      this._clear(), n.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      dbt(this.api, this.dataZoomModel), this.range = null;
    }, t.type = "dataZoom.inside", t;
  }(TE), nT = {
    zoom: function(n, t, e, r) {
      var i = this.range, a = i.slice(), s = n.axisModels[0];
      if (s) {
        var o = rT[t](null, [
          r.originX,
          r.originY
        ], s, e, n), l = (o.signal > 0 ? o.pixelStart + o.pixelLength - o.pixel : o.pixel - o.pixelStart) / o.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / r.scale, 0);
        a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
        var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        if (xh(0, a, [
          0,
          100
        ], 0, c.minSpan, c.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1]) return a;
      }
    },
    pan: N3(function(n, t, e, r, i, a) {
      var s = rT[r]([
        a.oldX,
        a.oldY
      ], [
        a.newX,
        a.newY
      ], t, i, e);
      return s.signal * (n[1] - n[0]) * s.pixel / s.pixelLength;
    }),
    scrollMove: N3(function(n, t, e, r, i, a) {
      var s = rT[r]([
        0,
        0
      ], [
        a.scrollDelta,
        a.scrollDelta
      ], t, i, e);
      return s.signal * (n[1] - n[0]) * a.scrollDelta;
    })
  };
  function N3(n) {
    return function(t, e, r, i) {
      var a = this.range, s = a.slice(), o = t.axisModels[0];
      if (o) {
        var l = n(s, o, t, e, r, i);
        if (xh(l, s, [
          0,
          100
        ], "all"), this.range = s, a[0] !== s[0] || a[1] !== s[1]) return s;
      }
    };
  }
  var rT = {
    grid: function(n, t, e, r, i) {
      var a = e.axis, s = {}, o = i.model.coordinateSystem.getRect();
      return n = n || [
        0,
        0
      ], a.dim === "x" ? (s.pixel = t[0] - n[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = t[1] - n[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
    },
    polar: function(n, t, e, r, i) {
      var a = e.axis, s = {}, o = i.model.coordinateSystem, l = o.getRadiusAxis().getExtent(), u = o.getAngleAxis().getExtent();
      return n = n ? o.pointToCoord(n) : [
        0,
        0
      ], t = o.pointToCoord(t), e.mainType === "radiusAxis" ? (s.pixel = t[0] - n[0], s.pixelLength = l[1] - l[0], s.pixelStart = l[0], s.signal = a.inverse ? 1 : -1) : (s.pixel = t[1] - n[1], s.pixelLength = u[1] - u[0], s.pixelStart = u[0], s.signal = a.inverse ? -1 : 1), s;
    },
    singleAxis: function(n, t, e, r, i) {
      var a = e.axis, s = i.model.coordinateSystem.getRect(), o = {};
      return n = n || [
        0,
        0
      ], a.orient === "horizontal" ? (o.pixel = t[0] - n[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - n[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
    }
  };
  function GX(n) {
    IE(n), n.registerComponentModel(hbt), n.registerComponentView(xbt), ybt(n);
  }
  var bbt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.slider", t.layoutMode = "box", t.defaultOption = ou(nv.defaultOption, {
      show: true,
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: true,
      showDataShadow: "auto",
      realtime: true,
      zoomLock: false,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: true,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleLabel: {
          show: true
        },
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), t;
  }(nv), Tp = ye, L3 = 7, _bt = 1, iT = 30, wbt = 7, Ip = "horizontal", P3 = "vertical", Sbt = 5, Cbt = [
    "line",
    "bar",
    "candlestick",
    "scatter"
  ], Tbt = {
    easing: "cubicOut",
    duration: 100,
    delay: 0
  }, Ibt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._displayables = {}, e;
    }
    return t.prototype.init = function(e, r) {
      this.api = r, this._onBrush = St(this._onBrush, this), this._onBrushEnd = St(this._onBrushEnd, this);
    }, t.prototype.render = function(e, r, i, a) {
      if (n.prototype.render.apply(this, arguments), kd(this, "_dispatchZoomAction", e.get("throttle"), "fixRate"), this._orient = e.getOrient(), e.get("show") === false) {
        this.group.removeAll();
        return;
      }
      if (e.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, t.prototype.dispose = function() {
      this._clear(), n.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      Wg(this, "_dispatchZoomAction");
      var e = this.api.getZr();
      e.off("mousemove", this._onBrush), e.off("mouseup", this._onBrushEnd);
    }, t.prototype._buildView = function() {
      var e = this.group;
      e.removeAll(), this._brushing = false, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var r = this._displayables.sliderGroup = new Vt();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), e.add(r), this._positionGroup();
    }, t.prototype._resetLocation = function() {
      var e = this.dataZoomModel, r = this.api, i = e.get("brushSelect"), a = i ? wbt : 0, s = this._findCoordRect(), o = {
        width: r.getWidth(),
        height: r.getHeight()
      }, l = this._orient === Ip ? {
        right: o.width - s.x - s.width,
        top: o.height - iT - L3 - a,
        width: s.width,
        height: iT
      } : {
        right: L3,
        top: s.y,
        width: iT,
        height: s.height
      }, u = Td(e.option);
      P([
        "right",
        "top",
        "width",
        "height"
      ], function(h) {
        u[h] === "ph" && (u[h] = l[h]);
      });
      var c = Zn(u, o);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [
        c.width,
        c.height
      ], this._orient === P3 && this._size.reverse();
    }, t.prototype._positionGroup = function() {
      var e = this.group, r = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), s = a && a.get("inverse"), o = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      o.attr(i === Ip && !s ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === Ip && s ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === P3 && !s ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = e.getBoundingRect([
        o
      ]);
      e.x = r.x - u.x, e.y = r.y - u.y, e.markRedraw();
    }, t.prototype._getViewExtent = function() {
      return [
        0,
        this._size[0]
      ];
    }, t.prototype._renderBackground = function() {
      var e = this.dataZoomModel, r = this._size, i = this._displayables.sliderGroup, a = e.get("brushSelect");
      i.add(new Tp({
        silent: true,
        shape: {
          x: 0,
          y: 0,
          width: r[0],
          height: r[1]
        },
        style: {
          fill: e.get("backgroundColor")
        },
        z2: -40
      }));
      var s = new Tp({
        shape: {
          x: 0,
          y: 0,
          width: r[0],
          height: r[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: St(this._onClickPanel, this)
      }), o = this.api.getZr();
      a ? (s.on("mousedown", this._onBrushStart, this), s.cursor = "crosshair", o.on("mousemove", this._onBrush), o.on("mouseup", this._onBrushEnd)) : (o.off("mousemove", this._onBrush), o.off("mouseup", this._onBrushEnd)), i.add(s);
    }, t.prototype._renderDataShadow = function() {
      var e = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !e) return;
      var r = this._size, i = this._shadowSize || [], a = e.series, s = a.getRawData(), o = a.getShadowDim && a.getShadowDim(), l = o && s.getDimensionInfo(o) ? a.getShadowDim() : e.otherDim;
      if (l == null) return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (s !== this._shadowData || l !== this._shadowDim || r[0] !== i[0] || r[1] !== i[1]) {
        var h = s.getDataExtent(l), f = (h[1] - h[0]) * 0.3;
        h = [
          h[0] - f,
          h[1] + f
        ];
        var d = [
          0,
          r[1]
        ], p = [
          0,
          r[0]
        ], g = [
          [
            r[0],
            0
          ],
          [
            0,
            0
          ]
        ], v = [], m = p[1] / (s.count() - 1), y = 0, x = Math.round(s.count() / r[0]), b;
        s.each([
          l
        ], function(T, A) {
          if (x > 0 && A % x) {
            y += m;
            return;
          }
          var C = T == null || isNaN(T) || T === "", D = C ? 0 : Pe(T, h, d, true);
          C && !b && A ? (g.push([
            g[g.length - 1][0],
            0
          ]), v.push([
            v[v.length - 1][0],
            0
          ])) : !C && b && (g.push([
            y,
            0
          ]), v.push([
            y,
            0
          ])), g.push([
            y,
            D
          ]), v.push([
            y,
            D
          ]), y += m, b = C;
        }), u = this._shadowPolygonPts = g, c = this._shadowPolylinePts = v;
      }
      this._shadowData = s, this._shadowDim = l, this._shadowSize = [
        r[0],
        r[1]
      ];
      var _ = this.dataZoomModel;
      function w(T) {
        var A = _.getModel(T ? "selectedDataBackground" : "dataBackground"), C = new Vt(), D = new yi({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: A.getModel("areaStyle").getAreaStyle(),
          silent: true,
          z2: -20
        }), E = new _i({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: A.getModel("lineStyle").getLineStyle(),
          silent: true,
          z2: -19
        });
        return C.add(D), C.add(E), C;
      }
      for (var S = 0; S < 3; S++) {
        var I = w(S === 1);
        this._displayables.sliderGroup.add(I), this._displayables.dataShadowSegs.push(I);
      }
    }, t.prototype._prepareDataShadowInfo = function() {
      var e = this.dataZoomModel, r = e.get("showDataShadow");
      if (r !== false) {
        var i, a = this.ecModel;
        return e.eachTargetAxis(function(s, o) {
          var l = e.getAxisProxy(s, o).getTargetSeriesModels();
          P(l, function(u) {
            if (!i && !(r !== true && ne(Cbt, u.get("type")) < 0)) {
              var c = a.getComponent(Ml(s), o).axis, h = Abt(s), f, d = u.coordinateSystem;
              h != null && d.getOtherAxis && (f = d.getOtherAxis(c).inverse), h = u.getData().mapDimension(h), i = {
                thisAxis: c,
                series: u,
                thisDim: s,
                otherDim: h,
                otherAxisInverse: f
              };
            }
          }, this);
        }, this), i;
      }
    }, t.prototype._renderHandle = function() {
      var e = this.group, r = this._displayables, i = r.handles = [
        null,
        null
      ], a = r.handleLabels = [
        null,
        null
      ], s = this._displayables.sliderGroup, o = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, h = l.get("brushSelect"), f = r.filler = new Tp({
        silent: h,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      s.add(f), s.add(new Tp({
        silent: true,
        subPixelOptimize: true,
        shape: {
          x: 0,
          y: 0,
          width: o[0],
          height: o[1],
          r: c
        },
        style: {
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: _bt,
          fill: "rgba(0,0,0,0)"
        }
      })), P([
        0,
        1
      ], function(x) {
        var b = l.get("handleIcon");
        !tb[b] && b.indexOf("path://") < 0 && b.indexOf("image://") < 0 && (b = "path://" + b);
        var _ = Fn(b, -1, 0, 2, 2, null, true);
        _.attr({
          cursor: $3(this._orient),
          draggable: true,
          drift: St(this._onDragMove, this, x),
          ondragend: St(this._onDragEnd, this),
          onmouseover: St(this._showDataInfo, this, true),
          onmouseout: St(this._showDataInfo, this, false),
          z2: 5
        });
        var w = _.getBoundingRect(), S = l.get("handleSize");
        this._handleHeight = yt(S, this._size[1]), this._handleWidth = w.width / w.height * this._handleHeight, _.setStyle(l.getModel("handleStyle").getItemStyle()), _.style.strokeNoScale = true, _.rectHover = true, _.ensureState("emphasis").style = l.getModel([
          "emphasis",
          "handleStyle"
        ]).getItemStyle(), Nc(_);
        var I = l.get("handleColor");
        I != null && (_.style.fill = I), s.add(i[x] = _);
        var T = l.getModel("textStyle"), A = l.get("handleLabel") || {}, C = A.show || false;
        e.add(a[x] = new be({
          silent: true,
          invisible: !C,
          style: nn(T, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: T.getTextColor(),
            font: T.getFont()
          }),
          z2: 10
        }));
      }, this);
      var d = f;
      if (h) {
        var p = yt(l.get("moveHandleSize"), o[1]), g = r.moveHandle = new ye({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: true,
          shape: {
            r: [
              0,
              0,
              2,
              2
            ],
            y: o[1] - 0.5,
            height: p
          }
        }), v = p * 0.8, m = r.moveHandleIcon = Fn(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, "#fff", true);
        m.silent = true, m.y = o[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel([
          "emphasis",
          "moveHandleStyle"
        ]).getItemStyle();
        var y = Math.min(o[1] / 2, Math.max(p, 10));
        d = r.moveZone = new ye({
          invisible: true,
          shape: {
            y: o[1] - y,
            height: p + y
          }
        }), d.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), s.add(g), s.add(m), s.add(d);
      }
      d.attr({
        draggable: true,
        cursor: $3(this._orient),
        drift: St(this._onDragMove, this, "all"),
        ondragstart: St(this._showDataInfo, this, true),
        ondragend: St(this._onDragEnd, this),
        onmouseover: St(this._showDataInfo, this, true),
        onmouseout: St(this._showDataInfo, this, false)
      });
    }, t.prototype._resetInterval = function() {
      var e = this._range = this.dataZoomModel.getPercentRange(), r = this._getViewExtent();
      this._handleEnds = [
        Pe(e[0], [
          0,
          100
        ], r, true),
        Pe(e[1], [
          0,
          100
        ], r, true)
      ];
    }, t.prototype._updateInterval = function(e, r) {
      var i = this.dataZoomModel, a = this._handleEnds, s = this._getViewExtent(), o = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [
        0,
        100
      ];
      xh(r, a, s, i.get("zoomLock") ? "all" : e, o.minSpan != null ? Pe(o.minSpan, l, s, true) : null, o.maxSpan != null ? Pe(o.maxSpan, l, s, true) : null);
      var u = this._range, c = this._range = _a([
        Pe(a[0], s, l, true),
        Pe(a[1], s, l, true)
      ]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, t.prototype._updateView = function(e) {
      var r = this._displayables, i = this._handleEnds, a = _a(i.slice()), s = this._size;
      P([
        0,
        1
      ], function(d) {
        var p = r.handles[d], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          x: i[d] + (d ? -1 : 1),
          y: s[1] / 2 - g / 2
        });
      }, this), r.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: s[1]
      });
      var o = {
        x: a[0],
        width: a[1] - a[0]
      };
      r.moveHandle && (r.moveHandle.setShape(o), r.moveZone.setShape(o), r.moveZone.getBoundingRect(), r.moveHandleIcon && r.moveHandleIcon.attr("x", o.x + o.width / 2));
      for (var l = r.dataShadowSegs, u = [
        0,
        a[0],
        a[1],
        s[0]
      ], c = 0; c < l.length; c++) {
        var h = l[c], f = h.getClipPath();
        f || (f = new ye(), h.setClipPath(f)), f.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: s[1]
        });
      }
      this._updateDataInfo(e);
    }, t.prototype._updateDataInfo = function(e) {
      var r = this.dataZoomModel, i = this._displayables, a = i.handleLabels, s = this._orient, o = [
        "",
        ""
      ];
      if (r.get("showDetail")) {
        var l = r.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, h = e ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          o = [
            this._formatLabel(h[0], u),
            this._formatLabel(h[1], u)
          ];
        }
      }
      var f = _a(this._handleEnds.slice());
      d.call(this, 0), d.call(this, 1);
      function d(p) {
        var g = Lc(i.handles[p].parent, this.group), v = E1(p === 0 ? "right" : "left", g), m = this._handleWidth / 2 + Sbt, y = es([
          f[p] + (p === 0 ? -m : m),
          this._size[1] / 2
        ], g);
        a[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: s === Ip ? "middle" : v,
          align: s === Ip ? v : "center",
          text: o[p]
        });
      }
    }, t.prototype._formatLabel = function(e, r) {
      var i = this.dataZoomModel, a = i.get("labelFormatter"), s = i.get("labelPrecision");
      (s == null || s === "auto") && (s = r.getPixelPrecision());
      var o = e == null || isNaN(e) ? "" : r.type === "category" || r.type === "time" ? r.scale.getLabel({
        value: Math.round(e)
      }) : e.toFixed(Math.min(s, 20));
      return Nt(a) ? a(e, o) : wt(a) ? a.replace("{value}", o) : o;
    }, t.prototype._showDataInfo = function(e) {
      var r = this.dataZoomModel.get("handleLabel") || {}, i = r.show || false, a = this.dataZoomModel.getModel([
        "emphasis",
        "handleLabel"
      ]), s = a.get("show") || false, o = e || this._dragging ? s : i, l = this._displayables, u = l.handleLabels;
      u[0].attr("invisible", !o), u[1].attr("invisible", !o), l.moveHandle && this.api[o ? "enterEmphasis" : "leaveEmphasis"](l.moveHandle, 1);
    }, t.prototype._onDragMove = function(e, r, i, a) {
      this._dragging = true, Bo(a.event);
      var s = this._displayables.sliderGroup.getLocalTransform(), o = es([
        r,
        i
      ], s, true), l = this._updateInterval(e, o[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(true);
    }, t.prototype._onDragEnd = function() {
      this._dragging = false, this._showDataInfo(false);
      var e = this.dataZoomModel.get("realtime");
      !e && this._dispatchZoomAction(false);
    }, t.prototype._onClickPanel = function(e) {
      var r = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);
      if (!(i[0] < 0 || i[0] > r[0] || i[1] < 0 || i[1] > r[1])) {
        var a = this._handleEnds, s = (a[0] + a[1]) / 2, o = this._updateInterval("all", i[0] - s);
        this._updateView(), o && this._dispatchZoomAction(false);
      }
    }, t.prototype._onBrushStart = function(e) {
      var r = e.offsetX, i = e.offsetY;
      this._brushStart = new Qt(r, i), this._brushing = true, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, t.prototype._onBrushEnd = function(e) {
      if (this._brushing) {
        var r = this._displayables.brushRect;
        if (this._brushing = false, !!r) {
          r.attr("ignore", true);
          var i = r.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var s = this._getViewExtent(), o = [
              0,
              100
            ];
            this._range = _a([
              Pe(i.x, s, o, true),
              Pe(i.x + i.width, s, o, true)
            ]), this._handleEnds = [
              i.x,
              i.x + i.width
            ], this._updateView(), this._dispatchZoomAction(false);
          }
        }
      }
    }, t.prototype._onBrush = function(e) {
      this._brushing && (Bo(e.event), this._updateBrushRect(e.offsetX, e.offsetY));
    }, t.prototype._updateBrushRect = function(e, r) {
      var i = this._displayables, a = this.dataZoomModel, s = i.brushRect;
      s || (s = i.brushRect = new Tp({
        silent: true,
        style: a.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(s)), s.attr("ignore", false);
      var o = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(e, r), c = l.transformCoordToLocal(o.x, o.y), h = this._size;
      u[0] = Math.max(Math.min(h[0], u[0]), 0), s.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: h[1]
      });
    }, t.prototype._dispatchZoomAction = function(e) {
      var r = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: e ? Tbt : null,
        start: r[0],
        end: r[1]
      });
    }, t.prototype._findCoordRect = function() {
      var e, r = SX(this.dataZoomModel).infoList;
      if (!e && r.length) {
        var i = r[0].model.coordinateSystem;
        e = i.getRect && i.getRect();
      }
      if (!e) {
        var a = this.api.getWidth(), s = this.api.getHeight();
        e = {
          x: a * 0.2,
          y: s * 0.2,
          width: a * 0.6,
          height: s * 0.6
        };
      }
      return e;
    }, t.type = "dataZoom.slider", t;
  }(TE);
  function Abt(n) {
    var t = {
      x: "y",
      y: "x",
      radius: "angle",
      angle: "radius"
    };
    return t[n];
  }
  function $3(n) {
    return n === "vertical" ? "ns-resize" : "ew-resize";
  }
  function WX(n) {
    n.registerComponentModel(bbt), n.registerComponentView(Ibt), IE(n);
  }
  function kbt(n) {
    se(GX), se(WX);
  }
  var UX = {
    get: function(n, t, e) {
      var r = Bt((Dbt[n] || {})[t]);
      return e && ct(r) ? r[r.length - 1] : r;
    }
  }, Dbt = {
    color: {
      active: [
        "#006edd",
        "#e0ffff"
      ],
      inactive: [
        "rgba(0,0,0,0)"
      ]
    },
    colorHue: {
      active: [
        0,
        360
      ],
      inactive: [
        0,
        0
      ]
    },
    colorSaturation: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    colorLightness: {
      active: [
        0.9,
        0.5
      ],
      inactive: [
        0,
        0
      ]
    },
    colorAlpha: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    opacity: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    symbol: {
      active: [
        "circle",
        "roundRect",
        "diamond"
      ],
      inactive: [
        "none"
      ]
    },
    symbolSize: {
      active: [
        10,
        50
      ],
      inactive: [
        0,
        0
      ]
    }
  }, O3 = or.mapVisual, Ebt = or.eachVisual, Mbt = ct, F3 = P, Rbt = _a, Nbt = Pe, Cb = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.stateList = [
        "inRange",
        "outOfRange"
      ], e.replacableOptionKeys = [
        "inRange",
        "outOfRange",
        "target",
        "controller",
        "color"
      ], e.layoutMode = {
        type: "box",
        ignoreSize: true
      }, e.dataBound = [
        -1 / 0,
        1 / 0
      ], e.targetVisuals = {}, e.controllerVisuals = {}, e;
    }
    return t.prototype.init = function(e, r, i) {
      this.mergeDefaultAndTheme(e, i);
    }, t.prototype.optionUpdated = function(e, r) {
      var i = this.option;
      !r && NX(i, e, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, t.prototype.resetVisual = function(e) {
      var r = this.stateList;
      e = St(e, this), this.controllerVisuals = ZA(this.option.controller, r, e), this.targetVisuals = ZA(this.option.target, r, e);
    }, t.prototype.getItemSymbol = function() {
      return null;
    }, t.prototype.getTargetSeriesIndices = function() {
      var e = this.option.seriesIndex, r = [];
      return e == null || e === "all" ? this.ecModel.eachSeries(function(i, a) {
        r.push(a);
      }) : r = He(e), r;
    }, t.prototype.eachTargetSeries = function(e, r) {
      P(this.getTargetSeriesIndices(), function(i) {
        var a = this.ecModel.getSeriesByIndex(i);
        a && e.call(r, a);
      }, this);
    }, t.prototype.isTargetSeries = function(e) {
      var r = false;
      return this.eachTargetSeries(function(i) {
        i === e && (r = true);
      }), r;
    }, t.prototype.formatValueText = function(e, r, i) {
      var a = this.option, s = a.precision, o = this.dataBound, l = a.formatter, u;
      i = i || [
        "<",
        ">"
      ], ct(e) && (e = e.slice(), u = true);
      var c = r ? e : u ? [
        h(e[0]),
        h(e[1])
      ] : h(e);
      if (wt(l)) return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (Nt(l)) return u ? l(e[0], e[1]) : l(e);
      if (u) return e[0] === o[0] ? i[0] + " " + c[1] : e[1] === o[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function h(f) {
        return f === o[0] ? "min" : f === o[1] ? "max" : (+f).toFixed(Math.min(s, 20));
      }
    }, t.prototype.resetExtent = function() {
      var e = this.option, r = Rbt([
        e.min,
        e.max
      ]);
      this._dataExtent = r;
    }, t.prototype.getDataDimensionIndex = function(e) {
      var r = this.option.dimension;
      if (r != null) return e.getDimensionIndex(r);
      for (var i = e.dimensions, a = i.length - 1; a >= 0; a--) {
        var s = i[a], o = e.getDimensionInfo(s);
        if (!o.isCalculationCoord) return o.storeDimIndex;
      }
    }, t.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, t.prototype.completeVisualOption = function() {
      var e = this.ecModel, r = this.option, i = {
        inRange: r.inRange,
        outOfRange: r.outOfRange
      }, a = r.target || (r.target = {}), s = r.controller || (r.controller = {});
      Zt(a, i), Zt(s, i);
      var o = this.isCategory();
      l.call(this, a), l.call(this, s), u.call(this, a, "inRange", "outOfRange"), c.call(this, s);
      function l(h) {
        Mbt(r.color) && !h.inRange && (h.inRange = {
          color: r.color.slice().reverse()
        }), h.inRange = h.inRange || {
          color: e.get("gradientColor")
        };
      }
      function u(h, f, d) {
        var p = h[f], g = h[d];
        p && !g && (g = h[d] = {}, F3(p, function(v, m) {
          if (or.isValidType(m)) {
            var y = UX.get(m, "inactive", o);
            y != null && (g[m] = y, m === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [
              0,
              0
            ]));
          }
        }));
      }
      function c(h) {
        var f = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol, d = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), v = g || "roundRect";
        F3(this.stateList, function(m) {
          var y = this.itemSize, x = h[m];
          x || (x = h[m] = {
            color: o ? p : [
              p
            ]
          }), x.symbol == null && (x.symbol = f && Bt(f) || (o ? v : [
            v
          ])), x.symbolSize == null && (x.symbolSize = d && Bt(d) || (o ? y[0] : [
            y[0],
            y[0]
          ])), x.symbol = O3(x.symbol, function(w) {
            return w === "none" ? v : w;
          });
          var b = x.symbolSize;
          if (b != null) {
            var _ = -1 / 0;
            Ebt(b, function(w) {
              w > _ && (_ = w);
            }), x.symbolSize = O3(b, function(w) {
              return Nbt(w, [
                0,
                _
              ], [
                0,
                y[0]
              ], true);
            });
          }
        }, this);
      }
    }, t.prototype.resetItemSize = function() {
      this.itemSize = [
        parseFloat(this.get("itemWidth")),
        parseFloat(this.get("itemHeight"))
      ];
    }, t.prototype.isCategory = function() {
      return !!this.option.categories;
    }, t.prototype.setSelected = function(e) {
    }, t.prototype.getSelected = function() {
      return null;
    }, t.prototype.getValueState = function(e) {
      return null;
    }, t.prototype.getVisualMeta = function(e) {
      return null;
    }, t.type = "visualMap", t.dependencies = [
      "series"
    ], t.defaultOption = {
      show: true,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: false,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
      }
    }, t;
  }(pe), B3 = [
    20,
    140
  ], Lbt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function(e, r) {
      n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, t.prototype.resetItemSize = function() {
      n.prototype.resetItemSize.apply(this, arguments);
      var e = this.itemSize;
      (e[0] == null || isNaN(e[0])) && (e[0] = B3[0]), (e[1] == null || isNaN(e[1])) && (e[1] = B3[1]);
    }, t.prototype._resetRange = function() {
      var e = this.getExtent(), r = this.option.range;
      !r || r.auto ? (e.auto = 1, this.option.range = e) : ct(r) && (r[0] > r[1] && r.reverse(), r[0] = Math.max(r[0], e[0]), r[1] = Math.min(r[1], e[1]));
    }, t.prototype.completeVisualOption = function() {
      n.prototype.completeVisualOption.apply(this, arguments), P(this.stateList, function(e) {
        var r = this.option.controller[e].symbolSize;
        r && r[0] !== r[1] && (r[0] = r[1] / 3);
      }, this);
    }, t.prototype.setSelected = function(e) {
      this.option.range = e.slice(), this._resetRange();
    }, t.prototype.getSelected = function() {
      var e = this.getExtent(), r = _a((this.get("range") || []).slice());
      return r[0] > e[1] && (r[0] = e[1]), r[1] > e[1] && (r[1] = e[1]), r[0] < e[0] && (r[0] = e[0]), r[1] < e[0] && (r[1] = e[0]), r;
    }, t.prototype.getValueState = function(e) {
      var r = this.option.range, i = this.getExtent();
      return (r[0] <= i[0] || r[0] <= e) && (r[1] >= i[1] || e <= r[1]) ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(e) {
      var r = [];
      return this.eachTargetSeries(function(i) {
        var a = [], s = i.getData();
        s.each(this.getDataDimensionIndex(s), function(o, l) {
          e[0] <= o && o <= e[1] && a.push(l);
        }, this), r.push({
          seriesId: i.id,
          dataIndex: a
        });
      }, this), r;
    }, t.prototype.getVisualMeta = function(e) {
      var r = z3(this, "outOfRange", this.getExtent()), i = z3(this, "inRange", this.option.range.slice()), a = [];
      function s(d, p) {
        a.push({
          value: d,
          color: e(d, p)
        });
      }
      for (var o = 0, l = 0, u = i.length, c = r.length; l < c && (!i.length || r[l] <= i[0]); l++) r[l] < i[o] && s(r[l], "outOfRange");
      for (var h = 1; o < u; o++, h = 0) h && a.length && s(i[o], "outOfRange"), s(i[o], "inRange");
      for (var h = 1; l < c; l++) (!i.length || i[i.length - 1] < r[l]) && (h && (a.length && s(a[a.length - 1].value, "outOfRange"), h = 0), s(r[l], "outOfRange"));
      var f = a.length;
      return {
        stops: a,
        outerColors: [
          f ? a[0].color : "transparent",
          f ? a[f - 1].color : "transparent"
        ]
      };
    }, t.type = "visualMap.continuous", t.defaultOption = ou(Cb.defaultOption, {
      align: "auto",
      calculable: false,
      hoverLink: true,
      realtime: true,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
    }), t;
  }(Cb);
  function z3(n, t, e) {
    if (e[0] === e[1]) return e.slice();
    for (var r = 200, i = (e[1] - e[0]) / r, a = e[0], s = [], o = 0; o <= r && a < e[1]; o++) s.push(a), a += i;
    return s.push(e[1]), s;
  }
  var HX = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, e;
    }
    return t.prototype.init = function(e, r) {
      this.ecModel = e, this.api = r;
    }, t.prototype.render = function(e, r, i, a) {
      if (this.visualMapModel = e, e.get("show") === false) {
        this.group.removeAll();
        return;
      }
      this.doRender(e, r, i, a);
    }, t.prototype.renderBackground = function(e) {
      var r = this.visualMapModel, i = Cd(r.get("padding") || 0), a = e.getBoundingRect();
      e.add(new ye({
        z2: -1,
        silent: true,
        shape: {
          x: a.x - i[3],
          y: a.y - i[0],
          width: a.width + i[3] + i[1],
          height: a.height + i[0] + i[2]
        },
        style: {
          fill: r.get("backgroundColor"),
          stroke: r.get("borderColor"),
          lineWidth: r.get("borderWidth")
        }
      }));
    }, t.prototype.getControllerVisual = function(e, r, i) {
      i = i || {};
      var a = i.forceState, s = this.visualMapModel, o = {};
      if (r === "color") {
        var l = s.get("contentColor");
        o.color = l;
      }
      function u(d) {
        return o[d];
      }
      function c(d, p) {
        o[d] = p;
      }
      var h = s.controllerVisuals[a || s.getValueState(e)], f = or.prepareVisualTypes(h);
      return P(f, function(d) {
        var p = h[d];
        i.convertOpacityToAlpha && d === "opacity" && (d = "colorAlpha", p = h.__alphaForOpacity), or.dependsOn(d, r) && p && p.applyVisual(e, u, c);
      }), o[r];
    }, t.prototype.positionGroup = function(e) {
      var r = this.visualMapModel, i = this.api;
      O1(e, r.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, t.prototype.doRender = function(e, r, i, a) {
    }, t.type = "visualMap", t;
  }(vn), V3 = [
    [
      "left",
      "right",
      "width"
    ],
    [
      "top",
      "bottom",
      "height"
    ]
  ];
  function XX(n, t, e) {
    var r = n.option, i = r.align;
    if (i != null && i !== "auto") return i;
    for (var a = {
      width: t.getWidth(),
      height: t.getHeight()
    }, s = r.orient === "horizontal" ? 1 : 0, o = V3[s], l = [
      0,
      null,
      10
    ], u = {}, c = 0; c < 3; c++) u[V3[1 - s][c]] = l[c], u[o[c]] = c === 2 ? e[0] : r[o[c]];
    var h = [
      [
        "x",
        "width",
        3
      ],
      [
        "y",
        "height",
        0
      ]
    ][s], f = Zn(u, a, r.padding);
    return o[(f.margin[h[2]] || 0) + f[h[0]] + f[h[1]] * 0.5 < a[h[1]] * 0.5 ? 0 : 1];
  }
  function _x(n, t) {
    return P(n || [], function(e) {
      e.dataIndex != null && (e.dataIndexInside = e.dataIndex, e.dataIndex = null), e.highlightKey = "visualMap" + (t ? t.componentIndex : "");
    }), n;
  }
  var Is = Pe, Pbt = P, G3 = Math.min, aT = Math.max, $bt = 12, Obt = 6, Fbt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._shapes = {}, e._dataInterval = [], e._handleEnds = [], e._hoverLinkDataIndices = [], e;
    }
    return t.prototype.init = function(e, r) {
      n.prototype.init.call(this, e, r), this._hoverLinkFromSeriesMouseOver = St(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = St(this._hideIndicator, this);
    }, t.prototype.doRender = function(e, r, i, a) {
      (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, t.prototype._buildView = function() {
      this.group.removeAll();
      var e = this.visualMapModel, r = this.group;
      this._orient = e.get("orient"), this._useHandle = e.get("calculable"), this._resetInterval(), this._renderBar(r);
      var i = e.get("text");
      this._renderEndsText(r, i, 0), this._renderEndsText(r, i, 1), this._updateView(true), this.renderBackground(r), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(r);
    }, t.prototype._renderEndsText = function(e, r, i) {
      if (r) {
        var a = r[1 - i];
        a = a != null ? a + "" : "";
        var s = this.visualMapModel, o = s.get("textGap"), l = s.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([
          l[0] / 2,
          i === 0 ? -o : l[1] + o
        ], u), h = this._applyTransform(i === 0 ? "bottom" : "top", u), f = this._orient, d = this.visualMapModel.textStyleModel;
        this.group.add(new be({
          style: nn(d, {
            x: c[0],
            y: c[1],
            verticalAlign: f === "horizontal" ? "middle" : h,
            align: f === "horizontal" ? h : "center",
            text: a
          })
        }));
      }
    }, t.prototype._renderBar = function(e) {
      var r = this.visualMapModel, i = this._shapes, a = r.itemSize, s = this._orient, o = this._useHandle, l = XX(r, this.api, a), u = i.mainGroup = this._createBarGroup(l), c = new Vt();
      u.add(c), c.add(i.outOfRange = W3()), c.add(i.inRange = W3(null, o ? H3(this._orient) : null, St(this._dragHandle, this, "all", false), St(this._dragHandle, this, "all", true))), c.setClipPath(new ye({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var h = r.textStyleModel.getTextRect("\u56FD"), f = aT(h.width, h.height);
      o && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(r, u, 0, a, f, s), this._createHandle(r, u, 1, a, f, s)), this._createIndicator(r, u, a, f, s), e.add(u);
    }, t.prototype._createHandle = function(e, r, i, a, s, o) {
      var l = St(this._dragHandle, this, i, false), u = St(this._dragHandle, this, i, true), c = ss(e.get("handleSize"), a[0]), h = Fn(e.get("handleIcon"), -c / 2, -c / 2, c, c, null, true), f = H3(this._orient);
      h.attr({
        cursor: f,
        draggable: true,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          Bo(m.event);
        }
      }), h.x = a[0] / 2, h.useStyle(e.getModel("handleStyle").getItemStyle()), h.setStyle({
        strokeNoScale: true,
        strokeFirst: true
      }), h.style.lineWidth *= 2, h.ensureState("emphasis").style = e.getModel([
        "emphasis",
        "handleStyle"
      ]).getItemStyle(), yc(h, true), r.add(h);
      var d = this.visualMapModel.textStyleModel, p = new be({
        cursor: f,
        draggable: true,
        drift: l,
        onmousemove: function(m) {
          Bo(m.event);
        },
        ondragend: u,
        style: nn(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [
        c,
        0
      ], v = this._shapes;
      v.handleThumbs[i] = h, v.handleLabelPoints[i] = g, v.handleLabels[i] = p;
    }, t.prototype._createIndicator = function(e, r, i, a, s) {
      var o = ss(e.get("indicatorSize"), i[0]), l = Fn(e.get("indicatorIcon"), -o / 2, -o / 2, o, o, null, true);
      l.attr({
        cursor: "move",
        invisible: true,
        silent: true,
        x: i[0] / 2
      });
      var u = e.getModel("indicatorStyle").getItemStyle();
      if (l instanceof br) {
        var c = l.style;
        l.useStyle(rt({
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else l.useStyle(u);
      r.add(l);
      var h = this.visualMapModel.textStyleModel, f = new be({
        silent: true,
        invisible: true,
        style: nn(h, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(f);
      var d = [
        (s === "horizontal" ? a / 2 : Obt) + i[0] / 2,
        0
      ], p = this._shapes;
      p.indicator = l, p.indicatorLabel = f, p.indicatorLabelPoint = d, this._firstShowIndicator = true;
    }, t.prototype._dragHandle = function(e, r, i, a) {
      if (this._useHandle) {
        if (this._dragging = !r, !r) {
          var s = this._applyTransform([
            i,
            a
          ], this._shapes.mainGroup, true);
          this._updateInterval(e, s[1]), this._hideIndicator(), this._updateView();
        }
        r === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), r ? !this._hovering && this._clearHoverLinkToSeries() : U3(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[e], false);
      }
    }, t.prototype._resetInterval = function() {
      var e = this.visualMapModel, r = this._dataInterval = e.getSelected(), i = e.getExtent(), a = [
        0,
        e.itemSize[1]
      ];
      this._handleEnds = [
        Is(r[0], i, a, true),
        Is(r[1], i, a, true)
      ];
    }, t.prototype._updateInterval = function(e, r) {
      r = r || 0;
      var i = this.visualMapModel, a = this._handleEnds, s = [
        0,
        i.itemSize[1]
      ];
      xh(r, a, s, e, 0);
      var o = i.getExtent();
      this._dataInterval = [
        Is(a[0], s, o, true),
        Is(a[1], s, o, true)
      ];
    }, t.prototype._updateView = function(e) {
      var r = this.visualMapModel, i = r.getExtent(), a = this._shapes, s = [
        0,
        r.itemSize[1]
      ], o = e ? s : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, o, "inRange"), u = this._createBarVisual(i, i, s, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
      }).setShape("points", u.barPoints), this._updateHandle(o, l);
    }, t.prototype._createBarVisual = function(e, r, i, a) {
      var s = {
        forceState: a,
        convertOpacityToAlpha: true
      }, o = this._makeColorGradient(e, s), l = [
        this.getControllerVisual(e[0], "symbolSize", s),
        this.getControllerVisual(e[1], "symbolSize", s)
      ], u = this._createBarPoints(i, l);
      return {
        barColor: new $v(0, 0, 0, 1, o),
        barPoints: u,
        handlesColor: [
          o[0].color,
          o[o.length - 1].color
        ]
      };
    }, t.prototype._makeColorGradient = function(e, r) {
      var i = 100, a = [], s = (e[1] - e[0]) / i;
      a.push({
        color: this.getControllerVisual(e[0], "color", r),
        offset: 0
      });
      for (var o = 1; o < i; o++) {
        var l = e[0] + s * o;
        if (l > e[1]) break;
        a.push({
          color: this.getControllerVisual(l, "color", r),
          offset: o / i
        });
      }
      return a.push({
        color: this.getControllerVisual(e[1], "color", r),
        offset: 1
      }), a;
    }, t.prototype._createBarPoints = function(e, r) {
      var i = this.visualMapModel.itemSize;
      return [
        [
          i[0] - r[0],
          e[0]
        ],
        [
          i[0],
          e[0]
        ],
        [
          i[0],
          e[1]
        ],
        [
          i[0] - r[1],
          e[1]
        ]
      ];
    }, t.prototype._createBarGroup = function(e) {
      var r = this._orient, i = this.visualMapModel.get("inverse");
      return new Vt(r === "horizontal" && !i ? {
        scaleX: e === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : r === "horizontal" && i ? {
        scaleX: e === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : r === "vertical" && !i ? {
        scaleX: e === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: e === "left" ? 1 : -1
      });
    }, t.prototype._updateHandle = function(e, r) {
      if (this._useHandle) {
        var i = this._shapes, a = this.visualMapModel, s = i.handleThumbs, o = i.handleLabels, l = a.itemSize, u = a.getExtent(), c = this._applyTransform("left", i.mainGroup);
        Pbt([
          0,
          1
        ], function(h) {
          var f = s[h];
          f.setStyle("fill", r.handlesColor[h]), f.y = e[h];
          var d = Is(e[h], [
            0,
            l[1]
          ], u, true), p = this.getControllerVisual(d, "symbolSize");
          f.scaleX = f.scaleY = p / l[0], f.x = l[0] - p / 2;
          var g = es(i.handleLabelPoints[h], Lc(f, this.group));
          if (this._orient === "horizontal") {
            var v = c === "left" || c === "top" ? (l[0] - p) / 2 : (l[0] - p) / -2;
            g[1] += v;
          }
          o[h].setStyle({
            x: g[0],
            y: g[1],
            text: a.formatValueText(this._dataInterval[h]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, t.prototype._showIndicator = function(e, r, i, a) {
      var s = this.visualMapModel, o = s.getExtent(), l = s.itemSize, u = [
        0,
        l[1]
      ], c = this._shapes, h = c.indicator;
      if (h) {
        h.attr("invisible", false);
        var f = {
          convertOpacityToAlpha: true
        }, d = this.getControllerVisual(e, "color", f), p = this.getControllerVisual(e, "symbolSize"), g = Is(e, o, u, true), v = l[0] - p / 2, m = {
          x: h.x,
          y: h.y
        };
        h.y = g, h.x = v;
        var y = es(c.indicatorLabelPoint, Lc(h, this.group)), x = c.indicatorLabel;
        x.attr("invisible", false);
        var b = this._applyTransform("left", c.mainGroup), _ = this._orient, w = _ === "horizontal";
        x.setStyle({
          text: (i || "") + s.formatValueText(r),
          verticalAlign: w ? b : "middle",
          align: w ? "center" : b
        });
        var S = {
          x: v,
          y: g,
          style: {
            fill: d
          }
        }, I = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (s.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var T = {
            duration: 100,
            easing: "cubicInOut",
            additive: true
          };
          h.x = m.x, h.y = m.y, h.animateTo(S, T), x.animateTo(I, T);
        } else h.attr(S), x.attr(I);
        this._firstShowIndicator = false;
        var A = this._shapes.handleLabels;
        if (A) for (var C = 0; C < A.length; C++) this.api.enterBlur(A[C]);
      }
    }, t.prototype._enableHoverLinkToSeries = function() {
      var e = this;
      this._shapes.mainGroup.on("mousemove", function(r) {
        if (e._hovering = true, !e._dragging) {
          var i = e.visualMapModel.itemSize, a = e._applyTransform([
            r.offsetX,
            r.offsetY
          ], e._shapes.mainGroup, true, true);
          a[1] = G3(aT(0, a[1]), i[1]), e._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]);
        }
      }).on("mouseout", function() {
        e._hovering = false, !e._dragging && e._clearHoverLinkToSeries();
      });
    }, t.prototype._enableHoverLinkFromSeries = function() {
      var e = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (e.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), e.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, t.prototype._doHoverLinkToSeries = function(e, r) {
      var i = this.visualMapModel, a = i.itemSize;
      if (i.option.hoverLink) {
        var s = [
          0,
          a[1]
        ], o = i.getExtent();
        e = G3(aT(s[0], e), s[1]);
        var l = Bbt(i, o, s), u = [
          e - l,
          e + l
        ], c = Is(e, s, o, true), h = [
          Is(u[0], s, o, true),
          Is(u[1], s, o, true)
        ];
        u[0] < s[0] && (h[0] = -1 / 0), u[1] > s[1] && (h[1] = 1 / 0), r && (h[0] === -1 / 0 ? this._showIndicator(c, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, "\u2248 ", l));
        var f = this._hoverLinkDataIndices, d = [];
        (r || U3(i)) && (d = this._hoverLinkDataIndices = i.findTargetDataIndices(h));
        var p = Hnt(f, d);
        this._dispatchHighDown("downplay", _x(p[0], i)), this._dispatchHighDown("highlight", _x(p[1], i));
      }
    }, t.prototype._hoverLinkFromSeriesMouseOver = function(e) {
      var r;
      if (bc(e.target, function(l) {
        var u = Ut(l);
        if (u.dataIndex != null) return r = u, true;
      }, true), !!r) {
        var i = this.ecModel.getSeriesByIndex(r.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(i)) {
          var s = i.getData(r.dataType), o = s.getStore().get(a.getDataDimensionIndex(s), r.dataIndex);
          isNaN(o) || this._showIndicator(o, o);
        }
      }
    }, t.prototype._hideIndicator = function() {
      var e = this._shapes;
      e.indicator && e.indicator.attr("invisible", true), e.indicatorLabel && e.indicatorLabel.attr("invisible", true);
      var r = this._shapes.handleLabels;
      if (r) for (var i = 0; i < r.length; i++) this.api.leaveBlur(r[i]);
    }, t.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var e = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", _x(e, this.visualMapModel)), e.length = 0;
    }, t.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var e = this.api.getZr();
      e.off("mouseover", this._hoverLinkFromSeriesMouseOver), e.off("mouseout", this._hideIndicator);
    }, t.prototype._applyTransform = function(e, r, i, a) {
      var s = Lc(r, a ? null : this.group);
      return ct(e) ? es(e, s, i) : E1(e, s, i);
    }, t.prototype._dispatchHighDown = function(e, r) {
      r && r.length && this.api.dispatchAction({
        type: e,
        batch: r
      });
    }, t.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, t.type = "visualMap.continuous", t;
  }(HX);
  function W3(n, t, e, r) {
    return new yi({
      shape: {
        points: n
      },
      draggable: !!e,
      cursor: t,
      drift: e,
      onmousemove: function(i) {
        Bo(i.event);
      },
      ondragend: r
    });
  }
  function Bbt(n, t, e) {
    var r = $bt / 2, i = n.get("hoverLinkDataSize");
    return i && (r = Is(i, t, e, true) / 2), r;
  }
  function U3(n) {
    var t = n.get("hoverLinkOnHandle");
    return !!(t ?? n.get("realtime"));
  }
  function H3(n) {
    return n === "vertical" ? "ns-resize" : "ew-resize";
  }
  var zbt = {
    type: "selectDataRange",
    event: "dataRangeSelected",
    update: "update"
  }, Vbt = function(n, t) {
    t.eachComponent({
      mainType: "visualMap",
      query: n
    }, function(e) {
      e.setSelected(n.selected);
    });
  }, Gbt = [
    {
      createOnAllSeries: true,
      reset: function(n, t) {
        var e = [];
        return t.eachComponent("visualMap", function(r) {
          var i = n.pipelineContext;
          !r.isTargetSeries(n) || i && i.large || e.push(cxt(r.stateList, r.targetVisuals, St(r.getValueState, r), r.getDataDimensionIndex(n.getData())));
        }), e;
      }
    },
    {
      createOnAllSeries: true,
      reset: function(n, t) {
        var e = n.getData(), r = [];
        t.eachComponent("visualMap", function(i) {
          if (i.isTargetSeries(n)) {
            var a = i.getVisualMeta(St(Wbt, null, n, i)) || {
              stops: [],
              outerColors: []
            }, s = i.getDataDimensionIndex(e);
            s >= 0 && (a.dimension = s, r.push(a));
          }
        }), n.getData().setVisual("visualMeta", r);
      }
    }
  ];
  function Wbt(n, t, e, r) {
    for (var i = t.targetVisuals[r], a = or.prepareVisualTypes(i), s = {
      color: zv(n.getData(), "color")
    }, o = 0, l = a.length; o < l; o++) {
      var u = a[o], c = i[u === "opacity" ? "__alphaForOpacity" : u];
      c && c.applyVisual(e, h, f);
    }
    return s.color;
    function h(d) {
      return s[d];
    }
    function f(d, p) {
      s[d] = p;
    }
  }
  var X3 = P;
  function Ubt(n) {
    var t = n && n.visualMap;
    ct(t) || (t = t ? [
      t
    ] : []), X3(t, function(e) {
      if (e) {
        Zh(e, "splitList") && !Zh(e, "pieces") && (e.pieces = e.splitList, delete e.splitList);
        var r = e.pieces;
        r && ct(r) && X3(r, function(i) {
          Ft(i) && (Zh(i, "start") && !Zh(i, "min") && (i.min = i.start), Zh(i, "end") && !Zh(i, "max") && (i.max = i.end));
        });
      }
    });
  }
  function Zh(n, t) {
    return n && n.hasOwnProperty && n.hasOwnProperty(t);
  }
  var Y3 = false;
  function YX(n) {
    Y3 || (Y3 = true, n.registerSubTypeDefaulter("visualMap", function(t) {
      return !t.categories && (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable) ? "continuous" : "piecewise";
    }), n.registerAction(zbt, Vbt), P(Gbt, function(t) {
      n.registerVisual(n.PRIORITY.VISUAL.COMPONENT, t);
    }), n.registerPreprocessor(Ubt));
  }
  function qX(n) {
    n.registerComponentModel(Lbt), n.registerComponentView(Fbt), YX(n);
  }
  var Hbt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e._pieceList = [], e;
    }
    return t.prototype.optionUpdated = function(e, r) {
      n.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], Xbt[this._mode].call(this, this._pieceList), this._resetSelected(e, r);
      var a = this.option.categories;
      this.resetVisual(function(s, o) {
        i === "categories" ? (s.mappingMethod = "category", s.categories = Bt(a)) : (s.dataExtent = this.getExtent(), s.mappingMethod = "piecewise", s.pieceList = ht(this._pieceList, function(l) {
          return l = Bt(l), o !== "inRange" && (l.visual = null), l;
        }));
      });
    }, t.prototype.completeVisualOption = function() {
      var e = this.option, r = {}, i = or.listVisualTypes(), a = this.isCategory();
      P(e.pieces, function(o) {
        P(i, function(l) {
          o.hasOwnProperty(l) && (r[l] = 1);
        });
      }), P(r, function(o, l) {
        var u = false;
        P(this.stateList, function(c) {
          u = u || s(e, c, l) || s(e.target, c, l);
        }, this), !u && P(this.stateList, function(c) {
          (e[c] || (e[c] = {}))[l] = UX.get(l, c === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function s(o, l, u) {
        return o && o[l] && o[l].hasOwnProperty(u);
      }
      n.prototype.completeVisualOption.apply(this, arguments);
    }, t.prototype._resetSelected = function(e, r) {
      var i = this.option, a = this._pieceList, s = (r ? i : e).selected || {};
      if (i.selected = s, P(a, function(l, u) {
        var c = this.getSelectedMapKey(l);
        s.hasOwnProperty(c) || (s[c] = true);
      }, this), i.selectedMode === "single") {
        var o = false;
        P(a, function(l, u) {
          var c = this.getSelectedMapKey(l);
          s[c] && (o ? s[c] = false : o = true);
        }, this);
      }
    }, t.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, t.prototype.getSelectedMapKey = function(e) {
      return this._mode === "categories" ? e.value + "" : e.index + "";
    }, t.prototype.getPieceList = function() {
      return this._pieceList;
    }, t.prototype._determineMode = function() {
      var e = this.option;
      return e.pieces && e.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, t.prototype.setSelected = function(e) {
      this.option.selected = Bt(e);
    }, t.prototype.getValueState = function(e) {
      var r = or.findPieceIndex(e, this._pieceList);
      return r != null && this.option.selected[this.getSelectedMapKey(this._pieceList[r])] ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(e) {
      var r = [], i = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var s = [], o = a.getData();
        o.each(this.getDataDimensionIndex(o), function(l, u) {
          var c = or.findPieceIndex(l, i);
          c === e && s.push(u);
        }, this), r.push({
          seriesId: a.id,
          dataIndex: s
        });
      }, this), r;
    }, t.prototype.getRepresentValue = function(e) {
      var r;
      if (this.isCategory()) r = e.value;
      else if (e.value != null) r = e.value;
      else {
        var i = e.interval || [];
        r = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return r;
    }, t.prototype.getVisualMeta = function(e) {
      if (this.isCategory()) return;
      var r = [], i = [
        "",
        ""
      ], a = this;
      function s(c, h) {
        var f = a.getRepresentValue({
          interval: c
        });
        h || (h = a.getValueState(f));
        var d = e(f, h);
        c[0] === -1 / 0 ? i[0] = d : c[1] === 1 / 0 ? i[1] = d : r.push({
          value: c[0],
          color: d
        }, {
          value: c[1],
          color: d
        });
      }
      var o = this._pieceList.slice();
      if (!o.length) o.push({
        interval: [
          -1 / 0,
          1 / 0
        ]
      });
      else {
        var l = o[0].interval[0];
        l !== -1 / 0 && o.unshift({
          interval: [
            -1 / 0,
            l
          ]
        }), l = o[o.length - 1].interval[1], l !== 1 / 0 && o.push({
          interval: [
            l,
            1 / 0
          ]
        });
      }
      var u = -1 / 0;
      return P(o, function(c) {
        var h = c.interval;
        h && (h[0] > u && s([
          u,
          h[0]
        ], "outOfRange"), s(h.slice()), u = h[1]);
      }, this), {
        stops: r,
        outerColors: i
      };
    }, t.type = "visualMap.piecewise", t.defaultOption = ou(Cb.defaultOption, {
      selected: null,
      minOpen: false,
      maxOpen: false,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: true
    }), t;
  }(Cb), Xbt = {
    splitNumber: function(n) {
      var t = this.option, e = Math.min(t.precision, 20), r = this.getExtent(), i = t.splitNumber;
      i = Math.max(parseInt(i, 10), 1), t.splitNumber = i;
      for (var a = (r[1] - r[0]) / i; +a.toFixed(e) !== a && e < 5; ) e++;
      t.precision = e, a = +a.toFixed(e), t.minOpen && n.push({
        interval: [
          -1 / 0,
          r[0]
        ],
        close: [
          0,
          0
        ]
      });
      for (var s = 0, o = r[0]; s < i; o += a, s++) {
        var l = s === i - 1 ? r[1] : o + a;
        n.push({
          interval: [
            o,
            l
          ],
          close: [
            1,
            1
          ]
        });
      }
      t.maxOpen && n.push({
        interval: [
          r[1],
          1 / 0
        ],
        close: [
          0,
          0
        ]
      }), VL(n), P(n, function(u, c) {
        u.index = c, u.text = this.formatValueText(u.interval);
      }, this);
    },
    categories: function(n) {
      var t = this.option;
      P(t.categories, function(e) {
        n.push({
          text: this.formatValueText(e, true),
          value: e
        });
      }, this), q3(t, n);
    },
    pieces: function(n) {
      var t = this.option;
      P(t.pieces, function(e, r) {
        Ft(e) || (e = {
          value: e
        });
        var i = {
          text: "",
          index: r
        };
        if (e.label != null && (i.text = e.label), e.hasOwnProperty("value")) {
          var a = i.value = e.value;
          i.interval = [
            a,
            a
          ], i.close = [
            1,
            1
          ];
        } else {
          for (var s = i.interval = [], o = i.close = [
            0,
            0
          ], l = [
            1,
            0,
            1
          ], u = [
            -1 / 0,
            1 / 0
          ], c = [], h = 0; h < 2; h++) {
            for (var f = [
              [
                "gte",
                "gt",
                "min"
              ],
              [
                "lte",
                "lt",
                "max"
              ]
            ][h], d = 0; d < 3 && s[h] == null; d++) s[h] = e[f[d]], o[h] = l[d], c[h] = d === 2;
            s[h] == null && (s[h] = u[h]);
          }
          c[0] && s[1] === 1 / 0 && (o[0] = 0), c[1] && s[0] === -1 / 0 && (o[1] = 0), s[0] === s[1] && o[0] && o[1] && (i.value = s[0]);
        }
        i.visual = or.retrieveVisuals(e), n.push(i);
      }, this), q3(t, n), VL(n), P(n, function(e) {
        var r = e.close, i = [
          [
            "<",
            "\u2264"
          ][r[1]],
          [
            ">",
            "\u2265"
          ][r[0]]
        ];
        e.text = e.text || this.formatValueText(e.value != null ? e.value : e.interval, false, i);
      }, this);
    }
  };
  function q3(n, t) {
    var e = n.inverse;
    (n.orient === "vertical" ? !e : e) && t.reverse();
  }
  var Ybt = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.doRender = function() {
      var e = this.group;
      e.removeAll();
      var r = this.visualMapModel, i = r.get("textGap"), a = r.textStyleModel, s = a.getFont(), o = a.getTextColor(), l = this._getItemAlign(), u = r.itemSize, c = this._getViewData(), h = c.endsText, f = mr(r.get("showLabel", true), !h), d = !r.get("selectedMode");
      h && this._renderEndsText(e, h[0], u, f, l), P(c.viewPieceList, function(p) {
        var g = p.piece, v = new Vt();
        v.onclick = St(this._onItemClick, this, g), this._enableHoverLink(v, p.indexInModelPieceList);
        var m = r.getRepresentValue(g);
        if (this._createItemSymbol(v, m, [
          0,
          0,
          u[0],
          u[1]
        ], d), f) {
          var y = this.visualMapModel.getValueState(m);
          v.add(new be({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: g.text,
              verticalAlign: "middle",
              align: l,
              font: s,
              fill: o,
              opacity: y === "outOfRange" ? 0.5 : 1
            },
            silent: d
          }));
        }
        e.add(v);
      }, this), h && this._renderEndsText(e, h[1], u, f, l), Pc(r.get("orient"), e, r.get("itemGap")), this.renderBackground(e), this.positionGroup(e);
    }, t.prototype._enableHoverLink = function(e, r) {
      var i = this;
      e.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(s) {
        var o = i.visualMapModel;
        o.option.hoverLink && i.api.dispatchAction({
          type: s,
          batch: _x(o.findTargetDataIndices(r), o)
        });
      };
    }, t.prototype._getItemAlign = function() {
      var e = this.visualMapModel, r = e.option;
      if (r.orient === "vertical") return XX(e, this.api, e.itemSize);
      var i = r.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, t.prototype._renderEndsText = function(e, r, i, a, s) {
      if (r) {
        var o = new Vt(), l = this.visualMapModel.textStyleModel;
        o.add(new be({
          style: nn(l, {
            x: a ? s === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: a ? s : "center",
            text: r
          })
        })), e.add(o);
      }
    }, t.prototype._getViewData = function() {
      var e = this.visualMapModel, r = ht(e.getPieceList(), function(o, l) {
        return {
          piece: o,
          indexInModelPieceList: l
        };
      }), i = e.get("text"), a = e.get("orient"), s = e.get("inverse");
      return (a === "horizontal" ? s : !s) ? r.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: r,
        endsText: i
      };
    }, t.prototype._createItemSymbol = function(e, r, i, a) {
      var s = Fn(this.getControllerVisual(r, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(r, "color"));
      s.silent = a, e.add(s);
    }, t.prototype._onItemClick = function(e) {
      var r = this.visualMapModel, i = r.option, a = i.selectedMode;
      if (a) {
        var s = Bt(i.selected), o = r.getSelectedMapKey(e);
        a === "single" || a === true ? (s[o] = true, P(s, function(l, u) {
          s[u] = u === o;
        })) : s[o] = !s[o], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: s
        });
      }
    }, t.type = "visualMap.piecewise", t;
  }(HX);
  function jX(n) {
    n.registerComponentModel(Hbt), n.registerComponentView(Ybt), YX(n);
  }
  function qbt(n) {
    se(qX), se(jX);
  }
  var jbt = {
    label: {
      enabled: true
    },
    decal: {
      show: false
    }
  }, j3 = xe(), Kbt = {};
  function Zbt(n, t) {
    var e = n.getModel("aria");
    if (!e.get("enabled")) return;
    var r = Bt(jbt);
    Zt(r.label, n.getLocaleModel().get("aria"), false), Zt(e.option, r, false), i(), a();
    function i() {
      var u = e.getModel("decal"), c = u.get("show");
      if (c) {
        var h = It();
        n.eachSeries(function(f) {
          if (!f.isColorBySeries()) {
            var d = h.get(f.type);
            d || (d = {}, h.set(f.type, d)), j3(f).scope = d;
          }
        }), n.eachRawSeries(function(f) {
          if (n.isSeriesFiltered(f)) return;
          if (Nt(f.enableAriaDecal)) {
            f.enableAriaDecal();
            return;
          }
          var d = f.getData();
          if (f.isColorBySeries()) {
            var y = rA(f.ecModel, f.name, Kbt, n.getSeriesCount()), x = d.getVisual("decal");
            d.setVisual("decal", b(x, y));
          } else {
            var p = f.getRawData(), g = {}, v = j3(f).scope;
            d.each(function(_) {
              var w = d.getRawIndex(_);
              g[w] = _;
            });
            var m = p.count();
            p.each(function(_) {
              var w = g[_], S = p.getName(_) || _ + "", I = rA(f.ecModel, S, v, m), T = d.getItemVisual(w, "decal");
              d.setItemVisual(w, "decal", b(T, I));
            });
          }
          function b(_, w) {
            var S = _ ? rt(rt({}, w), _) : w;
            return S.dirty = true, S;
          }
        });
      }
    }
    function a() {
      var u = t.getZr().dom;
      if (u) {
        var c = n.getLocaleModel().get("aria"), h = e.getModel("label");
        if (h.option = $t(h.option, c), !!h.get("enabled")) {
          if (u.setAttribute("role", "img"), h.get("description")) {
            u.setAttribute("aria-label", h.get("description"));
            return;
          }
          var f = n.getSeriesCount(), d = h.get([
            "data",
            "maxCount"
          ]) || 10, p = h.get([
            "series",
            "maxCount"
          ]) || 10, g = Math.min(f, p), v;
          if (!(f < 1)) {
            var m = o();
            if (m) {
              var y = h.get([
                "general",
                "withTitle"
              ]);
              v = s(y, {
                title: m
              });
            } else v = h.get([
              "general",
              "withoutTitle"
            ]);
            var x = [], b = f > 1 ? h.get([
              "series",
              "multiple",
              "prefix"
            ]) : h.get([
              "series",
              "single",
              "prefix"
            ]);
            v += s(b, {
              seriesCount: f
            }), n.eachSeries(function(I, T) {
              if (T < g) {
                var A = void 0, C = I.get("name"), D = C ? "withName" : "withoutName";
                A = f > 1 ? h.get([
                  "series",
                  "multiple",
                  D
                ]) : h.get([
                  "series",
                  "single",
                  D
                ]), A = s(A, {
                  seriesId: I.seriesIndex,
                  seriesName: I.get("name"),
                  seriesType: l(I.subType)
                });
                var E = I.getData();
                if (E.count() > d) {
                  var M = h.get([
                    "data",
                    "partialData"
                  ]);
                  A += s(M, {
                    displayCnt: d
                  });
                } else A += h.get([
                  "data",
                  "allData"
                ]);
                for (var L = h.get([
                  "data",
                  "separator",
                  "middle"
                ]), k = h.get([
                  "data",
                  "separator",
                  "end"
                ]), N = h.get([
                  "data",
                  "excludeDimensionId"
                ]), R = [], $ = 0; $ < E.count(); $++) if ($ < d) {
                  var O = E.getName($), F = N ? Le(E.getValues($), function(V, U) {
                    return ne(N, U) === -1;
                  }) : E.getValues($), z = h.get([
                    "data",
                    O ? "withName" : "withoutName"
                  ]);
                  R.push(s(z, {
                    name: O,
                    value: F.join(L)
                  }));
                }
                A += R.join(L) + k, x.push(A);
              }
            });
            var _ = h.getModel([
              "series",
              "multiple",
              "separator"
            ]), w = _.get("middle"), S = _.get("end");
            v += x.join(w) + S, u.setAttribute("aria-label", v);
          }
        }
      }
    }
    function s(u, c) {
      if (!wt(u)) return u;
      var h = u;
      return P(c, function(f, d) {
        h = h.replace(new RegExp("\\{\\s*" + d + "\\s*\\}", "g"), f);
      }), h;
    }
    function o() {
      var u = n.get("title");
      return u && u.length && (u = u[0]), u && u.text;
    }
    function l(u) {
      var c = n.getLocaleModel().get([
        "series",
        "typeNames"
      ]);
      return c[u] || c.chart;
    }
  }
  function Jbt(n) {
    if (!(!n || !n.aria)) {
      var t = n.aria;
      t.show != null && (t.enabled = t.show), t.label = t.label || {}, P([
        "description",
        "general",
        "series",
        "data"
      ], function(e) {
        t[e] != null && (t.label[e] = t[e]);
      });
    }
  }
  function Qbt(n) {
    n.registerPreprocessor(Jbt), n.registerVisual(n.PRIORITY.VISUAL.ARIA, Zbt);
  }
  var K3 = {
    value: "eq",
    "<": "lt",
    "<=": "lte",
    ">": "gt",
    ">=": "gte",
    "=": "eq",
    "!=": "ne",
    "<>": "ne"
  }, t1t = function() {
    function n(t) {
      var e = this._condVal = wt(t) ? new RegExp(t) : set(t) ? t : null;
      if (e == null) {
        var r = "";
        Ne(r);
      }
    }
    return n.prototype.evaluate = function(t) {
      var e = typeof t;
      return wt(e) ? this._condVal.test(t) : _e(e) ? this._condVal.test(t + "") : false;
    }, n;
  }(), e1t = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      return this.value;
    }, n;
  }(), n1t = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var t = this.children, e = 0; e < t.length; e++) if (!t[e].evaluate()) return false;
      return true;
    }, n;
  }(), r1t = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var t = this.children, e = 0; e < t.length; e++) if (t[e].evaluate()) return true;
      return false;
    }, n;
  }(), i1t = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, n;
  }(), a1t = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var t = !!this.valueParser, e = this.getValue, r = e(this.valueGetterParam), i = t ? this.valueParser(r) : null, a = 0; a < this.subCondList.length; a++) if (!this.subCondList[a].evaluate(t ? i : r)) return false;
      return true;
    }, n;
  }();
  function PE(n, t) {
    if (n === true || n === false) {
      var e = new e1t();
      return e.value = n, e;
    }
    var r = "";
    return KX(n) || Ne(r), n.and ? Z3("and", n, t) : n.or ? Z3("or", n, t) : n.not ? s1t(n, t) : o1t(n, t);
  }
  function Z3(n, t, e) {
    var r = t[n], i = "";
    ct(r) || Ne(i), r.length || Ne(i);
    var a = n === "and" ? new n1t() : new r1t();
    return a.children = ht(r, function(s) {
      return PE(s, e);
    }), a.children.length || Ne(i), a;
  }
  function s1t(n, t) {
    var e = n.not, r = "";
    KX(e) || Ne(r);
    var i = new i1t();
    return i.child = PE(e, t), i.child || Ne(r), i;
  }
  function o1t(n, t) {
    for (var e = "", r = t.prepareGetValue(n), i = [], a = ge(n), s = n.parser, o = s ? M5(s) : null, l = 0; l < a.length; l++) {
      var u = a[l];
      if (!(u === "parser" || t.valueGetterAttrMap.get(u))) {
        var c = Ct(K3, u) ? K3[u] : u, h = n[u], f = o ? o(h) : h, d = qat(c, f) || c === "reg" && new t1t(f);
        d || Ne(e), i.push(d);
      }
    }
    i.length || Ne(e);
    var p = new a1t();
    return p.valueGetterParam = r, p.valueParser = o, p.getValue = t.getValue, p.subCondList = i, p;
  }
  function KX(n) {
    return Ft(n) && !Kr(n);
  }
  var l1t = function() {
    function n(t, e) {
      this._cond = PE(t, e);
    }
    return n.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, n;
  }();
  function u1t(n, t) {
    return new l1t(n, t);
  }
  var c1t = {
    type: "echarts:filter",
    transform: function(n) {
      for (var t = n.upstream, e, r = u1t(n.config, {
        valueGetterAttrMap: It({
          dimension: true
        }),
        prepareGetValue: function(o) {
          var l = "", u = o.dimension;
          Ct(o, "dimension") || Ne(l);
          var c = t.getDimensionInfo(u);
          return c || Ne(l), {
            dimIdx: c.index
          };
        },
        getValue: function(o) {
          return t.retrieveValueFromItem(e, o.dimIdx);
        }
      }), i = [], a = 0, s = t.count(); a < s; a++) e = t.getRawDataItem(a), r.evaluate() && i.push(e);
      return {
        data: i
      };
    }
  }, h1t = {
    type: "echarts:sort",
    transform: function(n) {
      var t = n.upstream, e = n.config, r = "", i = He(e);
      i.length || Ne(r);
      var a = [];
      P(i, function(c) {
        var h = c.dimension, f = c.order, d = c.parser, p = c.incomparable;
        if (h == null && Ne(r), f !== "asc" && f !== "desc" && Ne(r), p && p !== "min" && p !== "max") {
          var g = "";
          Ne(g);
        }
        if (f !== "asc" && f !== "desc") {
          var v = "";
          Ne(v);
        }
        var m = t.getDimensionInfo(h);
        m || Ne(r);
        var y = d ? M5(d) : null;
        d && !y && Ne(r), a.push({
          dimIdx: m.index,
          parser: y,
          comparator: new N5(f, p)
        });
      });
      var s = t.sourceFormat;
      s !== Zr && s !== Ma && Ne(r);
      for (var o = [], l = 0, u = t.count(); l < u; l++) o.push(t.getRawDataItem(l));
      return o.sort(function(c, h) {
        for (var f = 0; f < a.length; f++) {
          var d = a[f], p = t.retrieveValueFromItem(c, d.dimIdx), g = t.retrieveValueFromItem(h, d.dimIdx);
          d.parser && (p = d.parser(p), g = d.parser(g));
          var v = d.comparator.evaluate(p, g);
          if (v !== 0) return v;
        }
        return 0;
      }), {
        data: o
      };
    }
  };
  function f1t(n) {
    n.registerTransform(c1t), n.registerTransform(h1t);
  }
  var d1t = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = "dataset", e;
    }
    return t.prototype.init = function(e, r, i) {
      n.prototype.init.call(this, e, r, i), this._sourceManager = new O5(this), QP(this);
    }, t.prototype.mergeOption = function(e, r) {
      n.prototype.mergeOption.call(this, e, r), QP(this);
    }, t.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, t.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, t.type = "dataset", t.defaultOption = {
      seriesLayoutBy: Hs
    }, t;
  }(pe), p1t = function(n) {
    q(t, n);
    function t() {
      var e = n !== null && n.apply(this, arguments) || this;
      return e.type = "dataset", e;
    }
    return t.type = "dataset", t;
  }(vn);
  function g1t(n) {
    n.registerComponentModel(d1t), n.registerComponentView(p1t);
  }
  var Ss = ro.CMD;
  function Tf(n, t) {
    return Math.abs(n - t) < 1e-5;
  }
  function i2(n) {
    var t = n.data, e = n.len(), r = [], i, a = 0, s = 0, o = 0, l = 0;
    function u(E, M) {
      i && i.length > 2 && r.push(i), i = [
        E,
        M
      ];
    }
    function c(E, M, L, k) {
      Tf(E, L) && Tf(M, k) || i.push(E, M, L, k, L, k);
    }
    function h(E, M, L, k, N, R) {
      var $ = Math.abs(M - E), O = Math.tan($ / 4) * 4 / 3, F = M < E ? -1 : 1, z = Math.cos(E), V = Math.sin(E), U = Math.cos(M), X = Math.sin(M), at = z * N + L, pt = V * R + k, it = U * N + L, et = X * R + k, ft = N * O * F, ut = R * O * F;
      i.push(at - ft * V, pt + ut * z, it + ft * X, et - ut * U, it, et);
    }
    for (var f, d, p, g, v = 0; v < e; ) {
      var m = t[v++], y = v === 1;
      switch (y && (a = t[v], s = t[v + 1], o = a, l = s, (m === Ss.L || m === Ss.C || m === Ss.Q) && (i = [
        o,
        l
      ])), m) {
        case Ss.M:
          a = o = t[v++], s = l = t[v++], u(o, l);
          break;
        case Ss.L:
          f = t[v++], d = t[v++], c(a, s, f, d), a = f, s = d;
          break;
        case Ss.C:
          i.push(t[v++], t[v++], t[v++], t[v++], a = t[v++], s = t[v++]);
          break;
        case Ss.Q:
          f = t[v++], d = t[v++], p = t[v++], g = t[v++], i.push(a + 2 / 3 * (f - a), s + 2 / 3 * (d - s), p + 2 / 3 * (f - p), g + 2 / 3 * (d - g), p, g), a = p, s = g;
          break;
        case Ss.A:
          var x = t[v++], b = t[v++], _ = t[v++], w = t[v++], S = t[v++], I = t[v++] + S;
          v += 1;
          var T = !t[v++];
          f = Math.cos(S) * _ + x, d = Math.sin(S) * w + b, y ? (o = f, l = d, u(o, l)) : c(a, s, f, d), a = Math.cos(I) * _ + x, s = Math.sin(I) * w + b;
          for (var A = (T ? -1 : 1) * Math.PI / 2, C = S; T ? C > I : C < I; C += A) {
            var D = T ? Math.max(C + A, I) : Math.min(C + A, I);
            h(C, D, x, b, _, w);
          }
          break;
        case Ss.R:
          o = a = t[v++], l = s = t[v++], f = o + t[v++], d = l + t[v++], u(f, l), c(f, l, f, d), c(f, d, o, d), c(o, d, o, l), c(o, l, f, l);
          break;
        case Ss.Z:
          i && c(a, s, o, l), a = o, s = l;
          break;
      }
    }
    return i && i.length > 2 && r.push(i), r;
  }
  function a2(n, t, e, r, i, a, s, o, l, u) {
    if (Tf(n, e) && Tf(t, r) && Tf(i, s) && Tf(a, o)) {
      l.push(s, o);
      return;
    }
    var c = 2 / u, h = c * c, f = s - n, d = o - t, p = Math.sqrt(f * f + d * d);
    f /= p, d /= p;
    var g = e - n, v = r - t, m = i - s, y = a - o, x = g * g + v * v, b = m * m + y * y;
    if (x < h && b < h) {
      l.push(s, o);
      return;
    }
    var _ = f * g + d * v, w = -f * m - d * y, S = x - _ * _, I = b - w * w;
    if (S < h && _ >= 0 && I < h && w >= 0) {
      l.push(s, o);
      return;
    }
    var T = [], A = [];
    Yl(n, e, i, s, 0.5, T), Yl(t, r, a, o, 0.5, A), a2(T[0], A[0], T[1], A[1], T[2], A[2], T[3], A[3], l, u), a2(T[4], A[4], T[5], A[5], T[6], A[6], T[7], A[7], l, u);
  }
  function v1t(n, t) {
    var e = i2(n), r = [];
    t = t || 1;
    for (var i = 0; i < e.length; i++) {
      var a = e[i], s = [], o = a[0], l = a[1];
      s.push(o, l);
      for (var u = 2; u < a.length; ) {
        var c = a[u++], h = a[u++], f = a[u++], d = a[u++], p = a[u++], g = a[u++];
        a2(o, l, c, h, f, d, p, g, s, t), o = p, l = g;
      }
      r.push(s);
    }
    return r;
  }
  function ZX(n, t, e) {
    var r = n[t], i = n[1 - t], a = Math.abs(r / i), s = Math.ceil(Math.sqrt(a * e)), o = Math.floor(e / s);
    o === 0 && (o = 1, s = e);
    for (var l = [], u = 0; u < s; u++) l.push(o);
    var c = s * o, h = e - c;
    if (h > 0) for (var u = 0; u < h; u++) l[u % s] += 1;
    return l;
  }
  function J3(n, t, e) {
    for (var r = n.r0, i = n.r, a = n.startAngle, s = n.endAngle, o = Math.abs(s - a), l = o * i, u = i - r, c = l > Math.abs(u), h = ZX([
      l,
      u
    ], c ? 0 : 1, t), f = (c ? o : u) / h.length, d = 0; d < h.length; d++) for (var p = (c ? u : o) / h[d], g = 0; g < h[d]; g++) {
      var v = {};
      c ? (v.startAngle = a + f * d, v.endAngle = a + f * (d + 1), v.r0 = r + p * g, v.r = r + p * (g + 1)) : (v.startAngle = a + p * g, v.endAngle = a + p * (g + 1), v.r0 = r + f * d, v.r = r + f * (d + 1)), v.clockwise = n.clockwise, v.cx = n.cx, v.cy = n.cy, e.push(v);
    }
  }
  function m1t(n, t, e) {
    for (var r = n.width, i = n.height, a = r > i, s = ZX([
      r,
      i
    ], a ? 0 : 1, t), o = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", c = a ? "y" : "x", h = n[o] / s.length, f = 0; f < s.length; f++) for (var d = n[l] / s[f], p = 0; p < s[f]; p++) {
      var g = {};
      g[u] = f * h, g[c] = p * d, g[o] = h, g[l] = d, g.x += n.x, g.y += n.y, e.push(g);
    }
  }
  function Q3(n, t, e, r) {
    return n * r - e * t;
  }
  function y1t(n, t, e, r, i, a, s, o) {
    var l = e - n, u = r - t, c = s - i, h = o - a, f = Q3(c, h, l, u);
    if (Math.abs(f) < 1e-6) return null;
    var d = n - i, p = t - a, g = Q3(d, p, c, h) / f;
    return g < 0 || g > 1 ? null : new Qt(g * l + n, g * u + t);
  }
  function x1t(n, t, e) {
    var r = new Qt();
    Qt.sub(r, e, t), r.normalize();
    var i = new Qt();
    Qt.sub(i, n, t);
    var a = i.dot(r);
    return a;
  }
  function Jh(n, t) {
    var e = n[n.length - 1];
    e && e[0] === t[0] && e[1] === t[1] || n.push(t);
  }
  function b1t(n, t, e) {
    for (var r = n.length, i = [], a = 0; a < r; a++) {
      var s = n[a], o = n[(a + 1) % r], l = y1t(s[0], s[1], o[0], o[1], t.x, t.y, e.x, e.y);
      l && i.push({
        projPt: x1t(l, t, e),
        pt: l,
        idx: a
      });
    }
    if (i.length < 2) return [
      {
        points: n
      },
      {
        points: n
      }
    ];
    i.sort(function(v, m) {
      return v.projPt - m.projPt;
    });
    var u = i[0], c = i[i.length - 1];
    if (c.idx < u.idx) {
      var h = u;
      u = c, c = h;
    }
    for (var f = [
      u.pt.x,
      u.pt.y
    ], d = [
      c.pt.x,
      c.pt.y
    ], p = [
      f
    ], g = [
      d
    ], a = u.idx + 1; a <= c.idx; a++) Jh(p, n[a].slice());
    Jh(p, d), Jh(p, f);
    for (var a = c.idx + 1; a <= u.idx + r; a++) Jh(g, n[a % r].slice());
    return Jh(g, f), Jh(g, d), [
      {
        points: p
      },
      {
        points: g
      }
    ];
  }
  function tz(n) {
    var t = n.points, e = [], r = [];
    C1(t, e, r);
    var i = new te(e[0], e[1], r[0] - e[0], r[1] - e[1]), a = i.width, s = i.height, o = i.x, l = i.y, u = new Qt(), c = new Qt();
    return a > s ? (u.x = c.x = o + a / 2, u.y = l, c.y = l + s) : (u.y = c.y = l + s / 2, u.x = o, c.x = o + a), b1t(t, u, c);
  }
  function Tb(n, t, e, r) {
    if (e === 1) r.push(t);
    else {
      var i = Math.floor(e / 2), a = n(t);
      Tb(n, a[0], i, r), Tb(n, a[1], e - i, r);
    }
    return r;
  }
  function _1t(n, t) {
    for (var e = [], r = 0; r < t; r++) e.push(Qk(n));
    return e;
  }
  function w1t(n, t) {
    t.setStyle(n.style), t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel;
  }
  function S1t(n) {
    for (var t = [], e = 0; e < n.length; ) t.push([
      n[e++],
      n[e++]
    ]);
    return t;
  }
  function C1t(n, t) {
    var e = [], r = n.shape, i;
    switch (n.type) {
      case "rect":
        m1t(r, t, e), i = ye;
        break;
      case "sector":
        J3(r, t, e), i = mi;
        break;
      case "circle":
        J3({
          r0: 0,
          r: r.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: r.cx,
          cy: r.cy
        }, t, e), i = mi;
        break;
      default:
        var a = n.getComputedTransform(), s = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, o = ht(v1t(n.getUpdatedPathProxy(), s), function(m) {
          return S1t(m);
        }), l = o.length;
        if (l === 0) Tb(tz, {
          points: o[0]
        }, t, e);
        else if (l === t) for (var u = 0; u < l; u++) e.push({
          points: o[u]
        });
        else {
          var c = 0, h = ht(o, function(m) {
            var y = [], x = [];
            C1(m, y, x);
            var b = (x[1] - y[1]) * (x[0] - y[0]);
            return c += b, {
              poly: m,
              area: b
            };
          });
          h.sort(function(m, y) {
            return y.area - m.area;
          });
          for (var f = t, u = 0; u < l; u++) {
            var d = h[u];
            if (f <= 0) break;
            var p = u === l - 1 ? f : Math.ceil(d.area / c * t);
            p < 0 || (Tb(tz, {
              points: d.poly
            }, p, e), f -= p);
          }
        }
        i = yi;
        break;
    }
    if (!i) return _1t(n, t);
    for (var g = [], u = 0; u < e.length; u++) {
      var v = new i();
      v.setShape(e[u]), w1t(n, v), g.push(v);
    }
    return g;
  }
  function T1t(n, t) {
    var e = n.length, r = t.length;
    if (e === r) return [
      n,
      t
    ];
    for (var i = [], a = [], s = e < r ? n : t, o = Math.min(e, r), l = Math.abs(r - e) / 6, u = (o - 2) / 6, c = Math.ceil(l / u) + 1, h = [
      s[0],
      s[1]
    ], f = l, d = 2; d < o; ) {
      var p = s[d - 2], g = s[d - 1], v = s[d++], m = s[d++], y = s[d++], x = s[d++], b = s[d++], _ = s[d++];
      if (f <= 0) {
        h.push(v, m, y, x, b, _);
        continue;
      }
      for (var w = Math.min(f, c - 1) + 1, S = 1; S <= w; S++) {
        var I = S / w;
        Yl(p, v, y, b, I, i), Yl(g, m, x, _, I, a), p = i[3], g = a[3], h.push(i[1], a[1], i[2], a[2], p, g), v = i[5], m = a[5], y = i[6], x = a[6];
      }
      f -= w - 1;
    }
    return s === n ? [
      h,
      t
    ] : [
      n,
      h
    ];
  }
  function ez(n, t) {
    for (var e = n.length, r = n[e - 2], i = n[e - 1], a = [], s = 0; s < t.length; ) a[s++] = r, a[s++] = i;
    return a;
  }
  function I1t(n, t) {
    for (var e, r, i, a = [], s = [], o = 0; o < Math.max(n.length, t.length); o++) {
      var l = n[o], u = t[o], c = void 0, h = void 0;
      l ? u ? (e = T1t(l, u), c = e[0], h = e[1], r = c, i = h) : (h = ez(i || l, l), c = l) : (c = ez(r || u, u), h = u), a.push(c), s.push(h);
    }
    return [
      a,
      s
    ];
  }
  function nz(n) {
    for (var t = 0, e = 0, r = 0, i = n.length, a = 0, s = i - 2; a < i; s = a, a += 2) {
      var o = n[s], l = n[s + 1], u = n[a], c = n[a + 1], h = o * c - u * l;
      t += h, e += (o + u) * h, r += (l + c) * h;
    }
    return t === 0 ? [
      n[0] || 0,
      n[1] || 0
    ] : [
      e / t / 3,
      r / t / 3,
      t
    ];
  }
  function A1t(n, t, e, r) {
    for (var i = (n.length - 2) / 6, a = 1 / 0, s = 0, o = n.length, l = o - 2, u = 0; u < i; u++) {
      for (var c = u * 6, h = 0, f = 0; f < o; f += 2) {
        var d = f === 0 ? c : (c + f - 2) % l + 2, p = n[d] - e[0], g = n[d + 1] - e[1], v = t[f] - r[0], m = t[f + 1] - r[1], y = v - p, x = m - g;
        h += y * y + x * x;
      }
      h < a && (a = h, s = u);
    }
    return s;
  }
  function k1t(n) {
    for (var t = [], e = n.length, r = 0; r < e; r += 2) t[r] = n[e - r - 2], t[r + 1] = n[e - r - 1];
    return t;
  }
  function D1t(n, t, e, r) {
    for (var i = [], a, s = 0; s < n.length; s++) {
      var o = n[s], l = t[s], u = nz(o), c = nz(l);
      a == null && (a = u[2] < 0 != c[2] < 0);
      var h = [], f = [], d = 0, p = 1 / 0, g = [], v = o.length;
      a && (o = k1t(o));
      for (var m = A1t(o, l, u, c) * 6, y = v - 2, x = 0; x < y; x += 2) {
        var b = (m + x) % y + 2;
        h[x + 2] = o[b] - u[0], h[x + 3] = o[b + 1] - u[1];
      }
      h[0] = o[m] - u[0], h[1] = o[m + 1] - u[1];
      for (var _ = r / e, w = -r / 2; w <= r / 2; w += _) {
        for (var S = Math.sin(w), I = Math.cos(w), T = 0, x = 0; x < o.length; x += 2) {
          var A = h[x], C = h[x + 1], D = l[x] - c[0], E = l[x + 1] - c[1], M = D * I - E * S, L = D * S + E * I;
          g[x] = M, g[x + 1] = L;
          var k = M - A, N = L - C;
          T += k * k + N * N;
        }
        if (T < p) {
          p = T, d = w;
          for (var R = 0; R < g.length; R++) f[R] = g[R];
        }
      }
      i.push({
        from: h,
        to: f,
        fromCp: u,
        toCp: c,
        rotation: -d
      });
    }
    return i;
  }
  function Ib(n) {
    return n.__isCombineMorphing;
  }
  var JX = "__mOriginal_";
  function Ab(n, t, e) {
    var r = JX + t, i = n[r] || n[t];
    n[r] || (n[r] = n[t]);
    var a = e.replace, s = e.after, o = e.before;
    n[t] = function() {
      var l = arguments, u;
      return o && o.apply(this, l), a ? u = a.apply(this, l) : u = i.apply(this, l), s && s.apply(this, l), u;
    };
  }
  function _g(n, t) {
    var e = JX + t;
    n[e] && (n[t] = n[e], n[e] = null);
  }
  function rz(n, t) {
    for (var e = 0; e < n.length; e++) for (var r = n[e], i = 0; i < r.length; ) {
      var a = r[i], s = r[i + 1];
      r[i++] = t[0] * a + t[2] * s + t[4], r[i++] = t[1] * a + t[3] * s + t[5];
    }
  }
  function QX(n, t) {
    var e = n.getUpdatedPathProxy(), r = t.getUpdatedPathProxy(), i = I1t(i2(e), i2(r)), a = i[0], s = i[1], o = n.getComputedTransform(), l = t.getComputedTransform();
    function u() {
      this.transform = null;
    }
    o && rz(a, o), l && rz(s, l), Ab(t, "updateTransform", {
      replace: u
    }), t.transform = null;
    var c = D1t(a, s, 10, Math.PI), h = [];
    Ab(t, "buildPath", {
      replace: function(f) {
        for (var d = t.__morphT, p = 1 - d, g = [], v = 0; v < c.length; v++) {
          var m = c[v], y = m.from, x = m.to, b = m.rotation * d, _ = m.fromCp, w = m.toCp, S = Math.sin(b), I = Math.cos(b);
          nx(g, _, w, d);
          for (var T = 0; T < y.length; T += 2) {
            var A = y[T], C = y[T + 1], D = x[T], E = x[T + 1], M = A * p + D * d, L = C * p + E * d;
            h[T] = M * I - L * S + g[0], h[T + 1] = M * S + L * I + g[1];
          }
          var k = h[0], N = h[1];
          f.moveTo(k, N);
          for (var T = 2; T < y.length; ) {
            var D = h[T++], E = h[T++], R = h[T++], $ = h[T++], O = h[T++], F = h[T++];
            k === D && N === E && R === O && $ === F ? f.lineTo(O, F) : f.bezierCurveTo(D, E, R, $, O, F), k = O, N = F;
          }
        }
      }
    });
  }
  function $E(n, t, e) {
    if (!n || !t) return t;
    var r = e.done, i = e.during;
    QX(n, t), t.__morphT = 0;
    function a() {
      _g(t, "buildPath"), _g(t, "updateTransform"), t.__morphT = -1, t.createPathProxy(), t.dirtyShape();
    }
    return t.animateTo({
      __morphT: 1
    }, $t({
      during: function(s) {
        t.dirtyShape(), i && i(s);
      },
      done: function() {
        a(), r && r();
      }
    }, e)), t;
  }
  function E1t(n, t, e, r, i, a) {
    var s = 16;
    n = i === e ? 0 : Math.round(32767 * (n - e) / (i - e)), t = a === r ? 0 : Math.round(32767 * (t - r) / (a - r));
    for (var o = 0, l, u = (1 << s) / 2; u > 0; u /= 2) {
      var c = 0, h = 0;
      (n & u) > 0 && (c = 1), (t & u) > 0 && (h = 1), o += u * u * (3 * c ^ h), h === 0 && (c === 1 && (n = u - 1 - n, t = u - 1 - t), l = n, n = t, t = l);
    }
    return o;
  }
  function kb(n) {
    var t = 1 / 0, e = 1 / 0, r = -1 / 0, i = -1 / 0, a = ht(n, function(o) {
      var l = o.getBoundingRect(), u = o.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), h = l.y + l.height / 2 + (u ? u[5] : 0);
      return t = Math.min(c, t), e = Math.min(h, e), r = Math.max(c, r), i = Math.max(h, i), [
        c,
        h
      ];
    }), s = ht(a, function(o, l) {
      return {
        cp: o,
        z: E1t(o[0], o[1], t, e, r, i),
        path: n[l]
      };
    });
    return s.sort(function(o, l) {
      return o.z - l.z;
    }).map(function(o) {
      return o.path;
    });
  }
  function tY(n) {
    return C1t(n.path, n.count);
  }
  function s2() {
    return {
      fromIndividuals: [],
      toIndividuals: [],
      count: 0
    };
  }
  function M1t(n, t, e) {
    var r = [];
    function i(_) {
      for (var w = 0; w < _.length; w++) {
        var S = _[w];
        Ib(S) ? i(S.childrenRef()) : S instanceof le && r.push(S);
      }
    }
    i(n);
    var a = r.length;
    if (!a) return s2();
    var s = e.dividePath || tY, o = s({
      path: t,
      count: a
    });
    if (o.length !== a) return console.error("Invalid morphing: unmatched splitted path"), s2();
    r = kb(r), o = kb(o);
    for (var l = e.done, u = e.during, c = e.individualDelay, h = new To(), f = 0; f < a; f++) {
      var d = r[f], p = o[f];
      p.parent = t, p.copyTransform(h), c || QX(d, p);
    }
    t.__isCombineMorphing = true, t.childrenRef = function() {
      return o;
    };
    function g(_) {
      for (var w = 0; w < o.length; w++) o[w].addSelfToZr(_);
    }
    Ab(t, "addSelfToZr", {
      after: function(_) {
        g(_);
      }
    }), Ab(t, "removeSelfFromZr", {
      after: function(_) {
        for (var w = 0; w < o.length; w++) o[w].removeSelfFromZr(_);
      }
    });
    function v() {
      t.__isCombineMorphing = false, t.__morphT = -1, t.childrenRef = null, _g(t, "addSelfToZr"), _g(t, "removeSelfFromZr");
    }
    var m = o.length;
    if (c) for (var y = m, x = function() {
      y--, y === 0 && (v(), l && l());
    }, f = 0; f < m; f++) {
      var b = c ? $t({
        delay: (e.delay || 0) + c(f, m, r[f], o[f]),
        done: x
      }, e) : e;
      $E(r[f], o[f], b);
    }
    else t.__morphT = 0, t.animateTo({
      __morphT: 1
    }, $t({
      during: function(_) {
        for (var w = 0; w < m; w++) {
          var S = o[w];
          S.__morphT = t.__morphT, S.dirtyShape();
        }
        u && u(_);
      },
      done: function() {
        v();
        for (var _ = 0; _ < n.length; _++) _g(n[_], "updateTransform");
        l && l();
      }
    }, e));
    return t.__zr && g(t.__zr), {
      fromIndividuals: r,
      toIndividuals: o,
      count: m
    };
  }
  function R1t(n, t, e) {
    var r = t.length, i = [], a = e.dividePath || tY;
    function s(d) {
      for (var p = 0; p < d.length; p++) {
        var g = d[p];
        Ib(g) ? s(g.childrenRef()) : g instanceof le && i.push(g);
      }
    }
    if (Ib(n)) {
      s(n.childrenRef());
      var o = i.length;
      if (o < r) for (var l = 0, u = o; u < r; u++) i.push(Qk(i[l++ % o]));
      i.length = r;
    } else {
      i = a({
        path: n,
        count: r
      });
      for (var c = n.getComputedTransform(), u = 0; u < i.length; u++) i[u].setLocalTransform(c);
      if (i.length !== r) return console.error("Invalid morphing: unmatched splitted path"), s2();
    }
    i = kb(i), t = kb(t);
    for (var h = e.individualDelay, u = 0; u < r; u++) {
      var f = h ? $t({
        delay: (e.delay || 0) + h(u, r, i[u], t[u])
      }, e) : e;
      $E(i[u], t[u], f);
    }
    return {
      fromIndividuals: i,
      toIndividuals: t,
      count: t.length
    };
  }
  function iz(n) {
    return ct(n[0]);
  }
  function az(n, t) {
    for (var e = [], r = n.length, i = 0; i < r; i++) e.push({
      one: n[i],
      many: []
    });
    for (var i = 0; i < t.length; i++) {
      var a = t[i].length, s = void 0;
      for (s = 0; s < a; s++) e[s % r].many.push(t[i][s]);
    }
    for (var o = 0, i = r - 1; i >= 0; i--) if (!e[i].many.length) {
      var l = e[o].many;
      if (l.length <= 1) if (o) o = 0;
      else return e;
      var a = l.length, u = Math.ceil(a / 2);
      e[i].many = l.slice(u, a), e[o].many = l.slice(0, u), o++;
    }
    return e;
  }
  var N1t = {
    clone: function(n) {
      for (var t = [], e = 1 - Math.pow(1 - n.path.style.opacity, 1 / n.count), r = 0; r < n.count; r++) {
        var i = Qk(n.path);
        i.setStyle("opacity", e), t.push(i);
      }
      return t;
    },
    split: null
  };
  function sT(n, t, e, r, i, a) {
    if (!n.length || !t.length) return;
    var s = _d("update", r, i);
    if (!(s && s.duration > 0)) return;
    var o = r.getModel("universalTransition").get("delay"), l = Object.assign({
      setToFinal: true
    }, s), u, c;
    iz(n) && (u = n, c = t), iz(t) && (u = t, c = n);
    function h(m, y, x, b, _) {
      var w = m.many, S = m.one;
      if (w.length === 1 && !_) {
        var I = y ? w[0] : S, T = y ? S : w[0];
        if (Ib(I)) h({
          many: [
            I
          ],
          one: T
        }, true, x, b, true);
        else {
          var A = o ? $t({
            delay: o(x, b)
          }, l) : l;
          $E(I, T, A), a(I, T, I, T, A);
        }
      } else for (var C = $t({
        dividePath: N1t[e],
        individualDelay: o && function(N, R, $, O) {
          return o(N + x, b);
        }
      }, l), D = y ? M1t(w, S, C) : R1t(S, w, C), E = D.fromIndividuals, M = D.toIndividuals, L = E.length, k = 0; k < L; k++) {
        var A = o ? $t({
          delay: o(k, L)
        }, l) : l;
        a(E[k], M[k], y ? w[k] : m.one, y ? m.one : w[k], A);
      }
    }
    for (var f = u ? u === n : n.length > t.length, d = u ? az(c, u) : az(f ? t : n, [
      f ? n : t
    ]), p = 0, g = 0; g < d.length; g++) p += d[g].many.length;
    for (var v = 0, g = 0; g < d.length; g++) h(d[g], f, v, p), v += d[g].many.length;
  }
  function rc(n) {
    if (!n) return [];
    if (ct(n)) {
      for (var t = [], e = 0; e < n.length; e++) t.push(rc(n[e]));
      return t;
    }
    var r = [];
    return n.traverse(function(i) {
      i instanceof le && !i.disableMorphing && !i.invisible && !i.ignore && r.push(i);
    }), r;
  }
  var eY = 1e4, L1t = 0, sz = 1, oz = 2, P1t = xe();
  function $1t(n, t) {
    for (var e = n.dimensions, r = 0; r < e.length; r++) {
      var i = n.getDimensionInfo(e[r]);
      if (i && i.otherDims[t] === 0) return e[r];
    }
  }
  function O1t(n, t, e) {
    var r = n.getDimensionInfo(e), i = r && r.ordinalMeta;
    if (r) {
      var a = n.get(r.name, t);
      return i && i.categories[a] || a + "";
    }
  }
  function lz(n, t, e, r) {
    var i = r ? "itemChildGroupId" : "itemGroupId", a = $1t(n, i);
    if (a) {
      var s = O1t(n, t, a);
      return s;
    }
    var o = n.getRawDataItem(t), l = r ? "childGroupId" : "groupId";
    if (o && o[l]) return o[l] + "";
    if (!r) return e || n.getId(t);
  }
  function uz(n) {
    var t = [];
    return P(n, function(e) {
      var r = e.data, i = e.dataGroupId;
      if (!(r.count() > eY)) for (var a = r.getIndices(), s = 0; s < a.length; s++) t.push({
        data: r,
        groupId: lz(r, s, i, false),
        childGroupId: lz(r, s, i, true),
        divide: e.divide,
        dataIndex: s
      });
    }), t;
  }
  function oT(n, t, e) {
    n.traverse(function(r) {
      r instanceof le && dn(r, {
        style: {
          opacity: 0
        }
      }, t, {
        dataIndex: e,
        isFrom: true
      });
    });
  }
  function lT(n) {
    if (n.parent) {
      var t = n.getComputedTransform();
      n.setLocalTransform(t), n.parent.remove(n);
    }
  }
  function Qh(n) {
    n.stopAnimation(), n.isGroup && n.traverse(function(t) {
      t.stopAnimation();
    });
  }
  function F1t(n, t, e) {
    var r = _d("update", e, t);
    r && n.traverse(function(i) {
      if (i instanceof Ia) {
        var a = Mit(i);
        a && i.animateFrom({
          style: a
        }, r);
      }
    });
  }
  function B1t(n, t) {
    var e = n.length;
    if (e !== t.length) return false;
    for (var r = 0; r < e; r++) {
      var i = n[r], a = t[r];
      if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex)) return false;
    }
    return true;
  }
  function nY(n, t, e) {
    var r = uz(n), i = uz(t);
    function a(x, b, _, w, S) {
      (_ || x) && b.animateFrom({
        style: _ && _ !== x ? rt(rt({}, _.style), x.style) : x.style
      }, S);
    }
    var s = false, o = L1t, l = It(), u = It();
    r.forEach(function(x) {
      x.groupId && l.set(x.groupId, true), x.childGroupId && u.set(x.childGroupId, true);
    });
    for (var c = 0; c < i.length; c++) {
      var h = i[c].groupId;
      if (u.get(h)) {
        o = sz;
        break;
      }
      var f = i[c].childGroupId;
      if (f && l.get(f)) {
        o = oz;
        break;
      }
    }
    function d(x, b) {
      return function(_) {
        var w = _.data, S = _.dataIndex;
        return b ? w.getId(S) : x ? o === sz ? _.childGroupId : _.groupId : o === oz ? _.childGroupId : _.groupId;
      };
    }
    var p = B1t(r, i), g = {};
    if (!p) for (var c = 0; c < i.length; c++) {
      var v = i[c], m = v.data.getItemGraphicEl(v.dataIndex);
      m && (g[m.id] = true);
    }
    function y(x, b) {
      var _ = r[b], w = i[x], S = w.data.hostModel, I = _.data.getItemGraphicEl(_.dataIndex), T = w.data.getItemGraphicEl(w.dataIndex);
      if (I === T) {
        T && F1t(T, w.dataIndex, S);
        return;
      }
      I && g[I.id] || T && (Qh(T), I ? (Qh(I), lT(I), s = true, sT(rc(I), rc(T), w.divide, S, x, a)) : oT(T, S, x));
    }
    new Wo(r, i, d(true, p), d(false, p), null, "multiple").update(y).updateManyToOne(function(x, b) {
      var _ = i[x], w = _.data, S = w.hostModel, I = w.getItemGraphicEl(_.dataIndex), T = Le(ht(b, function(A) {
        return r[A].data.getItemGraphicEl(r[A].dataIndex);
      }), function(A) {
        return A && A !== I && !g[A.id];
      });
      I && (Qh(I), T.length ? (P(T, function(A) {
        Qh(A), lT(A);
      }), s = true, sT(rc(T), rc(I), _.divide, S, x, a)) : oT(I, S, _.dataIndex));
    }).updateOneToMany(function(x, b) {
      var _ = r[b], w = _.data.getItemGraphicEl(_.dataIndex);
      if (!(w && g[w.id])) {
        var S = Le(ht(x, function(T) {
          return i[T].data.getItemGraphicEl(i[T].dataIndex);
        }), function(T) {
          return T && T !== w;
        }), I = i[x[0]].data.hostModel;
        S.length && (P(S, function(T) {
          return Qh(T);
        }), w ? (Qh(w), lT(w), s = true, sT(rc(w), rc(S), _.divide, I, x[0], a)) : P(S, function(T) {
          return oT(T, I, x[0]);
        }));
      }
    }).updateManyToMany(function(x, b) {
      new Wo(b, x, function(_) {
        return r[_].data.getId(r[_].dataIndex);
      }, function(_) {
        return i[_].data.getId(i[_].dataIndex);
      }).update(function(_, w) {
        y(x[_], b[w]);
      }).execute();
    }).execute(), s && P(t, function(x) {
      var b = x.data, _ = b.hostModel, w = _ && e.getViewOfSeriesModel(_), S = _d("update", _, 0);
      w && _.isAnimationEnabled() && S && S.duration > 0 && w.group.traverse(function(I) {
        I instanceof le && !I.animators.length && I.animateFrom({
          style: {
            opacity: 0
          }
        }, S);
      });
    });
  }
  function cz(n) {
    var t = n.getModel("universalTransition").get("seriesKey");
    return t || n.id;
  }
  function hz(n) {
    return ct(n) ? n.sort().join(",") : n;
  }
  function _l(n) {
    if (n.hostModel) return n.hostModel.getModel("universalTransition").get("divideShape");
  }
  function z1t(n, t) {
    var e = It(), r = It(), i = It();
    return P(n.oldSeries, function(a, s) {
      var o = n.oldDataGroupIds[s], l = n.oldData[s], u = cz(a), c = hz(u);
      r.set(c, {
        dataGroupId: o,
        data: l
      }), ct(u) && P(u, function(h) {
        i.set(h, {
          key: c,
          dataGroupId: o,
          data: l
        });
      });
    }), P(t.updatedSeries, function(a) {
      if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
        var s = a.get("dataGroupId"), o = a.getData(), l = cz(a), u = hz(l), c = r.get(u);
        if (c) e.set(u, {
          oldSeries: [
            {
              dataGroupId: c.dataGroupId,
              divide: _l(c.data),
              data: c.data
            }
          ],
          newSeries: [
            {
              dataGroupId: s,
              divide: _l(o),
              data: o
            }
          ]
        });
        else if (ct(l)) {
          var h = [];
          P(l, function(p) {
            var g = r.get(p);
            g.data && h.push({
              dataGroupId: g.dataGroupId,
              divide: _l(g.data),
              data: g.data
            });
          }), h.length && e.set(u, {
            oldSeries: h,
            newSeries: [
              {
                dataGroupId: s,
                data: o,
                divide: _l(o)
              }
            ]
          });
        } else {
          var f = i.get(l);
          if (f) {
            var d = e.get(f.key);
            d || (d = {
              oldSeries: [
                {
                  dataGroupId: f.dataGroupId,
                  data: f.data,
                  divide: _l(f.data)
                }
              ],
              newSeries: []
            }, e.set(f.key, d)), d.newSeries.push({
              dataGroupId: s,
              data: o,
              divide: _l(o)
            });
          }
        }
      }
    }), e;
  }
  function fz(n, t) {
    for (var e = 0; e < n.length; e++) {
      var r = t.seriesIndex != null && t.seriesIndex === n[e].seriesIndex || t.seriesId != null && t.seriesId === n[e].id;
      if (r) return e;
    }
  }
  function V1t(n, t, e, r) {
    var i = [], a = [];
    P(He(n.from), function(s) {
      var o = fz(t.oldSeries, s);
      o >= 0 && i.push({
        dataGroupId: t.oldDataGroupIds[o],
        data: t.oldData[o],
        divide: _l(t.oldData[o]),
        groupIdDim: s.dimension
      });
    }), P(He(n.to), function(s) {
      var o = fz(e.updatedSeries, s);
      if (o >= 0) {
        var l = e.updatedSeries[o].getData();
        a.push({
          dataGroupId: t.oldDataGroupIds[o],
          data: l,
          divide: _l(l),
          groupIdDim: s.dimension
        });
      }
    }), i.length > 0 && a.length > 0 && nY(i, a, r);
  }
  function G1t(n) {
    n.registerUpdateLifecycle("series:beforeupdate", function(t, e, r) {
      P(He(r.seriesTransition), function(i) {
        P(He(i.to), function(a) {
          for (var s = r.updatedSeries, o = 0; o < s.length; o++) (a.seriesIndex != null && a.seriesIndex === s[o].seriesIndex || a.seriesId != null && a.seriesId === s[o].id) && (s[o][px] = true);
        });
      });
    }), n.registerUpdateLifecycle("series:transition", function(t, e, r) {
      var i = P1t(e);
      if (i.oldSeries && r.updatedSeries && r.optionChanged) {
        var a = r.seriesTransition;
        if (a) P(He(a), function(d) {
          V1t(d, i, r, e);
        });
        else {
          var s = z1t(i, r);
          P(s.keys(), function(d) {
            var p = s.get(d);
            nY(p.oldSeries, p.newSeries, e);
          });
        }
        P(r.updatedSeries, function(d) {
          d[px] && (d[px] = false);
        });
      }
      for (var o = t.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], h = 0; h < o.length; h++) {
        var f = o[h].getData();
        f.count() < eY && (l.push(o[h]), u.push(o[h].get("dataGroupId")), c.push(f));
      }
    });
  }
  se([
    Jut
  ]);
  se([
    Yut
  ]);
  se([
    yct,
    Nct,
    Wct,
    wht,
    Nht,
    xft,
    Yft,
    Edt,
    Jdt,
    ipt,
    dpt,
    ogt,
    Rgt,
    Wgt,
    avt,
    uvt,
    xvt,
    Ivt,
    Ovt,
    Wvt,
    Qvt,
    $mt
  ]);
  se(eyt);
  se(Ayt);
  se(t8);
  se(zyt);
  se(B8);
  se(Uyt);
  se(Qyt);
  se(z0t);
  se(axt);
  se(Zv);
  se(wxt);
  se(Txt);
  se(Pxt);
  se(Gxt);
  se(qxt);
  se(tbt);
  se(cbt);
  se(kbt);
  se(GX);
  se(WX);
  se(qbt);
  se(qX);
  se(jX);
  se(Qbt);
  se(f1t);
  se(g1t);
  se(G1t);
  se(dut);
  const W1t = (n) => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var _0 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };
  const U1t = ({ size: n, strokeWidth: t = 2, absoluteStrokeWidth: e, color: r, iconNode: i, name: a, class: s, ...o }, { slots: l }) => Qa("svg", {
    ..._0,
    width: n || _0.width,
    height: n || _0.height,
    stroke: r || _0.stroke,
    "stroke-width": e ? Number(t) * 24 / Number(n) : t,
    class: [
      "lucide",
      `lucide-${W1t(a ?? "icon")}`
    ],
    ...o
  }, [
    ...i.map((u) => Qa(...u)),
    ...l.default ? [
      l.default()
    ] : []
  ]);
  const OE = (n, t) => (e, { slots: r }) => Qa(U1t, {
    ...e,
    iconNode: t,
    name: n
  }, r);
  const H1t = OE("LoaderIcon", [
    [
      "path",
      {
        d: "M12 2v4",
        key: "3427ic"
      }
    ],
    [
      "path",
      {
        d: "m16.2 7.8 2.9-2.9",
        key: "r700ao"
      }
    ],
    [
      "path",
      {
        d: "M18 12h4",
        key: "wj9ykh"
      }
    ],
    [
      "path",
      {
        d: "m16.2 16.2 2.9 2.9",
        key: "1bxg5t"
      }
    ],
    [
      "path",
      {
        d: "M12 18v4",
        key: "jadmvz"
      }
    ],
    [
      "path",
      {
        d: "m4.9 19.1 2.9-2.9",
        key: "bwix9q"
      }
    ],
    [
      "path",
      {
        d: "M2 12h4",
        key: "j09sii"
      }
    ],
    [
      "path",
      {
        d: "m4.9 4.9 2.9 2.9",
        key: "giyufr"
      }
    ]
  ]);
  const X1t = OE("UploadIcon", [
    [
      "path",
      {
        d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
        key: "ih7n3h"
      }
    ],
    [
      "polyline",
      {
        points: "17 8 12 3 7 8",
        key: "t8dd8p"
      }
    ],
    [
      "line",
      {
        x1: "12",
        x2: "12",
        y1: "3",
        y2: "15",
        key: "widbto"
      }
    ]
  ]);
  const Y1t = OE("XIcon", [
    [
      "path",
      {
        d: "M18 6 6 18",
        key: "1bl5f8"
      }
    ],
    [
      "path",
      {
        d: "m6 6 12 12",
        key: "d8bk6v"
      }
    ]
  ]);
  ktt();
  function rY(n) {
    return typeof n > "u" || n === null;
  }
  function q1t(n) {
    return typeof n == "object" && n !== null;
  }
  function j1t(n) {
    return Array.isArray(n) ? n : rY(n) ? [] : [
      n
    ];
  }
  function K1t(n, t) {
    var e, r, i, a;
    if (t) for (a = Object.keys(t), e = 0, r = a.length; e < r; e += 1) i = a[e], n[i] = t[i];
    return n;
  }
  function Z1t(n, t) {
    var e = "", r;
    for (r = 0; r < t; r += 1) e += n;
    return e;
  }
  function J1t(n) {
    return n === 0 && Number.NEGATIVE_INFINITY === 1 / n;
  }
  var Q1t = rY, t_t = q1t, e_t = j1t, n_t = Z1t, r_t = J1t, i_t = K1t, nr = {
    isNothing: Q1t,
    isObject: t_t,
    toArray: e_t,
    repeat: n_t,
    isNegativeZero: r_t,
    extend: i_t
  };
  function iY(n, t) {
    var e = "", r = n.reason || "(unknown reason)";
    return n.mark ? (n.mark.name && (e += 'in "' + n.mark.name + '" '), e += "(" + (n.mark.line + 1) + ":" + (n.mark.column + 1) + ")", !t && n.mark.snippet && (e += `

` + n.mark.snippet), r + " " + e) : r;
  }
  function av(n, t) {
    Error.call(this), this.name = "YAMLException", this.reason = n, this.mark = t, this.message = iY(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  av.prototype = Object.create(Error.prototype);
  av.prototype.constructor = av;
  av.prototype.toString = function(t) {
    return this.name + ": " + iY(this, t);
  };
  var ci = av;
  function uT(n, t, e, r, i) {
    var a = "", s = "", o = Math.floor(i / 2) - 1;
    return r - t > o && (a = " ... ", t = r - o + a.length), e - r > o && (s = " ...", e = r + o - s.length), {
      str: a + n.slice(t, e).replace(/\t/g, "\u2192") + s,
      pos: r - t + a.length
    };
  }
  function cT(n, t) {
    return nr.repeat(" ", t - n.length) + n;
  }
  function a_t(n, t) {
    if (t = Object.create(t || null), !n.buffer) return null;
    t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
    for (var e = /\r?\n|\r|\0/g, r = [
      0
    ], i = [], a, s = -1; a = e.exec(n.buffer); ) i.push(a.index), r.push(a.index + a[0].length), n.position <= a.index && s < 0 && (s = r.length - 2);
    s < 0 && (s = r.length - 1);
    var o = "", l, u, c = Math.min(n.line + t.linesAfter, i.length).toString().length, h = t.maxLength - (t.indent + c + 3);
    for (l = 1; l <= t.linesBefore && !(s - l < 0); l++) u = uT(n.buffer, r[s - l], i[s - l], n.position - (r[s] - r[s - l]), h), o = nr.repeat(" ", t.indent) + cT((n.line - l + 1).toString(), c) + " | " + u.str + `
` + o;
    for (u = uT(n.buffer, r[s], i[s], n.position, h), o += nr.repeat(" ", t.indent) + cT((n.line + 1).toString(), c) + " | " + u.str + `
`, o += nr.repeat("-", t.indent + c + 3 + u.pos) + `^
`, l = 1; l <= t.linesAfter && !(s + l >= i.length); l++) u = uT(n.buffer, r[s + l], i[s + l], n.position - (r[s] - r[s + l]), h), o += nr.repeat(" ", t.indent) + cT((n.line + l + 1).toString(), c) + " | " + u.str + `
`;
    return o.replace(/\n$/, "");
  }
  var s_t = a_t, o_t = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], l_t = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function u_t(n) {
    var t = {};
    return n !== null && Object.keys(n).forEach(function(e) {
      n[e].forEach(function(r) {
        t[String(r)] = e;
      });
    }), t;
  }
  function c_t(n, t) {
    if (t = t || {}, Object.keys(t).forEach(function(e) {
      if (o_t.indexOf(e) === -1) throw new ci('Unknown option "' + e + '" is met in definition of "' + n + '" YAML type.');
    }), this.options = t, this.tag = n, this.kind = t.kind || null, this.resolve = t.resolve || function() {
      return true;
    }, this.construct = t.construct || function(e) {
      return e;
    }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || false, this.styleAliases = u_t(t.styleAliases || null), l_t.indexOf(this.kind) === -1) throw new ci('Unknown kind "' + this.kind + '" is specified for "' + n + '" YAML type.');
  }
  var Ir = c_t;
  function dz(n, t) {
    var e = [];
    return n[t].forEach(function(r) {
      var i = e.length;
      e.forEach(function(a, s) {
        a.tag === r.tag && a.kind === r.kind && a.multi === r.multi && (i = s);
      }), e[i] = r;
    }), e;
  }
  function h_t() {
    var n = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, t, e;
    function r(i) {
      i.multi ? (n.multi[i.kind].push(i), n.multi.fallback.push(i)) : n[i.kind][i.tag] = n.fallback[i.tag] = i;
    }
    for (t = 0, e = arguments.length; t < e; t += 1) arguments[t].forEach(r);
    return n;
  }
  function o2(n) {
    return this.extend(n);
  }
  o2.prototype.extend = function(t) {
    var e = [], r = [];
    if (t instanceof Ir) r.push(t);
    else if (Array.isArray(t)) r = r.concat(t);
    else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit))) t.implicit && (e = e.concat(t.implicit)), t.explicit && (r = r.concat(t.explicit));
    else throw new ci("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    e.forEach(function(a) {
      if (!(a instanceof Ir)) throw new ci("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (a.loadKind && a.loadKind !== "scalar") throw new ci("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (a.multi) throw new ci("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), r.forEach(function(a) {
      if (!(a instanceof Ir)) throw new ci("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var i = Object.create(o2.prototype);
    return i.implicit = (this.implicit || []).concat(e), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = dz(i, "implicit"), i.compiledExplicit = dz(i, "explicit"), i.compiledTypeMap = h_t(i.compiledImplicit, i.compiledExplicit), i;
  };
  var aY = o2, sY = new Ir("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(n) {
      return n !== null ? n : "";
    }
  }), oY = new Ir("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(n) {
      return n !== null ? n : [];
    }
  }), lY = new Ir("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(n) {
      return n !== null ? n : {};
    }
  }), uY = new aY({
    explicit: [
      sY,
      oY,
      lY
    ]
  });
  function f_t(n) {
    if (n === null) return true;
    var t = n.length;
    return t === 1 && n === "~" || t === 4 && (n === "null" || n === "Null" || n === "NULL");
  }
  function d_t() {
    return null;
  }
  function p_t(n) {
    return n === null;
  }
  var cY = new Ir("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: f_t,
    construct: d_t,
    predicate: p_t,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function g_t(n) {
    if (n === null) return false;
    var t = n.length;
    return t === 4 && (n === "true" || n === "True" || n === "TRUE") || t === 5 && (n === "false" || n === "False" || n === "FALSE");
  }
  function v_t(n) {
    return n === "true" || n === "True" || n === "TRUE";
  }
  function m_t(n) {
    return Object.prototype.toString.call(n) === "[object Boolean]";
  }
  var hY = new Ir("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: g_t,
    construct: v_t,
    predicate: m_t,
    represent: {
      lowercase: function(n) {
        return n ? "true" : "false";
      },
      uppercase: function(n) {
        return n ? "TRUE" : "FALSE";
      },
      camelcase: function(n) {
        return n ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function y_t(n) {
    return 48 <= n && n <= 57 || 65 <= n && n <= 70 || 97 <= n && n <= 102;
  }
  function x_t(n) {
    return 48 <= n && n <= 55;
  }
  function b_t(n) {
    return 48 <= n && n <= 57;
  }
  function __t(n) {
    if (n === null) return false;
    var t = n.length, e = 0, r = false, i;
    if (!t) return false;
    if (i = n[e], (i === "-" || i === "+") && (i = n[++e]), i === "0") {
      if (e + 1 === t) return true;
      if (i = n[++e], i === "b") {
        for (e++; e < t; e++) if (i = n[e], i !== "_") {
          if (i !== "0" && i !== "1") return false;
          r = true;
        }
        return r && i !== "_";
      }
      if (i === "x") {
        for (e++; e < t; e++) if (i = n[e], i !== "_") {
          if (!y_t(n.charCodeAt(e))) return false;
          r = true;
        }
        return r && i !== "_";
      }
      if (i === "o") {
        for (e++; e < t; e++) if (i = n[e], i !== "_") {
          if (!x_t(n.charCodeAt(e))) return false;
          r = true;
        }
        return r && i !== "_";
      }
    }
    if (i === "_") return false;
    for (; e < t; e++) if (i = n[e], i !== "_") {
      if (!b_t(n.charCodeAt(e))) return false;
      r = true;
    }
    return !(!r || i === "_");
  }
  function w_t(n) {
    var t = n, e = 1, r;
    if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), r = t[0], (r === "-" || r === "+") && (r === "-" && (e = -1), t = t.slice(1), r = t[0]), t === "0") return 0;
    if (r === "0") {
      if (t[1] === "b") return e * parseInt(t.slice(2), 2);
      if (t[1] === "x") return e * parseInt(t.slice(2), 16);
      if (t[1] === "o") return e * parseInt(t.slice(2), 8);
    }
    return e * parseInt(t, 10);
  }
  function S_t(n) {
    return Object.prototype.toString.call(n) === "[object Number]" && n % 1 === 0 && !nr.isNegativeZero(n);
  }
  var fY = new Ir("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: __t,
    construct: w_t,
    predicate: S_t,
    represent: {
      binary: function(n) {
        return n >= 0 ? "0b" + n.toString(2) : "-0b" + n.toString(2).slice(1);
      },
      octal: function(n) {
        return n >= 0 ? "0o" + n.toString(8) : "-0o" + n.toString(8).slice(1);
      },
      decimal: function(n) {
        return n.toString(10);
      },
      hexadecimal: function(n) {
        return n >= 0 ? "0x" + n.toString(16).toUpperCase() : "-0x" + n.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [
        2,
        "bin"
      ],
      octal: [
        8,
        "oct"
      ],
      decimal: [
        10,
        "dec"
      ],
      hexadecimal: [
        16,
        "hex"
      ]
    }
  }), C_t = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
  function T_t(n) {
    return !(n === null || !C_t.test(n) || n[n.length - 1] === "_");
  }
  function I_t(n) {
    var t, e;
    return t = n.replace(/_/g, "").toLowerCase(), e = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? e === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : e * parseFloat(t, 10);
  }
  var A_t = /^[-+]?[0-9]+e/;
  function k_t(n, t) {
    var e;
    if (isNaN(n)) switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
    else if (Number.POSITIVE_INFINITY === n) switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
    else if (Number.NEGATIVE_INFINITY === n) switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
    else if (nr.isNegativeZero(n)) return "-0.0";
    return e = n.toString(10), A_t.test(e) ? e.replace("e", ".e") : e;
  }
  function D_t(n) {
    return Object.prototype.toString.call(n) === "[object Number]" && (n % 1 !== 0 || nr.isNegativeZero(n));
  }
  var dY = new Ir("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: T_t,
    construct: I_t,
    predicate: D_t,
    represent: k_t,
    defaultStyle: "lowercase"
  }), pY = uY.extend({
    implicit: [
      cY,
      hY,
      fY,
      dY
    ]
  }), gY = pY, vY = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), mY = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
  function E_t(n) {
    return n === null ? false : vY.exec(n) !== null || mY.exec(n) !== null;
  }
  function M_t(n) {
    var t, e, r, i, a, s, o, l = 0, u = null, c, h, f;
    if (t = vY.exec(n), t === null && (t = mY.exec(n)), t === null) throw new Error("Date resolve error");
    if (e = +t[1], r = +t[2] - 1, i = +t[3], !t[4]) return new Date(Date.UTC(e, r, i));
    if (a = +t[4], s = +t[5], o = +t[6], t[7]) {
      for (l = t[7].slice(0, 3); l.length < 3; ) l += "0";
      l = +l;
    }
    return t[9] && (c = +t[10], h = +(t[11] || 0), u = (c * 60 + h) * 6e4, t[9] === "-" && (u = -u)), f = new Date(Date.UTC(e, r, i, a, s, o, l)), u && f.setTime(f.getTime() - u), f;
  }
  function R_t(n) {
    return n.toISOString();
  }
  var yY = new Ir("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: E_t,
    construct: M_t,
    instanceOf: Date,
    represent: R_t
  });
  function N_t(n) {
    return n === "<<" || n === null;
  }
  var xY = new Ir("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: N_t
  }), FE = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function L_t(n) {
    if (n === null) return false;
    var t, e, r = 0, i = n.length, a = FE;
    for (e = 0; e < i; e++) if (t = a.indexOf(n.charAt(e)), !(t > 64)) {
      if (t < 0) return false;
      r += 6;
    }
    return r % 8 === 0;
  }
  function P_t(n) {
    var t, e, r = n.replace(/[\r\n=]/g, ""), i = r.length, a = FE, s = 0, o = [];
    for (t = 0; t < i; t++) t % 4 === 0 && t && (o.push(s >> 16 & 255), o.push(s >> 8 & 255), o.push(s & 255)), s = s << 6 | a.indexOf(r.charAt(t));
    return e = i % 4 * 6, e === 0 ? (o.push(s >> 16 & 255), o.push(s >> 8 & 255), o.push(s & 255)) : e === 18 ? (o.push(s >> 10 & 255), o.push(s >> 2 & 255)) : e === 12 && o.push(s >> 4 & 255), new Uint8Array(o);
  }
  function $_t(n) {
    var t = "", e = 0, r, i, a = n.length, s = FE;
    for (r = 0; r < a; r++) r % 3 === 0 && r && (t += s[e >> 18 & 63], t += s[e >> 12 & 63], t += s[e >> 6 & 63], t += s[e & 63]), e = (e << 8) + n[r];
    return i = a % 3, i === 0 ? (t += s[e >> 18 & 63], t += s[e >> 12 & 63], t += s[e >> 6 & 63], t += s[e & 63]) : i === 2 ? (t += s[e >> 10 & 63], t += s[e >> 4 & 63], t += s[e << 2 & 63], t += s[64]) : i === 1 && (t += s[e >> 2 & 63], t += s[e << 4 & 63], t += s[64], t += s[64]), t;
  }
  function O_t(n) {
    return Object.prototype.toString.call(n) === "[object Uint8Array]";
  }
  var bY = new Ir("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: L_t,
    construct: P_t,
    predicate: O_t,
    represent: $_t
  }), F_t = Object.prototype.hasOwnProperty, B_t = Object.prototype.toString;
  function z_t(n) {
    if (n === null) return true;
    var t = [], e, r, i, a, s, o = n;
    for (e = 0, r = o.length; e < r; e += 1) {
      if (i = o[e], s = false, B_t.call(i) !== "[object Object]") return false;
      for (a in i) if (F_t.call(i, a)) if (!s) s = true;
      else return false;
      if (!s) return false;
      if (t.indexOf(a) === -1) t.push(a);
      else return false;
    }
    return true;
  }
  function V_t(n) {
    return n !== null ? n : [];
  }
  var _Y = new Ir("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: z_t,
    construct: V_t
  }), G_t = Object.prototype.toString;
  function W_t(n) {
    if (n === null) return true;
    var t, e, r, i, a, s = n;
    for (a = new Array(s.length), t = 0, e = s.length; t < e; t += 1) {
      if (r = s[t], G_t.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1)) return false;
      a[t] = [
        i[0],
        r[i[0]]
      ];
    }
    return true;
  }
  function U_t(n) {
    if (n === null) return [];
    var t, e, r, i, a, s = n;
    for (a = new Array(s.length), t = 0, e = s.length; t < e; t += 1) r = s[t], i = Object.keys(r), a[t] = [
      i[0],
      r[i[0]]
    ];
    return a;
  }
  var wY = new Ir("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: W_t,
    construct: U_t
  }), H_t = Object.prototype.hasOwnProperty;
  function X_t(n) {
    if (n === null) return true;
    var t, e = n;
    for (t in e) if (H_t.call(e, t) && e[t] !== null) return false;
    return true;
  }
  function Y_t(n) {
    return n !== null ? n : {};
  }
  var SY = new Ir("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: X_t,
    construct: Y_t
  }), BE = gY.extend({
    implicit: [
      yY,
      xY
    ],
    explicit: [
      bY,
      _Y,
      wY,
      SY
    ]
  }), Ql = Object.prototype.hasOwnProperty, Db = 1, CY = 2, TY = 3, Eb = 4, hT = 1, q_t = 2, pz = 3, j_t = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, K_t = /[\x85\u2028\u2029]/, Z_t = /[,\[\]\{\}]/, IY = /^(?:!|!!|![a-z\-]+!)$/i, AY = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function gz(n) {
    return Object.prototype.toString.call(n);
  }
  function Xs(n) {
    return n === 10 || n === 13;
  }
  function Fc(n) {
    return n === 9 || n === 32;
  }
  function Ri(n) {
    return n === 9 || n === 32 || n === 10 || n === 13;
  }
  function If(n) {
    return n === 44 || n === 91 || n === 93 || n === 123 || n === 125;
  }
  function J_t(n) {
    var t;
    return 48 <= n && n <= 57 ? n - 48 : (t = n | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
  }
  function Q_t(n) {
    return n === 120 ? 2 : n === 117 ? 4 : n === 85 ? 8 : 0;
  }
  function twt(n) {
    return 48 <= n && n <= 57 ? n - 48 : -1;
  }
  function vz(n) {
    return n === 48 ? "\0" : n === 97 ? "\x07" : n === 98 ? "\b" : n === 116 || n === 9 ? "	" : n === 110 ? `
` : n === 118 ? "\v" : n === 102 ? "\f" : n === 114 ? "\r" : n === 101 ? "\x1B" : n === 32 ? " " : n === 34 ? '"' : n === 47 ? "/" : n === 92 ? "\\" : n === 78 ? "\x85" : n === 95 ? "\xA0" : n === 76 ? "\u2028" : n === 80 ? "\u2029" : "";
  }
  function ewt(n) {
    return n <= 65535 ? String.fromCharCode(n) : String.fromCharCode((n - 65536 >> 10) + 55296, (n - 65536 & 1023) + 56320);
  }
  var kY = new Array(256), DY = new Array(256);
  for (var tf = 0; tf < 256; tf++) kY[tf] = vz(tf) ? 1 : 0, DY[tf] = vz(tf);
  function nwt(n, t) {
    this.input = n, this.filename = t.filename || null, this.schema = t.schema || BE, this.onWarning = t.onWarning || null, this.legacy = t.legacy || false, this.json = t.json || false, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = n.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function EY(n, t) {
    var e = {
      name: n.filename,
      buffer: n.input.slice(0, -1),
      position: n.position,
      line: n.line,
      column: n.position - n.lineStart
    };
    return e.snippet = s_t(e), new ci(t, e);
  }
  function jt(n, t) {
    throw EY(n, t);
  }
  function Mb(n, t) {
    n.onWarning && n.onWarning.call(null, EY(n, t));
  }
  var mz = {
    YAML: function(t, e, r) {
      var i, a, s;
      t.version !== null && jt(t, "duplication of %YAML directive"), r.length !== 1 && jt(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && jt(t, "ill-formed argument of the YAML directive"), a = parseInt(i[1], 10), s = parseInt(i[2], 10), a !== 1 && jt(t, "unacceptable YAML version of the document"), t.version = r[0], t.checkLineBreaks = s < 2, s !== 1 && s !== 2 && Mb(t, "unsupported YAML version of the document");
    },
    TAG: function(t, e, r) {
      var i, a;
      r.length !== 2 && jt(t, "TAG directive accepts exactly two arguments"), i = r[0], a = r[1], IY.test(i) || jt(t, "ill-formed tag handle (first argument) of the TAG directive"), Ql.call(t.tagMap, i) && jt(t, 'there is a previously declared suffix for "' + i + '" tag handle'), AY.test(a) || jt(t, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        a = decodeURIComponent(a);
      } catch {
        jt(t, "tag prefix is malformed: " + a);
      }
      t.tagMap[i] = a;
    }
  };
  function zl(n, t, e, r) {
    var i, a, s, o;
    if (t < e) {
      if (o = n.input.slice(t, e), r) for (i = 0, a = o.length; i < a; i += 1) s = o.charCodeAt(i), s === 9 || 32 <= s && s <= 1114111 || jt(n, "expected valid JSON character");
      else j_t.test(o) && jt(n, "the stream contains non-printable characters");
      n.result += o;
    }
  }
  function yz(n, t, e, r) {
    var i, a, s, o;
    for (nr.isObject(e) || jt(n, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(e), s = 0, o = i.length; s < o; s += 1) a = i[s], Ql.call(t, a) || (t[a] = e[a], r[a] = true);
  }
  function Af(n, t, e, r, i, a, s, o, l) {
    var u, c;
    if (Array.isArray(i)) for (i = Array.prototype.slice.call(i), u = 0, c = i.length; u < c; u += 1) Array.isArray(i[u]) && jt(n, "nested arrays are not supported inside keys"), typeof i == "object" && gz(i[u]) === "[object Object]" && (i[u] = "[object Object]");
    if (typeof i == "object" && gz(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), r === "tag:yaml.org,2002:merge") if (Array.isArray(a)) for (u = 0, c = a.length; u < c; u += 1) yz(n, t, a[u], e);
    else yz(n, t, a, e);
    else !n.json && !Ql.call(e, i) && Ql.call(t, i) && (n.line = s || n.line, n.lineStart = o || n.lineStart, n.position = l || n.position, jt(n, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: a
    }) : t[i] = a, delete e[i];
    return t;
  }
  function zE(n) {
    var t;
    t = n.input.charCodeAt(n.position), t === 10 ? n.position++ : t === 13 ? (n.position++, n.input.charCodeAt(n.position) === 10 && n.position++) : jt(n, "a line break is expected"), n.line += 1, n.lineStart = n.position, n.firstTabInLine = -1;
  }
  function Gn(n, t, e) {
    for (var r = 0, i = n.input.charCodeAt(n.position); i !== 0; ) {
      for (; Fc(i); ) i === 9 && n.firstTabInLine === -1 && (n.firstTabInLine = n.position), i = n.input.charCodeAt(++n.position);
      if (t && i === 35) do
        i = n.input.charCodeAt(++n.position);
      while (i !== 10 && i !== 13 && i !== 0);
      if (Xs(i)) for (zE(n), i = n.input.charCodeAt(n.position), r++, n.lineIndent = 0; i === 32; ) n.lineIndent++, i = n.input.charCodeAt(++n.position);
      else break;
    }
    return e !== -1 && r !== 0 && n.lineIndent < e && Mb(n, "deficient indentation"), r;
  }
  function e_(n) {
    var t = n.position, e;
    return e = n.input.charCodeAt(t), !!((e === 45 || e === 46) && e === n.input.charCodeAt(t + 1) && e === n.input.charCodeAt(t + 2) && (t += 3, e = n.input.charCodeAt(t), e === 0 || Ri(e)));
  }
  function VE(n, t) {
    t === 1 ? n.result += " " : t > 1 && (n.result += nr.repeat(`
`, t - 1));
  }
  function rwt(n, t, e) {
    var r, i, a, s, o, l, u, c, h = n.kind, f = n.result, d;
    if (d = n.input.charCodeAt(n.position), Ri(d) || If(d) || d === 35 || d === 38 || d === 42 || d === 33 || d === 124 || d === 62 || d === 39 || d === 34 || d === 37 || d === 64 || d === 96 || (d === 63 || d === 45) && (i = n.input.charCodeAt(n.position + 1), Ri(i) || e && If(i))) return false;
    for (n.kind = "scalar", n.result = "", a = s = n.position, o = false; d !== 0; ) {
      if (d === 58) {
        if (i = n.input.charCodeAt(n.position + 1), Ri(i) || e && If(i)) break;
      } else if (d === 35) {
        if (r = n.input.charCodeAt(n.position - 1), Ri(r)) break;
      } else {
        if (n.position === n.lineStart && e_(n) || e && If(d)) break;
        if (Xs(d)) if (l = n.line, u = n.lineStart, c = n.lineIndent, Gn(n, false, -1), n.lineIndent >= t) {
          o = true, d = n.input.charCodeAt(n.position);
          continue;
        } else {
          n.position = s, n.line = l, n.lineStart = u, n.lineIndent = c;
          break;
        }
      }
      o && (zl(n, a, s, false), VE(n, n.line - l), a = s = n.position, o = false), Fc(d) || (s = n.position + 1), d = n.input.charCodeAt(++n.position);
    }
    return zl(n, a, s, false), n.result ? true : (n.kind = h, n.result = f, false);
  }
  function iwt(n, t) {
    var e, r, i;
    if (e = n.input.charCodeAt(n.position), e !== 39) return false;
    for (n.kind = "scalar", n.result = "", n.position++, r = i = n.position; (e = n.input.charCodeAt(n.position)) !== 0; ) if (e === 39) if (zl(n, r, n.position, true), e = n.input.charCodeAt(++n.position), e === 39) r = n.position, n.position++, i = n.position;
    else return true;
    else Xs(e) ? (zl(n, r, i, true), VE(n, Gn(n, false, t)), r = i = n.position) : n.position === n.lineStart && e_(n) ? jt(n, "unexpected end of the document within a single quoted scalar") : (n.position++, i = n.position);
    jt(n, "unexpected end of the stream within a single quoted scalar");
  }
  function awt(n, t) {
    var e, r, i, a, s, o;
    if (o = n.input.charCodeAt(n.position), o !== 34) return false;
    for (n.kind = "scalar", n.result = "", n.position++, e = r = n.position; (o = n.input.charCodeAt(n.position)) !== 0; ) {
      if (o === 34) return zl(n, e, n.position, true), n.position++, true;
      if (o === 92) {
        if (zl(n, e, n.position, true), o = n.input.charCodeAt(++n.position), Xs(o)) Gn(n, false, t);
        else if (o < 256 && kY[o]) n.result += DY[o], n.position++;
        else if ((s = Q_t(o)) > 0) {
          for (i = s, a = 0; i > 0; i--) o = n.input.charCodeAt(++n.position), (s = J_t(o)) >= 0 ? a = (a << 4) + s : jt(n, "expected hexadecimal character");
          n.result += ewt(a), n.position++;
        } else jt(n, "unknown escape sequence");
        e = r = n.position;
      } else Xs(o) ? (zl(n, e, r, true), VE(n, Gn(n, false, t)), e = r = n.position) : n.position === n.lineStart && e_(n) ? jt(n, "unexpected end of the document within a double quoted scalar") : (n.position++, r = n.position);
    }
    jt(n, "unexpected end of the stream within a double quoted scalar");
  }
  function swt(n, t) {
    var e = true, r, i, a, s = n.tag, o, l = n.anchor, u, c, h, f, d, p = /* @__PURE__ */ Object.create(null), g, v, m, y;
    if (y = n.input.charCodeAt(n.position), y === 91) c = 93, d = false, o = [];
    else if (y === 123) c = 125, d = true, o = {};
    else return false;
    for (n.anchor !== null && (n.anchorMap[n.anchor] = o), y = n.input.charCodeAt(++n.position); y !== 0; ) {
      if (Gn(n, true, t), y = n.input.charCodeAt(n.position), y === c) return n.position++, n.tag = s, n.anchor = l, n.kind = d ? "mapping" : "sequence", n.result = o, true;
      e ? y === 44 && jt(n, "expected the node content, but found ','") : jt(n, "missed comma between flow collection entries"), v = g = m = null, h = f = false, y === 63 && (u = n.input.charCodeAt(n.position + 1), Ri(u) && (h = f = true, n.position++, Gn(n, true, t))), r = n.line, i = n.lineStart, a = n.position, Zf(n, t, Db, false, true), v = n.tag, g = n.result, Gn(n, true, t), y = n.input.charCodeAt(n.position), (f || n.line === r) && y === 58 && (h = true, y = n.input.charCodeAt(++n.position), Gn(n, true, t), Zf(n, t, Db, false, true), m = n.result), d ? Af(n, o, p, v, g, m, r, i, a) : h ? o.push(Af(n, null, p, v, g, m, r, i, a)) : o.push(g), Gn(n, true, t), y = n.input.charCodeAt(n.position), y === 44 ? (e = true, y = n.input.charCodeAt(++n.position)) : e = false;
    }
    jt(n, "unexpected end of the stream within a flow collection");
  }
  function owt(n, t) {
    var e, r, i = hT, a = false, s = false, o = t, l = 0, u = false, c, h;
    if (h = n.input.charCodeAt(n.position), h === 124) r = false;
    else if (h === 62) r = true;
    else return false;
    for (n.kind = "scalar", n.result = ""; h !== 0; ) if (h = n.input.charCodeAt(++n.position), h === 43 || h === 45) hT === i ? i = h === 43 ? pz : q_t : jt(n, "repeat of a chomping mode identifier");
    else if ((c = twt(h)) >= 0) c === 0 ? jt(n, "bad explicit indentation width of a block scalar; it cannot be less than one") : s ? jt(n, "repeat of an indentation width identifier") : (o = t + c - 1, s = true);
    else break;
    if (Fc(h)) {
      do
        h = n.input.charCodeAt(++n.position);
      while (Fc(h));
      if (h === 35) do
        h = n.input.charCodeAt(++n.position);
      while (!Xs(h) && h !== 0);
    }
    for (; h !== 0; ) {
      for (zE(n), n.lineIndent = 0, h = n.input.charCodeAt(n.position); (!s || n.lineIndent < o) && h === 32; ) n.lineIndent++, h = n.input.charCodeAt(++n.position);
      if (!s && n.lineIndent > o && (o = n.lineIndent), Xs(h)) {
        l++;
        continue;
      }
      if (n.lineIndent < o) {
        i === pz ? n.result += nr.repeat(`
`, a ? 1 + l : l) : i === hT && a && (n.result += `
`);
        break;
      }
      for (r ? Fc(h) ? (u = true, n.result += nr.repeat(`
`, a ? 1 + l : l)) : u ? (u = false, n.result += nr.repeat(`
`, l + 1)) : l === 0 ? a && (n.result += " ") : n.result += nr.repeat(`
`, l) : n.result += nr.repeat(`
`, a ? 1 + l : l), a = true, s = true, l = 0, e = n.position; !Xs(h) && h !== 0; ) h = n.input.charCodeAt(++n.position);
      zl(n, e, n.position, false);
    }
    return true;
  }
  function xz(n, t) {
    var e, r = n.tag, i = n.anchor, a = [], s, o = false, l;
    if (n.firstTabInLine !== -1) return false;
    for (n.anchor !== null && (n.anchorMap[n.anchor] = a), l = n.input.charCodeAt(n.position); l !== 0 && (n.firstTabInLine !== -1 && (n.position = n.firstTabInLine, jt(n, "tab characters must not be used in indentation")), !(l !== 45 || (s = n.input.charCodeAt(n.position + 1), !Ri(s)))); ) {
      if (o = true, n.position++, Gn(n, true, -1) && n.lineIndent <= t) {
        a.push(null), l = n.input.charCodeAt(n.position);
        continue;
      }
      if (e = n.line, Zf(n, t, TY, false, true), a.push(n.result), Gn(n, true, -1), l = n.input.charCodeAt(n.position), (n.line === e || n.lineIndent > t) && l !== 0) jt(n, "bad indentation of a sequence entry");
      else if (n.lineIndent < t) break;
    }
    return o ? (n.tag = r, n.anchor = i, n.kind = "sequence", n.result = a, true) : false;
  }
  function lwt(n, t, e) {
    var r, i, a, s, o, l, u = n.tag, c = n.anchor, h = {}, f = /* @__PURE__ */ Object.create(null), d = null, p = null, g = null, v = false, m = false, y;
    if (n.firstTabInLine !== -1) return false;
    for (n.anchor !== null && (n.anchorMap[n.anchor] = h), y = n.input.charCodeAt(n.position); y !== 0; ) {
      if (!v && n.firstTabInLine !== -1 && (n.position = n.firstTabInLine, jt(n, "tab characters must not be used in indentation")), r = n.input.charCodeAt(n.position + 1), a = n.line, (y === 63 || y === 58) && Ri(r)) y === 63 ? (v && (Af(n, h, f, d, p, null, s, o, l), d = p = g = null), m = true, v = true, i = true) : v ? (v = false, i = true) : jt(n, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), n.position += 1, y = r;
      else {
        if (s = n.line, o = n.lineStart, l = n.position, !Zf(n, e, CY, false, true)) break;
        if (n.line === a) {
          for (y = n.input.charCodeAt(n.position); Fc(y); ) y = n.input.charCodeAt(++n.position);
          if (y === 58) y = n.input.charCodeAt(++n.position), Ri(y) || jt(n, "a whitespace character is expected after the key-value separator within a block mapping"), v && (Af(n, h, f, d, p, null, s, o, l), d = p = g = null), m = true, v = false, i = false, d = n.tag, p = n.result;
          else if (m) jt(n, "can not read an implicit mapping pair; a colon is missed");
          else return n.tag = u, n.anchor = c, true;
        } else if (m) jt(n, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else return n.tag = u, n.anchor = c, true;
      }
      if ((n.line === a || n.lineIndent > t) && (v && (s = n.line, o = n.lineStart, l = n.position), Zf(n, t, Eb, true, i) && (v ? p = n.result : g = n.result), v || (Af(n, h, f, d, p, g, s, o, l), d = p = g = null), Gn(n, true, -1), y = n.input.charCodeAt(n.position)), (n.line === a || n.lineIndent > t) && y !== 0) jt(n, "bad indentation of a mapping entry");
      else if (n.lineIndent < t) break;
    }
    return v && Af(n, h, f, d, p, null, s, o, l), m && (n.tag = u, n.anchor = c, n.kind = "mapping", n.result = h), m;
  }
  function uwt(n) {
    var t, e = false, r = false, i, a, s;
    if (s = n.input.charCodeAt(n.position), s !== 33) return false;
    if (n.tag !== null && jt(n, "duplication of a tag property"), s = n.input.charCodeAt(++n.position), s === 60 ? (e = true, s = n.input.charCodeAt(++n.position)) : s === 33 ? (r = true, i = "!!", s = n.input.charCodeAt(++n.position)) : i = "!", t = n.position, e) {
      do
        s = n.input.charCodeAt(++n.position);
      while (s !== 0 && s !== 62);
      n.position < n.length ? (a = n.input.slice(t, n.position), s = n.input.charCodeAt(++n.position)) : jt(n, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; s !== 0 && !Ri(s); ) s === 33 && (r ? jt(n, "tag suffix cannot contain exclamation marks") : (i = n.input.slice(t - 1, n.position + 1), IY.test(i) || jt(n, "named tag handle cannot contain such characters"), r = true, t = n.position + 1)), s = n.input.charCodeAt(++n.position);
      a = n.input.slice(t, n.position), Z_t.test(a) && jt(n, "tag suffix cannot contain flow indicator characters");
    }
    a && !AY.test(a) && jt(n, "tag name cannot contain such characters: " + a);
    try {
      a = decodeURIComponent(a);
    } catch {
      jt(n, "tag name is malformed: " + a);
    }
    return e ? n.tag = a : Ql.call(n.tagMap, i) ? n.tag = n.tagMap[i] + a : i === "!" ? n.tag = "!" + a : i === "!!" ? n.tag = "tag:yaml.org,2002:" + a : jt(n, 'undeclared tag handle "' + i + '"'), true;
  }
  function cwt(n) {
    var t, e;
    if (e = n.input.charCodeAt(n.position), e !== 38) return false;
    for (n.anchor !== null && jt(n, "duplication of an anchor property"), e = n.input.charCodeAt(++n.position), t = n.position; e !== 0 && !Ri(e) && !If(e); ) e = n.input.charCodeAt(++n.position);
    return n.position === t && jt(n, "name of an anchor node must contain at least one character"), n.anchor = n.input.slice(t, n.position), true;
  }
  function hwt(n) {
    var t, e, r;
    if (r = n.input.charCodeAt(n.position), r !== 42) return false;
    for (r = n.input.charCodeAt(++n.position), t = n.position; r !== 0 && !Ri(r) && !If(r); ) r = n.input.charCodeAt(++n.position);
    return n.position === t && jt(n, "name of an alias node must contain at least one character"), e = n.input.slice(t, n.position), Ql.call(n.anchorMap, e) || jt(n, 'unidentified alias "' + e + '"'), n.result = n.anchorMap[e], Gn(n, true, -1), true;
  }
  function Zf(n, t, e, r, i) {
    var a, s, o, l = 1, u = false, c = false, h, f, d, p, g, v;
    if (n.listener !== null && n.listener("open", n), n.tag = null, n.anchor = null, n.kind = null, n.result = null, a = s = o = Eb === e || TY === e, r && Gn(n, true, -1) && (u = true, n.lineIndent > t ? l = 1 : n.lineIndent === t ? l = 0 : n.lineIndent < t && (l = -1)), l === 1) for (; uwt(n) || cwt(n); ) Gn(n, true, -1) ? (u = true, o = a, n.lineIndent > t ? l = 1 : n.lineIndent === t ? l = 0 : n.lineIndent < t && (l = -1)) : o = false;
    if (o && (o = u || i), (l === 1 || Eb === e) && (Db === e || CY === e ? g = t : g = t + 1, v = n.position - n.lineStart, l === 1 ? o && (xz(n, v) || lwt(n, v, g)) || swt(n, g) ? c = true : (s && owt(n, g) || iwt(n, g) || awt(n, g) ? c = true : hwt(n) ? (c = true, (n.tag !== null || n.anchor !== null) && jt(n, "alias node should not have any properties")) : rwt(n, g, Db === e) && (c = true, n.tag === null && (n.tag = "?")), n.anchor !== null && (n.anchorMap[n.anchor] = n.result)) : l === 0 && (c = o && xz(n, v))), n.tag === null) n.anchor !== null && (n.anchorMap[n.anchor] = n.result);
    else if (n.tag === "?") {
      for (n.result !== null && n.kind !== "scalar" && jt(n, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + n.kind + '"'), h = 0, f = n.implicitTypes.length; h < f; h += 1) if (p = n.implicitTypes[h], p.resolve(n.result)) {
        n.result = p.construct(n.result), n.tag = p.tag, n.anchor !== null && (n.anchorMap[n.anchor] = n.result);
        break;
      }
    } else if (n.tag !== "!") {
      if (Ql.call(n.typeMap[n.kind || "fallback"], n.tag)) p = n.typeMap[n.kind || "fallback"][n.tag];
      else for (p = null, d = n.typeMap.multi[n.kind || "fallback"], h = 0, f = d.length; h < f; h += 1) if (n.tag.slice(0, d[h].tag.length) === d[h].tag) {
        p = d[h];
        break;
      }
      p || jt(n, "unknown tag !<" + n.tag + ">"), n.result !== null && p.kind !== n.kind && jt(n, "unacceptable node kind for !<" + n.tag + '> tag; it should be "' + p.kind + '", not "' + n.kind + '"'), p.resolve(n.result, n.tag) ? (n.result = p.construct(n.result, n.tag), n.anchor !== null && (n.anchorMap[n.anchor] = n.result)) : jt(n, "cannot resolve a node with !<" + n.tag + "> explicit tag");
    }
    return n.listener !== null && n.listener("close", n), n.tag !== null || n.anchor !== null || c;
  }
  function fwt(n) {
    var t = n.position, e, r, i, a = false, s;
    for (n.version = null, n.checkLineBreaks = n.legacy, n.tagMap = /* @__PURE__ */ Object.create(null), n.anchorMap = /* @__PURE__ */ Object.create(null); (s = n.input.charCodeAt(n.position)) !== 0 && (Gn(n, true, -1), s = n.input.charCodeAt(n.position), !(n.lineIndent > 0 || s !== 37)); ) {
      for (a = true, s = n.input.charCodeAt(++n.position), e = n.position; s !== 0 && !Ri(s); ) s = n.input.charCodeAt(++n.position);
      for (r = n.input.slice(e, n.position), i = [], r.length < 1 && jt(n, "directive name must not be less than one character in length"); s !== 0; ) {
        for (; Fc(s); ) s = n.input.charCodeAt(++n.position);
        if (s === 35) {
          do
            s = n.input.charCodeAt(++n.position);
          while (s !== 0 && !Xs(s));
          break;
        }
        if (Xs(s)) break;
        for (e = n.position; s !== 0 && !Ri(s); ) s = n.input.charCodeAt(++n.position);
        i.push(n.input.slice(e, n.position));
      }
      s !== 0 && zE(n), Ql.call(mz, r) ? mz[r](n, r, i) : Mb(n, 'unknown document directive "' + r + '"');
    }
    if (Gn(n, true, -1), n.lineIndent === 0 && n.input.charCodeAt(n.position) === 45 && n.input.charCodeAt(n.position + 1) === 45 && n.input.charCodeAt(n.position + 2) === 45 ? (n.position += 3, Gn(n, true, -1)) : a && jt(n, "directives end mark is expected"), Zf(n, n.lineIndent - 1, Eb, false, true), Gn(n, true, -1), n.checkLineBreaks && K_t.test(n.input.slice(t, n.position)) && Mb(n, "non-ASCII line breaks are interpreted as content"), n.documents.push(n.result), n.position === n.lineStart && e_(n)) {
      n.input.charCodeAt(n.position) === 46 && (n.position += 3, Gn(n, true, -1));
      return;
    }
    if (n.position < n.length - 1) jt(n, "end of the stream or a document separator is expected");
    else return;
  }
  function MY(n, t) {
    n = String(n), t = t || {}, n.length !== 0 && (n.charCodeAt(n.length - 1) !== 10 && n.charCodeAt(n.length - 1) !== 13 && (n += `
`), n.charCodeAt(0) === 65279 && (n = n.slice(1)));
    var e = new nwt(n, t), r = n.indexOf("\0");
    for (r !== -1 && (e.position = r, jt(e, "null byte is not allowed in input")), e.input += "\0"; e.input.charCodeAt(e.position) === 32; ) e.lineIndent += 1, e.position += 1;
    for (; e.position < e.length - 1; ) fwt(e);
    return e.documents;
  }
  function dwt(n, t, e) {
    t !== null && typeof t == "object" && typeof e > "u" && (e = t, t = null);
    var r = MY(n, e);
    if (typeof t != "function") return r;
    for (var i = 0, a = r.length; i < a; i += 1) t(r[i]);
  }
  function pwt(n, t) {
    var e = MY(n, t);
    if (e.length !== 0) {
      if (e.length === 1) return e[0];
      throw new ci("expected a single document in the stream, but found more");
    }
  }
  var gwt = dwt, vwt = pwt, RY = {
    loadAll: gwt,
    load: vwt
  }, NY = Object.prototype.toString, LY = Object.prototype.hasOwnProperty, GE = 65279, mwt = 9, sv = 10, ywt = 13, xwt = 32, bwt = 33, _wt = 34, l2 = 35, wwt = 37, Swt = 38, Cwt = 39, Twt = 42, PY = 44, Iwt = 45, Rb = 58, Awt = 61, kwt = 62, Dwt = 63, Ewt = 64, $Y = 91, OY = 93, Mwt = 96, FY = 123, Rwt = 124, BY = 125, Qr = {};
  Qr[0] = "\\0";
  Qr[7] = "\\a";
  Qr[8] = "\\b";
  Qr[9] = "\\t";
  Qr[10] = "\\n";
  Qr[11] = "\\v";
  Qr[12] = "\\f";
  Qr[13] = "\\r";
  Qr[27] = "\\e";
  Qr[34] = '\\"';
  Qr[92] = "\\\\";
  Qr[133] = "\\N";
  Qr[160] = "\\_";
  Qr[8232] = "\\L";
  Qr[8233] = "\\P";
  var Nwt = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], Lwt = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function Pwt(n, t) {
    var e, r, i, a, s, o, l;
    if (t === null) return {};
    for (e = {}, r = Object.keys(t), i = 0, a = r.length; i < a; i += 1) s = r[i], o = String(t[s]), s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)), l = n.compiledTypeMap.fallback[s], l && LY.call(l.styleAliases, o) && (o = l.styleAliases[o]), e[s] = o;
    return e;
  }
  function $wt(n) {
    var t, e, r;
    if (t = n.toString(16).toUpperCase(), n <= 255) e = "x", r = 2;
    else if (n <= 65535) e = "u", r = 4;
    else if (n <= 4294967295) e = "U", r = 8;
    else throw new ci("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + e + nr.repeat("0", r - t.length) + t;
  }
  var Owt = 1, ov = 2;
  function Fwt(n) {
    this.schema = n.schema || BE, this.indent = Math.max(1, n.indent || 2), this.noArrayIndent = n.noArrayIndent || false, this.skipInvalid = n.skipInvalid || false, this.flowLevel = nr.isNothing(n.flowLevel) ? -1 : n.flowLevel, this.styleMap = Pwt(this.schema, n.styles || null), this.sortKeys = n.sortKeys || false, this.lineWidth = n.lineWidth || 80, this.noRefs = n.noRefs || false, this.noCompatMode = n.noCompatMode || false, this.condenseFlow = n.condenseFlow || false, this.quotingType = n.quotingType === '"' ? ov : Owt, this.forceQuotes = n.forceQuotes || false, this.replacer = typeof n.replacer == "function" ? n.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function bz(n, t) {
    for (var e = nr.repeat(" ", t), r = 0, i = -1, a = "", s, o = n.length; r < o; ) i = n.indexOf(`
`, r), i === -1 ? (s = n.slice(r), r = o) : (s = n.slice(r, i + 1), r = i + 1), s.length && s !== `
` && (a += e), a += s;
    return a;
  }
  function u2(n, t) {
    return `
` + nr.repeat(" ", n.indent * t);
  }
  function Bwt(n, t) {
    var e, r, i;
    for (e = 0, r = n.implicitTypes.length; e < r; e += 1) if (i = n.implicitTypes[e], i.resolve(t)) return true;
    return false;
  }
  function Nb(n) {
    return n === xwt || n === mwt;
  }
  function lv(n) {
    return 32 <= n && n <= 126 || 161 <= n && n <= 55295 && n !== 8232 && n !== 8233 || 57344 <= n && n <= 65533 && n !== GE || 65536 <= n && n <= 1114111;
  }
  function _z(n) {
    return lv(n) && n !== GE && n !== ywt && n !== sv;
  }
  function wz(n, t, e) {
    var r = _z(n), i = r && !Nb(n);
    return (e ? r : r && n !== PY && n !== $Y && n !== OY && n !== FY && n !== BY) && n !== l2 && !(t === Rb && !i) || _z(t) && !Nb(t) && n === l2 || t === Rb && i;
  }
  function zwt(n) {
    return lv(n) && n !== GE && !Nb(n) && n !== Iwt && n !== Dwt && n !== Rb && n !== PY && n !== $Y && n !== OY && n !== FY && n !== BY && n !== l2 && n !== Swt && n !== Twt && n !== bwt && n !== Rwt && n !== Awt && n !== kwt && n !== Cwt && n !== _wt && n !== wwt && n !== Ewt && n !== Mwt;
  }
  function Vwt(n) {
    return !Nb(n) && n !== Rb;
  }
  function jp(n, t) {
    var e = n.charCodeAt(t), r;
    return e >= 55296 && e <= 56319 && t + 1 < n.length && (r = n.charCodeAt(t + 1), r >= 56320 && r <= 57343) ? (e - 55296) * 1024 + r - 56320 + 65536 : e;
  }
  function zY(n) {
    var t = /^\n* /;
    return t.test(n);
  }
  var VY = 1, c2 = 2, GY = 3, WY = 4, pf = 5;
  function Gwt(n, t, e, r, i, a, s, o) {
    var l, u = 0, c = null, h = false, f = false, d = r !== -1, p = -1, g = zwt(jp(n, 0)) && Vwt(jp(n, n.length - 1));
    if (t || s) for (l = 0; l < n.length; u >= 65536 ? l += 2 : l++) {
      if (u = jp(n, l), !lv(u)) return pf;
      g = g && wz(u, c, o), c = u;
    }
    else {
      for (l = 0; l < n.length; u >= 65536 ? l += 2 : l++) {
        if (u = jp(n, l), u === sv) h = true, d && (f = f || l - p - 1 > r && n[p + 1] !== " ", p = l);
        else if (!lv(u)) return pf;
        g = g && wz(u, c, o), c = u;
      }
      f = f || d && l - p - 1 > r && n[p + 1] !== " ";
    }
    return !h && !f ? g && !s && !i(n) ? VY : a === ov ? pf : c2 : e > 9 && zY(n) ? pf : s ? a === ov ? pf : c2 : f ? WY : GY;
  }
  function Wwt(n, t, e, r, i) {
    n.dump = function() {
      if (t.length === 0) return n.quotingType === ov ? '""' : "''";
      if (!n.noCompatMode && (Nwt.indexOf(t) !== -1 || Lwt.test(t))) return n.quotingType === ov ? '"' + t + '"' : "'" + t + "'";
      var a = n.indent * Math.max(1, e), s = n.lineWidth === -1 ? -1 : Math.max(Math.min(n.lineWidth, 40), n.lineWidth - a), o = r || n.flowLevel > -1 && e >= n.flowLevel;
      function l(u) {
        return Bwt(n, u);
      }
      switch (Gwt(t, o, n.indent, s, l, n.quotingType, n.forceQuotes && !r, i)) {
        case VY:
          return t;
        case c2:
          return "'" + t.replace(/'/g, "''") + "'";
        case GY:
          return "|" + Sz(t, n.indent) + Cz(bz(t, a));
        case WY:
          return ">" + Sz(t, n.indent) + Cz(bz(Uwt(t, s), a));
        case pf:
          return '"' + Hwt(t) + '"';
        default:
          throw new ci("impossible error: invalid scalar style");
      }
    }();
  }
  function Sz(n, t) {
    var e = zY(n) ? String(t) : "", r = n[n.length - 1] === `
`, i = r && (n[n.length - 2] === `
` || n === `
`), a = i ? "+" : r ? "" : "-";
    return e + a + `
`;
  }
  function Cz(n) {
    return n[n.length - 1] === `
` ? n.slice(0, -1) : n;
  }
  function Uwt(n, t) {
    for (var e = /(\n+)([^\n]*)/g, r = function() {
      var u = n.indexOf(`
`);
      return u = u !== -1 ? u : n.length, e.lastIndex = u, Tz(n.slice(0, u), t);
    }(), i = n[0] === `
` || n[0] === " ", a, s; s = e.exec(n); ) {
      var o = s[1], l = s[2];
      a = l[0] === " ", r += o + (!i && !a && l !== "" ? `
` : "") + Tz(l, t), i = a;
    }
    return r;
  }
  function Tz(n, t) {
    if (n === "" || n[0] === " ") return n;
    for (var e = / [^ ]/g, r, i = 0, a, s = 0, o = 0, l = ""; r = e.exec(n); ) o = r.index, o - i > t && (a = s > i ? s : o, l += `
` + n.slice(i, a), i = a + 1), s = o;
    return l += `
`, n.length - i > t && s > i ? l += n.slice(i, s) + `
` + n.slice(s + 1) : l += n.slice(i), l.slice(1);
  }
  function Hwt(n) {
    for (var t = "", e = 0, r, i = 0; i < n.length; e >= 65536 ? i += 2 : i++) e = jp(n, i), r = Qr[e], !r && lv(e) ? (t += n[i], e >= 65536 && (t += n[i + 1])) : t += r || $wt(e);
    return t;
  }
  function Xwt(n, t, e) {
    var r = "", i = n.tag, a, s, o;
    for (a = 0, s = e.length; a < s; a += 1) o = e[a], n.replacer && (o = n.replacer.call(e, String(a), o)), (Yo(n, t, o, false, false) || typeof o > "u" && Yo(n, t, null, false, false)) && (r !== "" && (r += "," + (n.condenseFlow ? "" : " ")), r += n.dump);
    n.tag = i, n.dump = "[" + r + "]";
  }
  function Iz(n, t, e, r) {
    var i = "", a = n.tag, s, o, l;
    for (s = 0, o = e.length; s < o; s += 1) l = e[s], n.replacer && (l = n.replacer.call(e, String(s), l)), (Yo(n, t + 1, l, true, true, false, true) || typeof l > "u" && Yo(n, t + 1, null, true, true, false, true)) && ((!r || i !== "") && (i += u2(n, t)), n.dump && sv === n.dump.charCodeAt(0) ? i += "-" : i += "- ", i += n.dump);
    n.tag = a, n.dump = i || "[]";
  }
  function Ywt(n, t, e) {
    var r = "", i = n.tag, a = Object.keys(e), s, o, l, u, c;
    for (s = 0, o = a.length; s < o; s += 1) c = "", r !== "" && (c += ", "), n.condenseFlow && (c += '"'), l = a[s], u = e[l], n.replacer && (u = n.replacer.call(e, l, u)), Yo(n, t, l, false, false) && (n.dump.length > 1024 && (c += "? "), c += n.dump + (n.condenseFlow ? '"' : "") + ":" + (n.condenseFlow ? "" : " "), Yo(n, t, u, false, false) && (c += n.dump, r += c));
    n.tag = i, n.dump = "{" + r + "}";
  }
  function qwt(n, t, e, r) {
    var i = "", a = n.tag, s = Object.keys(e), o, l, u, c, h, f;
    if (n.sortKeys === true) s.sort();
    else if (typeof n.sortKeys == "function") s.sort(n.sortKeys);
    else if (n.sortKeys) throw new ci("sortKeys must be a boolean or a function");
    for (o = 0, l = s.length; o < l; o += 1) f = "", (!r || i !== "") && (f += u2(n, t)), u = s[o], c = e[u], n.replacer && (c = n.replacer.call(e, u, c)), Yo(n, t + 1, u, true, true, true) && (h = n.tag !== null && n.tag !== "?" || n.dump && n.dump.length > 1024, h && (n.dump && sv === n.dump.charCodeAt(0) ? f += "?" : f += "? "), f += n.dump, h && (f += u2(n, t)), Yo(n, t + 1, c, true, h) && (n.dump && sv === n.dump.charCodeAt(0) ? f += ":" : f += ": ", f += n.dump, i += f));
    n.tag = a, n.dump = i || "{}";
  }
  function Az(n, t, e) {
    var r, i, a, s, o, l;
    for (i = e ? n.explicitTypes : n.implicitTypes, a = 0, s = i.length; a < s; a += 1) if (o = i[a], (o.instanceOf || o.predicate) && (!o.instanceOf || typeof t == "object" && t instanceof o.instanceOf) && (!o.predicate || o.predicate(t))) {
      if (e ? o.multi && o.representName ? n.tag = o.representName(t) : n.tag = o.tag : n.tag = "?", o.represent) {
        if (l = n.styleMap[o.tag] || o.defaultStyle, NY.call(o.represent) === "[object Function]") r = o.represent(t, l);
        else if (LY.call(o.represent, l)) r = o.represent[l](t, l);
        else throw new ci("!<" + o.tag + '> tag resolver accepts not "' + l + '" style');
        n.dump = r;
      }
      return true;
    }
    return false;
  }
  function Yo(n, t, e, r, i, a, s) {
    n.tag = null, n.dump = e, Az(n, e, false) || Az(n, e, true);
    var o = NY.call(n.dump), l = r, u;
    r && (r = n.flowLevel < 0 || n.flowLevel > t);
    var c = o === "[object Object]" || o === "[object Array]", h, f;
    if (c && (h = n.duplicates.indexOf(e), f = h !== -1), (n.tag !== null && n.tag !== "?" || f || n.indent !== 2 && t > 0) && (i = false), f && n.usedDuplicates[h]) n.dump = "*ref_" + h;
    else {
      if (c && f && !n.usedDuplicates[h] && (n.usedDuplicates[h] = true), o === "[object Object]") r && Object.keys(n.dump).length !== 0 ? (qwt(n, t, n.dump, i), f && (n.dump = "&ref_" + h + n.dump)) : (Ywt(n, t, n.dump), f && (n.dump = "&ref_" + h + " " + n.dump));
      else if (o === "[object Array]") r && n.dump.length !== 0 ? (n.noArrayIndent && !s && t > 0 ? Iz(n, t - 1, n.dump, i) : Iz(n, t, n.dump, i), f && (n.dump = "&ref_" + h + n.dump)) : (Xwt(n, t, n.dump), f && (n.dump = "&ref_" + h + " " + n.dump));
      else if (o === "[object String]") n.tag !== "?" && Wwt(n, n.dump, t, a, l);
      else {
        if (o === "[object Undefined]") return false;
        if (n.skipInvalid) return false;
        throw new ci("unacceptable kind of an object to dump " + o);
      }
      n.tag !== null && n.tag !== "?" && (u = encodeURI(n.tag[0] === "!" ? n.tag.slice(1) : n.tag).replace(/!/g, "%21"), n.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", n.dump = u + " " + n.dump);
    }
    return true;
  }
  function jwt(n, t) {
    var e = [], r = [], i, a;
    for (h2(n, e, r), i = 0, a = r.length; i < a; i += 1) t.duplicates.push(e[r[i]]);
    t.usedDuplicates = new Array(a);
  }
  function h2(n, t, e) {
    var r, i, a;
    if (n !== null && typeof n == "object") if (i = t.indexOf(n), i !== -1) e.indexOf(i) === -1 && e.push(i);
    else if (t.push(n), Array.isArray(n)) for (i = 0, a = n.length; i < a; i += 1) h2(n[i], t, e);
    else for (r = Object.keys(n), i = 0, a = r.length; i < a; i += 1) h2(n[r[i]], t, e);
  }
  function Kwt(n, t) {
    t = t || {};
    var e = new Fwt(t);
    e.noRefs || jwt(n, e);
    var r = n;
    return e.replacer && (r = e.replacer.call({
      "": r
    }, "", r)), Yo(e, 0, r, true, true) ? e.dump + `
` : "";
  }
  var Zwt = Kwt, Jwt = {
    dump: Zwt
  };
  function WE(n, t) {
    return function() {
      throw new Error("Function yaml." + n + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
    };
  }
  var Qwt = Ir, tSt = aY, eSt = uY, nSt = pY, rSt = gY, iSt = BE, aSt = RY.load, sSt = RY.loadAll, oSt = Jwt.dump, lSt = ci, uSt = {
    binary: bY,
    float: dY,
    map: lY,
    null: cY,
    pairs: wY,
    set: SY,
    timestamp: yY,
    bool: hY,
    int: fY,
    merge: xY,
    omap: _Y,
    seq: oY,
    str: sY
  }, cSt = WE("safeLoad", "load"), hSt = WE("safeLoadAll", "loadAll"), fSt = WE("safeDump", "dump"), dSt = {
    Type: Qwt,
    Schema: tSt,
    FAILSAFE_SCHEMA: eSt,
    JSON_SCHEMA: nSt,
    CORE_SCHEMA: rSt,
    DEFAULT_SCHEMA: iSt,
    load: aSt,
    loadAll: sSt,
    dump: oSt,
    YAMLException: lSt,
    types: uSt,
    safeLoad: cSt,
    safeLoadAll: hSt,
    safeDump: fSt
  };
  const pSt = 1e-7, gSt = 1e-4;
  class UY {
    constructor(t, e) {
      this.backend = t, this.dataMover = e, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
    }
    get(t) {
      return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);
    }
    set(t, e) {
      this.dataIdsCount++, this.data.set(t, e);
    }
    has(t) {
      return this.data.has(t);
    }
    delete(t) {
      return this.dataIdsCount--, this.data.delete(t);
    }
    numDataIds() {
      return this.dataIdsCount;
    }
  }
  class UE {
    refCount(t) {
      return Ti("refCount");
    }
    incRef(t) {
      return Ti("incRef");
    }
    timerAvailable() {
      return true;
    }
    time(t) {
      return Ti("time");
    }
    read(t) {
      return Ti("read");
    }
    readSync(t) {
      return Ti("readSync");
    }
    readToGPU(t, e) {
      return Ti("readToGPU");
    }
    numDataIds() {
      return Ti("numDataIds");
    }
    disposeData(t, e) {
      return Ti("disposeData");
    }
    write(t, e, r) {
      return Ti("write");
    }
    move(t, e, r, i, a) {
      return Ti("move");
    }
    createTensorFromGPUData(t, e, r) {
      return Ti("createTensorFromGPUData");
    }
    memory() {
      return Ti("memory");
    }
    floatPrecision() {
      return Ti("floatPrecision");
    }
    epsilon() {
      return this.floatPrecision() === 32 ? pSt : gSt;
    }
    dispose() {
      return Ti("dispose");
    }
  }
  function Ti(n) {
    throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
  }
  function vSt(n) {
    let t = n.length, e = 0;
    for (; t > 0; ) e = Math.random() * t | 0, t--, gf(n, t, e);
  }
  function Kc(n, t, e) {
    return Math.max(n, Math.min(t, e));
  }
  function HE(n) {
    return n % 2 === 0 ? n : n + 1;
  }
  function gf(n, t, e) {
    const r = n[t];
    n[t] = n[e], n[e] = r;
  }
  function mSt(n) {
    let t = 0;
    for (let e = 0; e < n.length; e++) t += n[e];
    return t;
  }
  function B(n, t) {
    if (!n) throw new Error(typeof t == "string" ? t : t());
  }
  function XE(n, t, e = "") {
    B(Xe(n, t), () => e + ` Shapes ${n} and ${t} must match`);
  }
  function HY(n) {
    B(n != null, () => "The input to the tensor constructor must be a non-null value.");
  }
  function lt(n) {
    if (n.length === 0) return 1;
    let t = n[0];
    for (let e = 1; e < n.length; e++) t *= n[e];
    return t;
  }
  function Xe(n, t) {
    if (n === t) return true;
    if (n == null || t == null || n.length !== t.length) return false;
    for (let e = 0; e < n.length; e++) if (n[e] !== t[e]) return false;
    return true;
  }
  function Jf(n) {
    return n % 1 === 0;
  }
  function f2(n) {
    const t = Math.ceil(Math.sqrt(n));
    return [
      t,
      Math.ceil(n / t)
    ];
  }
  function Lf(n, t) {
    return t <= n.length ? n : n + " ".repeat(t - n.length);
  }
  function kz(n, t = (i) => 0, e, r) {
    return new Promise((i, a) => {
      let s = 0;
      const o = () => {
        if (n()) {
          i();
          return;
        }
        s++;
        const l = t(s);
        if (e != null && s >= e) {
          a();
          return;
        }
        r != null ? r(o, l) : setTimeout(o, l);
      };
      o();
    });
  }
  function XY(n, t) {
    let e = 1, r = -1;
    for (let a = 0; a < n.length; ++a) if (n[a] >= 0) e *= n[a];
    else if (n[a] === -1) {
      if (r !== -1) throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);
      r = a;
    } else if (n[a] < 0) throw Error(`Shapes can not be < 0. Found ${n[a]} at dim ${a}`);
    if (r === -1) {
      if (t > 0 && t !== e) throw Error(`Size(${t}) must match the product of shape ${n}`);
      return n;
    }
    if (e === 0) throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);
    if (t % e !== 0) throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);
    const i = n.slice();
    return i[r] = t / e, i;
  }
  function Se(n, t) {
    const e = t.length;
    return n = n == null ? t.map((r, i) => i) : [].concat(n), B(n.every((r) => r >= -e && r < e), () => `All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`), B(n.every((r) => Jf(r)), () => `All values in axis param must be integers but got axis ${n}`), n.map((r) => r < 0 ? e + r : r);
  }
  function lu(n, t) {
    const e = [], r = [], i = t != null && Array.isArray(t) && t.length === 0, a = t == null || i ? null : Se(t, n).sort();
    let s = 0;
    for (let o = 0; o < n.length; ++o) {
      if (a != null) {
        if (a[s] === o && n[o] !== 1) throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);
        (a[s] == null || a[s] > o) && n[o] === 1 && (e.push(n[o]), r.push(o)), a[s] <= o && s++;
      }
      n[o] !== 1 && (e.push(n[o]), r.push(o));
    }
    return {
      newShape: e,
      keptDims: r
    };
  }
  function Dr(n, t) {
    return kn(n, t);
  }
  function kn(n, t) {
    let e = null;
    if (n == null || n === "float32") e = new Float32Array(t);
    else if (n === "int32") e = new Int32Array(t);
    else if (n === "bool") e = new Uint8Array(t);
    else if (n === "string") e = new Array(t);
    else throw new Error(`Unknown data type ${n}`);
    return e;
  }
  function ySt(n, t) {
    for (let e = 0; e < n.length; e++) {
      const r = n[e];
      if (isNaN(r) || !isFinite(r)) throw Error(`A tensor of type ${t} being uploaded contains ${r}.`);
    }
  }
  function xSt(n) {
    return n === "bool" || n === "complex64" || n === "float32" || n === "int32" || n === "string";
  }
  function YY(n, t) {
    return !(t === "complex64" || t === "float32" && n !== "complex64" || t === "int32" && n !== "float32" && n !== "complex64" || t === "bool" && n === "bool");
  }
  function Lb(n) {
    if (n === "float32" || n === "int32") return 4;
    if (n === "complex64") return 8;
    if (n === "bool") return 1;
    throw new Error(`Unknown dtype ${n}`);
  }
  function bSt(n) {
    if (n == null) return 0;
    let t = 0;
    return n.forEach((e) => t += e.length), t;
  }
  function Jv(n) {
    return typeof n == "string" || n instanceof String;
  }
  function _St(n) {
    return typeof n == "boolean";
  }
  function d2(n) {
    return typeof n == "number";
  }
  function Rd(n) {
    return Array.isArray(n) ? Rd(n[0]) : n instanceof Float32Array ? "float32" : n instanceof Int32Array || n instanceof Uint8Array || n instanceof Uint8ClampedArray ? "int32" : d2(n) ? "float32" : Jv(n) ? "string" : _St(n) ? "bool" : "float32";
  }
  function p2(n) {
    return !!(n && n.constructor && n.call && n.apply);
  }
  function g2(n, t) {
    for (let e = t; e < n; ++e) if (n % e === 0) return e;
    return n;
  }
  function Yt(n) {
    const t = n.length;
    if (t < 2) return [];
    const e = new Array(t - 1);
    e[t - 2] = n[t - 1];
    for (let r = t - 3; r >= 0; --r) e[r] = e[r + 1] * n[r + 1];
    return e;
  }
  function qY(n, t, e, r = false) {
    const i = new Array();
    if (t.length === 1) {
      const a = t[0] * (r ? 2 : 1);
      for (let s = 0; s < a; s++) i[s] = e[n + s];
    } else {
      const a = t[0], s = t.slice(1), o = s.reduce((l, u) => l * u) * (r ? 2 : 1);
      for (let l = 0; l < a; l++) i[l] = qY(n + l * o, s, e, r);
    }
    return i;
  }
  function ns(n, t, e = false) {
    if (n.length === 0) return t[0];
    const r = n.reduce((i, a) => i * a) * (e ? 2 : 1);
    if (r === 0) return [];
    if (r !== t.length) throw new Error(`[${n}] does not match the input size ${t.length}${e ? " for a complex tensor" : ""}.`);
    return qY(0, n, t, e);
  }
  function wSt(n, t) {
    if (Array.isArray(n)) return n;
    if (t === "float32") return n instanceof Float32Array ? n : new Float32Array(n);
    if (t === "int32") return n instanceof Int32Array ? n : new Int32Array(n);
    if (t === "bool" || t === "string") return Uint8Array.from(new Int32Array(n));
    throw new Error(`Unknown dtype ${t}`);
  }
  function YE(n, t) {
    const e = Er(n, t);
    for (let r = 0; r < e.length; r++) e[r] = 1;
    return e;
  }
  function Er(n, t) {
    if (t == null || t === "float32" || t === "complex64") return new Float32Array(n);
    if (t === "int32") return new Int32Array(n);
    if (t === "bool") return new Uint8Array(n);
    throw new Error(`Unknown data type ${t}`);
  }
  function jY(n, t) {
    const e = n.reduce((r, i) => r * i, 1);
    if (t == null || t === "float32") return ns(n, new Float32Array(e));
    if (t === "int32") return ns(n, new Int32Array(e));
    if (t === "bool") return ns(n, new Uint8Array(e));
    throw new Error(`Unknown data type ${t}`);
  }
  function nl(n) {
    n.forEach((t) => {
      B(Number.isInteger(t) && t >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${n}].`);
    });
  }
  function Ys(n, t, e) {
    if (t === 0) return 0;
    if (t === 1) return n[0];
    let r = n[n.length - 1];
    for (let i = 0; i < n.length - 1; ++i) r += e[i] * n[i];
    return r;
  }
  function Nd(n, t, e) {
    if (t === 0) return [];
    if (t === 1) return [
      n
    ];
    const r = new Array(t);
    for (let i = 0; i < r.length - 1; ++i) r[i] = Math.floor(n / e[i]), n -= r[i] * e[i];
    return r[r.length - 1] = n, r;
  }
  function qE(n) {
    return n && n.then && typeof n.then == "function";
  }
  const Dz = "tfjsflags";
  class SSt {
    constructor(t) {
      this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = CSt, this.populateURLFlags();
    }
    setPlatform(t, e) {
      this.platform != null && (nt().getBool("IS_TEST") || nt().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)), this.platformName = t, this.platform = e;
    }
    registerFlag(t, e, r) {
      if (this.flagRegistry[t] = {
        evaluationFn: e,
        setHook: r
      }, this.urlFlags[t] != null) {
        const i = this.urlFlags[t];
        nt().getBool("IS_TEST") || nt().getBool("PROD") || console.warn(`Setting feature override from URL ${t}: ${i}.`), this.set(t, i);
      }
    }
    async getAsync(t) {
      return t in this.flags ? this.flags[t] : (this.flags[t] = await this.evaluateFlag(t), this.flags[t]);
    }
    get(t) {
      if (t in this.flags) return this.flags[t];
      const e = this.evaluateFlag(t);
      if (qE(e)) throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);
      return this.flags[t] = e, this.flags[t];
    }
    getNumber(t) {
      return this.get(t);
    }
    getBool(t) {
      return this.get(t);
    }
    getString(t) {
      return this.get(t);
    }
    getFlags() {
      return this.flags;
    }
    get features() {
      return this.flags;
    }
    set(t, e) {
      if (this.flagRegistry[t] == null) throw new Error(`Cannot set flag ${t} as it has not been registered.`);
      this.flags[t] = e, this.flagRegistry[t].setHook != null && this.flagRegistry[t].setHook(e);
    }
    evaluateFlag(t) {
      if (this.flagRegistry[t] == null) throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);
      return this.flagRegistry[t].evaluationFn();
    }
    setFlags(t) {
      this.flags = Object.assign({}, t);
    }
    reset() {
      this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
    }
    populateURLFlags() {
      if (typeof this.global > "u" || typeof this.global.location > "u" || typeof this.global.location.search > "u") return;
      const t = this.getQueryParams(this.global.location.search);
      Dz in t && t[Dz].split(",").forEach((r) => {
        const [i, a] = r.split(":");
        this.urlFlags[i] = ISt(i, a);
      });
    }
  }
  function CSt(n) {
    const t = {};
    return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (e, ...r) => (TSt(t, r[0], r[1]), r.join("="))), t;
  }
  function TSt(n, t, e) {
    n[decodeURIComponent(t)] = decodeURIComponent(e || "");
  }
  function ISt(n, t) {
    const e = t.toLowerCase();
    return e === "true" || e === "false" ? e === "true" : `${+e}` === e ? +e : t;
  }
  function nt() {
    return KY;
  }
  let KY = null;
  function ASt(n) {
    KY = n;
  }
  let fT;
  function ZY() {
    if (fT == null) {
      let n;
      if (typeof window < "u") n = window;
      else if (typeof global < "u") n = global;
      else if (typeof process < "u") n = process;
      else if (typeof self < "u") n = self;
      else throw new Error("Could not find a global object");
      fT = n;
    }
    return fT;
  }
  function kSt() {
    const n = ZY();
    return n._tfGlobals == null && (n._tfGlobals = /* @__PURE__ */ new Map()), n._tfGlobals;
  }
  function jE(n, t) {
    const e = kSt();
    if (e.has(n)) return e.get(n);
    {
      const r = t();
      return e.set(n, r), e.get(n);
    }
  }
  const n_ = "Abs", Qv = "Acos", tm = "Acosh", Ld = "Add", KE = "AddN", ZE = "All", JE = "Any", r_ = "ArgMax", i_ = "ArgMin", em = "Asin", nm = "Asinh", rm = "Atan", im = "Atanh", am = "Atan2", a_ = "AvgPool", QE = "AvgPoolGrad", s_ = "AvgPool3D", tM = "AvgPool3DGrad", o_ = "BatchMatMul", l_ = "BatchToSpaceND", eM = "Bincount", nM = "BitwiseAnd", DSt = "BroadcastTo", JY = "BroadcastArgs", sm = "Cast", om = "Ceil", lm = "ClipByValue", rM = "Complex", u_ = "ComplexAbs", c_ = "Concat", h_ = "Conv2D", iM = "Conv2DBackpropFilter", f_ = "Conv2DBackpropInput", d_ = "Conv3D", aM = "Conv3DBackpropFilterV2", sM = "Conv3DBackpropInputV2", um = "Cos", cm = "Cosh", oM = "Cumprod", p_ = "Cumsum", lM = "CropAndResize", uM = "DenseBincount", cM = "DepthToSpace", g_ = "DepthwiseConv2dNative", hM = "DepthwiseConv2dNativeBackpropFilter", fM = "DepthwiseConv2dNativeBackpropInput", QY = "Diag", v_ = "Dilation2D", v2 = "Dilation2DBackpropInput", m2 = "Dilation2DBackpropFilter", ESt = "Draw", hm = "RealDiv", dM = "Einsum", fm = "Elu", pM = "EluGrad", dm = "Erf", m_ = "Equal", pm = "Exp", y_ = "ExpandDims", gm = "Expm1", gM = "FFT", vM = "Fill", mM = "FlipLeftRight", vm = "Floor", mm = "FloorDiv", x_ = "FusedBatchNorm", b_ = "GatherV2", tq = "GatherNd", __ = "Greater", ym = "GreaterEqual", xm = "Identity", yM = "IFFT", xM = "Imag", bm = "IsFinite", _m = "IsInf", wm = "IsNan", w_ = "LeakyRelu", S_ = "Less", C_ = "LessEqual", eq = "LinSpace", Sm = "Log", Cm = "Log1p", T_ = "LogicalAnd", I_ = "LogicalNot", A_ = "LogicalOr", MSt = "LogSoftmax", k_ = "LRN", bM = "LRNGrad", D_ = "Max", Tm = "Maximum", E_ = "MaxPool", _M = "MaxPoolGrad", M_ = "MaxPool3D", wM = "MaxPool3DGrad", nq = "MaxPoolWithArgmax", R_ = "Mean", N_ = "Min", Im = "Minimum", L_ = "MirrorPad", Am = "Mod", rq = "Multinomial", km = "Multiply", P_ = "Neg", $_ = "NotEqual", SM = "NonMaxSuppressionV3", CM = "NonMaxSuppressionV4", TM = "NonMaxSuppressionV5", O_ = "OnesLike", F_ = "OneHot", B_ = "Pack", z_ = "PadV2", Dm = "Pow", V_ = "Prelu", G_ = "Prod", iq = "RaggedGather", aq = "RaggedRange", sq = "RaggedTensorToTensor", IM = "Range", AM = "Real", Em = "Reciprocal", Mm = "Relu", W_ = "Reshape", U_ = "ResizeNearestNeighbor", kM = "ResizeNearestNeighborGrad", H_ = "ResizeBilinear", DM = "ResizeBilinearGrad", Rm = "Relu6", X_ = "Reverse", Nm = "Round", Lm = "Rsqrt", oq = "ScatterNd", lq = "TensorScatterUpdate", uq = "SearchSorted", Y_ = "Select", Pm = "Selu", q_ = "Slice", $m = "Sin", Om = "Sinh", Fm = "Sign", Bm = "Sigmoid", zm = "Softplus", Vm = "Sqrt", j_ = "Sum", K_ = "SpaceToBatchND", Z_ = "SplitV", J_ = "Softmax", cq = "SparseFillEmptyRows", hq = "SparseReshape", fq = "SparseSegmentMean", dq = "SparseSegmentSum", pq = "SparseToDense", Gm = "SquaredDifference", EM = "Square", MM = "StaticRegexReplace", RM = "StridedSlice", gq = "StringNGrams", vq = "StringSplit", mq = "StringToHashBucketFast", Wm = "Sub", Um = "Tan", Hm = "Tanh", Xm = "Tile", NM = "TopK", LM = "Transform", Pf = "Transpose", PM = "Unique", Q_ = "Unpack", tw = "UnsortedSegmentSum", ew = "ZerosLike", Ym = "Step", RSt = "FromPixels", $M = "RotateWithOffset", Pb = "_FusedMatMul", $b = "FusedConv2D", yq = "FusedDepthwiseConv2D";
  function Wi(...n) {
    nt().getBool("IS_TEST") || nt().getBool("PROD") || console.warn(...n);
  }
  function NSt(...n) {
    nt().getBool("IS_TEST") || nt().getBool("PROD") || console.log(...n);
  }
  const Ob = jE("kernelRegistry", () => /* @__PURE__ */ new Map()), y2 = jE("gradRegistry", () => /* @__PURE__ */ new Map());
  function Ez(n, t) {
    const e = bq(n, t);
    return Ob.get(e);
  }
  function Mz(n) {
    return y2.get(n);
  }
  function Rz(n) {
    const t = Ob.entries(), e = [];
    for (; ; ) {
      const { done: r, value: i } = t.next();
      if (r) break;
      const [a, s] = i, [o] = a.split("_");
      o === n && e.push(s);
    }
    return e;
  }
  function xq(n) {
    const { kernelName: t, backendName: e } = n, r = bq(t, e);
    Ob.has(r) && Wi(`The kernel '${t}' for backend '${e}' is already registered`), Ob.set(r, n);
  }
  function LSt(n) {
    const { kernelName: t } = n;
    y2.has(t) && nt().getBool("DEBUG") && Wi(`Overriding the gradient for '${t}'`), y2.set(t, n);
  }
  function bq(n, t) {
    return `${t}_${n}`;
  }
  function _q(n) {
    return n instanceof Float32Array || n instanceof Int32Array || n instanceof Uint8Array || n instanceof Uint8ClampedArray;
  }
  function nw(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
  }
  function PSt(n) {
    if (n.__esModule) return n;
    var t = n.default;
    if (typeof t == "function") {
      var e = function r() {
        return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
      };
      e.prototype = t.prototype;
    } else e = {};
    return Object.defineProperty(e, "__esModule", {
      value: true
    }), Object.keys(n).forEach(function(r) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      Object.defineProperty(e, r, i.get ? i : {
        enumerable: true,
        get: function() {
          return n[r];
        }
      });
    }), e;
  }
  var dT, Nz;
  function $St() {
    if (Nz) return dT;
    Nz = 1, dT = t;
    var n = null;
    try {
      n = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch {
    }
    function t(A, C, D) {
      this.low = A | 0, this.high = C | 0, this.unsigned = !!D;
    }
    t.prototype.__isLong__, Object.defineProperty(t.prototype, "__isLong__", {
      value: true
    });
    function e(A) {
      return (A && A.__isLong__) === true;
    }
    t.isLong = e;
    var r = {}, i = {};
    function a(A, C) {
      var D, E, M;
      return C ? (A >>>= 0, (M = 0 <= A && A < 256) && (E = i[A], E) ? E : (D = o(A, (A | 0) < 0 ? -1 : 0, true), M && (i[A] = D), D)) : (A |= 0, (M = -128 <= A && A < 128) && (E = r[A], E) ? E : (D = o(A, A < 0 ? -1 : 0, false), M && (r[A] = D), D));
    }
    t.fromInt = a;
    function s(A, C) {
      if (isNaN(A)) return C ? y : m;
      if (C) {
        if (A < 0) return y;
        if (A >= p) return S;
      } else {
        if (A <= -9223372036854776e3) return I;
        if (A + 1 >= g) return w;
      }
      return A < 0 ? s(-A, C).neg() : o(A % d | 0, A / d | 0, C);
    }
    t.fromNumber = s;
    function o(A, C, D) {
      return new t(A, C, D);
    }
    t.fromBits = o;
    var l = Math.pow;
    function u(A, C, D) {
      if (A.length === 0) throw Error("empty string");
      if (A === "NaN" || A === "Infinity" || A === "+Infinity" || A === "-Infinity") return m;
      if (typeof C == "number" ? (D = C, C = false) : C = !!C, D = D || 10, D < 2 || 36 < D) throw RangeError("radix");
      var E;
      if ((E = A.indexOf("-")) > 0) throw Error("interior hyphen");
      if (E === 0) return u(A.substring(1), C, D).neg();
      for (var M = s(l(D, 8)), L = m, k = 0; k < A.length; k += 8) {
        var N = Math.min(8, A.length - k), R = parseInt(A.substring(k, k + N), D);
        if (N < 8) {
          var $ = s(l(D, N));
          L = L.mul($).add(s(R));
        } else L = L.mul(M), L = L.add(s(R));
      }
      return L.unsigned = C, L;
    }
    t.fromString = u;
    function c(A, C) {
      return typeof A == "number" ? s(A, C) : typeof A == "string" ? u(A, C) : o(A.low, A.high, typeof C == "boolean" ? C : A.unsigned);
    }
    t.fromValue = c;
    var h = 65536, f = 1 << 24, d = h * h, p = d * d, g = p / 2, v = a(f), m = a(0);
    t.ZERO = m;
    var y = a(0, true);
    t.UZERO = y;
    var x = a(1);
    t.ONE = x;
    var b = a(1, true);
    t.UONE = b;
    var _ = a(-1);
    t.NEG_ONE = _;
    var w = o(-1, 2147483647, false);
    t.MAX_VALUE = w;
    var S = o(-1, -1, true);
    t.MAX_UNSIGNED_VALUE = S;
    var I = o(0, -2147483648, false);
    t.MIN_VALUE = I;
    var T = t.prototype;
    return T.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }, T.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * d + (this.low >>> 0) : this.high * d + (this.low >>> 0);
    }, T.toString = function(C) {
      if (C = C || 10, C < 2 || 36 < C) throw RangeError("radix");
      if (this.isZero()) return "0";
      if (this.isNegative()) if (this.eq(I)) {
        var D = s(C), E = this.div(D), M = E.mul(D).sub(this);
        return E.toString(C) + M.toInt().toString(C);
      } else return "-" + this.neg().toString(C);
      for (var L = s(l(C, 6), this.unsigned), k = this, N = ""; ; ) {
        var R = k.div(L), $ = k.sub(R.mul(L)).toInt() >>> 0, O = $.toString(C);
        if (k = R, k.isZero()) return O + N;
        for (; O.length < 6; ) O = "0" + O;
        N = "" + O + N;
      }
    }, T.getHighBits = function() {
      return this.high;
    }, T.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    }, T.getLowBits = function() {
      return this.low;
    }, T.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    }, T.getNumBitsAbs = function() {
      if (this.isNegative()) return this.eq(I) ? 64 : this.neg().getNumBitsAbs();
      for (var C = this.high != 0 ? this.high : this.low, D = 31; D > 0 && !(C & 1 << D); D--) ;
      return this.high != 0 ? D + 33 : D + 1;
    }, T.isZero = function() {
      return this.high === 0 && this.low === 0;
    }, T.eqz = T.isZero, T.isNegative = function() {
      return !this.unsigned && this.high < 0;
    }, T.isPositive = function() {
      return this.unsigned || this.high >= 0;
    }, T.isOdd = function() {
      return (this.low & 1) === 1;
    }, T.isEven = function() {
      return (this.low & 1) === 0;
    }, T.equals = function(C) {
      return e(C) || (C = c(C)), this.unsigned !== C.unsigned && this.high >>> 31 === 1 && C.high >>> 31 === 1 ? false : this.high === C.high && this.low === C.low;
    }, T.eq = T.equals, T.notEquals = function(C) {
      return !this.eq(C);
    }, T.neq = T.notEquals, T.ne = T.notEquals, T.lessThan = function(C) {
      return this.comp(C) < 0;
    }, T.lt = T.lessThan, T.lessThanOrEqual = function(C) {
      return this.comp(C) <= 0;
    }, T.lte = T.lessThanOrEqual, T.le = T.lessThanOrEqual, T.greaterThan = function(C) {
      return this.comp(C) > 0;
    }, T.gt = T.greaterThan, T.greaterThanOrEqual = function(C) {
      return this.comp(C) >= 0;
    }, T.gte = T.greaterThanOrEqual, T.ge = T.greaterThanOrEqual, T.compare = function(C) {
      if (e(C) || (C = c(C)), this.eq(C)) return 0;
      var D = this.isNegative(), E = C.isNegative();
      return D && !E ? -1 : !D && E ? 1 : this.unsigned ? C.high >>> 0 > this.high >>> 0 || C.high === this.high && C.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(C).isNegative() ? -1 : 1;
    }, T.comp = T.compare, T.negate = function() {
      return !this.unsigned && this.eq(I) ? I : this.not().add(x);
    }, T.neg = T.negate, T.add = function(C) {
      e(C) || (C = c(C));
      var D = this.high >>> 16, E = this.high & 65535, M = this.low >>> 16, L = this.low & 65535, k = C.high >>> 16, N = C.high & 65535, R = C.low >>> 16, $ = C.low & 65535, O = 0, F = 0, z = 0, V = 0;
      return V += L + $, z += V >>> 16, V &= 65535, z += M + R, F += z >>> 16, z &= 65535, F += E + N, O += F >>> 16, F &= 65535, O += D + k, O &= 65535, o(z << 16 | V, O << 16 | F, this.unsigned);
    }, T.subtract = function(C) {
      return e(C) || (C = c(C)), this.add(C.neg());
    }, T.sub = T.subtract, T.multiply = function(C) {
      if (this.isZero()) return m;
      if (e(C) || (C = c(C)), n) {
        var D = n.mul(this.low, this.high, C.low, C.high);
        return o(D, n.get_high(), this.unsigned);
      }
      if (C.isZero()) return m;
      if (this.eq(I)) return C.isOdd() ? I : m;
      if (C.eq(I)) return this.isOdd() ? I : m;
      if (this.isNegative()) return C.isNegative() ? this.neg().mul(C.neg()) : this.neg().mul(C).neg();
      if (C.isNegative()) return this.mul(C.neg()).neg();
      if (this.lt(v) && C.lt(v)) return s(this.toNumber() * C.toNumber(), this.unsigned);
      var E = this.high >>> 16, M = this.high & 65535, L = this.low >>> 16, k = this.low & 65535, N = C.high >>> 16, R = C.high & 65535, $ = C.low >>> 16, O = C.low & 65535, F = 0, z = 0, V = 0, U = 0;
      return U += k * O, V += U >>> 16, U &= 65535, V += L * O, z += V >>> 16, V &= 65535, V += k * $, z += V >>> 16, V &= 65535, z += M * O, F += z >>> 16, z &= 65535, z += L * $, F += z >>> 16, z &= 65535, z += k * R, F += z >>> 16, z &= 65535, F += E * O + M * $ + L * R + k * N, F &= 65535, o(V << 16 | U, F << 16 | z, this.unsigned);
    }, T.mul = T.multiply, T.divide = function(C) {
      if (e(C) || (C = c(C)), C.isZero()) throw Error("division by zero");
      if (n) {
        if (!this.unsigned && this.high === -2147483648 && C.low === -1 && C.high === -1) return this;
        var D = (this.unsigned ? n.div_u : n.div_s)(this.low, this.high, C.low, C.high);
        return o(D, n.get_high(), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? y : m;
      var E, M, L;
      if (this.unsigned) {
        if (C.unsigned || (C = C.toUnsigned()), C.gt(this)) return y;
        if (C.gt(this.shru(1))) return b;
        L = y;
      } else {
        if (this.eq(I)) {
          if (C.eq(x) || C.eq(_)) return I;
          if (C.eq(I)) return x;
          var k = this.shr(1);
          return E = k.div(C).shl(1), E.eq(m) ? C.isNegative() ? x : _ : (M = this.sub(C.mul(E)), L = E.add(M.div(C)), L);
        } else if (C.eq(I)) return this.unsigned ? y : m;
        if (this.isNegative()) return C.isNegative() ? this.neg().div(C.neg()) : this.neg().div(C).neg();
        if (C.isNegative()) return this.div(C.neg()).neg();
        L = m;
      }
      for (M = this; M.gte(C); ) {
        E = Math.max(1, Math.floor(M.toNumber() / C.toNumber()));
        for (var N = Math.ceil(Math.log(E) / Math.LN2), R = N <= 48 ? 1 : l(2, N - 48), $ = s(E), O = $.mul(C); O.isNegative() || O.gt(M); ) E -= R, $ = s(E, this.unsigned), O = $.mul(C);
        $.isZero() && ($ = x), L = L.add($), M = M.sub(O);
      }
      return L;
    }, T.div = T.divide, T.modulo = function(C) {
      if (e(C) || (C = c(C)), n) {
        var D = (this.unsigned ? n.rem_u : n.rem_s)(this.low, this.high, C.low, C.high);
        return o(D, n.get_high(), this.unsigned);
      }
      return this.sub(this.div(C).mul(C));
    }, T.mod = T.modulo, T.rem = T.modulo, T.not = function() {
      return o(~this.low, ~this.high, this.unsigned);
    }, T.and = function(C) {
      return e(C) || (C = c(C)), o(this.low & C.low, this.high & C.high, this.unsigned);
    }, T.or = function(C) {
      return e(C) || (C = c(C)), o(this.low | C.low, this.high | C.high, this.unsigned);
    }, T.xor = function(C) {
      return e(C) || (C = c(C)), o(this.low ^ C.low, this.high ^ C.high, this.unsigned);
    }, T.shiftLeft = function(C) {
      return e(C) && (C = C.toInt()), (C &= 63) === 0 ? this : C < 32 ? o(this.low << C, this.high << C | this.low >>> 32 - C, this.unsigned) : o(0, this.low << C - 32, this.unsigned);
    }, T.shl = T.shiftLeft, T.shiftRight = function(C) {
      return e(C) && (C = C.toInt()), (C &= 63) === 0 ? this : C < 32 ? o(this.low >>> C | this.high << 32 - C, this.high >> C, this.unsigned) : o(this.high >> C - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, T.shr = T.shiftRight, T.shiftRightUnsigned = function(C) {
      if (e(C) && (C = C.toInt()), C &= 63, C === 0) return this;
      var D = this.high;
      if (C < 32) {
        var E = this.low;
        return o(E >>> C | D << 32 - C, D >>> C, this.unsigned);
      } else return C === 32 ? o(D, 0, this.unsigned) : o(D >>> C - 32, 0, this.unsigned);
    }, T.shru = T.shiftRightUnsigned, T.shr_u = T.shiftRightUnsigned, T.toSigned = function() {
      return this.unsigned ? o(this.low, this.high, false) : this;
    }, T.toUnsigned = function() {
      return this.unsigned ? this : o(this.low, this.high, true);
    }, T.toBytes = function(C) {
      return C ? this.toBytesLE() : this.toBytesBE();
    }, T.toBytesLE = function() {
      var C = this.high, D = this.low;
      return [
        D & 255,
        D >>> 8 & 255,
        D >>> 16 & 255,
        D >>> 24,
        C & 255,
        C >>> 8 & 255,
        C >>> 16 & 255,
        C >>> 24
      ];
    }, T.toBytesBE = function() {
      var C = this.high, D = this.low;
      return [
        C >>> 24,
        C >>> 16 & 255,
        C >>> 8 & 255,
        C & 255,
        D >>> 24,
        D >>> 16 & 255,
        D >>> 8 & 255,
        D & 255
      ];
    }, t.fromBytes = function(C, D, E) {
      return E ? t.fromBytesLE(C, D) : t.fromBytesBE(C, D);
    }, t.fromBytesLE = function(C, D) {
      return new t(C[0] | C[1] << 8 | C[2] << 16 | C[3] << 24, C[4] | C[5] << 8 | C[6] << 16 | C[7] << 24, D);
    }, t.fromBytesBE = function(C, D) {
      return new t(C[4] << 24 | C[5] << 16 | C[6] << 8 | C[7], C[0] << 24 | C[1] << 16 | C[2] << 8 | C[3], D);
    }, dT;
  }
  var wq = $St();
  const Sq = nw(wq), OSt = Wtt({
    __proto__: null,
    default: Sq
  }, [
    wq
  ]);
  const dc = Sq || OSt;
  function rw(n) {
    return dc.fromString(n, true, 16);
  }
  const Cq = rw("c3a5c85c97cb3127"), ic = rw("b492b66fbe98f273"), Wr = rw("9ae16a3b2f90404f");
  function x2(n) {
    return n.xor(n.shru(47));
  }
  function Tq(n, t, e) {
    const r = n.slice(t, t + e);
    return dc.fromBytes(Array.from(r), true, true);
  }
  function cn(n, t) {
    return Tq(n, t, 8);
  }
  function Lz(n, t) {
    return Tq(n, t, 4);
  }
  function er(n, t) {
    return t === 0 ? n : n.shru(t).or(n.shl(64 - t));
  }
  function Vl(n, t, e = rw("9ddfea08eb382d69")) {
    let r = n.xor(t).mul(e);
    r = r.xor(r.shru(47));
    let i = t.xor(r).mul(e);
    return i = i.xor(i.shru(47)), i = i.mul(e), i;
  }
  function FSt(n, t, e, r, i, a) {
    i = i.add(n), a = er(a.add(i).add(r), 21);
    const s = i;
    return i = i.add(t), i = i.add(e), a = a.add(er(i, 44)), [
      i.add(r),
      a.add(s)
    ];
  }
  function w0(n, t, e, r) {
    return FSt(cn(n, t), cn(n, t + 8), cn(n, t + 16), cn(n, t + 24), e, r);
  }
  function BSt(n, t = n.length) {
    if (t >= 8) {
      const e = Wr.add(t * 2), r = cn(n, 0).add(Wr), i = cn(n, t - 8), a = er(i, 37).mul(e).add(r), s = er(r, 25).add(i).mul(e);
      return Vl(a, s, e);
    }
    if (t >= 4) {
      const e = Wr.add(t * 2), r = Lz(n, 0);
      return Vl(r.shl(3).add(t), Lz(n, t - 4), e);
    }
    if (t > 0) {
      const e = n[0], r = n[t >> 1], i = n[t - 1], a = e + (r << 8), s = t + (i << 2);
      return x2(Wr.mul(a).xor(Cq.mul(s))).mul(Wr);
    }
    return Wr;
  }
  function zSt(n, t = n.length) {
    const e = Wr.add(t * 2), r = cn(n, 0).mul(ic), i = cn(n, 8), a = cn(n, t - 8).mul(e), s = cn(n, t - 16).mul(Wr);
    return Vl(er(r.add(i), 43).add(er(a, 30)).add(s), r.add(er(i.add(Wr), 18)).add(a), e);
  }
  function VSt(n, t = n.length) {
    const e = Wr.add(t * 2), r = cn(n, 0).mul(Wr), i = cn(n, 8), a = cn(n, t - 8).mul(e), s = cn(n, t - 16).mul(Wr), o = er(r.add(i), 43).add(er(a, 30)).add(s), l = Vl(o, r.add(er(i.add(Wr), 18)).add(a), e), u = cn(n, 16).mul(e), c = cn(n, 24), h = o.add(cn(n, t - 32)).mul(e), f = l.add(cn(n, t - 24)).mul(e);
    return Vl(er(u.add(c), 43).add(er(h, 30)).add(f), u.add(er(c.add(r), 18)).add(h), e);
  }
  function GSt(n, t = n.length) {
    const e = dc.fromNumber(81, true);
    if (t <= 32) return t <= 16 ? BSt(n, t) : zSt(n, t);
    if (t <= 64) return VSt(n, t);
    let r = e, i = e.mul(ic).add(113), a = x2(i.mul(Wr).add(113)).mul(Wr), s = [
      dc.UZERO,
      dc.UZERO
    ], o = [
      dc.UZERO,
      dc.UZERO
    ];
    r = r.mul(Wr).add(cn(n, 0));
    let l = 0;
    const u = (t - 1 >> 6) * 64, c = u + (t - 1 & 63) - 63;
    do
      r = er(r.add(i).add(s[0]).add(cn(n, l + 8)), 37).mul(ic), i = er(i.add(s[1]).add(cn(n, l + 48)), 42).mul(ic), r = r.xor(o[1]), i = i.add(s[0]).add(cn(n, l + 40)), a = er(a.add(o[0]), 33).mul(ic), s = w0(n, l, s[1].mul(ic), r.add(o[0])), o = w0(n, l + 32, a.add(o[1]), i.add(cn(n, l + 16))), [a, r] = [
        r,
        a
      ], l += 64;
    while (l !== u);
    const h = ic.add(a.and(255).shl(1));
    return l = c, o[0] = o[0].add(t - 1 & 63), s[0] = s[0].add(o[0]), o[0] = o[0].add(s[0]), r = er(r.add(i).add(s[0]).add(cn(n, l + 8)), 37).mul(h), i = er(i.add(s[1]).add(cn(n, l + 48)), 42).mul(h), r = r.xor(o[1].mul(9)), i = i.add(s[0].mul(9).add(cn(n, l + 40))), a = er(a.add(o[0]), 33).mul(h), s = w0(n, l, s[1].mul(h), r.add(o[0])), o = w0(n, l + 32, a.add(o[1]), i.add(cn(n, l + 16))), [a, r] = [
      r,
      a
    ], Vl(Vl(s[0], o[0], h).add(x2(i).mul(Cq)).add(a), Vl(s[1], o[1], h).add(r), h);
  }
  function uu(n, t) {
    return t === "string" ? Gl(n) : bh([
      n
    ], t);
  }
  function WSt(n, t) {
    return n instanceof Float32Array && t === "float32" || n instanceof Int32Array && t === "int32" || n instanceof Uint8Array && t === "bool";
  }
  function bh(n, t) {
    if (t === "string") throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(n) && (n = Zc(n)), nt().getBool("DEBUG") && ySt(n, t), WSt(n, t)) return n;
    if (t == null || t === "float32" || t === "complex64") return new Float32Array(n);
    if (t === "int32") return new Int32Array(n);
    if (t === "bool") {
      const e = new Uint8Array(n.length);
      for (let r = 0; r < e.length; ++r) Math.round(n[r]) !== 0 && (e[r] = 1);
      return e;
    } else throw new Error(`Unknown data type ${t}`);
  }
  function si() {
    return nt().platform.now();
  }
  function Gl(n, t = "utf-8") {
    return t = t || "utf-8", nt().platform.encode(n, t);
  }
  function tu(n, t = "utf-8") {
    return t = t || "utf-8", nt().platform.decode(n, t);
  }
  function Aa(n) {
    return nt().platform.isTypedArray != null ? nt().platform.isTypedArray(n) : _q(n);
  }
  function Zc(n, t = [], e = false) {
    if (t == null && (t = []), typeof n == "boolean" || typeof n == "number" || typeof n == "string" || qE(n) || n == null || Aa(n) && e) t.push(n);
    else if (Array.isArray(n) || Aa(n)) for (let r = 0; r < n.length; ++r) Zc(n[r], t, e);
    else {
      let r = -1;
      for (const i of Object.keys(n)) /^([1-9]+[0-9]*|0)$/.test(i) && (r = Math.max(r, Number(i)));
      for (let i = 0; i <= r; i++) Zc(n[i], t, e);
    }
    return t;
  }
  class USt {
    constructor(t, e) {
      this.backendTimer = t, this.logger = e, e == null && (this.logger = new XSt());
    }
    profileKernel(t, e, r) {
      let i;
      const a = () => {
        i = r();
      };
      let s;
      const o = si();
      if (this.backendTimer.timerAvailable()) s = this.backendTimer.time(a);
      else {
        a();
        for (const u of i) u.dataSync();
        s = Promise.resolve({
          kernelMs: si() - o
        });
      }
      if (nt().getBool("CHECK_COMPUTATION_FOR_ERRORS")) for (let u = 0; u < i.length; u++) {
        const c = i[u];
        c.data().then((h) => {
          HSt(h, c.dtype, t);
        });
      }
      return {
        kernelName: t,
        outputs: i,
        inputs: e,
        timeMs: s.then((u) => u.kernelMs),
        extraInfo: s.then((u) => u.getExtraProfileInfo != null ? u.getExtraProfileInfo() : "")
      };
    }
    logKernelProfile(t) {
      const { kernelName: e, outputs: r, timeMs: i, inputs: a, extraInfo: s } = t;
      r.forEach((o) => {
        Promise.all([
          o.data(),
          i,
          s
        ]).then((l) => {
          this.logger.logKernelProfile(e, o, l[0], l[1], a, l[2]);
        });
      });
    }
  }
  function HSt(n, t, e) {
    if (t !== "float32") return false;
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      if (isNaN(i) || !isFinite(i)) return console.warn(`Found ${i} in the result of '${e}'`), true;
    }
    return false;
  }
  class XSt {
    logKernelProfile(t, e, r, i, a, s) {
      const o = typeof i == "number" ? Lf(`${i}ms`, 9) : i.error, l = Lf(t, 25), u = e.rank, c = e.size, h = Lf(e.shape.toString(), 14);
      let f = "";
      for (const d in a) {
        const p = a[d];
        if (p != null) {
          const g = p.shape || e.shape, v = g.length;
          f += `${d}: ${v}D ${v > 0 ? g : ""} `;
        }
      }
      console.log(`%c${l}	%c${o}	%c${u}D ${h}	%c${c}	%c${f}	%c${s}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }
  }
  function YSt(n, t, e) {
    const r = {}, i = {};
    for (let l = 0; l < t.length; l++) r[t[l].id] = true;
    for (let l = 0; l < n.length; l++) {
      const u = n[l], c = u.inputs;
      for (const h in c) {
        const f = c[h];
        let d = false;
        for (let p = 0; p < t.length; p++) if (r[f.id]) {
          u.outputs.forEach((g) => r[g.id] = true), d = true, i[u.id] = true;
          break;
        }
        if (d) break;
      }
    }
    const a = {};
    a[e.id] = true;
    const s = {};
    for (let l = n.length - 1; l >= 0; l--) {
      const u = n[l], c = u.inputs;
      for (let h = 0; h < u.outputs.length; h++) if (a[u.outputs[h].id]) {
        for (const f in c) a[c[f].id] = true, s[u.id] = true;
        break;
      }
    }
    const o = [];
    for (let l = 0; l < n.length; l++) {
      const u = n[l];
      if (i[u.id] && s[u.id]) {
        const c = {};
        for (const f in u.inputs) {
          const d = u.inputs[f];
          r[d.id] && (c[f] = d);
        }
        const h = Object.assign({}, u);
        h.inputs = c, h.outputs = u.outputs, o.push(h);
      }
    }
    return o;
  }
  function qSt(n, t, e, r) {
    for (let i = t.length - 1; i >= 0; i--) {
      const a = t[i], s = [];
      if (a.outputs.forEach((l) => {
        const u = n[l.id];
        u != null ? s.push(u) : s.push(null);
      }), a.gradient == null) throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);
      const o = a.gradient(s);
      for (const l in a.inputs) {
        if (!(l in o)) throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);
        const u = e(() => o[l]());
        if (u.dtype !== "float32") throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);
        const c = a.inputs[l];
        if (!Xe(u.shape, c.shape)) throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);
        if (n[c.id] == null) n[c.id] = u;
        else {
          const h = n[c.id];
          n[c.id] = r(h, u), h.dispose();
        }
      }
    }
  }
  const Pz = 20, Ap = 3, pT = 7;
  function jSt(n, t, e, r) {
    const i = Yt(t), a = KSt(n, t, e, i), s = t.length, o = Sx(n, t, e, i, a), l = [
      "Tensor"
    ];
    return r && (l.push(`  dtype: ${e}`), l.push(`  rank: ${s}`), l.push(`  shape: [${t}]`), l.push("  values:")), l.push(o.map((u) => "    " + u).join(`
`)), l.join(`
`);
  }
  function KSt(n, t, e, r) {
    const i = lt(t), a = r[r.length - 1], s = new Array(a).fill(0), o = t.length, l = e === "complex64" ? Zp(n) : n;
    if (o > 1) for (let u = 0; u < i / a; u++) {
      const c = u * a;
      for (let h = 0; h < a; h++) s[h] = Math.max(s[h], Kp(l[c + h], 0, e).length);
    }
    return s;
  }
  function Kp(n, t, e) {
    let r;
    return Array.isArray(n) ? r = `${parseFloat(n[0].toFixed(pT))} + ${parseFloat(n[1].toFixed(pT))}j` : Jv(n) ? r = `'${n}'` : e === "bool" ? r = Iq(n) : r = parseFloat(n.toFixed(pT)).toString(), Lf(r, t);
  }
  function Iq(n) {
    return n === 0 ? "false" : "true";
  }
  function Sx(n, t, e, r, i, a = true) {
    const s = e === "complex64" ? 2 : 1, o = t[0], l = t.length;
    if (l === 0) {
      if (e === "complex64") {
        const g = Zp(n);
        return [
          Kp(g[0], 0, e)
        ];
      }
      return e === "bool" ? [
        Iq(n[0])
      ] : [
        n[0].toString()
      ];
    }
    if (l === 1) {
      if (o > Pz) {
        const v = Ap * s;
        let m = Array.from(n.slice(0, v)), y = Array.from(n.slice((o - Ap) * s, o * s));
        return e === "complex64" && (m = Zp(m), y = Zp(y)), [
          "[" + m.map((x, b) => Kp(x, i[b], e)).join(", ") + ", ..., " + y.map((x, b) => Kp(x, i[o - Ap + b], e)).join(", ") + "]"
        ];
      }
      return [
        "[" + (e === "complex64" ? Zp(n) : Array.from(n)).map((v, m) => Kp(v, i[m], e)).join(", ") + "]"
      ];
    }
    const u = t.slice(1), c = r.slice(1), h = r[0] * s, f = [];
    if (o > Pz) {
      for (let g = 0; g < Ap; g++) {
        const v = g * h, m = v + h;
        f.push(...Sx(n.slice(v, m), u, e, c, i, false));
      }
      f.push("...");
      for (let g = o - Ap; g < o; g++) {
        const v = g * h, m = v + h;
        f.push(...Sx(n.slice(v, m), u, e, c, i, g === o - 1));
      }
    } else for (let g = 0; g < o; g++) {
      const v = g * h, m = v + h;
      f.push(...Sx(n.slice(v, m), u, e, c, i, g === o - 1));
    }
    const d = l === 2 ? "," : "";
    f[0] = "[" + (o > 0 ? f[0] + d : "");
    for (let g = 1; g < f.length - 1; g++) f[g] = " " + f[g] + d;
    let p = `,
`;
    for (let g = 2; g < l; g++) p += `
`;
    return f[f.length - 1] = " " + f[f.length - 1] + "]" + (a ? "" : p), f;
  }
  function Zp(n) {
    const t = [];
    for (let e = 0; e < n.length; e += 2) t.push([
      n[e],
      n[e + 1]
    ]);
    return t;
  }
  class xr {
    constructor(t, e, r) {
      if (this.dtype = e, this.shape = t.slice(), this.size = lt(t), r != null) {
        const i = r.length;
        B(i === this.size, () => `Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`);
      }
      if (e === "complex64") throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
      this.values = r || kn(e, this.size), this.strides = Yt(t);
    }
    set(t, ...e) {
      e.length === 0 && (e = [
        0
      ]), B(e.length === this.rank, () => `The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);
      const r = this.locToIndex(e);
      this.values[r] = t;
    }
    get(...t) {
      t.length === 0 && (t = [
        0
      ]);
      let e = 0;
      for (const i of t) {
        if (i < 0 || i >= this.shape[e]) {
          const a = `Requested out of range element at ${t}.   Buffer shape=${this.shape}`;
          throw new Error(a);
        }
        e++;
      }
      let r = t[t.length - 1];
      for (let i = 0; i < t.length - 1; ++i) r += this.strides[i] * t[i];
      return this.values[r];
    }
    locToIndex(t) {
      if (this.rank === 0) return 0;
      if (this.rank === 1) return t[0];
      let e = t[t.length - 1];
      for (let r = 0; r < t.length - 1; ++r) e += this.strides[r] * t[r];
      return e;
    }
    indexToLoc(t) {
      if (this.rank === 0) return [];
      if (this.rank === 1) return [
        t
      ];
      const e = new Array(this.shape.length);
      for (let r = 0; r < e.length - 1; ++r) e[r] = Math.floor(t / this.strides[r]), t -= e[r] * this.strides[r];
      return e[e.length - 1] = t, e;
    }
    get rank() {
      return this.shape.length;
    }
    toTensor() {
      return Xa().makeTensor(this.values, this.shape, this.dtype);
    }
  }
  let Xa = null, vf = null;
  function ZSt(n) {
    Xa = n;
  }
  function JSt(n) {
    vf = n;
  }
  class Vn {
    constructor(t, e, r, i) {
      this.kept = false, this.isDisposedInternal = false, this.shape = t.slice(), this.dtype = e || "float32", this.size = lt(t), this.strides = Yt(t), this.dataId = r, this.id = i, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    get rank() {
      return this.shape.length;
    }
    async buffer() {
      const t = await this.data();
      return vf.buffer(this.shape, this.dtype, t);
    }
    bufferSync() {
      return vf.buffer(this.shape, this.dtype, this.dataSync());
    }
    async array() {
      const t = await this.data();
      return ns(this.shape, t, this.dtype === "complex64");
    }
    arraySync() {
      return ns(this.shape, this.dataSync(), this.dtype === "complex64");
    }
    async data() {
      this.throwIfDisposed();
      const t = Xa().read(this.dataId);
      if (this.dtype === "string") {
        const e = await t;
        try {
          return e.map((r) => tu(r));
        } catch {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return t;
    }
    dataToGPU(t) {
      return this.throwIfDisposed(), Xa().readToGPU(this.dataId, t);
    }
    dataSync() {
      this.throwIfDisposed();
      const t = Xa().readSync(this.dataId);
      if (this.dtype === "string") try {
        return t.map((e) => tu(e));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
      return t;
    }
    async bytes() {
      this.throwIfDisposed();
      const t = await Xa().read(this.dataId);
      return this.dtype === "string" ? t : new Uint8Array(t.buffer);
    }
    dispose() {
      this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), Xa().disposeTensor(this), this.isDisposedInternal = true);
    }
    get isDisposed() {
      return this.isDisposedInternal;
    }
    throwIfDisposed() {
      if (this.isDisposed) throw new Error("Tensor is disposed.");
    }
    print(t = false) {
      return vf.print(this, t);
    }
    clone() {
      return this.throwIfDisposed(), vf.clone(this);
    }
    toString(t = false) {
      const e = this.dataSync();
      return jSt(e, this.shape, this.dtype, t);
    }
    cast(t) {
      return this.throwIfDisposed(), vf.cast(this, t);
    }
    variable(t = true, e, r) {
      return this.throwIfDisposed(), Xa().makeVariable(this, t, e, r);
    }
  }
  Object.defineProperty(Vn, Symbol.hasInstance, {
    value: (n) => !!n && n.data != null && n.dataSync != null && n.throwIfDisposed != null
  });
  function ot() {
    return jE("Tensor", () => Vn);
  }
  ot();
  class Fb extends Vn {
    constructor(t, e, r, i) {
      super(t.shape, t.dtype, t.dataId, i), this.trainable = e, this.name = r;
    }
    assign(t) {
      if (t.dtype !== this.dtype) throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);
      if (!Xe(t.shape, this.shape)) throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);
      Xa().disposeTensor(this), this.dataId = t.dataId, Xa().incRef(this, null);
    }
    dispose() {
      Xa().disposeVariable(this), this.isDisposedInternal = true;
    }
  }
  Object.defineProperty(Fb, Symbol.hasInstance, {
    value: (n) => n instanceof Vn && n.assign != null && n.assign instanceof Function
  });
  var $z;
  (function(n) {
    n.R0 = "R0", n.R1 = "R1", n.R2 = "R2", n.R3 = "R3", n.R4 = "R4", n.R5 = "R5", n.R6 = "R6";
  })($z || ($z = {}));
  var b2;
  (function(n) {
    n.float32 = "float32", n.int32 = "int32", n.bool = "int32", n.complex64 = "complex64";
  })(b2 || (b2 = {}));
  var _2;
  (function(n) {
    n.float32 = "float32", n.int32 = "int32", n.bool = "bool", n.complex64 = "complex64";
  })(_2 || (_2 = {}));
  var w2;
  (function(n) {
    n.float32 = "float32", n.int32 = "float32", n.bool = "float32", n.complex64 = "complex64";
  })(w2 || (w2 = {}));
  var S2;
  (function(n) {
    n.float32 = "complex64", n.int32 = "complex64", n.bool = "complex64", n.complex64 = "complex64";
  })(S2 || (S2 = {}));
  const QSt = {
    float32: w2,
    int32: b2,
    bool: _2,
    complex64: S2
  };
  function $i(n, t) {
    if (n === "string" || t === "string") {
      if (n === "string" && t === "string") return "string";
      throw new Error(`Can not upcast ${n} with ${t}`);
    }
    return QSt[n][t];
  }
  function OM(n) {
    return $i(n, "int32");
  }
  function Aq(n) {
    return n != null && typeof n == "object" && "texture" in n && n.texture instanceof WebGLTexture;
  }
  function kq(n) {
    return typeof GPUBuffer < "u" && n != null && typeof n == "object" && "buffer" in n && n.buffer instanceof GPUBuffer;
  }
  function Mn(n, t) {
    if (n.dtype === t.dtype) return [
      n,
      t
    ];
    const e = $i(n.dtype, t.dtype);
    return [
      n.cast(e),
      t.cast(e)
    ];
  }
  function Dq(n) {
    const t = [];
    return Eq(n, t, /* @__PURE__ */ new Set()), t;
  }
  function Eq(n, t, e) {
    if (n == null) return;
    if (n instanceof Vn) {
      t.push(n);
      return;
    }
    if (!tCt(n)) return;
    const r = n;
    for (const i in r) {
      const a = r[i];
      e.has(a) || (e.add(a), Eq(a, t, e));
    }
  }
  function tCt(n) {
    return Array.isArray(n) || typeof n == "object";
  }
  function gT(n) {
    return n.kernelName != null;
  }
  class Oz {
    constructor() {
      this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = {
        newBytes: 0,
        newTensors: 0,
        peakBytes: 0,
        kernels: [],
        result: null,
        get kernelNames() {
          return Array.from(new Set(this.kernels.map((t) => t.name)));
        }
      };
    }
    dispose() {
      for (const t in this.registeredVariables) this.registeredVariables[t].dispose();
    }
  }
  class Qf {
    constructor(t) {
      this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Oz();
    }
    async ready() {
      if (this.pendingBackendInit != null) return this.pendingBackendInit.then(() => {
      });
      if (this.backendInstance != null) return;
      const t = this.getSortedBackends();
      for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (await this.initializeBackend(r).success) {
          await this.setBackend(r);
          return;
        }
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    get backend() {
      if (this.pendingBackendInit != null) throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      if (this.backendInstance == null) {
        const { name: t, asyncInit: e } = this.initializeBackendsAndReturnBest();
        if (e) throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        this.setBackend(t);
      }
      return this.backendInstance;
    }
    backendNames() {
      return Object.keys(this.registryFactory);
    }
    findBackend(t) {
      if (!(t in this.registry)) if (t in this.registryFactory) {
        const { asyncInit: e } = this.initializeBackend(t);
        if (e) return null;
      } else return null;
      return this.registry[t];
    }
    findBackendFactory(t) {
      return t in this.registryFactory ? this.registryFactory[t].factory : null;
    }
    registerBackend(t, e, r = 1) {
      return t in this.registryFactory ? (Wi(`${t} backend was already registered. Reusing existing backend factory.`), false) : (this.registryFactory[t] = {
        factory: e,
        priority: r
      }, true);
    }
    async setBackend(t) {
      if (this.registryFactory[t] == null) throw new Error(`Backend name '${t}' not found in registry`);
      if (this.backendName = t, this.registry[t] == null) {
        this.backendInstance = null;
        const { success: e, asyncInit: r } = this.initializeBackend(t);
        if (!(r ? await e : e)) return false;
      }
      return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new USt(this.backendInstance), true;
    }
    setupRegisteredKernels() {
      Rz(this.backendName).forEach((e) => {
        e.setupFunc != null && e.setupFunc(this.backendInstance);
      });
    }
    disposeRegisteredKernels(t) {
      Rz(t).forEach((r) => {
        r.disposeFunc != null && r.disposeFunc(this.registry[t]);
      });
    }
    initializeBackend(t) {
      const e = this.registryFactory[t];
      if (e == null) throw new Error(`Cannot initialize backend ${t}, no registration found.`);
      try {
        const r = e.factory();
        if (r && !(r instanceof UE) && typeof r.then == "function") {
          const i = ++this.pendingBackendInitId, a = r.then((s) => i < this.pendingBackendInitId ? false : (this.registry[t] = s, this.pendingBackendInit = null, true)).catch((s) => (i < this.pendingBackendInitId || (this.pendingBackendInit = null, Wi(`Initialization of backend ${t} failed`), Wi(s.stack || s.message)), false));
          return this.pendingBackendInit = a, {
            success: a,
            asyncInit: true
          };
        } else return this.registry[t] = r, {
          success: true,
          asyncInit: false
        };
      } catch (r) {
        return Wi(`Initialization of backend ${t} failed`), Wi(r.stack || r.message), {
          success: false,
          asyncInit: false
        };
      }
    }
    removeBackend(t) {
      if (!(t in this.registryFactory)) throw new Error(`${t} backend not found in registry`);
      this.backendName === t && this.pendingBackendInit != null && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
    }
    getSortedBackends() {
      if (Object.keys(this.registryFactory).length === 0) throw new Error("No backend found in registry.");
      return Object.keys(this.registryFactory).sort((t, e) => this.registryFactory[e].priority - this.registryFactory[t].priority);
    }
    initializeBackendsAndReturnBest() {
      const t = this.getSortedBackends();
      for (let e = 0; e < t.length; e++) {
        const r = t[e], { success: i, asyncInit: a } = this.initializeBackend(r);
        if (a || i) return {
          name: r,
          asyncInit: a
        };
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    moveData(t, e) {
      const r = this.state.tensorInfo.get(e), i = r.backend, a = this.readSync(e), s = i.refCount(e);
      i.disposeData(e, true), r.backend = t, t.move(e, a, r.shape, r.dtype, s), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
    tidy(t, e) {
      let r = null;
      if (e == null) {
        if (typeof t != "function") throw new Error("Please provide a function to tidy()");
        e = t;
      } else {
        if (typeof t != "string" && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        if (typeof e != "function") throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        r = t;
      }
      let i;
      return this.scopedRun(() => this.startScope(r), () => this.endScope(i), () => (i = e(), i instanceof Promise && console.error("Cannot return a Promise inside of tidy."), i));
    }
    scopedRun(t, e, r) {
      t();
      try {
        const i = r();
        return e(), i;
      } catch (i) {
        throw e(), i;
      }
    }
    nextTensorId() {
      return Qf.nextTensorId++;
    }
    nextVariableId() {
      return Qf.nextVariableId++;
    }
    clone(t) {
      const e = K.runKernel(xm, {
        x: t
      }), r = {
        x: t
      }, i = (s) => ({
        x: () => {
          const o = "float32", l = {
            x: s
          }, u = {
            dtype: o
          };
          return K.runKernel(sm, l, u);
        }
      }), a = [];
      return this.addTapeNode(this.state.activeScope.name, r, [
        e
      ], i, a, {}), e;
    }
    runKernel(t, e, r) {
      if (this.backendName == null && this.backend, !(Ez(t, this.backendName) != null)) throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);
      return this.runKernelFunc({
        kernelName: t,
        inputs: e,
        attrs: r
      });
    }
    shouldCheckForMemLeaks() {
      return this.ENV.getBool("IS_TEST");
    }
    checkKernelForMemLeak(t, e, r) {
      const i = this.backend.numDataIds();
      let a = 0;
      r.forEach((l) => {
        a += l.dtype === "complex64" ? 3 : 1;
      });
      const s = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], o = i - e - a - s;
      if (o > 0) throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`);
    }
    runKernelFunc(t) {
      let e, r = [];
      const i = this.isTapeOn(), a = this.state.numBytes, s = this.state.numTensors;
      this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
      let o;
      this.backendName == null && this.backend;
      let l;
      const u = gT(t) ? t.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
      if (gT(t)) {
        const { kernelName: p, inputs: g, attrs: v } = t;
        this.backendName == null && this.backend;
        const m = Ez(p, this.backendName);
        B(m != null, () => `Cannot find registered kernel '${p}' for backend '${this.backendName}'`), o = () => {
          const y = this.backend.numDataIds();
          l = m.kernelFunc({
            inputs: g,
            attrs: v,
            backend: this.backend
          });
          const x = Array.isArray(l) ? l : [
            l
          ];
          this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(p, y, x);
          const b = x.map((_) => _.rank != null ? _ : this.makeTensorFromTensorInfo(_));
          if (i) {
            const _ = this.getTensorsForGradient(p, g, b);
            r = this.saveTensorsForBackwardMode(_);
          }
          return b;
        };
      } else {
        const { forwardFunc: p } = t, g = (v) => {
          i && (r = v.map((m) => this.keep(this.clone(m))));
        };
        o = () => {
          const v = this.backend.numDataIds();
          l = this.tidy(() => p(this.backend, g));
          const m = Array.isArray(l) ? l : [
            l
          ];
          return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(u, v, m), m;
        };
      }
      const { inputs: c, attrs: h } = t, f = gT(t) ? null : t.backwardsFunc;
      let d;
      return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
        !this.ENV.getBool("DEBUG") && !this.state.profiling ? e = o() : (d = this.profiler.profileKernel(u, c, () => o()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(d), e = d.outputs);
      }), i && this.addTapeNode(u, c, e, f, r, h), this.state.profiling && this.state.activeProfile.kernels.push({
        name: u,
        bytesAdded: this.state.numBytes - a,
        totalBytesSnapshot: this.state.numBytes,
        tensorsAdded: this.state.numTensors - s,
        totalTensorsSnapshot: this.state.numTensors,
        inputShapes: Object.keys(c).map((p) => c[p] != null ? c[p].shape : null),
        outputShapes: e.map((p) => p.shape),
        kernelTimeMs: d.timeMs,
        extraInfo: d.extraInfo
      }), Array.isArray(l) ? e : e[0];
    }
    saveTensorsForBackwardMode(t) {
      return t.map((r) => this.keep(this.clone(r)));
    }
    getTensorsForGradient(t, e, r) {
      const i = Mz(t);
      if (i != null) {
        const a = i.inputsToSave || [], s = i.outputsToSave || [];
        let o;
        i.saveAllInputs ? (B(Array.isArray(e), () => "saveAllInputs is true, expected inputs to be an array."), o = Object.keys(e).map((u) => e[u])) : o = a.map((u) => e[u]);
        const l = r.filter((u, c) => s[c]);
        return o.concat(l);
      }
      return [];
    }
    makeTensor(t, e, r, i) {
      if (t == null) throw new Error("Values passed to engine.makeTensor() are null");
      r = r || "float32", i = i || this.backend;
      let a = t;
      r === "string" && Jv(t[0]) && (a = t.map((l) => Gl(l)));
      const s = i.write(a, e, r), o = new Vn(e, r, s, this.nextTensorId());
      if (this.trackTensor(o, i), r === "string") {
        const l = this.state.tensorInfo.get(s), u = bSt(a);
        this.state.numBytes += u - l.bytes, l.bytes = u;
      }
      return o;
    }
    makeTensorFromDataId(t, e, r, i) {
      r = r || "float32";
      const a = {
        dataId: t,
        shape: e,
        dtype: r
      };
      return this.makeTensorFromTensorInfo(a, i);
    }
    makeTensorFromTensorInfo(t, e) {
      const { dataId: r, shape: i, dtype: a } = t, s = new Vn(i, a, r, this.nextTensorId());
      return this.trackTensor(s, e), s;
    }
    makeVariable(t, e = true, r, i) {
      r = r || this.nextVariableId().toString(), i != null && i !== t.dtype && (t = t.cast(i));
      const a = new Fb(t, e, r, this.nextTensorId());
      if (this.state.registeredVariables[a.name] != null) throw new Error(`Variable with name ${a.name} was already registered`);
      return this.state.registeredVariables[a.name] = a, this.incRef(a, this.backend), a;
    }
    trackTensor(t, e) {
      this.state.numTensors++, t.dtype === "string" && this.state.numStringTensors++;
      let r = 0;
      t.dtype !== "complex64" && t.dtype !== "string" && (r = t.size * Lb(t.dtype)), this.state.numBytes += r, this.state.tensorInfo.has(t.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(t.dataId, {
        backend: e || this.backend,
        dtype: t.dtype,
        shape: t.shape,
        bytes: r
      })), t instanceof Fb || this.track(t);
    }
    incRef(t, e) {
      this.trackTensor(t, e), this.backend.incRef(t.dataId);
    }
    removeDataId(t, e) {
      this.state.tensorInfo.has(t) && this.state.tensorInfo.get(t).backend === e && (this.state.tensorInfo.delete(t), this.state.numDataBuffers--);
    }
    disposeTensor(t) {
      if (!this.state.tensorInfo.has(t.dataId)) return;
      const e = this.state.tensorInfo.get(t.dataId);
      if (this.state.numTensors--, t.dtype === "string" && (this.state.numStringTensors--, this.state.numBytes -= e.bytes), t.dtype !== "complex64" && t.dtype !== "string") {
        const r = t.size * Lb(t.dtype);
        this.state.numBytes -= r;
      }
      e.backend.disposeData(t.dataId) && this.removeDataId(t.dataId, e.backend);
    }
    disposeVariables() {
      for (const t in this.state.registeredVariables) {
        const e = this.state.registeredVariables[t];
        this.disposeVariable(e);
      }
    }
    disposeVariable(t) {
      this.disposeTensor(t), this.state.registeredVariables[t.name] != null && delete this.state.registeredVariables[t.name];
    }
    memory() {
      const t = this.backend.memory();
      return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = true, t.reasons == null && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t;
    }
    async profile(t) {
      this.state.profiling = true;
      const e = this.state.numBytes, r = this.state.numTensors;
      this.state.activeProfile.kernels = [], this.state.activeProfile.result = await t(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((i) => i.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - r;
      for (const i of this.state.activeProfile.kernels) i.kernelTimeMs = await i.kernelTimeMs, i.extraInfo = await i.extraInfo;
      return this.state.activeProfile;
    }
    isTapeOn() {
      return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(t, e, r, i, a, s) {
      const o = {
        id: this.state.nextTapeNodeId++,
        kernelName: t,
        inputs: e,
        outputs: r,
        saved: a
      }, l = Mz(t);
      l != null && (i = l.gradFunc), i != null && (o.gradient = (u) => (u = u.map((c, h) => {
        if (c == null) {
          const f = r[h], d = Er(f.size, f.dtype);
          return this.makeTensor(d, f.shape, f.dtype);
        }
        return c;
      }), i(u.length > 1 ? u : u[0], a, s))), this.state.activeTape.push(o);
    }
    keep(t) {
      return t.kept = true, t;
    }
    startTape() {
      this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
    }
    endTape() {
      this.state.gradientDepth--;
    }
    startScope(t) {
      const e = {
        track: [],
        name: "unnamed scope",
        id: this.state.nextScopeId++
      };
      t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e;
    }
    endScope(t) {
      const e = Dq(t), r = new Set(e.map((a) => a.id));
      for (let a = 0; a < this.state.activeScope.track.length; a++) {
        const s = this.state.activeScope.track[a];
        !s.kept && !r.has(s.id) && s.dispose();
      }
      const i = this.state.scopeStack.pop();
      this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], e.forEach((a) => {
        !a.kept && a.scopeId === i.id && this.track(a);
      });
    }
    gradients(t, e, r, i = false) {
      if (B(e.length > 0, () => "gradients() received an empty list of xs."), r != null && r.dtype !== "float32") throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);
      const a = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", t));
      B(a instanceof Vn, () => "The result y returned by f() must be a tensor.");
      const s = YSt(this.state.activeTape, e, a);
      if (!i && s.length === 0 && e.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      return this.tidy("backward", () => {
        const o = {};
        o[a.id] = r ?? eCt(a.shape), qSt(o, s, (u) => this.tidy(u), nCt);
        const l = e.map((u) => o[u.id]);
        return this.state.gradientDepth === 0 && (this.state.activeTape.forEach((u) => {
          for (const c of u.saved) c.dispose();
        }), this.state.activeTape = null), {
          value: a,
          grads: l
        };
      });
    }
    customGrad(t) {
      return B(p2(t), () => "The f passed in customGrad(f) must be a function."), (...e) => {
        B(e.every((o) => o instanceof Vn), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
        let r;
        const i = {};
        e.forEach((o, l) => {
          i[l] = o;
        });
        const a = (o, l) => (r = t(...e, l), B(r.value instanceof Vn, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), B(p2(r.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), r.value), s = (o, l) => {
          const u = r.gradFunc(o, l), c = Array.isArray(u) ? u : [
            u
          ];
          B(c.length === e.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), B(c.every((f) => f instanceof Vn), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          const h = {};
          return c.forEach((f, d) => {
            h[d] = () => f;
          }), h;
        };
        return this.runKernelFunc({
          forwardFunc: a,
          backwardsFunc: s,
          inputs: i
        });
      };
    }
    readSync(t) {
      return this.state.tensorInfo.get(t).backend.readSync(t);
    }
    read(t) {
      return this.state.tensorInfo.get(t).backend.read(t);
    }
    readToGPU(t, e) {
      return this.state.tensorInfo.get(t).backend.readToGPU(t, e);
    }
    async time(t) {
      const e = si(), r = await this.backend.time(t);
      return r.wallMs = si() - e, r;
    }
    track(t) {
      return this.state.activeScope != null && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;
    }
    get registeredVariables() {
      return this.state.registeredVariables;
    }
    reset() {
      this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Oz();
      for (const t in this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];
      this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }
  }
  Qf.nextTensorId = 0;
  Qf.nextVariableId = 0;
  function eCt(n) {
    const t = YE(lt(n), "float32");
    return K.makeTensor(t, n, "float32");
  }
  function Mq() {
    const n = ZY();
    if (n._tfengine == null) {
      const t = new SSt(n);
      n._tfengine = new Qf(t);
    }
    return ASt(n._tfengine.ENV), ZSt(() => n._tfengine), n._tfengine;
  }
  const K = Mq();
  function nCt(n, t) {
    const e = {
      a: n,
      b: t
    };
    return K.runKernel(Ld, e);
  }
  function rCt() {
    return typeof navigator < "u" && navigator != null;
  }
  function Rq(n) {
    if (n || rCt()) {
      if (n || (n = navigator), n.product === "ReactNative") return true;
      const t = n.userAgent || n.vendor || (typeof window < "u" ? window.opera : "");
      if (!t) {
        const e = n;
        return e.userAgentData && e.userAgentData.mobile;
      }
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4));
    }
    return false;
  }
  function Nq() {
    return typeof window < "u" && window.document != null || typeof WorkerGlobalScope < "u";
  }
  const xi = nt();
  xi.registerFlag("DEBUG", () => false, (n) => {
    n && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
  });
  xi.registerFlag("IS_BROWSER", () => Nq());
  xi.registerFlag("IS_NODE", () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u");
  xi.registerFlag("IS_CHROME", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
  xi.registerFlag("IS_SAFARI", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
  xi.registerFlag("PROD", () => false);
  xi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => xi.getBool("DEBUG"));
  xi.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
  xi.registerFlag("IS_TEST", () => false);
  xi.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => xi.getBool("DEBUG"));
  xi.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
  xi.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
  xi.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
  function iw(n, t) {
    let e = n;
    if (Aa(n)) return t === "string" ? [] : [
      n.length
    ];
    if (Aq(n)) {
      const i = n.channels || "RGBA";
      return [
        n.height,
        n.width * i.length
      ];
    } else if (kq(n)) return [
      n.buffer.size / (t == null ? 4 : Lb(t))
    ];
    if (!Array.isArray(n)) return [];
    const r = [];
    for (; Array.isArray(e) || Aa(e) && t !== "string"; ) r.push(e.length), e = e[0];
    return Array.isArray(n) && nt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && Lq(n, r, []), r;
  }
  function Lq(n, t, e) {
    if (e = e || [], !Array.isArray(n) && !Aa(n)) {
      B(t.length === 0, () => `Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);
      return;
    }
    B(t.length > 0, () => `Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`), B(n.length === t[0], () => `Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);
    const r = t.slice(1);
    for (let i = 0; i < n.length; ++i) Lq(n[i], r, e.concat(i));
  }
  function Fz(n, t, e, r) {
    if (n !== "string_or_numeric") {
      if (n == null) throw new Error("Expected dtype cannot be null.");
      if (n !== "numeric" && n !== t || n === "numeric" && t === "string") throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`);
    }
  }
  function W(n, t, e, r = "numeric") {
    if (n instanceof ot()) return Fz(r, n.dtype, t, e), n;
    let i = Rd(n);
    if (i !== "string" && [
      "bool",
      "int32",
      "float32"
    ].indexOf(r) >= 0 && (i = r), Fz(r, i, t, e), n == null || !Aa(n) && !Array.isArray(n) && typeof n != "number" && typeof n != "boolean" && typeof n != "string") {
      const l = n == null ? "null" : n.constructor.name;
      throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`);
    }
    const a = iw(n, i);
    !Aa(n) && !Array.isArray(n) && (n = [
      n
    ]);
    const o = i !== "string" ? bh(n, i) : Zc(n, [], true);
    return K.makeTensor(o, a, i);
  }
  function Pq(n, t, e, r = "numeric") {
    if (!Array.isArray(n)) throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);
    return n.map((a, s) => W(a, `${t}[${s}]`, e, r));
  }
  const iCt = "__op";
  function Q(n) {
    const t = Object.keys(n);
    if (t.length !== 1) throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);
    let e = t[0];
    const r = n[e];
    e.endsWith("_") && (e = e.substring(0, e.length - 1)), e = e + iCt;
    const i = (...a) => {
      K.startScope(e);
      try {
        const s = r(...a);
        return qE(s) && console.error("Cannot return a Promise inside of tidy."), K.endScope(s), s;
      } catch (s) {
        throw K.endScope(null), s;
      }
    };
    return Object.defineProperty(i, "name", {
      value: e,
      configurable: true
    }), i;
  }
  function aCt(n, t) {
    const e = W(n, "real", "complex"), r = W(t, "imag", "complex");
    XE(e.shape, r.shape, `real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`);
    const i = {
      real: e,
      imag: r
    };
    return K.runKernel(rM, i);
  }
  const td = Q({
    complex_: aCt
  });
  function aw(n, t, e, r) {
    if (r == null) r = Rd(n);
    else if (r === "complex64") throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (kq(n) || Aq(n)) {
      if (r !== "float32" && r !== "int32") throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);
      return K.backend.createTensorFromGPUData(n, t || e, r);
    }
    if (!Aa(n) && !Array.isArray(n) && typeof n != "number" && typeof n != "boolean" && typeof n != "string") throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (t != null) {
      nl(t);
      const i = lt(t), a = lt(e);
      B(i === a, () => `Based on the provided shape, [${t}], the tensor should have ${i} values but has ${a}`);
      for (let s = 0; s < e.length; ++s) {
        const o = e[s], l = s === e.length - 1 ? o !== lt(t.slice(s)) : true;
        B(e[s] === t[s] || !l, () => `Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `);
      }
    }
    return !Aa(n) && !Array.isArray(n) && (n = [
      n
    ]), t = t || e, n = r !== "string" ? bh(n, r) : Zc(n, [], true), K.makeTensor(n, t, r);
  }
  function $q(n, t, e) {
    const r = iw(n, e);
    return aw(n, t, r, e);
  }
  class Pd {
    static join(t) {
      return new Pd(t).slice();
    }
    constructor(t) {
      if (this.shards = [], this.previousShardIndex = 0, t == null || (t instanceof Array || (t = [
        t
      ]), t = t.map((r) => Aa(r) ? r.buffer : r), t.length === 0)) return;
      this.bufferUniformSize = t[0].byteLength;
      let e = 0;
      for (let r = 0; r < t.length; r++) {
        const i = t[r];
        r !== t.length - 1 && i.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
        const a = e + i.byteLength;
        this.shards.push({
          buffer: i,
          start: e,
          end: a
        }), e = a;
      }
      this.shards.length === 0 && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
    }
    slice(t = 0, e = this.byteLength) {
      if (this.shards.length === 0) return new ArrayBuffer(0);
      if (t = isNaN(Number(t)) ? 0 : t, e = isNaN(Number(e)) ? 0 : e, t = Math.max(0, t), e = Math.min(this.byteLength, e), e <= t) return new ArrayBuffer(0);
      const r = this.findShardForByte(t);
      if (r === -1) throw new Error(`Could not find start shard for byte ${t}`);
      const i = e - t, a = new ArrayBuffer(i), s = new Uint8Array(a);
      let o = 0;
      for (let l = r; l < this.shards.length; l++) {
        const u = this.shards[l], h = t + o - u.start, f = o, p = Math.min(e, u.end) - u.start, g = new Uint8Array(u.buffer, h, p - h);
        if (s.set(g, f), o += g.length, e < u.end) break;
      }
      return a;
    }
    findShardForByte(t) {
      if (this.shards.length === 0 || t < 0 || t >= this.byteLength) return -1;
      if (this.bufferUniformSize != null) return this.previousShardIndex = Math.floor(t / this.bufferUniformSize), this.previousShardIndex;
      function e(i) {
        return t < i.start ? -1 : t >= i.end ? 1 : 0;
      }
      if (e(this.shards[this.previousShardIndex]) === 0) return this.previousShardIndex;
      const r = sCt(this.shards, e);
      return r === -1 ? -1 : (this.previousShardIndex = r, this.previousShardIndex);
    }
  }
  function sCt(n, t) {
    let e = 0, r = n.length;
    for (; e <= r; ) {
      const i = Math.floor((r - e) / 2) + e, a = t(n[i]);
      if (a === 0) return i;
      a < 0 ? r = i : e = i + 1;
    }
    return -1;
  }
  function Es() {
    return K;
  }
  function Bz() {
    return K.memory();
  }
  function tt(n, t) {
    return K.tidy(n, t);
  }
  function Te(n) {
    Dq(n).forEach((e) => e.dispose());
  }
  function qs(n) {
    return K.keep(n);
  }
  function oCt(n) {
    return K.setBackend(n);
  }
  function lCt() {
    return K.ready();
  }
  function Oq(n, t, e = 1) {
    return K.registerBackend(n, t, e);
  }
  function uCt() {
    return K.backend;
  }
  const zz = 4;
  async function Vz(n, t) {
    const e = [], r = [], i = Array.isArray(n) ? n.map((s) => s.name) : Object.keys(n);
    for (let s = 0; s < i.length; ++s) {
      const o = i[s], l = Array.isArray(n) ? n[s].tensor : n[o];
      if (l.dtype !== "float32" && l.dtype !== "int32" && l.dtype !== "bool" && l.dtype !== "string" && l.dtype !== "complex64") throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);
      const u = {
        name: o,
        shape: l.shape,
        dtype: l.dtype
      };
      if (l.dtype === "string") {
        const c = new Promise(async (h) => {
          const f = await l.bytes(), d = f.reduce((v, m) => v + m.length, 0) + zz * f.length, p = new Uint8Array(d);
          let g = 0;
          for (let v = 0; v < f.length; v++) {
            const m = f[v], y = new Uint8Array(new Uint32Array([
              m.length
            ]).buffer);
            p.set(y, g), g += zz, p.set(m, g), g += m.length;
          }
          h(p);
        });
        r.push(c);
      } else r.push(l.data());
      t != null && (u.group = t), e.push(u);
    }
    const a = await Promise.all(r);
    return {
      data: cCt(a),
      specs: e
    };
  }
  function cCt(n) {
    if (n === null) throw new Error(`Invalid input value: ${JSON.stringify(n)}`);
    let t = 0;
    const e = [];
    n.forEach((a) => {
      if (t += a.byteLength, e.push(a.byteLength === a.buffer.byteLength ? a : new a.constructor(a)), !(a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array)) throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`);
    });
    const r = new Uint8Array(t);
    let i = 0;
    return e.forEach((a) => {
      r.set(new Uint8Array(a.buffer), i), i += a.byteLength;
    }), r.buffer;
  }
  const FM = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
  function Gz(n) {
    return FM ? Buffer.byteLength(n, "utf8") : new Blob([
      n
    ]).size;
  }
  function hCt(n) {
    if (FM) return Buffer.from(n).toString("base64");
    const t = new Uint8Array(n);
    let e = "";
    for (let r = 0, i = t.length; r < i; r++) e += String.fromCharCode(t[r]);
    return btoa(e);
  }
  function fCt(n) {
    if (FM) {
      const r = Buffer.from(n, "base64");
      return r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
    }
    const t = atob(n), e = new Uint8Array(t.length);
    for (let r = 0; r < t.length; ++r) e.set([
      t.charCodeAt(r)
    ], r);
    return e.buffer;
  }
  function dCt(n) {
    return Pd.join(n);
  }
  function Fq(n) {
    if (n.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return {
      dateSaved: /* @__PURE__ */ new Date(),
      modelTopologyType: "JSON",
      modelTopologyBytes: n.modelTopology == null ? 0 : Gz(JSON.stringify(n.modelTopology)),
      weightSpecsBytes: n.weightSpecs == null ? 0 : Gz(JSON.stringify(n.weightSpecs)),
      weightDataBytes: n.weightData == null ? 0 : new Pd(n.weightData).byteLength
    };
  }
  class zr {
    constructor() {
      this.saveRouters = [], this.loadRouters = [];
    }
    static getInstance() {
      return zr.instance == null && (zr.instance = new zr()), zr.instance;
    }
    static registerSaveRouter(t) {
      zr.getInstance().saveRouters.push(t);
    }
    static registerLoadRouter(t) {
      zr.getInstance().loadRouters.push(t);
    }
    static getSaveHandlers(t) {
      return zr.getHandlers(t, "save");
    }
    static getLoadHandlers(t, e) {
      return zr.getHandlers(t, "load", e);
    }
    static getHandlers(t, e, r) {
      const i = [];
      return (e === "load" ? zr.getInstance().loadRouters : zr.getInstance().saveRouters).forEach((s) => {
        const o = s(t, r);
        o !== null && i.push(o);
      }), i;
    }
  }
  const pCt = (n) => zr.getSaveHandlers(n);
  const C2 = "tensorflowjs", T2 = 1, Cc = "models_store", Rl = "model_info_store";
  function Bq() {
    if (!nt().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    const n = typeof window > "u" ? self : window, t = n.indexedDB || n.mozIndexedDB || n.webkitIndexedDB || n.msIndexedDB || n.shimIndexedDB;
    if (t == null) throw new Error("The current browser does not appear to support IndexedDB.");
    return t;
  }
  function I2(n) {
    const t = n.result;
    t.createObjectStore(Cc, {
      keyPath: "modelPath"
    }), t.createObjectStore(Rl, {
      keyPath: "modelPath"
    });
  }
  class Jc {
    constructor(t) {
      if (this.indexedDB = Bq(), t == null || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      this.modelPath = t;
    }
    async save(t) {
      if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      return this.databaseAction(this.modelPath, t);
    }
    async load() {
      return this.databaseAction(this.modelPath);
    }
    databaseAction(t, e) {
      return new Promise((r, i) => {
        const a = this.indexedDB.open(C2, T2);
        a.onupgradeneeded = () => I2(a), a.onsuccess = () => {
          const s = a.result;
          if (e == null) {
            const o = s.transaction(Cc, "readonly"), u = o.objectStore(Cc).get(this.modelPath);
            u.onsuccess = () => {
              if (u.result == null) return s.close(), i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
              r(u.result.modelArtifacts);
            }, u.onerror = (c) => (s.close(), i(u.error)), o.oncomplete = () => s.close();
          } else {
            e.weightData = Pd.join(e.weightData);
            const o = Fq(e), l = s.transaction(Rl, "readwrite");
            let u = l.objectStore(Rl), c;
            try {
              c = u.put({
                modelPath: this.modelPath,
                modelArtifactsInfo: o
              });
            } catch (f) {
              return i(f);
            }
            let h;
            c.onsuccess = () => {
              h = s.transaction(Cc, "readwrite");
              const f = h.objectStore(Cc);
              let d;
              try {
                d = f.put({
                  modelPath: this.modelPath,
                  modelArtifacts: e,
                  modelArtifactsInfo: o
                });
              } catch (p) {
                return i(p);
              }
              d.onsuccess = () => r({
                modelArtifactsInfo: o
              }), d.onerror = (p) => {
                u = l.objectStore(Rl);
                const g = u.delete(this.modelPath);
                g.onsuccess = () => (s.close(), i(d.error)), g.onerror = (v) => (s.close(), i(d.error));
              };
            }, c.onerror = (f) => (s.close(), i(c.error)), l.oncomplete = () => {
              h == null ? s.close() : h.oncomplete = () => s.close();
            };
          }
        }, a.onerror = (s) => i(a.error);
      });
    }
  }
  Jc.URL_SCHEME = "indexeddb://";
  const zq = (n) => nt().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(Jc.URL_SCHEME) ? gCt(n.slice(Jc.URL_SCHEME.length)) : null;
  zr.registerSaveRouter(zq);
  zr.registerLoadRouter(zq);
  function gCt(n) {
    return new Jc(n);
  }
  function vCt(n) {
    return n.startsWith(Jc.URL_SCHEME) ? n.slice(Jc.URL_SCHEME.length) : n;
  }
  class mCt {
    constructor() {
      this.indexedDB = Bq();
    }
    async listModels() {
      return new Promise((t, e) => {
        const r = this.indexedDB.open(C2, T2);
        r.onupgradeneeded = () => I2(r), r.onsuccess = () => {
          const i = r.result, a = i.transaction(Rl, "readonly"), o = a.objectStore(Rl).getAll();
          o.onsuccess = () => {
            const l = {};
            for (const u of o.result) l[u.modelPath] = u.modelArtifactsInfo;
            t(l);
          }, o.onerror = (l) => (i.close(), e(o.error)), a.oncomplete = () => i.close();
        }, r.onerror = (i) => e(r.error);
      });
    }
    async removeModel(t) {
      return t = vCt(t), new Promise((e, r) => {
        const i = this.indexedDB.open(C2, T2);
        i.onupgradeneeded = () => I2(i), i.onsuccess = () => {
          const a = i.result, s = a.transaction(Rl, "readwrite"), o = s.objectStore(Rl), l = o.get(t);
          let u;
          l.onsuccess = () => {
            if (l.result == null) return a.close(), r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));
            {
              const c = o.delete(t), h = () => {
                u = a.transaction(Cc, "readwrite");
                const d = u.objectStore(Cc).delete(t);
                d.onsuccess = () => e(l.result.modelArtifactsInfo), d.onerror = (p) => r(l.error);
              };
              c.onsuccess = h, c.onerror = (f) => (h(), a.close(), r(l.error));
            }
          }, l.onerror = (c) => (a.close(), r(l.error)), s.oncomplete = () => {
            u == null ? a.close() : u.oncomplete = () => a.close();
          };
        }, i.onerror = (a) => r(i.error);
      });
    }
  }
  const Co = "/", mf = "tensorflowjs_models", Vq = "info", yCt = "model_topology", xCt = "weight_specs", bCt = "weight_data", _Ct = "model_metadata";
  function Gq(n) {
    return {
      info: [
        mf,
        n,
        Vq
      ].join(Co),
      topology: [
        mf,
        n,
        yCt
      ].join(Co),
      weightSpecs: [
        mf,
        n,
        xCt
      ].join(Co),
      weightData: [
        mf,
        n,
        bCt
      ].join(Co),
      modelMetadata: [
        mf,
        n,
        _Ct
      ].join(Co)
    };
  }
  function Wq(n) {
    for (const t of Object.values(n)) window.localStorage.removeItem(t);
  }
  function wCt(n) {
    const t = n.split(Co);
    if (t.length < 3) throw new Error(`Invalid key format: ${n}`);
    return t.slice(1, t.length - 1).join(Co);
  }
  function SCt(n) {
    return n.startsWith(Qc.URL_SCHEME) ? n.slice(Qc.URL_SCHEME.length) : n;
  }
  class Qc {
    constructor(t) {
      if (!nt().getBool("IS_BROWSER") || typeof window > "u" || typeof window.localStorage > "u") throw new Error("The current environment does not support local storage.");
      if (this.LS = window.localStorage, t == null || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      this.modelPath = t, this.keys = Gq(this.modelPath);
    }
    async save(t) {
      if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      {
        const e = JSON.stringify(t.modelTopology), r = JSON.stringify(t.weightSpecs), i = Fq(t), a = Pd.join(t.weightData);
        try {
          this.LS.setItem(this.keys.info, JSON.stringify(i)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, hCt(a));
          const s = {
            format: t.format,
            generatedBy: t.generatedBy,
            convertedBy: t.convertedBy,
            signature: t.signature != null ? t.signature : void 0,
            userDefinedMetadata: t.userDefinedMetadata != null ? t.userDefinedMetadata : void 0,
            modelInitializer: t.modelInitializer != null ? t.modelInitializer : void 0,
            initializerSignature: t.initializerSignature != null ? t.initializerSignature : void 0,
            trainingConfig: t.trainingConfig != null ? t.trainingConfig : void 0
          };
          return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(s)), {
            modelArtifactsInfo: i
          };
        } catch {
          throw Wq(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`);
        }
      }
    }
    async load() {
      const t = JSON.parse(this.LS.getItem(this.keys.info));
      if (t == null) throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
      if (t.modelTopologyType !== "JSON") throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      const e = {}, r = JSON.parse(this.LS.getItem(this.keys.topology));
      if (r == null) throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
      e.modelTopology = r;
      const i = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
      if (i == null) throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
      e.weightSpecs = i;
      const a = this.LS.getItem(this.keys.modelMetadata);
      if (a != null) {
        const o = JSON.parse(a);
        e.format = o.format, e.generatedBy = o.generatedBy, e.convertedBy = o.convertedBy, o.signature != null && (e.signature = o.signature), o.userDefinedMetadata != null && (e.userDefinedMetadata = o.userDefinedMetadata), o.modelInitializer != null && (e.modelInitializer = o.modelInitializer), o.initializerSignature != null && (e.initializerSignature = o.initializerSignature), o.trainingConfig != null && (e.trainingConfig = o.trainingConfig);
      }
      const s = this.LS.getItem(this.keys.weightData);
      if (s == null) throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
      return e.weightData = fCt(s), e;
    }
  }
  Qc.URL_SCHEME = "localstorage://";
  const Uq = (n) => nt().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(Qc.URL_SCHEME) ? CCt(n.slice(Qc.URL_SCHEME.length)) : null;
  zr.registerSaveRouter(Uq);
  zr.registerLoadRouter(Uq);
  function CCt(n) {
    return new Qc(n);
  }
  class TCt {
    constructor() {
      B(nt().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), B(typeof window > "u" || typeof window.localStorage < "u", () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
    }
    async listModels() {
      const t = {}, e = mf + Co, r = Co + Vq;
      for (let i = 0; i < this.LS.length; ++i) {
        const a = this.LS.key(i);
        if (a.startsWith(e) && a.endsWith(r)) {
          const s = wCt(a);
          t[s] = JSON.parse(this.LS.getItem(a));
        }
      }
      return t;
    }
    async removeModel(t) {
      t = SCt(t);
      const e = Gq(t);
      if (this.LS.getItem(e.info) == null) throw new Error(`Cannot find model at path '${t}'`);
      const r = JSON.parse(this.LS.getItem(e.info));
      return Wq(e), r;
    }
  }
  const Wz = "://";
  class Rs {
    constructor() {
      this.managers = {};
    }
    static getInstance() {
      return Rs.instance == null && (Rs.instance = new Rs()), Rs.instance;
    }
    static registerManager(t, e) {
      B(t != null, () => "scheme must not be undefined or null."), t.endsWith(Wz) && (t = t.slice(0, t.indexOf(Wz))), B(t.length > 0, () => "scheme must not be an empty string.");
      const r = Rs.getInstance();
      B(r.managers[t] == null, () => `A model store manager is already registered for scheme '${t}'.`), r.managers[t] = e;
    }
    static getManager(t) {
      const e = Rs.getInstance().managers[t];
      if (e == null) throw new Error(`Cannot find model manager for scheme '${t}'`);
      return e;
    }
    static getSchemes() {
      return Object.keys(Rs.getInstance().managers);
    }
  }
  class ICt {
    constructor() {
      this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = false;
    }
    fetch(t, e) {
      return fetch(t, e);
    }
    now() {
      return performance.now();
    }
    encode(t, e) {
      if (e !== "utf-8" && e !== "utf8") throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);
      return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t);
    }
    decode(t, e) {
      return new TextDecoder(e).decode(t);
    }
    setTimeoutCustom(t, e) {
      if (typeof window > "u" || !nt().getBool("USE_SETTIMEOUTCUSTOM")) {
        setTimeout(t, e);
        return;
      }
      this.functionRefs.push(t), setTimeout(() => {
        window.postMessage({
          name: this.messageName,
          index: this.functionRefs.length - 1
        }, "*");
      }, e), this.hasEventListener || (this.hasEventListener = true, window.addEventListener("message", (r) => {
        if (r.source === window && r.data.name === this.messageName) {
          r.stopPropagation();
          const i = this.functionRefs[r.data.index];
          i(), this.handledMessageCount++, this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], this.handledMessageCount = 0);
        }
      }, true));
    }
    isTypedArray(t) {
      return _q(t);
    }
  }
  if (nt().get("IS_BROWSER")) {
    nt().setPlatform("browser", new ICt());
    try {
      Rs.registerManager(Qc.URL_SCHEME, new TCt());
    } catch {
    }
    try {
      Rs.registerManager(Jc.URL_SCHEME, new mCt());
    } catch {
    }
  }
  const ACt = {
    importFetch: () => require("node-fetch")
  };
  let vT;
  class kCt {
    constructor() {
      this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
    }
    fetch(t, e) {
      return nt().global.fetch != null ? nt().global.fetch(t, e) : (vT == null && (vT = ACt.importFetch()), vT(t, e));
    }
    now() {
      const t = process.hrtime();
      return t[0] * 1e3 + t[1] / 1e6;
    }
    encode(t, e) {
      if (e !== "utf-8" && e !== "utf8") throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);
      return this.textEncoder.encode(t);
    }
    decode(t, e) {
      return t.length === 0 ? "" : new this.util.TextDecoder(e).decode(t);
    }
    isTypedArray(t) {
      return this.util.types.isFloat32Array(t) || this.util.types.isInt32Array(t) || this.util.types.isUint8Array(t) || this.util.types.isUint8ClampedArray(t);
    }
  }
  nt().get("IS_NODE") && !nt().get("IS_BROWSER") && nt().setPlatform("node", new kCt());
  function we(n, t = "float32", e) {
    return t = t || "float32", nl(n), new xr(n, t, e);
  }
  function DCt(n, t) {
    const e = W(n, "x", "cast");
    if (!xSt(t)) throw new Error(`Failed to cast to unknown dtype ${t}`);
    if (t === "string" && e.dtype !== "string" || t !== "string" && e.dtype === "string") throw new Error("Only strings can be casted to strings");
    const r = {
      x: e
    }, i = {
      dtype: t
    };
    return K.runKernel(sm, r, i);
  }
  const Et = Q({
    cast_: DCt
  });
  function ECt(n) {
    const e = {
      x: W(n, "x", "clone", "string_or_numeric")
    };
    return K.runKernel(xm, e);
  }
  const Bc = Q({
    clone_: ECt
  });
  function MCt(n, t = false) {
    console.log(n.toString(t));
  }
  Mq();
  const RCt = {
    buffer: we,
    cast: Et,
    clone: Bc,
    print: MCt
  };
  JSt(RCt);
  function NCt(n, t) {
    let e = W(n, "a", "add"), r = W(t, "b", "add");
    [e, r] = Mn(e, r);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(Ld, i);
  }
  const bt = Q({
    add_: NCt
  });
  function LCt(n, t) {
    let e = W(n, "a", "floorDiv"), r = W(t, "b", "floorDiv");
    [e, r] = Mn(e, r);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(mm, i);
  }
  const Hq = Q({
    floorDiv_: LCt
  });
  function PCt(n, t) {
    let e = W(n, "a", "div"), r = W(t, "b", "div");
    if ([e, r] = Mn(e, r), e.dtype === "int32" && r.dtype === "int32") return Hq(e, r);
    const i = {
      a: e,
      b: r
    }, a = {};
    return K.runKernel(hm, i, a);
  }
  const Jt = Q({
    div_: PCt
  });
  function $Ct(n, t) {
    let e = W(n, "a", "mul"), r = W(t, "b", "mul");
    [e, r] = Mn(e, r);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(km, i);
  }
  const j = Q({
    mul_: $Ct
  });
  function OCt(n) {
    const t = W(n, "x", "abs");
    if (t.dtype === "complex64") {
      const e = {
        x: t
      };
      return K.runKernel(u_, e);
    } else {
      const e = {
        x: t
      };
      return K.runKernel(n_, e);
    }
  }
  const Gr = Q({
    abs_: OCt
  });
  function FCt(n) {
    const e = {
      x: W(n, "x", "acos")
    };
    return K.runKernel(Qv, e);
  }
  const BCt = Q({
    acos_: FCt
  });
  function zCt(n) {
    const e = {
      x: W(n, "x", "acosh")
    };
    return K.runKernel(tm, e);
  }
  const VCt = Q({
    acosh_: zCt
  });
  function GCt(n, t = null, e = false) {
    const i = {
      x: W(n, "x", "all", "bool")
    }, a = {
      axis: t,
      keepDims: e
    };
    return K.runKernel(ZE, i, a);
  }
  const Xq = Q({
    all_: GCt
  });
  function WCt(n, t = null, e = false) {
    const i = {
      x: W(n, "x", "any", "bool")
    }, a = {
      axis: t,
      keepDims: e
    };
    return K.runKernel(JE, i, a);
  }
  const A2 = Q({
    any_: WCt
  });
  function UCt(n, t = 0) {
    const r = {
      x: W(n, "x", "argMax")
    }, i = {
      axis: t
    };
    return K.runKernel(r_, r, i);
  }
  const uv = Q({
    argMax_: UCt
  });
  function HCt(n, t = 0) {
    const r = {
      x: W(n, "x", "argMin")
    }, i = {
      axis: t
    };
    return K.runKernel(i_, r, i);
  }
  const XCt = Q({
    argMin_: HCt
  });
  function YCt(n) {
    const e = {
      x: W(n, "x", "asin")
    };
    return K.runKernel(em, e);
  }
  const qCt = Q({
    asin_: YCt
  });
  function jCt(n) {
    const e = {
      x: W(n, "x", "asinh")
    };
    return K.runKernel(nm, e);
  }
  const KCt = Q({
    asinh_: jCt
  });
  function ZCt(n) {
    const e = {
      x: W(n, "x", "atan")
    };
    return K.runKernel(rm, e);
  }
  const JCt = Q({
    atan_: ZCt
  });
  function QCt(n, t) {
    let e = W(n, "a", "atan2"), r = W(t, "b", "atan2");
    [e, r] = Mn(e, r);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(am, i);
  }
  const tTt = Q({
    atan2_: QCt
  });
  function eTt(n) {
    const e = {
      x: W(n, "x", "atanh")
    };
    return K.runKernel(im, e);
  }
  const nTt = Q({
    atanh_: eTt
  });
  function qm(n, t, e, r, i = "NHWC", a) {
    const s = n[3], o = [
      ...t,
      s
    ], l = il(i);
    return _r(n, o, e, a, r, null, null, l);
  }
  function Ra(n, t, e, r, i, a, s = "channelsLast") {
    const [o, l] = cv(t);
    let u;
    if (s === "channelsLast") u = [
      o,
      l,
      n[3],
      n[3]
    ];
    else if (s === "channelsFirst") u = [
      o,
      l,
      n[1],
      n[1]
    ];
    else throw new Error(`Unknown dataFormat ${s}`);
    return _r(n, u, e, r, i, a, false, s);
  }
  function rl(n, t, e, r, i, a, s = "NDHWC") {
    const [o, l, u] = k2(t);
    let c, h;
    if (s === "NDHWC") h = "channelsLast", c = [
      o,
      l,
      u,
      n[4],
      n[4]
    ];
    else if (s === "NCDHW") h = "channelsFirst", c = [
      o,
      l,
      u,
      n[1],
      n[1]
    ];
    else throw new Error(`Unknown dataFormat ${s}`);
    return cu(n, c, e, r, i, false, h, a);
  }
  function _r(n, t, e, r, i, a, s = false, o = "channelsLast") {
    let [l, u, c, h] = [
      -1,
      -1,
      -1,
      -1
    ];
    if (o === "channelsLast") [l, u, c, h] = n;
    else if (o === "channelsFirst") [l, h, u, c] = n;
    else throw new Error(`Unknown dataFormat ${o}`);
    const [f, d, , p] = t, [g, v] = cv(e), [m, y] = cv(r), x = $f(f, m), b = $f(d, y), { padInfo: _, outHeight: w, outWidth: S } = aTt(i, u, c, g, v, x, b, a, o), I = s ? p * h : p;
    let T;
    return o === "channelsFirst" ? T = [
      l,
      I,
      w,
      S
    ] : o === "channelsLast" && (T = [
      l,
      w,
      S,
      I
    ]), {
      batchSize: l,
      dataFormat: o,
      inHeight: u,
      inWidth: c,
      inChannels: h,
      outHeight: w,
      outWidth: S,
      outChannels: I,
      padInfo: _,
      strideHeight: g,
      strideWidth: v,
      filterHeight: f,
      filterWidth: d,
      effectiveFilterHeight: x,
      effectiveFilterWidth: b,
      dilationHeight: m,
      dilationWidth: y,
      inShape: n,
      outShape: T,
      filterShape: t
    };
  }
  function cu(n, t, e, r, i, a = false, s = "channelsLast", o) {
    let [l, u, c, h, f] = [
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    if (s === "channelsLast") [l, u, c, h, f] = n;
    else if (s === "channelsFirst") [l, f, u, c, h] = n;
    else throw new Error(`Unknown dataFormat ${s}`);
    const [d, p, g, , v] = t, [m, y, x] = k2(e), [b, _, w] = k2(r), S = $f(d, b), I = $f(p, _), T = $f(g, w), { padInfo: A, outDepth: C, outHeight: D, outWidth: E } = sTt(i, u, c, h, m, y, x, S, I, T, o), M = a ? v * f : v;
    let L;
    return s === "channelsFirst" ? L = [
      l,
      M,
      C,
      D,
      E
    ] : s === "channelsLast" && (L = [
      l,
      C,
      D,
      E,
      M
    ]), {
      batchSize: l,
      dataFormat: s,
      inDepth: u,
      inHeight: c,
      inWidth: h,
      inChannels: f,
      outDepth: C,
      outHeight: D,
      outWidth: E,
      outChannels: M,
      padInfo: A,
      strideDepth: m,
      strideHeight: y,
      strideWidth: x,
      filterDepth: d,
      filterHeight: p,
      filterWidth: g,
      effectiveFilterDepth: S,
      effectiveFilterHeight: I,
      effectiveFilterWidth: T,
      dilationDepth: b,
      dilationHeight: _,
      dilationWidth: w,
      inShape: n,
      outShape: L,
      filterShape: t
    };
  }
  function rTt(n, t, e, r, i) {
    r == null && (r = BM(n, t, e));
    const a = n[0], s = n[1], o = hv((a - t + 2 * r) / e + 1, i), l = hv((s - t + 2 * r) / e + 1, i);
    return [
      o,
      l
    ];
  }
  function iTt(n, t, e, r, i, a) {
    i == null && (i = BM(n, t[0], r[0]));
    const s = [
      0,
      0,
      0,
      e
    ];
    for (let o = 0; o < 3; o++) n[o] + 2 * i >= t[o] && (s[o] = hv((n[o] - t[o] + 2 * i) / r[o] + 1, a));
    return s;
  }
  function BM(n, t, e, r = 1) {
    const i = $f(t, r);
    return Math.floor((n[0] * (e - 1) - e + i) / 2);
  }
  function cv(n) {
    return typeof n == "number" ? [
      n,
      n,
      n
    ] : n.length === 2 ? [
      n[0],
      n[1],
      1
    ] : n;
  }
  function k2(n) {
    return typeof n == "number" ? [
      n,
      n,
      n
    ] : n;
  }
  function $f(n, t) {
    return t <= 1 ? n : n + (n - 1) * (t - 1);
  }
  function aTt(n, t, e, r, i, a, s, o, l) {
    let u, c, h;
    if (typeof n == "number") {
      u = {
        top: n,
        bottom: n,
        left: n,
        right: n,
        type: n === 0 ? "VALID" : "NUMBER"
      };
      const d = rTt([
        t,
        e
      ], a, r, n, o);
      c = d[0], h = d[1];
    } else if (n === "same") {
      c = Math.ceil(t / r), h = Math.ceil(e / i);
      const f = Math.max(0, (c - 1) * r + a - t), d = Math.max(0, (h - 1) * i + s - e), p = Math.floor(f / 2), g = f - p, v = Math.floor(d / 2), m = d - v;
      u = {
        top: p,
        bottom: g,
        left: v,
        right: m,
        type: "SAME"
      };
    } else if (n === "valid") u = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      type: "VALID"
    }, c = Math.ceil((t - a + 1) / r), h = Math.ceil((e - s + 1) / i);
    else if (typeof n == "object") {
      const f = l === "channelsLast" ? n[1][0] : n[2][0], d = l === "channelsLast" ? n[1][1] : n[2][1], p = l === "channelsLast" ? n[2][0] : n[3][0], g = l === "channelsLast" ? n[2][1] : n[3][1];
      u = {
        top: f,
        bottom: d,
        left: p,
        right: g,
        type: f === 0 && d === 0 && p === 0 && g === 0 ? "VALID" : "EXPLICIT"
      }, c = hv((t - a + f + d) / r + 1, o), h = hv((e - s + p + g) / i + 1, o);
    } else throw Error(`Unknown padding parameter: ${n}`);
    return {
      padInfo: u,
      outHeight: c,
      outWidth: h
    };
  }
  function sTt(n, t, e, r, i, a, s, o, l, u, c) {
    let h, f, d, p;
    if (n === "valid" && (n = 0), typeof n == "number") {
      h = {
        top: n,
        bottom: n,
        left: n,
        right: n,
        front: n,
        back: n,
        type: n === 0 ? "VALID" : "NUMBER"
      };
      const v = iTt([
        t,
        e,
        r,
        1
      ], [
        o,
        l,
        u
      ], 1, [
        i,
        a,
        s
      ], n, c);
      f = v[0], d = v[1], p = v[2];
    } else if (n === "same") {
      f = Math.ceil(t / i), d = Math.ceil(e / a), p = Math.ceil(r / s);
      const g = (f - 1) * i + o - t, v = (d - 1) * a + l - e, m = (p - 1) * s + u - r, y = Math.floor(g / 2), x = g - y, b = Math.floor(v / 2), _ = v - b, w = Math.floor(m / 2), S = m - w;
      h = {
        top: b,
        bottom: _,
        left: w,
        right: S,
        front: y,
        back: x,
        type: "SAME"
      };
    } else throw Error(`Unknown padding parameter: ${n}`);
    return {
      padInfo: h,
      outDepth: f,
      outHeight: d,
      outWidth: p
    };
  }
  function hv(n, t) {
    if (!t) return Math.trunc(n);
    switch (t) {
      case "round":
        return Math.round(n);
      case "ceil":
        return Math.ceil(n);
      case "floor":
        return Math.floor(n);
      default:
        throw new Error(`Unknown roundingMode ${t}`);
    }
  }
  function th(n) {
    const [t, e, r] = cv(n);
    return t === 1 && e === 1 && r === 1;
  }
  function Rr(n, t) {
    return th(n) || th(t);
  }
  function eh(n) {
    return cv(n).every((t) => t > 0);
  }
  function il(n) {
    if (n === "NHWC") return "channelsLast";
    if (n === "NCHW") return "channelsFirst";
    throw new Error(`Unknown dataFormat ${n}`);
  }
  function wi(n, t, e) {
    if (e != null) {
      if (typeof t == "string") throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);
      if (typeof t == "number") B(Jf(t), () => `Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);
      else if (typeof t == "object") t.forEach((r) => {
        r.forEach((i) => {
          B(Jf(i), () => `Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${i}.`);
        });
      });
      else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);
    }
  }
  function oTt(n, t) {
    const r = {
      x: W(n, "x", "reshape", "string_or_numeric")
    }, i = {
      shape: t
    };
    return K.runKernel(W_, r, i);
  }
  const Z = Q({
    reshape_: oTt
  });
  function lTt(n, t, e, r, i) {
    const a = W(n, "x", "avgPool", "float32"), s = 1;
    B(Rr(e, s), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);
    let o = a, l = false;
    a.rank === 3 && (l = true, o = Z(a, [
      1,
      a.shape[0],
      a.shape[1],
      a.shape[2]
    ])), B(o.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${o.rank}.`), wi("avgPool", r, i);
    const u = {
      x: o
    }, c = {
      filterSize: t,
      strides: e,
      pad: r,
      dimRoundingMode: i
    };
    let h = K.runKernel(a_, u, c);
    return h = Et(h, a.dtype), l ? Z(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3]
    ]) : h;
  }
  const zM = Q({
    avgPool_: lTt
  });
  function uTt(n, t, e, r, i, a = "NDHWC") {
    const s = W(n, "x", "avgPool3d", "float32");
    let o = s, l = false;
    s.rank === 4 && (l = true, o = Z(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2],
      s.shape[3]
    ])), B(o.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`), B(a === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`), B(typeof e == "number" && e > 0 || Array.isArray(e) && e[0] > 0 && e[1] > 0 && e[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${e}'`), wi("avgPool3d", r, i);
    const u = {
      x: o
    }, c = {
      filterSize: t,
      strides: e,
      pad: r,
      dimRoundingMode: i,
      dataFormat: a
    };
    let h = K.runKernel(s_, u, c);
    return h = Et(h, o.dtype), l ? Z(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3],
      h.shape[4]
    ]) : h;
  }
  const cTt = Q({
    avgPool3d_: uTt
  });
  function hTt(n, t = 0) {
    B(n.length >= 1, () => "Pass at least one tensor to concat");
    const e = Pq(n, "tensors", "concat", "string_or_numeric");
    if (e[0].dtype === "complex64" && e.forEach((a) => {
      if (a.dtype !== "complex64") throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `);
    }), e.length === 1) return Bc(e[0]);
    const r = e, i = {
      axis: t
    };
    return K.runKernel(c_, r, i);
  }
  const pi = Q({
    concat_: hTt
  });
  function fTt(n, t, e = false, r = false) {
    let i = W(n, "a", "matMul"), a = W(t, "b", "matMul");
    [i, a] = Mn(i, a);
    const s = {
      a: i,
      b: a
    }, o = {
      transposeA: e,
      transposeB: r
    };
    return K.runKernel(o_, s, o);
  }
  const Ge = Q({
    matMul_: fTt
  });
  function dTt(n) {
    const e = {
      x: W(n, "x", "sigmoid", "float32")
    };
    return K.runKernel(Bm, e);
  }
  const $d = Q({
    sigmoid_: dTt
  });
  function pTt(n, t, e) {
    const r = W(n, "x", "slice", "string_or_numeric");
    if (r.rank === 0) throw new Error("Slicing scalar is not possible");
    const i = {
      x: r
    }, a = {
      begin: t,
      size: e
    };
    return K.runKernel(q_, i, a);
  }
  const hn = Q({
    slice_: pTt
  });
  function gTt(n) {
    const e = {
      x: W(n, "x", "tanh", "float32")
    };
    return K.runKernel(Hm, e);
  }
  const sw = Q({
    tanh_: gTt
  });
  function vTt(n, t, e) {
    const r = W(n, "x", "batchToSpaceND"), i = t.reduce((o, l) => o * l);
    B(r.rank >= 1 + t.length, () => `input rank is ${r.rank} but should be > than blockShape.length ${t.length}`), B(e.length === t.length, () => `crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`), B(r.shape[0] % i === 0, () => `input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`);
    const a = {
      x: r
    }, s = {
      blockShape: t,
      crops: e
    };
    return K.runKernel(l_, a, s);
  }
  const VM = Q({
    batchToSpaceND_: vTt
  });
  function mTt(n) {
    let t;
    return n.rank === 0 || n.rank === 1 ? t = Z(n, [
      1,
      1,
      1,
      n.size
    ]) : n.rank === 2 ? t = Z(n, [
      1,
      1,
      n.shape[0],
      n.shape[1]
    ]) : n.rank === 3 ? t = Z(n, [
      1,
      n.shape[0],
      n.shape[1],
      n.shape[2]
    ]) : t = n, t;
  }
  function yTt(n, t, e, r, i, a) {
    a == null && (a = 1e-3);
    const s = W(n, "x", "batchNorm"), o = W(t, "mean", "batchNorm"), l = W(e, "variance", "batchNorm");
    let u;
    i != null && (u = W(i, "scale", "batchNorm"));
    let c;
    r != null && (c = W(r, "offset", "batchNorm")), B(o.rank === l.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), B(c == null || o.rank === c.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), B(u == null || o.rank === u.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    const f = {
      x: mTt(s),
      scale: u,
      offset: c,
      mean: o,
      variance: l
    }, d = {
      varianceEpsilon: a
    }, p = K.runKernel(x_, f, d);
    return Z(p, s.shape);
  }
  const ow = Q({
    batchNorm_: yTt
  });
  function xTt(n, t, e, r, i, a) {
    const s = W(n, "x", "batchNorm"), o = W(t, "mean", "batchNorm"), l = W(e, "variance", "batchNorm");
    let u;
    i != null && (u = W(i, "scale", "batchNorm"));
    let c;
    return r != null && (c = W(r, "offset", "batchNorm")), B(s.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${s.rank}.`), B(o.rank === 2 || o.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`), B(l.rank === 2 || l.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`), u != null && B(u.rank === 2 || u.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`), c != null && B(c.rank === 2 || c.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`), ow(s, o, l, c, u, a);
  }
  const bTt = Q({
    batchNorm2d_: xTt
  });
  function _Tt(n, t, e, r, i, a) {
    const s = W(n, "x", "batchNorm"), o = W(t, "mean", "batchNorm"), l = W(e, "variance", "batchNorm");
    let u;
    i != null && (u = W(i, "scale", "batchNorm"));
    let c;
    return r != null && (c = W(r, "offset", "batchNorm")), B(s.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${s.rank}.`), B(o.rank === 3 || o.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`), B(l.rank === 3 || l.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`), u != null && B(u.rank === 3 || u.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`), c != null && B(c.rank === 3 || c.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`), ow(s, o, l, c, u, a);
  }
  const wTt = Q({
    batchNorm3d_: _Tt
  });
  function STt(n, t, e, r, i, a) {
    const s = W(n, "x", "batchNorm"), o = W(t, "mean", "batchNorm"), l = W(e, "variance", "batchNorm");
    let u;
    i != null && (u = W(i, "scale", "batchNorm"));
    let c;
    return r != null && (c = W(r, "offset", "batchNorm")), B(s.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${s.rank}.`), B(o.rank === 4 || o.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`), B(l.rank === 4 || l.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`), u != null && B(u.rank === 4 || u.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`), c != null && B(c.rank === 4 || c.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`), ow(s, o, l, c, u, a);
  }
  const CTt = Q({
    batchNorm4d_: STt
  });
  function TTt(n, t, e) {
    const r = W(n, "x", "bincount"), i = W(t, "weights", "bincount");
    B(r.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${r.dtype}`), B(e >= 0, () => `size must be non-negative, but got ${e}.`), B(i.size === r.size || i.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`);
    const a = {
      x: r,
      weights: i
    }, s = {
      size: e
    };
    return K.runKernel(eM, a, s);
  }
  const ITt = Q({
    bincount_: TTt
  });
  function ATt(n, t) {
    let e = W(n, "broadcastTo", "x");
    const r = e.shape;
    if (nl(t), t.length < e.rank) throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);
    if (t.length > e.rank) {
      const u = e.shape.slice();
      for (; u.length < t.length; ) u.unshift(1);
      e = Z(e, u);
    }
    const i = e.shape, a = Array.from(t);
    for (let u = t.length - 1; u >= 0; u--) if (i[u] === t[u]) a[u] = 1;
    else if (e.shape[u] !== 1) throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);
    if (a.map((u, c) => u > 1 ? c : -1).filter((u) => u >= 0).length === 0) return Bc(e);
    const o = {
      x: e
    }, l = {
      reps: a
    };
    return K.runKernel(Xm, o, l);
  }
  const wg = Q({
    broadcastTo_: ATt
  });
  function kTt(n) {
    const e = {
      x: W(n, "x", "ceil", "float32")
    };
    return K.runKernel(om, e);
  }
  const DTt = Q({
    ceil_: kTt
  });
  function lw(n, t, e) {
    nl(n), e = e || Rd(t);
    const r = {
      shape: n,
      value: t,
      dtype: e
    };
    return K.runKernel(vM, {}, r);
  }
  function ETt(n, t, e) {
    const r = W(n, "x", "clipByValue");
    if (B(t <= e, () => `Error in clip: min (${t}) must be less than or equal to max (${e}).`), t === e) return lw(r.shape, t, r.dtype);
    const i = {
      x: r
    }, a = {
      clipValueMin: t,
      clipValueMax: e
    };
    return K.runKernel(lm, i, a);
  }
  const Ji = Q({
    clipByValue_: ETt
  });
  function MTt(n) {
    return pi(n, 0);
  }
  const RTt = Q({
    concat1d_: MTt
  });
  function NTt(n, t) {
    return pi(n, t);
  }
  const LTt = Q({
    concat2d_: NTt
  });
  function PTt(n, t) {
    return pi(n, t);
  }
  const $Tt = Q({
    concat3d_: PTt
  });
  function OTt(n, t) {
    return pi(n, t);
  }
  const FTt = Q({
    concat4d_: OTt
  });
  function BTt(n, t, e, r, i = "NHWC", a = [
    1,
    1
  ], s) {
    const o = W(n, "x", "conv2d", "float32"), l = W(t, "filter", "conv2d", "float32");
    let u = o, c = false;
    o.rank === 3 && (c = true, u = Z(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2]
    ])), B(u.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${u.rank}.`), B(l.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`), wi("conv2d", r, s);
    const h = i === "NHWC" ? u.shape[3] : u.shape[1];
    B(h === l.shape[2], () => `Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`), B(Rr(e, a), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`), B(eh(a), () => "Error in conv2D: Dilated rates should be larger than 0."), B(eh(e), () => "Error in conv2D: Strides should be larger than 0.");
    const f = {
      x: u,
      filter: l
    }, d = {
      strides: e,
      pad: r,
      dataFormat: i,
      dilations: a,
      dimRoundingMode: s
    }, p = K.runKernel(h_, f, d);
    return c ? Z(p, [
      p.shape[1],
      p.shape[2],
      p.shape[3]
    ]) : p;
  }
  const nh = Q({
    conv2d_: BTt
  });
  function zTt(n, t, e, r, i = "NWC", a = 1, s) {
    const o = W(n, "x", "conv1d"), l = W(t, "filter", "conv1d");
    let u = o, c = false;
    o.rank === 2 && (c = true, u = Z(o, [
      1,
      o.shape[0],
      o.shape[1]
    ])), B(u.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${u.rank}.`), B(l.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`), wi("conv1d", r, s), B(u.shape[2] === l.shape[1], () => `Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`), B(Rr(e, a), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${a}'`), B(eh(a), () => "Error in conv1D: Dilated rates should be larger than 0."), B(eh(e), () => "Error in conv1D: Stride should be larger than 0."), B(i === "NWC", () => `Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);
    const h = Z(l, [
      1,
      l.shape[0],
      l.shape[1],
      l.shape[2]
    ]), f = Z(u, [
      u.shape[0],
      1,
      u.shape[1],
      u.shape[2]
    ]), v = nh(f, h, [
      1,
      e
    ], r, "NHWC", [
      1,
      a
    ], s);
    return c ? Z(v, [
      v.shape[2],
      v.shape[3]
    ]) : Z(v, [
      v.shape[0],
      v.shape[2],
      v.shape[3]
    ]);
  }
  const Yq = Q({
    conv1d_: zTt
  });
  function VTt(n, t, e, r, i, a = "NHWC", s) {
    B(n.length === t.rank, () => `Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);
    let o = n, l = t, u = false;
    t.rank === 3 && (u = true, l = Z(t, [
      1,
      t.shape[0],
      t.shape[1],
      t.shape[2]
    ]), o = [
      1,
      n[0],
      n[1],
      n[2]
    ]), B(o.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`), B(l.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`), B(e.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);
    const c = a === "NHWC" ? o[3] : o[1], h = a === "NHWC" ? l.shape[3] : l.shape[1];
    B(c === e.shape[2], () => `Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`), B(h === e.shape[3], () => `Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[3]}.`), wi("conv2dDerInput", i, s);
    const f = {
      dy: l,
      filter: e
    }, d = {
      strides: r,
      pad: i,
      dataFormat: a,
      dimRoundingMode: s,
      inputShape: o
    }, p = K.runKernel(f_, f, d);
    return u ? Z(p, [
      p.shape[1],
      p.shape[2],
      p.shape[3]
    ]) : p;
  }
  const GM = Q({
    conv2DBackpropInput_: VTt
  });
  function GTt(n, t, e, r, i, a) {
    const s = W(n, "x", "conv2dTranspose"), o = W(t, "filter", "conv2dTranspose");
    return GM(e, s, o, r, i, "NHWC", a);
  }
  const qq = Q({
    conv2dTranspose_: GTt
  });
  function WTt(n, t, e, r, i = "NDHWC", a = [
    1,
    1,
    1
  ]) {
    const s = W(n, "x", "conv3d"), o = W(t, "filter", "conv3d");
    let l = s, u = false;
    s.rank === 4 && (u = true, l = Z(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2],
      s.shape[3]
    ])), B(l.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${l.rank}.`), B(o.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`), B(l.shape[4] === o.shape[3], () => `Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`), B(Rr(e, a), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`), B(i === "NDHWC", () => `Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`), B(eh(a), () => "Error in conv3D: Dilated rates should be larger than 0."), B(eh(e), () => "Error in conv3D: Strides should be larger than 0.");
    const c = {
      x: l,
      filter: o
    }, h = {
      strides: e,
      pad: r,
      dataFormat: i,
      dilations: a
    }, f = K.runKernel(d_, c, h);
    return u ? Z(f, [
      f.shape[1],
      f.shape[2],
      f.shape[3],
      f.shape[4]
    ]) : f;
  }
  const UTt = Q({
    conv3d_: WTt
  });
  function HTt(n, t, e, r, i) {
    B(n.length === t.rank, () => `Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);
    let a = n, s = t, o = false;
    t.rank === 4 && (o = true, s = Z(t, [
      1,
      t.shape[0],
      t.shape[1],
      t.shape[2],
      t.shape[3]
    ]), a = [
      1,
      n[0],
      n[1],
      n[2],
      n[3]
    ]);
    const l = a[4], u = s.shape[4];
    B(a.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`), B(s.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`), B(e.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`), B(l === e.shape[3], () => `Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`), B(u === e.shape[4], () => `Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);
    const c = {
      dy: s,
      filter: e
    }, h = {
      pad: i,
      strides: r,
      inputShape: a
    }, f = K.runKernel(sM, c, h);
    return o ? Z(f, [
      f.shape[1],
      f.shape[2],
      f.shape[3],
      f.shape[4]
    ]) : f;
  }
  const jq = Q({
    conv3DBackpropInput_: HTt
  });
  function XTt(n, t, e, r, i) {
    const a = W(n, "x", "conv3dTranspose"), s = W(t, "filter", "conv3dTranspose");
    return jq(e, a, s, r, i);
  }
  const YTt = Q({
    conv3dTranspose_: XTt
  });
  function qTt(n) {
    const e = {
      x: W(n, "x", "cos", "float32")
    };
    return K.runKernel(um, e);
  }
  const WM = Q({
    cos_: qTt
  });
  function jTt(n) {
    const e = {
      x: W(n, "x", "cosh", "float32")
    };
    return K.runKernel(cm, e);
  }
  const Kq = Q({
    cosh_: jTt
  });
  function KTt(n, t = 0, e = false, r = false) {
    const a = {
      x: W(n, "x", "cumprod")
    }, s = {
      axis: t,
      exclusive: e,
      reverse: r
    };
    return K.runKernel(oM, a, s);
  }
  const D2 = Q({
    cumprod_: KTt
  });
  function ZTt(n, t = 0, e = false, r = false) {
    const a = {
      x: W(n, "x", "cumsum")
    }, s = {
      axis: t,
      exclusive: e,
      reverse: r
    };
    return K.runKernel(p_, a, s);
  }
  const Zq = Q({
    cumsum_: ZTt
  });
  function JTt(n, t, e, r = false) {
    const i = W(n, "x", "denseBincount"), a = W(t, "weights", "denseBincount");
    B(i.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${i.dtype}`), B(i.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`), B(e >= 0, () => `size must be non-negative, but got ${e}.`), B(a.size === i.size || a.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${a.shape}.`);
    const s = {
      x: i,
      weights: a
    }, o = {
      size: e,
      binaryOutput: r
    };
    return K.runKernel(uM, s, o);
  }
  const Uz = Q({
    denseBincount_: JTt
  });
  function QTt(n, t, e = "NHWC") {
    const r = W(n, "x", "depthToSpace", "float32"), i = e === "NHWC" ? r.shape[1] : r.shape[2], a = e === "NHWC" ? r.shape[2] : r.shape[3], s = e === "NHWC" ? r.shape[3] : r.shape[1];
    B(t > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${t}`), B(i * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${i} and ${t}  for depthToSpace with input shape
    ${r.shape}`), B(a * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`), B(s % (t * t) === 0, () => `Dimension size must be evenly divisible by ${t * t} but is ${s} for depthToSpace with input shape ${r.shape}`);
    const o = {
      x: r
    }, l = {
      blockSize: t,
      dataFormat: e
    };
    return K.runKernel(cM, o, l);
  }
  const tIt = Q({
    depthToSpace_: QTt
  });
  function eIt(n, t, e, r, i = "NHWC", a = [
    1,
    1
  ], s) {
    const o = W(n, "x", "depthwiseConv2d", "float32"), l = W(t, "filter", "depthwiseConv2d", "float32");
    let u = o, c = false;
    o.rank === 3 && (c = true, u = Z(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2]
    ])), B(u.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`), B(l.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);
    const h = i === "NHWC" ? u.shape[3] : u.shape[1];
    B(h === l.shape[2], () => `Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`), wi("depthwiseConv2d", r, s);
    const f = {
      x: u,
      filter: l
    }, d = {
      strides: e,
      pad: r,
      dataFormat: i,
      dilations: a,
      dimRoundingMode: s
    }, p = K.runKernel(g_, f, d);
    return c ? Z(p, [
      p.shape[1],
      p.shape[2],
      p.shape[3]
    ]) : p;
  }
  const UM = Q({
    depthwiseConv2d_: eIt
  });
  function nIt(n, t, e, r, i = [
    1,
    1
  ], a = "NHWC") {
    const s = W(n, "x", "dilation2d"), o = W(t, "filter", "dilation2d");
    B(s.rank === 3 || s.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${s.rank}.`), B(o.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`), B(a === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);
    let l = s, u = false;
    s.rank === 3 && (l = Z(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2]
    ]), u = true), B(l.shape[3] === o.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);
    const c = {
      x: l,
      filter: o
    }, h = {
      strides: e,
      pad: r,
      dilations: i
    }, f = K.runKernel(v_, c, h);
    return u ? Z(f, [
      f.shape[1],
      f.shape[2],
      f.shape[3]
    ]) : f;
  }
  const rIt = Q({
    dilation2d_: nIt
  });
  function ed(n, t) {
    const e = n.length, r = [];
    for (let i = 0; i < e; i++) {
      const a = e - 1 - i, s = n[a] || 1;
      (t[t.length - 1 - i] || 1) > 1 && s === 1 && r.unshift(a);
    }
    return r;
  }
  function Jn(n, t) {
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const i = n[n.length - r - 1], a = t.length - r - 1, s = t[a];
      (i == null || i === 1 && s > 1) && e.unshift(a);
    }
    return e;
  }
  function ve(n, t) {
    const e = Math.max(n.length, t.length), r = new Array(e);
    for (let i = 0; i < e; i++) {
      let a = n[n.length - i - 1];
      a == null && (a = 1);
      let s = t[t.length - i - 1];
      if (s == null && (s = 1), a === 1) r[e - i - 1] = s;
      else if (s === 1) r[e - i - 1] = a;
      else if (a !== s) {
        const o = `Operands could not be broadcast together with shapes ${n} and ${t}.`;
        throw Error(o);
      } else r[e - i - 1] = a;
    }
    return r;
  }
  function iIt(n, t) {
    let e = W(n, "a", "equal", "string_or_numeric"), r = W(t, "b", "equal", "string_or_numeric");
    [e, r] = Mn(e, r), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(m_, i);
  }
  const io = Q({
    equal_: iIt
  });
  function aIt(n, t, e) {
    const r = W(t, "a", "where"), i = W(e, "b", "where"), a = W(n, "condition", "where", "bool"), s = ve(ve(a.shape, r.shape), i.shape), o = wg(a, s), l = wg(r, s), u = wg(i, s), c = {
      condition: o,
      t: l,
      e: u
    };
    return K.runKernel(Y_, c);
  }
  const qr = Q({
    where_: aIt
  });
  function sIt(n) {
    const e = {
      x: W(n, "x", "zerosLike")
    };
    return K.runKernel(ew, e);
  }
  const Fe = Q({
    zerosLike_: sIt
  });
  function oIt(n, t) {
    let e = W(n, "a", "div"), r = W(t, "b", "div");
    [e, r] = Mn(e, r);
    const i = Jt(e, r), a = Fe(i), s = io(r, a);
    return qr(s, a, i);
  }
  const lIt = Q({
    divNoNan_: oIt
  });
  function uIt(n, t) {
    const e = W(n, "t1", "dot"), r = W(t, "t2", "dot");
    B((e.rank === 1 || e.rank === 2) && (r.rank === 1 || r.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);
    const i = e.rank === 1 ? e.size : e.shape[1], a = r.rank === 1 ? r.size : r.shape[0];
    if (B(i === a, () => `Error in dot: inner dimensions of inputs must match, but got ${i} and ${a}.`), e.rank === 1 && r.rank === 1) {
      const s = Z(e, [
        1,
        -1
      ]), o = Z(r, [
        -1,
        1
      ]), l = Ge(s, o);
      return Z(l, []);
    } else if (e.rank === 1 && r.rank === 2) {
      const s = Z(e, [
        1,
        -1
      ]), o = Z(r, [
        r.shape[0],
        r.shape[1]
      ]), l = Ge(s, o);
      return Z(l, [
        l.size
      ]);
    } else if (e.rank === 2 && r.rank === 1) {
      const s = Z(r, [
        -1,
        1
      ]), o = Ge(e, s);
      return Z(o, [
        o.size
      ]);
    } else {
      const s = Z(r, [
        r.shape[0],
        r.shape[1]
      ]);
      return Ge(e, s);
    }
  }
  const cIt = Q({
    dot_: uIt
  });
  function hIt(n, ...t) {
    const e = t.map((i, a) => W(i, `tensors${a}`, "einsum")), r = {
      equation: n
    };
    return K.runKernel(dM, e, r);
  }
  const kp = Q({
    einsum_: hIt
  });
  function fIt(n) {
    const e = {
      x: W(n, "x", "elu", "float32")
    };
    return K.runKernel(fm, e);
  }
  const uw = Q({
    elu_: fIt
  });
  function dIt(n) {
    let t = W(n, "x", "erf");
    B(t.dtype === "int32" || t.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), t.dtype === "int32" && (t = Et(t, "float32"));
    const e = {
      x: t
    };
    return K.runKernel(dm, e);
  }
  const Jq = Q({
    erf_: dIt
  });
  function HM(n, t) {
    for (let e = 0; e < n.length; ++e) if (n[n.length - e - 1] !== t - 1 - e) return false;
    return true;
  }
  function Qq(n, t, e) {
    const r = n.length + t.length, i = [];
    let a = 0, s = 0;
    for (let o = 0; o < r; o++) e.indexOf(o) === -1 ? i.push(n[a++]) : i.push(t[s++]);
    return i;
  }
  function hr(n, t) {
    const e = [], r = n.length;
    for (let a = 0; a < r; a++) t.indexOf(a) === -1 && e.push(n[a]);
    const i = t.map((a) => n[a]);
    return [
      e,
      i
    ];
  }
  function Bn(n, t) {
    const e = t.map((r) => 1);
    return Qq(n, e, t);
  }
  function wr(n, t, e) {
    B(HM(t, e), () => `${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`);
  }
  function wn(n, t) {
    if (HM(n, t)) return null;
    const e = [];
    for (let r = 0; r < t; ++r) n.indexOf(r) === -1 && e.push(r);
    return n.forEach((r) => e.push(r)), e;
  }
  function hu(n) {
    return n.map((t, e) => [
      e,
      t
    ]).sort((t, e) => t[1] - e[1]).map((t) => t[0]);
  }
  function Rn(n, t) {
    const e = [];
    for (let r = t - n; r < t; ++r) e.push(r);
    return e;
  }
  function pIt(n, t = null, e = false) {
    const i = {
      x: W(n, "x", "max")
    }, a = {
      reductionIndices: t,
      keepDims: e
    };
    return K.runKernel(D_, i, a);
  }
  const rs = Q({
    max_: pIt
  });
  function gIt(n, t = null, e = false) {
    const i = {
      x: W(n, "x", "min")
    }, a = {
      axis: t,
      keepDims: e
    };
    return K.runKernel(N_, i, a);
  }
  const Bb = Q({
    min_: gIt
  });
  function vIt(n, t) {
    let e = W(n, "base", "pow"), r = W(t, "exp", "pow");
    [e, r] = Mn(e, r);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(Dm, i);
  }
  const rh = Q({
    pow_: vIt
  });
  function Ue(n, t) {
    if ((Aa(n) && t !== "string" || Array.isArray(n)) && t !== "complex64") throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if (t === "string" && Aa(n) && !(n instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return aw(n, [], [], t);
  }
  function mIt(n) {
    const e = {
      x: W(n, "x", "sqrt", "float32")
    };
    return K.runKernel(Vm, e);
  }
  const Mr = Q({
    sqrt_: mIt
  });
  function yIt(n) {
    const t = W(n, "x", "square"), e = {};
    return K.runKernel("Square", {
      x: t
    }, e);
  }
  const gn = Q({
    square_: yIt
  });
  function xIt(n, t = null, e = false) {
    let r = W(n, "x", "sum");
    r.dtype === "bool" && (r = Et(r, "int32"));
    const i = {
      x: r
    }, a = {
      axis: t,
      keepDims: e
    };
    return K.runKernel(j_, i, a);
  }
  const Kt = Q({
    sum_: xIt
  });
  function bIt(n, t = "euclidean", e = null, r = false) {
    n = W(n, "x", "norm");
    const i = tj(n, t, e);
    let a = i.shape;
    if (r) {
      const s = Se(e, n.shape);
      a = Bn(i.shape, s);
    }
    return Z(i, a);
  }
  function tj(n, t, e = null) {
    if (n.rank === 0) return Gr(n);
    if (n.rank !== 1 && e === null) return tj(Z(n, [
      -1
    ]), t, e);
    if (n.rank === 1 || typeof e == "number" || Array.isArray(e) && e.length === 1) {
      if (t === 1) return Kt(Gr(n), e);
      if (t === 1 / 0) return rs(Gr(n), e);
      if (t === -1 / 0) return Bb(Gr(n), e);
      if (t === "euclidean" || t === 2) return Mr(Kt(rh(Gr(n), Ue(2, "int32")), e));
      throw new Error(`Error in norm: invalid ord value: ${t}`);
    }
    if (Array.isArray(e) && e.length === 2) {
      if (t === 1) return rs(Kt(Gr(n), e[0]), e[1] - 1);
      if (t === 1 / 0) return rs(Kt(Gr(n), e[1]), e[0]);
      if (t === -1 / 0) return Bb(Kt(Gr(n), e[1]), e[0]);
      if (t === "fro" || t === "euclidean") return Mr(Kt(gn(n), e));
      throw new Error(`Error in norm: invalid ord value: ${t}`);
    }
    throw new Error(`Error in norm: invalid axis: ${e}`);
  }
  const cw = Q({
    norm_: bIt
  });
  function _It(n, t = null, e = false) {
    return cw(n, "euclidean", t, e);
  }
  const wIt = Q({
    euclideanNorm_: _It
  });
  function SIt(n) {
    const e = {
      x: W(n, "x", "exp")
    };
    return K.runKernel(pm, e);
  }
  const ao = Q({
    exp_: SIt
  });
  function CIt(n, t = 0) {
    const e = W(n, "x", "expandDims", "string_or_numeric");
    B(t <= e.rank, () => "Axis must be <= rank of the tensor");
    const r = {
      input: e
    }, i = {
      dim: t
    };
    return K.runKernel(y_, r, i);
  }
  const li = Q({
    expandDims_: CIt
  });
  function TIt(n) {
    const e = {
      x: W(n, "x", "expm1")
    };
    return K.runKernel(gm, e);
  }
  const IIt = Q({
    expm1_: TIt
  });
  function AIt(n, t) {
    const e = W(n, "x", "tile", "string_or_numeric");
    B(e.rank === t.length, () => `Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);
    const r = {
      x: e
    }, i = {
      reps: t
    };
    return K.runKernel(Xm, r, i);
  }
  const Za = Q({
    tile_: AIt
  });
  function kIt(n, t, e, r = "float32") {
    t == null && (t = n);
    const i = we([
      n,
      t
    ], r), a = n <= t ? n : t;
    for (let o = 0; o < a; ++o) i.set(1, o, o);
    const s = Z(i.toTensor(), [
      n,
      t
    ]);
    if (e == null) return s;
    if (e.length === 1) return Za(li(s, 0), [
      e[0],
      1,
      1
    ]);
    if (e.length === 2) return Za(li(li(s, 0), 0), [
      e[0],
      e[1],
      1,
      1
    ]);
    if (e.length === 3) return Za(li(li(li(s, 0), 0), 0), [
      e[0],
      e[1],
      e[2],
      1,
      1
    ]);
    throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`);
  }
  const ej = Q({
    eye_: kIt
  });
  function DIt(n) {
    const e = {
      x: W(n, "x", "floor", "float32")
    };
    return K.runKernel(vm, e);
  }
  const hw = Q({
    floor_: DIt
  });
  function EIt(n, t, e = 0, r = 0) {
    const i = W(n, "x", "gather"), a = W(t, "indices", "gather", "int32"), s = {
      x: i,
      indices: a
    }, o = {
      axis: e,
      batchDims: r
    };
    return K.runKernel(b_, s, o);
  }
  const XM = Q({
    gather_: EIt
  });
  function MIt(n, t) {
    let e = W(n, "a", "greater", "string_or_numeric"), r = W(t, "b", "greater", "string_or_numeric");
    [e, r] = Mn(e, r), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(__, i);
  }
  const ea = Q({
    greater_: MIt
  });
  function RIt(n, t) {
    let e = W(n, "a", "greaterEqual", "string_or_numeric"), r = W(t, "b", "greaterEqual", "string_or_numeric");
    [e, r] = Mn(e, r), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(ym, i);
  }
  const _h = Q({
    greaterEqual_: RIt
  });
  function NIt(n) {
    const e = {
      input: W(n, "input", "imag")
    };
    return K.runKernel(xM, e);
  }
  const YM = Q({
    imag_: NIt
  });
  function LIt(n) {
    const e = {
      x: W(n, "x", "isFinite")
    };
    return K.runKernel(bm, e);
  }
  const PIt = Q({
    isFinite_: LIt
  });
  function $It(n) {
    const e = {
      x: W(n, "x", "isInf")
    };
    return K.runKernel(_m, e);
  }
  const OIt = Q({
    isInf_: $It
  });
  function FIt(n) {
    const e = {
      x: W(n, "x", "isNaN")
    };
    return K.runKernel(wm, e);
  }
  const BIt = Q({
    isNaN_: FIt
  });
  function zIt(n, t = 0.2) {
    const r = {
      x: W(n, "x", "leakyRelu")
    }, i = {
      alpha: t
    };
    return K.runKernel(w_, r, i);
  }
  const qM = Q({
    leakyRelu_: zIt
  });
  function VIt(n, t) {
    let e = W(n, "a", "less", "string_or_numeric"), r = W(t, "b", "less", "string_or_numeric");
    [e, r] = Mn(e, r), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(S_, i);
  }
  const zb = Q({
    less_: VIt
  });
  function GIt(n, t) {
    let e = W(n, "a", "lessEqual", "string_or_numeric"), r = W(t, "b", "lessEqual", "string_or_numeric");
    [e, r] = Mn(e, r), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(C_, i);
  }
  const Od = Q({
    lessEqual_: GIt
  });
  function WIt(n, t = 5, e = 1, r = 1, i = 0.5) {
    const a = W(n, "x", "localResponseNormalization");
    B(a.rank === 4 || a.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`), B(Jf(t), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);
    let s = a, o = false;
    a.rank === 3 && (o = true, s = Z(a, [
      1,
      a.shape[0],
      a.shape[1],
      a.shape[2]
    ]));
    const l = {
      x: s
    }, u = {
      depthRadius: t,
      bias: e,
      alpha: r,
      beta: i
    }, c = K.runKernel(k_, l, u);
    return o ? Z(c, [
      c.shape[1],
      c.shape[2],
      c.shape[3]
    ]) : c;
  }
  const UIt = Q({
    localResponseNormalization_: WIt
  });
  function HIt(n) {
    const e = {
      x: W(n, "x", "log", "float32")
    };
    return K.runKernel(Sm, e);
  }
  const so = Q({
    log_: HIt
  });
  function XIt(n) {
    const e = {
      x: W(n, "x", "log1p")
    };
    return K.runKernel(Cm, e);
  }
  const nj = Q({
    log1p_: XIt
  });
  function YIt(n, t) {
    B(p2(n), () => "The f passed in variableGrads(f) must be a function"), B(t == null || Array.isArray(t) && t.every((u) => u instanceof Fb), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
    const e = t != null;
    if (!e) {
      t = [];
      for (const u in K.registeredVariables) t.push(K.registeredVariables[u]);
    }
    const r = e ? t.filter((u) => !u.trainable) : null, i = t.length;
    t = t.filter((u) => u.trainable), B(t.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);
    const a = true, { value: s, grads: o } = K.gradients(n, t, null, a);
    B(o.some((u) => u != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), B(s.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);
    const l = {};
    return t.forEach((u, c) => {
      o[c] != null && (l[u.name] = o[c]);
    }), r == null ? void 0 : r.forEach((u) => l[u.name] = null), {
      value: s,
      grads: l
    };
  }
  function nd(n) {
    return K.customGrad(n);
  }
  function qIt(n) {
    const e = {
      x: W(n, "x", "neg")
    };
    return K.runKernel(P_, e);
  }
  const En = Q({
    neg_: qIt
  });
  function jIt(n) {
    const e = {
      x: W(n, "x", "softplus")
    };
    return K.runKernel(zm, e);
  }
  const jm = Q({
    softplus_: jIt
  });
  function KIt(n) {
    const t = W(n, "x", "logSigmoid");
    return nd((r) => ({
      value: En(jm(En(r))),
      gradFunc: (s) => j(s, $d(En(r)))
    }))(t);
  }
  const ZIt = Q({
    logSigmoid_: KIt
  });
  function JIt(n, t) {
    let e = W(n, "a", "sub"), r = W(t, "b", "sub");
    [e, r] = Mn(e, r);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(Wm, i);
  }
  const re = Q({
    sub_: JIt
  });
  function QIt(n, t = -1) {
    const e = W(n, "logits", "logSoftmax");
    if (t === -1 && (t = e.rank - 1), t !== e.rank - 1) throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);
    return nd((i, a) => {
      const o = rs(i, t, true), l = re(i, o), u = re(Et(l, "float32"), so(Kt(ao(l), t, true)));
      return a([
        u
      ]), {
        value: u,
        gradFunc: (h, f) => {
          const [d] = f, p = true, g = ao(d);
          return re(h, j(Kt(h, t, p), g));
        }
      };
    })(e);
  }
  const rj = Q({
    logSoftmax_: QIt
  });
  function tAt(n, t = null, e = false) {
    const r = W(n, "x", "logSumExp"), i = Se(t, r.shape), a = rs(r, i, true), s = re(r, a), o = ao(s), l = Kt(o, i), u = so(l), c = bt(Z(a, u.shape), u);
    if (e) {
      const h = Bn(c.shape, i);
      return Z(c, h);
    }
    return c;
  }
  const ij = Q({
    logSumExp_: tAt
  });
  function eAt(n, t) {
    const e = W(n, "a", "logicalAnd", "bool"), r = W(t, "b", "logicalAnd", "bool");
    ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(T_, i);
  }
  const qo = Q({
    logicalAnd_: eAt
  });
  function nAt(n) {
    const e = {
      x: W(n, "x", "logicalNot", "bool")
    };
    return K.runKernel(I_, e);
  }
  const jM = Q({
    logicalNot_: nAt
  });
  function rAt(n, t) {
    const e = W(n, "a", "logicalOr", "bool"), r = W(t, "b", "logicalOr", "bool");
    ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(A_, i);
  }
  const aj = Q({
    logicalOr_: rAt
  });
  function iAt(n, t) {
    const e = W(n, "a", "logicalXor", "bool"), r = W(t, "b", "logicalXor", "bool");
    return ve(e.shape, r.shape), qo(aj(n, t), jM(qo(n, t)));
  }
  const aAt = Q({
    logicalXor_: iAt
  });
  function sAt(n, t, e, r, i) {
    const a = W(n, "x", "maxPool"), s = 1;
    let o = a, l = false;
    a.rank === 3 && (l = true, o = Z(a, [
      1,
      a.shape[0],
      a.shape[1],
      a.shape[2]
    ])), B(o.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${o.rank}.`), B(Rr(e, s), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`), wi("maxPool", r, i);
    const u = {
      x: o
    }, c = {
      filterSize: t,
      strides: e,
      pad: r,
      dimRoundingMode: i
    }, h = K.runKernel(E_, u, c);
    return l ? Z(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3]
    ]) : h;
  }
  const KM = Q({
    maxPool_: sAt
  });
  function oAt(n, t = [
    1,
    1,
    1
  ], e, r, i, a = "NDHWC") {
    const s = W(n, "x", "maxPool3d");
    let o = s, l = false;
    s.rank === 4 && (l = true, o = Z(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2],
      s.shape[3]
    ])), B(o.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`), B(a === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`), wi("maxPool3d", r, i);
    const u = {
      x: o
    }, c = {
      filterSize: t,
      strides: e,
      pad: r,
      dimRoundingMode: i,
      dataFormat: a
    }, h = K.runKernel(M_, u, c);
    return l ? Z(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3],
      h.shape[4]
    ]) : h;
  }
  const lAt = Q({
    maxPool3d_: oAt
  });
  function uAt(n, t) {
    let e = W(n, "a", "maximum"), r = W(t, "b", "maximum");
    [e, r] = Mn(e, r), e.dtype === "bool" && (e = Et(e, "int32"), r = Et(r, "int32")), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(Tm, i);
  }
  const fu = Q({
    maximum_: uAt
  });
  function cAt(n, t = null, e = false) {
    const i = {
      x: W(n, "x", "mean")
    }, a = {
      axis: t,
      keepDims: e
    };
    return K.runKernel(R_, i, a);
  }
  const $n = Q({
    mean_: cAt
  });
  function rr(n, t = "float32") {
    if (nl(n), t === "complex64") {
      const r = rr(n, "float32"), i = rr(n, "float32");
      return td(r, i);
    }
    const e = Er(lt(n), t);
    return K.makeTensor(e, n, t);
  }
  function du(n, t = "float32") {
    if (nl(n), t === "complex64") {
      const r = du(n, "float32"), i = rr(n, "float32");
      return td(r, i);
    }
    const e = YE(lt(n), t);
    return K.makeTensor(e, n, t);
  }
  function hAt(n, t) {
    let e = W(n, "a", "minimum"), r = W(t, "b", "minimum");
    [e, r] = Mn(e, r), e.dtype === "bool" && (e = Et(e, "int32"), r = Et(r, "int32")), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(Im, i);
  }
  const fv = Q({
    minimum_: hAt
  });
  function fAt(n, t, e) {
    B(e === "reflect" || e === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);
    const r = W(n, "x", "mirrorPad");
    if (r.rank === 0) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    B(t.length === r.rank, () => `Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);
    const i = e === "reflect" ? 1 : 0;
    for (let o = 0; o < r.rank; o++) B(t[o].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), B(t[o][0] >= 0 && t[o][0] <= r.shape[o] - i && t[o][1] >= 0 && t[o][1] <= r.shape[o] - i, () => `Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o] - i} or less than 0 for input of shape ${r.shape}`);
    const a = {
      paddings: t,
      mode: e
    }, s = {
      x: r
    };
    return K.runKernel(L_, s, a);
  }
  const dAt = Q({
    mirrorPad_: fAt
  });
  function pAt(n, t) {
    let e = W(n, "a", "mod"), r = W(t, "b", "mod");
    [e, r] = Mn(e, r);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel(Am, i);
  }
  const gAt = Q({
    mod_: pAt
  });
  function vAt(n, t = null, e = false) {
    n = W(n, "x", "moments");
    const r = Se(t, n.shape), i = $n(n, r, e);
    let a = i.shape;
    e || (a = Bn(i.shape, r));
    const s = gn(re(Et(n, "float32"), Z(i, a))), o = $n(s, r, e);
    return {
      mean: i,
      variance: o
    };
  }
  const ZM = Q({
    moments_: vAt
  });
  function mAt(n, t) {
    let e = W(n, "a", "notEqual", "string_or_numeric"), r = W(t, "b", "notEqual", "string_or_numeric");
    [e, r] = Mn(e, r), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    };
    return K.runKernel($_, i);
  }
  const Vb = Q({
    notEqual_: mAt
  });
  function yAt(n, t, e = 1, r = 0, i = "int32") {
    if (t < 2) throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);
    const s = {
      indices: W(n, "indices", "oneHot", "int32")
    }, o = {
      dtype: i,
      depth: t,
      onValue: e,
      offValue: r
    };
    return K.runKernel(F_, s, o);
  }
  const sj = Q({
    oneHot_: yAt
  });
  function xAt(n) {
    const e = {
      x: W(n, "x", "onesLike")
    };
    return K.runKernel(O_, e);
  }
  const ka = Q({
    onesLike_: xAt
  });
  function bAt(n, t, e = 0) {
    const r = W(n, "x", "pad");
    if (r.rank === 0) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    const i = {
      paddings: t,
      constantValue: e
    }, a = {
      x: r
    };
    return K.runKernel(z_, a, i);
  }
  const JM = Q({
    pad_: bAt
  });
  function _At(n, t, e) {
    const r = W(n, "x", "spaceToBatchND");
    B(r.rank >= 1 + t.length, () => `input rank ${r.rank} should be > than [blockShape] ${t.length}`), B(e.length === t.length, () => `paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`), B(r.shape.reduce((s, o, l) => l > 0 && l <= t.length ? s && (o + e[l - 1][0] + e[l - 1][1]) % t[l - 1] === 0 : s, true), () => `input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);
    const i = {
      x: r
    }, a = {
      blockShape: t,
      paddings: e
    };
    return K.runKernel(K_, i, a);
  }
  const QM = Q({
    spaceToBatchND_: _At
  });
  function wAt(n, t, e, r, i, a, s) {
    i == null && (i = [
      1,
      1
    ]), a == null && (a = 1), r === 0 && (r = "valid");
    const o = W(n, "x", "maxPool");
    let l = o, u = false;
    o.rank === 3 && (u = true, l = Z(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2]
    ])), B(Rr(a, i), () => `Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${i}'`);
    const c = Ra(l.shape, t, a, i, r), h = [
      c.dilationHeight,
      c.dilationWidth
    ];
    let f;
    r === "same" ? f = CAt([
      c.filterHeight,
      c.filterWidth
    ], h) : f = [
      [
        0,
        0
      ],
      [
        0,
        0
      ]
    ];
    const d = h[0] === 1 && h[1] === 1, [p, g] = SAt([
      c.inHeight,
      c.inWidth
    ], h, f), v = d ? r : "valid", m = d ? l : QM(l, h, p), x = (e === "avg" ? () => zM(m, t, a, v, s) : () => KM(m, t, a, v, s))(), b = d ? x : VM(x, h, g);
    return u ? Z(b, [
      b.shape[1],
      b.shape[2],
      b.shape[3]
    ]) : b;
  }
  function SAt(n, t, e) {
    const r = e.map((c) => c[0]), i = e.map((c) => c[1]), a = n.concat(r, i), s = t.map((c, h) => (c - a[h] % c) % c), o = i.map((c, h) => c + s[h]), l = t.map((c, h) => [
      r[h],
      o[h]
    ]), u = t.map((c, h) => [
      0,
      s[h]
    ]);
    return [
      l,
      u
    ];
  }
  function CAt(n, t) {
    const r = n.map((s, o) => s + (s - 1) * (t[o] - 1)).map((s) => s - 1), i = r.map((s) => Math.floor(s / 2)), a = r.map((s, o) => s - i[o]);
    return r.map((s, o) => [
      i[o],
      a[o]
    ]);
  }
  const TAt = Q({
    pool_: wAt
  });
  function IAt(n, t) {
    const e = W(n, "x", "prelu"), r = W(t, "alpha", "prelu"), i = {
      x: e,
      alpha: r
    };
    return K.runKernel(V_, i);
  }
  const tR = Q({
    prelu_: IAt
  });
  function AAt(n, t = null, e = false) {
    let r = W(n, "x", "prod");
    r.dtype === "bool" && (r = Et(r, "int32"));
    const i = {
      x: r
    }, a = {
      axis: t,
      keepDims: e
    };
    return K.runKernel(G_, i, a);
  }
  const kAt = Q({
    prod_: AAt
  });
  var Cx = {
    exports: {}
  }, DAt = Cx.exports, Hz;
  function EAt() {
    return Hz || (Hz = 1, function(n) {
      (function(t, e, r) {
        function i(l) {
          var u = this, c = o();
          u.next = function() {
            var h = 2091639 * u.s0 + u.c * 23283064365386963e-26;
            return u.s0 = u.s1, u.s1 = u.s2, u.s2 = h - (u.c = h | 0);
          }, u.c = 1, u.s0 = c(" "), u.s1 = c(" "), u.s2 = c(" "), u.s0 -= c(l), u.s0 < 0 && (u.s0 += 1), u.s1 -= c(l), u.s1 < 0 && (u.s1 += 1), u.s2 -= c(l), u.s2 < 0 && (u.s2 += 1), c = null;
        }
        function a(l, u) {
          return u.c = l.c, u.s0 = l.s0, u.s1 = l.s1, u.s2 = l.s2, u;
        }
        function s(l, u) {
          var c = new i(l), h = u && u.state, f = c.next;
          return f.int32 = function() {
            return c.next() * 4294967296 | 0;
          }, f.double = function() {
            return f() + (f() * 2097152 | 0) * 11102230246251565e-32;
          }, f.quick = f, h && (typeof h == "object" && a(h, c), f.state = function() {
            return a(c, {});
          }), f;
        }
        function o() {
          var l = 4022871197, u = function(c) {
            c = String(c);
            for (var h = 0; h < c.length; h++) {
              l += c.charCodeAt(h);
              var f = 0.02519603282416938 * l;
              l = f >>> 0, f -= l, f *= l, l = f >>> 0, f -= l, l += f * 4294967296;
            }
            return (l >>> 0) * 23283064365386963e-26;
          };
          return u;
        }
        e && e.exports ? e.exports = s : this.alea = s;
      })(DAt, n);
    }(Cx)), Cx.exports;
  }
  var Tx = {
    exports: {}
  }, MAt = Tx.exports, Xz;
  function RAt() {
    return Xz || (Xz = 1, function(n) {
      (function(t, e, r) {
        function i(o) {
          var l = this, u = "";
          l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.next = function() {
            var h = l.x ^ l.x << 11;
            return l.x = l.y, l.y = l.z, l.z = l.w, l.w ^= l.w >>> 19 ^ h ^ h >>> 8;
          }, o === (o | 0) ? l.x = o : u += o;
          for (var c = 0; c < u.length + 64; c++) l.x ^= u.charCodeAt(c) | 0, l.next();
        }
        function a(o, l) {
          return l.x = o.x, l.y = o.y, l.z = o.z, l.w = o.w, l;
        }
        function s(o, l) {
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var f = u.next() >>> 11, d = (u.next() >>> 0) / 4294967296, p = (f + d) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (typeof c == "object" && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        e && e.exports ? e.exports = s : this.xor128 = s;
      })(MAt, n);
    }(Tx)), Tx.exports;
  }
  var Ix = {
    exports: {}
  }, NAt = Ix.exports, Yz;
  function LAt() {
    return Yz || (Yz = 1, function(n) {
      (function(t, e, r) {
        function i(o) {
          var l = this, u = "";
          l.next = function() {
            var h = l.x ^ l.x >>> 2;
            return l.x = l.y, l.y = l.z, l.z = l.w, l.w = l.v, (l.d = l.d + 362437 | 0) + (l.v = l.v ^ l.v << 4 ^ (h ^ h << 1)) | 0;
          }, l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.v = 0, o === (o | 0) ? l.x = o : u += o;
          for (var c = 0; c < u.length + 64; c++) l.x ^= u.charCodeAt(c) | 0, c == u.length && (l.d = l.x << 10 ^ l.x >>> 4), l.next();
        }
        function a(o, l) {
          return l.x = o.x, l.y = o.y, l.z = o.z, l.w = o.w, l.v = o.v, l.d = o.d, l;
        }
        function s(o, l) {
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var f = u.next() >>> 11, d = (u.next() >>> 0) / 4294967296, p = (f + d) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (typeof c == "object" && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        e && e.exports ? e.exports = s : this.xorwow = s;
      })(NAt, n);
    }(Ix)), Ix.exports;
  }
  var Ax = {
    exports: {}
  }, PAt = Ax.exports, qz;
  function $At() {
    return qz || (qz = 1, function(n) {
      (function(t, e, r) {
        function i(o) {
          var l = this;
          l.next = function() {
            var c = l.x, h = l.i, f, d;
            return f = c[h], f ^= f >>> 7, d = f ^ f << 24, f = c[h + 1 & 7], d ^= f ^ f >>> 10, f = c[h + 3 & 7], d ^= f ^ f >>> 3, f = c[h + 4 & 7], d ^= f ^ f << 7, f = c[h + 7 & 7], f = f ^ f << 13, d ^= f ^ f << 9, c[h] = d, l.i = h + 1 & 7, d;
          };
          function u(c, h) {
            var f, d = [];
            if (h === (h | 0)) d[0] = h;
            else for (h = "" + h, f = 0; f < h.length; ++f) d[f & 7] = d[f & 7] << 15 ^ h.charCodeAt(f) + d[f + 1 & 7] << 13;
            for (; d.length < 8; ) d.push(0);
            for (f = 0; f < 8 && d[f] === 0; ++f) ;
            for (f == 8 ? d[7] = -1 : d[f], c.x = d, c.i = 0, f = 256; f > 0; --f) c.next();
          }
          u(l, o);
        }
        function a(o, l) {
          return l.x = o.x.slice(), l.i = o.i, l;
        }
        function s(o, l) {
          o == null && (o = +/* @__PURE__ */ new Date());
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var f = u.next() >>> 11, d = (u.next() >>> 0) / 4294967296, p = (f + d) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (c.x && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        e && e.exports ? e.exports = s : this.xorshift7 = s;
      })(PAt, n);
    }(Ax)), Ax.exports;
  }
  var kx = {
    exports: {}
  }, OAt = kx.exports, jz;
  function FAt() {
    return jz || (jz = 1, function(n) {
      (function(t, e, r) {
        function i(o) {
          var l = this;
          l.next = function() {
            var c = l.w, h = l.X, f = l.i, d, p;
            return l.w = c = c + 1640531527 | 0, p = h[f + 34 & 127], d = h[f = f + 1 & 127], p ^= p << 13, d ^= d << 17, p ^= p >>> 15, d ^= d >>> 12, p = h[f] = p ^ d, l.i = f, p + (c ^ c >>> 16) | 0;
          };
          function u(c, h) {
            var f, d, p, g, v, m = [], y = 128;
            for (h === (h | 0) ? (d = h, h = null) : (h = h + "\0", d = 0, y = Math.max(y, h.length)), p = 0, g = -32; g < y; ++g) h && (d ^= h.charCodeAt((g + 32) % h.length)), g === 0 && (v = d), d ^= d << 10, d ^= d >>> 15, d ^= d << 4, d ^= d >>> 13, g >= 0 && (v = v + 1640531527 | 0, f = m[g & 127] ^= d + v, p = f == 0 ? p + 1 : 0);
            for (p >= 128 && (m[(h && h.length || 0) & 127] = -1), p = 127, g = 4 * 128; g > 0; --g) d = m[p + 34 & 127], f = m[p = p + 1 & 127], d ^= d << 13, f ^= f << 17, d ^= d >>> 15, f ^= f >>> 12, m[p] = d ^ f;
            c.w = v, c.X = m, c.i = p;
          }
          u(l, o);
        }
        function a(o, l) {
          return l.i = o.i, l.w = o.w, l.X = o.X.slice(), l;
        }
        function s(o, l) {
          o == null && (o = +/* @__PURE__ */ new Date());
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var f = u.next() >>> 11, d = (u.next() >>> 0) / 4294967296, p = (f + d) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (c.X && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        e && e.exports ? e.exports = s : this.xor4096 = s;
      })(OAt, n);
    }(kx)), kx.exports;
  }
  var Dx = {
    exports: {}
  }, BAt = Dx.exports, Kz;
  function zAt() {
    return Kz || (Kz = 1, function(n) {
      (function(t, e, r) {
        function i(o) {
          var l = this, u = "";
          l.next = function() {
            var h = l.b, f = l.c, d = l.d, p = l.a;
            return h = h << 25 ^ h >>> 7 ^ f, f = f - d | 0, d = d << 24 ^ d >>> 8 ^ p, p = p - h | 0, l.b = h = h << 20 ^ h >>> 12 ^ f, l.c = f = f - d | 0, l.d = d << 16 ^ f >>> 16 ^ p, l.a = p - h | 0;
          }, l.a = 0, l.b = 0, l.c = -1640531527, l.d = 1367130551, o === Math.floor(o) ? (l.a = o / 4294967296 | 0, l.b = o | 0) : u += o;
          for (var c = 0; c < u.length + 20; c++) l.b ^= u.charCodeAt(c) | 0, l.next();
        }
        function a(o, l) {
          return l.a = o.a, l.b = o.b, l.c = o.c, l.d = o.d, l;
        }
        function s(o, l) {
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var f = u.next() >>> 11, d = (u.next() >>> 0) / 4294967296, p = (f + d) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (typeof c == "object" && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        e && e.exports ? e.exports = s : this.tychei = s;
      })(BAt, n);
    }(Dx)), Dx.exports;
  }
  var Ex = {
    exports: {}
  };
  const VAt = {}, GAt = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: VAt
  }, Symbol.toStringTag, {
    value: "Module"
  })), WAt = PSt(GAt);
  var UAt = Ex.exports, Zz;
  function HAt() {
    return Zz || (Zz = 1, function(n) {
      (function(t, e, r) {
        var i = 256, a = 6, s = 52, o = "random", l = r.pow(i, a), u = r.pow(2, s), c = u * 2, h = i - 1, f;
        function d(b, _, w) {
          var S = [];
          _ = _ == true ? {
            entropy: true
          } : _ || {};
          var I = m(v(_.entropy ? [
            b,
            x(e)
          ] : b ?? y(), 3), S), T = new p(S), A = function() {
            for (var C = T.g(a), D = l, E = 0; C < u; ) C = (C + E) * i, D *= i, E = T.g(1);
            for (; C >= c; ) C /= 2, D /= 2, E >>>= 1;
            return (C + E) / D;
          };
          return A.int32 = function() {
            return T.g(4) | 0;
          }, A.quick = function() {
            return T.g(4) / 4294967296;
          }, A.double = A, m(x(T.S), e), (_.pass || w || function(C, D, E, M) {
            return M && (M.S && g(M, T), C.state = function() {
              return g(T, {});
            }), E ? (r[o] = C, D) : C;
          })(A, I, "global" in _ ? _.global : this == r, _.state);
        }
        function p(b) {
          var _, w = b.length, S = this, I = 0, T = S.i = S.j = 0, A = S.S = [];
          for (w || (b = [
            w++
          ]); I < i; ) A[I] = I++;
          for (I = 0; I < i; I++) A[I] = A[T = h & T + b[I % w] + (_ = A[I])], A[T] = _;
          (S.g = function(C) {
            for (var D, E = 0, M = S.i, L = S.j, k = S.S; C--; ) D = k[M = h & M + 1], E = E * i + k[h & (k[M] = k[L = h & L + D]) + (k[L] = D)];
            return S.i = M, S.j = L, E;
          })(i);
        }
        function g(b, _) {
          return _.i = b.i, _.j = b.j, _.S = b.S.slice(), _;
        }
        function v(b, _) {
          var w = [], S = typeof b, I;
          if (_ && S == "object") for (I in b) try {
            w.push(v(b[I], _ - 1));
          } catch {
          }
          return w.length ? w : S == "string" ? b : b + "\0";
        }
        function m(b, _) {
          for (var w = b + "", S, I = 0; I < w.length; ) _[h & I] = h & (S ^= _[h & I] * 19) + w.charCodeAt(I++);
          return x(_);
        }
        function y() {
          try {
            var b;
            return f && (b = f.randomBytes) ? b = b(i) : (b = new Uint8Array(i), (t.crypto || t.msCrypto).getRandomValues(b)), x(b);
          } catch {
            var _ = t.navigator, w = _ && _.plugins;
            return [
              +/* @__PURE__ */ new Date(),
              t,
              w,
              t.screen,
              x(e)
            ];
          }
        }
        function x(b) {
          return String.fromCharCode.apply(0, b);
        }
        if (m(r.random(), e), n.exports) {
          n.exports = d;
          try {
            f = WAt;
          } catch {
          }
        } else r["seed" + o] = d;
      })(typeof self < "u" ? self : UAt, [], Math);
    }(Ex)), Ex.exports;
  }
  var mT, Jz;
  function XAt() {
    if (Jz) return mT;
    Jz = 1;
    var n = EAt(), t = RAt(), e = LAt(), r = $At(), i = FAt(), a = zAt(), s = HAt();
    return s.alea = n, s.xor128 = t, s.xorwow = e, s.xorshift7 = r, s.xor4096 = i, s.tychei = a, mT = s, mT;
  }
  var eR = XAt();
  class oj {
    constructor(t, e, r, i, a) {
      this.mean = t, this.stdDev = e, this.dtype = r, this.nextVal = NaN, this.truncated = i, this.truncated && (this.upper = this.mean + this.stdDev * 2, this.lower = this.mean - this.stdDev * 2);
      const s = a || Math.random();
      this.random = eR.alea(s.toString());
    }
    nextValue() {
      if (!isNaN(this.nextVal)) {
        const i = this.nextVal;
        return this.nextVal = NaN, i;
      }
      let t, e, r = false;
      for (; !r; ) {
        let i, a, s;
        do
          i = 2 * this.random() - 1, a = 2 * this.random() - 1, s = i * i + a * a;
        while (s >= 1 || s === 0);
        const o = Math.sqrt(-2 * Math.log(s) / s);
        t = this.mean + this.stdDev * i * o, e = this.mean + this.stdDev * a * o, (!this.truncated || this.isValidTruncated(t)) && (r = true);
      }
      return (!this.truncated || this.isValidTruncated(e)) && (this.nextVal = this.convertValue(e)), this.convertValue(t);
    }
    convertValue(t) {
      return this.dtype == null || this.dtype === "float32" ? t : Math.round(t);
    }
    isValidTruncated(t) {
      return t <= this.upper && t >= this.lower;
    }
  }
  class YAt {
    constructor(t = 0, e = 1, r, i) {
      if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", this.min = t, this.range = e - t, this.dtype = r, i == null && (i = Math.random()), typeof i == "number" && (i = i.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);
      this.random = eR.alea(i);
    }
    convertValue(t) {
      return this.canReturnFloat() ? t : Math.round(t);
    }
    nextValue() {
      return this.convertValue(this.min + this.range * this.random());
    }
  }
  function qAt(n, t = 0, e = 1, r, i) {
    if (nl(n), r != null && r === "bool") throw new Error(`Unsupported data type ${r}`);
    const a = new oj(t, e, r, false, i), s = we(n, r);
    for (let o = 0; o < s.values.length; o++) s.values[o] = a.nextValue();
    return s.toTensor();
  }
  const jAt = Q({
    randomNormal_: qAt
  });
  function KAt(n, t = 0, e = 1, r = "float32", i) {
    nl(n);
    const a = we(n, r), s = new YAt(t, e, null, i);
    for (let o = 0; o < a.values.length; o++) a.values[o] = s.nextValue();
    return a.toTensor();
  }
  const Km = Q({
    randomUniform_: KAt
  });
  function dv(n, t, e = 1, r = "float32") {
    if (e === 0) throw new Error("Cannot have a step of zero");
    const i = {
      start: n,
      stop: t,
      step: e,
      dtype: r
    };
    return K.runKernel(IM, {}, i);
  }
  function ZAt(n) {
    const e = {
      input: W(n, "input", "real")
    };
    return K.runKernel(AM, e);
  }
  const Gb = Q({
    real_: ZAt
  });
  function JAt(n) {
    const e = {
      x: W(n, "x", "reciprocal")
    };
    return K.runKernel(Em, e);
  }
  const QAt = Q({
    reciprocal_: JAt
  });
  function t2t(n) {
    const e = {
      x: W(n, "x", "relu")
    };
    return K.runKernel(Mm, e);
  }
  const wh = Q({
    relu_: t2t
  });
  function e2t(n) {
    const e = {
      x: W(n, "x", "relu6")
    };
    return K.runKernel(Rm, e);
  }
  const lj = Q({
    relu6_: e2t
  });
  function n2t(n, t) {
    const r = {
      x: W(n, "x", "reverse")
    }, i = {
      dims: t
    };
    return K.runKernel(X_, r, i);
  }
  const ih = Q({
    reverse_: n2t
  });
  function r2t(n) {
    const e = {
      x: W(n, "x", "round")
    };
    return K.runKernel(Nm, e);
  }
  const uj = Q({
    round_: r2t
  });
  function i2t(n) {
    const e = {
      x: W(n, "x", "rsqrt", "float32")
    };
    return K.runKernel(Lm, e);
  }
  const cj = Q({
    rsqrt_: i2t
  });
  function a2t(n) {
    const e = {
      x: W(n, "x", "selu")
    };
    return K.runKernel(Pm, e);
  }
  const hj = Q({
    selu_: a2t
  });
  function s2t(n, t, e, r, i, a = [
    1,
    1
  ], s = "NHWC") {
    const o = W(n, "x", "separableConv2d"), l = W(t, "depthwiseFilter", "separableConv2d"), u = W(e, "pointwiseFilter", "separableConv2d");
    let c = o, h = false;
    if (o.rank === 3 && (h = true, c = Z(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2]
    ])), s === "NCHW") throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    B(c.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`), B(l.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`), B(u.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`), B(u.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`), B(u.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);
    const f = l.shape[2], d = l.shape[3];
    B(u.shape[2] === f * d, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${f * d}, but got ${u.shape[2]}.`);
    const p = UM(c, l, r, i, s, a), v = nh(p, u, 1, "valid", s);
    return h ? Z(v, [
      v.shape[1],
      v.shape[2],
      v.shape[3]
    ]) : v;
  }
  const fj = Q({
    separableConv2d_: s2t
  });
  function o2t(n) {
    const e = {
      x: W(n, "x", "sign")
    };
    return K.runKernel(Fm, e);
  }
  const l2t = Q({
    sign_: o2t
  });
  function u2t(n) {
    const e = {
      x: W(n, "x", "sin", "float32")
    };
    return K.runKernel($m, e);
  }
  const dj = Q({
    sin_: u2t
  });
  function c2t(n) {
    const e = {
      x: W(n, "x", "sinh")
    };
    return K.runKernel(Om, e);
  }
  const pj = Q({
    sinh_: c2t
  });
  function h2t(n, t, e) {
    const r = W(n, "x", "slice1d");
    return B(r.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`), hn(r, [
      t
    ], [
      e
    ]);
  }
  const nR = Q({
    slice1d_: h2t
  });
  function f2t(n, t, e) {
    const r = W(n, "x", "slice2d");
    return B(r.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`), hn(r, t, e);
  }
  const gj = Q({
    slice2d_: f2t
  });
  function d2t(n, t, e) {
    const r = W(n, "x", "slice3d");
    return B(r.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`), hn(r, t, e);
  }
  const rR = Q({
    slice3d_: d2t
  });
  function p2t(n, t, e) {
    const r = W(n, "x", "slice4d");
    return B(r.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`), hn(r, t, e);
  }
  const Wb = Q({
    slice4d_: p2t
  });
  function g2t(n, t = -1) {
    const e = W(n, "logits", "softmax", "float32");
    if (t === -1 && (t = e.rank - 1), t !== e.rank - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);
    const r = {
      logits: e
    }, i = {
      dim: t
    };
    return K.runKernel(J_, r, i);
  }
  const iR = Q({
    softmax_: g2t
  });
  function v2t(n) {
    B(n.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);
    const t = {
      input: n
    };
    return K.runKernel(gM, t);
  }
  const vj = Q({
    fft_: v2t
  });
  function m2t(n) {
    B(n.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);
    const t = {
      input: n
    };
    return K.runKernel(yM, t);
  }
  const E2 = Q({
    ifft_: m2t
  });
  function y2t(n) {
    const t = n.shape[n.shape.length - 1], e = n.size / t;
    let r;
    if (t <= 2) {
      const i = Z(n, [
        e,
        t
      ]);
      r = E2(i);
    } else {
      const i = [
        e,
        2 * (t - 1)
      ], a = Z(Gb(n), [
        e,
        t
      ]), s = Z(YM(n), [
        e,
        t
      ]), o = ih(hn(a, [
        0,
        1
      ], [
        e,
        t - 2
      ]), 1), l = j(ih(hn(s, [
        0,
        1
      ], [
        e,
        t - 2
      ]), 1), Ue(-1)), u = pi([
        a,
        o
      ], 1), c = pi([
        s,
        l
      ], 1), h = Z(td(u, c), [
        i[0],
        i[1]
      ]);
      r = E2(h);
    }
    if (r = Gb(r), n.rank === 3 && n.shape[0] !== 0) {
      const i = r, a = n.shape[0];
      r = Z(r, [
        a,
        r.shape[0] / a,
        r.shape[1]
      ]), i.dispose();
    }
    return r;
  }
  const x2t = Q({
    irfft_: y2t
  });
  function b2t(n, t, e = 0) {
    const i = {
      x: W(n, "x", "split")
    }, a = {
      numOrSizeSplits: t,
      axis: e
    };
    return K.runKernel(Z_, i, a);
  }
  const ji = Q({
    split_: b2t
  });
  function _2t(n, t) {
    B(n.dtype === "float32", () => `The dtype for rfft() must be real value but got ${n.dtype}`);
    let e = n.shape[n.shape.length - 1];
    const r = n.size / e;
    let i;
    if (t != null && t < e) {
      const p = n.shape.map((v) => 0), g = n.shape.map((v) => v);
      g[n.shape.length - 1] = t, i = hn(n, p, g), e = t;
    } else if (t != null && t > e) {
      const p = n.shape.map((g) => g);
      p[n.shape.length - 1] = t - e, i = pi([
        n,
        rr(p)
      ], n.shape.length - 1), e = t;
    } else i = n;
    const a = Fe(i), s = Z(td(i, a), [
      r,
      e
    ]), o = vj(s), l = Math.floor(e / 2) + 1, u = Gb(o), c = YM(o), h = ji(u, [
      l,
      e - l
    ], u.shape.length - 1), f = ji(c, [
      l,
      e - l
    ], c.shape.length - 1), d = i.shape.slice();
    return d[i.shape.length - 1] = l, Z(td(h[0], f[0]), d);
  }
  const w2t = Q({
    rfft_: _2t
  });
  function S2t(n, t) {
    let e = W(n, "a", "squaredDifference"), r = W(t, "b", "squaredDifference");
    [e, r] = Mn(e, r), ve(e.shape, r.shape);
    const i = {
      a: e,
      b: r
    }, a = {};
    return K.runKernel(Gm, i, a);
  }
  const C2t = Q({
    squaredDifference_: S2t
  });
  function T2t(n, t) {
    const e = W(n, "x", "squeeze", "string_or_numeric");
    return Z(e, lu(e.shape, t).newShape);
  }
  const Zm = Q({
    squeeze_: T2t
  });
  function I2t(n, t = 0) {
    const e = Pq(n, "tensors", "stack", "string_or_numeric");
    B(e.length >= 1, () => "Pass at least one tensor to tf.stack"), e.length > 0 && B(t <= e[0].rank, () => "Axis must be <= rank of the tensor");
    const r = e, i = {
      axis: t
    };
    return K.runKernel(B_, r, i);
  }
  const jo = Q({
    stack_: I2t
  });
  function A2t(n, t = 0) {
    const r = {
      x: W(n, "x", "step")
    }, i = {
      alpha: t
    };
    return K.runKernel(Ym, r, i);
  }
  const Jm = Q({
    step_: A2t
  });
  function k2t(n, t, e, r, i = 0, a = 0, s = 0, o = 0, l = 0) {
    const c = {
      x: W(n, "x", "stridedSlice", "string_or_numeric")
    }, h = {
      begin: t,
      end: e,
      strides: r,
      beginMask: i,
      endMask: a,
      ellipsisMask: s,
      newAxisMask: o,
      shrinkAxisMask: l
    };
    return K.runKernel(RM, c, h);
  }
  const D2t = Q({
    stridedSlice_: k2t
  });
  function E2t(n) {
    const e = {
      x: W(n, "x", "tan", "float32")
    };
    return K.runKernel(Um, e);
  }
  const M2t = Q({
    tan_: E2t
  });
  function Ni(n, t) {
    HY(n);
    const e = iw(n, t);
    if (e.length !== 1) throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return aw(n, null, e, t);
  }
  function yT(n, t, e) {
    if (HY(n), t != null && t.length !== 2) throw new Error("tensor2d() requires shape to have two numbers");
    const r = iw(n, e);
    if (r.length !== 2 && r.length !== 1) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (r.length === 1 && t == null) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return aw(n, t, r, e);
  }
  function mj(n, t, e) {
    const r = t.rank > 1 ? t.shape[t.rank - 1] : 1, i = t.rank > 1 ? t.rank - 1 : 1, a = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${i}.`;
    if (e.rank < i) throw new Error(a + ` update.rank < ${i}. `);
    if (n.length < r + (e.rank - i)) throw new Error(a + ` Output shape length < ${r + (e.rank - i)}`);
    if (e.rank !== i + n.length - r) throw new Error(a + ` update.rank != ${i + n.length - r}`);
    for (let s = 0; s < i; ++s) if (e.shape[s] !== t.shape[s]) throw new Error(a + ` updates.shape[${s}] (${e.shape[s]}) != indices.shape[${s}] (${t.shape[s]}).`);
    for (let s = 0; s < e.rank - i; ++s) if (e.shape[s + i] !== n[s + r]) throw new Error(a + ` updates.shape[${s + i}] (${e.shape[s + i]}) != shape[${s + i}] (${n[s + i]})`);
  }
  function R2t(n, t, e) {
    if (t.rank < 1) throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);
    if (n.rank < 1) throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);
    if (t.dtype !== "int32") throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);
    if (e.length < 1) throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);
    if (e.length === 0) {
      if (t.size === 0) throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);
      if (n.size === 0) throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`);
    }
    mj(e, t, n);
  }
  function Sh(n, t, e) {
    const r = t.shape.length, i = r > 1 ? t.shape[r - 1] : 1, a = e.length;
    let s = 1;
    for (let h = i; h < a; ++h) s *= e[h];
    const o = i < 1 ? 1 : i, l = lt(t.shape) / o, u = [
      ...Yt(e.slice(0, i)),
      1
    ], c = lt(e);
    return {
      sliceRank: i,
      numUpdates: l,
      sliceSize: s,
      strides: u,
      outputSize: c
    };
  }
  function N2t(n, t = 1, e = true) {
    const r = W(n, "x", "topk");
    if (r.rank === 0) throw new Error("topk() expects the input to be of rank 1 or higher");
    const i = r.shape[r.shape.length - 1];
    if (t < 0) throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);
    if (t > i) throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);
    const a = {
      x: r
    }, s = {
      k: t,
      sorted: e
    }, [o, l] = K.runKernel(NM, a, s);
    return {
      values: o,
      indices: l
    };
  }
  const L2t = Q({
    topk_: N2t
  });
  function P2t(n, t = 0, e = 1, r, i) {
    if (nl(n), r != null && r === "bool") throw new Error("Unsupported data type $ { dtype }");
    const a = new oj(t, e, r, true, i), s = we(n, r);
    for (let o = 0; o < s.values.length; o++) s.values[o] = a.nextValue();
    return s.toTensor();
  }
  const yj = Q({
    truncatedNormal_: P2t
  });
  function $2t(n, t = 0) {
    const e = W(n, "x", "unique", "string_or_numeric");
    B(e.rank > 0, () => "The input tensor must be at least 1D");
    const r = {
      x: e
    }, i = {
      axis: t
    }, [a, s] = K.runKernel(PM, r, i);
    return {
      values: a,
      indices: s
    };
  }
  const O2t = Q({
    unique_: $2t
  });
  function F2t(n, t, e) {
    const r = W(n, "x", "unsortedSegmentSum"), i = W(t, "segmentIds", "unsortedSegmentSum", "int32");
    B(Jf(e), () => "numSegments must be of dtype int");
    const a = {
      x: r,
      segmentIds: i
    }, s = {
      numSegments: e
    };
    return K.runKernel(tw, a, s);
  }
  const xj = Q({
    unsortedSegmentSum_: F2t
  });
  function B2t(n, t = 0) {
    const e = W(n, "x", "unstack", "string_or_numeric");
    B(t >= -e.shape.length && t < e.shape.length, () => `Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);
    const r = {
      value: e
    }, i = {
      axis: t
    };
    return K.runKernel(Q_, r, i);
  }
  const ah = Q({
    unstack_: B2t
  });
  function z2t(n, t = true, e, r) {
    return K.makeVariable(n, t, e, r);
  }
  function bj(n, t) {
    const e = [];
    for (let a = 0; a < t.length; a++) t[a] && e.push(a);
    const r = we(n, "int32"), i = we([
      e.length,
      n.length
    ], "int32");
    for (let a = 0; a < e.length; a++) {
      const s = r.indexToLoc(e[a]), o = a * n.length;
      i.values.set(s, o);
    }
    return i.toTensor();
  }
  function V2t(n, t, e) {
    const r = W(n, "x", "transpose");
    if (t == null && (t = r.shape.map((s, o) => o).reverse()), B(r.rank === t.length, () => `Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`), t.forEach((s) => {
      B(s >= 0 && s < r.rank, () => `All entries in 'perm' must be between 0 and ${r.rank - 1} but got ${t}`);
    }), r.rank <= 1) return r.clone();
    const i = {
      x: r
    }, a = {
      perm: t
    };
    return r.dtype === "complex64" ? tt(() => {
      let s = Gb(r), o = YM(r);
      return s = K.runKernel(Pf, {
        x: s
      }, a), o = K.runKernel(Pf, {
        x: o
      }, a), e && (o = En(o)), td(s, o);
    }) : K.runKernel(Pf, i, a);
  }
  const Oe = Q({
    transpose_: V2t
  });
  function G2t(n, t) {
    if (t == null) return n.shape.slice();
    if (Xe(n.shape, t)) return t;
    if (n.shape.length === t.length) {
      const e = [];
      for (let r = 0; r < n.shape.length; r++) t[r] == null && n.shape[r] != null ? e.push(n.shape[r]) : e.push(t[r]);
      return e;
    }
    return t;
  }
  function W2t(n, t, e, r) {
    const i = W(n, "x", "dropout");
    if (B(i.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`), B(t >= 0 && t < 1, () => `rate must be a float in the range [0, 1), but got ${t}.`), t === 0) return n instanceof Vn ? i.clone() : i;
    const a = G2t(i, e), s = 1 - t, o = Jt(hw(bt(Km(a, 0, 1, "float32", r), s)), s);
    return j(i, o);
  }
  const U2t = Q({
    dropout_: W2t
  });
  function H2t(n, t, e, r, i, a = "NHWC", s) {
    let o = n;
    n.rank === 3 && (o = Z(n, [
      1,
      n.shape[0],
      n.shape[1],
      n.shape[2]
    ]));
    let l = t;
    l.rank === 3 && (l = Z(t, [
      1,
      t.shape[0],
      t.shape[1],
      t.shape[2]
    ])), B(o.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`), B(l.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`), B(e.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);
    const u = a === "NHWC" ? o.shape[3] : o.shape[1], c = a === "NHWC" ? l.shape[3] : l.shape[1];
    B(u === e[2], () => `Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`), B(c === e[3], () => `Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`), wi("conv2dDerFilter", i, s);
    const h = {
      x: o,
      dy: l
    }, f = {
      strides: r,
      pad: i,
      dataFormat: a,
      dimRoundingMode: s,
      filterShape: e
    };
    return K.runKernel(iM, h, f);
  }
  const aR = Q({
    conv2DBackpropFilter_: H2t
  });
  function sR(n, t, e) {
    if (e == null || e === "linear") return n;
    if (e === "relu") return j(n, Jm(t));
    throw new Error(`Cannot compute gradient for fused activation ${e}.`);
  }
  function oR(n, t) {
    let e = t;
    const r = Jn(n.shape, t.shape);
    return r.length > 0 && (e = Kt(e, r)), Z(e, n.shape);
  }
  function lR(n, t, e, r) {
    if (t === "linear") return n;
    if (t === "relu") return wh(n);
    if (t === "elu") return uw(n);
    if (t === "relu6") return lj(n);
    if (t === "prelu") return tR(n, e);
    if (t === "leakyrelu") return qM(n, r);
    if (t === "sigmoid") return $d(n);
    throw new Error(`Unknown fused activation ${t}.`);
  }
  const uR = (n, t) => !(n > 0) || t === "linear";
  function X2t({ x: n, filter: t, strides: e, pad: r, dataFormat: i = "NHWC", dilations: a = [
    1,
    1
  ], dimRoundingMode: s, bias: o, activation: l = "linear", preluActivationWeights: u, leakyreluAlpha: c }) {
    if (l = l || "linear", uR(K.state.gradientDepth, l) === false) {
      B(i === "NHWC", () => `Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
      let w = nh(n, t, e, r, i, a, s);
      return o != null && (w = bt(w, o)), lR(w, l, u, c);
    }
    const h = W(n, "x", "conv2d", "float32"), f = W(t, "filter", "conv2d", "float32");
    let d = h, p = false;
    h.rank === 3 && (p = true, d = Z(h, [
      1,
      h.shape[0],
      h.shape[1],
      h.shape[2]
    ])), B(d.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`), B(f.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`), wi("fused conv2d", r, s);
    const g = i === "NHWC" ? d.shape[3] : d.shape[1];
    B(f.shape[2] === g, () => `Error in conv2d: depth of input (${g}) must match input depth for filter ${f.shape[2]}.`), B(Rr(e, a), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`);
    const v = _r(d.shape, f.shape, e, a, r, s);
    let m;
    o != null && (m = W(o, "bias", "fused conv2d"), [m] = Mn(m, h), i === "NHWC" ? ve(v.outShape, m.shape) : (B(m.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${m.shape.length}.`), B(m.shape.length === 0 || m.shape[0] === v.outChannels || m.shape[0] === 1, () => `Error in fused conv2d: bias shape (${m.shape}) is not compatible with the number of output channels (${v.outChannels})`)));
    let y;
    if (u != null) {
      const w = u.shape;
      if (B(w.length <= 1 || w.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${w.length}.`), w.length === 1) B(w[0] === 1 || w[0] === v.outChannels, () => `Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the number of output channels (${v.outChannels}).`);
      else if (w.length === 3) try {
        ve(w, v.outShape);
      } catch {
        const I = `Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the output shape of the conv2d (${v.outShape}).`;
        throw Error(I);
      }
      y = W(u, "prelu weights", "fused conv2d");
    }
    const x = (w, S) => {
      B(i === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);
      const [I, T, A, C] = S, D = sR(w, A, l);
      B(th(a), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);
      const E = GM(T.shape, D, I, e, r), M = aR(T, D, I.shape, e, r), L = [
        E,
        M
      ];
      if (C != null) {
        const k = oR(C, D);
        L.push(k);
      }
      return L;
    }, b = {
      x: d,
      filter: f,
      bias: m,
      preluActivationWeights: y
    }, _ = {
      strides: e,
      pad: r,
      dataFormat: i,
      dilations: a,
      dimRoundingMode: s,
      activation: l,
      leakyreluAlpha: c
    };
    return o == null ? nd((S, I, T) => {
      let A = K.runKernel($b, b, _);
      return T([
        I,
        S,
        A
      ]), p && (A = Z(A, [
        A.shape[1],
        A.shape[2],
        A.shape[3]
      ])), {
        value: A,
        gradFunc: x
      };
    })(d, f) : nd((S, I, T, A) => {
      let C = K.runKernel($b, b, _);
      return A([
        I,
        S,
        C,
        T
      ]), p && (C = Z(C, [
        C.shape[1],
        C.shape[2],
        C.shape[3]
      ])), {
        value: C,
        gradFunc: x
      };
    })(d, f, m);
  }
  const Y2t = Q({
    fusedConv2d_: X2t
  });
  function q2t(n, t, e, r, i, a = [
    1,
    1
  ], s) {
    let o = n;
    n.rank === 3 && (o = Z(n, [
      1,
      n.shape[0],
      n.shape[1],
      n.shape[2]
    ]));
    let l = t;
    l.rank === 3 && (l = Z(t, [
      1,
      t.shape[0],
      t.shape[1],
      t.shape[2]
    ]));
    const u = {
      x: o,
      dy: l
    }, c = {
      strides: r,
      pad: i,
      dimRoundingMode: s,
      dilations: a,
      filterShape: e
    };
    return K.runKernel(hM, u, c);
  }
  const j2t = Q({
    depthwiseConv2dNativeBackpropFilter_: q2t
  });
  function K2t(n, t, e, r, i, a = [
    1,
    1
  ], s) {
    let o = t, l = false;
    t.rank === 3 && (l = true, o = Z(t, [
      1,
      t.shape[0],
      t.shape[1],
      t.shape[2]
    ]));
    const u = {
      dy: o,
      filter: e
    }, c = {
      strides: r,
      pad: i,
      dimRoundingMode: s,
      dilations: a,
      inputShape: n
    }, h = K.runKernel(fM, u, c);
    return l ? Z(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3]
    ]) : h;
  }
  const Z2t = Q({
    depthwiseConv2dNativeBackpropInput_: K2t
  });
  function J2t({ a: n, b: t, transposeA: e = false, transposeB: r = false, bias: i, activation: a = "linear", preluActivationWeights: s, leakyreluAlpha: o = 0.2 }) {
    if (uR(K.state.gradientDepth, a) === false) {
      let C = Ge(n, t, e, r);
      return i != null && (C = bt(C, i)), lR(C, a, s, o);
    }
    let l = W(n, "a", "fused matMul"), u = W(t, "b", "fused matMul");
    [l, u] = Mn(l, u);
    const c = e ? l.shape[l.rank - 2] : l.shape[l.rank - 1], h = r ? u.shape[u.rank - 1] : u.shape[u.rank - 2], f = e ? l.shape[l.rank - 1] : l.shape[l.rank - 2], d = r ? u.shape[u.rank - 2] : u.shape[u.rank - 1], p = l.shape.slice(0, -2), g = u.shape.slice(0, -2), v = lt(p), m = lt(g);
    B(c === h, () => `Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);
    const x = ve(l.shape.slice(0, -2), u.shape.slice(0, -2)).concat([
      f,
      d
    ]), b = e ? Z(l, [
      v,
      c,
      f
    ]) : Z(l, [
      v,
      f,
      c
    ]), _ = r ? Z(u, [
      m,
      d,
      h
    ]) : Z(u, [
      m,
      h,
      d
    ]);
    let w;
    i != null && (w = W(i, "bias", "fused matMul"), [w] = Mn(w, l), ve(x, w.shape));
    let S;
    s != null && (S = W(s, "prelu weights", "fused matMul"));
    const I = (C, D) => {
      const [E, M, L, k] = D, N = sR(Z(C, L.shape), L, a);
      let R, $;
      if (!e && !r ? (R = Ge(N, M, false, true), $ = Ge(E, N, true, false)) : !e && r ? (R = Ge(N, M, false, false), $ = Ge(N, E, true, false)) : e && !r ? (R = Ge(M, N, false, true), $ = Ge(E, N, false, false)) : (R = Ge(M, N, true, true), $ = Ge(N, E, true, true)), i != null) {
        const O = oR(k, N);
        return [
          R,
          $,
          O
        ];
      } else return [
        R,
        $
      ];
    }, T = {
      a: b,
      b: _,
      bias: w,
      preluActivationWeights: S
    }, A = {
      transposeA: e,
      transposeB: r,
      activation: a,
      leakyreluAlpha: o
    };
    return i == null ? nd((D, E, M) => {
      const L = K.runKernel(Pb, T, A);
      return M([
        D,
        E,
        L
      ]), {
        value: Z(L, x),
        gradFunc: I
      };
    })(b, _) : nd((D, E, M, L) => {
      const k = K.runKernel(Pb, T, A);
      return L([
        D,
        E,
        k,
        M
      ]), {
        value: Z(k, x),
        gradFunc: I
      };
    })(b, _, w);
  }
  const Qz = Q({
    fusedMatMul_: J2t
  });
  function Q2t(n, t, e, r, i = "bilinear", a = 0) {
    const s = W(n, "image", "cropAndResize"), o = W(t, "boxes", "cropAndResize", "float32"), l = W(e, "boxInd", "cropAndResize", "int32"), u = o.shape[0];
    B(s.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${s.rank}.`), B(o.rank === 2 && o.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`), B(l.rank === 1 && l.shape[0] === u, () => `Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`), B(r.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`), B(r[0] >= 1 && r[1] >= 1, () => `cropSize must be atleast [1,1], but was ${r}`), B(i === "bilinear" || i === "nearest", () => `method must be bilinear or nearest, but was ${i}`);
    const c = {
      image: s,
      boxes: o,
      boxInd: l
    }, h = {
      method: i,
      extrapolationValue: a,
      cropSize: r
    };
    return K.runKernel(lM, c, h);
  }
  const tkt = Q({
    cropAndResize_: Q2t
  });
  function ekt(n) {
    const t = W(n, "image", "flipLeftRight", "float32");
    B(t.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);
    const e = {
      image: t
    };
    return K.runKernel(mM, e, {});
  }
  const nkt = Q({
    flipLeftRight_: ekt
  });
  function rkt(n) {
    const t = W(n, "image", "grayscaleToRGB"), e = t.rank - 1, r = t.shape[e];
    B(t.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`), B(r === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);
    const i = new Array(t.rank);
    return i.fill(1, 0, e), i[e] = 3, Za(t, i);
  }
  const ikt = Q({
    grayscaleToRGB_: rkt
  });
  function akt(n) {
    const t = W(n, "image", "RGBToGrayscale"), e = t.rank - 1, r = t.shape[e];
    B(t.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`), B(r === 3, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);
    const i = t.dtype, a = Et(t, "float32"), s = Ni([
      0.2989,
      0.587,
      0.114
    ]);
    let o;
    switch (t.rank) {
      case 2:
        o = kp("ij,j->i", a, s);
        break;
      case 3:
        o = kp("ijk,k->ij", a, s);
        break;
      case 4:
        o = kp("ijkl,l->ijk", a, s);
        break;
      case 5:
        o = kp("ijklm,m->ijkl", a, s);
        break;
      case 6:
        o = kp("ijklmn,n->ijklm", a, s);
        break;
      default:
        throw new Error("Not a valid tensor rank.");
    }
    return o = li(o, -1), Et(o, i);
  }
  const skt = Q({
    rgbToGrayscale_: akt
  });
  function okt(n, t, e = 0, r = 0.5) {
    const i = W(n, "image", "rotateWithOffset", "float32");
    B(i.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);
    const a = {
      image: i
    }, s = {
      radians: t,
      fillValue: e,
      center: r
    };
    return K.runKernel($M, a, s);
  }
  const lkt = Q({
    rotateWithOffset_: okt
  });
  function Fd(n, t, e, r, i, a) {
    r == null && (r = 0.5), i == null && (i = Number.NEGATIVE_INFINITY), a == null && (a = 0);
    const s = n.shape[0];
    return e = Math.min(e, s), B(0 <= r && r <= 1, () => `iouThreshold must be in [0, 1], but was '${r}'`), B(n.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${n.rank}'`), B(n.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`), B(t.rank === 1, () => "scores must be a 1D tensor"), B(t.shape[0] === s, () => `scores has incompatible shape with boxes. Expected ${s}, but was ${t.shape[0]}`), B(0 <= a && a <= 1, () => `softNmsSigma must be in [0, 1], but was '${a}'`), {
      maxOutputSize: e,
      iouThreshold: r,
      scoreThreshold: i,
      softNmsSigma: a
    };
  }
  function ukt(n, t, e, r = 0.5, i = Number.NEGATIVE_INFINITY) {
    const a = W(n, "boxes", "nonMaxSuppression", "float32"), s = W(t, "scores", "nonMaxSuppression", "float32"), o = Fd(a, s, e, r, i);
    e = o.maxOutputSize, r = o.iouThreshold, i = o.scoreThreshold;
    const l = {
      maxOutputSize: e,
      iouThreshold: r,
      scoreThreshold: i
    };
    return K.runKernel(SM, {
      boxes: a,
      scores: s
    }, l);
  }
  const ckt = Q({
    nonMaxSuppression_: ukt
  });
  function hkt(n, t, e) {
    const r = fkt(n, t, e), i = r < 0 ? -(r + 1) : r;
    n.splice(i, 0, t);
  }
  function fkt(n, t, e) {
    return pkt(n, t, e || dkt);
  }
  function dkt(n, t) {
    return n > t ? 1 : n < t ? -1 : 0;
  }
  function pkt(n, t, e) {
    let r = 0, i = n.length, a = 0, s = false;
    for (; r < i; ) {
      a = r + (i - r >>> 1);
      const o = e(t, n[a]);
      o > 0 ? r = a + 1 : (i = a, s = !o);
    }
    return s ? r : -r - 1;
  }
  function cR(n, t, e, r, i) {
    return dR(n, t, e, r, i, 0);
  }
  function hR(n, t, e, r, i, a) {
    return dR(n, t, e, r, i, 0, false, a, true);
  }
  function fR(n, t, e, r, i, a) {
    return dR(n, t, e, r, i, a, true);
  }
  function dR(n, t, e, r, i, a, s = false, o = false, l = false) {
    const u = [];
    for (let v = 0; v < t.length; v++) t[v] > i && u.push({
      score: t[v],
      boxIndex: v,
      suppressBeginIndex: 0
    });
    u.sort(tV);
    const c = a > 0 ? -0.5 / a : 0, h = [], f = [];
    for (; h.length < e && u.length > 0; ) {
      const v = u.pop(), { score: m, boxIndex: y, suppressBeginIndex: x } = v;
      if (m < i) break;
      let b = false;
      for (let _ = h.length - 1; _ >= x; --_) {
        const w = gkt(n, y, h[_]);
        if (w >= r) {
          b = true;
          break;
        }
        if (v.score = v.score * vkt(r, c, w), v.score <= i) break;
      }
      v.suppressBeginIndex = h.length, b || (v.score === m ? (h.push(y), f.push(v.score)) : v.score > i && hkt(u, v, tV));
    }
    const d = h.length, p = e - d;
    o && p > 0 && (h.push(...new Array(p).fill(0)), f.push(...new Array(p).fill(0)));
    const g = {
      selectedIndices: h
    };
    return s && (g.selectedScores = f), l && (g.validOutputs = d), g;
  }
  function gkt(n, t, e) {
    const r = n.subarray(t * 4, t * 4 + 4), i = n.subarray(e * 4, e * 4 + 4), a = Math.min(r[0], r[2]), s = Math.min(r[1], r[3]), o = Math.max(r[0], r[2]), l = Math.max(r[1], r[3]), u = Math.min(i[0], i[2]), c = Math.min(i[1], i[3]), h = Math.max(i[0], i[2]), f = Math.max(i[1], i[3]), d = (o - a) * (l - s), p = (h - u) * (f - c);
    if (d <= 0 || p <= 0) return 0;
    const g = Math.max(a, u), v = Math.max(s, c), m = Math.min(o, h), y = Math.min(l, f), x = Math.max(m - g, 0) * Math.max(y - v, 0);
    return x / (d + p - x);
  }
  function vkt(n, t, e) {
    const r = Math.exp(t * e * e);
    return e <= n ? r : 0;
  }
  function tV(n, t) {
    return n.score - t.score || n.score === t.score && t.boxIndex - n.boxIndex;
  }
  async function mkt(n, t, e, r = 0.5, i = Number.NEGATIVE_INFINITY) {
    const a = W(n, "boxes", "nonMaxSuppressionAsync"), s = W(t, "scores", "nonMaxSuppressionAsync"), o = Fd(a, s, e, r, i);
    e = o.maxOutputSize, r = o.iouThreshold, i = o.scoreThreshold;
    const l = await Promise.all([
      a.data(),
      s.data()
    ]), u = l[0], c = l[1], { selectedIndices: h } = cR(u, c, e, r, i);
    return a !== n && a.dispose(), s !== t && s.dispose(), Ni(h, "int32");
  }
  const ykt = mkt;
  function xkt(n, t, e, r = 0.5, i = Number.NEGATIVE_INFINITY, a = 0) {
    const s = W(n, "boxes", "nonMaxSuppression"), o = W(t, "scores", "nonMaxSuppression"), l = Fd(s, o, e, r, i, a);
    e = l.maxOutputSize, r = l.iouThreshold, i = l.scoreThreshold, a = l.softNmsSigma;
    const u = {
      boxes: s,
      scores: o
    }, c = {
      maxOutputSize: e,
      iouThreshold: r,
      scoreThreshold: i,
      softNmsSigma: a
    }, h = K.runKernel(TM, u, c);
    return {
      selectedIndices: h[0],
      selectedScores: h[1]
    };
  }
  const bkt = Q({
    nonMaxSuppressionWithScore_: xkt
  });
  async function _kt(n, t, e, r = 0.5, i = Number.NEGATIVE_INFINITY, a = 0) {
    const s = W(n, "boxes", "nonMaxSuppressionAsync"), o = W(t, "scores", "nonMaxSuppressionAsync"), l = Fd(s, o, e, r, i, a);
    e = l.maxOutputSize, r = l.iouThreshold, i = l.scoreThreshold, a = l.softNmsSigma;
    const u = await Promise.all([
      s.data(),
      o.data()
    ]), c = u[0], h = u[1], { selectedIndices: f, selectedScores: d } = fR(c, h, e, r, i, a);
    return s !== n && s.dispose(), o !== t && o.dispose(), {
      selectedIndices: Ni(f, "int32"),
      selectedScores: Ni(d)
    };
  }
  const wkt = _kt;
  function Skt(n, t, e, r = 0.5, i = Number.NEGATIVE_INFINITY, a = false) {
    const s = W(n, "boxes", "nonMaxSuppression"), o = W(t, "scores", "nonMaxSuppression"), l = Fd(s, o, e, r, i, null), u = l.maxOutputSize, c = l.iouThreshold, h = l.scoreThreshold, f = {
      boxes: s,
      scores: o
    }, d = {
      maxOutputSize: u,
      iouThreshold: c,
      scoreThreshold: h,
      padToMaxOutputSize: a
    }, p = K.runKernel(CM, f, d);
    return {
      selectedIndices: p[0],
      validOutputs: p[1]
    };
  }
  const Ckt = Q({
    nonMaxSuppressionPadded_: Skt
  });
  async function Tkt(n, t, e, r = 0.5, i = Number.NEGATIVE_INFINITY, a = false) {
    const s = W(n, "boxes", "nonMaxSuppressionAsync"), o = W(t, "scores", "nonMaxSuppressionAsync"), l = Fd(s, o, e, r, i, null), u = l.maxOutputSize, c = l.iouThreshold, h = l.scoreThreshold, [f, d] = await Promise.all([
      s.data(),
      o.data()
    ]), { selectedIndices: p, validOutputs: g } = hR(f, d, u, c, h, a);
    return s !== n && s.dispose(), o !== t && o.dispose(), {
      selectedIndices: Ni(p, "int32"),
      validOutputs: Ue(g, "int32")
    };
  }
  const Ikt = Tkt;
  function Akt(n, t, e = false, r = false) {
    const i = W(n, "images", "resizeBilinear");
    B(i.rank === 3 || i.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`), B(t.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${t}.`), B(r === false || e === false, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
    let a = i, s = false;
    i.rank === 3 && (s = true, a = Z(i, [
      1,
      i.shape[0],
      i.shape[1],
      i.shape[2]
    ]));
    const o = {
      images: a
    }, l = {
      alignCorners: e,
      halfPixelCenters: r,
      size: t
    }, u = K.runKernel(H_, o, l);
    return s ? Z(u, [
      u.shape[1],
      u.shape[2],
      u.shape[3]
    ]) : u;
  }
  const _j = Q({
    resizeBilinear_: Akt
  });
  function kkt(n, t, e = false, r = false) {
    const i = W(n, "images", "resizeNearestNeighbor");
    B(i.rank === 3 || i.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`), B(t.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`), B(i.dtype === "float32" || i.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), B(r === false || e === false, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
    let a = i, s = false;
    i.rank === 3 && (s = true, a = Z(i, [
      1,
      i.shape[0],
      i.shape[1],
      i.shape[2]
    ]));
    const o = {
      images: a
    }, l = {
      alignCorners: e,
      halfPixelCenters: r,
      size: t
    }, u = K.runKernel(U_, o, l);
    return s ? Z(u, [
      u.shape[1],
      u.shape[2],
      u.shape[3]
    ]) : u;
  }
  const wj = Q({
    resizeNearestNeighbor_: kkt
  });
  function Dkt(n, t = "binary", e = false, r = 0.5) {
    const i = W(n, "image", "threshold"), a = 0.2989, s = 0.587, o = 0.114, l = i.shape[0] * i.shape[1];
    let u = j(Ni([
      r
    ]), 255), c, h, f, d;
    if (B(i.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${i.rank}.`), B(i.shape[2] === 3 || i.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`), B(i.dtype === "int32" || i.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`), B(t === "otsu" || t === "binary", () => `Method must be binary or otsu, but was ${t}`), i.shape[2] === 3) {
      [c, h, f] = ji(i, [
        1,
        1,
        1
      ], -1);
      const v = j(c, a), m = j(h, s), y = j(f, o);
      d = bt(bt(v, m), y);
    } else d = n;
    if (t === "otsu") {
      const v = ITt(Et(uj(d), "int32"), $q([]), 256);
      u = Ekt(v, l);
    }
    const p = e ? Od(d, u) : ea(d, u);
    return Et(j(p, 255), "int32");
  }
  function Ekt(n, t) {
    let e = Ni([
      -1
    ]), r = Ni([
      0
    ]), i = Ni([
      0
    ]), a, s, o, l, u, c;
    for (let h = 0; h < n.size - 1; h++) {
      a = hn(n, 0, h + 1), s = hn(n, h + 1), u = Jt(Kt(a), t), c = Jt(Kt(s), t);
      const f = Kt(j(a, dv(0, a.size)));
      o = Jt(f, Kt(a));
      const d = lw(s.shape, a.size), p = bt(dv(0, s.size), d), g = j(s, p);
      l = Jt(Kt(g), Kt(s));
      const v = re(o, l), m = re(o, l), y = j(u, c);
      i = j(j(y, v), m);
      const x = ea(i, r);
      r = qr(x, i, r), e = qr(x, Ni([
        h
      ]), e);
    }
    return e;
  }
  const Mkt = Q({
    threshold_: Dkt
  });
  function Rkt(n, t, e = "nearest", r = "constant", i = 0, a) {
    const s = W(n, "image", "transform", "float32"), o = W(t, "transforms", "transform", "float32");
    B(s.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${s.rank}.`), B(o.rank === 2 && (o.shape[0] === s.shape[0] || o.shape[0] === 1) && o.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), B(a == null || a.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${a}.`);
    const l = {
      image: s,
      transforms: o
    }, u = {
      interpolation: e,
      fillMode: r,
      fillValue: i,
      outputShape: a
    };
    return K.runKernel(LM, l, u);
  }
  const Nkt = Q({
    transform_: Rkt
  });
  function Lkt(n, t, e) {
    const r = W(n, "a", "bandPart");
    B(r.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${r.rank}.`);
    const i = r.shape, [a, s] = r.shape.slice(-2);
    let o, l;
    typeof t == "number" ? (B(t % 1 === 0, () => `bandPart(): numLower must be an integer, got ${t}.`), B(t <= a, () => `bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`), o = W(t < 0 ? a : t, "numLower", "bandPart")) : (B(t.dtype === "int32", () => "bandPart(): numLower's dtype must be an int32."), o = qr(zb(t, 0), a, fv(t, a))), typeof e == "number" ? (B(e % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${e}.`), B(e <= s, () => `bandPart(): numUpper (${e}) must not be greater than the number of columns (${s}).`), l = W(e < 0 ? s : e, "numUpper", "bandPart")) : (B(e.dtype === "int32", () => "bandPart(): numUpper's dtype must be an int32."), l = qr(zb(e, 0), s, fv(e, s)));
    const u = Z(dv(0, a, 1, "int32"), [
      -1,
      1
    ]), c = dv(0, s, 1, "int32"), h = re(u, c), f = qo(Od(h, o), _h(h, En(l))), d = rr([
      a,
      s
    ], r.dtype);
    return Z(jo(ah(Z(r, [
      -1,
      a,
      s
    ])).map((p) => qr(f, p, d))), i);
  }
  const Pkt = Q({
    bandPart_: Lkt
  });
  function $kt(n) {
    let t;
    if (Array.isArray(n)) {
      t = false, B(n != null && n.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
      const i = n[0].shape[0];
      for (let a = 1; a < n.length; ++a) B(n[a].shape[0] === i, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${i})`);
    } else t = true, n = ji(n, n.shape[0], 0).map((i) => Zm(i, [
      0
    ]));
    B(n.length <= n[0].shape[0], () => `Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);
    const e = [], r = n;
    for (let i = 0; i < n.length; ++i) e.push(K.tidy(() => {
      let a = r[i];
      if (i > 0) for (let s = 0; s < i; ++s) {
        const o = j(Kt(j(e[s], a)), e[s]);
        a = re(a, o);
      }
      return Jt(a, cw(a, "euclidean"));
    }));
    return t ? jo(e, 0) : e;
  }
  const Okt = Q({
    gramSchmidt_: $kt
  });
  function Fkt(n, t = false) {
    if (B(n.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`), n.rank === 2) return eV(n, t);
    {
      const e = n.shape.slice(0, n.shape.length - 2).reduce((l, u) => l * u), r = ah(Z(n, [
        e,
        n.shape[n.shape.length - 2],
        n.shape[n.shape.length - 1]
      ]), 0), i = [], a = [];
      r.forEach((l) => {
        const [u, c] = eV(l, t);
        i.push(u), a.push(c);
      });
      const s = Z(jo(i, 0), n.shape), o = Z(jo(a, 0), n.shape);
      return [
        s,
        o
      ];
    }
  }
  function eV(n, t = false) {
    return K.tidy(() => {
      B(n.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);
      const e = n.shape[0], r = n.shape[1];
      let i = ej(e), a = Bc(n);
      const s = yT([
        [
          1
        ]
      ], [
        1,
        1
      ]);
      let o = Bc(s);
      const l = e >= r ? r : e;
      for (let u = 0; u < l; ++u) {
        const c = a, h = o, f = i;
        [o, a, i] = K.tidy(() => {
          const d = hn(a, [
            u,
            u
          ], [
            e - u,
            1
          ]), p = cw(d), g = hn(a, [
            u,
            u
          ], [
            1,
            1
          ]), v = qr(ea(g, 0), yT([
            [
              -1
            ]
          ]), yT([
            [
              1
            ]
          ])), m = re(g, j(v, p)), y = Jt(d, m);
          y.shape[0] === 1 ? o = Bc(s) : o = pi([
            s,
            hn(y, [
              1,
              0
            ], [
              y.shape[0] - 1,
              y.shape[1]
            ])
          ], 0);
          const x = En(Jt(Ge(v, m), p)), b = hn(a, [
            u,
            0
          ], [
            e - u,
            r
          ]), _ = j(x, o), w = Oe(o);
          if (u === 0) a = re(b, Ge(_, Ge(w, b)));
          else {
            const T = re(b, Ge(_, Ge(w, b)));
            a = pi([
              hn(a, [
                0,
                0
              ], [
                u,
                r
              ]),
              T
            ], 0);
          }
          const S = Oe(_), I = hn(i, [
            0,
            u
          ], [
            e,
            i.shape[1] - u
          ]);
          if (u === 0) i = re(I, Ge(Ge(I, o), S));
          else {
            const T = re(I, Ge(Ge(I, o), S));
            i = pi([
              hn(i, [
                0,
                0
              ], [
                e,
                u
              ]),
              T
            ], 1);
          }
          return [
            o,
            a,
            i
          ];
        }), Te([
          c,
          h,
          f
        ]);
      }
      return !t && e > r && (i = hn(i, [
        0,
        0
      ], [
        e,
        r
      ]), a = hn(a, [
        0,
        0
      ], [
        r,
        r
      ])), [
        i,
        a
      ];
    });
  }
  const Bkt = Q({
    qr_: Fkt
  });
  const Ao = {
    flipLeftRight: nkt,
    grayscaleToRGB: ikt,
    resizeNearestNeighbor: wj,
    resizeBilinear: _j,
    rgbToGrayscale: skt,
    rotateWithOffset: lkt,
    cropAndResize: tkt,
    nonMaxSuppression: ckt,
    nonMaxSuppressionAsync: ykt,
    nonMaxSuppressionWithScore: bkt,
    nonMaxSuppressionWithScoreAsync: wkt,
    nonMaxSuppressionPadded: Ckt,
    nonMaxSuppressionPaddedAsync: Ikt,
    threshold: Mkt,
    transform: Nkt
  }, zkt = {
    bandPart: Pkt,
    gramSchmidt: Okt,
    qr: Bkt
  };
  const Vkt = /* @__PURE__ */ new Map(), Gkt = /* @__PURE__ */ new Map();
  class Bd {
    getClassName() {
      return this.constructor.className;
    }
    static fromConfig(t, e) {
      return new t(e);
    }
  }
  class ba {
    constructor() {
      this.classNameMap = {};
    }
    static getMap() {
      return ba.instance == null && (ba.instance = new ba()), ba.instance;
    }
    static register(t) {
      ba.getMap().classNameMap[t.className] = [
        t,
        t.fromConfig
      ];
    }
  }
  function vt(n, t, e) {
    B(n.className != null, () => "Class being registered does not have the static className property defined."), B(typeof n.className == "string", () => "className is required to be a string, but got type " + typeof n.className), B(n.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), typeof t > "u" && (t = "Custom"), typeof e > "u" && (e = n.className);
    const r = e, i = t + ">" + r;
    return ba.register(n), Vkt.set(i, n), Gkt.set(n, i), n;
  }
  class pu extends Bd {
    minimize(t, e = false, r) {
      const { value: i, grads: a } = this.computeGradients(t, r);
      if (r != null) {
        const s = r.map((o) => ({
          name: o.name,
          tensor: a[o.name]
        }));
        this.applyGradients(s);
      } else this.applyGradients(a);
      return Te(a), e ? i : (i.dispose(), null);
    }
    get iterations() {
      return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
    }
    incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
    computeGradients(t, e) {
      return YIt(t, e);
    }
    dispose() {
      this.iterations_ != null && Te(this.iterations_);
    }
    async saveIterations() {
      return this.iterations_ == null && (this.iterations_ = 0), {
        name: "iter",
        tensor: Ue(this.iterations_, "int32")
      };
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(t) {
      throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
    }
    async extractIterations(t) {
      return this.iterations_ = (await t[0].tensor.data())[0], t.slice(1);
    }
  }
  Object.defineProperty(pu, Symbol.hasInstance, {
    value: (n) => n.minimize != null && n.computeGradients != null && n.applyGradients != null
  });
  class Sj extends pu {
    static get className() {
      return "Adadelta";
    }
    constructor(t, e, r = null) {
      super(), this.learningRate = t, this.rho = e, this.epsilon = r, this.accumulatedGrads = [], this.accumulatedUpdates = [], r == null && (this.epsilon = K.backend.epsilon());
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((r) => r.name) : Object.keys(t)).forEach((r, i) => {
        const a = K.registeredVariables[r], s = false;
        this.accumulatedGrads[i] == null && (this.accumulatedGrads[i] = {
          originalName: `${r}/accum_grad`,
          variable: tt(() => Fe(a).variable(s))
        }), this.accumulatedUpdates[i] == null && (this.accumulatedUpdates[i] = {
          originalName: `${r}/accum_var`,
          variable: tt(() => Fe(a).variable(s))
        });
        const o = Array.isArray(t) ? t[i].tensor : t[r];
        if (o == null) return;
        const l = this.accumulatedGrads[i].variable, u = this.accumulatedUpdates[i].variable;
        tt(() => {
          const c = bt(j(l, this.rho), j(gn(o), 1 - this.rho)), h = j(Jt(Mr(bt(u, this.epsilon)), Mr(bt(l, this.epsilon))), o), f = bt(j(u, this.rho), j(gn(h), 1 - this.rho));
          l.assign(c), u.assign(f);
          const d = bt(j(h, -this.learningRate), a);
          a.assign(d);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedUpdates != null && (Te(this.accumulatedGrads.map((t) => t.variable)), Te(this.accumulatedUpdates.map((t) => t.variable)));
    }
    async getWeights() {
      const t = [
        ...this.accumulatedGrads,
        ...this.accumulatedUpdates
      ];
      return [
        await this.saveIterations()
      ].concat(t.map((e) => ({
        name: e.originalName,
        tensor: e.variable
      })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t);
      const e = t.length / 2, r = false;
      this.accumulatedGrads = t.slice(0, e).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })), this.accumulatedUpdates = t.slice(e, e * 2).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        rho: this.rho,
        epsilon: this.epsilon
      };
    }
    static fromConfig(t, e) {
      return new t(e.learningRate, e.rho, e.epsilon);
    }
  }
  class Cj extends pu {
    static get className() {
      return "Adagrad";
    }
    constructor(t, e = 0.1) {
      super(), this.learningRate = t, this.initialAccumulatorValue = e, this.accumulatedGrads = [];
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((r) => r.name) : Object.keys(t)).forEach((r, i) => {
        const a = K.registeredVariables[r];
        this.accumulatedGrads[i] == null && (this.accumulatedGrads[i] = {
          originalName: `${r}/accumulator`,
          variable: tt(() => lw(a.shape, this.initialAccumulatorValue).variable(false))
        });
        const s = Array.isArray(t) ? t[i].tensor : t[r];
        if (s == null) return;
        const o = this.accumulatedGrads[i].variable;
        tt(() => {
          const l = bt(o, gn(s));
          o.assign(l);
          const u = bt(j(Jt(s, Mr(bt(l, K.backend.epsilon()))), -this.learningRate), a);
          a.assign(u);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedGrads != null && Te(this.accumulatedGrads.map((t) => t.variable));
    }
    async getWeights() {
      return [
        await this.saveIterations()
      ].concat(this.accumulatedGrads.map((t) => ({
        name: t.originalName,
        tensor: t.variable
      })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t);
      const e = false;
      this.accumulatedGrads = t.map((r) => ({
        originalName: r.name,
        variable: r.tensor.variable(e)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        initialAccumulatorValue: this.initialAccumulatorValue
      };
    }
    static fromConfig(t, e) {
      return new t(e.learningRate, e.initialAccumulatorValue);
    }
  }
  class Tj extends pu {
    static get className() {
      return "Adam";
    }
    constructor(t, e, r, i = null) {
      super(), this.learningRate = t, this.beta1 = e, this.beta2 = r, this.epsilon = i, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], tt(() => {
        this.accBeta1 = Ue(e).variable(), this.accBeta2 = Ue(r).variable();
      }), i == null && (this.epsilon = K.backend.epsilon());
    }
    applyGradients(t) {
      const e = Array.isArray(t) ? t.map((r) => r.name) : Object.keys(t);
      tt(() => {
        const r = re(1, this.accBeta1), i = re(1, this.accBeta2);
        e.forEach((a, s) => {
          const o = K.registeredVariables[a], l = false;
          this.accumulatedFirstMoment[s] == null && (this.accumulatedFirstMoment[s] = {
            originalName: `${a}/m`,
            variable: tt(() => Fe(o).variable(l))
          }), this.accumulatedSecondMoment[s] == null && (this.accumulatedSecondMoment[s] = {
            originalName: `${a}/v`,
            variable: tt(() => Fe(o).variable(l))
          });
          const u = Array.isArray(t) ? t[s].tensor : t[a];
          if (u == null) return;
          const c = this.accumulatedFirstMoment[s].variable, h = this.accumulatedSecondMoment[s].variable, f = bt(j(c, this.beta1), j(u, 1 - this.beta1)), d = bt(j(h, this.beta2), j(gn(u), 1 - this.beta2)), p = Jt(f, r), g = Jt(d, i);
          c.assign(f), h.assign(d);
          const v = bt(j(Jt(p, bt(Mr(g), this.epsilon)), -this.learningRate), o);
          o.assign(v);
        }), this.accBeta1.assign(j(this.accBeta1, this.beta1)), this.accBeta2.assign(j(this.accBeta2, this.beta2));
      }), this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && Te(this.accumulatedFirstMoment.map((t) => t.variable)), this.accumulatedSecondMoment != null && Te(this.accumulatedSecondMoment.map((t) => t.variable));
    }
    async getWeights() {
      const t = [
        ...this.accumulatedFirstMoment,
        ...this.accumulatedSecondMoment
      ];
      return [
        await this.saveIterations()
      ].concat(t.map((e) => ({
        name: e.originalName,
        tensor: e.variable
      })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t), tt(() => {
        this.accBeta1.assign(rh(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(rh(this.beta2, this.iterations_ + 1));
      });
      const e = t.length / 2, r = false;
      this.accumulatedFirstMoment = t.slice(0, e).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })), this.accumulatedSecondMoment = t.slice(e, e * 2).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon
      };
    }
    static fromConfig(t, e) {
      return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);
    }
  }
  class Ij extends pu {
    static get className() {
      return "Adamax";
    }
    constructor(t, e, r, i = null, a = 0) {
      super(), this.learningRate = t, this.beta1 = e, this.beta2 = r, this.epsilon = i, this.decay = a, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], tt(() => {
        this.iteration = Ue(0).variable(), this.accBeta1 = Ue(e).variable();
      }), i == null && (this.epsilon = K.backend.epsilon());
    }
    applyGradients(t) {
      const e = Array.isArray(t) ? t.map((r) => r.name) : Object.keys(t);
      tt(() => {
        const r = re(1, this.accBeta1), i = Jt(-this.learningRate, bt(j(this.iteration, this.decay), 1));
        e.forEach((a, s) => {
          const o = K.registeredVariables[a], l = false;
          this.accumulatedFirstMoment[s] == null && (this.accumulatedFirstMoment[s] = {
            originalName: `${a}/m`,
            variable: Fe(o).variable(l)
          }), this.accumulatedWeightedInfNorm[s] == null && (this.accumulatedWeightedInfNorm[s] = {
            originalName: `${a}/v`,
            variable: Fe(o).variable(l)
          });
          const u = Array.isArray(t) ? t[s].tensor : t[a];
          if (u == null) return;
          const c = this.accumulatedFirstMoment[s].variable, h = this.accumulatedWeightedInfNorm[s].variable, f = bt(j(c, this.beta1), j(u, 1 - this.beta1)), d = j(h, this.beta2), p = Gr(u), g = fu(d, p);
          c.assign(f), h.assign(g);
          const v = bt(j(Jt(i, r), Jt(f, bt(g, this.epsilon))), o);
          o.assign(v);
        }), this.iteration.assign(bt(this.iteration, 1)), this.accBeta1.assign(j(this.accBeta1, this.beta1));
      }), this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && Te(this.accumulatedFirstMoment.map((t) => t.variable)), this.accumulatedWeightedInfNorm != null && Te(this.accumulatedWeightedInfNorm.map((t) => t.variable));
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(t) {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon,
        decay: this.decay
      };
    }
    static fromConfig(t, e) {
      return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);
    }
  }
  class pR extends pu {
    static get className() {
      return "SGD";
    }
    constructor(t) {
      super(), this.learningRate = t, this.setLearningRate(t);
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((r) => r.name) : Object.keys(t)).forEach((r, i) => {
        const a = Array.isArray(t) ? t[i].tensor : t[r];
        if (a == null) return;
        const s = K.registeredVariables[r];
        tt(() => {
          const o = bt(j(this.c, a), s);
          s.assign(o);
        });
      }), this.incrementIterations();
    }
    setLearningRate(t) {
      this.learningRate = t, this.c != null && this.c.dispose(), this.c = qs(Ue(-t));
    }
    dispose() {
      this.c.dispose();
    }
    async getWeights() {
      return [
        await this.saveIterations()
      ];
    }
    async setWeights(t) {
      if (t = await this.extractIterations(t), t.length !== 0) throw new Error("SGD optimizer does not have settable weights.");
    }
    getConfig() {
      return {
        learningRate: this.learningRate
      };
    }
    static fromConfig(t, e) {
      return new t(e.learningRate);
    }
  }
  class Aj extends pR {
    static get className() {
      return "Momentum";
    }
    constructor(t, e, r = false) {
      super(t), this.learningRate = t, this.momentum = e, this.useNesterov = r, this.accumulations = [], this.m = Ue(this.momentum);
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((r) => r.name) : Object.keys(t)).forEach((r, i) => {
        const a = K.registeredVariables[r];
        this.accumulations[i] == null && (this.accumulations[i] = {
          originalName: `${r}/momentum`,
          variable: tt(() => Fe(a).variable(false))
        });
        const s = this.accumulations[i].variable, o = Array.isArray(t) ? t[i].tensor : t[r];
        o != null && tt(() => {
          let l;
          const u = bt(j(this.m, s), o);
          this.useNesterov ? l = bt(j(this.c, bt(o, j(u, this.m))), a) : l = bt(j(this.c, u), a), s.assign(u), a.assign(l);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.m.dispose(), this.accumulations != null && Te(this.accumulations.map((t) => t.variable));
    }
    setMomentum(t) {
      this.momentum = t;
    }
    async getWeights() {
      return [
        await this.saveIterations()
      ].concat(this.accumulations.map((t) => ({
        name: t.originalName,
        tensor: t.variable
      })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t);
      const e = false;
      this.accumulations = t.map((r) => ({
        originalName: r.name,
        variable: r.tensor.variable(e)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        momentum: this.momentum,
        useNesterov: this.useNesterov
      };
    }
    static fromConfig(t, e) {
      return new t(e.learningRate, e.momentum, e.useNesterov);
    }
  }
  class kj extends pu {
    static get className() {
      return "RMSProp";
    }
    constructor(t, e = 0.9, r = 0, i = null, a = false) {
      if (super(), this.learningRate = t, this.decay = e, this.momentum = r, this.epsilon = i, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = a, i == null && (this.epsilon = K.backend.epsilon()), t == null) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    }
    applyGradients(t) {
      (Array.isArray(t) ? t.map((r) => r.name) : Object.keys(t)).forEach((r, i) => {
        const a = K.registeredVariables[r], s = false;
        this.accumulatedMeanSquares[i] == null && (this.accumulatedMeanSquares[i] = {
          originalName: `${r}/rms`,
          variable: tt(() => Fe(a).variable(s))
        }), this.accumulatedMoments[i] == null && (this.accumulatedMoments[i] = {
          originalName: `${r}/momentum`,
          variable: tt(() => Fe(a).variable(s))
        }), this.accumulatedMeanGrads[i] == null && this.centered && (this.accumulatedMeanGrads[i] = {
          originalName: `${r}/mg`,
          variable: tt(() => Fe(a).variable(s))
        });
        const o = Array.isArray(t) ? t[i].tensor : t[r];
        if (o == null) return;
        const l = this.accumulatedMeanSquares[i].variable, u = this.accumulatedMoments[i].variable;
        tt(() => {
          const c = bt(j(l, this.decay), j(gn(o), 1 - this.decay));
          if (this.centered) {
            const h = this.accumulatedMeanGrads[i].variable, f = bt(j(h, this.decay), j(o, 1 - this.decay)), d = Jt(j(o, this.learningRate), Mr(re(c, bt(gn(f), this.epsilon)))), p = bt(j(u, this.momentum), d);
            l.assign(c), h.assign(f), u.assign(p);
            const g = re(a, p);
            a.assign(g);
          } else {
            const h = bt(j(l, this.decay), j(gn(o), 1 - this.decay)), f = bt(j(u, this.momentum), Jt(j(o, this.learningRate), Mr(bt(h, this.epsilon))));
            l.assign(h), u.assign(f);
            const d = re(a, f);
            a.assign(d);
          }
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedMeanSquares != null && Te(this.accumulatedMeanSquares.map((t) => t.variable)), this.accumulatedMeanGrads != null && this.centered && Te(this.accumulatedMeanGrads.map((t) => t.variable)), this.accumulatedMoments != null && Te(this.accumulatedMoments.map((t) => t.variable));
    }
    async getWeights() {
      const t = [
        ...this.accumulatedMeanSquares,
        ...this.accumulatedMoments
      ];
      return this.centered && t.push(...this.accumulatedMeanGrads), [
        await this.saveIterations()
      ].concat(t.map((e) => ({
        name: e.originalName,
        tensor: e.variable
      })));
    }
    async setWeights(t) {
      t = await this.extractIterations(t);
      const e = this.centered ? t.length / 3 : t.length / 2, r = false;
      this.accumulatedMeanSquares = t.slice(0, e).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })), this.accumulatedMoments = t.slice(e, e * 2).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })), this.centered && (this.accumulatedMeanGrads = t.slice(e * 2, e * 3).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        decay: this.decay,
        momentum: this.momentum,
        epsilon: this.epsilon,
        centered: this.centered
      };
    }
    static fromConfig(t, e) {
      return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered);
    }
  }
  const Wkt = [
    Sj,
    Cj,
    Tj,
    Ij,
    Aj,
    kj,
    pR
  ];
  function Ukt() {
    for (const n of Wkt) vt(n);
  }
  function gR(n, t) {
    const e = n.shape.length, r = t.shape.length;
    if (e < 1) throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);
    if (r < 1) throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);
    if (t.dtype !== "int32") throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
    if (t.shape[r - 1] > e) throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r - 1]} vs. ${e}`);
    if (lt(n.shape) === 0) throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);
    const i = t.shape, a = i[i.length - 1];
    let s = 1;
    for (let h = 0; h < i.length - 1; ++h) s *= i[h];
    const o = n.shape, l = i.slice();
    l.pop();
    let u = 1;
    for (let h = a; h < e; ++h) u *= o[h], l.push(o[h]);
    const c = [
      ...Yt(n.shape).map((h) => h / u),
      1
    ].slice(0, a);
    return [
      l,
      s,
      u,
      c
    ];
  }
  const M2 = -2, Hkt = -1;
  function vR(n, t, e) {
    const r = n.shape.length;
    B(r === t.length, () => `Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`), B(r === e.length, () => `Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);
    for (let i = 0; i < r; ++i) B(t[i] + e[i] <= n.shape[i], () => `Error in slice${r}D: begin[${i}] + size[${i}] (${t[i] + e[i]}) would overflow input.shape[${i}] (${n.shape[i]})`);
  }
  function Xkt(n) {
    const t = [];
    let e = 0;
    for (; n > 0; ) n & 1 && t.push(e), n /= 2, e++;
    return t;
  }
  function mR(n, t, e) {
    const r = [];
    for (let i = 0; i < n.length; i++) r[i] = Math.ceil((t[i] - n[i]) / e[i]);
    return r;
  }
  function Dj(n, t, e, r) {
    const i = [
      ...n
    ];
    for (let a = i.length; a < r.length; a++) i.push(1);
    for (let a = 0; a < e; a++) a === 0 ? i[t] = 1 : (i.splice(t, 0, 1), i.pop());
    return i;
  }
  function Ej(n, t, e) {
    return e <= n ? e : e - (t - 1);
  }
  function Mj(n, t) {
    const e = [];
    for (let r = 0; r < n; r++) e.push(t + r);
    return e;
  }
  function Ykt(n, t, e, r, i, a, s, o, l) {
    const u = n.length;
    let c = new Array(u), h = new Array(u), f = new Array(u);
    if (t.length && e > 0) {
      const d = t[0], p = e + 1;
      c = Rj(s, d, p, r, n), h = Nj(o, d, p, i, n), f = Dj(a, d, p, n);
    } else for (let d = 0; d < u; d++) c[d] = Pj(s, r, a, n, d, l), h[d] = $j(o, i, a, n, d, l), f[d] = Lj(a, d, l);
    return {
      begin: c,
      end: h,
      strides: f
    };
  }
  function Rj(n, t, e, r, i) {
    const a = [
      ...i
    ], s = Mj(e, t);
    for (let o = 0; o < a.length; o++) if (s.indexOf(o) > -1) a[o] = 0;
    else {
      const l = Ej(t, e, o);
      let u = r[l];
      n & 1 << l && (u = 0), a[o] = u;
    }
    return a;
  }
  function Nj(n, t, e, r, i) {
    const a = [
      ...i
    ], s = Mj(e, t);
    for (let o = 0; o < a.length; o++) if (s.indexOf(o) > -1) a[o] = Number.MAX_SAFE_INTEGER;
    else {
      const l = Ej(t, e, o);
      let u = r[l];
      n & 1 << l && (u = Number.MAX_SAFE_INTEGER), a[o] = u;
    }
    for (let o = 0; o < a.length; o++) {
      const l = i[o];
      a[o] < 0 && (a[o] += l), a[o] = Kc(0, a[o], i[o]);
    }
    return a;
  }
  function Lj(n, t, e) {
    let r = n[t];
    return (e & 1 << t || r == null) && (r = 1), r;
  }
  function Pj(n, t, e, r, i, a) {
    let s = t[i];
    const o = e[i] || 1;
    (n & 1 << i || a & 1 << i || s == null) && (o > 0 ? s = Number.MIN_SAFE_INTEGER : s = Number.MAX_SAFE_INTEGER);
    const l = r[i];
    return s < 0 && (s += l), s = Kc(0, s, l - 1), s;
  }
  function $j(n, t, e, r, i, a) {
    let s = t[i];
    const o = e[i] || 1;
    (n & 1 << i || a & 1 << i || s == null) && (o > 0 ? s = Number.MAX_SAFE_INTEGER : s = Number.MIN_SAFE_INTEGER);
    const l = r[i];
    return s < 0 && (s += l), o > 0 ? s = Kc(0, s, l) : s = Kc(-1, s, l - 1), s;
  }
  function yR(n, t, e) {
    let r = e.length;
    for (let i = 0; i < e.length; i++) if (e[i] > 1) {
      r = i;
      break;
    }
    for (let i = r + 1; i < e.length; i++) if (t[i] > 0 || e[i] !== n[i]) return false;
    return true;
  }
  function xR(n, t) {
    let e = n.length > 0 ? n[n.length - 1] : 1;
    for (let r = 0; r < n.length - 1; r++) e += n[r] * t[r];
    return e;
  }
  function fw(n, t, e) {
    let r;
    const i = n.shape.length;
    typeof t == "number" ? r = [
      t,
      ...new Array(i - 1).fill(0)
    ] : t.length < i ? r = t.concat(new Array(i - t.length).fill(0)) : r = t.slice(), r.forEach((s) => {
      B(s !== -1, () => "slice() does not support negative begin indexing.");
    });
    let a;
    return e == null ? a = new Array(i).fill(-1) : typeof e == "number" ? a = [
      e,
      ...new Array(i - 1).fill(-1)
    ] : e.length < i ? a = e.concat(new Array(i - e.length).fill(-1)) : a = e, a = a.map((s, o) => s >= 0 ? s : (B(s === -1, () => `Negative size values should be exactly -1 but got ${s} for the slice() size at index ${o}.`), n.shape[o] - r[o])), [
      r,
      a
    ];
  }
  function bR(n, t, e, r, i, a, s, o, l) {
    let u;
    if (r == null ? (u = new Array(t.length), u.fill(1)) : u = r, s != null && s & s - 1) throw new Error("Multiple ellipses in slice is not allowed.");
    let c = false;
    const h = {
      dims: u.length,
      numAddAxisAfterEllipsis: 0,
      begin: t.slice(),
      end: e.slice(),
      strides: u.slice(),
      beginMask: i,
      endMask: a,
      ellipsisMask: s,
      newAxisMask: o,
      shrinkAxisMask: l
    };
    for (let x = 0; x < h.dims; x++) c && 1 << x & o && h.numAddAxisAfterEllipsis++, 1 << x & s && (c = true);
    c || (h.ellipsisMask |= 1 << h.dims, h.dims++);
    const f = {
      dims: n.length,
      beginMask: 0,
      endMask: 0,
      beginValid: false,
      endValid: false
    };
    qkt(h, f);
    let d = true, p = true, g = true;
    const v = [], m = [];
    for (let x = 0; x < n.length; ++x) {
      if (f.strides[x] === 0) throw Error(`strides[${x}] must be non-zero`);
      const b = !!(f.shrinkAxisMask & 1 << x), _ = n[x];
      if (_ === -1) {
        v.push(b ? 1 : -1);
        continue;
      }
      const w = [
        f.beginMask & 1 << x,
        f.endMask & 1 << x
      ], S = [
        f.strides[x] > 0 ? 0 : -1,
        f.strides[x] > 0 ? _ : _ - 1
      ];
      if (b && f.strides[x] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
      g = g && f.strides[x] === 1;
      const I = !!(f.beginMask & 1 << x && f.endMask & 1 << x);
      if (f.beginValid && f.endValid) {
        if (b) {
          const D = f.begin[x] < 0 ? _ + f.begin[x] : f.begin[x];
          if (f.begin[x] = D, f.end[x] = f.begin[x] + 1, D < 0 || D >= _) throw Error(`slice index ${f.begin[x]} of dimension ${x} out of bounds.`);
        } else f.begin[x] = nV(f.begin[x], 0, f.strides[x], _, w, S), f.end[x] = nV(f.end[x], 1, f.strides[x], _, w, S);
        const C = f.strides[x] === 1 && f.begin[x] === 0 && f.end[x] === _;
        d = d && C, p = p && (x === 0 && f.strides[x] === 1 || C);
      } else d = d && f.strides[x] === 1 && I, p = p && (x === 0 && f.strides[x] === 1 || I);
      let T, A = false;
      if (f.beginValid && f.endValid ? (T = f.end[x] - f.begin[x], A = true) : b ? (T = 1, A = true) : I && _ >= 0 && (f.strides[x] < 0 ? T = -_ : T = _, A = true), A) {
        let C;
        T === 0 || T < 0 != f.strides[x] < 0 ? C = 0 : C = Math.trunc(T / f.strides[x]) + (T % f.strides[x] !== 0 ? 1 : 0), v.push(C);
      } else v.push(-1);
    }
    for (let x = 0; x < f.finalShapeGatherIndices.length; ++x) {
      const b = f.finalShapeGatherIndices[x];
      b >= 0 ? m.push(v[b]) : b === M2 && m.push(1);
    }
    return {
      finalShapeSparse: m.filter((x, b) => f.finalShapeGatherIndices[b] !== M2),
      finalShape: m,
      isIdentity: d,
      sliceDim0: p,
      isSimpleSlice: g,
      begin: f.begin,
      end: f.end,
      strides: f.strides
    };
  }
  function qkt(n, t) {
    t.beginMask = 0, t.endMask = 0, t.shrinkAxisMask = 0;
    let e = 0;
    t.beginValid = n.begin != null, t.endValid = n.end != null, t.begin = new Array(t.dims), t.end = new Array(t.dims), t.strides = new Array(t.dims), t.finalShapeGatherIndices = [], t.finalShapeGatherIndicesSparse = [], t.inputShapeGatherIndicesSparse = new Array(t.dims);
    for (let r = 0; r < n.dims; r++) if (1 << r & n.ellipsisMask) {
      const i = Math.min(t.dims - (n.dims - r) + 1 + n.numAddAxisAfterEllipsis, t.dims);
      for (; e < i; e++) t.begin[e] = 0, t.end[e] = 0, t.strides[e] = 1, t.beginMask |= 1 << e, t.endMask |= 1 << e, t.finalShapeGatherIndices.push(e), t.finalShapeGatherIndicesSparse.push(-1), t.inputShapeGatherIndicesSparse[e] = r;
    } else if (1 << r & n.newAxisMask) t.finalShapeGatherIndices.push(M2), t.finalShapeGatherIndicesSparse.push(-1);
    else {
      if (e === t.begin.length) throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);
      n.begin != null && (t.begin[e] = n.begin[r]), n.end != null && (t.end[e] = n.end[r]), t.strides[e] = n.strides[r], n.beginMask & 1 << r && (t.beginMask |= 1 << e), n.endMask & 1 << r && (t.endMask |= 1 << e), n.shrinkAxisMask & 1 << r ? (t.finalShapeGatherIndices.push(Hkt), t.finalShapeGatherIndicesSparse.push(-1), t.shrinkAxisMask |= 1 << e) : (t.finalShapeGatherIndices.push(e), t.finalShapeGatherIndicesSparse.push(r)), t.inputShapeGatherIndicesSparse[e] = r, e++;
    }
  }
  function nV(n, t, e, r, i, a) {
    if (i[t]) return e > 0 ? a[t] : a[t + 1 & 1];
    {
      const s = n < 0 ? r + n : n;
      return s < a[0] ? a[0] : s > a[1] ? a[1] : s;
    }
  }
  const jkt = Object.freeze(Object.defineProperty({
    __proto__: null,
    assertParamsValid: vR,
    computeFlatOffset: xR,
    computeOutShape: mR,
    getNormalizedAxes: Ykt,
    isSliceContinous: yR,
    maskToAxes: Xkt,
    parseSliceParams: fw,
    sliceInfo: bR,
    startForAxis: Pj,
    startIndicesWithElidedDims: Rj,
    stopForAxis: $j,
    stopIndicesWithElidedDims: Nj,
    stridesForAxis: Lj,
    stridesWithElidedDims: Dj
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Kkt {
    static sgd(t) {
      return new pR(t);
    }
    static momentum(t, e, r = false) {
      return new Aj(t, e, r);
    }
    static rmsprop(t, e = 0.9, r = 0, i = null, a = false) {
      return new kj(t, e, r, i, a);
    }
    static adam(t = 1e-3, e = 0.9, r = 0.999, i = null) {
      return new Tj(t, e, r, i);
    }
    static adadelta(t = 1e-3, e = 0.95, r = null) {
      return new Sj(t, e, r);
    }
    static adamax(t = 2e-3, e = 0.9, r = 0.999, i = null, a = 0) {
      return new Ij(t, e, r, i, a);
    }
    static adagrad(t, e = 0.1) {
      return new Cj(t, e);
    }
  }
  const ef = Kkt;
  const Zkt = typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : (n) => n();
  function Oj() {
    return new Promise((n) => Zkt(() => n()));
  }
  function _R(n, t) {
    const e = n[0].length;
    n.forEach((i, a) => {
      B(i.length === e, () => `Error in concat${e}D: rank of tensors[${a}] must be the same as the rank of the rest (${e})`);
    }), B(t >= 0 && t < e, () => `Error in concat${e}D: axis must be between 0 and ${e - 1}.`);
    const r = n[0];
    n.forEach((i, a) => {
      for (let s = 0; s < e; s++) B(s === t || i[s] === r[s], () => `Error in concat${e}D: Shape of tensors[${a}] (${i}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`);
    });
  }
  function js(n, t) {
    const e = n[0].slice();
    for (let r = 1; r < n.length; r++) e[t] += n[r][t];
    return e;
  }
  var Ya;
  (function(n) {
    n[n.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", n[n.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", n[n.ROW_LENGTHS = 2] = "ROW_LENGTHS", n[n.ROW_SPLITS = 3] = "ROW_SPLITS", n[n.ROW_LIMITS = 4] = "ROW_LIMITS", n[n.ROW_STARTS = 5] = "ROW_STARTS";
  })(Ya || (Ya = {}));
  function Fj(n, t, e) {
    let r = new Array();
    if (e == null && t == null) return r;
    if (t == null) for (; r.length < n + e.length; ) r.push(-1);
    else r = t.slice();
    if (e == null) return r;
    if (n + e.length !== r.length) throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n + e.length}, but shape.rank = ${r.length}`);
    for (let i = 1; i < e.length; ++i) {
      const a = e[i], s = r[r.length - e.length + i], o = r[s];
      if (a >= 0) if (o >= 0) {
        if (o !== a) throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i + n}] = ${a} but shape[${i + n}] = ${o}`);
      } else r[s] = a;
    }
    return r;
  }
  function Bj(n) {
    const t = {
      FIRST_DIM_SIZE: Ya.FIRST_DIM_SIZE,
      VALUE_ROWIDS: Ya.VALUE_ROWIDS,
      ROW_LENGTHS: Ya.ROW_LENGTHS,
      ROW_SPLITS: Ya.ROW_SPLITS,
      ROW_LIMITS: Ya.ROW_LIMITS,
      ROW_STARTS: Ya.ROW_STARTS
    }, e = [];
    for (const r of n) if (r in t) e.push(t[r]);
    else break;
    return e;
  }
  function zj(n) {
    return n.length === 0 ? 0 : n[0] === Ya.FIRST_DIM_SIZE ? n.length - 1 : n.length;
  }
  function Vj(n, t) {
    if (n == null || t == null) return;
    const e = n.length, r = t.length;
    if (e >= r) throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);
    for (let i = 0; i < Math.min(e, r - 1); ++i) {
      const a = n[i], s = t[i + 1];
      if (a >= 0 && s >= 0 && a !== 1 && a !== s) throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i - n.length}] = ${a} but ragged tensor input.flatValues.shape[${i - n.length}] = ${s}`);
    }
  }
  const wR = 30;
  function dw(n) {
    return n <= wR ? n : g2(n, Math.floor(Math.sqrt(n)));
  }
  function SR(n, t, e) {
    const r = e * (typeof n == "number" ? n : n[0]), i = t * (typeof n == "number" ? n : n[1]);
    return [
      r,
      i
    ];
  }
  function Qm(n, t, e, r = true) {
    let i = [];
    if (r) i = i.concat(t.slice(0)), i.push(n[0] / e), i = i.concat(n.slice(1));
    else {
      i = i.concat(n[0]);
      const a = t.length;
      for (let s = 0; s < a; ++s) i = i.concat([
        n[s + 1] / t[s],
        t[s]
      ]);
      i = i.concat(n.slice(a + 1));
    }
    return i;
  }
  function ty(n, t, e = true) {
    const r = [];
    if (e) {
      r.push(t);
      for (let i = t + 1; i < n; ++i) i <= 2 * t ? (r.push(i), r.push(i - (t + 1))) : r.push(i);
    } else {
      const i = [], a = [];
      for (let s = 1; s < n; ++s) s >= t * 2 + 1 || s % 2 === 1 ? a.push(s) : i.push(s);
      r.push(...i), r.push(0), r.push(...a);
    }
    return r;
  }
  function ey(n, t, e, r = true) {
    const i = [];
    r ? i.push(n[0] / e) : i.push(n[0] * e);
    for (let a = 1; a < n.length; ++a) a <= t.length ? r ? i.push(t[a - 1] * n[a]) : i.push(n[a] / t[a - 1]) : i.push(n[a]);
    return i;
  }
  function CR(n, t) {
    const e = [
      0
    ];
    for (let r = 0; r < t; ++r) e.push(n[r][0]);
    return e;
  }
  function TR(n, t, e) {
    const r = n.slice(0, 1);
    for (let i = 0; i < e; ++i) r.push(n[i + 1] - t[i][0] - t[i][1]);
    return r;
  }
  const pw = 1.7580993408473768, gw = 1.0507009873554805;
  const IR = 0.3275911, AR = 0.254829592, kR = -0.284496736, DR = 1.421413741, ER = -1.453152027, MR = 1.061405429;
  function Ko(n, t) {
    if (n.length !== t.length) throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);
    const e = new Float32Array(n.length * 2);
    for (let r = 0; r < e.length; r += 2) e[r] = n[r / 2], e[r + 1] = t[r / 2];
    return e;
  }
  function Gj(n) {
    const t = new Float32Array(n.length / 2), e = new Float32Array(n.length / 2);
    for (let r = 0; r < n.length; r += 2) t[r / 2] = n[r], e[r / 2] = n[r + 1];
    return {
      real: t,
      imag: e
    };
  }
  function Wj(n) {
    const t = Math.ceil(n.length / 4), e = new Float32Array(t), r = new Float32Array(t);
    for (let i = 0; i < n.length; i += 4) e[Math.floor(i / 4)] = n[i], r[Math.floor(i / 4)] = n[i + 1];
    return {
      real: e,
      imag: r
    };
  }
  function Uj(n) {
    const t = Math.floor(n.length / 4), e = new Float32Array(t), r = new Float32Array(t);
    for (let i = 2; i < n.length; i += 4) e[Math.floor(i / 4)] = n[i], r[Math.floor(i / 4)] = n[i + 1];
    return {
      real: e,
      imag: r
    };
  }
  function RR(n, t) {
    const e = n[t * 2], r = n[t * 2 + 1];
    return {
      real: e,
      imag: r
    };
  }
  function Hj(n, t, e, r) {
    n[r * 2] = t, n[r * 2 + 1] = e;
  }
  function Xj(n, t) {
    const e = new Float32Array(n / 2), r = new Float32Array(n / 2);
    for (let i = 0; i < Math.ceil(n / 2); i++) {
      const a = (t ? 2 : -2) * Math.PI * (i / n);
      e[i] = Math.cos(a), r[i] = Math.sin(a);
    }
    return {
      real: e,
      imag: r
    };
  }
  function Yj(n, t, e) {
    const r = (e ? 2 : -2) * Math.PI * (n / t), i = Math.cos(r), a = Math.sin(r);
    return {
      real: i,
      imag: a
    };
  }
  const xT = "->", Jkt = /->/g, rV = ",", iV = "...";
  function NR(n, t) {
    n = n.replace(/\s/g, "");
    const e = (n.length - n.replace(Jkt, "").length) / xT.length;
    if (e < 1) throw new Error("Equations without an arrow are not supported.");
    if (e > 1) throw new Error(`Equation must contain exactly one arrow ("${xT}").`);
    const [r, i] = n.split(xT);
    B(r.indexOf(iV) === -1, () => `The ellipsis notation ("${iV}") is not supported yet.`);
    const a = r.split(rV), s = a.length;
    if (t !== s) throw new Error(`Expected ${s} input tensors, received ${t}`);
    if (s > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
    const o = [];
    for (let f = 0; f < i.length; ++f) {
      const d = i[f];
      if (!a.some((p) => p.indexOf(d) !== -1)) throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);
      o.indexOf(d) === -1 && o.push(d);
    }
    for (let f = 0; f < r.length; ++f) {
      const d = r[f];
      o.indexOf(d) === -1 && d !== rV && o.push(d);
    }
    const l = new Array(a.length);
    for (let f = 0; f < s; ++f) {
      if (new Set(a[f].split("")).size !== a[f].length) throw new Error(`Found duplicate axes in input component ${a[f]}. Support for duplicate axes in input is not implemented yet.`);
      l[f] = [];
      for (let d = 0; d < a[f].length; ++d) l[f].push(o.indexOf(a[f][d]));
    }
    const u = o.length, c = i.length, h = [];
    for (let f = c; f < u; ++f) h.push(f);
    return {
      allDims: o,
      summedDims: h,
      idDims: l
    };
  }
  function LR(n, t) {
    let e = new Array(n);
    e.fill(-1);
    for (let i = 0; i < t.length; ++i) e[t[i]] = i;
    const r = [];
    for (let i = 0; i < n; ++i) e[i] === -1 && r.push(i);
    return e = e.filter((i) => i !== -1), {
      permutationIndices: e,
      expandDims: r
    };
  }
  function PR(n, t, e) {
    const r = new Array(n);
    for (let i = 0; i < e.length; ++i) {
      const a = e[i].shape;
      for (let s = 0; s < t[i].length; ++s) r[t[i][s]] === void 0 ? r[t[i][s]] = a[s] : B(r[t[i][s]] === a[s], () => `Expected dimension ${r[t[i][s]]} at axis ${s} of input shaped ${JSON.stringify(a)}, but got dimension ${a[s]}`);
    }
  }
  function $R(n, t) {
    const e = n, r = [];
    let i = 0;
    n.length === 0 && e.push(-1), i = n.length + 1;
    for (let s = 0; s < i; ++s) r.push([]);
    const a = [];
    for (let s = 0; s < e.length; ++s) {
      const o = e[s], l = Qkt(t, o);
      for (const u of l) a.indexOf(u) === -1 && (r[s].push(u), a.push(u));
    }
    return {
      path: e,
      steps: r
    };
  }
  function OR(n) {
    return n.every((t, e) => t === e);
  }
  function Qkt(n, t) {
    const e = [];
    for (let r = 0; r < n.length; ++r) (n[r].length === 0 || n[r].indexOf(t) !== -1 || t === -1) && e.push(r);
    return e;
  }
  function FR(n, t, e = 0) {
    let r = [];
    if (typeof t == "number") B(n.shape[e] % t === 0, () => "Number of splits must evenly divide the axis."), r = new Array(t).fill(n.shape[e] / t);
    else {
      const i = t.reduce((s, o) => (o === -1 && (s += 1), s), 0);
      B(i <= 1, () => "There should be only one negative value in split array.");
      const a = t.indexOf(-1);
      if (a !== -1) {
        const s = t.reduce((o, l) => l > 0 ? o + l : o);
        t[a] = n.shape[e] - s;
      }
      B(n.shape[e] === t.reduce((s, o) => s + o), () => "The sum of sizes must match the size of the axis dimension."), r = t;
    }
    return r;
  }
  function qj(n) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`;
  }
  function jj(n, t) {
    return `indices(${n}, 0) is invalid: ${t} < 0`;
  }
  function Kj(n, t, e) {
    return `indices(${n}, 0) is invalid: ${t} >= ${e}`;
  }
  function Zj(n, t) {
    return `only one output dimension may be -1, not both ${n} and ${t}`;
  }
  function Jj(n, t) {
    return `size ${n} must be non-negative, not ${t}`;
  }
  function Qj() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
  }
  function t7(n, t) {
    const e = lt(n), r = lt(t);
    return `Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${t}`;
  }
  function e7(n, t) {
    const e = lt(n), r = lt(t);
    return `Input to reshape is a tensor with ${e} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${t}`;
  }
  function R2() {
    return "segment ids must be >= 0";
  }
  function n7() {
    return "segment ids are not increasing";
  }
  function r7(n, t) {
    return `Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`;
  }
  function i7(n, t, e) {
    return `Bad: indices[${n}] == ${t} out of range [0, ${e})`;
  }
  function a7(n, t) {
    let e = false, r;
    for (n <= wR ? (r = n, e = true) : r = g2(n, Math.floor(Math.sqrt(n))); !e; ) r > t || r === n ? e = true : r = g2(n, r + 1);
    return r;
  }
  function s7(n, t, e) {
    const r = [], i = n.length;
    for (let a = 0; a < i; a++) a !== t ? r.push(n[a]) : r.push(e);
    return r;
  }
  function BR(n, t, e, r) {
    const i = t.shape.length, a = n.shape.length;
    if (r !== 0 && (r < -i || r > i)) throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);
    if (r < 0 && (r += i), r > a) throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);
    if (e < r) throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);
    for (let h = 0; h < r; ++h) if (n.shape[h] !== t.shape[h]) throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);
    const s = n.shape[e], o = [];
    let l = 1, u = 1, c = 1;
    for (let h = 0; h < r; ++h) o.push(n.shape[h]), l *= n.shape[h];
    for (let h = r; h < e; h++) o.push(n.shape[h]), u *= n.shape[h];
    for (let h = r; h < i; h++) o.push(t.shape[h]);
    for (let h = e + 1; h < a; h++) o.push(n.shape[h]), c *= n.shape[h];
    return {
      batchSize: l,
      sliceSize: c,
      outerSize: u,
      dimSize: s,
      outputShape: o
    };
  }
  const tDt = Object.freeze(Object.defineProperty({
    __proto__: null,
    collectGatherOpShapeInfo: BR,
    computeOutShape: s7,
    segOpComputeOptimalWindowSize: a7
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function Zo(n) {
    try {
      return n.map((t) => tu(t));
    } catch (t) {
      throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`);
    }
  }
  function o7(n) {
    return n.map((t) => Gl(t));
  }
  const eDt = Object.freeze(Object.defineProperty({
    __proto__: null,
    ERF_A1: AR,
    ERF_A2: kR,
    ERF_A3: DR,
    ERF_A4: ER,
    ERF_A5: MR,
    ERF_P: IR,
    PARALLELIZE_THRESHOLD: wR,
    get RowPartitionType() {
      return Ya;
    },
    SELU_SCALE: gw,
    SELU_SCALEALPHA: pw,
    applyActivation: lR,
    assertAndGetBroadcastShape: ve,
    assertAxesAreInnerMostDims: wr,
    assertParamsConsistent: _R,
    assignToTypedArray: Hj,
    axesAreInnerMostDims: HM,
    calculateShapes: Sh,
    checkEinsumDimSizes: PR,
    checkPadOnDimRoundingMode: wi,
    combineLocations: Qq,
    combineRaggedTensorToTensorShapes: Fj,
    complexWithEvenIndex: Wj,
    complexWithOddIndex: Uj,
    computeConv2DInfo: _r,
    computeConv3DInfo: cu,
    computeDefaultPad: BM,
    computeDilation2DInfo: qm,
    computeOptimalWindowSize: dw,
    computeOutAndReduceShapes: hr,
    computeOutShape: js,
    computePool2DInfo: Ra,
    computePool3DInfo: rl,
    convertConv2DDataFormat: il,
    decodeEinsumEquation: NR,
    eitherStridesOrDilationsAreOne: Rr,
    expandShapeToKeepDim: Bn,
    exponent: Yj,
    exponents: Xj,
    fromStringArrayToUint8: o7,
    fromUint8ToStringArray: Zo,
    getAxesPermutation: wn,
    getBroadcastDims: ed,
    getComplexWithIndex: RR,
    getEinsumComputePath: $R,
    getEinsumPermutation: LR,
    getFusedBiasGradient: oR,
    getFusedDyActivation: sR,
    getImageCenter: SR,
    getInnerMostAxes: Rn,
    getPermuted: ty,
    getRaggedRank: zj,
    getReductionAxes: Jn,
    getReshaped: Qm,
    getReshapedPermuted: ey,
    getRowPartitionTypesHelper: Bj,
    getSliceBeginCoords: CR,
    getSliceSize: TR,
    getSparseFillEmptyRowsIndicesDenseShapeMismatch: qj,
    getSparseFillEmptyRowsNegativeIndexErrorMessage: jj,
    getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: Kj,
    getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: Qj,
    getSparseReshapeInputOutputMismatchErrorMessage: e7,
    getSparseReshapeInputOutputMultipleErrorMessage: t7,
    getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: Zj,
    getSparseReshapeNegativeOutputDimErrorMessage: Jj,
    getSparseSegmentReductionIndicesOutOfRangeErrorMessage: i7,
    getSparseSegmentReductionNegativeSegmentIdsErrorMessage: R2,
    getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: n7,
    getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: r7,
    getUndoAxesPermutation: hu,
    isIdentityPermutation: OR,
    log: NSt,
    mergeRealAndImagArrays: Ko,
    prepareAndValidate: gR,
    prepareSplitSize: FR,
    segment_util: tDt,
    shouldFuse: uR,
    slice_util: jkt,
    splitRealAndImagArrays: Gj,
    stridesOrDilationsArePositive: eh,
    tupleValuesAreOne: th,
    upcastType: $i,
    validateDefaultValueShape: Vj,
    validateInput: R2t,
    validateUpdateShape: mj,
    warn: Wi
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  Ukt();
  const l7 = {
    kernelName: n_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(n, Jm(Et(e, "float32"), -1))
      };
    }
  };
  const nDt = {
    kernelName: Qv,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => {
          const r = gn(Et(e, "float32")), i = Mr(re(Ue(1), r));
          return En(Jt(n, i));
        }
      };
    }
  };
  const rDt = {
    kernelName: tm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => {
          const r = Mr(re(gn(Et(e, "float32")), 1));
          return Jt(n, r);
        }
      };
    }
  };
  const iDt = {
    kernelName: Ld,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = ve(e.shape, r.shape);
      return {
        a: () => {
          let o = n;
          const l = Jn(e.shape, i);
          return l.length > 0 && (o = Kt(o, l)), Z(o, e.shape);
        },
        b: () => {
          let o = n;
          const l = Jn(r.shape, i);
          return l.length > 0 && (o = Kt(o, l)), Z(o, r.shape);
        }
      };
    }
  };
  const aDt = {
    kernelName: KE,
    saveAllInputs: true,
    gradFunc: (n, t) => {
      const e = {};
      return t.forEach((r, i) => {
        e[i] = () => n.clone();
      }), e;
    }
  };
  const sDt = {
    kernelName: r_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Fe(e)
      };
    }
  };
  const oDt = {
    kernelName: i_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Fe(e)
      };
    }
  };
  const lDt = {
    kernelName: em,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Jt(n, Mr(re(Ue(1), gn(Et(e, "float32")))))
      };
    }
  };
  const uDt = {
    kernelName: nm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => {
          const r = Mr(bt(Ue(1), gn(Et(e, "float32"))));
          return Jt(n, r);
        }
      };
    }
  };
  const cDt = {
    kernelName: am,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = ve(e.shape, r.shape);
      return {
        a: () => {
          const o = bt(gn(e), gn(r));
          let l = j(n, Jt(r, o));
          const u = Jn(e.shape, i);
          return u.length > 0 && (l = Kt(l, u)), Z(l, e.shape);
        },
        b: () => {
          const o = bt(gn(e), gn(r));
          let l = En(j(n, Jt(e, o)));
          const u = Jn(r.shape, i);
          return u.length > 0 && (l = Kt(l, u)), Z(l, r.shape);
        }
      };
    }
  };
  const hDt = {
    kernelName: rm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Jt(n, bt(gn(Et(e, "float32")), 1))
      };
    }
  };
  const fDt = {
    kernelName: im,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Jt(n, re(Ue(1), gn(Et(e, "float32"))))
      };
    }
  };
  function dDt(n, t, e, r, i, a) {
    const s = W(n, "dy", "avgPool3dGrad"), o = W(t, "input", "avgPool3dGrad");
    let l = s, u = o, c = false;
    o.rank === 4 && (c = true, l = Z(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2],
      s.shape[3]
    ]), u = Z(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2],
      o.shape[3]
    ])), B(l.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`), B(u.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`), wi("avgPool3dGrad", i, a);
    const h = {
      dy: l,
      input: u
    }, f = {
      filterSize: e,
      strides: r,
      pad: i,
      dimRoundingMode: a
    }, d = K.runKernel(tM, h, f);
    return c ? Z(d, [
      d.shape[1],
      d.shape[2],
      d.shape[3],
      d.shape[4]
    ]) : d;
  }
  const pDt = Q({
    avgPool3dGrad_: dDt
  });
  const gDt = {
    kernelName: s_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { filterSize: i, strides: a, pad: s, dimRoundingMode: o } = e;
      return {
        x: () => pDt(n, r, i, a, s, o)
      };
    }
  };
  function vDt(n, t, e, r, i) {
    const a = W(n, "dy", "avgPoolGrad"), s = W(t, "input", "avgPoolGrad");
    B(s.rank === a.rank, () => `Rank of input (${s.rank}) does not match rank of dy (${a.rank})`);
    let o = s, l = a, u = false;
    s.rank === 3 && (u = true, o = Z(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2]
    ]), l = Z(a, [
      1,
      a.shape[0],
      a.shape[1],
      a.shape[2]
    ])), B(l.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`), B(o.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);
    const c = {
      dy: l,
      input: o
    }, h = {
      filterSize: e,
      strides: r,
      pad: i
    }, f = K.runKernel(QE, c, h);
    return u ? Z(f, [
      f.shape[1],
      f.shape[2],
      f.shape[3]
    ]) : f;
  }
  const mDt = Q({
    avgPoolGrad_: vDt
  });
  const yDt = {
    kernelName: a_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { filterSize: i, strides: a, pad: s } = e;
      return {
        x: () => mDt(n, r, i, a, s)
      };
    }
  };
  const xDt = {
    kernelName: o_,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t, e) => {
      const [r, i] = t, { transposeA: a, transposeB: s } = e;
      return !a && !s ? {
        a: () => Ge(n, i, false, true),
        b: () => Ge(r, n, true, false)
      } : !a && s ? {
        a: () => Ge(n, i, false, false),
        b: () => Ge(n, r, true, false)
      } : a && !s ? {
        a: () => Ge(i, n, false, true),
        b: () => Ge(r, n, false, false)
      } : {
        a: () => Ge(i, n, true, true),
        b: () => Ge(n, r, true, true)
      };
    }
  };
  const bDt = {
    kernelName: l_,
    gradFunc: (n, t, e) => {
      const { blockShape: r, crops: i } = e;
      return {
        x: () => QM(n, r, i)
      };
    }
  };
  const _Dt = {
    kernelName: DSt,
    gradFunc: (n, t, e) => {
      const r = e, i = r.inputShape, a = r.shape, s = Array.from(a);
      for (let l = i.length - 1; l >= 0; l--) if (i[l] === a[l]) s[l] = 1;
      else if (i[l] !== 1) throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${a}].`);
      const o = [];
      for (let l = 0; l < s.length; l++) s[l] > 1 && o.push(l);
      return {
        x: () => Kt(n, o, true)
      };
    }
  };
  const wDt = {
    kernelName: sm,
    gradFunc: (n) => ({
      x: () => n.clone()
    })
  };
  const SDt = {
    kernelName: om,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const CDt = {
    kernelName: lm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { clipValueMin: i, clipValueMax: a } = e;
      return {
        x: () => qr(qo(_h(r, i), Od(r, a)), n, Fe(n))
      };
    }
  };
  const TDt = {
    kernelName: u_,
    inputsToSave: [
      "x"
    ],
    gradFunc: l7.gradFunc
  };
  const IDt = {
    kernelName: c_,
    saveAllInputs: true,
    gradFunc: (n, t, e) => {
      const r = t.map((l) => l.shape), { axis: i } = e, a = Se(i, t[0].shape)[0], s = r.map((l) => l[a]);
      return ji(n, s, a).map((l) => () => l);
    }
  };
  const ADt = {
    kernelName: h_,
    inputsToSave: [
      "x",
      "filter"
    ],
    gradFunc: (n, t, e) => {
      const [r, i] = t, { dilations: a, strides: s, pad: o, dataFormat: l } = e;
      return B(th(a), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`), {
        x: () => GM(r.shape, n, i, s, o, l),
        filter: () => aR(r, n, i.shape, s, o, l)
      };
    }
  };
  const kDt = {
    kernelName: f_,
    inputsToSave: [
      "dy",
      "filter"
    ],
    gradFunc: (n, t, e) => {
      const [r, i] = t, { strides: a, pad: s, dataFormat: o, dimRoundingMode: l } = e;
      return {
        dy: () => nh(n, i, a, s, o, 1, l),
        filter: () => aR(n, r, i.shape, a, s, o, l)
      };
    }
  };
  function DDt(n, t, e, r, i) {
    let a = n;
    n.rank === 4 && (a = Z(n, [
      1,
      n.shape[0],
      n.shape[1],
      n.shape[2],
      n.shape[3]
    ]));
    let s = t;
    s.rank === 4 && (s = Z(t, [
      1,
      t.shape[0],
      t.shape[1],
      t.shape[2],
      t.shape[3]
    ])), B(a.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`), B(s.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${s.shape}.`), B(e.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`), B(a.shape[4] === e[3], () => `Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${e[3]}.`), B(s.shape[4] === e[4], () => `Error in conv3dDerFilter: depth of dy (${s.shape[4]}) must match output depth for filter (${e[4]}).`);
    const o = {
      x: a,
      dy: s
    }, l = {
      strides: r,
      pad: i,
      filterShape: e
    };
    return K.runKernel(aM, o, l);
  }
  const EDt = Q({
    conv3DBackpropFilter_: DDt
  });
  const MDt = {
    kernelName: d_,
    inputsToSave: [
      "x",
      "filter"
    ],
    gradFunc: (n, t, e) => {
      const { dilations: r, strides: i, pad: a } = e;
      B(th(r), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);
      const [s, o] = t;
      return {
        x: () => jq(s.shape, n, o, i, a),
        filter: () => EDt(s, n, o.shape, i, a)
      };
    }
  };
  const RDt = {
    kernelName: um,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(En(dj(Et(e, "float32"))), n)
      };
    }
  };
  const NDt = {
    kernelName: cm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(pj(Et(e, "float32")), n)
      };
    }
  };
  const LDt = {
    kernelName: p_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { axis: i, exclusive: a, reverse: s } = e;
      return {
        x: () => {
          const o = wn([
            i
          ], r.rank);
          let l = Zq(n, i, a, !s);
          return o != null && (l = Oe(l, o)), l;
        }
      };
    }
  };
  const PDt = {
    kernelName: g_,
    inputsToSave: [
      "x",
      "filter"
    ],
    gradFunc: (n, t, e) => {
      const { dilations: r, strides: i, pad: a, dimRoundingMode: s } = e, o = r ?? [
        1,
        1
      ];
      B(th(o), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);
      const [l, u] = t;
      return B(l.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`), B(u.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`), B(l.shape[3] === u.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`), B(Rr(i, o), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`), wi("depthwiseConv2d", a, s), {
        x: () => Z2t(l.shape, n, u, i, a, o, s),
        filter: () => j2t(l, n, u.shape, i, a, o, s)
      };
    }
  };
  const $Dt = {
    kernelName: v_,
    inputsToSave: [
      "x",
      "filter"
    ],
    gradFunc: (n, t, e) => {
      const [r, i] = t, a = {
        x: r,
        filter: i,
        dy: n
      }, s = {
        x: r,
        filter: i,
        dy: n
      };
      return {
        x: () => K.runKernel(v2, a, e),
        filter: () => K.runKernel(m2, s, e)
      };
    }
  };
  const ODt = {
    kernelName: fm,
    outputsToSave: [
      true
    ],
    gradFunc: (n, t) => {
      const [e] = t, r = {
        dy: n,
        y: e
      };
      return {
        x: () => K.runKernel(pM, r)
      };
    }
  };
  const FDt = {
    kernelName: dm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t, r = j(ao(En(gn(e))), 2 / Math.sqrt(Math.PI));
      return {
        x: () => j(n, r)
      };
    }
  };
  const BDt = {
    kernelName: pm,
    outputsToSave: [
      true
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(n, e)
      };
    }
  };
  const zDt = {
    kernelName: y_,
    inputsToSave: [
      "input"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        input: () => Z(n, e.shape)
      };
    }
  };
  const VDt = {
    kernelName: gm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(n, ao(e))
      };
    }
  };
  const GDt = {
    kernelName: vm,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const WDt = {
    kernelName: mm,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = ve(e.shape, r.shape);
      return {
        a: () => {
          const o = Jt(n, Et(r, "float32")), l = Jn(e.shape, i);
          return l.length > 0 ? Z(Kt(o, l), e.shape) : o;
        },
        b: () => {
          let o = j(n, Et(e, "float32"));
          const l = Jn(r.shape, i);
          l.length > 0 && (o = Z(Kt(o, l), r.shape));
          const u = gn(r);
          return En(Jt(o, Et(u, "float32")));
        }
      };
    }
  };
  const UDt = {
    kernelName: x_,
    inputsToSave: [
      "x",
      "mean",
      "variance",
      "scale"
    ],
    gradFunc: (n, t, e) => {
      const { varianceEpsilon: r } = e, [i, a, s, o] = t, l = o ?? Ue(1), u = Jn(a.shape, i.shape), c = [];
      if (a.rank === 1) {
        for (let b = 0; b < i.shape.length - 1; ++b) c.push(i.shape[b]);
        c.push(1);
      }
      const h = re(i, a), f = j(n, l), d = cj(bt(s, Ue(r))), p = j(j(j(d, d), d), Ue(-0.5));
      return {
        x: () => a.rank === 1 ? Z(j(j(n, Za(Z(d, [
          1,
          1,
          1,
          a.shape[0]
        ]), c)), l), i.shape) : Z(j(j(n, d), l), i.shape),
        mean: () => {
          let b = j(j(d, Ue(-1)), f);
          return a.rank === 1 && (b = Kt(b, u)), Z(b, a.shape);
        },
        variance: () => {
          let b = j(j(p, h), f);
          return a.rank === 1 && (b = Kt(b, u)), Z(b, a.shape);
        },
        scale: () => {
          const b = j(h, d);
          let _ = j(n, b);
          return a.rank === 1 && (_ = Kt(_, u)), Z(_, a.shape);
        },
        offset: () => {
          let b = n;
          return a.rank === 1 && (b = Kt(b, u)), Z(b, a.shape);
        }
      };
    }
  };
  const HDt = {
    kernelName: b_,
    inputsToSave: [
      "x",
      "indices"
    ],
    gradFunc: (n, t, e) => {
      const [r, i] = t, { axis: a, batchDims: s } = e, o = Se(a, r.shape)[0], l = (u, c, h) => () => {
        const f = u.shape, d = c.size, p = f.slice(0, o), g = p.length, v = f.slice(a, f.length).slice(1), m = v.length, y = aV(0, g), x = aV(g + 1, g + 1 + m), b = sV([
          p,
          [
            d
          ],
          v
        ]), _ = Z(h, b), w = Z(c, [
          d
        ]), S = sV([
          [
            g
          ],
          y,
          x
        ]), I = Oe(_, S);
        let T = xj(I, w, u.shape[o]);
        const A = hu(S);
        return T = Oe(T, A), T;
      };
      if (s === 1) {
        const u = r.shape[0], c = r.split(u, 0);
        return {
          x: () => jo(c.map((d, p) => l(d, i.slice(p, 1), n.slice(p, 1))())).reshape(r.shape),
          indices: () => i
        };
      } else return {
        x: l(r, i, n),
        indices: () => i
      };
    }
  };
  function aV(n, t) {
    const e = [];
    for (let r = n; r < t; ++r) e.push(r);
    return e;
  }
  function sV(n) {
    const t = [];
    for (let e = 0; e < n.length; ++e) for (let r = 0; r < n[e].length; ++r) t.push(n[e][r]);
    return t;
  }
  const XDt = {
    kernelName: ym,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t;
      return {
        a: () => Fe(e),
        b: () => Fe(r)
      };
    }
  };
  const YDt = {
    kernelName: xm,
    gradFunc: (n) => ({
      x: () => Et(n, "float32")
    })
  };
  const qDt = {
    kernelName: bm,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const jDt = {
    kernelName: _m,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const KDt = {
    kernelName: wm,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const ZDt = {
    kernelName: w_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { alpha: i } = e, a = ea(r, 0);
      return {
        x: () => qr(a, n, j(n, i))
      };
    }
  };
  const JDt = {
    kernelName: Cm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Jt(n, bt(e, 1))
      };
    }
  };
  const QDt = {
    kernelName: Sm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Jt(n, Et(e, "float32"))
      };
    }
  };
  const tEt = {
    kernelName: MSt,
    inputsToSave: [],
    outputsToSave: [
      true
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { axis: i } = e;
      return {
        logits: () => {
          const s = ao(r);
          return re(n, j(Kt(n, i, true), s));
        }
      };
    }
  };
  function eEt(n, t, e, r = 5, i = 1, a = 1, s = 0.5) {
    const o = {
      x: n,
      y: t,
      dy: e
    }, l = {
      depthRadius: r,
      bias: i,
      alpha: a,
      beta: s
    };
    return K.runKernel(bM, o, l);
  }
  const nEt = Q({
    localResponseNormalizationBackprop_: eEt
  });
  const rEt = {
    kernelName: k_,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, t, e) => {
      const [r, i] = t, { depthRadius: a, bias: s, alpha: o, beta: l } = e;
      return {
        x: () => nEt(r, i, n, a, s, o, l)
      };
    }
  };
  function u7(n, t, e, r) {
    return t.rank < e.rank && (t = Z(t, Bn(t.shape, r))), n.rank < e.rank && (n = Z(n, Bn(n.shape, r))), {
      x: () => j(n, Et(io(e, t), n.dtype))
    };
  }
  const oV = {
    kernelName: D_,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, t, e) => {
      const r = e, { reductionIndices: i } = r, a = t[0], s = t[1], o = Se(i, a.shape), l = u7(n, s, a, o);
      return {
        x: () => l.x()
      };
    }
  };
  const iEt = {
    kernelName: Tm,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t;
      return {
        a: () => j(n, Et(_h(e, r), "float32")),
        b: () => j(n, Et(zb(e, r), "float32"))
      };
    }
  };
  function aEt(n, t, e, r, i, a, s) {
    const o = W(n, "dy", "maxPool3dGrad"), l = W(t, "input", "maxPool3dGrad"), u = W(e, "output", "maxPool3dGrad");
    let c = o, h = l, f = u, d = false;
    l.rank === 4 && (d = true, c = Z(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2],
      o.shape[3]
    ]), h = Z(l, [
      1,
      l.shape[0],
      l.shape[1],
      l.shape[2],
      l.shape[3]
    ]), f = Z(u, [
      1,
      u.shape[0],
      u.shape[1],
      u.shape[2],
      u.shape[3]
    ])), B(c.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`), B(h.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`), B(f.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`), wi("maxPool3dGrad", a, s);
    const p = {
      dy: c,
      input: h,
      output: f
    }, g = {
      filterSize: r,
      strides: i,
      pad: a,
      dimRoundingMode: s
    }, v = K.runKernel(wM, p, g);
    return d ? Z(v, [
      v.shape[1],
      v.shape[2],
      v.shape[3],
      v.shape[4]
    ]) : v;
  }
  const sEt = Q({
    maxPool3dGrad_: aEt
  });
  const oEt = {
    kernelName: M_,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, t, e) => {
      const [r, i] = t, { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = e;
      return {
        x: () => sEt(n, r, i, a, s, o, l)
      };
    }
  };
  function lEt(n, t, e, r, i, a, s) {
    const o = W(n, "dy", "maxPoolGrad"), l = W(t, "input", "maxPoolGrad"), u = W(e, "output", "maxPoolGrad");
    B(l.rank === o.rank, () => `Rank of input (${l.rank}) does not match rank of dy (${o.rank})`), B(o.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`), B(l.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`), wi("maxPoolGrad", a, s);
    const c = {
      dy: o,
      input: l,
      output: u
    }, h = {
      filterSize: r,
      strides: i,
      pad: a,
      dimRoundingMode: s
    };
    return K.runKernel(_M, c, h);
  }
  const uEt = Q({
    maxPoolGrad_: lEt
  });
  const cEt = {
    kernelName: E_,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, t, e) => {
      const [r, i] = t, { filterSize: a, strides: s, pad: o } = e;
      return {
        x: () => uEt(n, r, i, a, s, o)
      };
    }
  };
  const hEt = {
    kernelName: R_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { axis: i } = e, a = Se(i, r.shape), o = hr(r.shape, a)[1], l = lt(o);
      return {
        x: () => {
          const c = r.shape.slice();
          a.forEach((d) => {
            c[d] = 1;
          });
          const h = Z(n, c);
          return Jt(j(h, du(r.shape, "float32")), l);
        }
      };
    }
  };
  const fEt = {
    kernelName: N_,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, t, e) => {
      const r = e, { axis: i } = r, [a, s] = t, o = Se(i, a.shape), l = u7(n, s, a, o);
      return {
        x: () => l.x()
      };
    }
  };
  const dEt = {
    kernelName: Im,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t;
      return {
        a: () => j(n, Et(Od(e, r), "float32")),
        b: () => j(n, Et(ea(e, r), "float32"))
      };
    }
  };
  const pEt = {
    kernelName: L_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const r = t[0], { paddings: i } = e, a = i.map((s) => s[0]);
      return {
        x: () => hn(n, a, r.shape)
      };
    }
  };
  const gEt = {
    kernelName: Am,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = ve(e.shape, r.shape);
      return {
        a: () => {
          const o = Jn(e.shape, i);
          return o.length > 0 ? Z(Kt(n, o), e.shape) : n;
        },
        b: () => {
          const o = j(n, En(hw(Jt(e, r)))), l = Jn(r.shape, i);
          return l.length > 0 ? Z(Kt(o, l), r.shape) : o;
        }
      };
    }
  };
  const vEt = {
    kernelName: km,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = ve(e.shape, r.shape);
      return {
        a: () => {
          const o = j(n, Et(r, "float32")), l = Jn(e.shape, i);
          return l.length > 0 ? Z(Kt(o, l), e.shape) : o;
        },
        b: () => {
          const o = j(n, Et(e, "float32")), l = Jn(r.shape, i);
          return l.length > 0 ? Z(Kt(o, l), r.shape) : o;
        }
      };
    }
  };
  const mEt = {
    kernelName: P_,
    gradFunc: (n) => ({
      x: () => En(n)
    })
  };
  const yEt = {
    kernelName: F_,
    inputsToSave: [
      "indices"
    ],
    gradFunc: (n, t) => {
      const e = t[0];
      return {
        indices: () => rr(e.shape, "float32")
      };
    }
  };
  const xEt = {
    kernelName: O_,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const bEt = {
    kernelName: B_,
    saveAllInputs: true,
    gradFunc: (n, t, e) => {
      const { axis: r } = e;
      return ah(n, r).map((a) => () => a);
    }
  };
  const lV = {
    kernelName: z_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const r = t[0], { paddings: i } = e, a = i.map((s) => s[0]);
      return {
        x: () => hn(n, a, r.shape)
      };
    }
  };
  const _Et = {
    kernelName: Dm,
    inputsToSave: [
      "a",
      "b"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, t) => {
      const [e, r, i] = t, a = e, s = r, o = ve(a.shape, s.shape);
      return {
        a: () => {
          const c = Et(s, "float32");
          let h = j(n, j(c, rh(a, re(c, Ue(1)))));
          const f = Jn(a.shape, o);
          return f.length > 0 && (h = Kt(h, f)), Z(h, a.shape);
        },
        b: () => {
          const c = ea(a, 0), h = qr(c, so(a), Fe(a));
          let f = j(n, j(i, h));
          const d = Jn(s.shape, o);
          return d.length > 0 && (f = Kt(f, d)), Z(f, s.shape);
        }
      };
    }
  };
  const wEt = {
    kernelName: V_,
    inputsToSave: [
      "x",
      "alpha"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = ea(e, 0);
      return {
        x: () => qr(i, n, j(n, r)),
        alpha: () => {
          let a = qr(i, Fe(n), j(n, e));
          const s = Jn(r.shape, n.shape);
          return s.length > 0 && (a = Kt(a, s)), Z(a, r.shape);
        }
      };
    }
  };
  function SEt(n, t, e) {
    const r = n.shape.slice();
    r[e] = 1;
    const i = Z(t, r), a = D2(n, e, true, false), s = D2(n, e, true, true), o = j(a, s);
    return j(i, o);
  }
  function CEt(n, t, e) {
    const r = n.shape.length, i = r - e.length, a = wn(e, r);
    let s = n;
    a != null && (s = Oe(n, a));
    const o = s.shape.slice(), u = o.splice(r - e.length, e.length).reduce((f, d) => f * d, 1);
    o.push(u);
    const c = s.reshape(o);
    let h = SEt(c, t, i);
    if (h = h.reshape(s.shape), a != null) {
      const f = hu(a);
      h = Oe(h, f);
    }
    return h;
  }
  const TEt = {
    kernelName: G_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { axis: i } = e;
      let a = [];
      return i == null ? a = r.shape.map((s, o) => o) : typeof i == "number" ? a = [
        i
      ] : a = i, {
        x: () => CEt(r, n, a)
      };
    }
  };
  const IEt = {
    kernelName: hm,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = ve(e.shape, r.shape);
      return {
        a: () => {
          const o = Jt(n, Et(r, "float32")), l = Jn(e.shape, i);
          return l.length > 0 ? Z(Kt(o, l), e.shape) : o;
        },
        b: () => {
          let o = j(n, Et(e, "float32"));
          const l = Jn(r.shape, i);
          l.length > 0 && (o = Z(Kt(o, l), r.shape));
          const u = gn(r);
          return En(Jt(o, Et(u, "float32")));
        }
      };
    }
  };
  const AEt = {
    kernelName: Em,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Jt(n, En(gn(e)))
      };
    }
  };
  const kEt = {
    kernelName: Rm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t, r = j(Od(e, 6), Jm(e));
      return {
        x: () => j(n, Et(r, "float32"))
      };
    }
  };
  const DEt = {
    kernelName: Mm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(n, Et(Jm(e), "float32"))
      };
    }
  };
  const EEt = {
    kernelName: W_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Z(n, e.shape)
      };
    }
  };
  const MEt = {
    kernelName: H_,
    inputsToSave: [
      "images"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, i = {
        dy: n,
        images: r
      };
      return {
        images: () => K.runKernel(DM, i, e)
      };
    }
  };
  const REt = {
    kernelName: U_,
    inputsToSave: [
      "images"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, i = {
        dy: n,
        images: r
      };
      return {
        images: () => K.runKernel(kM, i, e)
      };
    }
  };
  const NEt = {
    kernelName: X_,
    gradFunc: (n, t, e) => {
      const { dims: r } = e, i = Se(r, n.shape);
      return {
        x: () => ih(n, i)
      };
    }
  };
  const LEt = {
    kernelName: Nm,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const PEt = {
    kernelName: Lm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => En(Jt(n, j(rh(e, 1.5), 2)))
      };
    }
  };
  const $Et = {
    kernelName: Y_,
    inputsToSave: [
      "condition"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        condition: () => Et(Fe(e), "float32"),
        t: () => j(n, Et(e, n.dtype)),
        e: () => j(n, Et(jM(e), n.dtype))
      };
    }
  };
  const OEt = {
    kernelName: Pm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => {
          const r = ea(e, Ue(0)), i = Ue(pw), a = Ue(gw), s = j(n, a), o = j(j(n, i), ao(Et(e, "float32")));
          return qr(r, s, o);
        }
      };
    }
  };
  const FEt = {
    kernelName: Bm,
    outputsToSave: [
      true
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(n, j(e, re(Ue(1), e)))
      };
    }
  };
  const BEt = {
    kernelName: Fm,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const zEt = {
    kernelName: $m,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(WM(Et(e, "float32")), n)
      };
    }
  };
  const VEt = {
    kernelName: Om,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(Kq(Et(e, "float32")), n)
      };
    }
  };
  const GEt = {
    kernelName: q_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { begin: i, size: a } = e, s = r.shape, [o, l] = fw(r, i, a), u = [];
      for (let c = 0; c < n.rank; c++) u.push([
        o[c],
        s[c] - o[c] - l[c]
      ]);
      return {
        x: () => JM(n, u)
      };
    }
  };
  const WEt = {
    kernelName: J_,
    outputsToSave: [
      true
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { dim: i } = e, a = true, s = j(n, r);
      return {
        logits: () => re(s, j(Kt(s, [
          i
        ], a), r))
      };
    }
  };
  const UEt = {
    kernelName: zm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(n, $d(e))
      };
    }
  };
  const uV = {
    kernelName: K_,
    gradFunc: (n, t, e) => {
      const { blockShape: r, paddings: i } = e;
      return {
        x: () => VM(n, r, i)
      };
    }
  };
  const cV = {
    kernelName: Z_,
    gradFunc: (n, t, e) => {
      const { axis: r } = e;
      return {
        x: () => pi(n, r)
      };
    }
  };
  const HEt = {
    kernelName: Vm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Jt(n, j(Mr(Et(e, "float32")), 2))
      };
    }
  };
  const XEt = {
    kernelName: EM,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(n, j(Et(e, "float32"), 2))
      };
    }
  };
  const YEt = {
    kernelName: Gm,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = Ue(2);
      return {
        a: () => j(n, j(i, re(e, r))),
        b: () => j(n, j(i, re(r, e)))
      };
    }
  };
  const qEt = {
    kernelName: Ym,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const jEt = {
    kernelName: Wm,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, t) => {
      const [e, r] = t, i = ve(e.shape, r.shape);
      return {
        a: () => {
          let o = n;
          const l = Jn(e.shape, i);
          return l.length > 0 && (o = Kt(o, l)), Z(o, e.shape);
        },
        b: () => {
          let o = n;
          const l = Jn(r.shape, i);
          return l.length > 0 && (o = Kt(o, l)), Z(En(o), r.shape);
        }
      };
    }
  };
  const KEt = {
    kernelName: j_,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, i = r.shape.slice(), { axis: a } = e;
      Se(a, r.shape).forEach((u) => {
        i[u] = 1;
      });
      const o = Z(n, i), l = j(o, du(r.shape, "float32"));
      return {
        x: () => l
      };
    }
  };
  const ZEt = {
    kernelName: Um,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => Jt(n, gn(WM(e)))
      };
    }
  };
  const JEt = {
    kernelName: Hm,
    outputsToSave: [
      true
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => j(re(Ue(1), gn(e)), n)
      };
    }
  };
  const QEt = {
    kernelName: Xm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, t, e) => {
      const [r] = t, { reps: i } = e;
      return {
        x: () => {
          let s = Fe(r);
          if (r.rank === 1) for (let o = 0; o < i[0]; ++o) s = bt(s, hn(n, [
            o * r.shape[0]
          ], [
            r.shape[0]
          ]));
          else if (r.rank === 2) for (let o = 0; o < i[0]; ++o) for (let l = 0; l < i[1]; ++l) s = bt(s, hn(n, [
            o * r.shape[0],
            l * r.shape[1]
          ], [
            r.shape[0],
            r.shape[1]
          ]));
          else if (r.rank === 3) for (let o = 0; o < i[0]; ++o) for (let l = 0; l < i[1]; ++l) for (let u = 0; u < i[2]; ++u) s = bt(s, hn(n, [
            o * r.shape[0],
            l * r.shape[1],
            u * r.shape[2]
          ], [
            r.shape[0],
            r.shape[1],
            r.shape[2]
          ]));
          else if (r.rank === 4) for (let o = 0; o < i[0]; ++o) for (let l = 0; l < i[1]; ++l) for (let u = 0; u < i[2]; ++u) for (let c = 0; c < i[3]; ++c) s = bt(s, hn(n, [
            o * r.shape[0],
            l * r.shape[1],
            u * r.shape[2],
            c * r.shape[3]
          ], [
            r.shape[0],
            r.shape[1],
            r.shape[2],
            r.shape[3]
          ]));
          else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);
          return s;
        }
      };
    }
  };
  const tMt = {
    kernelName: Pf,
    gradFunc: (n, t, e) => {
      const r = e, { perm: i } = r, a = hu(i);
      return {
        x: () => Oe(n, a)
      };
    }
  };
  const eMt = {
    kernelName: Q_,
    gradFunc: (n, t, e) => {
      const r = e, { axis: i } = r;
      return {
        value: () => jo(n, i)
      };
    }
  };
  const nMt = {
    kernelName: tw,
    inputsToSave: [
      "segmentIds"
    ],
    gradFunc: (n, t) => {
      const [e] = t;
      return {
        x: () => rMt(n, e)
      };
    }
  };
  function rMt(n, t) {
    const e = fu(t, Fe(t)), r = XM(n, e);
    let i = _h(t, Ue(0, "int32"));
    const a = r.rank - i.rank;
    for (let o = 0; o < a; ++o) i = li(i, o + 1);
    i = qo(i, du(r.shape, "bool"));
    const s = Fe(r);
    return qr(i, r, s);
  }
  const iMt = {
    kernelName: ew,
    gradFunc: (n) => ({
      x: () => Fe(n)
    })
  };
  const aMt = [
    l7,
    nDt,
    rDt,
    iDt,
    aDt,
    sDt,
    oDt,
    lDt,
    uDt,
    cDt,
    hDt,
    fDt,
    gDt,
    yDt,
    xDt,
    bDt,
    _Dt,
    wDt,
    SDt,
    CDt,
    TDt,
    IDt,
    kDt,
    ADt,
    MDt,
    RDt,
    NDt,
    LDt,
    PDt,
    $Dt,
    IEt,
    ODt,
    FDt,
    BDt,
    zDt,
    VDt,
    WDt,
    GDt,
    UDt,
    HDt,
    XDt,
    YDt,
    qDt,
    jDt,
    KDt,
    ZDt,
    JDt,
    QDt,
    tEt,
    rEt,
    oV,
    oV,
    iEt,
    oEt,
    cEt,
    hEt,
    fEt,
    dEt,
    pEt,
    gEt,
    vEt,
    mEt,
    yEt,
    xEt,
    bEt,
    lV,
    lV,
    _Et,
    wEt,
    TEt,
    AEt,
    kEt,
    DEt,
    EEt,
    MEt,
    REt,
    NEt,
    LEt,
    PEt,
    $Et,
    OEt,
    FEt,
    BEt,
    zEt,
    VEt,
    GEt,
    WEt,
    UEt,
    uV,
    uV,
    cV,
    cV,
    HEt,
    YEt,
    XEt,
    qEt,
    jEt,
    KEt,
    ZEt,
    JEt,
    QEt,
    tMt,
    eMt,
    nMt,
    iMt
  ];
  for (const n of aMt) LSt(n);
  ot().prototype.abs = function() {
    return this.throwIfDisposed(), Gr(this);
  };
  ot().prototype.acos = function() {
    return this.throwIfDisposed(), BCt(this);
  };
  ot().prototype.acosh = function() {
    return this.throwIfDisposed(), VCt(this);
  };
  ot().prototype.add = function(n) {
    return this.throwIfDisposed(), bt(this, n);
  };
  ot().prototype.all = function(n, t) {
    return this.throwIfDisposed(), Xq(this, n, t);
  };
  ot().prototype.any = function(n, t) {
    return this.throwIfDisposed(), A2(this, n, t);
  };
  ot().prototype.argMax = function(n) {
    return this.throwIfDisposed(), uv(this, n);
  };
  ot().prototype.argMin = function(n) {
    return this.throwIfDisposed(), XCt(this, n);
  };
  ot().prototype.asScalar = function() {
    return this.throwIfDisposed(), B(this.size === 1, () => "The array must have only 1 element."), Z(this, []);
  };
  ot().prototype.asType = function(n) {
    return this.throwIfDisposed(), Et(this, n);
  };
  ot().prototype.as1D = function() {
    return this.throwIfDisposed(), Z(this, [
      this.size
    ]);
  };
  ot().prototype.as2D = function(n, t) {
    return this.throwIfDisposed(), Z(this, [
      n,
      t
    ]);
  };
  ot().prototype.as3D = function(n, t, e) {
    return this.throwIfDisposed(), Z(this, [
      n,
      t,
      e
    ]);
  };
  ot().prototype.as4D = function(n, t, e, r) {
    return this.throwIfDisposed(), Z(this, [
      n,
      t,
      e,
      r
    ]);
  };
  ot().prototype.as5D = function(n, t, e, r, i) {
    return this.throwIfDisposed(), Z(this, [
      n,
      t,
      e,
      r,
      i
    ]);
  };
  ot().prototype.asin = function() {
    return this.throwIfDisposed(), qCt(this);
  };
  ot().prototype.asinh = function() {
    return this.throwIfDisposed(), KCt(this);
  };
  ot().prototype.atan = function() {
    return this.throwIfDisposed(), JCt(this);
  };
  ot().prototype.atan2 = function(n) {
    return this.throwIfDisposed(), tTt(this, n);
  };
  ot().prototype.atanh = function() {
    return this.throwIfDisposed(), nTt(this);
  };
  ot().prototype.avgPool = function(n, t, e, r) {
    return this.throwIfDisposed(), zM(this, n, t, e, r);
  };
  ot().prototype.batchToSpaceND = function(n, t) {
    return this.throwIfDisposed(), VM(this, n, t);
  };
  ot().prototype.batchNorm = function(n, t, e, r, i) {
    return this.throwIfDisposed(), ow(this, n, t, e, r, i);
  };
  ot().prototype.broadcastTo = function(n) {
    return this.throwIfDisposed(), wg(this, n);
  };
  ot().prototype.cast = function(n) {
    return this.throwIfDisposed(), Et(this, n);
  };
  ot().prototype.ceil = function() {
    return this.throwIfDisposed(), DTt(this);
  };
  ot().prototype.clipByValue = function(n, t) {
    return this.throwIfDisposed(), Ji(this, n, t);
  };
  ot().prototype.concat = function(n, t) {
    return this.throwIfDisposed(), n instanceof Vn && (n = [
      n
    ]), pi([
      this,
      ...n
    ], t);
  };
  ot().prototype.conv1d = function(n, t, e, r, i, a) {
    return this.throwIfDisposed(), Yq(this, n, t, e, r, i, a);
  };
  ot().prototype.conv2dTranspose = function(n, t, e, r, i) {
    return this.throwIfDisposed(), qq(this, n, t, e, r, i);
  };
  ot().prototype.conv2d = function(n, t, e, r, i, a) {
    return this.throwIfDisposed(), nh(this, n, t, e, r, i, a);
  };
  ot().prototype.cos = function() {
    return this.throwIfDisposed(), WM(this);
  };
  ot().prototype.cosh = function() {
    return this.throwIfDisposed(), Kq(this);
  };
  ot().prototype.cumprod = function(n, t, e) {
    return this.throwIfDisposed(), D2(this, n, t, e);
  };
  ot().prototype.cumsum = function(n, t, e) {
    return this.throwIfDisposed(), Zq(this, n, t, e);
  };
  ot().prototype.depthToSpace = function(n, t) {
    return this.throwIfDisposed(), tIt(this, n, t);
  };
  ot().prototype.depthwiseConv2d = function(n, t, e, r, i, a) {
    return this.throwIfDisposed(), UM(this, n, t, e, r, i, a);
  };
  ot().prototype.dilation2d = function(n, t, e, r, i) {
    return this.throwIfDisposed(), rIt(this, n, t, e, r, i);
  };
  ot().prototype.divNoNan = function(n) {
    return this.throwIfDisposed(), lIt(this, n);
  };
  ot().prototype.div = function(n) {
    return this.throwIfDisposed(), Jt(this, n);
  };
  ot().prototype.dot = function(n) {
    return this.throwIfDisposed(), cIt(this, n);
  };
  ot().prototype.elu = function() {
    return this.throwIfDisposed(), uw(this);
  };
  ot().prototype.equal = function(n) {
    return this.throwIfDisposed(), io(this, n);
  };
  ot().prototype.erf = function() {
    return this.throwIfDisposed(), Jq(this);
  };
  ot().prototype.euclideanNorm = function(n, t) {
    return this.throwIfDisposed(), wIt(this, n, t);
  };
  ot().prototype.exp = function() {
    return this.throwIfDisposed(), ao(this);
  };
  ot().prototype.expandDims = function(n) {
    return this.throwIfDisposed(), li(this, n);
  };
  ot().prototype.expm1 = function() {
    return this.throwIfDisposed(), IIt(this);
  };
  ot().prototype.fft = function() {
    return this.throwIfDisposed(), vj(this);
  };
  ot().prototype.flatten = function() {
    return this.throwIfDisposed(), Z(this, [
      this.size
    ]);
  };
  ot().prototype.floor = function() {
    return this.throwIfDisposed(), hw(this);
  };
  ot().prototype.floorDiv = function(n) {
    return this.throwIfDisposed(), Hq(this, n);
  };
  ot().prototype.gather = function(n, t, e) {
    return this.throwIfDisposed(), XM(this, n, t, e);
  };
  ot().prototype.greaterEqual = function(n) {
    return this.throwIfDisposed(), _h(this, n);
  };
  ot().prototype.greater = function(n) {
    return this.throwIfDisposed(), ea(this, n);
  };
  ot().prototype.ifft = function() {
    return this.throwIfDisposed(), E2(this);
  };
  ot().prototype.irfft = function() {
    return this.throwIfDisposed(), x2t(this);
  };
  ot().prototype.isFinite = function() {
    return this.throwIfDisposed(), PIt(this);
  };
  ot().prototype.isInf = function() {
    return this.throwIfDisposed(), OIt(this);
  };
  ot().prototype.isNaN = function() {
    return this.throwIfDisposed(), BIt(this);
  };
  ot().prototype.leakyRelu = function(n) {
    return this.throwIfDisposed(), qM(this, n);
  };
  ot().prototype.lessEqual = function(n) {
    return this.throwIfDisposed(), Od(this, n);
  };
  ot().prototype.less = function(n) {
    return this.throwIfDisposed(), zb(this, n);
  };
  ot().prototype.localResponseNormalization = function(n, t, e, r) {
    return this.throwIfDisposed(), UIt(this, n, t, e, r);
  };
  ot().prototype.logSigmoid = function() {
    return this.throwIfDisposed(), ZIt(this);
  };
  ot().prototype.logSoftmax = function(n) {
    return this.throwIfDisposed(), rj(this, n);
  };
  ot().prototype.logSumExp = function(n, t) {
    return this.throwIfDisposed(), ij(this, n, t);
  };
  ot().prototype.log = function() {
    return this.throwIfDisposed(), so(this);
  };
  ot().prototype.log1p = function() {
    return this.throwIfDisposed(), nj(this);
  };
  ot().prototype.logicalAnd = function(n) {
    return this.throwIfDisposed(), qo(this, n);
  };
  ot().prototype.logicalNot = function() {
    return this.throwIfDisposed(), jM(this);
  };
  ot().prototype.logicalOr = function(n) {
    return this.throwIfDisposed(), aj(this, n);
  };
  ot().prototype.logicalXor = function(n) {
    return this.throwIfDisposed(), aAt(this, n);
  };
  ot().prototype.matMul = function(n, t, e) {
    return this.throwIfDisposed(), Ge(this, n, t, e);
  };
  ot().prototype.maxPool = function(n, t, e, r) {
    return this.throwIfDisposed(), KM(this, n, t, e, r);
  };
  ot().prototype.max = function(n, t) {
    return this.throwIfDisposed(), rs(this, n, t);
  };
  ot().prototype.maximum = function(n) {
    return this.throwIfDisposed(), fu(this, n);
  };
  ot().prototype.mean = function(n, t) {
    return this.throwIfDisposed(), $n(this, n, t);
  };
  ot().prototype.min = function(n, t) {
    return this.throwIfDisposed(), Bb(this, n, t);
  };
  ot().prototype.minimum = function(n) {
    return this.throwIfDisposed(), fv(this, n);
  };
  ot().prototype.mirrorPad = function(n, t) {
    return this.throwIfDisposed(), dAt(this, n, t);
  };
  ot().prototype.mod = function(n) {
    return this.throwIfDisposed(), gAt(this, n);
  };
  ot().prototype.mul = function(n) {
    return this.throwIfDisposed(), j(this, n);
  };
  ot().prototype.neg = function() {
    return this.throwIfDisposed(), En(this);
  };
  ot().prototype.norm = function(n, t, e) {
    return this.throwIfDisposed(), cw(this, n, t, e);
  };
  ot().prototype.notEqual = function(n) {
    return this.throwIfDisposed(), Vb(this, n);
  };
  ot().prototype.oneHot = function(n, t = 1, e = 0) {
    return this.throwIfDisposed(), sj(this, n, t, e);
  };
  ot().prototype.onesLike = function() {
    return this.throwIfDisposed(), ka(this);
  };
  ot().prototype.pad = function(n, t) {
    return this.throwIfDisposed(), JM(this, n, t);
  };
  ot().prototype.pool = function(n, t, e, r, i, a) {
    return this.throwIfDisposed(), TAt(this, n, t, e, r, i, a);
  };
  ot().prototype.pow = function(n) {
    return this.throwIfDisposed(), rh(this, n);
  };
  ot().prototype.prelu = function(n) {
    return this.throwIfDisposed(), tR(this, n);
  };
  ot().prototype.prod = function(n, t) {
    return this.throwIfDisposed(), kAt(this, n, t);
  };
  ot().prototype.reciprocal = function() {
    return this.throwIfDisposed(), QAt(this);
  };
  ot().prototype.relu = function() {
    return this.throwIfDisposed(), wh(this);
  };
  ot().prototype.relu6 = function() {
    return this.throwIfDisposed(), lj(this);
  };
  ot().prototype.reshapeAs = function(n) {
    return this.throwIfDisposed(), Z(this, n.shape);
  };
  ot().prototype.reshape = function(n) {
    return this.throwIfDisposed(), Z(this, n);
  };
  ot().prototype.resizeBilinear = function(n, t, e) {
    return this.throwIfDisposed(), _j(this, n, t, e);
  };
  ot().prototype.resizeNearestNeighbor = function(n, t, e) {
    return this.throwIfDisposed(), wj(this, n, t, e);
  };
  ot().prototype.reverse = function(n) {
    return this.throwIfDisposed(), ih(this, n);
  };
  ot().prototype.rfft = function() {
    return this.throwIfDisposed(), w2t(this);
  };
  ot().prototype.round = function() {
    return this.throwIfDisposed(), uj(this);
  };
  ot().prototype.rsqrt = function() {
    return this.throwIfDisposed(), cj(this);
  };
  ot().prototype.selu = function() {
    return this.throwIfDisposed(), hj(this);
  };
  ot().prototype.separableConv2d = function(n, t, e, r, i, a) {
    return this.throwIfDisposed(), fj(this, n, t, e, r, i, a);
  };
  ot().prototype.sigmoid = function() {
    return this.throwIfDisposed(), $d(this);
  };
  ot().prototype.sign = function() {
    return this.throwIfDisposed(), l2t(this);
  };
  ot().prototype.sin = function() {
    return this.throwIfDisposed(), dj(this);
  };
  ot().prototype.sinh = function() {
    return this.throwIfDisposed(), pj(this);
  };
  ot().prototype.slice = function(n, t) {
    return this.throwIfDisposed(), hn(this, n, t);
  };
  ot().prototype.softmax = function(n) {
    return this.throwIfDisposed(), iR(this, n);
  };
  ot().prototype.softplus = function() {
    return this.throwIfDisposed(), jm(this);
  };
  ot().prototype.spaceToBatchND = function(n, t) {
    return this.throwIfDisposed(), QM(this, n, t);
  };
  ot().prototype.split = function(n, t) {
    return this.throwIfDisposed(), ji(this, n, t);
  };
  ot().prototype.sqrt = function() {
    return this.throwIfDisposed(), Mr(this);
  };
  ot().prototype.square = function() {
    return this.throwIfDisposed(), gn(this);
  };
  ot().prototype.squaredDifference = function(n) {
    return this.throwIfDisposed(), C2t(this, n);
  };
  ot().prototype.squeeze = function(n) {
    return this.throwIfDisposed(), Zm(this, n);
  };
  ot().prototype.stack = function(n, t) {
    this.throwIfDisposed();
    const e = n instanceof Vn ? [
      this,
      n
    ] : [
      this,
      ...n
    ];
    return jo(e, t);
  };
  ot().prototype.step = function(n) {
    return this.throwIfDisposed(), Jm(this, n);
  };
  ot().prototype.stridedSlice = function(n, t, e, r, i, a, s, o) {
    return this.throwIfDisposed(), D2t(this, n, t, e, r, i, a, s, o);
  };
  ot().prototype.sub = function(n) {
    return this.throwIfDisposed(), re(this, n);
  };
  ot().prototype.sum = function(n, t) {
    return this.throwIfDisposed(), Kt(this, n, t);
  };
  ot().prototype.tan = function() {
    return this.throwIfDisposed(), M2t(this);
  };
  ot().prototype.tanh = function() {
    return this.throwIfDisposed(), sw(this);
  };
  ot().prototype.tile = function(n) {
    return this.throwIfDisposed(), Za(this, n);
  };
  ot().prototype.toBool = function() {
    return this.throwIfDisposed(), Et(this, "bool");
  };
  ot().prototype.toFloat = function() {
    return this.throwIfDisposed(), Et(this, "float32");
  };
  ot().prototype.toInt = function() {
    return this.throwIfDisposed(), Et(this, "int32");
  };
  ot().prototype.topk = function(n, t) {
    return this.throwIfDisposed(), L2t(this, n, t);
  };
  ot().prototype.transpose = function(n) {
    return this.throwIfDisposed(), Oe(this, n);
  };
  ot().prototype.unique = function(n) {
    return this.throwIfDisposed(), O2t(this, n);
  };
  ot().prototype.unsortedSegmentSum = function(n, t) {
    return this.throwIfDisposed(), xj(this, n, t);
  };
  ot().prototype.unstack = function(n) {
    return this.throwIfDisposed(), ah(this, n);
  };
  ot().prototype.where = function(n, t) {
    return this.throwIfDisposed(), qr(n, this, t);
  };
  ot().prototype.zerosLike = function() {
    return this.throwIfDisposed(), Fe(this);
  };
  class Ns extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, Ns.prototype);
    }
  }
  class wa extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, wa.prototype);
    }
  }
  class Y extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, Y.prototype);
    }
  }
  class me extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, me.prototype);
    }
  }
  class zR extends Error {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, zR.prototype);
    }
  }
  class c7 {
    constructor(t) {
      this.maxEntries = t || 100, this.cache = /* @__PURE__ */ new Map();
    }
    get(t) {
      let e;
      return this.cache.has(t) && (e = this.cache.get(t), this.cache.delete(t), this.cache.set(t, e)), e;
    }
    put(t, e) {
      if (this.cache.has(t)) this.cache.delete(t);
      else if (this.cache.size >= this.maxEntries) {
        const r = this.cache.keys().next().value;
        this.cache.delete(r);
      }
      this.cache.set(t, e);
    }
    getMaxEntries() {
      return this.maxEntries;
    }
    setMaxEntries(t) {
      if (t < 0) throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);
      if (this.maxEntries > t) for (let e = 0; e < this.maxEntries - t; e++) {
        const r = this.cache.keys().next().value;
        this.cache.delete(r);
      }
      this.maxEntries = t;
    }
  }
  function sh(n, t) {
    if (Array.isArray(n)) {
      let e = [];
      for (let r = 0; r < t; r++) e = e.concat(n);
      return e;
    } else {
      const e = new Array(t);
      return e.fill(n), e;
    }
  }
  function Ls(n, t) {
    if (!n) throw new zR(t);
  }
  function hV(n, t) {
    let e = 0;
    for (const r of n) r === t && e++;
    return e;
  }
  function ui(n) {
    return n.length === 1 ? n[0] : n;
  }
  function Ze(n) {
    return Array.isArray(n) ? n : [
      n
    ];
  }
  function So(n) {
    const e = n.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    return e[0] !== "_" ? e : "private" + e;
  }
  function pc(n) {
    return n.length <= 1 || n.indexOf("_") === -1 ? n : n.replace(/[_]+(\w|$)/g, (t, e) => e.toUpperCase());
  }
  let oa = {};
  function VR(n) {
    if (n == null) return null;
    const t = {};
    return t.className = n.getClassName(), t.config = n.getConfig(), t;
  }
  function N2(n) {
    if (!(n == null || typeof n != "object")) if (Array.isArray(n)) n.forEach((t) => N2(t));
    else {
      const t = Object.keys(n);
      for (const e of t) {
        const r = n[e];
        r != null && typeof r == "object" && (!Array.isArray(r) && r.type === "ndarray" && typeof r.value == "number" ? n[e] = r.value : N2(r));
      }
    }
  }
  function ny(n, t = {}, e = {}, r = "object", i = false) {
    if (typeof n == "string") {
      const a = n;
      let s;
      if (a in e) s = e[a];
      else if (a in oa) s = oa[a];
      else if (s = t[a], s == null) throw new Y(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      return s;
    } else {
      const a = n;
      if (a.className == null || a.config == null) throw new Y(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);
      const s = a.className;
      let o, l;
      if (s in e ? [o, l] = e[s] : s in oa ? [o, l] = oa.className : s in t && ([o, l] = t[s]), o == null) throw new Y(`Unknown ${r}: ${s}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      if (l != null) {
        const u = {};
        for (const d of Object.keys(oa)) u[d] = oa[d];
        for (const d of Object.keys(e)) u[d] = e[d];
        const c = a.config;
        c.customObjects = u;
        const h = Object.assign({}, oa);
        for (const d of Object.keys(e)) oa[d] = e[d];
        N2(a.config);
        const f = l(o, a.config, e, i);
        return oa = Object.assign({}, h), f;
      } else {
        const u = Object.assign({}, oa);
        for (const h of Object.keys(e)) oa[h] = e[h];
        const c = new o(a.config);
        return oa = Object.assign({}, u), c;
      }
    }
  }
  function sMt(n, t) {
    return n < t ? -1 : n > t ? 1 : 0;
  }
  function S0(n, t) {
    return -1 * sMt(n, t);
  }
  function Wl(n) {
    if (n == null) return n;
    const t = [];
    for (const e of n) t.indexOf(e) === -1 && t.push(e);
    return t;
  }
  function oMt(n) {
    if (n == null) throw new Y(`Invalid value in obj: ${JSON.stringify(n)}`);
    for (const t in n) if (n.hasOwnProperty(t)) return false;
    return true;
  }
  function Ch(n, t, e) {
    if (e != null && n.indexOf(e) < 0) throw new Y(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`);
  }
  function GR(n, t, e = 0, r = 1 / 0) {
    return Ls(e >= 0), Ls(r >= e), Array.isArray(n) && n.length >= e && n.length <= r && n.every((i) => typeof i === t);
  }
  function sr(n, t) {
    Array.isArray(n) ? (B(n.length > 0, () => `${t} is unexpectedly an empty array.`), n.forEach((e, r) => sr(e, `element ${r + 1} of ${t}`))) : B(Number.isInteger(n) && n > 0, () => `Expected ${t} to be a positive integer, but got ${h7(n)}.`);
  }
  function h7(n) {
    return n === null ? "null" : Array.isArray(n) ? "[" + n.map((t) => h7(t)).join(",") + "]" : typeof n == "string" ? `"${n}"` : `${n}`;
  }
  function lMt(n, t, e) {
    let r = e != null ? e() : si(), i;
    return (...s) => {
      const o = e != null ? e() : si();
      return o - r < t || (r = o, i = n(...s)), i;
    };
  }
  function f7(n) {
    return n === "relu" ? "relu" : n === "linear" ? "linear" : n === "elu" ? "elu" : null;
  }
  let uMt = 0;
  function d7() {
    return uMt++;
  }
  const C0 = {};
  function vw(n = "") {
    return n in C0 || (C0[n] = 0), C0[n] += 1, n + C0[n].toString();
  }
  const cMt = [
    "channelsFirst",
    "channelsLast"
  ], hMt = [
    "nearest",
    "bilinear"
  ], fMt = [
    "valid",
    "same",
    "causal"
  ], dMt = [
    "max",
    "avg"
  ], pMt = [
    "sum",
    "mul",
    "concat",
    "ave"
  ];
  const nf = /* @__PURE__ */ new Map();
  function Nn(n) {
    Ch(cMt, "DataFormat", n);
  }
  function gMt(n) {
    Ch(hMt, "InterpolationFormat", n);
  }
  function na(n) {
    Ch(fMt, "PaddingMode", n);
  }
  function p7(n) {
    Ch(dMt, "PoolMode", n);
  }
  const Sg = [], fV = "/";
  function zc(n, t) {
    Sg.push(n);
    try {
      const e = t();
      return Sg.pop(), e;
    } catch (e) {
      throw Sg.pop(), e;
    }
  }
  function vMt() {
    return Sg.length === 0 ? "" : Sg.join(fV) + fV;
  }
  function g7(n) {
    if (!m7(n)) throw new Error("Not a valid tensor name: '" + n + "'");
    return vMt() + n;
  }
  function v7(n) {
    if (!m7(n)) throw new Error("Not a valid tensor name: '" + n + "'");
    nf.has(n) || nf.set(n, 0);
    const t = nf.get(n);
    if (nf.set(n, nf.get(n) + 1), t > 0) {
      const e = `${n}_${t}`;
      return nf.set(e, 1), e;
    } else return n;
  }
  const mMt = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
  function m7(n) {
    return !!n.match(mMt);
  }
  function yMt(n) {
    return n === parseInt(n.toString(), 10);
  }
  function Ul(n, t, e) {
    t == null && (t = 0), e == null && (e = n.length);
    let r = 1;
    for (let i = t; i < e; ++i) r *= n[i];
    return r;
  }
  function rd(n) {
    if (n.length === 0) return Number.NaN;
    let t = Number.POSITIVE_INFINITY;
    for (let e = 0; e < n.length; e++) {
      const r = n[e];
      r < t && (t = r);
    }
    return t;
  }
  function eu(n) {
    if (n.length === 0) return Number.NaN;
    let t = Number.NEGATIVE_INFINITY;
    for (let e = 0; e < n.length; e++) {
      const r = n[e];
      r > t && (t = r);
    }
    return t;
  }
  function ls(n, t) {
    if (t < n) throw new Y(`end (${t}) < begin (${n}) is forbidden.`);
    const e = [];
    for (let r = n; r < t; ++r) e.push(r);
    return e;
  }
  let bT;
  function Hn() {
    return bT == null && (bT = uCt().epsilon()), bT;
  }
  function us() {
    return "channelsLast";
  }
  function Ks(n, t) {
    return Et(n, t);
  }
  function ry(n, t = -1) {
    const e = n.shape.slice();
    return t < 0 && (t = e.length + t + 1), e.splice(t, 0, 1), Z(n, e);
  }
  function xMt(n, t) {
    return tt(() => {
      if (n.shape.length !== 2) throw new Y(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);
      const e = ry(n, 1);
      return L2(e, [
        1,
        t,
        1
      ]);
    });
  }
  function bMt(n) {
    const t = [
      Ul(n.shape)
    ];
    return Z(n, t);
  }
  function _Mt(n) {
    if (n.rank <= 1) throw new Y(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);
    const t = [
      n.shape[0],
      Ul(n.shape, 1)
    ];
    return Z(n, t);
  }
  function Vc(n, t, e) {
    return tt(() => {
      switch (n.rank) {
        case 1:
          return nR(n, t, e);
        case 2:
          return gj(n, [
            t,
            0
          ], [
            e,
            n.shape[1]
          ]);
        case 3:
          return rR(n, [
            t,
            0,
            0
          ], [
            e,
            n.shape[1],
            n.shape[2]
          ]);
        case 4:
          return Wb(n, [
            t,
            0,
            0,
            0
          ], [
            e,
            n.shape[1],
            n.shape[2],
            n.shape[3]
          ]);
        case 5:
          return hn(n, [
            t,
            0,
            0,
            0,
            0
          ], [
            e,
            n.shape[1],
            n.shape[2],
            n.shape[3],
            n.shape[4]
          ]);
        case 6:
          return hn(n, [
            t,
            0,
            0,
            0,
            0,
            0
          ], [
            e,
            n.shape[1],
            n.shape[2],
            n.shape[3],
            n.shape[4],
            n.shape[5]
          ]);
        default:
          throw new Y(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`);
      }
    });
  }
  function _T(n, t, e) {
    return tt(() => {
      switch (n.rank) {
        case 1:
          return nR(n, t, e);
        case 2:
          return gj(n, [
            0,
            t
          ], [
            n.shape[0],
            e
          ]);
        case 3:
          return rR(n, [
            0,
            0,
            t
          ], [
            n.shape[0],
            n.shape[1],
            e
          ]);
        case 4:
          return Wb(n, [
            0,
            0,
            0,
            t
          ], [
            n.shape[0],
            n.shape[1],
            n.shape[2],
            e
          ]);
        default:
          throw new Y(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`);
      }
    });
  }
  function T0(n, t, e, r) {
    return tt(() => {
      switch (n.rank) {
        case 1:
          return nR(n, t, e);
        case 2:
          switch (r) {
            case 1:
              return Vc(n, t, e);
            case 2:
              return _T(n, t, e);
            default:
              throw new Y(`The axis is not within the rank of the tensor ${r}`);
          }
        case 3:
          switch (r) {
            case 1:
              return Vc(n, t, e);
            case 2:
              return rR(n, [
                0,
                t,
                0
              ], [
                n.shape[0],
                e,
                n.shape[2]
              ]);
            case 3:
              return _T(n, t, e);
            default:
              throw new Y(`The axis is not within the rank of the tensor ${r}`);
          }
        case 4:
          switch (r) {
            case 1:
              return Vc(n, t, e);
            case 2:
              return Wb(n, [
                0,
                t,
                0,
                0
              ], [
                n.shape[0],
                e,
                n.shape[2],
                n.shape[3]
              ]);
            case 3:
              return Wb(n, [
                0,
                0,
                t,
                0
              ], [
                n.shape[0],
                n.shape[1],
                e,
                n.shape[3]
              ]);
            case 4:
              return _T(n, t, e);
            default:
              throw new Y(`The axis is not within the rank of the tensor ${r}`);
          }
        default:
          throw new Y(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`);
      }
    });
  }
  function WR(n, t = -1) {
    let e;
    return t < 0 && (e = n[0].rank, e !== 0 ? t = e : t = 0), t === n[0].rank && (t = -1), pi(n, t);
  }
  function dV(n, t) {
    switch (n.rank) {
      case 1:
        return RTt([
          n,
          t
        ]);
      case 2:
        return LTt([
          n,
          t
        ], 0);
      case 3:
        return $Tt([
          n,
          t
        ], 0);
      case 4:
        return FTt([
          n,
          t
        ], 0);
      default:
        throw new Y(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`);
    }
  }
  function L2(n, t) {
    if (Array.isArray(t) || (t = [
      t
    ]), n.rank !== t.length) throw new Y(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);
    return Za(n, t);
  }
  function mw(n, t = 0, e = 1, r, i) {
    return jAt(n, t, e, r, i);
  }
  function Zs(n, t, e, r) {
    if (n.rank < 2 || t.rank < 2) throw new me(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);
    if (t.rank >= 3) {
      const i = n.shape.slice(-1)[0], a = t.shape.slice(-2)[0];
      if (i !== a) throw new me(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);
    }
    if (n.rank === 2 && t.rank === 2) return Qz({
      a: n,
      b: t,
      transposeA: false,
      transposeB: false,
      bias: r ? P2(n.rank, r, us()) : null,
      activation: e
    });
    {
      const i = n.shape.slice(), a = i.pop();
      n = Z(n, [
        -1,
        a
      ]);
      const s = t.shape.slice(), o = s.pop(), l = s.pop(), u = [
        ...s,
        o
      ], c = Array.from({
        length: t.rank
      }, (p, g) => g === 0 ? t.rank - 2 : g <= t.rank - 2 ? g - 1 : g);
      t = Z(Oe(t, c), [
        l,
        -1
      ]);
      const h = [
        ...i,
        ...u
      ];
      return Z(Qz({
        a: n,
        b: t,
        transposeA: false,
        transposeB: false,
        bias: r ? P2(n.rank, r, us()) : null,
        activation: e
      }), h);
    }
  }
  function y7(n, t, e) {
    return tt(() => (Array.isArray(t) ? t = Ni(t, "int32") : t = Et(t, "int32"), XM(n, t, e)));
  }
  function iy(n) {
    return j(n, n);
  }
  function P2(n, t, e) {
    const r = t.shape;
    if (t.rank !== 1 && t.rank !== n) throw new Y(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);
    if (n === 5) {
      if (e === "channelsFirst") return r.length === 1 ? Z(t, [
        1,
        r[0],
        1,
        1,
        1
      ]) : Z(t, [
        1,
        r[3],
        r[0],
        r[1],
        r[2]
      ]);
      if (e === "channelsLast") return r.length === 1 ? Z(t, [
        1,
        1,
        1,
        1,
        r[0]
      ]) : Z(t, [
        1
      ].concat(r));
    } else if (n === 4) {
      if (e === "channelsFirst") return r.length === 1 ? Z(t, [
        1,
        r[0],
        1,
        1
      ]) : Z(t, [
        1,
        r[2],
        r[0],
        r[1]
      ]);
      if (e === "channelsLast") return r.length === 1 ? Z(t, [
        1,
        1,
        1,
        r[0]
      ]) : Z(t, [
        1
      ].concat(r));
    } else if (n === 3) {
      if (e === "channelsFirst") return r.length === 1 ? Z(t, [
        1,
        r[0],
        1
      ]) : Z(t, [
        1,
        r[1],
        r[0]
      ]);
      if (e === "channelsLast") return r.length === 1 ? Z(t, [
        1,
        1,
        r[0]
      ]) : Z(t, [
        1
      ].concat(r));
    } else if (n < 3) return t;
    throw new Y(`Unsupported input rank by biasAdd: ${t.rank}`);
  }
  function ps(n, t, e) {
    return tt(() => (e == null && (e = us()), Nn(e), bt(n, P2(n.rank, t, e))));
  }
  function wMt(n, t = 1) {
    if (t !== 1) throw new me(`Support for alpha values other than 1 (${t}) is not implemented yet.`);
    return uw(n);
  }
  function SMt(n) {
    return tt(() => Jt(n, bt(Gr(n), 1)));
  }
  function x7(n, t, e, r) {
    return tt(() => U2t(n, t, e, r));
  }
  function CMt(n) {
    return tt(() => {
      const t = bt(0.5, j(0.2, n));
      return Ji(t, 0, 1);
    });
  }
  function ay(n, t, e = false) {
    return e ? n() : t();
  }
  const TMt = [
    "fanIn",
    "fanOut",
    "fanAvg"
  ], IMt = [
    "normal",
    "uniform",
    "truncatedNormal"
  ];
  function AMt(n) {
    Ch(TMt, "FanMode", n);
  }
  function kMt(n) {
    Ch(IMt, "Distribution", n);
  }
  class Na extends Bd {
    fromConfigUsesCustomObjects() {
      return false;
    }
    getConfig() {
      return {};
    }
  }
  class b7 extends Na {
    apply(t, e) {
      return rr(t, e);
    }
  }
  b7.className = "Zeros";
  vt(b7);
  class UR extends Na {
    apply(t, e) {
      return du(t, e);
    }
  }
  UR.className = "Ones";
  vt(UR);
  class _7 extends Na {
    constructor(t) {
      if (super(), typeof t != "object") throw new Y(`Expected argument of type ConstantConfig but got ${t}`);
      if (t.value === void 0) throw new Y(`config must have value set but got ${t}`);
      this.value = t.value;
    }
    apply(t, e) {
      return tt(() => j(Ue(this.value), du(t, e)));
    }
    getConfig() {
      return {
        value: this.value
      };
    }
  }
  _7.className = "Constant";
  vt(_7);
  class w7 extends Na {
    constructor(t) {
      super(), this.DEFAULT_MINVAL = -0.05, this.DEFAULT_MAXVAL = 0.05, this.minval = t.minval || this.DEFAULT_MINVAL, this.maxval = t.maxval || this.DEFAULT_MAXVAL, this.seed = t.seed;
    }
    apply(t, e) {
      return Km(t, this.minval, this.maxval, e, this.seed);
    }
    getConfig() {
      return {
        minval: this.minval,
        maxval: this.maxval,
        seed: this.seed
      };
    }
  }
  w7.className = "RandomUniform";
  vt(w7);
  class S7 extends Na {
    constructor(t) {
      super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = t.mean || this.DEFAULT_MEAN, this.stddev = t.stddev || this.DEFAULT_STDDEV, this.seed = t.seed;
    }
    apply(t, e) {
      if (e = e || "float32", e !== "float32" && e !== "int32") throw new me(`randomNormal does not support dType ${e}.`);
      return mw(t, this.mean, this.stddev, e, this.seed);
    }
    getConfig() {
      return {
        mean: this.mean,
        stddev: this.stddev,
        seed: this.seed
      };
    }
  }
  S7.className = "RandomNormal";
  vt(S7);
  class C7 extends Na {
    constructor(t) {
      super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = t.mean || this.DEFAULT_MEAN, this.stddev = t.stddev || this.DEFAULT_STDDEV, this.seed = t.seed;
    }
    apply(t, e) {
      if (e = e || "float32", e !== "float32" && e !== "int32") throw new me(`truncatedNormal does not support dType ${e}.`);
      return yj(t, this.mean, this.stddev, e, this.seed);
    }
    getConfig() {
      return {
        mean: this.mean,
        stddev: this.stddev,
        seed: this.seed
      };
    }
  }
  C7.className = "TruncatedNormal";
  vt(C7);
  class T7 extends Na {
    constructor(t) {
      super(), this.gain = t.gain != null ? t.gain : 1;
    }
    apply(t, e) {
      return tt(() => {
        if (t.length !== 2 || t[0] !== t[1]) throw new Y("Identity matrix initializer can only be used for 2D square matrices.");
        return j(this.gain, ej(t[0]));
      });
    }
    getConfig() {
      return {
        gain: this.gain
      };
    }
  }
  T7.className = "Identity";
  vt(T7);
  function DMt(n, t = "channelsLast") {
    let e, r;
    if (Nn(t), n.length === 2) e = n[0], r = n[1];
    else if ([
      3,
      4,
      5
    ].indexOf(n.length) !== -1) {
      if (t === "channelsFirst") {
        const i = Ul(n, 2);
        e = n[1] * i, r = n[0] * i;
      } else if (t === "channelsLast") {
        const i = Ul(n, 0, n.length - 2);
        e = n[n.length - 2] * i, r = n[n.length - 1] * i;
      }
    } else {
      const i = Ul(n);
      e = Math.sqrt(i), r = Math.sqrt(i);
    }
    return [
      e,
      r
    ];
  }
  class Oi extends Na {
    constructor(t) {
      if (super(), t.scale < 0) throw new Y(`scale must be a positive float. Got: ${t.scale}`);
      this.scale = t.scale == null ? 1 : t.scale, this.mode = t.mode == null ? "fanIn" : t.mode, AMt(this.mode), this.distribution = t.distribution == null ? "normal" : t.distribution, kMt(this.distribution), this.seed = t.seed;
    }
    apply(t, e) {
      const r = DMt(t), i = r[0], a = r[1];
      let s = this.scale;
      if (this.mode === "fanIn" ? s /= Math.max(1, i) : this.mode === "fanOut" ? s /= Math.max(1, a) : s /= Math.max(1, (i + a) / 2), this.distribution === "normal") {
        const o = Math.sqrt(s);
        if (e = e || "float32", e !== "float32" && e !== "int32") throw new me(`${this.getClassName()} does not support dType ${e}.`);
        return yj(t, 0, o, e, this.seed);
      } else {
        const o = Math.sqrt(3 * s);
        return Km(t, -o, o, e, this.seed);
      }
    }
    getConfig() {
      return {
        scale: this.scale,
        mode: this.mode,
        distribution: this.distribution,
        seed: this.seed
      };
    }
  }
  Oi.className = "VarianceScaling";
  vt(Oi);
  class HR extends Oi {
    constructor(t) {
      super({
        scale: 1,
        mode: "fanAvg",
        distribution: "uniform",
        seed: t == null ? null : t.seed
      });
    }
    getClassName() {
      return Oi.className;
    }
  }
  HR.className = "GlorotUniform";
  vt(HR);
  class XR extends Oi {
    constructor(t) {
      super({
        scale: 1,
        mode: "fanAvg",
        distribution: "normal",
        seed: t == null ? null : t.seed
      });
    }
    getClassName() {
      return Oi.className;
    }
  }
  XR.className = "GlorotNormal";
  vt(XR);
  class YR extends Oi {
    constructor(t) {
      super({
        scale: 2,
        mode: "fanIn",
        distribution: "normal",
        seed: t == null ? null : t.seed
      });
    }
    getClassName() {
      return Oi.className;
    }
  }
  YR.className = "HeNormal";
  vt(YR);
  class qR extends Oi {
    constructor(t) {
      super({
        scale: 2,
        mode: "fanIn",
        distribution: "uniform",
        seed: t == null ? null : t.seed
      });
    }
    getClassName() {
      return Oi.className;
    }
  }
  qR.className = "HeUniform";
  vt(qR);
  class jR extends Oi {
    constructor(t) {
      super({
        scale: 1,
        mode: "fanIn",
        distribution: "normal",
        seed: t == null ? null : t.seed
      });
    }
    getClassName() {
      return Oi.className;
    }
  }
  jR.className = "LeCunNormal";
  vt(jR);
  class KR extends Oi {
    constructor(t) {
      super({
        scale: 1,
        mode: "fanIn",
        distribution: "uniform",
        seed: t == null ? null : t.seed
      });
    }
    getClassName() {
      return Oi.className;
    }
  }
  KR.className = "LeCunUniform";
  vt(KR);
  class I7 extends Na {
    constructor(t) {
      super(), this.DEFAULT_GAIN = 1, this.ELEMENTS_WARN_SLOW = 2e3, this.gain = t.gain == null ? this.DEFAULT_GAIN : t.gain, this.seed = t.seed;
    }
    apply(t, e) {
      return tt(() => {
        if (t.length < 2) throw new me("Shape must be at least 2D.");
        if (e !== "int32" && e !== "float32" && e !== void 0) throw new TypeError(`Unsupported data type ${e}.`);
        e = e;
        const r = lt(t.slice(0, -1)), i = t[t.length - 1], a = r * i;
        a > this.ELEMENTS_WARN_SLOW && console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);
        const s = [
          Math.max(i, r),
          Math.min(i, r)
        ], o = mw(s, 0, 1, e, this.seed), l = zkt.qr(o, false);
        let u = l[0];
        const h = l[1].flatten().stridedSlice([
          0
        ], [
          Math.min(i, r) * Math.min(i, r)
        ], [
          Math.min(i, r) + 1
        ]);
        return u = j(u, h.sign()), r < i && (u = u.transpose()), j(Ue(this.gain), u.reshape(t));
      });
    }
    getConfig() {
      return {
        gain: this.gain,
        seed: this.seed
      };
    }
  }
  I7.className = "Orthogonal";
  vt(I7);
  const pV = {
    constant: "Constant",
    glorotNormal: "GlorotNormal",
    glorotUniform: "GlorotUniform",
    heNormal: "HeNormal",
    heUniform: "HeUniform",
    identity: "Identity",
    leCunNormal: "LeCunNormal",
    leCunUniform: "LeCunUniform",
    ones: "Ones",
    orthogonal: "Orthogonal",
    randomNormal: "RandomNormal",
    randomUniform: "RandomUniform",
    truncatedNormal: "TruncatedNormal",
    varianceScaling: "VarianceScaling",
    zeros: "Zeros"
  };
  function gV(n, t = {}) {
    return ny(n, ba.getMap().classNameMap, t, "initializer");
  }
  function _n(n) {
    return VR(n);
  }
  function yn(n) {
    if (typeof n == "string") {
      const t = n in pV ? pV[n] : n;
      if (t === "GlorotNormal") return new XR();
      if (t === "GlorotUniform") return new HR();
      if (t === "HeNormal") return new YR();
      if (t === "HeUniform") return new qR();
      if (t === "LeCunNormal") return new jR();
      if (t === "LeCunUniform") return new KR();
      {
        const e = {};
        return e.className = t, e.config = {}, gV(e);
      }
    } else return n instanceof Na ? n : gV(n);
  }
  function $2(n) {
    return Array.isArray(n) && Array.isArray(n[0]);
  }
  function Ub(n) {
    return n.length === 0 ? [] : Array.isArray(n[0]) ? n : [
      n
    ];
  }
  function ae(n) {
    let t;
    if (Array.isArray(n)) {
      if (n.length !== 1) throw new Y(`Expected Tensor length to be 1; got ${n.length}`);
      t = n[0];
    } else t = n;
    return t;
  }
  function ze(n) {
    if (Array.isArray(n) && Array.isArray(n[0])) {
      if (n.length === 1) return n = n, n[0];
      throw new Y(`Expected exactly 1 Shape; got ${n.length}`);
    } else return n;
  }
  function Hb(n) {
    let t = 0;
    for (const e of n) e.shape.length === 0 ? t += 1 : t += e.shape.reduce((r, i) => r * i);
    return t;
  }
  const vV = "Variable";
  class EMt {
    constructor(t, e = "float32", r = vV, i = true, a = null) {
      this.dtype = e ?? "float32", this.shape = t.shape, this.id = d7(), r = r ?? vV, this.originalName = g7(r), this.name = v7(this.originalName), this.trainable_ = i, this.constraint = a, this.val = z2t(t, this.trainable_, this.name, this.dtype);
    }
    read() {
      return this.assertNotDisposed(), this.val;
    }
    write(t) {
      return this.assertNotDisposed(), MMt(this.val, t), this.val.id !== t.id && (this.val.assign(t), this.constraint != null && this.val.assign(this.constraint.apply(this.val))), this;
    }
    dispose() {
      this.assertNotDisposed(), this.val.dispose();
    }
    assertNotDisposed() {
      if (this.val.isDisposed) throw new Error(`LayersVariable ${this.name} is already disposed.`);
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(t) {
      this.trainable_ = t, this.val.trainable = t;
    }
  }
  function MMt(n, t) {
    if (n.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(n.shape) + " vs. " + JSON.stringify(t.shape));
  }
  function O2(n) {
    return n.map((t) => t.read());
  }
  function ZR(n) {
    n.forEach((t) => {
      t[0].write(t[1]);
    });
  }
  class Xn {
    constructor(t) {
      this.dtype = t.dtype, this.shape = t.shape, t.shape != null ? this.ndim = t.shape.length : this.ndim = t.ndim, this.maxNDim = t.maxNDim, this.minNDim = t.minNDim, this.axes = t.axes || {};
    }
  }
  class oo {
    constructor(t, e, r, i, a, s, o) {
      this.dtype = t, this.shape = e, this.sourceLayer = r, this.inputs = i, this.callArgs = a, this.outputTensorIndex = o, this.id = d7(), s != null && (this.originalName = g7(s), this.name = v7(this.originalName)), this.rank = e.length;
    }
  }
  let RMt = 0;
  class yw {
    constructor(t, e) {
      this.callArgs = e, this.id = RMt++, this.outboundLayer = t.outboundLayer, this.inboundLayers = t.inboundLayers, this.nodeIndices = t.nodeIndices, this.tensorIndices = t.tensorIndices, this.inputTensors = t.inputTensors, this.outputTensors = t.outputTensors, this.inputMasks = t.inputMasks, this.outputMasks = t.outputMasks, this.inputShapes = t.inputShapes, this.outputShapes = t.outputShapes;
      for (const r of t.inboundLayers) r == null ? void 0 : r.outboundNodes.push(this);
      t.outboundLayer.inboundNodes.push(this);
    }
    getConfig() {
      const t = [];
      for (const e of this.inboundLayers) e != null ? t.push(e.name) : t.push(null);
      return {
        outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
        inboundLayers: t,
        nodeIndices: this.nodeIndices,
        tensorIndices: this.tensorIndices
      };
    }
  }
  let NMt = 0;
  class Ce extends Bd {
    constructor(t = {}) {
      super(), this._callHook = null, this._addedWeightNames = [], this._stateful = false, this.id = NMt++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = false, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = false, this.inboundNodes = [], this.outboundNodes = [];
      let e = t.name;
      if (!e) {
        const r = this.getClassName();
        e = So(r) + "_" + vw(r);
      }
      if (this.name = e, this.trainable_ = t.trainable == null ? true : t.trainable, t.inputShape != null || t.batchInputShape != null) {
        let r;
        if (t.batchInputShape != null) r = t.batchInputShape;
        else if (t.inputShape != null) {
          let a = null;
          t.batchSize != null && (a = t.batchSize), r = [
            a
          ].concat(t.inputShape);
        }
        this.batchInputShape = r;
        let i = t.dtype;
        i == null && (i = t.inputDType), i == null && (i = "float32"), this.dtype = i;
      }
      t.weights != null ? this.initialWeights = t.weights : this.initialWeights = null, this._refCount = null, this.fastWeightInitDuringBuild = false;
    }
    static nodeKey(t, e) {
      return t.name + "_ib-" + e.toString();
    }
    getNodeAtIndex(t, e) {
      if (this.inboundNodes.length === 0) throw new wa(`The layer has never been called and thus has no defined ${e}.`);
      if (this.inboundNodes.length <= t) throw new Y(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
      return this.inboundNodes[t];
    }
    getInputAt(t) {
      return ui(this.getNodeAtIndex(t, "input").inputTensors);
    }
    getOutputAt(t) {
      return ui(this.getNodeAtIndex(t, "output").outputTensors);
    }
    get input() {
      if (this.inboundNodes.length > 1) throw new Ns(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
      if (this.inboundNodes.length === 0) throw new Ns(`Layer ${this.name} is not connected, no input to return.`);
      return ui(this.getNodeAtIndex(0, "input").inputTensors);
    }
    get output() {
      if (this.inboundNodes.length === 0) throw new Ns(`Layer ${this.name} has no inbound nodes.`);
      if (this.inboundNodes.length > 1) throw new Ns(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
      return ui(this.getNodeAtIndex(0, "output").outputTensors);
    }
    get losses() {
      return this._losses;
    }
    calculateLosses() {
      return this.losses.map((t) => t());
    }
    get updates() {
      return this._updates;
    }
    get built() {
      return this._built;
    }
    set built(t) {
      this._built = t;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(t) {
      this._trainableWeights.forEach((e) => e.trainable = t), this.trainable_ = t;
    }
    get trainableWeights() {
      return this.trainable_ ? this._trainableWeights.filter((t) => t.trainable) : [];
    }
    set trainableWeights(t) {
      this._trainableWeights = t;
    }
    get nonTrainableWeights() {
      return this.trainable ? this._trainableWeights.filter((t) => !t.trainable).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
    }
    set nonTrainableWeights(t) {
      this._nonTrainableWeights = t;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    get stateful() {
      return this._stateful;
    }
    resetStates() {
      if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
    }
    assertInputCompatibility(t) {
      const e = Ze(t);
      if (this.inputSpec == null || this.inputSpec.length === 0) return;
      const r = Ze(this.inputSpec);
      if (e.length !== r.length) throw new Y(`Layer ${this.name} expects ${r.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);
      for (let i = 0; i < e.length; i++) {
        const a = e[i], s = r[i];
        if (s == null) continue;
        const o = a.rank;
        if (s.ndim != null && o !== s.ndim) throw new Y(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${o}`);
        if (s.maxNDim != null && o > s.maxNDim) throw new Y(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${o}`);
        if (s.minNDim != null && o < s.minNDim) throw new Y(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${o}.`);
        if (s.dtype != null && a.dtype !== s.dtype) throw new Y(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${a.dtype}.`);
        if (s.axes) {
          const l = a.shape;
          for (const u in s.axes) {
            const c = Number(u), h = s.axes[u], f = c >= 0 ? l[c] : l[l.length + c];
            if (h != null && [
              h,
              null
            ].indexOf(f) === -1) throw new Y(`Input ${i} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`);
          }
        }
        if (s.shape != null) for (let l = 0; l < s.shape.length; ++l) {
          const u = s.shape[l], c = a.shape[l];
          if (u != null && c != null && u !== c) throw new Y(`Input ${i} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${a.shape}.`);
        }
      }
    }
    call(t, e) {
      return t;
    }
    invokeCallHook(t, e) {
      this._callHook != null && this._callHook(t, e);
    }
    setCallHook(t) {
      this._callHook = t;
    }
    clearCallHook() {
      this._callHook = null;
    }
    apply(t, e) {
      e = e || {}, this.assertNotDisposed();
      const r = Ze(t), i = $Mt(t), a = OMt(t);
      if (i === a) throw new Y("Arguments to apply() must be all SymbolicTensors or all Tensors");
      return zc(this.name, () => {
        if (!this.built) {
          this.assertInputCompatibility(t);
          const s = [];
          for (const o of Ze(t)) s.push(o.shape);
          this.build(ui(s)), this.built = true, this.initialWeights && this.setWeights(this.initialWeights), this._refCount === null && a && (this._refCount = 1);
        }
        if (this.assertInputCompatibility(t), a) {
          let s = this.call(t, e);
          this.supportsMasking && this.setMaskMetadata(t, s);
          const o = Ze(s), l = [];
          for (let u of o) r.indexOf(u) !== -1 && (u = u.clone()), l.push(u);
          if (s = ui(l), this.activityRegularizer != null) throw new me("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return s;
        } else {
          const s = LMt(t), o = this.computeOutputShape(s);
          let l;
          const u = PMt(t);
          if (this.warnOnIncompatibleInputShape(Array.isArray(t) ? s[0] : s), o != null && o.length > 0 && Array.isArray(o[0]) ? l = o.map((c, h) => new oo(u, c, this, Ze(t), e, this.name, h)) : l = new oo(u, o, this, Ze(t), e, this.name), this.addInboundNode(t, l, null, null, s, o, e), this._refCount++, this.activityRegularizer != null) throw new me("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return l;
        }
      });
    }
    warnOnIncompatibleInputShape(t) {
      if (this.batchInputShape != null) if (t.length !== this.batchInputShape.length) console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
      else {
        let e = false;
        this.batchInputShape.forEach((r, i) => {
          r != null && t[i] != null && t[i] !== r && (e = true);
        }), e && console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
      }
    }
    get outputShape() {
      if (this.inboundNodes == null || this.inboundNodes.length === 0) throw new Ns(`The layer ${this.name} has never been called and thus has no defined output shape.`);
      const t = [];
      for (const e of this.inboundNodes) {
        const r = JSON.stringify(e.outputShapes);
        t.indexOf(r) === -1 && t.push(r);
      }
      if (t.length === 1) {
        const e = this.inboundNodes[0].outputShapes;
        return Array.isArray(e) && Array.isArray(e[0]) && e.length === 1 ? e[0] : e;
      } else throw new Ns(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
    }
    countParams() {
      if (!this.built) throw new wa(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
      return Hb(this.weights);
    }
    build(t) {
      this.built = true;
    }
    getWeights(t = false) {
      return O2(t ? this.trainableWeights : this.weights);
    }
    setWeights(t) {
      tt(() => {
        const e = this.weights;
        if (e.length !== t.length) throw new Y(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);
        if (e.length === 0) return;
        const r = [], i = O2(e);
        for (let a = 0; a < i.length; ++a) {
          const s = i[a], o = e[a], l = t[a];
          if (!Xe(s.shape, l.shape)) throw new Y(`Layer weight shape ${s.shape} not compatible with provided weight shape ${l.shape}`);
          r.push([
            o,
            l
          ]);
        }
        ZR(r);
      });
    }
    addWeight(t, e, r, i, a, s, o, l) {
      if (this._addedWeightNames.indexOf(t) !== -1) throw new Y(`Duplicate weight name ${t} for layer ${this.name}`);
      this._addedWeightNames.push(t), r == null && (r = "float32"), this.fastWeightInitDuringBuild && (i = l != null ? l() : yn("zeros"));
      const u = i.apply(e, r), c = new EMt(u, r, t, s, o);
      return u.dispose(), a != null && this.addLoss(() => a.apply(c.read())), s == null && (s = true), s ? this._trainableWeights.push(c) : this._nonTrainableWeights.push(c), c;
    }
    setFastWeightInitDuringBuild(t) {
      this.fastWeightInitDuringBuild = t;
    }
    addLoss(t) {
      t == null || Array.isArray(t) && t.length === 0 || (t = Ze(t), this._losses !== void 0 && this._losses !== null && this.losses.push(...t));
    }
    computeOutputShape(t) {
      return t;
    }
    computeMask(t, e) {
      if (!this.supportsMasking) {
        if (e != null) if (Array.isArray(e)) e.forEach((r) => {
          if (r != null) throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
        });
        else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
        return null;
      }
      return e;
    }
    setMaskMetadata(t, e, r) {
      if (!this.supportsMasking) return;
      const i = this.computeMask(t, r), a = Ze(e), s = Ze(i);
      if (a.length !== s.length) throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);
      for (let o = 0; o < a.length; o++) a[o].kerasMask = s[o];
    }
    addInboundNode(t, e, r, i, a, s, o = null) {
      const l = Ze(t);
      e = Ze(e), r = Ze(r), i = Ze(i), a = Ub(a), s = Ub(s);
      const u = [], c = [], h = [];
      for (const f of l) u.push(f.sourceLayer), c.push(f.nodeIndex), h.push(f.tensorIndex);
      new yw({
        outboundLayer: this,
        inboundLayers: u,
        nodeIndices: c,
        tensorIndices: h,
        inputTensors: l,
        outputTensors: e,
        inputMasks: r,
        outputMasks: i,
        inputShapes: a,
        outputShapes: s
      }, o);
      for (let f = 0; f < e.length; f++) e[f].sourceLayer = this, e[f].nodeIndex = this.inboundNodes.length - 1, e[f].tensorIndex = f;
    }
    getConfig() {
      const t = {
        name: this.name,
        trainable: this.trainable
      };
      return this.batchInputShape != null && (t.batchInputShape = this.batchInputShape), this.dtype != null && (t.dtype = this.dtype), t;
    }
    disposeWeights() {
      return this.weights.forEach((t) => t.dispose()), this.weights.length;
    }
    assertNotDisposed() {
      if (this._refCount === 0) throw new Error(`Layer '${this.name}' is already disposed.`);
    }
    dispose() {
      if (!this.built) throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
      if (this._refCount === null) throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
      this.assertNotDisposed();
      let t = 0;
      return --this._refCount === 0 && (t = this.disposeWeights()), {
        refCountAfterDispose: this._refCount,
        numDisposedVariables: t
      };
    }
  }
  function LMt(n) {
    n = Ze(n);
    const t = [];
    for (const e of n) t.push(e.shape);
    return ui(t);
  }
  function PMt(n) {
    return "float32";
  }
  function A7(n, t, e) {
    if ((t == null || e != null && e > 0) && (t = n.sourceLayer, e = n.nodeIndex), t.inboundNodes.length === 0) return [
      n
    ];
    {
      const r = t.inboundNodes[e];
      if (r.inboundLayers.length === 0) return r.inputTensors;
      {
        const i = [];
        for (let a = 0; a < r.inboundLayers.length; a++) {
          const s = r.inputTensors[a], o = r.inboundLayers[a], l = r.nodeIndices[a], u = A7(s, o, l);
          for (const c of u) i.indexOf(c) === -1 && i.push(c);
        }
        return i;
      }
    }
  }
  function $Mt(n) {
    let t = true;
    for (const e of Ze(n)) if (!(e instanceof oo)) {
      t = false;
      break;
    }
    return t;
  }
  function OMt(n) {
    let t = true;
    for (const e of Ze(n)) if (e instanceof oo) {
      t = false;
      break;
    }
    return t;
  }
  class sy extends Ce {
    constructor(t) {
      if (super({
        dtype: t.dtype,
        name: t.name != null ? t.name : vw("input").toString()
      }), t.batchSize == null && (t.batchSize = null), t.sparse == null && (t.sparse = false), this.trainable = false, this.built = true, this.sparse = t.sparse, t.inputShape != null && t.batchInputShape != null) throw new Y("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
      let e = t.batchInputShape;
      if (e == null) {
        if (t.inputShape == null) throw new Y("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
        e = [
          t.batchSize
        ].concat(t.inputShape);
      } else if (t.batchSize != null) throw new Y("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
      const r = t.dtype || "float32";
      this.batchInputShape = e, this.dtype = r, this.inputSpec = [
        {
          shape: e
        }
      ];
      const i = new oo(this.dtype, this.batchInputShape, this, [], {}, this.name);
      i.nodeIndex = 0, i.tensorIndex = 0, new yw({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: [
          i
        ],
        outputTensors: [
          i
        ],
        inputMasks: [
          null
        ],
        outputMasks: [
          null
        ],
        inputShapes: [
          e
        ],
        outputShapes: [
          e
        ]
      });
    }
    apply(t, e) {
      throw new Y(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
    }
    dispose() {
      return {
        refCountAfterDispose: this._refCount,
        numDisposedVariables: 0
      };
    }
    getConfig() {
      return {
        batchInputShape: this.batchInputShape,
        dtype: this.dtype,
        sparse: this.sparse,
        name: this.name
      };
    }
  }
  sy.className = "InputLayer";
  vt(sy);
  function FMt(n) {
    if (n.batchShape == null && n.shape == null) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
    if (n.batchShape != null && n.shape != null) throw new Y("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
    let t = n.batchShape;
    n.shape != null && t == null && (t = [
      null
    ].concat(n.shape));
    let e = n.dtype;
    return e == null && (e = "float32"), new sy({
      batchInputShape: t,
      name: n.name,
      dtype: e,
      sparse: n.sparse
    }).inboundNodes[0].outputTensors[0];
  }
  function BMt(n, t) {
    if (n.dtype == null || n.dtype === t.dtype) return t;
    try {
      return Et(t, n.dtype);
    } catch {
      throw new Y(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`);
    }
  }
  class Nl {
    constructor(t) {
      if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t instanceof Nl) for (const e in t.id2Value) this.id2Value[e] = t.id2Value[e], e in t.id2Mask && (this.id2Mask[e] = t.id2Mask[e]);
      else {
        if (t == null) return;
        for (const e of t) this.add(e.key, e.value);
      }
    }
    add(t, e, r) {
      if (this.id2Value[t.id] == null) this.id2Value[t.id] = BMt(t, e), this.name2Id[t.name] = t.id, r != null && (this.id2Mask[t.id] = r);
      else throw new Y(`Duplicate key: name=${t.name}, id=${t.id}`);
      return this;
    }
    addFeed(t) {
      this.add(t.key, t.value);
    }
    hasKey(t) {
      return this.id2Value[t.id] != null;
    }
    names() {
      return Object.keys(this.name2Id);
    }
    getValue(t) {
      if (t instanceof oo) {
        if (this.id2Value[t.id] == null) throw new Y(`Nonexistent key: ${t.name}`);
        return this.id2Value[t.id];
      } else {
        const e = this.name2Id[t];
        if (e == null) throw new Y(`Feed dict has no SymbolicTensor name: ${t}`);
        return this.id2Value[e];
      }
    }
    getMask(t) {
      if (t instanceof oo) {
        if (this.id2Value[t.id] == null) throw new Y(`Nonexistent key: ${t.name}`);
        return this.id2Mask[t.id];
      } else {
        const e = this.name2Id[t];
        if (e == null) throw new Y(`Feed dict has no SymbolicTensor name: ${t}`);
        return this.id2Mask[e];
      }
    }
    disposeMasks() {
      this.id2Mask != null && Te(this.id2Mask);
    }
  }
  const Xb = new c7(), Yb = new c7();
  function zMt(n) {
    Xb == null ? void 0 : Xb.setMaxEntries(n), Yb == null ? void 0 : Yb.setMaxEntries(n);
  }
  function Jp(n, t, e, r) {
    const i = e == null ? false : e.training, a = Array.isArray(n), s = a ? n : [
      n
    ], o = s.map((p) => p.name), l = [], u = t.names();
    for (const p of o) u.indexOf(p) !== -1 ? l.push(t.getValue(p)) : l.push(null);
    const c = o.join(",") + "|" + t.names().sort().join(",");
    let h = Xb.get(c), f;
    if (h == null) {
      const p = VMt(s, t);
      h = p.sorted, f = p.recipientCounts, Xb.put(c, h), Yb.put(c, f);
    }
    f = {}, i || Object.assign(f, Yb.get(c));
    const d = new Nl(t);
    for (let p = 0; p < h.length; ++p) {
      const g = h[p], v = g.sourceLayer;
      if (v instanceof sy) continue;
      const m = [], y = [], x = [];
      let b = false;
      for (const T of g.inputs) {
        const A = d.getValue(T), C = d.getMask(T);
        m.push(A), y.push(C), C != null && (b = true), i || (f[T.name]--, f[T.name] === 0 && !t.hasKey(T) && o.indexOf(T.name) === -1 && !A.isDisposed && T.sourceLayer.stateful !== true && x.push(A));
      }
      b && (e = e || {}, e.mask = y[0]);
      const _ = Ze(v.apply(m, e));
      let w = null;
      v.supportsMasking && (w = v.computeMask(m, y));
      const S = WMt(g), I = Array.isArray(S) ? S : [
        S
      ];
      for (let T = 0; T < I.length; ++T) {
        d.hasKey(I[T]) || d.add(I[T], _[T], Array.isArray(w) ? w[0] : w);
        const A = o.indexOf(I[T].name);
        A !== -1 && (l[A] = _[T]);
      }
      i || Te(x);
    }
    return d.disposeMasks(), a ? l : l[0];
  }
  function VMt(n, t) {
    B(n != null && n.length > 0, () => "Expected at least one fetch, got none");
    let e = [], r = {};
    if (n.length === 1) {
      const i = mV(n[0], t);
      e = i.sorted, r = i.recipientMap;
    } else {
      const i = /* @__PURE__ */ new Set();
      for (const a of n) {
        const { sorted: s, recipientMap: o } = mV(a, t);
        for (const l of s) i.has(l.name) || (e.push(l), i.add(l.name));
        for (const l in o) r[l] == null && (r[l] = /* @__PURE__ */ new Set()), o[l].forEach((u) => r[l].add(u));
      }
    }
    return {
      sorted: e,
      recipientCounts: GMt(r)
    };
  }
  function GMt(n) {
    const t = {};
    for (const e in n) t[e] = n[e].size;
    return t;
  }
  function mV(n, t) {
    const e = /* @__PURE__ */ new Set(), r = [], i = {};
    for (const o of t.names()) e.add(o);
    const a = [], s = [];
    for (a.push(n); a.length > 0; ) {
      const o = a[a.length - 1];
      if (e.has(o.name)) {
        a.pop();
        continue;
      }
      const l = s[s.length - 1] === a.length - 1;
      if (o.inputs.length === 0 || l) a.pop(), r.push(o), e.add(o.name), l && s.pop();
      else {
        s.push(a.length - 1);
        for (const u of o.inputs) i[u.name] == null && (i[u.name] = /* @__PURE__ */ new Set()), i[u.name].add(o.name), !e.has(u.name) && a.push(u);
      }
    }
    return {
      sorted: r,
      recipientMap: i
    };
  }
  function WMt(n) {
    let t;
    if (n.sourceLayer.inboundNodes.length === 1) t = n.sourceLayer.output;
    else {
      let e = null;
      for (let r = 0; r < n.sourceLayer.inboundNodes.length; ++r) for (const i of n.sourceLayer.inboundNodes[r].outputTensors) if (i.id === n.id) {
        e = r;
        break;
      }
      t = n.sourceLayer.getOutputAt(e);
    }
    return t;
  }
  const UMt = nt();
  UMt.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", () => 100, zMt);
  function JR(n, t) {
    return tt(() => Mr(Kt(j(n, n), t, true)));
  }
  class oy extends Bd {
    getConfig() {
      return {};
    }
  }
  class k7 extends oy {
    constructor(t) {
      super(), this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = t.maxValue != null ? t.maxValue : this.defaultMaxValue, this.axis = t.axis != null ? t.axis : this.defaultAxis;
    }
    apply(t) {
      return tt(() => {
        const e = JR(t, this.axis), r = Ji(e, 0, this.maxValue);
        return j(t, Jt(r, bt(Hn(), e)));
      });
    }
    getConfig() {
      return {
        maxValue: this.maxValue,
        axis: this.axis
      };
    }
  }
  k7.className = "MaxNorm";
  vt(k7);
  class D7 extends oy {
    constructor(t) {
      super(), this.defaultAxis = 0, this.axis = t.axis != null ? t.axis : this.defaultAxis;
    }
    apply(t) {
      return tt(() => Jt(t, bt(Hn(), JR(t, this.axis))));
    }
    getConfig() {
      return {
        axis: this.axis
      };
    }
  }
  D7.className = "UnitNorm";
  vt(D7);
  class E7 extends oy {
    apply(t) {
      return wh(t);
    }
  }
  E7.className = "NonNeg";
  vt(E7);
  class M7 extends oy {
    constructor(t) {
      super(), this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = t.minValue != null ? t.minValue : this.defaultMinValue, this.maxValue = t.maxValue != null ? t.maxValue : this.defaultMaxValue, this.rate = t.rate != null ? t.rate : this.defaultRate, this.axis = t.axis != null ? t.axis : this.defaultAxis;
    }
    apply(t) {
      return tt(() => {
        const e = JR(t, this.axis), r = bt(j(this.rate, Ji(e, this.minValue, this.maxValue)), j(1 - this.rate, e));
        return j(t, Jt(r, bt(Hn(), e)));
      });
    }
    getConfig() {
      return {
        minValue: this.minValue,
        maxValue: this.maxValue,
        rate: this.rate,
        axis: this.axis
      };
    }
  }
  M7.className = "MinMaxNorm";
  vt(M7);
  const yV = {
    maxNorm: "MaxNorm",
    minMaxNorm: "MinMaxNorm",
    nonNeg: "NonNeg",
    unitNorm: "UnitNorm"
  };
  function jn(n) {
    return VR(n);
  }
  function xV(n, t = {}) {
    return ny(n, ba.getMap().classNameMap, t, "constraint");
  }
  function Kn(n) {
    if (n == null) return null;
    if (typeof n == "string") {
      const e = {
        className: n in yV ? yV[n] : n,
        config: {}
      };
      return xV(e);
    } else return n instanceof oy ? n : xV(n);
  }
  async function Xu(n) {
    if (n == null) return;
    const t = [], e = [], r = [];
    for (const i in n) {
      const a = n[i];
      if (typeof a != "number") {
        const s = a;
        t.push(s.data()), e.push(i), r.push(s);
      }
    }
    if (t.length > 0) {
      const i = await Promise.all(t);
      for (let a = 0; a < i.length; ++a) n[e[a]] = i[a][0];
      Te(r);
    }
  }
  function R7(n) {
    if (n != null) for (const t in n) {
      const e = n[t];
      typeof e != "number" && e.dispose();
    }
  }
  var bV;
  (function(n) {
    n[n.SILENT = 0] = "SILENT", n[n.VERBOSE = 1] = "VERBOSE";
  })(bV || (bV = {}));
  const HMt = 125;
  class pv {
    constructor() {
      this.validationData = null;
    }
    setParams(t) {
      this.params = t;
    }
    async onEpochBegin(t, e) {
    }
    async onEpochEnd(t, e) {
    }
    async onBatchBegin(t, e) {
    }
    async onBatchEnd(t, e) {
    }
    async onTrainBegin(t) {
    }
    async onTrainEnd(t) {
    }
    setModel(t) {
    }
  }
  class XMt {
    constructor(t, e = 10) {
      t == null && (t = []), this.callbacks = t, this.queueLength = e;
    }
    append(t) {
      this.callbacks.push(t);
    }
    setParams(t) {
      for (const e of this.callbacks) e.setParams(t);
    }
    setModel(t) {
      for (const e of this.callbacks) e.setModel(t);
    }
    async onEpochBegin(t, e) {
      e == null && (e = {});
      for (const r of this.callbacks) await r.onEpochBegin(t, e);
    }
    async onEpochEnd(t, e) {
      e == null && (e = {});
      for (const r of this.callbacks) await r.onEpochEnd(t, e);
    }
    async onBatchBegin(t, e) {
      e == null && (e = {});
      for (const r of this.callbacks) await r.onBatchBegin(t, e);
    }
    async onBatchEnd(t, e) {
      e == null && (e = {});
      for (const r of this.callbacks) await r.onBatchEnd(t, e);
    }
    async onTrainBegin(t) {
      t == null && (t = {});
      for (const e of this.callbacks) await e.onTrainBegin(t);
    }
    async onTrainEnd(t) {
      t == null && (t = {});
      for (const e of this.callbacks) await e.onTrainEnd(t);
    }
  }
  class YMt extends pv {
    constructor() {
      super();
    }
    async onEpochBegin(t) {
      this.seen = 0, this.totals = {};
    }
    async onBatchEnd(t, e) {
      e == null && (e = {});
      const r = e.size == null ? 0 : e.size;
      this.seen += r;
      for (const i in e) {
        const a = e[i];
        if (typeof a == "number") this.totals.hasOwnProperty(i) || (this.totals[i] = 0), this.totals[i] = this.totals[i] + a * r;
        else {
          let s;
          i in this.totals ? s = this.totals[i] : this.totals[i] = 0;
          const o = tt(() => bt(this.totals[i], j(a, r)));
          this.totals[i] = o, s == null ? void 0 : s.dispose();
        }
      }
    }
    async onEpochEnd(t, e) {
      if (e != null) for (const r of this.params.metrics) this.totals[r] != null && (typeof this.totals[r] == "number" ? e[r] = this.totals[r] / this.seen : tt(() => {
        const i = j(Jt(1, this.seen), this.totals[r]);
        e[r] = i, this.totals[r].dispose(), qs(e[r]);
      }));
    }
  }
  class qMt extends pv {
    async onTrainBegin(t) {
      this.epoch = [], this.history = {};
    }
    async onEpochEnd(t, e) {
      e == null && (e = {}), this.epoch.push(t);
      for (const r in e) this.history[r] == null && (this.history[r] = []), this.history[r].push(e[r]);
    }
    async syncData() {
      const t = [], e = [], r = [];
      for (const a in this.history) {
        const s = this.history[a];
        for (let o = 0; o < s.length; ++o) if (typeof s[o] != "number") {
          const l = s[o];
          t.push(l.data()), e.push(a), r.push(o);
        }
      }
      const i = await Promise.all(t);
      for (let a = 0; a < i.length; ++a) this.history[e[a]][r[a]].dispose(), this.history[e[a]][r[a]] = i[a][0];
    }
  }
  class jMt extends pv {
    constructor(t, e) {
      if (super(), this.currentEpoch = 0, this.nowFunc = t.nowFunc, this.nextFrameFunc = t.nextFrameFunc || Oj, this.yieldEvery = e || "auto", this.yieldEvery === "auto" && (this.yieldEvery = HMt), this.yieldEvery === "never" && t.onYield != null) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
      d2(this.yieldEvery) && (this.maybeWait = lMt(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc)), this.trainBegin = t.onTrainBegin, this.trainEnd = t.onTrainEnd, this.epochBegin = t.onEpochBegin, this.epochEnd = t.onEpochEnd, this.batchBegin = t.onBatchBegin, this.batchEnd = t.onBatchEnd, this.yield = t.onYield;
    }
    async maybeWait(t, e, r) {
      const i = [];
      this.yield != null && (await Xu(r), i.push(this.yield(t, e, r))), i.push(this.nextFrameFunc()), await Promise.all(i);
    }
    async onEpochBegin(t, e) {
      this.currentEpoch = t, this.epochBegin != null && (await Xu(e), await this.epochBegin(t, e));
    }
    async onEpochEnd(t, e) {
      const r = [];
      this.epochEnd != null && (await Xu(e), r.push(this.epochEnd(t, e))), this.yieldEvery === "epoch" && r.push(this.nextFrameFunc()), await Promise.all(r);
    }
    async onBatchBegin(t, e) {
      this.batchBegin != null && (await Xu(e), await this.batchBegin(t, e));
    }
    async onBatchEnd(t, e) {
      const r = [];
      this.batchEnd != null && (await Xu(e), r.push(this.batchEnd(t, e))), this.yieldEvery === "batch" ? r.push(this.nextFrameFunc()) : d2(this.yieldEvery) && r.push(this.maybeWait(this.currentEpoch, t, e)), await Promise.all(r);
    }
    async onTrainBegin(t) {
      this.trainBegin != null && (await Xu(t), await this.trainBegin(t));
    }
    async onTrainEnd(t) {
      this.trainEnd != null && (await Xu(t), await this.trainEnd(t));
    }
  }
  function N7(n, t) {
    return n == null && (n = {}), n instanceof pv ? [
      n
    ] : Array.isArray(n) && n[0] instanceof pv ? n : Ze(n).map((r) => new jMt(r, t));
  }
  class fa {
    constructor() {
    }
    static registerCallbackConstructor(t, e) {
      B(t >= 0 && Number.isInteger(t), () => `Verbosity level is expected to be an integer >= 0, but got ${t}`), fa.checkForDuplicate(e), fa.constructors[t] == null && (fa.constructors[t] = []), fa.constructors[t].push(e);
    }
    static checkForDuplicate(t) {
      for (const e in fa.constructors) fa.constructors[+e].forEach((i) => {
        if (i === t) throw new Y("Duplicate callback constructor.");
      });
    }
    static clear() {
      fa.constructors = {};
    }
    static createCallbacks(t) {
      const e = [];
      for (const r in fa.constructors) {
        const i = +r;
        t >= i && e.push(...fa.constructors[i]);
      }
      return e.map((r) => new r());
    }
  }
  fa.constructors = {};
  function L7(n, t, e, r, i, a, s, o, l) {
    const u = new qMt(), c = [
      new YMt(),
      ...fa.createCallbacks(t)
    ];
    n != null && c.push(...n), c.push(u);
    const h = new XMt(c);
    return h.setParams({
      epochs: e,
      initialEpoch: r,
      samples: i,
      steps: a,
      batchSize: s,
      verbose: t,
      doValidation: o,
      metrics: l
    }), {
      callbackList: h,
      history: u
    };
  }
  function $o(n, t = {}, e = false) {
    return ny(n, ba.getMap().classNameMap, t, "layer", e);
  }
  function qb(n, t) {
    return tt(() => {
      n.dtype !== "float32" && (n = Et(n, "float32"));
      const e = Kt(iy(n), t, true), r = lw(e.shape, Hn()), i = Mr(fu(e, r));
      return Jt(n, i);
    });
  }
  function xw(n, t) {
    return tt(() => $n(iy(re(t, n)), -1));
  }
  function QR(n, t) {
    return tt(() => $n(Gr(re(t, n)), -1));
  }
  function tN(n, t) {
    return tt(() => {
      const e = re(n, t), r = Ji(Gr(n), Hn(), Number.MAX_VALUE), i = Gr(Jt(e, r));
      return j(100, $n(i, -1));
    });
  }
  function KMt(n, t) {
    return tt(() => {
      const e = Ji(t, Hn(), Number.MAX_VALUE), r = so(bt(1, e)), i = Ji(n, Hn(), Number.MAX_VALUE), a = so(bt(1, i));
      return $n(iy(re(r, a)), -1);
    });
  }
  function ZMt(n, t) {
    return tt(() => {
      const e = fu(0, re(1, j(n, t)));
      return $n(iy(e), -1);
    });
  }
  function JMt(n, t) {
    return tt(() => {
      const e = fu(0, re(1, j(n, t)));
      return $n(e, -1);
    });
  }
  function QMt(n, t) {
    return tt(() => {
      const e = Kt(j(n, t), -1), r = rs(j(re(1, n), t), -1);
      return fu(0, bt(1, re(r, e)));
    });
  }
  function tRt(n, t) {
    return tt(() => {
      const e = Math.log(2), r = re(t, n), i = re(bt(r, jm(j(-2, r))), e);
      return $n(i, -1);
    });
  }
  function gv(n, t, e = false) {
    return tt(() => {
      if (e) t = iR(t);
      else {
        const r = Kt(t, t.shape.length - 1, true);
        t = Jt(t, r);
      }
      return t = Ji(t, Hn(), 1 - Hn()), En(Kt(j(Et(n, "float32"), so(t)), t.shape.length - 1));
    });
  }
  function jb(n, t, e = false) {
    return tt(() => {
      const r = Et(hw(bMt(n)), "int32");
      t = Ji(t, Hn(), 1 - Hn());
      const i = t.shape, a = Z(sj(r, i[i.length - 1]), i);
      return gv(a, t, e);
    });
  }
  function eRt(n, t) {
    if (!Xe(n.shape, t.shape)) throw new Y(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);
    return tt(() => {
      const e = wh(t), r = En(Gr(t));
      return bt(re(e, j(t, n)), nj(ao(r)));
    });
  }
  function bw(n, t) {
    return tt(() => {
      let e;
      return e = Ji(t, Hn(), 1 - Hn()), e = so(Jt(e, re(1, e))), $n(eRt(n, e), -1);
    });
  }
  function nRt(n, t) {
    return tt(() => {
      const e = Ji(n, Hn(), 1), r = Ji(t, Hn(), 1);
      return Kt(j(n, so(Jt(e, r))), -1);
    });
  }
  function rRt(n, t) {
    return tt(() => {
      const e = so(bt(Hn(), t));
      return $n(re(t, j(n, e)), -1);
    });
  }
  function P7(n, t) {
    return tt(() => {
      const e = qb(n, -1), r = qb(t, -1), i = j(e, r);
      return En(Kt(i, -1));
    });
  }
  const Kb = {
    meanSquaredError: xw,
    meanAbsoluteError: QR,
    meanAbsolutePercentageError: tN,
    meanSquaredLogarithmicError: KMt,
    squaredHinge: ZMt,
    hinge: JMt,
    categoricalHinge: QMt,
    logcosh: tRt,
    categoricalCrossentropy: gv,
    sparseCategoricalCrossentropy: jb,
    binaryCrossentropy: bw,
    kullbackLeiblerDivergence: nRt,
    poisson: rRt,
    cosineProximity: P7
  };
  function wT(n) {
    if (typeof n == "string") {
      if (n in Kb) return Kb[n];
      let t = `Unknown loss ${n}`;
      throw n.toLowerCase().includes("softmaxcrossentropy") && (t = `Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`), new Y(t);
    } else return n;
  }
  function $7(n, t) {
    return tt(() => {
      const e = j(0.5, ka(t)), r = Ks(ea(t, e), n.dtype);
      return $n(io(n, r), -1);
    });
  }
  function O7(n, t) {
    return tt(() => Ks(io(uv(n, -1), uv(t, -1)), "float32"));
  }
  function iRt(n, t) {
    return tt(() => Et(Kt(qo(io(n, 1), io(t, 1))), "float32"));
  }
  function aRt(n, t) {
    return tt(() => Et(Kt(qo(io(n, 0), io(t, 1))), "float32"));
  }
  function sRt(n, t) {
    return tt(() => {
      const e = iRt(n, t), r = aRt(n, t), i = bt(e, r);
      return Et(qr(ea(i, 0), Jt(e, i), 0), "float32");
    });
  }
  function oRt(n, t) {
    return bw(n, t);
  }
  function lRt(n, t) {
    return n.rank === t.rank && (n = Zm(n, [
      n.rank - 1
    ])), t = uv(t, -1), t.dtype !== n.dtype && (t = Et(t, n.dtype)), Et(io(n, t), "float32");
  }
  const uRt = xw, cRt = xw, hRt = QR, fRt = QR, dRt = tN, pRt = tN, F7 = gv, gRt = P7, B7 = jb, Zb = {
    binaryAccuracy: $7,
    categoricalAccuracy: O7,
    precision: sRt,
    categoricalCrossentropy: F7,
    sparseCategoricalCrossentropy: B7,
    mse: uRt,
    MSE: cRt,
    mae: hRt,
    MAE: fRt,
    mape: dRt,
    MAPE: pRt,
    cosine: gRt
  };
  function vRt(n) {
    if (typeof n == "string" && n in Zb) return Zb[n];
    if (typeof n != "string" && n != null) return n;
    throw new Y(`Unknown metric ${n}`);
  }
  function I0(n) {
    if (Ls(n !== null, `Unknown LossOrMetricFn ${n}`), typeof n == "string") return n;
    {
      let t;
      for (const e of Object.keys(Kb)) if (Kb[e] === n) {
        t = e;
        break;
      }
      if (t !== void 0) return t;
      for (const e of Object.keys(Zb)) if (Zb[e] === n) {
        t = e;
        break;
      }
      return t !== void 0 ? t : n.name;
    }
  }
  function mRt(n) {
    const t = {
      Adagrad: () => ef.adagrad(0.01),
      Adadelta: () => ef.adadelta(1, 0.95, Hn()),
      Adam: () => ef.adam(1e-3, 0.9, 0.999, Hn()),
      Adamax: () => ef.adamax(2e-3, 0.9, 0.999, Hn(), 0),
      RMSProp: () => ef.rmsprop(1e-3, 0.9, 0, Hn()),
      SGD: () => ef.sgd(0.01)
    };
    if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, n in t) return t[n]();
    throw new Y(`Unknown Optimizer ${n}`);
  }
  const _V = 1 * 1024 * 1024;
  function wV(n, t, e = false) {
    if (n == null || typeof n != "object" || Object.getPrototypeOf(n) !== Object.prototype || !F2(n)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
    if (e) {
      const r = JSON.stringify(n);
      r.length > _V && console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${_V}.`);
    }
  }
  function F2(n) {
    if (n === null) return true;
    if (typeof n == "object") if (Object.getPrototypeOf(n) === Object.prototype) {
      const t = Object.keys(n);
      for (const e of t) if (typeof e != "string" || !F2(n[e])) return false;
      return true;
    } else if (Array.isArray(n)) {
      for (const t of n) if (!F2(t)) return false;
      return true;
    } else return false;
    else {
      const t = typeof n;
      return t === "string" || t === "number" || t === "boolean";
    }
  }
  function yRt(n, t, e, r = console.log) {
    const i = bRt(n), a = [
      "Layer (type)",
      "Input Shape",
      "Output shape",
      "Param #"
    ];
    i ? (t = t || 90, e = e || [
      0.32,
      0.61,
      0.89,
      1
    ]) : (t = t || 115, e = e || [
      0.24,
      0.48,
      0.7,
      0.8,
      1
    ]), e[e.length - 1] <= 1 && (e = e.map((c) => Math.floor(t * c)));
    let s;
    if (!i) {
      a.push("Receives inputs"), s = [];
      for (const c in n.nodesByDepth) s.push(...n.nodesByDepth[c]);
    }
    r("_".repeat(t)), Jb(a, e, r), r("=".repeat(t));
    const o = n.layers;
    for (let c = 0; c < o.length; ++c) i ? _Rt(o[c], e, r) : wRt(o[c], e, s, r), r((c === o.length - 1 ? "=" : "_").repeat(t));
    n.checkTrainableWeightsConsistency();
    const l = xRt(n), u = Hb(n.nonTrainableWeights);
    r(`Total params: ${l + u}`), r(`Trainable params: ${l}`), r(`Non-trainable params: ${u}`), r("_".repeat(t));
  }
  function xRt(n) {
    let t;
    return n.collectedTrainableWeights != null ? t = Hb(n.collectedTrainableWeights) : t = Hb(n.trainableWeights), t;
  }
  function bRt(n) {
    let t = true;
    const e = [], r = [];
    for (const i in n.nodesByDepth) e.push(n.nodesByDepth[i]);
    for (const i of e) {
      if (i.length > 1 || i.length === 1 && i[0].inboundLayers.length > 1) {
        t = false;
        break;
      }
      r.push(...i);
    }
    if (t) for (const i of n.layers) {
      let a = false;
      for (const s of i.inboundNodes) if (r.indexOf(s) !== -1) if (a) {
        t = false;
        break;
      } else a = true;
      if (!t) break;
    }
    return t;
  }
  function Jb(n, t, e = console.log) {
    let r = "";
    for (let i = 0; i < n.length; ++i) i > 0 && (r = r.slice(0, r.length - 1) + " "), r += n[i], r = r.slice(0, t[i]), r += " ".repeat(t[i] - r.length);
    e(r);
  }
  function _Rt(n, t, e) {
    let r, i;
    try {
      i = n.inboundNodes.map((l) => JSON.stringify(l.inputShapes)).join(",");
    } catch {
      i = "multiple";
    }
    try {
      r = JSON.stringify(n.outputShape);
    } catch {
      r = "multiple";
    }
    const a = n.name, s = n.getClassName(), o = [
      `${a} (${s})`,
      i,
      r,
      n.countParams().toString()
    ];
    Jb(o, t, e);
  }
  function wRt(n, t, e, r) {
    let i, a;
    try {
      a = n.inboundNodes.map((h) => JSON.stringify(h.inputShapes)).join(",");
    } catch {
      a = "multiple";
    }
    try {
      i = JSON.stringify(n.outputShape);
    } catch {
      i = "multiple";
    }
    const s = [];
    for (const h of n.inboundNodes) if (!(e != null && e.length > 0 && e.indexOf(h) === -1)) for (let f = 0; f < h.inboundLayers.length; ++f) {
      const d = h.inboundLayers[f].name, p = h.nodeIndices[f], g = h.tensorIndices[f];
      s.push(`${d}[${p}][${g}]`);
    }
    const o = n.name, l = n.getClassName(), u = s.length === 0 ? "" : s[0], c = [
      `${o} (${l})`,
      a,
      i,
      n.countParams().toString(),
      u
    ];
    Jb(c, t, r);
    for (let h = 1; h < s.length; ++h) Jb([
      "",
      "",
      "",
      "",
      s[h]
    ], t, r);
  }
  function z7(n, t, e) {
    return (n === "inboundNodes" || n === "outputLayers" || n === "inputLayers") && t === 0 && typeof e == "string";
  }
  function B2(n, t) {
    if (n === null) return null;
    if (typeof n == "string") return pc(n);
    if (typeof n == "number" || typeof n == "boolean") return n;
    if (n instanceof Array) {
      const e = [], r = n.length;
      for (let i = 0; i < r; ++i) {
        const a = n[i];
        z7(t, i, a) ? e.push(a) : e.push(B2(a, t));
      }
      return e;
    } else {
      const e = {};
      for (const r of Object.keys(n)) {
        const i = n[r];
        if (r === "name" && typeof i == "string") e[r] = i;
        else {
          const a = pc(r);
          e[a] = B2(i, a);
        }
      }
      return e;
    }
  }
  function z2(n, t) {
    if (n == null) return null;
    if (typeof n == "string") return So(n);
    if (typeof n == "number" || typeof n == "boolean") return n;
    if (n instanceof Array) {
      const e = [], r = n.length;
      for (let i = 0; i < r; ++i) {
        const a = n[i];
        z7(t, i, a) ? e.push(a) : e.push(z2(a, t));
      }
      return e;
    } else {
      const e = {};
      for (const r of Object.keys(n)) {
        const i = n[r], a = So(r);
        (r === "name" || r === "className") && typeof i == "string" ? e[a] = i : e[a] = z2(i, r);
      }
      return e;
    }
  }
  const V7 = "4.22.0";
  const SRt = (n) => {
    const t = Object.keys(n);
    if (t.length === 0) return false;
    const e = t[0].split("/");
    return !isNaN(parseInt(e[e.length - 1], 10));
  };
  let CRt = class As extends Ce {
    constructor(t) {
      if (super({}), this.containerNodes = /* @__PURE__ */ new Set(), this.name = t.name, this.name == null) {
        const y = this.getClassName().toLowerCase();
        this.name = vw(y);
      }
      if (this.supportsMasking = false, this.trainable_ = true, Array.isArray(t.inputs) ? this.inputs = t.inputs.slice() : this.inputs = [
        t.inputs
      ], Array.isArray(t.outputs) ? this.outputs = t.outputs.slice() : this.outputs = [
        t.outputs
      ], Wl(this.inputs).length !== this.inputs.length) throw new Y(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((y) => y.name)}`);
      Wl(this.outputs).length !== this.outputs.length && console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((y) => y.name)}`), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];
      for (const y of this.outputs) {
        const x = y.sourceLayer, b = y.nodeIndex, _ = y.tensorIndex;
        this.outputLayers.push(x), this.outputLayersNodeIndices.push(b), this.outputLayersTensorIndices.push(_);
      }
      for (const y of this.inputs) {
        const x = y.sourceLayer, b = y.nodeIndex, _ = y.tensorIndex;
        Ls(b === 0, "input layer has >1 nodes"), Ls(_ === 0, "input layer has >1 tensors"), this.inputLayers.push(x), this.inputLayersNodeIndices.push(b), this.inputLayersTensorIndices.push(_);
      }
      this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];
      for (let y = 0; y < this.inputLayers.length; y++) {
        const x = this.inputLayers[y];
        if (!(x instanceof sy)) throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${x.getClassName()}.`);
        this.inputNames.push(x.name), this.feedInputShapes.push(x.batchInputShape), this.feedInputNames.push(x.name);
      }
      for (const y of this.outputLayers) this.outputNames.push(y.name);
      this.internalInputShapes = this.inputs.map((y) => y.shape), this.internalOutputShapes = this.outputs.map((y) => y.shape);
      const e = {}, r = {}, i = {}, a = {}, s = {}, o = [], l = (y, x, b, _, w, S) => {
        (_ == null || w == null || S == null) && (_ = y.sourceLayer, w = y.nodeIndex, S = y.tensorIndex);
        const I = _.inboundNodes[w];
        if (b.indexOf(I) !== -1) throw new wa(`The tensor ${y.name} at layer "${_.name}" is part of a cycle.`);
        if (x.indexOf(I) !== -1) return;
        this.containerNodes.add(As.nodeKey(_, w)), _.id in s || (s[_.id] = Object.keys(s).length), b.indexOf(I) === -1 && b.push(I);
        const T = I.inboundLayers.length;
        for (let A = 0; A < T; A++) {
          const C = I.inputTensors[A], D = I.inboundLayers[A], E = I.nodeIndices[A], M = I.tensorIndices[A];
          l(C, x, b, D, E, M);
        }
        for (x.push(I); b.indexOf(I) >= 0; ) b.splice(b.indexOf(I), 1);
        o.push(I);
      }, u = [], c = [];
      for (const y of this.outputs) l(y, u, c);
      const h = o.slice().reverse();
      for (const y of h) {
        r[y.id] = y, y.id in e || (e[y.id] = 0);
        let x = e[y.id];
        const b = i[y.outboundLayer.id] == null ? 0 : i[y.outboundLayer.id];
        x = Math.max(x, b), i[y.outboundLayer.id] = x, a[y.outboundLayer.id] = y.outboundLayer, e[y.id] = x;
        for (let _ = 0; _ < y.inboundLayers.length; _++) {
          const w = y.inboundLayers[_], S = y.nodeIndices[_], I = w.inboundNodes[S], T = e[I.id] == null ? 0 : e[I.id];
          e[I.id] = Math.max(x + 1, T), r[I.id] = I;
        }
      }
      const f = {};
      for (const y in e) {
        const x = e[y];
        x in f || (f[x] = []), f[x].push(r[y]);
      }
      const d = {};
      for (const y in i) {
        const x = i[y];
        x in d || (d[x] = []), d[x].push(a[y]);
      }
      let p = Object.keys(d).map((y) => parseInt(y, 10)).sort(S0);
      this.layers = [];
      for (const y of p) {
        const x = d[y];
        x.sort((b, _) => {
          const w = s[b.id], S = s[_.id];
          return w < S ? -1 : w > S ? 1 : 0;
        });
        for (const b of x) b instanceof As && this.internalContainerRefs.push(b), this.layers.push(b);
      }
      this.layersByDepth = d, p = Object.keys(f).map((y) => parseInt(y, 10)).sort(S0);
      const g = this.inputs.slice(), v = [];
      for (const y of p) for (const x of f[y]) {
        const b = x.outboundLayer;
        if (b != null) {
          for (const _ of x.inputTensors) if (g.indexOf(_) === -1) throw new wa(`Graph disconnected: cannot obtain value for tensor ${_} at layer "${b.name}". The following previous layers were accessed without issue: ${v}`);
          for (const _ of x.outputTensors) g.push(_);
          v.push(b.name);
        }
      }
      this.nodesByDepth = f;
      const m = this.layers.map((y) => y.name);
      for (const y of m) {
        const x = m.filter((b) => b === y).length;
        if (x !== 1) throw new wa(`The name "${y}" is used ${x} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(m));
      }
      this.outboundNodes = [], this.inboundNodes = [], new yw({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: this.inputs.map((y) => null),
        outputMasks: this.outputs.map((y) => null),
        inputShapes: this.inputs.map((y) => y.shape),
        outputShapes: this.outputs.map((y) => y.shape)
      }), this.built = true, this._refCount = 1;
    }
    assertNotDisposed() {
      if (this._refCount === 0) throw new Error(`Container '${this.name}' is already disposed.`);
    }
    dispose() {
      this.assertNotDisposed();
      const t = {
        refCountAfterDispose: null,
        numDisposedVariables: 0
      };
      if (--this._refCount === 0) {
        for (const e of this.layers) t.numDisposedVariables += e.dispose().numDisposedVariables;
        for (const e of this.internalContainerRefs) t.numDisposedVariables += e.dispose().numDisposedVariables;
      }
      return t.refCountAfterDispose = this._refCount, t;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(t) {
      this.layers.forEach((e) => {
        e._trainableWeights.forEach((r) => r.trainable = t);
      }), this.trainable_ = t;
    }
    get trainableWeights() {
      if (this._trainableWeights.length > 0) throw new Y("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
      if (!this.trainable) return [];
      let t = [];
      for (const e of this.layers) t = t.concat(e.trainableWeights);
      return t;
    }
    get nonTrainableWeights() {
      const t = [];
      for (const e of this.layers) t.push(...e.nonTrainableWeights);
      if (!this.trainable) {
        const e = [];
        for (const r of this.layers) e.push(...r.trainableWeights);
        return e.concat(t);
      }
      return t;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    loadWeights(t, e = true) {
      const r = {};
      let i = 0;
      const a = SRt(t);
      a && this.parseWeights(t);
      for (const o of this.layers) for (const [l, u] of o.weights.entries()) {
        const c = a ? `${u.name.split("/").slice(0, -1).join("/") + "/"}${l}` : u.originalName;
        if (r[c] != null) throw new Y(`Duplicate weight name: ${c}`);
        r[c] = u, i++;
      }
      const s = [];
      for (const o in t) {
        let l = o;
        if (r[o] == null) {
          const u = o.split("/");
          l = u.slice(0, -2).concat([
            u[u.length - 1]
          ]).join("/");
        }
        if (r[l] != null) s.push([
          r[l],
          t[o]
        ]);
        else if (e) throw new Y(`Provided weight data has no target variable: ${o}`);
        delete r[l];
      }
      if (e) {
        const o = [];
        for (const l in r) o.push(l);
        if (o.length > 0) throw new Y(`${o.length} of ${i} weights are not set: ${o}`);
      }
      ZR(s);
    }
    parseWeights(t) {
      for (const e in Object.keys(t)) {
        const r = e.split("/"), i = [
          "vars",
          "layer_checkpoint_dependencies"
        ], a = r.map((s) => s.startsWith("_") ? s.slice(1) : s).filter((s) => !i.includes(s)).join("/");
        a !== e && (t[a] = t[e], delete t[e]);
      }
    }
    updatedConfig() {
      const t = this.getConfig(), e = {};
      return e.className = this.getClassName(), e.config = t, e.kerasVersion = `tfjs-layers ${V7}`, e.backend = "TensorFlow.js", e;
    }
    toJSON(t, e = true) {
      const r = z2(this.updatedConfig());
      return e ? JSON.stringify(r) : r;
    }
    call(t, e) {
      return tt(() => {
        t = Ze(t);
        const r = new Nl();
        for (let i = 0; i < this.inputs.length; ++i) r.add(this.inputs[i], t[i]);
        return Jp(this.outputs, r, e);
      });
    }
    computeMask(t, e) {
      return tt(() => {
        t = Ze(t);
        let r;
        return e == null ? r = sh(null, t.length) : r = Ze(e), this.runInternalGraph(t, r)[1];
      });
    }
    computeOutputShape(t) {
      const e = Ub(t);
      if (e.length !== this.inputLayers.length) throw new Y(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);
      const r = {};
      for (let o = 0; o < e.length; o++) {
        const l = this.inputLayers[o], u = e[o], c = l.name + "_0_0";
        r[c] = u;
      }
      const i = Object.keys(this.nodesByDepth).map((o) => parseInt(o, 10)).sort(S0);
      if (i.length > 1) for (const o of i) {
        const l = this.nodesByDepth[o];
        for (const u of l) {
          const c = u.outboundLayer;
          if (this.inputLayers.map((g) => g.id).indexOf(c.id) !== -1) continue;
          const h = [];
          for (let g = 0; g < u.inboundLayers.length; g++) {
            const v = u.inboundLayers[g], m = u.nodeIndices[g], y = u.tensorIndices[g], x = `${v.name}_${m}_${y}`, b = r[x];
            h.push(b);
          }
          const f = c.computeOutputShape(ui(h)), d = Ub(f), p = c.inboundNodes.indexOf(u);
          for (let g = 0; g < d.length; g++) {
            const v = `${c.name}_${p}_${g}`;
            r[v] = d[g];
          }
        }
      }
      const a = [], s = [];
      for (let o = 0; o < this.outputLayers.length; o++) {
        const l = this.outputLayers[o], u = this.outputLayersNodeIndices[o], c = this.outputLayersTensorIndices[o], h = `${l.name}_${u}_${c}`;
        s.push(h);
      }
      for (let o = 0; o < s.length; o++) {
        const l = s[o];
        Ls(l in r), a.push(r[l]);
      }
      return ui(a);
    }
    runInternalGraph(t, e) {
      e == null && (e = sh(null, t.length));
      const r = {};
      for (let l = 0; l < this.inputs.length; ++l) {
        const u = this.inputs[l], c = t[l], h = e[l];
        r[u.id] = [
          c,
          h
        ];
      }
      const i = Object.keys(this.nodesByDepth).map((l) => parseInt(l, 10)).sort(S0);
      for (const l of i) {
        const u = this.nodesByDepth[l];
        for (const c of u) {
          const h = c.outboundLayer, f = c.inputTensors, d = c.outputTensors, p = new Array();
          for (const g of f) g.id in r && p.push(r[g.id]);
          if (p.length === f.length) {
            let g = {}, v, m, y, x;
            if (c.callArgs != null && (g = c.callArgs), p.length === 1) {
              const [b, _] = p[0];
              g.mask == null && (g.mask = _), y = Ze(h.call(b, g)), x = Ze(h.computeMask(b, _)), v = [
                b
              ], m = [
                _
              ];
            } else v = p.map((b) => b[0]), m = p.map((b) => b[1]), g.mask == null && (g.mask = m), y = Ze(h.call(v, g)), x = Ze(h.computeMask(v, m));
            if (h.activityRegularizer) throw new me("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
            for (let b = 0; b < d.length; ++b) {
              const _ = d[b], w = y[b], S = x[b];
              r[_.id] = [
                w,
                S
              ];
            }
          }
        }
      }
      const a = [], s = [], o = [];
      for (const l of this.outputs) {
        Ls(l.id in r, `Could not compute output ${l.name} : ${l.id}`);
        const [u, c] = r[l.id];
        o.push(u.shape), a.push(u), s.push(c);
      }
      return [
        a,
        s,
        o
      ];
    }
    buildNodeConversionMap(t) {
      const e = {};
      let r;
      for (const i of this.layers) {
        r = i instanceof As ? 1 : 0;
        for (let a = 0; a < i.inboundNodes.length; a++) {
          const s = As.nodeKey(i, a);
          this.containerNodes.has(s) && (e[s] = r, r += 1);
        }
      }
      return e;
    }
    getLayer(t, e) {
      if (e != null) return this.findLayer(e);
      if (t == null) throw new Y("Provide either a layer name or layer index");
      if (typeof t == "number") return this.findLayer(t);
      for (const r of this.layers) if (r.name === t) return r;
      throw new Y(`No such layer: ${t}`);
    }
    findLayer(t) {
      if (this.layers.length <= t) throw new Y(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);
      return this.layers[t];
    }
    calculateLosses() {
      return tt(() => {
        const t = [];
        for (const e of this.layers) for (let r = 0; r < e.inboundNodes.length; ++r) {
          const i = As.nodeKey(e, r);
          this.containerNodes.has(i) && t.push(...e.calculateLosses());
        }
        return t;
      });
    }
    getConfig() {
      const t = {
        name: this.name
      }, e = this.buildNodeConversionMap(this.layers), r = [];
      for (const s of this.layers) {
        const o = s.getClassName(), l = s.getConfig(), u = [];
        for (let h = 0; h < s.inboundNodes.length; h++) {
          const f = s.inboundNodes[h], d = As.nodeKey(s, h);
          let p = {};
          if (this.containerNodes.has(d)) {
            if (f.callArgs) try {
              JSON.stringify(f.callArgs), p = f.callArgs;
            } catch {
              console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`), p = {};
            }
            if (f.inboundLayers.length > 0) {
              const g = [];
              for (let v = 0; v < f.inboundLayers.length; v++) {
                const m = f.inboundLayers[v], y = f.nodeIndices[v], x = f.tensorIndices[v], b = As.nodeKey(m, y);
                let _ = e[b];
                _ == null && (_ = 0), g.push([
                  m.name,
                  _,
                  x,
                  p
                ]);
              }
              u.push(g);
            }
          }
        }
        const c = {};
        c.name = s.name, c.className = o, c.config = l, c.inboundNodes = u, r.push(c);
      }
      t.layers = r;
      const i = [];
      for (let s = 0; s < this.inputLayers.length; s++) {
        const o = this.inputLayers[s], l = this.inputLayersNodeIndices[s], u = As.nodeKey(o, l);
        if (!this.containerNodes.has(u)) continue;
        let c = e[u];
        c == null && (c = 0);
        const h = this.inputLayersTensorIndices[s];
        i.push([
          o.name,
          c,
          h
        ]);
      }
      t.inputLayers = i;
      const a = [];
      for (let s = 0; s < this.outputLayers.length; s++) {
        const o = this.outputLayers[s], l = this.outputLayersNodeIndices[s], u = As.nodeKey(o, l);
        if (!this.containerNodes.has(u)) continue;
        let c = e[u];
        c == null && (c = 0);
        const h = this.outputLayersTensorIndices[s];
        a.push([
          o.name,
          c,
          h
        ]);
      }
      return t.outputLayers = a, t;
    }
    static fromConfig(t, e, r = {}, i = false) {
      const a = {}, s = {};
      function o(v, m) {
        v.name in s ? s[v.name].push(m) : s[v.name] = [
          m
        ];
      }
      function l(v, m) {
        const y = [];
        let x;
        for (const b of m) {
          const _ = b[0], w = b[1], S = b[2];
          if (x = b[3] == null ? {} : b[3], !(_ in a)) {
            o(v, m);
            return;
          }
          const I = a[_];
          if (I.inboundNodes.length <= w) {
            o(v, m);
            return;
          }
          const T = I.inboundNodes[w];
          y.push(T.outputTensors[S]);
        }
        y.length > 0 && v.apply(ui(y), x);
      }
      function u(v) {
        const m = v.name, y = $o(v, e.customObjects != null ? e.customObjects : {});
        y.setFastWeightInitDuringBuild(i), a[m] = y, v.inboundNodes.forEach((b) => {
          if (!(b instanceof Array)) throw new Y(`Corrupted configuration, expected array for nodeData: ${b}`);
          o(y, b);
        });
      }
      const c = e.name, h = e.layers;
      for (const v of h) u(v);
      for (; !oMt(s); ) for (const v of h) {
        const m = a[v.name];
        if (m.name in s) {
          const y = s[m.name];
          delete s[m.name];
          for (const x of y) l(m, x);
        }
      }
      const f = [], d = [], p = e.inputLayers;
      for (const v of p) {
        const m = v[0], y = v[1], x = v[2];
        Ls(m in a);
        const _ = a[m].inboundNodes[y].outputTensors;
        f.push(_[x]);
      }
      const g = e.outputLayers;
      for (const v of g) {
        const m = v[0], y = v[1], x = v[2];
        Ls(m in a);
        const _ = a[m].inboundNodes[y].outputTensors;
        d.push(_[x]);
      }
      return new t({
        inputs: f,
        outputs: d,
        name: c
      });
    }
    get stateful() {
      if (this._stateful) throw new Y("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
      for (const t of this.layers) if (t.stateful) return true;
      return false;
    }
    resetStates() {
      tt(() => {
        this.layers.forEach((t) => {
          t.stateful && t.resetStates();
        });
      });
    }
  };
  function TRt(n, t, e) {
    const r = t.length;
    if (n == null || Array.isArray(n) && n.length === 0) return t.map((i) => null);
    if (r === 1) return Array.isArray(n) && n.length === 1 ? n : typeof n == "object" && t[0] in n ? [
      n[t[0]]
    ] : [
      n
    ];
    if (Array.isArray(n)) {
      if (n.length !== r) throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);
      return n;
    } else if (typeof n == "object" && Object.keys(n).length > 0 && typeof n[Object.keys(n)[0]] == "object") {
      const i = [];
      return t.forEach((a) => {
        a in n ? i.push(n[a]) : i.push(null);
      }), i;
    } else throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`);
  }
  function G7(n, t) {
    return TRt(n, t, "classWeight");
  }
  async function W7(n, t, e, r) {
    if (e != null) {
      const i = tt(() => {
        if (n.shape.length === 1) return Bc(n);
        if (n.shape.length === 2) {
          if (n.shape[1] > 1) return uv(n, 1);
          if (n.shape[1] === 1) return Z(n, [
            n.shape[0]
          ]);
          throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
        } else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
      }), a = Array.from(await i.data());
      Te(i);
      const s = [];
      return a.forEach((o) => {
        if (e[o] == null) throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);
        s.push(e[o]);
      }), Ni(s, "float32");
    } else return null;
  }
  function IRt(n, t) {
    return j(n, t);
  }
  const ARt = 32;
  function U7(n, t) {
    let e, r;
    const i = t;
    e = i.xs, r = i.ys, B(e != null && r != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);
    const a = SV("input", n.inputNames, e), s = SV("output", n.outputNames, r), o = a[0].shape[0];
    B(a.length === n.inputs.length, () => `LayersModel has ${n.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`), B(s.length === n.outputs.length, () => `LayersModel has ${n.outputs.length} outputs, but the dataset provides ${s.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);
    for (let l = 0; l < a.length; l++) B(a[l].shape[0] === o, () => `Batch size mismatch: input ${n.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);
    for (let l = 0; l < s.length; l++) B(s[l].shape[0] === o, () => `Batch size mismatch: output ${n.outputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);
    return {
      xs: a,
      ys: s
    };
  }
  function SV(n, t, e) {
    if (e instanceof Vn) return [
      e
    ];
    if (Array.isArray(e)) return B(e.length === t.length, () => `Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`), e;
    {
      const r = [];
      for (const i of t) {
        if (e[i] == null) throw new Y(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);
        r.push(e[i]);
      }
      return r;
    }
  }
  function kRt(n) {
    if (n.length === 3) throw new me("Validation with sample weights is not implemented yet.");
    return {
      xs: n[0],
      ys: n[1]
    };
  }
  async function DRt(n, t, e) {
    const r = e.batchesPerEpoch != null;
    if (B(n.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."), B(e != null, () => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."), B(e.epochs != null && e.epochs > 0 && Number.isInteger(e.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`), B(!r || e.batchesPerEpoch > 0 && Number.isInteger(e.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`), B(e.validationSplit == null, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."), n.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
    n.isTraining = true;
    try {
      const i = e.validationData != null;
      let a, s;
      if (i) if (CV(e.validationData)) B(e.validationBatches == null || e.validationBatches > 0 && Number.isInteger(e.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);
      else {
        const v = kRt(e.validationData);
        a = v.xs, s = v.ys;
      }
      const o = n.makeTrainFunction(), l = n.getDedupedMetricsNames();
      let u;
      i ? u = l.slice().concat(l.map((v) => "val_" + v)) : u = l.slice();
      const c = N7(e.callbacks, e.yieldEvery), h = e.verbose == null ? 1 : e.verbose, { callbackList: f, history: d } = L7(c, h, e.epochs, null, null, ERt(t, e), null, i, u);
      f.setModel(n), n.history = d, await f.onTrainBegin(), n.stopTraining_ = false;
      let p = e.initialEpoch == null ? 0 : e.initialEpoch, g = await t.iterator();
      for (; p < e.epochs; ) {
        const v = {};
        await f.onEpochBegin(p);
        let m = 0, y = 0;
        for (r || (g = await t.iterator()); !r || m < e.batchesPerEpoch; ) {
          const x = await g.next();
          if (r && x.done) {
            console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${m} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch * e.epochs} batches). You may need to use the repeat() function when building your dataset.`);
            break;
          }
          if (x.value != null) {
            const { xs: b, ys: _ } = U7(n, x.value), w = {};
            w.batch = y, w.size = b[0].shape[0], await f.onBatchBegin(y, w);
            const S = [];
            if (e.classWeight != null) {
              const A = G7(e.classWeight, n.outputNames);
              for (let C = 0; C < A.length; ++C) S.push(await W7(_[C], null, A[C]));
            }
            const I = b.concat(_).concat(S), T = o(I);
            Te(I);
            for (let A = 0; A < l.length; ++A) {
              const C = l[A], D = T[A];
              w[C] = D, qs(D);
            }
            await f.onBatchEnd(y, w), R7(w), y++, m++;
          }
          if (r ? m >= e.batchesPerEpoch : x.done) {
            if (i) {
              let b;
              CV(e.validationData) ? b = Ze(await n.evaluateDataset(e.validationData, {
                batches: e.validationBatches
              })) : b = Ze(n.evaluate(a, s, {
                batchSize: e.validationBatchSize == null ? ARt : e.validationBatchSize,
                verbose: 0
              }));
              for (let _ = 0; _ < n.metricsNames.length; ++_) v[`val_${n.metricsNames[_]}`] = b[_];
            }
            break;
          }
          if (n.stopTraining_) break;
        }
        if (await f.onEpochEnd(p, v), p++, n.stopTraining_) break;
      }
      return await f.onTrainEnd(), await n.history.syncData(), n.history;
    } finally {
      n.isTraining = false;
    }
  }
  function ERt(n, t) {
    let e = null;
    return t.batchesPerEpoch != null ? e = t.batchesPerEpoch : Number.isFinite(n.size) && (e = n.size), e;
  }
  function CV(n) {
    return typeof n.iterator == "function";
  }
  function MRt(n) {
    return typeof n.next == "function";
  }
  async function RRt(n, t, e) {
    e = e || {};
    const r = e.batches != null, i = n.testFunction;
    let a = [];
    if (e.verbose > 0) throw new me("Verbose mode is not implemented yet.");
    B(!r || e.batches > 0 && Number.isInteger(e.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);
    const s = MRt(t) ? t : await t.iterator();
    let o = 0, l = 0;
    for (; !r || l < e.batches; ) {
      const u = await s.next();
      if (a = tt(() => {
        if (u.value) {
          const { xs: c, ys: h } = U7(n, u.value), f = c.concat(h), d = tt(() => i(f));
          if (Te(f), l === 0) for (let g = 0; g < d.length; ++g) a.push(Ue(0));
          const p = f[0].shape[0];
          for (let g = 0; g < d.length; ++g) {
            const v = d[g], m = a[g];
            a[g] = tt(() => bt(a[g], j(p, v))), l > 0 && Te(m);
          }
          Te(d), o += p, ++l;
        }
        return a;
      }), u.done) {
        r && console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);
        break;
      }
    }
    for (let u = 0; u < a.length; ++u) {
      const c = a[u];
      a[u] = Jt(a[u], o), Te(c);
    }
    return ui(a);
  }
  function ST(n) {
    B(n > 0 && Number.isInteger(n), () => `batchSize is required to be a positive integer, but got ${n}`);
  }
  function Dp(n, t, e) {
    return n == null ? [
      null
    ] : Array.isArray(n) ? n.map((r) => Vc(r, t, e - t)) : Vc(n, t, e - t);
  }
  function V2(n, t) {
    return tt(() => n == null ? null : Array.isArray(n) ? n.map((e) => V2(e, t)) : y7(n, t.dtype === "int32" ? t : Et(t, "int32")));
  }
  function CT(n, t) {
    const e = [];
    let r = 0, i = null;
    for (; r < n; ) i = r + t, i >= n && (i = n), e.push([
      r,
      i
    ]), r = i;
    return e;
  }
  function H7(n) {
    const t = [];
    n instanceof Vn && (n = [
      n
    ]);
    for (let e = 0; e < n.length; ++e) {
      const r = n[e];
      if (r.rank === 1) t.push(ry(r, 1));
      else {
        if (r.rank === 0) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
        t.push(r);
      }
    }
    return t;
  }
  function Ba(n, t) {
    if (n == null) return;
    const e = [];
    if (t instanceof Vn) e.push(t.id);
    else if (Array.isArray(t)) t.forEach((i) => e.push(i.id));
    else if (t != null) for (const i in t) {
      const a = t[i];
      e.push(a.id);
    }
    const r = [];
    if (n instanceof Vn) e.indexOf(n.id) === -1 && r.push(n);
    else if (Array.isArray(n)) n.forEach((i) => {
      e.indexOf(i.id) === -1 && r.push(i);
    });
    else if (n != null) for (const i in n) {
      const a = n[i];
      e.indexOf(a.id) === -1 && r.push(a);
    }
    r.forEach((i) => {
      i.isDisposed || i.dispose();
    });
  }
  function NRt(n) {
    return n instanceof Vn;
  }
  function G2(n) {
    return Array.isArray(n);
  }
  function TV(n) {
    return !NRt(n) && !G2(n);
  }
  function IV(n, t, e, r = true, i = "") {
    if (t == null || t.length === 0) {
      if (n != null) {
        let s = false;
        if (G2(n) && n.length > 0) s = true;
        else if (TV(n)) {
          for (const o in n) if (n.hasOwnProperty(o)) {
            s = true;
            break;
          }
        } else s = true;
        if (s) throw new Y(`Error when checking model ${i} expected no data, but got ${n}`);
      }
      return [];
    }
    if (n == null) return t.map((s) => null);
    let a;
    if (TV(n)) {
      n = n, a = [];
      for (const s of t) {
        if (n[s] == null) throw new Y(`No data provided for "${s}". Need data for each key in: ${t}`);
        a.push(n[s]);
      }
    } else if (G2(n)) {
      if (n = n, n.length !== t.length) throw new Y(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);
      a = n;
    } else {
      if (n = n, t.length > 1) throw new Y(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);
      a = [
        n
      ];
    }
    if (a = H7(a), e != null) for (let s = 0; s < t.length; ++s) {
      if (e[s] == null) continue;
      const o = a[s];
      if (o.shape.length !== e[s].length) throw new Y(`Error when checking ${i}: expected ${t[s]} to have ${e[s].length} dimension(s). but got array with shape ${o.shape}`);
      for (let l = 0; l < e[s].length; ++l) {
        if (l === 0 && !r) continue;
        const u = o.shape[l], c = e[s][l];
        if (c != null && c >= 0 && u !== c) throw new Y(`${i} expected a batch of elements where each example has shape [${e[s].slice(1, e[s].length)}] (i.e.,tensor shape [*,${e[s].slice(1, e[s].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1, o.shape.length)}] (tensor shape [${o.shape}])`);
      }
    }
    return a;
  }
  function LRt(n, t, e) {
    const r = Wl(n.map((a) => a.shape[0]));
    r.sort();
    const i = Wl(t.map((a) => a.shape[0]));
    if (i.sort(), r.length > 1) throw new Y(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map((a) => a.shape))}`);
    if (i.length > 1) throw new Y(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((a) => a.shape))}`);
    if (r.length > 0 && i.length > 0 && !Xe(r, i)) throw new Y(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`);
  }
  function PRt(n, t, e) {
    const r = [
      xw,
      bw,
      gv
    ];
    for (let i = 0; i < n.length; ++i) {
      const a = n[i], s = t[i], o = e[i];
      if (s != null) {
        if (s === gv && a.shape[a.shape.length - 1] === 1) throw new Y(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
        if (r.indexOf(s) !== -1) {
          const l = a.shape.slice(1), u = o.slice(1);
          for (let c = 0; c < l.length; ++c) {
            const h = l[c], f = u[c];
            if (f != null && h !== f) throw new Y(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`);
          }
        }
      }
    }
  }
  function AV(n, t, e, r = true, i = "") {
    let a;
    if (Array.isArray(n)) {
      if (n.length !== t.length) throw new Y(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);
      a = n;
    } else {
      if (t.length > 1) throw new Y(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);
      a = [
        n
      ];
    }
    if (e != null) for (let s = 0; s < t.length; ++s) {
      if (e[s] == null) continue;
      const o = a[s];
      if (o.shape.length !== e[s].length) throw new Y(`Error when checking ${i}: expected ${t[s]} to have ${e[s].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);
      for (let l = 0; l < e[s].length; ++l) {
        if (l === 0 && !r) continue;
        const u = o.shape[l], c = e[s][l];
        if (c != null && c !== u) throw new Y(`Error when checking ${i}: expected ${t[s]} to have shape ${JSON.stringify(e[s])} but got array with shape ${JSON.stringify(o.shape)}.`);
      }
    }
  }
  function $Rt(n, t) {
    if (n == null || Array.isArray(n) && n.length === 0) return t.map((r) => []);
    let e;
    if (typeof n == "string" || typeof n == "function") e = [
      n
    ];
    else if (Array.isArray(n) || typeof n == "object") e = n;
    else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);
    if (Array.isArray(e)) return t.map((r) => e);
    {
      const r = [];
      for (const i of t) {
        let a = e.hasOwnProperty(i) ? e[i] : [];
        Array.isArray(a) || (a = [
          a
        ]), r.push(a);
      }
      return r;
    }
  }
  const ORt = "layers-model";
  class Of extends CRt {
    constructor(t) {
      super(t), this.isTraining = false;
    }
    summary(t, e, r = console.log) {
      if (!this.built) throw new Y("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
      yRt(this, t, e, r);
    }
    compile(t) {
      if (t.loss == null && (t.loss = []), this.loss = t.loss, typeof t.optimizer == "string") this.optimizer_ = mRt(t.optimizer), this.isOptimizerOwned = true;
      else {
        if (!(t.optimizer instanceof pu)) throw new Y("User-defined optimizer must be an instance of tf.Optimizer.");
        this.optimizer_ = t.optimizer, this.isOptimizerOwned = false;
      }
      let e = [];
      if (!Array.isArray(t.loss) && typeof t.loss != "string" && typeof t.loss != "function") {
        t.loss = t.loss;
        for (const s in t.loss) if (this.outputNames.indexOf(s) === -1) throw new Y(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);
        for (const s of this.outputNames) t.loss[s] == null && console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`), e.push(wT(t.loss[s]));
      } else if (Array.isArray(t.loss)) {
        if (t.loss.length !== this.outputs.length) throw new Y(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);
        e = t.loss.map((o) => wT(o));
      } else {
        const s = wT(t.loss);
        this.outputs.forEach((o) => {
          e.push(s);
        });
      }
      this.lossFunctions = e, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
      for (let s = 0; s < this.outputs.length; ++s) {
        const o = this.internalOutputShapes[s], l = this.outputNames[s];
        this.feedOutputNames.push(l), this.feedOutputShapes.push(o), this.feedLossFns.push(this.lossFunctions[s]);
      }
      const r = [];
      this.metrics = t.metrics, this.metricsNames = [
        "loss"
      ], this.metricsTensors = [], zc("loss", () => {
        for (let s = 0; s < this.outputs.length; ++s) {
          if (r.indexOf(s) !== -1) continue;
          const o = this.lossFunctions[s];
          this.outputs.length > 1 && (this.metricsTensors.push([
            o,
            s
          ]), this.metricsNames.push(this.outputNames[s] + "_loss"));
        }
      });
      const i = $Rt(t.metrics, this.outputNames), a = (s, o, l) => {
        this.outputNames.length > 1 && (o = this.outputNames[s] + "_" + o), this.metricsNames.push(o), this.metricsTensors.push([
          l,
          s
        ]);
      };
      zc("metric", () => {
        for (let s = 0; s < this.outputs.length; ++s) {
          if (r.indexOf(s) !== -1) continue;
          const o = i[s];
          ((u) => {
            const c = "";
            let h, f, d;
            for (const p of u) {
              if (typeof p == "string" && [
                "accuracy",
                "acc",
                "crossentropy",
                "ce"
              ].indexOf(p) !== -1) {
                const v = this.internalOutputShapes[s];
                v[v.length - 1] === 1 || this.lossFunctions[s] === bw ? [
                  "accuracy",
                  "acc"
                ].indexOf(p) !== -1 ? f = $7 : [
                  "crossentropy",
                  "ce"
                ].indexOf(p) !== -1 && (f = oRt) : this.lossFunctions[s] === jb ? [
                  "accuracy",
                  "acc"
                ].indexOf(p) !== -1 ? f = lRt : [
                  "crossentropy",
                  "ce"
                ].indexOf(p) !== -1 && (f = B7) : [
                  "accuracy",
                  "acc"
                ].indexOf(p) !== -1 ? f = O7 : [
                  "crossentropy",
                  "ce"
                ].indexOf(p) !== -1 && (f = F7);
                let m;
                [
                  "accuracy",
                  "acc"
                ].indexOf(p) !== -1 ? m = "acc" : [
                  "crossentropy",
                  "ce"
                ].indexOf(p) !== -1 && (m = "ce"), d = f, h = c + m;
              } else d = vRt(p), h = c + I0(p);
              let g;
              zc(h, () => {
                g = d;
              }), a(s, h, g);
            }
          })(o);
        }
      }), this.collectedTrainableWeights = this.trainableWeights;
    }
    checkTrainableWeightsConsistency() {
      this.collectedTrainableWeights != null && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
    }
    evaluate(t, e, r = {}) {
      const i = r.batchSize == null ? 32 : r.batchSize;
      ST(i);
      const s = this.standardizeUserDataXY(t, e, true, i);
      try {
        const o = s[0].concat(s[1]);
        this.makeTestFunction();
        const l = this.testFunction, u = this.testLoop(l, o, i, r.verbose, r.steps);
        return ui(u);
      } finally {
        Ba(s[0], t), Ba(s[1], e);
      }
    }
    async evaluateDataset(t, e) {
      return this.makeTestFunction(), RRt(this, t, e);
    }
    checkNumSamples(t, e, r, i = "steps") {
      let a;
      if (r != null) {
        if (a = null, e != null) throw new Y(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${e}`);
      } else if (t != null) Array.isArray(t) ? a = t[0].shape[0] : a = t.shape[0];
      else throw new Y(`Either the input data should have a defined shape, or ${i} shoud be specified.`);
      return a;
    }
    execute(t, e) {
      if (Array.isArray(e) && e.length === 0) throw new Y("`outputs` is an empty Array, which is not allowed.");
      const r = Array.isArray(e), i = r ? e : [
        e
      ], a = this.retrieveSymbolicTensors(i), s = new Nl();
      if (t instanceof Vn && (t = [
        t
      ]), Array.isArray(t)) {
        if (t.length !== this.inputs.length) throw new Y(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
        for (let l = 0; l < this.inputs.length; ++l) s.add(this.inputs[l], t[l]);
      } else for (const l of this.inputs) {
        const u = t[l.name];
        if (u == null) throw new Y(`No value is provided for the model's input ${l.name}`);
        s.add(l, u);
      }
      const o = Jp(a, s);
      return r ? o : o[0];
    }
    retrieveSymbolicTensors(t) {
      const e = sh(null, t.length);
      let r = t.length;
      for (const i of this.layers) {
        const a = Array.isArray(i.output) ? i.output : [
          i.output
        ], s = a.map((o) => o.name);
        for (let o = 0; o < t.length; ++o) {
          const l = s.indexOf(t[o]);
          if (l !== -1 && (e[o] = a[l], r--), r === 0) break;
        }
        if (r === 0) break;
      }
      if (r > 0) {
        const i = [];
        throw e.forEach((a, s) => {
          a == null && i.push(t[s]);
        }), new Y(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`);
      }
      return e;
    }
    predictLoop(t, e = 32, r = false) {
      return tt(() => {
        const i = this.checkNumSamples(t);
        if (r) throw new me("Verbose predictLoop() is not implemented yet.");
        const a = CT(i, e), s = this.outputs.map((o) => []);
        for (let o = 0; o < a.length; ++o) tt(() => {
          const u = a[o][0], c = a[o][1], h = Dp(t, u, c), f = [];
          if (Array.isArray(h)) for (let p = 0; p < h.length; ++p) f.push({
            key: this.inputs[p],
            value: h[p]
          });
          else f.push({
            key: this.inputs[0],
            value: h
          });
          const d = new Nl(f);
          return Jp(this.outputs, d);
        }).forEach((u, c) => s[c].push(u));
        return ui(s.map((o) => pi(o, 0)));
      });
    }
    predict(t, e = {}) {
      const r = H7(t);
      AV(r, this.inputNames, this.feedInputShapes, false);
      try {
        const i = e.batchSize == null ? 32 : e.batchSize;
        return ST(i), this.predictLoop(r, i);
      } finally {
        Ba(r, t);
      }
    }
    predictOnBatch(t) {
      AV(t, this.inputNames, this.feedInputShapes, true);
      const e = (Array.isArray(t) ? t[0] : t).shape[0];
      return this.predictLoop(t, e);
    }
    standardizeUserDataXY(t, e, r = true, i) {
      if (this.optimizer_ == null) throw new wa("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
      const a = [];
      for (let s = 0; s < this.feedOutputShapes.length; ++s) {
        const o = this.feedOutputShapes[s];
        this.feedLossFns[s] === jb ? a.push(o.slice(0, o.length - 1).concat([
          1
        ])) : a.push(o);
      }
      if (t = IV(t, this.feedInputNames, this.feedInputShapes, false, "input"), e = IV(e, this.feedOutputNames, a, false, "target"), LRt(t, e), PRt(e, this.feedLossFns, this.feedOutputShapes), this.stateful && i != null && i > 0 && t[0].shape[0] % i !== 0) throw new Y(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${t[0].shape[0]} sample(s).`);
      return [
        t,
        e
      ];
    }
    async standardizeUserData(t, e, r, i, a = true, s) {
      const [o, l] = this.standardizeUserDataXY(t, e, a, s);
      if (r != null) throw new Error("sample weight is not supported yet.");
      let u = null;
      if (i != null) {
        const c = G7(i, this.outputNames);
        u = [];
        for (let h = 0; h < c.length; ++h) u.push(await W7(l[h], null, c[h]));
      }
      return [
        o,
        l,
        u
      ];
    }
    testLoop(t, e, r, i = 0, a) {
      return tt(() => {
        const s = this.checkNumSamples(e, r, a, "steps"), o = [];
        if (i > 0) throw new me("Verbose mode is not implemented yet.");
        if (a != null) throw new me("steps mode in testLoop() is not implemented yet");
        {
          const l = CT(s, r), u = Ni(ls(0, s));
          for (let c = 0; c < l.length; ++c) {
            const h = l[c][0], f = l[c][1], d = Vc(u, h, f - h), p = V2(e, d), g = t(p);
            if (c === 0) for (let v = 0; v < g.length; ++v) o.push(Ue(0));
            for (let v = 0; v < g.length; ++v) {
              const m = g[v];
              o[v] = bt(o[v], j(f - h, m));
            }
          }
          for (let c = 0; c < o.length; ++c) o[c] = Jt(o[c], s);
        }
        return o;
      });
    }
    getDedupedMetricsNames() {
      const t = this.metricsNames, e = [];
      for (let r = 0; r < t.length; ++r) {
        const i = t[r];
        let a = i;
        if (hV(t, i) > 1) {
          const s = hV(t.slice(0, r), i);
          a += `_${s}`;
        }
        e.push(a);
      }
      return e;
    }
    makeTrainFunction() {
      return (t) => {
        const e = [], r = t.slice(0, this.inputs.length), i = t.slice(this.inputs.length, this.inputs.length + this.outputs.length), a = t.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2), s = [], o = () => {
          const h = [];
          for (let g = 0; g < this.inputs.length; ++g) h.push({
            key: this.inputs[g],
            value: r[g]
          });
          const f = new Nl(h), d = Jp(this.outputs, f, {
            training: true
          });
          let p;
          for (let g = 0; g < this.lossFunctions.length; ++g) {
            const v = this.lossFunctions[g];
            let m = v(i[g], d[g]);
            a[g] != null && (m = IRt(m, a[g]));
            const y = $n(m);
            e.push(y), g === 0 ? p = m : p = bt(p, m);
          }
          for (let g = 0; g < this.metricsTensors.length; ++g) {
            let v;
            if (this.outputs.length > 1 && g < this.outputs.length) v = e[g];
            else {
              const m = this.metricsTensors[g][0], y = this.metricsTensors[g][1];
              v = $n(m(i[y], d[y]));
            }
            qs(v), s.push(v);
          }
          return p = $n(p), this.calculateLosses().forEach((g) => {
            p = bt(p, g);
          }), p;
        }, l = this.collectedTrainableWeights.map((h) => h.read());
        return [
          this.optimizer_.minimize(o, true, l)
        ].concat(s);
      };
    }
    makeTestFunction() {
      this.testFunction = (t) => tt(() => {
        const e = [];
        let r;
        const i = t.slice(0, this.inputs.length), a = t.slice(this.inputs.length, this.inputs.length + this.outputs.length), s = [];
        for (let u = 0; u < this.inputs.length; ++u) s.push({
          key: this.inputs[u],
          value: i[u]
        });
        const o = new Nl(s), l = Jp(this.outputs, o);
        for (let u = 0; u < this.lossFunctions.length; ++u) {
          const c = this.lossFunctions[u], h = $n(c(a[u], l[u]));
          u === 0 ? r = h : r = bt(r, h), e.push(r);
        }
        for (let u = 0; u < this.metricsTensors.length; ++u) {
          const c = this.metricsTensors[u][0], h = this.metricsTensors[u][1], f = $n(c(a[h], l[h]));
          e.push(f);
        }
        return e;
      });
    }
    async fit(t, e, r = {}) {
      if (this.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
      this.isTraining = true;
      let i, a, s, o, l, u, c, h, f;
      try {
        const d = r.batchSize == null ? 32 : r.batchSize;
        ST(d);
        const g = await this.standardizeUserData(t, e, r.sampleWeight, r.classWeight, false, d);
        i = g[0], a = g[1], f = g[2];
        let v = false, m;
        if (r.validationData != null && r.validationData.length > 0) {
          if (v = true, r.validationData.length === 2) l = r.validationData[0], u = r.validationData[1];
          else throw r.validationData.length === 3 ? new me("validationData including sample weights is not supported yet.") : new Y(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);
          const A = await this.standardizeUserData(l, u, null, null, true, d);
          c = A[0], h = A[1], m = c.concat(h);
        } else if (r.validationSplit != null && r.validationSplit > 0 && r.validationSplit < 1) {
          v = true;
          const T = Math.floor(i[0].shape[0] * (1 - r.validationSplit)), A = i[0].shape[0];
          c = Dp(i, T, A), s = i, i = Dp(i, 0, T), h = Dp(a, T, A), o = a, a = Dp(a, 0, T), m = c.concat(h);
        } else r.validationSteps != null && (v = true);
        const y = i.concat(a).concat(f);
        this.checkTrainableWeightsConsistency();
        const x = this.makeTrainFunction(), b = this.getDedupedMetricsNames();
        let _, w;
        v ? (this.makeTestFunction(), _ = this.testFunction, w = b.slice().concat(b.map((T) => "val_" + T))) : (_ = null, m = [], w = b.slice());
        const S = N7(r.callbacks, r.yieldEvery);
        return await this.fitLoop(x, y, b, d, r.epochs, r.verbose, S, _, m, r.shuffle, w, r.initialEpoch, null, null);
      } finally {
        this.isTraining = false, Ba(i, t), Ba(a, e), Ba(s, t), Ba(o, e), Ba(c, l), Ba(h, u), f != null && Te(f);
      }
    }
    async fitLoop(t, e, r, i, a, s, o, l, u, c, h, f, d, p) {
      i == null && (i = 32), a == null && (a = 1), c == null && (c = true), f == null && (f = 0);
      let g = false;
      if (l != null && u != null && (g = true), p != null && (g = true, d == null)) throw new Y("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
      const v = this.checkNumSamples(e, i, d, "steps_per_epoch");
      let m;
      v != null && (m = ls(0, v)), s == null && (s = 1);
      const { callbackList: y, history: x } = L7(o, s, a, f, v, d, i, g, h);
      y.setModel(this), this.history = x, await y.onTrainBegin(), this.stopTraining_ = false;
      for (let b = f; b < a; ++b) {
        await y.onEpochBegin(b);
        const _ = {};
        if (d != null) throw new me("stepsPerEpoch mode is not implemented yet.");
        {
          if (c === "batch") throw new me("batch shuffling is not implemneted yet");
          c && vSt(m);
          const w = Ni(m), S = CT(v, i);
          for (let I = 0; I < S.length; ++I) {
            const T = {};
            if (await y.onBatchBegin(I, T), tt(() => {
              const A = S[I][0], C = S[I][1], D = Vc(w, A, C - A);
              T.batch = I, T.size = C - A;
              const E = V2(e, D), M = t(E);
              for (let L = 0; L < r.length; ++L) {
                const k = r[L], N = M[L];
                T[k] = N, qs(N);
              }
              if (I === S.length - 1 && g) {
                const L = this.testLoop(l, u, i);
                for (let k = 0; k < r.length; ++k) {
                  const N = r[k], R = L[k];
                  qs(R), _["val_" + N] = R;
                }
              }
            }), await y.onBatchEnd(I, T), R7(T), this.stopTraining_) break;
          }
          w.dispose();
        }
        if (await y.onEpochEnd(b, _), this.stopTraining_) break;
      }
      return await y.onTrainEnd(), await this.history.syncData(), this.history;
    }
    async fitDataset(t, e) {
      return DRt(this, t, e);
    }
    async trainOnBatch(t, e) {
      const r = await this.standardizeUserData(t, e), i = r[0], a = r[1], o = this.makeTrainFunction()(i.concat(a)), l = [];
      for (const u of o) {
        const c = await u.data();
        l.push(c[0]);
      }
      return Te(o), Ba(r[0], t), Ba(r[1], e), ui(l);
    }
    getNamedWeights(t) {
      const e = [], r = t != null && t.trainableOnly, i = r ? this.trainableWeights : this.weights, a = this.getWeights(r);
      for (let s = 0; s < i.length; ++s) r && !i[s].trainable || e.push({
        name: i[s].originalName,
        tensor: a[s]
      });
      return e;
    }
    set stopTraining(t) {
      this.stopTraining_ = t;
    }
    get stopTraining() {
      return this.stopTraining_;
    }
    get optimizer() {
      return this.optimizer_;
    }
    set optimizer(t) {
      this.optimizer_ !== t && (this.optimizer_ = t, this.isOptimizerOwned = false);
    }
    dispose() {
      const t = super.dispose();
      if (t.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
        const e = Bz().numTensors;
        this.optimizer_.dispose(), t.numDisposedVariables += e - Bz().numTensors;
      }
      return t;
    }
    getLossIdentifiers() {
      let t;
      if (typeof this.loss == "string") t = So(this.loss);
      else if (Array.isArray(this.loss)) {
        for (const e of this.loss) if (typeof e != "string") throw new Error("Serialization of non-string loss is not supported.");
        t = this.loss.map((e) => So(e));
      } else {
        const e = Object.keys(this.loss);
        t = {};
        const r = this.loss;
        for (const i of e) if (typeof r[i] == "string") t[i] = So(r[i]);
        else throw new Error("Serialization of non-string loss is not supported.");
      }
      return t;
    }
    getMetricIdentifiers() {
      if (typeof this.metrics == "string" || typeof this.metrics == "function") return [
        So(I0(this.metrics))
      ];
      if (Array.isArray(this.metrics)) return this.metrics.map((t) => So(I0(t)));
      {
        const t = {};
        for (const e in this.metrics) t[e] = So(I0(this.metrics[e]));
        return t;
      }
    }
    getTrainingConfig() {
      return {
        loss: this.getLossIdentifiers(),
        metrics: this.getMetricIdentifiers(),
        optimizer_config: {
          class_name: this.optimizer.getClassName(),
          config: this.optimizer.getConfig()
        }
      };
    }
    loadTrainingConfig(t) {
      if (t.weighted_metrics != null) throw new Error("Loading weight_metrics is not supported yet.");
      if (t.loss_weights != null) throw new Error("Loading loss_weights is not supported yet.");
      if (t.sample_weight_mode != null) throw new Error("Loading sample_weight_mode is not supported yet.");
      const e = B2(t.optimizer_config), r = $o(e);
      let i;
      if (typeof t.loss == "string") i = pc(t.loss);
      else if (Array.isArray(t.loss)) i = t.loss.map((s) => pc(s));
      else if (t.loss != null) {
        i = {};
        for (const s in t.loss) i[s] = pc(t.loss[s]);
      }
      let a;
      if (Array.isArray(t.metrics)) a = t.metrics.map((s) => pc(s));
      else if (t.metrics != null) {
        a = {};
        for (const s in t.metrics) a[s] = pc(t.metrics[s]);
      }
      this.compile({
        loss: i,
        metrics: a,
        optimizer: r
      });
    }
    async save(t, e) {
      if (typeof t == "string") {
        const u = pCt(t);
        if (u.length === 0) throw new Y(`Cannot find any save handlers for URL '${t}'`);
        if (u.length > 1) throw new Y(`Found more than one (${u.length}) save handlers for URL '${t}'`);
        t = u[0];
      }
      if (t.save == null) throw new Y("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      const r = await Vz(this.getNamedWeights(e)), o = {
        modelTopology: this.toJSON(null, false),
        format: ORt,
        generatedBy: `TensorFlow.js tfjs-layers v${V7}`,
        convertedBy: null
      };
      if ((e == null ? false : e.includeOptimizer) && this.optimizer != null) {
        o.trainingConfig = this.getTrainingConfig();
        const u = "optimizer", { data: c, specs: h } = await Vz(await this.optimizer.getWeights(), u);
        r.specs.push(...h), r.data = dCt([
          r.data,
          c
        ]);
      }
      return this.userDefinedMetadata != null && (wV(this.userDefinedMetadata, this.name, true), o.userDefinedMetadata = this.userDefinedMetadata), o.weightData = r.data, o.weightSpecs = r.specs, t.save(o);
    }
    setUserDefinedMetadata(t) {
      wV(t, this.name), this.userDefinedMetadata = t;
    }
    getUserDefinedMetadata() {
      return this.userDefinedMetadata;
    }
  }
  Of.className = "Model";
  vt(Of);
  class X7 extends Of {
  }
  X7.className = "Functional";
  vt(X7);
  class vv extends Of {
    constructor(t) {
      if (super({
        inputs: [],
        outputs: []
      }), t = t || {}, this.trainable = true, this.built = false, this.name = t.name != null ? t.name : vw("sequential_"), t.layers != null) for (const e of t.layers) this.add(e);
    }
    checkShape(t) {
      if (t.inboundNodes[0].outputTensors[0].shape.some((r) => r < 0)) throw new Y(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`);
    }
    add(t) {
      const e = t instanceof vv || t instanceof Of;
      let r;
      if (e) {
        if (r = t, r.outputs.length !== 1) throw new Y("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        if (r.inputs.length !== 1) throw new Y("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
      }
      if (this.outputs.length === 0) {
        if (t.inboundNodes.length === 0) {
          if (t.batchInputShape == null) throw new Y("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
          const i = FMt({
            batchShape: t.batchInputShape,
            dtype: t.dtype,
            name: t.name + "_input"
          });
          t.apply(i);
        }
        if (e) this.outputs = r.outputs, this.inputs = r.inputs;
        else {
          if (t.inboundNodes.length !== 1) throw new Y(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);
          if (t.inboundNodes[0].outputTensors.length !== 1) throw new Y("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          this.checkShape(t), this.outputs = [
            t.inboundNodes[0].outputTensors[0]
          ], this.inputs = A7(this.outputs[0]);
        }
        this.inboundNodes = [], new yw({
          outboundLayer: this,
          inboundLayers: [],
          nodeIndices: [],
          tensorIndices: [],
          inputTensors: this.inputs,
          outputTensors: this.outputs,
          inputMasks: sh(null, this.inputs.length),
          outputMasks: [
            null
          ],
          inputShapes: this.inputs.map((i) => i.shape),
          outputShapes: this.outputs[0].shape
        });
      } else {
        const i = t.apply(this.outputs[0]);
        if (Array.isArray(i)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(t), this.outputs = [
          i
        ], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [
          this.outputs[0].shape
        ];
      }
      this.layers.push(t), this.built = false;
    }
    pop() {
      if (this.layers.length === 0) throw new TypeError("There are no layers in the model.");
      if (this.layers.pop(), this.layers.length === 0) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
      else {
        const t = this.layers.length - 1;
        this.layers[t].outboundNodes = [], this.outputs = [
          this.layers[t].output
        ], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [
          this.outputs[0].shape
        ];
      }
    }
    call(t, e) {
      return this.model == null && this.build(), this.model.call(t, e);
    }
    build(t) {
      if (ze(t), this.inputs.length === 0 || this.outputs.length === 0) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
      this.model = new Of({
        inputs: this.inputs,
        outputs: this.outputs[0],
        name: this.name + "_model"
      }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = true;
    }
    countParams() {
      return this.built || this.build(), super.countParams();
    }
    summary(t, e, r = console.log) {
      this.built || this.build(), super.summary(t, e, r);
    }
    setWeights(t) {
      this.model == null && this.build(), this.model.setWeights(t);
    }
    evaluate(t, e, r = {}) {
      if (!this.built) throw new wa("The model needs to be compiled before being used.");
      return this.model.evaluate(t, e, r);
    }
    async evaluateDataset(t, e) {
      if (!this.built) throw new wa("The model needs to be compiled before being used.");
      return this.model.evaluateDataset(t, e);
    }
    predict(t, e = {}) {
      return this.model == null && this.build(), this.model.predict(t, e);
    }
    predictOnBatch(t) {
      return this.model == null && this.build(), this.model.predictOnBatch(t);
    }
    compile(t) {
      this.build(), this.model.compile(t), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
    }
    get optimizer() {
      return this.model == null ? void 0 : this.model.optimizer;
    }
    set optimizer(t) {
      this.model.optimizer = t;
    }
    async fit(t, e, r = {}) {
      if (!this.built) throw new wa("The model needs to be compiled before being used.");
      return this.model.fit(t, e, r);
    }
    async fitDataset(t, e) {
      if (!this.built) throw new wa("The model needs to be compiled before being used.");
      return this.model.fitDataset(t, e);
    }
    async trainOnBatch(t, e) {
      return this.model.trainOnBatch(t, e);
    }
    static fromConfig(t, e, r = {}, i = false) {
      let a, s = {};
      if (e instanceof Array) {
        if (e[0].className == null || e[0].className === "Merge") throw new Y("Legacy serialization format not supported yet.");
        a = e;
      } else B(e.layers != null, () => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."), a = e.layers, delete e.layers, s = e;
      const o = new t(s);
      if (!(o instanceof vv)) throw new me(`Sequential.fromConfig called on non-Sequential input: ${o}`);
      for (const l of a) {
        const c = $o(l, void 0, i);
        i && c.setFastWeightInitDuringBuild(true), o.add(c);
      }
      return o;
    }
    set stopTraining(t) {
      if (this.model == null) throw new Y("Cannot set the stopTraining property of a sequential model before it is compiled.");
      this.model.stopTraining = t;
    }
    get stopTraining() {
      if (this.model == null) throw new Y("Cannot get the stopTraining property of a sequential model before it is compiled.");
      return this.model.stopTraining;
    }
    getConfig() {
      const t = [];
      for (const e of this.layers) {
        const r = {};
        r.className = e.getClassName(), r.config = e.getConfig(), t.push(r);
      }
      return {
        name: this.name,
        layers: t
      };
    }
  }
  vv.className = "Sequential";
  vt(vv);
  let Nr = class extends Bd {
    getConfig() {
      return {};
    }
  };
  class Y7 extends Nr {
    apply(t, e = 1) {
      return wMt(t, e);
    }
  }
  Y7.className = "elu";
  vt(Y7);
  class q7 extends Nr {
    apply(t) {
      return hj(t);
    }
  }
  q7.className = "selu";
  vt(q7);
  class j7 extends Nr {
    apply(t) {
      return wh(t);
    }
  }
  j7.className = "relu";
  vt(j7);
  class K7 extends Nr {
    apply(t) {
      return tt(() => fv(6, wh(t)));
    }
  }
  K7.className = "relu6";
  vt(K7);
  class Z7 extends Nr {
    apply(t) {
      return t;
    }
  }
  Z7.className = "linear";
  vt(Z7);
  class J7 extends Nr {
    apply(t) {
      return $d(t);
    }
  }
  J7.className = "sigmoid";
  vt(J7);
  class Q7 extends Nr {
    apply(t) {
      return CMt(t);
    }
  }
  Q7.className = "hardSigmoid";
  vt(Q7);
  class t9 extends Nr {
    apply(t) {
      return jm(t);
    }
  }
  t9.className = "softplus";
  vt(t9);
  class e9 extends Nr {
    apply(t) {
      return SMt(t);
    }
  }
  e9.className = "softsign";
  vt(e9);
  class n9 extends Nr {
    apply(t) {
      return sw(t);
    }
  }
  n9.className = "tanh";
  vt(n9);
  let eN = class extends Nr {
    apply(t, e = -1) {
      return iR(t, e);
    }
  };
  eN.className = "softmax";
  vt(eN);
  class r9 extends Nr {
    apply(t, e = -1) {
      return rj(t, e);
    }
  }
  r9.className = "logSoftmax";
  vt(r9);
  class i9 extends Nr {
    apply(t) {
      return tt(() => tt(() => {
        const e = Math.sqrt(2), r = j(0.5, bt(1, Jq(Jt(t, e))));
        return j(t, r);
      }));
    }
  }
  i9.className = "gelu";
  vt(i9);
  class a9 extends Nr {
    apply(t) {
      return tt(() => j(0.5, j(t, bt(1, sw(j(Mr(Jt(2, Math.PI)), bt(t, j(0.044715, rh(t, 3)))))))));
    }
  }
  a9.className = "gelu_new";
  vt(a9);
  class s9 extends Nr {
    apply(t) {
      return tt(() => j(t, sw(jm(t))));
    }
  }
  s9.className = "mish";
  vt(s9);
  class o9 extends Nr {
    apply(t, e = 1) {
      return tt(() => j($d(j(t, e)), t));
    }
  }
  o9.className = "swish";
  vt(o9);
  function nu(n) {
    return n.getClassName();
  }
  function TT(n, t = {}) {
    return ny(n, ba.getMap().classNameMap, t, "activation");
  }
  function ru(n) {
    if (n == null) {
      const t = {};
      return t.className = "linear", t.config = {}, TT(t);
    }
    if (typeof n == "string") {
      const t = {};
      return t.className = n, t.config = {}, TT(t);
    } else return n instanceof Nr ? n : TT(n);
  }
  function FRt(n) {
    if (n != null && typeof n != "object") throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`);
  }
  class l9 extends Bd {
  }
  class u9 extends l9 {
    constructor(t) {
      super(), FRt(t), this.l1 = t == null || t.l1 == null ? 0.01 : t.l1, this.l2 = t == null || t.l2 == null ? 0.01 : t.l2, this.hasL1 = this.l1 !== 0, this.hasL2 = this.l2 !== 0;
    }
    apply(t) {
      return tt(() => {
        let e = rr([
          1
        ]);
        return this.hasL1 && (e = bt(e, Kt(j(this.l1, Gr(t))))), this.hasL2 && (e = bt(e, Kt(j(this.l2, iy(t))))), Z(e, []);
      });
    }
    getConfig() {
      return {
        l1: this.l1,
        l2: this.l2
      };
    }
    static fromConfig(t, e) {
      return new t({
        l1: e.l1,
        l2: e.l2
      });
    }
  }
  u9.className = "L1L2";
  vt(u9);
  const kV = {
    l1l2: "L1L2"
  };
  function ln(n) {
    return VR(n);
  }
  function DV(n, t = {}) {
    return ny(n, ba.getMap().classNameMap, t, "regularizer");
  }
  function xn(n) {
    if (n == null) return null;
    if (typeof n == "string") {
      const e = {
        className: n in kV ? kV[n] : n,
        config: {}
      };
      return DV(e);
    } else return n instanceof l9 ? n : DV(n);
  }
  class c9 extends Ce {
    constructor(t) {
      super(t ?? {}), this.supportsMasking = true, t != null && (this.maxValue = t.maxValue);
    }
    call(t, e) {
      t = ae(t);
      let r = wh(t);
      return this.maxValue != null && (r = Ji(r, 0, this.maxValue)), r;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = {
        maxValue: this.maxValue
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  c9.className = "ReLU";
  vt(c9);
  class h9 extends Ce {
    constructor(t) {
      super(t ?? {}), this.DEFAULT_ALPHA = 0.3, t == null && (t = {}), this.alpha = t.alpha == null ? this.DEFAULT_ALPHA : t.alpha;
    }
    call(t, e) {
      const r = ae(t);
      return qM(r, this.alpha);
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = {
        alpha: this.alpha
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  h9.className = "LeakyReLU";
  vt(h9);
  class f9 extends Ce {
    constructor(t) {
      if (super(t ?? {}), this.DEFAULT_ALPHA_INITIALIZER = "zeros", t == null && (t = {}), this.supportsMasking = true, this.alphaInitializer = yn(t.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = xn(t.alphaRegularizer), this.alphaConstraint = Kn(t.alphaConstraint), t.sharedAxes == null) this.sharedAxes = null;
      else if (Array.isArray(t.sharedAxes)) this.sharedAxes = t.sharedAxes;
      else if (typeof t.sharedAxes == "number") this.sharedAxes = [
        t.sharedAxes
      ];
      else throw new Y(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);
    }
    build(t) {
      t = ze(t);
      const e = t.slice(1);
      if (this.sharedAxes != null) for (const i of this.sharedAxes) e[i - 1] = 1;
      this.alpha = this.addWeight("alpha", e, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
      const r = {};
      if (this.sharedAxes != null) for (let i = 1; i < t.length; ++i) r[i] = t[i];
      this.inputSpec = [
        new Xn({
          ndim: t.length,
          axes: r
        })
      ], this.built = true;
    }
    call(t, e) {
      return t = ae(t), tR(t, this.alpha.read());
    }
    getConfig() {
      const t = {
        alphaInitializer: _n(this.alphaInitializer),
        alphaRegularizer: ln(this.alphaRegularizer),
        alphaConstraint: jn(this.alphaConstraint),
        sharedAxes: this.sharedAxes
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  f9.className = "PReLU";
  vt(f9);
  let d9 = class extends Ce {
    constructor(t) {
      if (super(t ?? {}), this.DEFAULT_ALPHA = 1, t == null && (t = {}), t.alpha != null && t.alpha !== this.DEFAULT_ALPHA) throw new me(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);
      this.alpha = t.alpha == null ? this.DEFAULT_ALPHA : t.alpha;
    }
    call(t, e) {
      const r = ae(t);
      return uw(r);
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = {
        alpha: this.alpha
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  };
  d9.className = "ELU";
  vt(d9);
  class p9 extends Ce {
    constructor(t) {
      super(t ?? {}), this.DEFAULT_THETA = 1, t == null && (t = {}), this.theta = t.theta == null ? this.DEFAULT_THETA : t.theta;
    }
    call(t, e) {
      const r = ae(t);
      return j(r, Et(ea(r, this.theta), "float32"));
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = {
        theta: this.theta
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  p9.className = "ThresholdedReLU";
  vt(p9);
  class g9 extends Ce {
    constructor(t) {
      super(t ?? {}), this.DEFAULT_AXIS = 1, t == null && (t = {}), this.softmax = new eN().apply, this.axis = t.axis == null ? this.DEFAULT_AXIS : t.axis;
    }
    call(t, e) {
      return tt(() => {
        let r = ae(t);
        const i = e.mask;
        if (i != null) {
          const a = j(re(du(r.shape), Et(i, r.dtype)), Ue(-1e9));
          r = bt(r, a);
        }
        return this.axis instanceof Array ? this.axis.length > 1 ? ao(re(r, ij(r, this.axis, true))) : this.softmax(r, this.axis[0]) : this.softmax(r, this.axis);
      });
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = {
        axis: this.axis
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  g9.className = "Softmax";
  vt(g9);
  function Ff(n, t, e) {
    if (typeof n == "number") return sh(n, t);
    if (n.length !== t) throw new Y(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);
    for (let r = 0; r < t; ++r) {
      const i = n[r];
      if (!yMt(i)) throw new Y(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`);
    }
    return n;
  }
  function is(n, t, e, r, i = 1) {
    if (n == null) return n;
    const a = t + (t - 1) * (i - 1);
    let s;
    return e === "same" ? s = n : s = n - a + 1, Math.floor((s + r - 1) / r);
  }
  function Ps(n, t, e, r) {
    if (n == null) return null;
    if (r === "valid") n = n * t + eu([
      e - t,
      0
    ]);
    else if (r === "same") n = n * t;
    else throw new Y(`Unsupport padding mode: ${r}.`);
    return n;
  }
  function nN(n, t) {
    return tt(() => (Nn(t), t === "channelsFirst" ? Oe(n, [
      0,
      2,
      3,
      1
    ]) : n));
  }
  function v9(n, t) {
    return tt(() => (Nn(t), t === "channelsFirst" ? Oe(n, [
      0,
      2,
      3,
      4,
      1
    ]) : n));
  }
  function BRt(n, t, e, r = 1, i = "valid", a, s = 1) {
    return tt(() => {
      if (a == null && (a = us()), Nn(a), n.shape.length !== 3) throw new Y(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);
      if (t.shape.length !== 3) throw new Y(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);
      if (e != null && e.shape.length !== 1) throw new Y(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);
      if (a === "channelsFirst" && (n = Oe(n, [
        0,
        2,
        1
      ])), i === "causal") throw new me("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      let o = Yq(n, t, r, i === "same" ? "same" : "valid", "NWC", s);
      return e != null && (o = ps(o, e)), o;
    });
  }
  function EV(n, t, e, r = [
    1,
    1
  ], i = "valid", a, s, o = null) {
    return tt(() => {
      if (a == null && (a = us()), Nn(a), n.rank !== 3 && n.rank !== 4) throw new Y(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);
      if (t.rank !== 3 && t.rank !== 4) throw new Y(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);
      let l = nN(n, a);
      if (i === "causal") throw new me("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      return l = Y2t({
        x: l,
        filter: t,
        strides: r,
        pad: i === "same" ? "same" : "valid",
        dilations: s,
        dataFormat: "NHWC",
        bias: e,
        activation: o
      }), a === "channelsFirst" && (l = Oe(l, [
        0,
        3,
        1,
        2
      ])), l;
    });
  }
  function zRt(n, t, e, r = [
    1,
    1,
    1
  ], i = "valid", a, s) {
    return tt(() => {
      if (a == null && (a = us()), Nn(a), n.rank !== 4 && n.rank !== 5) throw new Y(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);
      if (t.rank !== 4 && t.rank !== 5) throw new Y(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);
      let o = v9(n, a);
      if (i === "causal") throw new me("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
      return o = UTt(o, t, r, i === "same" ? "same" : "valid", "NDHWC", s), e != null && (o = ps(o, e)), a === "channelsFirst" && (o = Oe(o, [
        0,
        4,
        1,
        2,
        3
      ])), o;
    });
  }
  class _w extends Ce {
    constructor(t, e) {
      if (super(e), this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", _w.verifyArgs(e), this.rank = t, sr(this.rank, "rank"), this.rank !== 1 && this.rank !== 2 && this.rank !== 3) throw new me(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
      if (this.kernelSize = Ff(e.kernelSize, t, "kernelSize"), this.strides = Ff(e.strides == null ? 1 : e.strides, t, "strides"), this.padding = e.padding == null ? "valid" : e.padding, na(this.padding), this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, Nn(this.dataFormat), this.activation = ru(e.activation), this.useBias = e.useBias == null ? true : e.useBias, this.biasInitializer = yn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = Kn(e.biasConstraint), this.biasRegularizer = xn(e.biasRegularizer), this.activityRegularizer = xn(e.activityRegularizer), this.dilationRate = Ff(e.dilationRate == null ? 1 : e.dilationRate, t, "dilationRate"), this.rank === 1 && Array.isArray(this.dilationRate) && this.dilationRate.length !== 1) throw new Y(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      if (this.rank === 2) {
        if (typeof this.dilationRate == "number") this.dilationRate = [
          this.dilationRate,
          this.dilationRate
        ];
        else if (this.dilationRate.length !== 2) throw new Y(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      } else if (this.rank === 3) {
        if (typeof this.dilationRate == "number") this.dilationRate = [
          this.dilationRate,
          this.dilationRate,
          this.dilationRate
        ];
        else if (this.dilationRate.length !== 3) throw new Y(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      }
    }
    static verifyArgs(t) {
      if (Ls("kernelSize" in t, "required key 'kernelSize' not in config"), typeof t.kernelSize != "number" && !GR(t.kernelSize, "number", 1, 3)) throw new Y(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`);
    }
    getConfig() {
      const t = {
        kernelSize: this.kernelSize,
        strides: this.strides,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        activation: nu(this.activation),
        useBias: this.useBias,
        biasInitializer: _n(this.biasInitializer),
        biasRegularizer: ln(this.biasRegularizer),
        activityRegularizer: ln(this.activityRegularizer),
        biasConstraint: jn(this.biasConstraint)
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  class zd extends _w {
    constructor(t, e) {
      super(t, e), this.kernel = null, zd.verifyArgs(e), this.filters = e.filters, sr(this.filters, "filters"), this.kernelInitializer = yn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = Kn(e.kernelConstraint), this.kernelRegularizer = xn(e.kernelRegularizer);
    }
    build(t) {
      t = ze(t);
      const e = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[e] == null) throw new Y(`The channel dimension of the input should be defined. Found ${t[e]}`);
      const r = t[e], i = this.kernelSize.concat([
        r,
        this.filters
      ]);
      this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
        this.filters
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [
        {
          ndim: this.rank + 2,
          axes: {
            [e]: r
          }
        }
      ], this.built = true;
    }
    call(t, e) {
      return tt(() => {
        t = ae(t);
        let r;
        const i = this.bias == null ? null : this.bias.read(), a = f7(this.activation.getClassName());
        if (a != null && this.rank === 2) r = EV(t, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate, a);
        else {
          if (this.rank === 1) r = BRt(t, this.kernel.read(), i, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
          else if (this.rank === 2) r = EV(t, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate);
          else if (this.rank === 3) r = zRt(t, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate);
          else throw new me("convolutions greater than 3D are not implemented yet.");
          this.activation != null && (r = this.activation.apply(r));
        }
        return r;
      });
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = [], r = this.dataFormat === "channelsLast" ? t.slice(1, t.length - 1) : t.slice(2);
      for (let a = 0; a < r.length; ++a) {
        const s = is(r[a], this.kernelSize[a], this.padding, this.strides[a], typeof this.dilationRate == "number" ? this.dilationRate : this.dilationRate[a]);
        e.push(s);
      }
      let i = [
        t[0]
      ];
      return this.dataFormat === "channelsLast" ? (i = i.concat(e), i.push(this.filters)) : (i.push(this.filters), i = i.concat(e)), i;
    }
    getConfig() {
      const t = {
        filters: this.filters,
        kernelInitializer: _n(this.kernelInitializer),
        kernelRegularizer: ln(this.kernelRegularizer),
        kernelConstraint: jn(this.kernelConstraint)
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    static verifyArgs(t) {
      if (!("filters" in t) || typeof t.filters != "number" || t.filters < 1) throw new Y(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`);
    }
  }
  class ly extends zd {
    constructor(t) {
      super(2, t), ly.verifyArgs(t);
    }
    getConfig() {
      const t = super.getConfig();
      return delete t.rank, t;
    }
    static verifyArgs(t) {
      if (typeof t.kernelSize != "number" && !GR(t.kernelSize, "number", 1, 2)) throw new Y(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`);
    }
  }
  ly.className = "Conv2D";
  vt(ly);
  class uy extends zd {
    constructor(t) {
      super(3, t), uy.verifyArgs(t);
    }
    getConfig() {
      const t = super.getConfig();
      return delete t.rank, t;
    }
    static verifyArgs(t) {
      if (typeof t.kernelSize != "number" && !(Array.isArray(t.kernelSize) && (t.kernelSize.length === 1 || t.kernelSize.length === 3))) throw new Y(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`);
    }
  }
  uy.className = "Conv3D";
  vt(uy);
  class m9 extends ly {
    constructor(t) {
      if (super(t), this.inputSpec = [
        new Xn({
          ndim: 4
        })
      ], this.padding !== "same" && this.padding !== "valid") throw new Y(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
    }
    build(t) {
      if (t = ze(t), t.length !== 4) throw new Y("Input should have rank 4; Received input shape: " + JSON.stringify(t));
      const e = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[e] == null) throw new Y("The channel dimension of the inputs should be defined. Found `None`.");
      const r = t[e], i = this.kernelSize.concat([
        this.filters,
        r
      ]);
      this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
        this.filters
      ], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [
        new Xn({
          ndim: 4,
          axes: {
            [e]: r
          }
        })
      ], this.built = true;
    }
    call(t, e) {
      return tt(() => {
        let r = ae(t);
        if (r.shape.length !== 4) throw new Y(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);
        const i = r.shape, a = i[0];
        let s, o;
        this.dataFormat === "channelsFirst" ? (s = 2, o = 3) : (s = 1, o = 2);
        const l = i[s], u = i[o], c = this.kernelSize[0], h = this.kernelSize[1], f = this.strides[0], d = this.strides[1], p = Ps(l, f, c, this.padding), g = Ps(u, d, h, this.padding), v = [
          a,
          p,
          g,
          this.filters
        ];
        this.dataFormat !== "channelsLast" && (r = Oe(r, [
          0,
          2,
          3,
          1
        ]));
        let m = qq(r, this.kernel.read(), v, this.strides, this.padding);
        return this.dataFormat !== "channelsLast" && (m = Oe(m, [
          0,
          3,
          1,
          2
        ])), this.bias != null && (m = ps(m, this.bias.read(), this.dataFormat)), this.activation != null && (m = this.activation.apply(m)), m;
      });
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = t.slice();
      let r, i, a;
      this.dataFormat === "channelsFirst" ? (r = 1, i = 2, a = 3) : (r = 3, i = 1, a = 2);
      const s = this.kernelSize[0], o = this.kernelSize[1], l = this.strides[0], u = this.strides[1];
      return e[r] = this.filters, e[i] = Ps(e[i], l, s, this.padding), e[a] = Ps(e[a], u, o, this.padding), e;
    }
    getConfig() {
      const t = super.getConfig();
      return delete t.dilationRate, t;
    }
  }
  m9.className = "Conv2DTranspose";
  vt(m9);
  class y9 extends uy {
    constructor(t) {
      if (super(t), this.inputSpec = [
        new Xn({
          ndim: 5
        })
      ], this.padding !== "same" && this.padding !== "valid") throw new Y(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
    }
    build(t) {
      if (t = ze(t), t.length !== 5) throw new Y("Input should have rank 5; Received input shape: " + JSON.stringify(t));
      const e = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[e] == null) throw new Y("The channel dimension of the inputs should be defined. Found `None`.");
      const r = t[e], i = this.kernelSize.concat([
        this.filters,
        r
      ]);
      this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
        this.filters
      ], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [
        new Xn({
          ndim: 5,
          axes: {
            [e]: r
          }
        })
      ], this.built = true;
    }
    call(t, e) {
      return tt(() => {
        let r = ae(t);
        if (r.shape.length !== 5) throw new Y(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);
        const i = r.shape, a = i[0];
        let s, o, l;
        this.dataFormat === "channelsFirst" ? (l = 2, s = 3, o = 4) : (l = 1, s = 2, o = 3);
        const u = i[l], c = i[s], h = i[o], f = this.kernelSize[0], d = this.kernelSize[1], p = this.kernelSize[2], g = this.strides[0], v = this.strides[1], m = this.strides[2], y = Ps(u, g, f, this.padding), x = Ps(c, v, d, this.padding), b = Ps(h, m, p, this.padding), _ = [
          a,
          y,
          x,
          b,
          this.filters
        ];
        this.dataFormat !== "channelsLast" && (r = Oe(r, [
          0,
          2,
          3,
          4,
          1
        ]));
        let w = YTt(r, this.kernel.read(), _, this.strides, this.padding);
        return this.dataFormat !== "channelsLast" && (w = Oe(w, [
          0,
          4,
          1,
          2,
          3
        ])), this.bias !== null && (w = ps(w, this.bias.read(), this.dataFormat)), this.activation !== null && (w = this.activation.apply(w)), w;
      });
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = t.slice();
      let r, i, a, s;
      this.dataFormat === "channelsFirst" ? (r = 1, i = 2, a = 3, s = 4) : (r = 4, i = 1, a = 2, s = 3);
      const o = this.kernelSize[0], l = this.kernelSize[1], u = this.kernelSize[2], c = this.strides[0], h = this.strides[1], f = this.strides[2];
      return e[r] = this.filters, e[i] = Ps(e[i], c, o, this.padding), e[a] = Ps(e[a], h, l, this.padding), e[s] = Ps(e[s], f, u, this.padding), e;
    }
    getConfig() {
      const t = super.getConfig();
      return delete t.dilationRate, t;
    }
  }
  y9.className = "Conv3DTranspose";
  vt(y9);
  class x9 extends zd {
    constructor(t, e) {
      if (super(t, e), this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, e.filters == null) throw new Y("The `filters` configuration field is required by SeparableConv, but is unspecified.");
      if (e.kernelInitializer != null || e.kernelRegularizer != null || e.kernelConstraint != null) throw new Y("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
      if (e.padding != null && e.padding !== "same" && e.padding !== "valid") throw new Y(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);
      this.depthMultiplier = e.depthMultiplier == null ? 1 : e.depthMultiplier, this.depthwiseInitializer = yn(e.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = xn(e.depthwiseRegularizer), this.depthwiseConstraint = Kn(e.depthwiseConstraint), this.pointwiseInitializer = yn(e.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = xn(e.pointwiseRegularizer), this.pointwiseConstraint = Kn(e.pointwiseConstraint);
    }
    build(t) {
      if (t = ze(t), t.length < this.rank + 2) throw new Y(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(t)}`);
      const e = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[e] == null || t[e] < 0) throw new Y(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);
      const r = t[e], i = this.kernelSize.concat([
        r,
        this.depthMultiplier
      ]), a = [];
      for (let o = 0; o < this.rank; ++o) a.push(1);
      a.push(r * this.depthMultiplier, this.filters);
      const s = true;
      this.depthwiseKernel = this.addWeight("depthwise_kernel", i, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, s, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", a, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, s, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [
        this.filters
      ], "float32", this.biasInitializer, this.biasRegularizer, s, this.biasConstraint) : this.bias = null, this.inputSpec = [
        new Xn({
          ndim: this.rank + 2,
          axes: {
            [e]: r
          }
        })
      ], this.built = true;
    }
    call(t, e) {
      return tt(() => {
        t = ae(t);
        let r;
        if (this.rank === 1) throw new me("1D separable convolution is not implemented yet.");
        return this.rank === 2 && (this.dataFormat === "channelsFirst" && (t = Oe(t, [
          0,
          2,
          3,
          1
        ])), r = fj(t, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (r = ps(r, this.bias.read(), this.dataFormat)), this.activation != null && (r = this.activation.apply(r)), this.dataFormat === "channelsFirst" && (r = Oe(r, [
          0,
          3,
          1,
          2
        ])), r;
      });
    }
    getConfig() {
      const t = super.getConfig();
      return delete t.rank, delete t.kernelInitializer, delete t.kernelRegularizer, delete t.kernelConstraint, t.depthwiseInitializer = _n(this.depthwiseInitializer), t.pointwiseInitializer = _n(this.pointwiseInitializer), t.depthwiseRegularizer = ln(this.depthwiseRegularizer), t.pointwiseRegularizer = ln(this.pointwiseRegularizer), t.depthwiseConstraint = jn(this.depthwiseConstraint), t.pointwiseConstraint = jn(this.pointwiseConstraint), t;
    }
  }
  x9.className = "SeparableConv";
  class b9 extends x9 {
    constructor(t) {
      super(2, t);
    }
  }
  b9.className = "SeparableConv2D";
  vt(b9);
  class ww extends zd {
    constructor(t) {
      super(1, t), ww.verifyArgs(t), this.inputSpec = [
        {
          ndim: 3
        }
      ];
    }
    getConfig() {
      const t = super.getConfig();
      return delete t.rank, delete t.dataFormat, t;
    }
    static verifyArgs(t) {
      if (typeof t.kernelSize != "number" && !GR(t.kernelSize, "number", 1, 1)) throw new Y(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`);
    }
  }
  ww.className = "Conv1D";
  vt(ww);
  class _9 extends Ce {
    constructor(t) {
      super(t), typeof t.cropping == "number" ? this.cropping = [
        [
          t.cropping,
          t.cropping
        ],
        [
          t.cropping,
          t.cropping
        ]
      ] : typeof t.cropping[0] == "number" ? this.cropping = [
        [
          t.cropping[0],
          t.cropping[0]
        ],
        [
          t.cropping[1],
          t.cropping[1]
        ]
      ] : this.cropping = t.cropping, this.dataFormat = t.dataFormat === void 0 ? "channelsLast" : t.dataFormat, this.inputSpec = [
        {
          ndim: 4
        }
      ];
    }
    computeOutputShape(t) {
      return this.dataFormat === "channelsFirst" ? [
        t[0],
        t[1],
        t[2] - this.cropping[0][0] - this.cropping[0][1],
        t[3] - this.cropping[1][0] - this.cropping[1][1]
      ] : [
        t[0],
        t[1] - this.cropping[0][0] - this.cropping[0][1],
        t[2] - this.cropping[1][0] - this.cropping[1][1],
        t[3]
      ];
    }
    call(t, e) {
      return tt(() => {
        if (t = ae(t), this.dataFormat === "channelsLast") {
          const r = T0(t, this.cropping[0][0], t.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
          return T0(r, this.cropping[1][0], t.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
        } else {
          const r = T0(t, this.cropping[0][0], t.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
          return T0(r, this.cropping[1][0], t.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
        }
      });
    }
    getConfig() {
      const t = {
        cropping: this.cropping,
        dataFormat: this.dataFormat
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  _9.className = "Cropping2D";
  vt(_9);
  class w9 extends Ce {
    constructor(t) {
      super(t), this.DEFAULT_SIZE = [
        2,
        2
      ], this.inputSpec = [
        {
          ndim: 4
        }
      ], this.size = t.size == null ? this.DEFAULT_SIZE : t.size, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, Nn(this.dataFormat), this.interpolation = t.interpolation == null ? "nearest" : t.interpolation, gMt(this.interpolation);
    }
    computeOutputShape(t) {
      if (this.dataFormat === "channelsFirst") {
        const e = t[2] == null ? null : this.size[0] * t[2], r = t[3] == null ? null : this.size[1] * t[3];
        return [
          t[0],
          t[1],
          e,
          r
        ];
      } else {
        const e = t[1] == null ? null : this.size[0] * t[1], r = t[2] == null ? null : this.size[1] * t[2];
        return [
          t[0],
          e,
          r,
          t[3]
        ];
      }
    }
    call(t, e) {
      return tt(() => {
        let r = ae(t);
        const i = r.shape;
        if (this.dataFormat === "channelsFirst") {
          r = Oe(r, [
            0,
            2,
            3,
            1
          ]);
          const a = this.size[0] * i[2], s = this.size[1] * i[3], o = this.interpolation === "nearest" ? Ao.resizeNearestNeighbor(r, [
            a,
            s
          ]) : Ao.resizeBilinear(r, [
            a,
            s
          ]);
          return Oe(o, [
            0,
            3,
            1,
            2
          ]);
        } else {
          const a = this.size[0] * i[1], s = this.size[1] * i[2];
          return this.interpolation === "nearest" ? Ao.resizeNearestNeighbor(r, [
            a,
            s
          ]) : Ao.resizeBilinear(r, [
            a,
            s
          ]);
        }
      });
    }
    getConfig() {
      const t = {
        size: this.size,
        dataFormat: this.dataFormat,
        interpolation: this.interpolation
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  w9.className = "UpSampling2D";
  vt(w9);
  function VRt(n, t, e = [
    1,
    1
  ], r = "valid", i, a) {
    return tt(() => {
      i == null && (i = us()), Nn(i);
      let s = nN(n, i);
      if (n.rank !== 4) throw new Y(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);
      if (t.rank !== 4) throw new Y(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);
      return s = UM(s, t, e, r === "same" ? "same" : "valid", "NHWC", a), i === "channelsFirst" && (s = Oe(s, [
        0,
        3,
        1,
        2
      ])), s;
    });
  }
  class S9 extends _w {
    constructor(t) {
      super(2, t), this.depthwiseKernel = null, this.depthMultiplier = t.depthMultiplier == null ? 1 : t.depthMultiplier, this.depthwiseInitializer = yn(t.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = Kn(t.depthwiseConstraint), this.depthwiseRegularizer = xn(t.depthwiseRegularizer);
    }
    build(t) {
      if (t = ze(t), t.length < 4) throw new Y(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);
      const e = this.dataFormat === "channelsFirst" ? 1 : 3;
      if (t[e] == null || t[e] < 0) throw new Y(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);
      const r = t[e], i = [
        this.kernelSize[0],
        this.kernelSize[1],
        r,
        this.depthMultiplier
      ];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", i, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [
        r * this.depthMultiplier
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(t, e) {
      return tt(() => {
        t = ae(t);
        let r = VRt(t, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
        return this.useBias && (r = ps(r, this.bias.read(), this.dataFormat)), this.activation != null && (r = this.activation.apply(r)), r;
      });
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = this.dataFormat === "channelsFirst" ? t[2] : t[1], r = this.dataFormat === "channelsFirst" ? t[3] : t[2], i = this.dataFormat === "channelsFirst" ? t[1] * this.depthMultiplier : t[3] * this.depthMultiplier, a = is(e, this.kernelSize[0], this.padding, this.strides[0]), s = is(r, this.kernelSize[1], this.padding, this.strides[1]);
      return this.dataFormat === "channelsFirst" ? [
        t[0],
        i,
        a,
        s
      ] : [
        t[0],
        a,
        s,
        i
      ];
    }
    getConfig() {
      const t = super.getConfig();
      return t.depthMultiplier = this.depthMultiplier, t.depthwiseInitializer = _n(this.depthwiseInitializer), t.depthwiseRegularizer = ln(this.depthwiseRegularizer), t.depthwiseConstraint = jn(this.depthwiseRegularizer), t;
    }
  }
  S9.className = "DepthwiseConv2D";
  vt(S9);
  function C9(n, t, e, r) {
    if (Array.isArray(n)) {
      if (t != null || e != null) throw new Y("When inputs is an array, neither initialState or constants should be provided");
      r != null && (e = n.slice(n.length - r, n.length), n = n.slice(0, n.length - r)), n.length > 1 && (t = n.slice(1, n.length)), n = n[0];
    }
    function i(a) {
      return a == null || Array.isArray(a) ? a : [
        a
      ];
    }
    return t = i(t), e = i(e), {
      inputs: n,
      initialState: t,
      constants: e
    };
  }
  function T9(n, t, e, r = false, i, a, s = false, o = false) {
    return tt(() => {
      const l = t.shape.length;
      if (l < 3) throw new Y(`Input should be at least 3D, but is ${l}D.`);
      const u = [
        1,
        0
      ].concat(ls(2, l));
      t = Oe(t, u), s && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), i != null && (i = Et(Et(i, "bool"), "float32"), i.rank === l - 1 && (i = li(i, -1)), i = Oe(i, u)), r && (t = ih(t, 0), i != null && (i = ih(i, 0)));
      const c = [];
      let h, f = e;
      const d = t.shape[0], p = ah(t);
      let g;
      i != null && (g = ah(i));
      for (let m = 0; m < d; ++m) {
        const y = p[m], x = tt(() => n(y, f));
        if (i == null) h = x[0], f = x[1];
        else {
          const b = tt(() => {
            const _ = g[m], w = re(ka(_), _), S = bt(j(x[0], _), j(f[0], w)), I = f.map((T, A) => bt(j(x[1][A], _), j(T, w)));
            return {
              output: S,
              newStates: I
            };
          });
          h = b.output, f = b.newStates;
        }
        o && c.push(h);
      }
      let v;
      return o && (v = jo(c, 1)), [
        h,
        v,
        f
      ];
    });
  }
  class gu extends Ce {
    constructor(t) {
      super(t);
      let e;
      if (t.cell == null) throw new Y("cell property is missing for the constructor of RNN.");
      if (Array.isArray(t.cell) ? e = new aN({
        cells: t.cell
      }) : e = t.cell, e.stateSize == null) throw new Y("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
      this.cell = e, this.returnSequences = t.returnSequences == null ? false : t.returnSequences, this.returnState = t.returnState == null ? false : t.returnState, this.goBackwards = t.goBackwards == null ? false : t.goBackwards, this._stateful = t.stateful == null ? false : t.stateful, this.unroll = t.unroll == null ? false : t.unroll, this.supportsMasking = true, this.inputSpec = [
        new Xn({
          ndim: 3
        })
      ], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = [];
    }
    getStates() {
      if (this.states_ == null) {
        const t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        return ls(0, t).map((e) => null);
      } else return this.states_;
    }
    setStates(t) {
      this.states_ = t;
    }
    computeOutputShape(t) {
      $2(t) && (t = t[0]), t = t;
      let e = this.cell.stateSize;
      Array.isArray(e) || (e = [
        e
      ]);
      const r = e[0];
      let i;
      if (this.returnSequences ? i = [
        t[0],
        t[1],
        r
      ] : i = [
        t[0],
        r
      ], this.returnState) {
        const a = [];
        for (const s of e) a.push([
          t[0],
          s
        ]);
        return [
          i
        ].concat(a);
      } else return i;
    }
    computeMask(t, e) {
      return tt(() => {
        Array.isArray(e) && (e = e[0]);
        const r = this.returnSequences ? e : null;
        if (this.returnState) {
          const i = this.states.map((a) => null);
          return [
            r
          ].concat(i);
        } else return r;
      });
    }
    get states() {
      if (this.states_ == null) {
        const t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, e = [];
        for (let r = 0; r < t; ++r) e.push(null);
        return e;
      } else return this.states_;
    }
    set states(t) {
      this.states_ = t;
    }
    build(t) {
      if (this.numConstants != null) throw new me("Constants support is not implemented in RNN yet.");
      $2(t) && (t = t[0]), t = t;
      const e = this.stateful ? t[0] : null, r = t.slice(2);
      this.inputSpec[0] = new Xn({
        shape: [
          e,
          null,
          ...r
        ]
      });
      const i = [
        t[0]
      ].concat(t.slice(2));
      this.cell.build(i);
      let a;
      if (Array.isArray(this.cell.stateSize) ? a = this.cell.stateSize : a = [
        this.cell.stateSize
      ], this.stateSpec != null) {
        if (!Xe(this.stateSpec.map((s) => s.shape[s.shape.length - 1]), a)) throw new Y(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
      } else this.stateSpec = a.map((s) => new Xn({
        shape: [
          null,
          s
        ]
      }));
      this.stateful && this.resetStates();
    }
    resetStates(t, e = false) {
      tt(() => {
        if (!this.stateful) throw new Ns("Cannot call resetStates() on an RNN Layer that is not stateful.");
        const r = this.inputSpec[0].shape[0];
        if (r == null) throw new Y("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (this.states_ == null) Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((i) => rr([
          r,
          i
        ])) : this.states_ = [
          rr([
            r,
            this.cell.stateSize
          ])
        ];
        else if (t == null) Te(this.states_), this.keptStates != null && (Te(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((i) => rr([
          r,
          i
        ])) : this.states_[0] = rr([
          r,
          this.cell.stateSize
        ]);
        else {
          if (Array.isArray(t) || (t = [
            t
          ]), t.length !== this.states_.length) throw new Y(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);
          e === true ? this.keptStates.push(this.states_.slice()) : Te(this.states_);
          for (let i = 0; i < this.states_.length; ++i) {
            const a = t[i], s = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[i] : this.cell.stateSize, o = [
              r,
              s
            ];
            if (!Xe(a.shape, o)) throw new Y(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);
            this.states_[i] = a;
          }
        }
        this.states_ = this.states_.map((i) => qs(i.clone()));
      });
    }
    apply(t, e) {
      let r = e == null ? null : e.initialState, i = e == null ? null : e.constants;
      e == null && (e = {});
      const a = C9(t, r, i, this.numConstants);
      t = a.inputs, r = a.initialState, i = a.constants;
      let s = [], o = [];
      if (r != null) {
        e.initialState = r, s = s.concat(r), this.stateSpec = [];
        for (const u of r) this.stateSpec.push(new Xn({
          shape: u.shape
        }));
        o = o.concat(this.stateSpec);
      }
      if (i != null && (e.constants = i, s = s.concat(i), this.numConstants = i.length), s[0] instanceof oo) {
        const u = [
          t
        ].concat(s), c = this.inputSpec.concat(o), h = this.inputSpec;
        this.inputSpec = c;
        const f = super.apply(u, e);
        return this.inputSpec = h, f;
      } else return super.apply(t, e);
    }
    call(t, e) {
      return tt(() => {
        const r = e == null ? null : e.mask, i = e == null ? null : e.training;
        let a = e == null ? null : e.initialState;
        t = ae(t), a == null && (this.stateful ? a = this.states_ : a = this.getInitialState(t));
        const s = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        if (a.length !== s) throw new Y(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);
        this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
        const o = {
          training: i
        }, u = T9((p, g) => {
          const v = this.cell.call([
            p
          ].concat(g), o);
          return [
            v[0],
            v.slice(1)
          ];
        }, t, a, this.goBackwards, r, null, this.unroll, this.returnSequences), c = u[0], h = u[1], f = u[2];
        this.stateful && this.resetStates(f, i);
        const d = this.returnSequences ? h : c;
        return this.returnState ? [
          d
        ].concat(f) : d;
      });
    }
    getInitialState(t) {
      return tt(() => {
        let e = rr(t.shape);
        return e = Kt(e, [
          1,
          2
        ]), e = ry(e), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map((r) => r > 1 ? L2(e, [
          1,
          r
        ]) : e) : this.cell.stateSize > 1 ? [
          L2(e, [
            1,
            this.cell.stateSize
          ])
        ] : [
          e
        ];
      });
    }
    get trainableWeights() {
      return this.trainable ? this.cell.trainableWeights : [];
    }
    get nonTrainableWeights() {
      return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
    }
    setFastWeightInitDuringBuild(t) {
      super.setFastWeightInitDuringBuild(t), this.cell != null && this.cell.setFastWeightInitDuringBuild(t);
    }
    getConfig() {
      const t = super.getConfig(), e = {
        returnSequences: this.returnSequences,
        returnState: this.returnState,
        goBackwards: this.goBackwards,
        stateful: this.stateful,
        unroll: this.unroll
      };
      this.numConstants != null && (e.numConstants = this.numConstants);
      const r = this.cell.getConfig();
      return this.getClassName() === gu.className && (e.cell = {
        className: this.cell.getClassName(),
        config: r
      }), Object.assign(Object.assign(Object.assign({}, r), t), e);
    }
    static fromConfig(t, e, r = {}) {
      const i = e.cell, a = $o(i, r);
      return new t(Object.assign(e, {
        cell: a
      }));
    }
  }
  gu.className = "RNN";
  vt(gu);
  class Sw extends Ce {
  }
  class rN extends Sw {
    constructor(t) {
      super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = t.units, sr(this.units, "units"), this.activation = ru(t.activation == null ? this.DEFAULT_ACTIVATION : t.activation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = yn(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = yn(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = yn(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = xn(t.kernelRegularizer), this.recurrentRegularizer = xn(t.recurrentRegularizer), this.biasRegularizer = xn(t.biasRegularizer), this.kernelConstraint = Kn(t.kernelConstraint), this.recurrentConstraint = Kn(t.recurrentConstraint), this.biasConstraint = Kn(t.biasConstraint), this.dropout = rd([
        1,
        eu([
          0,
          t.dropout == null ? 0 : t.dropout
        ])
      ]), this.recurrentDropout = rd([
        1,
        eu([
          0,
          t.recurrentDropout == null ? 0 : t.recurrentDropout
        ])
      ]), this.dropoutFunc = t.dropoutFunc, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(t) {
      t = ze(t), this.kernel = this.addWeight("kernel", [
        t[t.length - 1],
        this.units
      ], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
        this.units,
        this.units
      ], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [
        this.units
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(t, e) {
      return tt(() => {
        if (t = t, t.length !== 2) throw new Y(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);
        let r = t[1];
        t = t[0];
        const i = e.training == null ? false : e.training;
        0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = iu({
          ones: () => ka(t),
          rate: this.dropout,
          training: i,
          dropoutFunc: this.dropoutFunc
        })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = iu({
          ones: () => ka(r),
          rate: this.recurrentDropout,
          training: i,
          dropoutFunc: this.dropoutFunc
        }));
        let a;
        const s = this.dropoutMask, o = this.recurrentDropoutMask;
        s != null ? a = Zs(j(t, s), this.kernel.read()) : a = Zs(t, this.kernel.read()), this.bias != null && (a = ps(a, this.bias.read())), o != null && (r = j(r, o));
        let l = bt(a, Zs(r, this.recurrentKernel.read()));
        return this.activation != null && (l = this.activation.apply(l)), [
          l,
          l
        ];
      });
    }
    getConfig() {
      const t = super.getConfig(), e = {
        units: this.units,
        activation: nu(this.activation),
        useBias: this.useBias,
        kernelInitializer: _n(this.kernelInitializer),
        recurrentInitializer: _n(this.recurrentInitializer),
        biasInitializer: _n(this.biasInitializer),
        kernelRegularizer: ln(this.kernelRegularizer),
        recurrentRegularizer: ln(this.recurrentRegularizer),
        biasRegularizer: ln(this.biasRegularizer),
        activityRegularizer: ln(this.activityRegularizer),
        kernelConstraint: jn(this.kernelConstraint),
        recurrentConstraint: jn(this.recurrentConstraint),
        biasConstraint: jn(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout
      };
      return Object.assign(Object.assign({}, t), e);
    }
  }
  rN.className = "SimpleRNNCell";
  vt(rN);
  class I9 extends gu {
    constructor(t) {
      t.cell = new rN(t), super(t);
    }
    call(t, e) {
      return tt(() => {
        this.cell.dropoutMask != null && (Te(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Te(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        const r = e == null ? null : e.mask, i = e == null ? null : e.training, a = e == null ? null : e.initialState;
        return super.call(t, {
          mask: r,
          training: i,
          initialState: a
        });
      });
    }
    static fromConfig(t, e) {
      return new t(e);
    }
  }
  I9.className = "SimpleRNN";
  vt(I9);
  class iN extends Sw {
    constructor(t) {
      if (super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", t.resetAfter) throw new Y("GRUCell does not support reset_after parameter set to true.");
      this.units = t.units, sr(this.units, "units"), this.activation = ru(t.activation === void 0 ? this.DEFAULT_ACTIVATION : t.activation), this.recurrentActivation = ru(t.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = yn(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = yn(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = yn(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = xn(t.kernelRegularizer), this.recurrentRegularizer = xn(t.recurrentRegularizer), this.biasRegularizer = xn(t.biasRegularizer), this.kernelConstraint = Kn(t.kernelConstraint), this.recurrentConstraint = Kn(t.recurrentConstraint), this.biasConstraint = Kn(t.biasConstraint), this.dropout = rd([
        1,
        eu([
          0,
          t.dropout == null ? 0 : t.dropout
        ])
      ]), this.recurrentDropout = rd([
        1,
        eu([
          0,
          t.recurrentDropout == null ? 0 : t.recurrentDropout
        ])
      ]), this.dropoutFunc = t.dropoutFunc, this.implementation = t.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(t) {
      t = ze(t);
      const e = t[t.length - 1];
      this.kernel = this.addWeight("kernel", [
        e,
        this.units * 3
      ], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
        this.units,
        this.units * 3
      ], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [
        this.units * 3
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(t, e) {
      return tt(() => {
        if (t = t, t.length !== 2) throw new Y(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);
        const r = e.training == null ? false : e.training;
        let i = t[1];
        t = t[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = iu({
          ones: () => ka(t),
          rate: this.dropout,
          training: r,
          count: 3,
          dropoutFunc: this.dropoutFunc
        })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = iu({
          ones: () => ka(i),
          rate: this.recurrentDropout,
          training: r,
          count: 3,
          dropoutFunc: this.dropoutFunc
        }));
        const a = this.dropoutMask, s = this.recurrentDropoutMask;
        let o, l, u;
        0 < this.dropout && this.dropout < 1 && (t = j(t, a[0]));
        let c = Zs(t, this.kernel.read());
        this.useBias && (c = ps(c, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (i = j(i, s[0]));
        const h = this.recurrentKernel.read(), [f, d] = ji(h, [
          2 * this.units,
          this.units
        ], h.rank - 1), p = Zs(i, f), [g, v, m] = ji(c, 3, c.rank - 1), [y, x] = ji(p, 2, p.rank - 1);
        o = this.recurrentActivation.apply(bt(g, y)), l = this.recurrentActivation.apply(bt(v, x));
        const b = Zs(j(l, i), d);
        u = this.activation.apply(bt(m, b));
        const _ = bt(j(o, i), j(bt(1, En(o)), u));
        return [
          _,
          _
        ];
      });
    }
    getConfig() {
      const t = super.getConfig(), e = {
        units: this.units,
        activation: nu(this.activation),
        recurrentActivation: nu(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: _n(this.kernelInitializer),
        recurrentInitializer: _n(this.recurrentInitializer),
        biasInitializer: _n(this.biasInitializer),
        kernelRegularizer: ln(this.kernelRegularizer),
        recurrentRegularizer: ln(this.recurrentRegularizer),
        biasRegularizer: ln(this.biasRegularizer),
        activityRegularizer: ln(this.activityRegularizer),
        kernelConstraint: jn(this.kernelConstraint),
        recurrentConstraint: jn(this.recurrentConstraint),
        biasConstraint: jn(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation,
        resetAfter: false
      };
      return Object.assign(Object.assign({}, t), e);
    }
  }
  iN.className = "GRUCell";
  vt(iN);
  class A9 extends gu {
    constructor(t) {
      t.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new iN(t), super(t);
    }
    call(t, e) {
      return tt(() => {
        this.cell.dropoutMask != null && (Te(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Te(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        const r = e == null ? null : e.mask, i = e == null ? null : e.training, a = e == null ? null : e.initialState;
        return super.call(t, {
          mask: r,
          training: i,
          initialState: a
        });
      });
    }
    static fromConfig(t, e) {
      return e.implmentation === 0 && (e.implementation = 1), new t(e);
    }
  }
  A9.className = "GRU";
  vt(A9);
  class Cw extends Sw {
    constructor(t) {
      super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = t.units, sr(this.units, "units"), this.activation = ru(t.activation === void 0 ? this.DEFAULT_ACTIVATION : t.activation), this.recurrentActivation = ru(t.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = yn(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = yn(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = yn(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = t.unitForgetBias, this.kernelRegularizer = xn(t.kernelRegularizer), this.recurrentRegularizer = xn(t.recurrentRegularizer), this.biasRegularizer = xn(t.biasRegularizer), this.kernelConstraint = Kn(t.kernelConstraint), this.recurrentConstraint = Kn(t.recurrentConstraint), this.biasConstraint = Kn(t.biasConstraint), this.dropout = rd([
        1,
        eu([
          0,
          t.dropout == null ? 0 : t.dropout
        ])
      ]), this.recurrentDropout = rd([
        1,
        eu([
          0,
          t.recurrentDropout == null ? 0 : t.recurrentDropout
        ])
      ]), this.dropoutFunc = t.dropoutFunc, this.implementation = t.implementation, this.stateSize = [
        this.units,
        this.units
      ], this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(t) {
      var e;
      t = ze(t);
      const r = t[t.length - 1];
      this.kernel = this.addWeight("kernel", [
        r,
        this.units * 4
      ], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
        this.units,
        this.units * 4
      ], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      let i;
      if (this.useBias) {
        if (this.unitForgetBias) {
          const a = this.biasInitializer, s = this.units;
          i = new (e = class extends Na {
            apply(l, u) {
              const c = a.apply([
                s
              ]), h = new UR().apply([
                s
              ]), f = a.apply([
                s * 2
              ]);
              return dV(dV(c, h), f);
            }
          }, e.className = "CustomInit", e)();
        } else i = this.biasInitializer;
        this.bias = this.addWeight("bias", [
          this.units * 4
        ], null, i, this.biasRegularizer, true, this.biasConstraint);
      } else this.bias = null;
      this.built = true;
    }
    call(t, e) {
      return tt(() => {
        const r = e.training == null ? false : e.training;
        if (t = t, t.length !== 3) throw new Y(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);
        let i = t[1];
        const a = t[2];
        t = t[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = iu({
          ones: () => ka(t),
          rate: this.dropout,
          training: r,
          count: 4,
          dropoutFunc: this.dropoutFunc
        })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = iu({
          ones: () => ka(i),
          rate: this.recurrentDropout,
          training: r,
          count: 4,
          dropoutFunc: this.dropoutFunc
        }));
        const s = this.dropoutMask, o = this.recurrentDropoutMask;
        let l, u, c, h;
        0 < this.dropout && this.dropout < 1 && (t = j(t, s[0]));
        let f = Zs(t, this.kernel.read());
        0 < this.recurrentDropout && this.recurrentDropout < 1 && (i = j(i, o[0])), f = bt(f, Zs(i, this.recurrentKernel.read())), this.useBias && (f = ps(f, this.bias.read()));
        const [d, p, g, v] = ji(f, 4, f.rank - 1);
        l = this.recurrentActivation.apply(d), u = this.recurrentActivation.apply(p), c = bt(j(u, a), j(l, this.activation.apply(g))), h = this.recurrentActivation.apply(v);
        const m = j(h, this.activation.apply(c));
        return [
          m,
          m,
          c
        ];
      });
    }
    getConfig() {
      const t = super.getConfig(), e = {
        units: this.units,
        activation: nu(this.activation),
        recurrentActivation: nu(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: _n(this.kernelInitializer),
        recurrentInitializer: _n(this.recurrentInitializer),
        biasInitializer: _n(this.biasInitializer),
        unitForgetBias: this.unitForgetBias,
        kernelRegularizer: ln(this.kernelRegularizer),
        recurrentRegularizer: ln(this.recurrentRegularizer),
        biasRegularizer: ln(this.biasRegularizer),
        activityRegularizer: ln(this.activityRegularizer),
        kernelConstraint: jn(this.kernelConstraint),
        recurrentConstraint: jn(this.recurrentConstraint),
        biasConstraint: jn(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
      };
      return Object.assign(Object.assign({}, t), e);
    }
  }
  Cw.className = "LSTMCell";
  vt(Cw);
  class k9 extends gu {
    constructor(t) {
      t.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new Cw(t), super(t);
    }
    call(t, e) {
      return tt(() => {
        this.cell.dropoutMask != null && (Te(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Te(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        const r = e == null ? null : e.mask, i = e == null ? null : e.training, a = e == null ? null : e.initialState;
        return super.call(t, {
          mask: r,
          training: i,
          initialState: a
        });
      });
    }
    static fromConfig(t, e) {
      return e.implmentation === 0 && (e.implementation = 1), new t(e);
    }
  }
  k9.className = "LSTM";
  vt(k9);
  class aN extends Sw {
    constructor(t) {
      super(t), this.cells = t.cells;
    }
    get stateSize() {
      const t = [];
      for (const e of this.cells.slice().reverse()) Array.isArray(e.stateSize) ? t.push(...e.stateSize) : t.push(e.stateSize);
      return t;
    }
    call(t, e) {
      return tt(() => {
        t = t;
        let r = t.slice(1);
        const i = [];
        for (const o of this.cells.slice().reverse()) Array.isArray(o.stateSize) ? i.push(r.splice(0, o.stateSize.length)) : i.push(r.splice(0, 1));
        i.reverse();
        const a = [];
        let s;
        for (let o = 0; o < this.cells.length; ++o) {
          const l = this.cells[o];
          r = i[o], o === 0 ? s = [
            t[0]
          ].concat(r) : s = [
            s[0]
          ].concat(r), s = l.call(s, e), a.push(s.slice(1));
        }
        r = [];
        for (const o of a.slice().reverse()) r.push(...o);
        return [
          s[0]
        ].concat(r);
      });
    }
    build(t) {
      $2(t) && (t = t[0]), t = t;
      let e;
      this.cells.forEach((r, i) => {
        zc(`RNNCell_${i}`, () => {
          r.build(t), Array.isArray(r.stateSize) ? e = r.stateSize[0] : e = r.stateSize, t = [
            t[0],
            e
          ];
        });
      }), this.built = true;
    }
    getConfig() {
      const t = super.getConfig(), e = (a) => ({
        className: a.getClassName(),
        config: a.getConfig()
      }), i = {
        cells: this.cells.map(e)
      };
      return Object.assign(Object.assign({}, t), i);
    }
    static fromConfig(t, e, r = {}) {
      const i = [];
      for (const a of e.cells) i.push($o(a, r));
      return new t({
        cells: i
      });
    }
    get trainableWeights() {
      if (!this.trainable) return [];
      const t = [];
      for (const e of this.cells) t.push(...e.trainableWeights);
      return t;
    }
    get nonTrainableWeights() {
      const t = [];
      for (const e of this.cells) t.push(...e.nonTrainableWeights);
      if (!this.trainable) {
        const e = [];
        for (const r of this.cells) e.push(...r.trainableWeights);
        return e.concat(t);
      }
      return t;
    }
    getWeights() {
      const t = [];
      for (const e of this.cells) t.push(...e.weights);
      return O2(t);
    }
    setWeights(t) {
      const e = [];
      for (const r of this.cells) {
        const i = r.weights.length, a = t.splice(i);
        for (let s = 0; s < r.weights.length; ++s) e.push([
          r.weights[s],
          a[s]
        ]);
      }
      ZR(e);
    }
  }
  aN.className = "StackedRNNCells";
  vt(aN);
  function iu(n) {
    const { ones: t, rate: e, training: r = false, count: i = 1, dropoutFunc: a } = n, s = () => a != null ? a(t(), e) : x7(t(), e), o = () => ay(s, t, r);
    return !i || i <= 1 ? qs(o().clone()) : Array(i).fill(void 0).map(o).map((u) => qs(u.clone()));
  }
  var GRt = function(n, t) {
    var e = {};
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && t.indexOf(r) < 0 && (e[r] = n[r]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (e[r[i]] = n[r[i]]);
    return e;
  };
  class D9 extends gu {
    constructor(t) {
      if (t.unroll) throw new me("Unrolling is not possible with convolutional RNNs.");
      if (Array.isArray(t.cell)) throw new me("It is not possible at the moment to stack convolutional cells.");
      super(t), this.inputSpec = [
        new Xn({
          ndim: 5
        })
      ];
    }
    call(t, e) {
      return tt(() => {
        if (this.cell.dropoutMask != null && (Te(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (Te(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), e && e.constants) throw new Y("ConvRNN2D cell does not support constants");
        const r = e == null ? null : e.mask, i = e == null ? null : e.training, a = e == null ? null : e.initialState;
        return super.call(t, {
          mask: r,
          training: i,
          initialState: a
        });
      });
    }
    computeOutputShape(t) {
      let e = this.computeSingleOutputShape(t);
      return this.returnSequences || (e = [
        e[0],
        ...e.slice(2)
      ]), this.returnState && (e = [
        e,
        ...Array(2).fill([
          t[0],
          ...e.slice(-3)
        ])
      ]), e;
    }
    getInitialState(t) {
      return tt(() => {
        const { stateSize: e } = this.cell, r = t.shape, i = this.computeSingleOutputShape(r), a = [
          i[0],
          ...i.slice(2)
        ], s = rr(a);
        return Array.isArray(e) ? Array(e.length).fill(s) : [
          s
        ];
      });
    }
    resetStates(t, e = false) {
      tt(() => {
        if (!this.stateful) throw new Ns("Cannot call resetStates() on an RNN Layer that is not stateful.");
        const r = this.inputSpec[0].shape, i = this.computeSingleOutputShape(r), a = [
          i[0],
          ...i.slice(2)
        ];
        if (r[0] == null) throw new Y("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (this.getStates() == null) Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => rr(a)) : this.states_ = [
          rr(a)
        ];
        else if (t == null) Te(this.states_), this.keptStates != null && (Te(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => rr(a)) : this.states_[0] = rr(a);
        else {
          if (Array.isArray(t) || (t = [
            t
          ]), t.length !== this.states_.length) throw new Y(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);
          e ? this.keptStates.push(this.states_.slice()) : Te(this.states_);
          for (let o = 0; o < this.states_.length; ++o) {
            const l = t[o], u = a;
            if (!Xe(l.shape, u)) throw new Y(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);
            this.states_[o] = l;
          }
        }
        this.states_ = this.states_.map((o) => qs(o.clone()));
      });
    }
    computeSingleOutputShape(t) {
      const { dataFormat: e, filters: r, kernelSize: i, padding: a, strides: s, dilationRate: o } = this.cell, l = e === "channelsFirst", u = t[l ? 3 : 2], c = t[l ? 4 : 3], h = is(u, i[0], a, s[0], o[0]), f = is(c, i[1], a, s[1], o[1]);
      return [
        ...t.slice(0, 2),
        ...l ? [
          r,
          h,
          f
        ] : [
          h,
          f,
          r
        ]
      ];
    }
  }
  D9.className = "ConvRNN2D";
  class sN extends Cw {
    constructor(t) {
      const { filters: e, kernelSize: r, strides: i, padding: a, dataFormat: s, dilationRate: o } = t;
      super(Object.assign(Object.assign({}, t), {
        units: e
      })), this.filters = e, sr(this.filters, "filters"), this.kernelSize = Ff(r, 2, "kernelSize"), this.kernelSize.forEach((l) => sr(l, "kernelSize")), this.strides = Ff(i || 1, 2, "strides"), this.strides.forEach((l) => sr(l, "strides")), this.padding = a || "valid", na(this.padding), this.dataFormat = s || "channelsLast", Nn(this.dataFormat), this.dilationRate = Ff(o || 1, 2, "dilationRate"), this.dilationRate.forEach((l) => sr(l, "dilationRate"));
    }
    build(t) {
      var e;
      t = ze(t);
      const r = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
      if (t[r] == null) throw new Y(`The channel dimension of the input should be defined. Found ${t[r]}`);
      const i = t[r], a = 4, s = this.kernelSize.concat([
        i,
        this.filters * a
      ]);
      this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      const o = this.kernelSize.concat([
        this.filters,
        this.filters * a
      ]);
      if (this.recurrentKernel = this.addWeight("recurrent_kernel", o, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias) {
        let l;
        if (this.unitForgetBias) {
          const u = this.biasInitializer, c = this.filters;
          l = new (e = class extends Na {
            apply(f, d) {
              const p = u.apply([
                c
              ]), g = du([
                c
              ]), v = u.apply([
                c * 2
              ]);
              return WR([
                p,
                g,
                v
              ]);
            }
          }, e.className = "CustomInit", e)();
        } else l = this.biasInitializer;
        this.bias = this.addWeight("bias", [
          this.filters * a
        ], null, l, this.biasRegularizer, true, this.biasConstraint);
      }
      this.built = true;
    }
    call(t, e) {
      return tt(() => {
        if (t.length !== 3) throw new Y(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);
        const r = e.training || false, i = t[0], a = t[1], s = t[2], o = 4;
        0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = iu({
          ones: () => ka(i),
          rate: this.dropout,
          training: r,
          count: o,
          dropoutFunc: this.dropoutFunc
        }));
        const l = this.dropoutMask, u = (O, F, z) => !F || !F[z] ? O : j(F[z], O);
        let c = u(i, l, 0), h = u(i, l, 1), f = u(i, l, 2), d = u(i, l, 3);
        0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = iu({
          ones: () => ka(a),
          rate: this.recurrentDropout,
          training: r,
          count: o,
          dropoutFunc: this.dropoutFunc
        }));
        const p = this.recurrentDropoutMask;
        let g = u(a, p, 0), v = u(a, p, 1), m = u(a, p, 2), y = u(a, p, 3);
        const x = 3, [b, _, w, S] = ji(this.kernel.read(), o, x), [I, T, A, C] = this.useBias ? ji(this.bias.read(), o) : [
          null,
          null,
          null,
          null
        ];
        c = this.inputConv(c, b, I, this.padding), h = this.inputConv(h, _, T, this.padding), f = this.inputConv(f, w, A, this.padding), d = this.inputConv(d, S, C, this.padding);
        const [D, E, M, L] = ji(this.recurrentKernel.read(), o, x);
        g = this.recurrentConv(g, D), v = this.recurrentConv(v, E), m = this.recurrentConv(m, M), y = this.recurrentConv(y, L);
        const k = this.recurrentActivation.apply(bt(c, g)), N = this.recurrentActivation.apply(bt(h, v)), R = bt(j(N, s), j(k, this.activation.apply(bt(f, m)))), $ = j(this.recurrentActivation.apply(bt(d, y)), this.activation.apply(R));
        return [
          $,
          $,
          R
        ];
      });
    }
    getConfig() {
      const t = super.getConfig(), { units: e } = t, r = GRt(t, [
        "units"
      ]), i = {
        filters: this.filters,
        kernelSize: this.kernelSize,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        strides: this.strides
      };
      return Object.assign(Object.assign({}, r), i);
    }
    inputConv(t, e, r, i) {
      const a = nh(t, e, this.strides, i || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
      return r ? ps(a, r, this.dataFormat) : a;
    }
    recurrentConv(t, e) {
      return nh(t, e, 1, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
    }
  }
  sN.className = "ConvLSTM2DCell";
  vt(sN);
  class E9 extends D9 {
    constructor(t) {
      const e = new sN(t);
      super(Object.assign(Object.assign({}, t), {
        cell: e
      }));
    }
    static fromConfig(t, e) {
      return new t(e);
    }
  }
  E9.className = "ConvLSTM2D";
  vt(E9);
  class oN extends Ce {
    constructor(t) {
      super(t), this.rate = Math.max(Math.min(t.rate, 1), 0), this.noiseShape = t.noiseShape, this.seed = t.seed, this.supportsMasking = true;
    }
    getNoiseShape(t) {
      if (this.noiseShape == null) return this.noiseShape;
      const e = t.shape, r = [];
      for (let i = 0; i < this.noiseShape.length; ++i) r.push(this.noiseShape[i] == null ? e[i] : this.noiseShape[i]);
      return r;
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        const r = ae(t);
        if (0 < this.rate && this.rate < 1) {
          const i = e.training == null ? false : e.training, a = this.getNoiseShape(r);
          return ay(() => x7(r, this.rate, a, this.seed), () => r, i);
        }
        return t;
      });
    }
    getConfig() {
      const t = {
        rate: this.rate,
        noiseShape: this.noiseShape,
        seed: this.seed
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    dispose() {
      return super.dispose();
    }
  }
  oN.className = "Dropout";
  vt(oN);
  class M9 extends oN {
    constructor(t) {
      super(t), this.inputSpec = [
        {
          ndim: 3
        }
      ];
    }
    getNoiseShape(t) {
      const e = t.shape;
      return [
        e[0],
        1,
        e[2]
      ];
    }
  }
  M9.className = "SpatialDropout1D";
  vt(M9);
  class R9 extends Ce {
    constructor(t) {
      if (super(t), this.activation = null, this.useBias = true, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", t.batchInputShape == null && t.inputShape == null && t.inputDim != null) {
        let e = null;
        t.batchSize != null && (e = t.batchSize), this.batchInputShape = [
          e,
          t.inputDim
        ];
      }
      this.units = t.units, sr(this.units, "units"), this.activation = ru(t.activation), t.useBias != null && (this.useBias = t.useBias), this.kernelInitializer = yn(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = yn(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = Kn(t.kernelConstraint), this.biasConstraint = Kn(t.biasConstraint), this.kernelRegularizer = xn(t.kernelRegularizer), this.biasRegularizer = xn(t.biasRegularizer), this.activityRegularizer = xn(t.activityRegularizer), this.supportsMasking = true, this.inputSpec = [
        {
          minNDim: 2
        }
      ];
    }
    build(t) {
      t = ze(t);
      const e = t[t.length - 1];
      this.kernel == null && (this.kernel = this.addWeight("kernel", [
        e,
        this.units
      ], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
        this.units
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint))), this.inputSpec = [
        {
          minNDim: 2,
          axes: {
            [-1]: e
          }
        }
      ], this.built = true;
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = t.slice();
      return e[e.length - 1] = this.units, e;
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        const r = ae(t), i = f7(this.activation.getClassName());
        let a;
        return i != null ? a = Zs(r, this.kernel.read(), i, this.bias ? this.bias.read() : null) : (a = Zs(r, this.kernel.read()), this.bias != null && (a = ps(a, this.bias.read())), this.activation != null && (a = this.activation.apply(a))), a;
      });
    }
    getConfig() {
      const t = {
        units: this.units,
        activation: nu(this.activation),
        useBias: this.useBias,
        kernelInitializer: _n(this.kernelInitializer),
        biasInitializer: _n(this.biasInitializer),
        kernelRegularizer: ln(this.kernelRegularizer),
        biasRegularizer: ln(this.biasRegularizer),
        activityRegularizer: ln(this.activityRegularizer),
        kernelConstraint: jn(this.kernelConstraint),
        biasConstraint: jn(this.biasConstraint)
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  R9.className = "Dense";
  vt(R9);
  class N9 extends Ce {
    constructor(t) {
      t = t || {}, super(t), this.inputSpec = [
        {
          minNDim: 3
        }
      ], this.dataFormat = t.dataFormat;
    }
    computeOutputShape(t) {
      t = ze(t);
      for (const e of t.slice(1)) if (e == null) throw new Y(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
      return [
        t[0],
        Ul(t, 1)
      ];
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        let r = ae(t);
        if (this.dataFormat === "channelsFirst" && r.rank > 1) {
          const i = [
            0
          ];
          for (let a = 2; a < r.rank; ++a) i.push(a);
          i.push(1), r = Oe(r, i);
        }
        return _Mt(r);
      });
    }
    getConfig() {
      const t = {};
      this.dataFormat != null && (t.dataFormat = this.dataFormat);
      const e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  N9.className = "Flatten";
  vt(N9);
  class L9 extends Ce {
    constructor(t) {
      super(t), this.supportsMasking = true, this.activation = ru(t.activation);
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        const r = ae(t);
        return this.activation.apply(r);
      });
    }
    getConfig() {
      const t = {
        activation: nu(this.activation)
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  L9.className = "Activation";
  vt(L9);
  class P9 extends Ce {
    constructor(t) {
      super(t), this.n = t.n, this.inputSpec = [
        {
          ndim: 2
        }
      ];
    }
    computeOutputShape(t) {
      return [
        t[0],
        this.n,
        t[1]
      ];
    }
    call(t, e) {
      return tt(() => (t = ae(t), xMt(t, this.n)));
    }
    getConfig() {
      const t = {
        n: this.n
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  P9.className = "RepeatVector";
  vt(P9);
  class $9 extends Ce {
    constructor(t) {
      super(t), this.targetShape = t.targetShape;
      for (let e = 0; e < this.targetShape.length; ++e) this.isUnknown(this.targetShape[e]) && (this.targetShape[e] = null);
    }
    isUnknown(t) {
      return t < 0 || t == null;
    }
    fixUnknownDimension(t, e) {
      const r = "Total size of new array must be unchanged.", i = e.slice();
      let a = 1, s = null;
      for (let l = 0; l < i.length; ++l) {
        const u = i[l];
        if (this.isUnknown(u)) if (s === null) s = l;
        else throw new Y("Can only specifiy one unknown dimension.");
        else a *= u;
      }
      const o = Ul(t);
      if (s !== null) {
        if (a === 0 || o % a !== 0) throw new Y(r);
        i[s] = o / a;
      } else if (o !== a) throw new Y(r);
      return i;
    }
    computeOutputShape(t) {
      let e = false;
      for (let r = 0; r < t.length; ++r) if (this.isUnknown(t[r])) {
        e = true;
        break;
      }
      return e ? t.slice(0, 1).concat(this.targetShape) : t.slice(0, 1).concat(this.fixUnknownDimension(t.slice(1), this.targetShape));
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        const r = ae(t), i = r.shape, a = i.slice(0, 1).concat(this.fixUnknownDimension(i.slice(1), this.targetShape));
        return Z(r, a);
      });
    }
    getConfig() {
      const t = {
        targetShape: this.targetShape
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  $9.className = "Reshape";
  vt($9);
  class O9 extends Ce {
    constructor(t) {
      if (super(t), t.dims == null) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
      if (!Array.isArray(t.dims)) throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);
      const e = ls(1, t.dims.length + 1);
      if (!Xe(t.dims.slice().sort(), e)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(t.dims) + " `dims` must contain consecutive integers starting from 1.");
      this.dims = t.dims, this.dimsIncludingBatch = [
        0
      ].concat(this.dims), this.inputSpec = [
        new Xn({
          ndim: this.dims.length + 1
        })
      ];
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = t.slice();
      return this.dims.forEach((r, i) => {
        e[i + 1] = t[r];
      }), e;
    }
    call(t, e) {
      return Oe(ae(t), this.dimsIncludingBatch);
    }
    getConfig() {
      const t = {
        dims: this.dims
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  O9.className = "Permute";
  vt(O9);
  class F9 extends Ce {
    constructor(t) {
      super(t ?? {}), this.supportsMasking = true, t != null ? this.maskValue = t.maskValue == null ? 0 : t.maskValue : this.maskValue = 0;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = super.getConfig(), e = {
        maskValue: this.maskValue
      };
      return Object.assign(e, t), e;
    }
    computeMask(t, e) {
      const r = ae(t);
      return A2(Vb(r, this.maskValue), -1);
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        const r = ae(t), s = A2(Vb(r, this.maskValue), -1, true);
        return j(r, Et(s, r.dtype));
      });
    }
  }
  F9.className = "Masking";
  vt(F9);
  class B9 extends Ce {
    constructor(t) {
      if (super(t), this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", t.batchInputShape == null && t.inputShape == null) {
        let e = null;
        t.batchSize != null && (e = t.batchSize), t.inputLength == null ? this.batchInputShape = [
          e,
          null
        ] : this.batchInputShape = [
          e
        ].concat(Ze(t.inputLength));
      }
      this.inputDim = t.inputDim, sr(this.inputDim, "inputDim"), this.outputDim = t.outputDim, sr(this.outputDim, "outputDim"), this.embeddingsInitializer = yn(t.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = xn(t.embeddingsRegularizer), this.activityRegularizer = xn(t.activityRegularizer), this.embeddingsConstraint = Kn(t.embeddingsConstraint), this.maskZero = t.maskZero, this.supportsMasking = t.maskZero, this.inputLength = t.inputLength;
    }
    build(t) {
      this.embeddings = this.addWeight("embeddings", [
        this.inputDim,
        this.outputDim
      ], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint), this.built = true;
    }
    warnOnIncompatibleInputShape(t) {
    }
    computeMask(t, e) {
      return tt(() => this.maskZero ? (t = ae(t), Vb(t, Fe(t))) : null);
    }
    computeOutputShape(t) {
      if (t = ze(t), this.inputLength == null) return [
        ...t,
        this.outputDim
      ];
      const e = Ze(this.inputLength);
      if (e.length !== t.length - 1) throw new Y(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);
      {
        let r = 0;
        for (let i = 0; i < e.length; ++i) {
          const a = e[i], s = t[i + 1];
          if (a != null && s != null && a !== s) throw new Y(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);
          a == null && (e[r] = s), r++;
        }
      }
      return [
        t[0],
        ...e,
        this.outputDim
      ];
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        let r = ae(t);
        r.dtype !== "int32" && (r = Ks(r, "int32"));
        const i = y7(this.embeddings.read(), Z(r, [
          r.size
        ]));
        return Z(i, ze(this.computeOutputShape(r.shape)));
      });
    }
    getConfig() {
      const t = {
        inputDim: this.inputDim,
        outputDim: this.outputDim,
        embeddingsInitializer: _n(this.embeddingsInitializer),
        embeddingsRegularizer: ln(this.embeddingsRegularizer),
        activityRegularizer: ln(this.activityRegularizer),
        embeddingsConstraint: jn(this.embeddingsConstraint),
        maskZero: this.maskZero,
        inputLength: this.inputLength
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  B9.className = "Embedding";
  vt(B9);
  class Th extends Ce {
    constructor(t) {
      super(t || {}), this.supportsMasking = true;
    }
    mergeFunction(t) {
      throw new me();
    }
    computeElementwiseOpOutputShape(t, e) {
      if (t == null || e == null) return null;
      if (t.length < e.length) return this.computeElementwiseOpOutputShape(e, t);
      if (e.length === 0) return t;
      const r = t.slice(0, t.length - e.length);
      for (let i = 0; i < e.length; ++i) {
        const a = t[t.length - e.length + i], s = e[i];
        if (a == null || s == null || a < 0 || s < 0) r.push(null);
        else if (a === 1) r.push(s);
        else if (s === 1) r.push(a);
        else {
          if (a !== s) throw new Y("Operands could not be broadcast together with shapes " + JSON.stringify(t) + " " + JSON.stringify(e));
          r.push(a);
        }
      }
      return r;
    }
    build(t) {
      if (Array.isArray(t) && !Array.isArray(t[0]) && (t = [
        ze(t)
      ]), t = t, t.length < 2) throw new Y(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);
      let e = [];
      for (const a of t) a != null && a[0] !== null && e.push(a[0]);
      if (e = Wl(e), e.length > 1) throw new Y(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);
      let r = t[0] == null ? null : t[0].slice(1);
      for (let a = 1; a < t.length; ++a) {
        const s = t[a] == null ? null : t[a].slice(1);
        r = this.computeElementwiseOpOutputShape(r, s);
      }
      const i = t.map((a) => a.length);
      t.indexOf(null) === -1 && Wl(i).length === 1 ? this.reshapeRequired = false : this.reshapeRequired = true;
    }
    call(t, e) {
      return tt(() => {
        if (t = t, this.reshapeRequired) {
          const r = [], i = t.map((a) => a.rank);
          if (i.indexOf(null) === -1) {
            const a = eu(i);
            for (let s of t) {
              const o = s.rank;
              for (let l = 0; l < a - o; ++l) s = ry(s, 1);
              r.push(s);
            }
            return this.mergeFunction(r);
          } else {
            let a = false;
            for (const l of t) {
              const u = l.rank;
              if (u == null) {
                const c = l.shape, h = c[0], f = c.slice(1).concat([
                  h
                ]);
                let d = Z(l, [
                  h
                ].concat(Ul(c.slice(1))));
                d = Oe(d, [
                  1,
                  0
                ]), d = Z(d, f), r.push(d), a = true;
              } else if (u > 1) {
                const c = ls(1, u).concat([
                  0
                ]);
                r.push(Oe(l, c)), a = true;
              } else r.push(l);
            }
            let s = this.mergeFunction(r);
            const o = s.rank;
            if (a) {
              if (o == null) {
                const l = s.shape, u = l.length, c = l[u - 1], h = [
                  c
                ].concat(l.slice(0, l.length - 1));
                s = Z(Oe(Z(s, [
                  -1,
                  c
                ]), [
                  1,
                  0
                ]), h);
              } else if (o > 1) {
                const l = [
                  o - 1
                ].concat(ls(0, o - 1));
                s = Oe(s, l);
              }
            }
            return s;
          }
        } else return this.mergeFunction(t);
      });
    }
    computeOutputShape(t) {
      t = t;
      let e;
      t[0] == null ? e = null : e = t[0].slice(1);
      for (let i = 1; i < t.length; ++i) {
        const a = t[i] == null ? null : t[i].slice(1);
        e = this.computeElementwiseOpOutputShape(e, a);
      }
      let r = [];
      for (const i of t) i != null && i[0] !== null && r.push(i[0]);
      return r = Wl(r), r.length === 1 ? e = r.concat(e) : e = [
        null
      ].concat(e), e;
    }
    computeMask(t, e) {
      return tt(() => {
        if (e == null) return null;
        if (!Array.isArray(e)) throw new Y("`mask` should be an Array");
        if (!Array.isArray(t)) throw new Y("`inputs` should be an Array");
        if (e.length !== t.length) throw new Y(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);
        if (e.every((i) => i == null)) return null;
        e = e.map((i) => i == null ? i : li(i, 0));
        let r = e[0];
        for (let i = 1; i < e.length - 1; ++i) r = qo(r, e[i]);
        return r;
      });
    }
  }
  class z9 extends Th {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return tt(() => {
        let e = t[0].clone();
        for (let r = 1; r < t.length; ++r) e = bt(e, t[r]);
        return e;
      });
    }
  }
  z9.className = "Add";
  vt(z9);
  class V9 extends Th {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return tt(() => {
        let e = t[0].clone();
        for (let r = 1; r < t.length; ++r) e = j(e, t[r]);
        return e;
      });
    }
  }
  V9.className = "Multiply";
  vt(V9);
  class G9 extends Th {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return tt(() => {
        let e = t[0].clone();
        for (let r = 1; r < t.length; ++r) e = bt(e, t[r]);
        return j(1 / t.length, e);
      });
    }
  }
  G9.className = "Average";
  vt(G9);
  class W9 extends Th {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return tt(() => {
        let e = t[0];
        for (let r = 1; r < t.length; ++r) e = fu(e, t[r]);
        return e;
      });
    }
  }
  W9.className = "Maximum";
  vt(W9);
  class U9 extends Th {
    constructor(t) {
      super(t);
    }
    mergeFunction(t) {
      return tt(() => {
        let e = t[0];
        for (let r = 1; r < t.length; ++r) e = fv(e, t[r]);
        return e;
      });
    }
  }
  U9.className = "Minimum";
  vt(U9);
  class H9 extends Th {
    constructor(t) {
      super(t), this.DEFAULT_AXIS = -1, t == null && (t = {}), this.axis = t.axis == null ? this.DEFAULT_AXIS : t.axis, this.supportsMasking = true, this.reshapeRequired = false;
    }
    build(t) {
      if (!(Array.isArray(t) && Array.isArray(t[0])) || t.length === 1) throw new Y("A `Concatenate` layer should be called on a list of at least 2 inputs");
      t = t;
      let e = true;
      for (const i of t) if (i != null) {
        e = false;
        break;
      }
      if (e) return;
      const r = [];
      for (let i = 0; i < t.length; ++i) {
        const a = t[i].slice();
        a.splice(this.axis, 1);
        let s = false;
        for (const o of r) if (Xe(o, a)) {
          s = true;
          break;
        }
        s || r.push(a);
      }
      if (r.length > 1) throw new Y("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(t));
    }
    mergeFunction(t) {
      return tt(() => WR(t, this.axis));
    }
    computeOutputShape(t) {
      if (!(Array.isArray(t) && Array.isArray(t[0]))) throw new Y("A `Concatenate` layer should be called on a list of inputs.");
      const e = t, r = e[0].slice(), i = this.axis < 0 ? r.length + this.axis : this.axis;
      for (const a of e.slice(1)) {
        if (r[i] == null || a[i] == null) {
          r[i] = null;
          break;
        }
        r[i] += a[i];
      }
      return r;
    }
    computeMask(t, e) {
      if (e == null) return null;
      if (!Array.isArray(e)) throw new Y("`mask` should be an array for Concatenate");
      if (!Array.isArray(t)) throw new Y("`inputs` should be an array for Concatenate");
      if (e.length !== t.length) throw new Y(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);
      return tt(() => {
        let r = true;
        if (e.forEach((s) => {
          if (s != null) {
            r = false;
            return;
          }
        }), r) return null;
        const i = [];
        for (let s = 0; s < t.length; ++s) e[s] == null ? i.push(Et(ka(t[s]), "bool")) : e[s].rank < t[s].rank ? i.push(li(e[s], -1)) : i.push(e[s]);
        const a = pi(i, this.axis);
        return Xq(a, -1, false);
      });
    }
    getConfig() {
      const t = {
        axis: this.axis
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  H9.className = "Concatenate";
  vt(H9);
  function Ep(n, t) {
    for (; n < 0; ) n += t;
    return n;
  }
  function WRt(n, t, e) {
    if (n.shape.length > 3 || t.shape.length > 3) throw new me("batchDot is not implemented for tensors of 4D or higher rank yet");
    if (B(n.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`), B(n.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`), typeof e == "number" && (e = [
      e,
      e
    ]), n.dtype === "complex64" || t.dtype === "complex64") throw new me("batchDot is not implemented for complex64-type Tensors yet.");
    const r = n.shape.length, i = t.shape.length;
    e == null && (e = [
      r - 1,
      i - 2
    ]);
    const a = e;
    return tt(() => {
      let s;
      if (r > i) {
        s = r - i;
        const l = [];
        for (let u = 0; u < s; ++u) l.push(1);
        t = Z(t, t.shape.concat(l));
      } else if (i > r) {
        s = i - r;
        const l = [];
        for (let u = 0; u < s; ++u) l.push(1);
        n = Z(n, n.shape.concat(l));
      } else s = 0;
      let o;
      if (n.shape.length === 2 && t.shape.length === 2) a[0] === a[1] ? o = Kt(j(n, t), a[0]) : o = Kt(j(Oe(n, [
        1,
        0
      ]), t), a[1]);
      else {
        const l = a[0] !== n.shape.length - 1, u = a[1] === t.shape.length - 1;
        o = Ge(n, t, l, u);
      }
      if (s > 0) {
        let l;
        r > i ? l = r + i - 3 : l = r - 1;
        const u = [];
        for (let c = l; c < l + s; ++c) u.push(c);
        o = Zm(o, u);
      }
      return o.shape.length === 1 && (o = li(o, 1)), o;
    });
  }
  class X9 extends Th {
    constructor(t) {
      super(t), this.axes = t.axes, this.normalize = t.normalize == null ? false : t.normalize, this.supportsMasking = true, this.reshapeRequired = false;
    }
    build(t) {
      B(Array.isArray(t) && t.length === 2 && Array.isArray(t[0]) && Array.isArray(t[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      const e = t[0], r = t[1];
      if (e.length > 3 || r.length > 3) throw new me("Dot layer does not support tensors of 4D or higher rank yet.");
      const i = this.interpretAxes(e, r);
      if (e[i[0]] !== r[i[1]]) throw new Y(`Dimension incompatibility: ${e[i[0]]} !== ${r[i[1]]}`);
    }
    mergeFunction(t) {
      if (t.length !== 2) throw new Y(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);
      let e = t[0], r = t[1], i;
      return Array.isArray(this.axes) ? i = this.axes.map((a, s) => Ep(a, t[s].shape.length)) : i = [
        Ep(this.axes, e.shape.length),
        Ep(this.axes, r.shape.length)
      ], this.normalize && (e = qb(e, i[0]), r = qb(r, i[1])), WRt(e, r, i);
    }
    interpretAxes(t, e) {
      let r;
      return Array.isArray(this.axes) ? r = this.axes : r = [
        Ep(this.axes, t.length),
        Ep(this.axes, e.length)
      ], r;
    }
    computeOutputShape(t) {
      B(Array.isArray(t) && t.length === 2 && Array.isArray(t[0]) && Array.isArray(t[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      const e = t[0].slice(), r = t[1].slice();
      if (e.length > 3 || r.length > 3) throw new me("Dot layer does not support tensors of 4D or higher rank yet.");
      const i = this.interpretAxes(e, r);
      e.splice(i[0], 1), r.splice(i[1], 1), r.splice(0, 1);
      const a = e.concat(r);
      return a.length === 1 && a.push(1), a;
    }
    computeMask(t, e) {
      return null;
    }
    getConfig() {
      const t = {
        axes: this.axes,
        normalize: this.normalize
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  X9.className = "Dot";
  vt(X9);
  class Y9 extends Ce {
    constructor(t) {
      super(t), this.supportsMasking = true, this.stddev = t.stddev;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = super.getConfig(), e = {
        stddev: this.stddev
      };
      return Object.assign(e, t), e;
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        const r = ae(t);
        return ay(() => bt(mw(r.shape, 0, this.stddev), r), () => r, e.training || false);
      });
    }
  }
  Y9.className = "GaussianNoise";
  vt(Y9);
  class q9 extends Ce {
    constructor(t) {
      super(t), this.supportsMasking = true, this.rate = t.rate;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = super.getConfig(), e = {
        rate: this.rate
      };
      return Object.assign(e, t), e;
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e);
        const r = ae(t);
        return this.rate > 0 && this.rate < 1 ? ay(() => {
          const a = Math.sqrt(this.rate / (1 - this.rate));
          return j(r, mw(r.shape, 1, a));
        }, () => r, e.training || false) : r;
      });
    }
  }
  q9.className = "GaussianDropout";
  vt(q9);
  class j9 extends Ce {
    constructor(t) {
      super(t), this.supportsMasking = true, this.rate = t.rate, this.noiseShape = t.noiseShape;
    }
    _getNoiseShape(t) {
      return this.noiseShape || ae(t).shape;
    }
    computeOutputShape(t) {
      return t;
    }
    getConfig() {
      const t = super.getConfig(), e = {
        rate: this.rate
      };
      return Object.assign(e, t), e;
    }
    call(t, e) {
      return tt(() => {
        if (this.rate < 1 && this.rate > 0) {
          const r = this._getNoiseShape(t);
          return ay(() => {
            const a = ae(t), o = -1.6732632423543772 * 1.0507009873554805;
            let l = _h(Km(r), this.rate);
            l = Ks(l, "float32");
            const u = ((1 - this.rate) * (1 + this.rate * o ** 2)) ** -0.5, c = -u * o * this.rate, h = bt(j(a, l), j(bt(l, -1), o));
            return bt(j(h, u), c);
          }, () => ae(t), e.training || false);
        }
        return t;
      });
    }
  }
  j9.className = "AlphaDropout";
  vt(j9);
  function mv(n, t, e, r, i, a = 1e-3) {
    let s;
    if (n.rank === 2) s = bTt(n, t, e, r, i, a);
    else if (n.rank === 3) s = wTt(n, t, e, r, i, a);
    else if (n.rank === 4) s = CTt(n, t, e, r, i, a);
    else throw new me(`batchNormalization is not implemented for array of rank ${n.rank} yet`);
    return s;
  }
  function URt(n, t, e, r, i = 1e-3) {
    return tt(() => {
      const a = ZM(n, r), s = a.mean, o = a.variance;
      return [
        mv(n, s, o, e, t, i),
        s,
        o
      ];
    });
  }
  function HRt(n, t, e, r, i = 1e-3) {
    return tt(() => {
      const a = ZM(n, r), s = a.mean, o = a.variance, l = [];
      for (const p of ls(0, n.rank)) r.indexOf(p) !== -1 ? l.push(1) : l.push(n.shape[p]);
      const u = Z(s, l), c = Z(o, l), h = t == null ? null : Z(t, l), f = e == null ? null : Z(e, l);
      return [
        mv(n, u, c, f, h, i),
        s,
        o
      ];
    });
  }
  function XRt(n, t, e, r, i = 1e-3) {
    return Xe(r.slice().sort(), ls(0, n.rank - 1)) ? URt(n, t, e, r, i) : HRt(n, t, e, r, i);
  }
  class K9 extends Ce {
    constructor(t) {
      t == null && (t = {}), super(t), this.supportsMasking = true, this.axis = t.axis == null ? -1 : t.axis, this.momentum = t.momentum == null ? 0.99 : t.momentum, this.epsilon = t.epsilon == null ? 1e-3 : t.epsilon, this.center = t.center == null ? true : t.center, this.scale = t.scale == null ? true : t.scale, this.betaInitializer = yn(t.betaInitializer || "zeros"), this.gammaInitializer = yn(t.gammaInitializer || "ones"), this.movingMeanInitializer = yn(t.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = yn(t.movingVarianceInitializer || "ones"), this.betaConstraint = Kn(t.betaConstraint), this.gammaConstraint = Kn(t.gammaConstraint), this.betaRegularizer = xn(t.betaRegularizer), this.gammaRegularizer = xn(t.gammaRegularizer);
    }
    build(t) {
      t = ze(t);
      const e = this.axis >= 0 ? this.axis : this.axis + t.length, r = t[e];
      if (r == null) throw new Y(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);
      this.inputSpec = [
        new Xn({
          ndim: t.length,
          axes: {
            [e]: r
          }
        })
      ];
      const i = [
        r
      ];
      this.scale && (this.gamma = this.addWeight("gamma", i, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", i, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", i, null, this.movingMeanInitializer, null, false), this.movingVariance = this.addWeight("moving_variance", i, null, this.movingVarianceInitializer, null, false), this.built = true;
    }
    call(t, e) {
      return tt(() => {
        const r = e.training == null ? false : e.training, i = ae(t), a = i.shape, s = a.length, o = ls(0, s), l = this.axis >= 0 ? this.axis : this.axis + s;
        o.splice(l, 1);
        const u = sh(1, s);
        u[l] = a[l];
        const c = o.slice();
        c.sort();
        const h = !Xe(c, ls(0, s).slice(0, s - 1)), f = () => {
          if (h) {
            const y = Z(this.movingMean.read(), u), x = Z(this.movingVariance.read(), u), b = this.center ? Z(this.beta.read(), u) : null, _ = this.scale ? Z(this.gamma.read(), u) : null;
            return mv(i, y, x, b, _, this.epsilon);
          } else return mv(i, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
        };
        if (!r) return f();
        const [d, p, g] = XRt(i, this.gamma.read(), this.beta.read(), o, this.epsilon), v = (y, x, b) => {
          tt(() => {
            const _ = 1 - b, w = y.read(), S = j(re(w, x), _);
            y.write(re(w, S));
          });
        };
        return (() => {
          v(this.movingMean, p, this.momentum), v(this.movingVariance, g, this.momentum);
        })(), d;
      });
    }
    getConfig() {
      const t = {
        axis: this.axis,
        momentum: this.momentum,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: _n(this.betaInitializer),
        gammaInitializer: _n(this.gammaInitializer),
        movingMeanInitializer: _n(this.movingMeanInitializer),
        movingVarianceInitializer: _n(this.movingVarianceInitializer),
        betaRegularizer: ln(this.betaRegularizer),
        gammaRegularizer: ln(this.gammaRegularizer),
        betaConstraint: jn(this.betaConstraint),
        gammaConstraint: jn(this.gammaConstraint)
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  K9.className = "BatchNormalization";
  vt(K9);
  class Z9 extends Ce {
    constructor(t) {
      if (t == null && (t = {}), super(t), this.axis = t.axis == null ? -1 : t.axis, typeof this.axis == "number") {
        if (!Number.isInteger(this.axis)) throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
      } else if (Array.isArray(this.axis)) {
        for (const e of this.axis) if (!Number.isInteger(e)) throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
      } else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
      this.epsilon = t.epsilon == null ? 1e-3 : t.epsilon, this.center = t.center == null ? true : t.center, this.scale = t.scale == null ? true : t.scale, this.betaInitializer = yn(t.betaInitializer || "zeros"), this.gammaInitializer = yn(t.gammaInitializer || "ones"), this.betaRegularizer = xn(t.betaRegularizer), this.gammaRegularizer = xn(t.gammaRegularizer), this.supportsMasking = true;
    }
    build(t) {
      t = ze(t);
      const e = t.length;
      typeof this.axis == "number" && (this.axis = [
        this.axis
      ]);
      for (let a = 0; a < this.axis.length; ++a) this.axis[a] < 0 && (this.axis[a] += e);
      for (const a of this.axis) if (a < 0 || a >= e) throw new Error(`Invalid axis: ${a}`);
      if (this.axis.length !== Wl(this.axis).length) throw new Error(`Found duplicate axes in: ${this.axis}`);
      const r = this.axis.map((a) => t[a]), i = true;
      this.scale ? this.gamma = this.addWeight("gamma", r, "float32", this.gammaInitializer, this.gammaRegularizer, i) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", r, "float32", this.betaInitializer, this.betaRegularizer, i) : this.beta = null, this.built = true;
    }
    call(t, e) {
      const r = ae(t), i = r.shape, a = i.length;
      return tt(() => {
        let { mean: o, variance: l } = ZM(r, this.axis, true);
        const u = sh(1, a);
        for (const g of this.axis) u[g] = i[g];
        const c = (g) => g != null && g.shape.length !== a ? Z(g, u) : g;
        let h = this.scale ? c(this.gamma.read()) : null, f = this.center ? c(this.beta.read()) : null;
        const d = [], p = [];
        for (let g = 0; g < a; ++g) this.axis.indexOf(g) !== -1 ? (d.push(i[g]), p.push(1)) : (d.push(1), p.push(i[g]));
        return o = Za(o, d), l = Za(l, d), h != null && (h = Za(h, p)), f != null && (f = Za(f, p)), mv(r, o, l, f, h, this.epsilon);
      });
    }
    getConfig() {
      const t = {
        axis: this.axis,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: _n(this.betaInitializer),
        gammaInitializer: _n(this.gammaInitializer),
        betaRegularizer: ln(this.betaRegularizer),
        gammaRegularizer: ln(this.gammaRegularizer)
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  Z9.className = "LayerNormalization";
  vt(Z9);
  function YRt(n, t, e) {
    return tt(() => {
      if (n.rank !== 4) throw new Y(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);
      if (t == null && (t = [
        [
          1,
          1
        ],
        [
          1,
          1
        ]
      ]), t.length !== 2 || t[0].length !== 2 || t[1].length !== 2) throw new Y("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
      if (e == null && (e = us()), e !== "channelsLast" && e !== "channelsFirst") throw new Y(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
      let r;
      return e === "channelsFirst" ? r = [
        [
          0,
          0
        ],
        [
          0,
          0
        ],
        t[0],
        t[1]
      ] : r = [
        [
          0,
          0
        ],
        t[0],
        t[1],
        [
          0,
          0
        ]
      ], JM(n, r);
    });
  }
  class J9 extends Ce {
    constructor(t) {
      if (t == null && (t = {}), super(t), this.dataFormat = t.dataFormat == null ? us() : t.dataFormat, t.padding == null) this.padding = [
        [
          1,
          1
        ],
        [
          1,
          1
        ]
      ];
      else if (typeof t.padding == "number") this.padding = [
        [
          t.padding,
          t.padding
        ],
        [
          t.padding,
          t.padding
        ]
      ];
      else {
        if (t.padding = t.padding, t.padding.length !== 2) throw new Y(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);
        let e, r;
        if (typeof t.padding[0] == "number") e = [
          t.padding[0],
          t.padding[0]
        ], r = [
          t.padding[1],
          t.padding[1]
        ];
        else {
          if (t.padding = t.padding, t.padding[0].length !== 2) throw new Y(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);
          if (e = t.padding[0], t.padding[1].length !== 2) throw new Y(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);
          r = t.padding[1];
        }
        this.padding = [
          e,
          r
        ];
      }
      this.inputSpec = [
        new Xn({
          ndim: 4
        })
      ];
    }
    computeOutputShape(t) {
      t = ze(t);
      let e, r;
      return this.dataFormat === "channelsFirst" ? (t[2] != null && t[2] >= 0 ? e = t[2] + this.padding[0][0] + this.padding[0][1] : e = null, t[3] != null && t[3] >= 0 ? r = t[3] + this.padding[1][0] + this.padding[1][1] : r = null, [
        t[0],
        t[1],
        e,
        r
      ]) : (t[1] != null && t[1] >= 0 ? e = t[1] + this.padding[0][0] + this.padding[0][1] : e = null, t[2] != null && t[2] >= 0 ? r = t[2] + this.padding[1][0] + this.padding[1][1] : r = null, [
        t[0],
        e,
        r,
        t[3]
      ]);
    }
    call(t, e) {
      return tt(() => YRt(ae(t), this.padding, this.dataFormat));
    }
    getConfig() {
      const t = {
        padding: this.padding,
        dataFormat: this.dataFormat
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  J9.className = "ZeroPadding2D";
  vt(J9);
  function Tw(n, t, e, r, i, a) {
    return tt(() => {
      Nn(i), p7(a), na(r), e == null && (e = [
        1,
        1
      ]), r == null && (r = "valid"), i == null && (i = us()), a == null && (a = "max"), n = nN(n, i);
      let s;
      const o = r === "same" ? "same" : "valid";
      return a === "max" ? s = KM(n, t, e, o) : s = zM(n, t, e, o), i === "channelsFirst" && (s = Oe(s, [
        0,
        3,
        1,
        2
      ])), s;
    });
  }
  function Q9(n, t, e, r, i, a) {
    return tt(() => {
      Nn(i), p7(a), na(r), e == null && (e = [
        1,
        1,
        1
      ]), r == null && (r = "valid"), i == null && (i = us()), a == null && (a = "max"), n = v9(n, i);
      let s;
      const o = r === "same" ? "same" : "valid";
      return a === "max" ? s = lAt(n, t, e, o) : s = cTt(n, t, e, o), i === "channelsFirst" && (s = Oe(s, [
        0,
        4,
        1,
        2,
        3
      ])), s;
    });
  }
  class tK extends Ce {
    constructor(t) {
      if (t.poolSize == null && (t.poolSize = 2), super(t), typeof t.poolSize == "number") this.poolSize = [
        t.poolSize
      ];
      else if (Array.isArray(t.poolSize) && t.poolSize.length === 1 && typeof t.poolSize[0] == "number") this.poolSize = t.poolSize;
      else throw new Y(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);
      if (sr(this.poolSize, "poolSize"), t.strides == null) this.strides = this.poolSize;
      else if (typeof t.strides == "number") this.strides = [
        t.strides
      ];
      else if (Array.isArray(t.strides) && t.strides.length === 1 && typeof t.strides[0] == "number") this.strides = t.strides;
      else throw new Y(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);
      sr(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, na(this.padding), this.inputSpec = [
        new Xn({
          ndim: 3
        })
      ];
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = is(t[1], this.poolSize[0], this.padding, this.strides[0]);
      return [
        t[0],
        e,
        t[2]
      ];
    }
    call(t, e) {
      return tt(() => {
        this.invokeCallHook(t, e), t = ry(ae(t), 2);
        const r = this.poolingFunction(ae(t), [
          this.poolSize[0],
          1
        ], [
          this.strides[0],
          1
        ], this.padding, "channelsLast");
        return Zm(r, [
          2
        ]);
      });
    }
    getConfig() {
      const t = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  class eK extends tK {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, e, r, i, a) {
      return Nn(a), na(i), Tw(t, e, r, i, a, "max");
    }
  }
  eK.className = "MaxPooling1D";
  vt(eK);
  class nK extends tK {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, e, r, i, a) {
      return Nn(a), na(i), Tw(t, e, r, i, a, "avg");
    }
  }
  nK.className = "AveragePooling1D";
  vt(nK);
  class rK extends Ce {
    constructor(t) {
      if (t.poolSize == null && (t.poolSize = [
        2,
        2
      ]), super(t), this.poolSize = Array.isArray(t.poolSize) ? t.poolSize : [
        t.poolSize,
        t.poolSize
      ], t.strides == null) this.strides = this.poolSize;
      else if (Array.isArray(t.strides)) {
        if (t.strides.length !== 2) throw new Y(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);
        this.strides = t.strides;
      } else this.strides = [
        t.strides,
        t.strides
      ];
      sr(this.poolSize, "poolSize"), sr(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, Nn(this.dataFormat), na(this.padding), this.inputSpec = [
        new Xn({
          ndim: 4
        })
      ];
    }
    computeOutputShape(t) {
      t = ze(t);
      let e = this.dataFormat === "channelsFirst" ? t[2] : t[1], r = this.dataFormat === "channelsFirst" ? t[3] : t[2];
      return e = is(e, this.poolSize[0], this.padding, this.strides[0]), r = is(r, this.poolSize[1], this.padding, this.strides[1]), this.dataFormat === "channelsFirst" ? [
        t[0],
        t[1],
        e,
        r
      ] : [
        t[0],
        e,
        r,
        t[3]
      ];
    }
    call(t, e) {
      return tt(() => (this.invokeCallHook(t, e), this.poolingFunction(ae(t), this.poolSize, this.strides, this.padding, this.dataFormat)));
    }
    getConfig() {
      const t = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  class iK extends rK {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, e, r, i, a) {
      return Nn(a), na(i), Tw(t, e, r, i, a, "max");
    }
  }
  iK.className = "MaxPooling2D";
  vt(iK);
  class aK extends rK {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, e, r, i, a) {
      return Nn(a), na(i), Tw(t, e, r, i, a, "avg");
    }
  }
  aK.className = "AveragePooling2D";
  vt(aK);
  class sK extends Ce {
    constructor(t) {
      if (t.poolSize == null && (t.poolSize = [
        2,
        2,
        2
      ]), super(t), this.poolSize = Array.isArray(t.poolSize) ? t.poolSize : [
        t.poolSize,
        t.poolSize,
        t.poolSize
      ], t.strides == null) this.strides = this.poolSize;
      else if (Array.isArray(t.strides)) {
        if (t.strides.length !== 3) throw new Y(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);
        this.strides = t.strides;
      } else this.strides = [
        t.strides,
        t.strides,
        t.strides
      ];
      sr(this.poolSize, "poolSize"), sr(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, Nn(this.dataFormat), na(this.padding), this.inputSpec = [
        new Xn({
          ndim: 5
        })
      ];
    }
    computeOutputShape(t) {
      t = ze(t);
      let e = this.dataFormat === "channelsFirst" ? t[2] : t[1], r = this.dataFormat === "channelsFirst" ? t[3] : t[2], i = this.dataFormat === "channelsFirst" ? t[4] : t[3];
      return e = is(e, this.poolSize[0], this.padding, this.strides[0]), r = is(r, this.poolSize[1], this.padding, this.strides[1]), i = is(i, this.poolSize[2], this.padding, this.strides[2]), this.dataFormat === "channelsFirst" ? [
        t[0],
        t[1],
        e,
        r,
        i
      ] : [
        t[0],
        e,
        r,
        i,
        t[4]
      ];
    }
    call(t, e) {
      return tt(() => (this.invokeCallHook(t, e), this.poolingFunction(ae(t), this.poolSize, this.strides, this.padding, this.dataFormat)));
    }
    getConfig() {
      const t = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  class oK extends sK {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, e, r, i, a) {
      return Nn(a), na(i), Q9(t, e, r, i, a, "max");
    }
  }
  oK.className = "MaxPooling3D";
  vt(oK);
  class lK extends sK {
    constructor(t) {
      super(t);
    }
    poolingFunction(t, e, r, i, a) {
      return Nn(a), na(i), Q9(t, e, r, i, a, "avg");
    }
  }
  lK.className = "AveragePooling3D";
  vt(lK);
  class uK extends Ce {
    constructor(t) {
      super(t), this.inputSpec = [
        new Xn({
          ndim: 3
        })
      ];
    }
    computeOutputShape(t) {
      return [
        t[0],
        t[2]
      ];
    }
    call(t, e) {
      throw new me();
    }
  }
  class cK extends uK {
    constructor(t) {
      super(t || {});
    }
    call(t, e) {
      return tt(() => {
        const r = ae(t);
        return $n(r, 1);
      });
    }
  }
  cK.className = "GlobalAveragePooling1D";
  vt(cK);
  class hK extends uK {
    constructor(t) {
      super(t || {});
    }
    call(t, e) {
      return tt(() => {
        const r = ae(t);
        return rs(r, 1);
      });
    }
  }
  hK.className = "GlobalMaxPooling1D";
  vt(hK);
  class fK extends Ce {
    constructor(t) {
      super(t), this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, Nn(this.dataFormat), this.inputSpec = [
        new Xn({
          ndim: 4
        })
      ];
    }
    computeOutputShape(t) {
      return t = t, this.dataFormat === "channelsLast" ? [
        t[0],
        t[3]
      ] : [
        t[0],
        t[1]
      ];
    }
    call(t, e) {
      throw new me();
    }
    getConfig() {
      const t = {
        dataFormat: this.dataFormat
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  class dK extends fK {
    call(t, e) {
      return tt(() => {
        const r = ae(t);
        return this.dataFormat === "channelsLast" ? $n(r, [
          1,
          2
        ]) : $n(r, [
          2,
          3
        ]);
      });
    }
  }
  dK.className = "GlobalAveragePooling2D";
  vt(dK);
  class pK extends fK {
    call(t, e) {
      return tt(() => {
        const r = ae(t);
        return this.dataFormat === "channelsLast" ? rs(r, [
          1,
          2
        ]) : rs(r, [
          2,
          3
        ]);
      });
    }
  }
  pK.className = "GlobalMaxPooling2D";
  vt(pK);
  class gK extends Ce {
    constructor(t) {
      super(t), this.layer = t.layer;
    }
    build(t) {
      this.built = true;
    }
    get trainable() {
      return this.layer != null ? this.layer.trainable : false;
    }
    set trainable(t) {
      this.layer != null && (this.layer.trainable = t);
    }
    get trainableWeights() {
      return this.layer.trainableWeights;
    }
    get nonTrainableWeights() {
      return this.layer.nonTrainableWeights;
    }
    get updates() {
      return this.layer._updates;
    }
    get losses() {
      return this.layer.losses;
    }
    getWeights() {
      return this.layer.getWeights();
    }
    setWeights(t) {
      this.layer.setWeights(t);
    }
    getConfig() {
      const t = {
        layer: {
          className: this.layer.getClassName(),
          config: this.layer.getConfig()
        }
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    setFastWeightInitDuringBuild(t) {
      super.setFastWeightInitDuringBuild(t), this.layer != null && this.layer.setFastWeightInitDuringBuild(t);
    }
    static fromConfig(t, e, r = {}) {
      const i = e.layer, a = $o(i, r);
      delete e.layer;
      const s = {
        layer: a
      };
      return Object.assign(s, e), new t(s);
    }
  }
  class vK extends gK {
    constructor(t) {
      super(t), this.supportsMasking = true;
    }
    build(t) {
      if (t = ze(t), t.length < 3) throw new Y(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);
      this.inputSpec = [
        {
          shape: t
        }
      ];
      const e = [
        t[0]
      ].concat(t.slice(2));
      this.layer.built || (this.layer.build(e), this.layer.built = true), super.build(t);
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = [
        t[0]
      ].concat(t.slice(2)), r = this.layer.computeOutputShape(e), i = t[1];
      return [
        r[0],
        i
      ].concat(r.slice(1));
    }
    call(t, e) {
      return tt(() => (t = ae(t), T9((s, o) => [
        ae(this.layer.call(s, e)),
        []
      ], t, [], false, null, null, false, true)[1]));
    }
  }
  vK.className = "TimeDistributed";
  vt(vK);
  function qRt(n) {
    Ch(pMt, "BidirectionalMergeMode", n);
  }
  const jRt = "concat";
  class mK extends gK {
    constructor(t) {
      super(t);
      const e = t.layer.getConfig(), r = {};
      r.className = t.layer.getClassName(), r.config = e, this.forwardLayer = $o(r), e.goBackwards = e.goBackwards !== true;
      const i = {};
      if (i.className = t.layer.getClassName(), i.config = e, this.backwardLayer = $o(i), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = t.mergeMode === void 0 ? jRt : t.mergeMode, qRt(this.mergeMode), t.weights) throw new me("weights support is not implemented for Bidirectional layer yet.");
      this._stateful = t.layer.stateful, this.returnSequences = t.layer.returnSequences, this.returnState = t.layer.returnState, this.supportsMasking = true, this._trainable = true, this.inputSpec = t.layer.inputSpec, this.numConstants = null;
    }
    get trainable() {
      return this._trainable;
    }
    set trainable(t) {
      this._trainable = t, this.forwardLayer != null && (this.forwardLayer.trainable = t), this.backwardLayer != null && (this.backwardLayer.trainable = t);
    }
    getWeights() {
      return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    }
    setWeights(t) {
      const e = t.length, r = Math.floor(e / 2);
      this.forwardLayer.setWeights(t.slice(0, r)), this.backwardLayer.setWeights(t.slice(r));
    }
    computeOutputShape(t) {
      let e = this.forwardLayer.computeOutputShape(t);
      Array.isArray(e) && Array.isArray(e[0]) || (e = [
        e
      ]), e = e;
      let r, i, a;
      return this.returnState && (a = e.slice(1)), r = e[0], r = r, this.mergeMode === "concat" ? (r[r.length - 1] *= 2, i = [
        r
      ]) : this.mergeMode == null ? i = [
        r,
        r.slice()
      ] : i = [
        r
      ], this.returnState ? this.mergeMode == null ? i.concat(a).concat(a.slice()) : [
        r
      ].concat(a).concat(a.slice()) : ui(i);
    }
    apply(t, e) {
      let r = e == null ? null : e.initialState, i = e == null ? null : e.constants;
      e == null && (e = {});
      const a = C9(t, r, i, this.numConstants);
      if (t = a.inputs, r = a.initialState, i = a.constants, Array.isArray(t) && (r = t.slice(1), t = t[0]), (r == null || r.length === 0) && i == null) return super.apply(t, e);
      const s = [], o = [];
      if (r != null) {
        const u = r.length;
        if (u % 2 > 0) throw new Y("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
        e.initialState = r, s.push(...r);
        const c = r.map((h) => new Xn({
          shape: h.shape
        }));
        this.forwardLayer.stateSpec = c.slice(0, u / 2), this.backwardLayer.stateSpec = c.slice(u / 2), o.push(...c);
      }
      if (i != null) throw new me("Support for constants in Bidirectional layers is not implemented yet.");
      const l = s[0] instanceof oo;
      for (const u of s) if (u instanceof oo !== l) throw new Y("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
      if (l) {
        const u = [
          t
        ].concat(s), c = this.inputSpec.concat(o), h = this.inputSpec;
        this.inputSpec = c;
        const f = super.apply(u, e);
        return this.inputSpec = h, f;
      } else return super.apply(t, e);
    }
    call(t, e) {
      return tt(() => {
        const r = e.initialState;
        let i, a;
        if (r == null) i = this.forwardLayer.call(t, e), a = this.backwardLayer.call(t, e);
        else {
          const l = r.slice(0, r.length / 2), u = r.slice(r.length / 2);
          i = this.forwardLayer.call(t, Object.assign(e, {
            initialState: l
          })), a = this.backwardLayer.call(t, Object.assign(e, {
            initialState: u
          }));
        }
        let s;
        this.returnState && (Array.isArray(i) && (s = i.slice(1).concat(a.slice(1))), i = i[0], a = a[0]), this.returnSequences && (a = ih(a, 1));
        let o;
        return this.mergeMode === "concat" ? o = WR([
          i,
          a
        ]) : this.mergeMode === "sum" ? o = bt(i, a) : this.mergeMode === "ave" ? o = j(0.5, bt(i, a)) : this.mergeMode === "mul" ? o = j(i, a) : this.mergeMode == null && (o = [
          i,
          a
        ]), this.returnState ? this.mergeMode == null ? o.concat(s) : [
          o
        ].concat(s) : o;
      });
    }
    resetStates(t) {
      this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
    }
    build(t) {
      zc(this.forwardLayer.name, () => {
        this.forwardLayer.build(t);
      }), zc(this.backwardLayer.name, () => {
        this.backwardLayer.build(t);
      }), this.built = true;
    }
    computeMask(t, e) {
      Array.isArray(e) && (e = e[0]);
      let r;
      if (this.returnSequences ? this.mergeMode == null ? r = [
        e,
        e
      ] : r = e : this.mergeMode == null ? r = [
        null,
        null
      ] : r = null, this.returnState) {
        const a = this.forwardLayer.states.map((s) => null);
        return Array.isArray(r) ? r.concat(a).concat(a) : [
          r
        ].concat(a).concat(a);
      } else return r;
    }
    get trainableWeights() {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    }
    get nonTrainableWeights() {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    }
    setFastWeightInitDuringBuild(t) {
      super.setFastWeightInitDuringBuild(t), this.forwardLayer != null && this.forwardLayer.setFastWeightInitDuringBuild(t), this.backwardLayer != null && this.backwardLayer.setFastWeightInitDuringBuild(t);
    }
    getConfig() {
      const t = {
        mergeMode: this.mergeMode
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    static fromConfig(t, e) {
      const r = $o(e.layer);
      if (delete e.layer, e.numConstants != null) throw new me("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
      const i = e;
      return i.layer = r, new t(i);
    }
  }
  mK.className = "Bidirectional";
  vt(mK);
  class yK extends Ce {
    constructor(t) {
      super(t), this.scale = t.scale, t.offset ? this.offset = t.offset : this.offset = 0;
    }
    getConfig() {
      const t = {
        scale: this.scale,
        offset: this.offset
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    call(t, e) {
      return tt(() => (t = ae(t), t.dtype !== "float32" && (t = Ks(t, "float32")), bt(j(t, this.scale), this.offset)));
    }
  }
  yK.className = "Rescaling";
  vt(yK);
  const { resizeBilinear: KRt, cropAndResize: ZRt } = Ao;
  class xK extends Ce {
    constructor(t) {
      super(t), this.height = t.height, this.width = t.width;
    }
    centerCrop(t, e, r, i, a, s, o, l) {
      return tt(() => {
        let u, c = false;
        const h = e / s, f = r / o, d = (i + e) / s, p = (a + r) / o, g = [
          h,
          f,
          d,
          p
        ], v = [];
        t.rank === 3 ? (c = true, u = jo([
          t
        ])) : u = t;
        for (let _ = 0; _ < u.shape[0]; _++) v.push(g);
        const m = $q(v, [
          v.length,
          4
        ]), y = dv(0, v.length, 1, "int32"), b = ZRt(u, m, y, [
          i,
          a
        ], "nearest");
        return Ks(c ? ae(ah(b)) : b, l);
      });
    }
    upsize(t, e, r, i) {
      return tt(() => {
        const a = KRt(t, [
          e,
          r
        ]);
        return Ks(a, i);
      });
    }
    call(t, e) {
      return tt(() => {
        const r = ae(t), i = r.dtype, a = r.shape, s = a[a.length - 3], o = a[a.length - 2];
        let l = 0;
        s !== this.height && (l = Math.floor((s - this.height) / 2));
        let u = 0;
        return o !== this.width && (u = Math.floor((o - this.width) / 2), u === 0 && (u = 1)), l >= 0 && u >= 0 ? this.centerCrop(r, l, u, this.height, this.width, s, o, i) : this.upsize(t, this.height, this.width, i);
      });
    }
    getConfig() {
      const t = {
        height: this.height,
        width: this.width
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = t.length - 3, r = t.length - 2;
      return t[e] = this.height, t[r] = this.width, t;
    }
  }
  xK.className = "CenterCrop";
  vt(xK);
  function JRt(n, t, e, r) {
    let i = ae(n);
    if (i.dtype !== "int32" && (i = Ks(i, "int32")), t === "int") return i;
    const a = i.shape;
    if (i.rank === 0 && (i = li(i, -1)), t === "oneHot" && i.shape[i.shape.length - 1] !== 1 && (i = li(i, -1)), i.rank > 2) throw new Y(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${i.rank}.`);
    const s = [
      "multiHot",
      "oneHot"
    ].includes(t), o = i;
    let l;
    if (typeof r < "u" && t === "count" ? l = Uz(o, r, e, s) : l = Uz(o, [], e, s), t !== "tfIdf") return l;
    if (r) return j(l, r);
    throw new Y("When outputMode is 'tfIdf', weights must be provided.");
  }
  class bK extends Ce {
    constructor(t) {
      super(t), this.numTokens = t.numTokens, t.outputMode ? this.outputMode = t.outputMode : this.outputMode = "multiHot";
    }
    getConfig() {
      const t = {
        numTokens: this.numTokens,
        outputMode: this.outputMode
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    computeOutputShape(t) {
      return t = ze(t), t == null ? [
        this.numTokens
      ] : this.outputMode === "oneHot" && t[t.length - 1] !== 1 ? (t.push(this.numTokens), t) : (t[t.length - 1] = this.numTokens, t);
    }
    call(t, e) {
      return tt(() => {
        t = ae(t), t.dtype !== "int32" && (t = Ks(t, "int32"));
        let r;
        if (typeof e.countWeights < "u") {
          if (this.outputMode !== "count") throw new Y(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);
          r = ae(e.countWeights);
        }
        const i = rs(t), a = Bb(t), s = ea(this.numTokens, i).bufferSync().get(0), o = _h(a, 0).bufferSync().get(0);
        if (!(s && o)) throw new Y(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);
        return JRt(t, this.outputMode, this.numTokens, r);
      });
    }
  }
  bK.className = "CategoryEncoding";
  vt(bK);
  const QRt = [
    "bilinear",
    "nearest"
  ], MV = new Set(QRt);
  class _K extends Ce {
    constructor(t) {
      if (super(t), this.height = t.height, this.width = t.width, t.interpolation) if (MV.has(t.interpolation)) this.interpolation = t.interpolation;
      else throw new Y(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);
      else this.interpolation = "bilinear";
      this.cropToAspectRatio = !!t.cropToAspectRatio;
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = t[2];
      return [
        this.height,
        this.width,
        e
      ];
    }
    getConfig() {
      const t = {
        height: this.height,
        width: this.width,
        interpolation: this.interpolation,
        cropToAspectRatio: this.cropToAspectRatio
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    call(t, e) {
      return tt(() => {
        const r = [
          this.height,
          this.width
        ];
        if (this.interpolation === "bilinear") return Ao.resizeBilinear(t, r, !this.cropToAspectRatio);
        if (this.interpolation === "nearest") return Ao.resizeNearestNeighbor(t, r, !this.cropToAspectRatio);
        throw new Error(`Interpolation is ${this.interpolation} but only ${[
          ...MV
        ]} are supported`);
      });
    }
  }
  _K.className = "Resizing";
  vt(_K);
  class wK {
    constructor(t) {
      this.seed = t;
    }
    next() {
      if (this.seed !== void 0) return this.seed++;
    }
  }
  wK.className = "RandomSeed";
  class SK extends Ce {
    constructor(t) {
      super(t), this.randomGenerator = new wK(t.seed);
    }
    getConfig() {
      const t = {
        seed: this.randomGenerator.seed
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
  }
  SK.className = "BaseRandomLayer";
  const tNt = [
    "bilinear",
    "nearest"
  ], RV = new Set(tNt);
  class CK extends SK {
    constructor(t) {
      super(t);
      const { factor: e, interpolation: r = "bilinear" } = t;
      if (this.factor = e, Array.isArray(this.factor) && this.factor.length === 2) this.widthLower = this.factor[0], this.widthUpper = this.factor[1];
      else if (!Array.isArray(this.factor) && this.factor > 0) this.widthLower = -this.factor, this.widthUpper = this.factor;
      else throw new Y(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);
      if (this.widthLower < -1 || this.widthUpper < -1) throw new Y(`factor must have values larger than -1. Got: ${this.factor}`);
      if (this.widthUpper < this.widthLower) throw new Y(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);
      if (r) if (RV.has(r)) this.interpolation = r;
      else throw new Y(`Invalid interpolation parameter: ${r} is not implemented`);
    }
    getConfig() {
      const t = {
        factor: this.factor,
        interpolation: this.interpolation
      }, e = super.getConfig();
      return Object.assign(t, e), t;
    }
    computeOutputShape(t) {
      t = ze(t);
      const e = t[2];
      return [
        this.imgHeight,
        -1,
        e
      ];
    }
    call(t, e) {
      return tt(() => {
        const r = ae(t);
        this.imgHeight = r.shape[r.shape.length - 3];
        const i = r.shape[r.shape.length - 2];
        this.widthFactor = Km([
          1
        ], 1 + this.widthLower, 1 + this.widthUpper, "float32", this.randomGenerator.next());
        let a = this.widthFactor.dataSync()[0] * i;
        a = Math.round(a);
        const s = [
          this.imgHeight,
          a
        ];
        switch (this.interpolation) {
          case "bilinear":
            return Ao.resizeBilinear(t, s);
          case "nearest":
            return Ao.resizeNearestNeighbor(t, s);
          default:
            throw new Error(`Interpolation is ${this.interpolation}
          but only ${[
              ...RV
            ]} are supported`);
        }
      });
    }
  }
  CK.className = "RandomWidth";
  vt(CK);
  const eNt = nt();
  eNt.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (n) => {
    n && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
  });
  var NV;
  (function(n) {
    n[n.DT_INVALID = 0] = "DT_INVALID", n[n.DT_FLOAT = 1] = "DT_FLOAT", n[n.DT_DOUBLE = 2] = "DT_DOUBLE", n[n.DT_INT32 = 3] = "DT_INT32", n[n.DT_UINT8 = 4] = "DT_UINT8", n[n.DT_INT16 = 5] = "DT_INT16", n[n.DT_INT8 = 6] = "DT_INT8", n[n.DT_STRING = 7] = "DT_STRING", n[n.DT_COMPLEX64 = 8] = "DT_COMPLEX64", n[n.DT_INT64 = 9] = "DT_INT64", n[n.DT_BOOL = 10] = "DT_BOOL", n[n.DT_QINT8 = 11] = "DT_QINT8", n[n.DT_QUINT8 = 12] = "DT_QUINT8", n[n.DT_QINT32 = 13] = "DT_QINT32", n[n.DT_BFLOAT16 = 14] = "DT_BFLOAT16", n[n.DT_QINT16 = 15] = "DT_QINT16", n[n.DT_QUINT16 = 16] = "DT_QUINT16", n[n.DT_UINT16 = 17] = "DT_UINT16", n[n.DT_COMPLEX128 = 18] = "DT_COMPLEX128", n[n.DT_HALF = 19] = "DT_HALF", n[n.DT_RESOURCE = 20] = "DT_RESOURCE", n[n.DT_VARIANT = 21] = "DT_VARIANT", n[n.DT_UINT32 = 22] = "DT_UINT32", n[n.DT_UINT64 = 23] = "DT_UINT64", n[n.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", n[n.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", n[n.DT_INT32_REF = 103] = "DT_INT32_REF", n[n.DT_UINT8_REF = 104] = "DT_UINT8_REF", n[n.DT_INT16_REF = 105] = "DT_INT16_REF", n[n.DT_INT8_REF = 106] = "DT_INT8_REF", n[n.DT_STRING_REF = 107] = "DT_STRING_REF", n[n.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", n[n.DT_INT64_REF = 109] = "DT_INT64_REF", n[n.DT_BOOL_REF = 110] = "DT_BOOL_REF", n[n.DT_QINT8_REF = 111] = "DT_QINT8_REF", n[n.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", n[n.DT_QINT32_REF = 113] = "DT_QINT32_REF", n[n.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", n[n.DT_QINT16_REF = 115] = "DT_QINT16_REF", n[n.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", n[n.DT_UINT16_REF = 117] = "DT_UINT16_REF", n[n.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", n[n.DT_HALF_REF = 119] = "DT_HALF_REF", n[n.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", n[n.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", n[n.DT_UINT32_REF = 122] = "DT_UINT32_REF", n[n.DT_UINT64_REF = 123] = "DT_UINT64_REF";
  })(NV || (NV = {}));
  var LV;
  (function(n) {
    (function(t) {
      t[t.LEGACY = 0] = "LEGACY", t[t.V1 = 1] = "V1", t[t.V2 = 2] = "V2";
    })(n.CheckpointFormatVersion || (n.CheckpointFormatVersion = {}));
  })(LV || (LV = {}));
  var PV;
  (function(n) {
    n[n.FAIL = 0] = "FAIL", n[n.SHORTEST = 1] = "SHORTEST", n[n.LONGEST = 2] = "LONGEST";
  })(PV || (PV = {}));
  function zt(n, t) {
    Array.isArray(n) || (n = [
      n
    ]), n.forEach((e) => {
      e != null && B(e.dtype !== "complex64", () => `${t} does not support complex64 tensors in the CPU backend.`);
    });
  }
  const nNt = bj;
  class Iw extends UE {
    nextDataId() {
      return Iw.nextDataId++;
    }
    constructor() {
      super(), this.blockSize = 48, this.firstUse = true, this.data = new UY(this, Es());
    }
    write(t, e, r) {
      this.firstUse && (this.firstUse = false, nt().get("IS_NODE") && Wi(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));
      const i = {
        id: this.nextDataId()
      };
      return this.data.set(i, {
        values: t,
        dtype: r,
        refCount: 1
      }), i;
    }
    makeTensorInfo(t, e, r) {
      let i;
      if (e === "string" && r != null && r.length > 0 && Jv(r[0])) {
        const a = r.map((s) => Gl(s));
        i = this.write(a, t, e);
      } else i = this.write(r, t, e);
      return {
        dataId: i,
        shape: t,
        dtype: e
      };
    }
    refCount(t) {
      return this.data.has(t) ? this.data.get(t).refCount : 0;
    }
    incRef(t) {
      const e = this.data.get(t);
      e.refCount++;
    }
    decRef(t) {
      if (this.data.has(t)) {
        const e = this.data.get(t);
        e.refCount--;
      }
    }
    move(t, e, r, i, a) {
      this.data.set(t, {
        values: e,
        dtype: i,
        refCount: a
      });
    }
    numDataIds() {
      return this.data.numDataIds();
    }
    async read(t) {
      return this.readSync(t);
    }
    readSync(t) {
      const { dtype: e, complexTensorInfos: r } = this.data.get(t);
      if (e === "complex64") {
        const i = this.readSync(r.real.dataId), a = this.readSync(r.imag.dataId);
        return Ko(i, a);
      }
      return wSt(this.data.get(t).values, e);
    }
    bufferSync(t) {
      const e = this.readSync(t.dataId);
      if (t.dtype === "string") try {
        const r = e.map((i) => tu(i));
        return we(t.shape, t.dtype, r);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return we(t.shape, t.dtype, e);
    }
    makeOutput(t, e, r) {
      return Es().makeTensorFromTensorInfo(this.makeTensorInfo(e, r, t), this);
    }
    disposeData(t, e = false) {
      if (this.data.has(t)) {
        if (this.data.get(t).refCount--, !e && this.data.get(t).refCount > 0) return false;
        const { complexTensorInfos: r } = this.data.get(t);
        r != null && (this.disposeData(r.real.dataId, true), this.disposeData(r.imag.dataId, true)), this.data.delete(t);
      }
      return true;
    }
    disposeIntermediateTensorInfo(t) {
      this.disposeData(t.dataId);
    }
    async time(t) {
      const e = si();
      return t(), {
        kernelMs: si() - e
      };
    }
    memory() {
      return {
        unreliable: true,
        reasons: [
          "The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."
        ]
      };
    }
    where(t) {
      zt([
        t
      ], "where");
      const e = this.readSync(t.dataId);
      return nNt(t.shape, e);
    }
    dispose() {
    }
    floatPrecision() {
      return 32;
    }
    epsilon() {
      return super.epsilon();
    }
  }
  Iw.nextDataId = 0;
  function TK(n) {
    const t = new Float32Array(n.length);
    for (let e = 0; e < n.length; ++e) t[e] = Math.abs(n[e]);
    return t;
  }
  const rNt = (n) => {
    const { x: t } = n.inputs, e = n.backend;
    zt(t, "abs");
    let r = new Float32Array(lt(t.shape));
    const i = e.data.get(t.dataId).values;
    return r = TK(i), e.makeOutput(r, t.shape, t.dtype);
  }, iNt = {
    kernelName: n_,
    backendName: "cpu",
    kernelFunc: rNt
  };
  function Ln(n) {
    return (t, e, r, i, a) => {
      const s = ve(t, e), o = s.length, l = Yt(s), u = lt(s), c = Dr(a, u), h = t.length, f = e.length, d = Yt(t), p = Yt(e), g = ed(t, s), v = ed(e, s);
      if (g.length + v.length === 0) for (let m = 0; m < c.length; ++m) c[m] = n(r[m % r.length], i[m % i.length]);
      else for (let m = 0; m < c.length; ++m) {
        const y = Nd(m, o, l), x = y.slice(-h);
        g.forEach((S) => x[S] = 0);
        const b = Ys(x, h, d), _ = y.slice(-f);
        v.forEach((S) => _[S] = 0);
        const w = Ys(_, f, p);
        c[m] = n(r[b], i[w]);
      }
      return [
        c,
        s
      ];
    };
  }
  function Mi(n) {
    const { inputs: t, backend: e } = n, { real: r, imag: i } = t, a = e.data.get(r.dataId).values, s = e.data.get(i.dataId).values, o = e.makeTensorInfo(r.shape, "complex64"), l = e.data.get(o.dataId);
    return l.complexTensorInfos = {
      real: e.makeTensorInfo(r.shape, "float32", a),
      imag: e.makeTensorInfo(i.shape, "float32", s)
    }, o;
  }
  const aNt = {
    kernelName: rM,
    backendName: "cpu",
    kernelFunc: Mi
  };
  function Qb(n, t, e = "float32") {
    if (e === "complex64") {
      const i = Qb(n, t, "float32"), a = Qb(n, t, "float32");
      return Mi({
        inputs: {
          real: i,
          imag: a
        },
        backend: n
      });
    }
    const r = Er(lt(t), e);
    return n.makeTensorInfo(t, e, r);
  }
  function lo(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    return e.incRef(r.dataId), {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  const sNt = {
    kernelName: xm,
    backendName: "cpu",
    kernelFunc: lo
  };
  function oh(n) {
    const { inputs: t, backend: e } = n, { input: r } = t, i = e.data.get(r.dataId).complexTensorInfos.real, a = e.data.get(i.dataId).values;
    return e.makeTensorInfo(i.shape, i.dtype, a);
  }
  const oNt = {
    kernelName: AM,
    backendName: "cpu",
    kernelFunc: oh
  };
  function IK(n, t, e, r) {
    if (r === "int32") {
      const i = Int32Array.from(n);
      return [
        t,
        "int32",
        i
      ];
    }
    if (r === "bool") {
      const i = bh([
        0
      ], e), [a, s] = Ln((o, l) => o !== l ? 1 : 0)(t, [], n, i, "bool");
      return [
        s,
        "bool",
        a
      ];
    }
    throw new Error(`Error in Cast: failed to cast ${e} to ${r}`);
  }
  function au(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { dtype: a } = r;
    if (a === "complex64") {
      if (i.dtype === "complex64") return lo({
        inputs: {
          x: i
        },
        backend: e
      });
      const c = Qb(e, i.shape, i.dtype), h = au({
        inputs: {
          x: i
        },
        backend: e,
        attrs: {
          dtype: "float32"
        }
      }), f = Mi({
        inputs: {
          real: h,
          imag: c
        },
        backend: e
      });
      return e.disposeIntermediateTensorInfo(c), e.disposeIntermediateTensorInfo(h), f;
    }
    if (i.dtype === "complex64") {
      const c = oh({
        inputs: {
          input: i
        },
        backend: e
      }), h = au({
        inputs: {
          x: c
        },
        backend: e,
        attrs: {
          dtype: a
        }
      });
      return e.disposeIntermediateTensorInfo(c), h;
    }
    if (!YY(i.dtype, a)) {
      const c = lo({
        inputs: {
          x: i
        },
        backend: e
      });
      return {
        dataId: c.dataId,
        shape: c.shape,
        dtype: a
      };
    }
    const s = e.data.get(i.dataId).values, [o, l, u] = IK(s, i.shape, i.dtype, a);
    return e.makeTensorInfo(o, l, u);
  }
  const lNt = {
    kernelName: sm,
    backendName: "cpu",
    kernelFunc: au
  };
  function Qn(n, t, e, r) {
    return e == null ? ({ inputs: i, backend: a }) => {
      const { a: s, b: o } = i, l = a;
      zt([
        s,
        o
      ], n);
      const u = l.data.get(s.dataId).values, c = l.data.get(o.dataId).values, h = s.dtype === "string" ? Zo(u) : u, f = s.dtype === "string" ? Zo(c) : c, d = r || s.dtype, [p, g] = t(s.shape, o.shape, h, f, d);
      return l.makeTensorInfo(g, d, p);
    } : ({ inputs: i, backend: a }) => {
      const { a: s, b: o } = i, l = a;
      if (s.dtype === "complex64" || o.dtype === "complex64") {
        const u = au({
          inputs: {
            x: s
          },
          backend: l,
          attrs: {
            dtype: "complex64"
          }
        }), c = l.data.get(u.dataId), h = c.complexTensorInfos.real, f = c.complexTensorInfos.imag, d = l.data.get(h.dataId).values, p = l.data.get(f.dataId).values, g = au({
          inputs: {
            x: o
          },
          backend: l,
          attrs: {
            dtype: "complex64"
          }
        }), v = l.data.get(g.dataId), m = v.complexTensorInfos.real, y = v.complexTensorInfos.imag, x = l.data.get(m.dataId).values, b = l.data.get(y.dataId).values, [_, w, S] = e(s.shape, o.shape, d, p, x, b), I = l.makeTensorInfo(S, "float32", _), T = l.makeTensorInfo(S, "float32", w), A = Mi({
          inputs: {
            real: I,
            imag: T
          },
          backend: l
        });
        return l.disposeIntermediateTensorInfo(u), l.disposeIntermediateTensorInfo(g), l.disposeIntermediateTensorInfo(I), l.disposeIntermediateTensorInfo(T), A;
      } else {
        const u = l.data.get(s.dataId).values, c = l.data.get(o.dataId).values, h = r || s.dtype, [f, d] = t(s.shape, o.shape, u, c, h);
        return l.makeTensorInfo(d, h, f);
      }
    };
  }
  function lN(n) {
    return (t, e, r, i, a, s) => {
      const o = ve(t, e), l = lt(o), u = o.length, c = Yt(o), h = Dr("float32", l), f = Dr("float32", l), d = ed(t, o), p = ed(e, o), g = Ko(r, i), v = Ko(a, s), m = t.length, y = Yt(t), x = e.length, b = Yt(e);
      if (d.length + p.length === 0) for (let _ = 0; _ < h.length; _++) {
        const w = _ % g.length, S = _ % v.length, I = n(g[w * 2], g[w * 2 + 1], v[S * 2], v[S * 2 + 1]);
        h[_] = I.real, f[_] = I.imag;
      }
      else for (let _ = 0; _ < h.length; _++) {
        const w = Nd(_, u, c), S = w.slice(-m);
        d.forEach((D) => S[D] = 0);
        const I = Ys(S, m, y), T = w.slice(-x);
        p.forEach((D) => T[D] = 0);
        const A = Ys(T, x, b), C = n(g[I * 2], g[I * 2 + 1], v[A * 2], v[A * 2 + 1]);
        h[_] = C.real, f[_] = C.imag;
      }
      return [
        h,
        f,
        o
      ];
    };
  }
  const AK = Ln((n, t) => n + t), uNt = lN((n, t, e, r) => ({
    real: n + e,
    imag: t + r
  })), id = Qn(Ld, AK, uNt), cNt = {
    kernelName: Ld,
    backendName: "cpu",
    kernelFunc: id
  };
  function uN(n, t, e, r, i) {
    const a = lt(r), s = Er(i, e);
    for (let o = 0; o < n.length; o++) {
      const l = n[o];
      if (l < 0) throw new Error("Input x must be non-negative!");
      l >= i || (a > 0 ? s[l] += t[o] : s[l] += 1);
    }
    return s;
  }
  function kK(n, t, e, r = false) {
    const i = n.shape[0], a = n.shape[1], s = we([
      i,
      e
    ], t.dtype);
    for (let o = 0; o < i; o++) for (let l = 0; l < a; l++) {
      const u = n.get(o, l);
      if (u < 0) throw new Error("Input x must be non-negative!");
      u >= e || (r ? s.set(1, o, u) : t.size > 0 ? s.set(s.get(o, u) + t.get(o, l), o, u) : s.set(s.get(o, u) + 1, o, u));
    }
    return s;
  }
  const DK = Ln((n, t) => n & t), hNt = Qn(nM, DK), fNt = {
    kernelName: nM,
    backendName: "cpu",
    kernelFunc: hNt
  };
  function fo(n) {
    return (t, e, r) => {
      const i = kn(e, t.length);
      for (let a = 0; a < t.length; ++a) i[a] = n(t[a], r);
      return i;
    };
  }
  function Qe(n, t, e) {
    const r = fo(t);
    return vu(n, r, e);
  }
  function vu(n, t, e) {
    return ({ inputs: r, attrs: i, backend: a }) => {
      const { x: s } = r;
      zt(s, n);
      const o = a, l = o.data.get(s.dataId).values;
      let u;
      if (s.dtype === "string") {
        if (!Array.isArray(l)) throw new Error("String tensor's value was not an instance of Array");
        u = Zo(l);
      } else u = l;
      const c = e || s.dtype, h = t(u, c, i);
      return o.makeTensorInfo(s.shape, c, h);
    };
  }
  const EK = fo((n) => Math.ceil(n)), dNt = vu(om, EK), pNt = {
    kernelName: om,
    backendName: "cpu",
    kernelFunc: dNt
  };
  function MK(n, t, e, r) {
    const i = kn(e, lt(t));
    if (r && e !== "string") {
      let a = 0;
      n.forEach((s) => {
        const o = lt(s.shape);
        i.set(s.vals, a), a += o;
      });
    } else {
      let a = 0;
      n.forEach((s) => {
        const o = e === "string" ? Zo(s.vals) : s.vals;
        let l = 0;
        for (let u = 0; u < s.shape[0]; ++u) {
          const c = u * t[1] + a;
          for (let h = 0; h < s.shape[1]; ++h) i[c + h] = o[l++];
        }
        a += s.shape[1];
      });
    }
    return i;
  }
  const RK = Ln((n, t) => n === t ? 1 : 0), NK = Qn(m_, RK, null, "bool"), gNt = {
    kernelName: m_,
    backendName: "cpu",
    kernelFunc: NK
  };
  const LK = fo((n) => Math.exp(n)), PK = vu(pm, LK, "float32"), vNt = {
    kernelName: pm,
    backendName: "cpu",
    kernelFunc: PK
  };
  const $K = fo((n) => Math.expm1(n)), mNt = vu(gm, $K), yNt = {
    kernelName: gm,
    backendName: "cpu",
    kernelFunc: mNt
  };
  const OK = fo((n) => Math.floor(n)), xNt = vu(vm, OK), bNt = {
    kernelName: vm,
    backendName: "cpu",
    kernelFunc: xNt
  };
  const FK = Ln((n, t) => Math.floor(n / t)), _Nt = Qn(mm, FK, null, "int32"), wNt = {
    kernelName: mm,
    backendName: "cpu",
    kernelFunc: _Nt
  };
  function BK(n, t, e, r, i, a, s, o, l) {
    const u = we([
      r,
      a
    ], e);
    for (let c = 0; c < r; c++) {
      const h = [];
      let f = 0;
      for (let d = 0; d < i; d++) {
        const p = n[c * i + d];
        f += p * s[d], h.push(p);
      }
      if (f < 0 || f >= l / a) throw new Error(`Invalid indices: ${h} does not index into ${o}`);
      for (let d = 0; d < a; d++) u.values[c * a + d] = t.get(...t.indexToLoc(f * a + d));
    }
    return u;
  }
  function zK(n, t, e) {
    const r = we(e, n.dtype);
    for (let i = 0; i < r.size; ++i) {
      const s = r.indexToLoc(i).slice(), o = s[0], l = s[2], u = t.locToIndex([
        o,
        l
      ]);
      s[2] = t.values[u];
      const c = n.locToIndex(s);
      0 <= c && c < n.values.length && (r.values[i] = n.values[c]);
    }
    return r;
  }
  const VK = Ln((n, t) => n > t ? 1 : 0), SNt = Qn(__, VK, null, "bool"), CNt = {
    kernelName: __,
    backendName: "cpu",
    kernelFunc: SNt
  };
  const GK = Ln((n, t) => n >= t ? 1 : 0), TNt = Qn(ym, GK, null, "bool"), INt = {
    kernelName: ym,
    backendName: "cpu",
    kernelFunc: TNt
  };
  const WK = Ln((n, t) => n < t ? 1 : 0), ANt = Qn(S_, WK, null, "bool"), kNt = {
    kernelName: S_,
    backendName: "cpu",
    kernelFunc: ANt
  };
  const UK = Ln((n, t) => n <= t ? 1 : 0), DNt = Qn(C_, UK, null, "bool"), ENt = {
    kernelName: C_,
    backendName: "cpu",
    kernelFunc: DNt
  };
  function HK(n, t, e) {
    const r = (t - n) / (e - 1), i = Er(e, "float32");
    i[0] = n;
    for (let a = 1; a < i.length; a++) i[a] = i[a - 1] + r;
    return i;
  }
  const XK = fo((n) => Math.log(n)), MNt = vu(Sm, XK), RNt = {
    kernelName: Sm,
    backendName: "cpu",
    kernelFunc: MNt
  };
  function YK(n, t, e, r) {
    const i = Dr(r, lt(e));
    for (let a = 0; a < i.length; ++a) {
      const s = a * t;
      let o = n[s];
      for (let l = 0; l < t; ++l) {
        const u = n[s + l];
        (Number.isNaN(u) || u > o) && (o = u);
      }
      i[a] = o;
    }
    return i;
  }
  const qK = Ln((n, t) => Math.max(n, t)), NNt = Qn(Tm, qK), LNt = {
    kernelName: Tm,
    backendName: "cpu",
    kernelFunc: NNt
  };
  const jK = Ln((n, t) => Math.min(n, t)), PNt = Qn(Im, jK), $Nt = {
    kernelName: Im,
    backendName: "cpu",
    kernelFunc: PNt
  };
  const cN = Ln((n, t) => n * t), ONt = lN((n, t, e, r) => ({
    real: n * e - t * r,
    imag: n * r + t * e
  })), Aw = Qn(km, cN, ONt), FNt = {
    kernelName: km,
    backendName: "cpu",
    kernelFunc: Aw
  };
  function KK(n, t, e) {
    const r = uu(-1, e);
    return cN([], t, r, n, e);
  }
  function BNt(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    zt(r, "neg");
    const i = e.data.get(r.dataId).values, [a, s] = KK(i, r.shape, r.dtype);
    return e.makeTensorInfo(s, r.dtype, a);
  }
  const zNt = {
    kernelName: P_,
    backendName: "cpu",
    kernelFunc: BNt
  };
  const ZK = Ln((n, t) => n !== t ? 1 : 0), VNt = Qn($_, ZK, null, "bool"), GNt = {
    kernelName: $_,
    backendName: "cpu",
    kernelFunc: VNt
  };
  function hN(n, t, e, r, i) {
    const a = t.length, s = lt(t), o = Yt(t), l = Yt(i), u = Dr(e, lt(i));
    for (let c = 0; c < s; ++c) {
      const h = Nd(c, a, o), f = new Array(h.length);
      for (let p = 0; p < f.length; p++) f[p] = h[r[p]];
      const d = Ys(f, a, l);
      u[d] = n[c];
    }
    return u;
  }
  function bi(n) {
    const { inputs: t, attrs: e, backend: r } = n, { x: i } = t, { perm: a } = e;
    zt(i, "transpose");
    const s = i.shape.length, o = new Array(s);
    for (let h = 0; h < o.length; h++) o[h] = i.shape[a[h]];
    const l = r.data.get(i.dataId).values, u = hN(l, i.shape, i.dtype, a, o);
    return {
      dataId: r.write(u, o, i.dtype),
      shape: o,
      dtype: i.dtype
    };
  }
  const WNt = {
    kernelName: Pf,
    backendName: "cpu",
    kernelFunc: bi
  };
  function JK(n, t, e, r) {
    const [i, a] = hr(n, r), s = $i(t, "int32"), o = Er(lt(i), s), l = lt(a);
    for (let u = 0; u < o.length; ++u) {
      const c = u * l;
      let h = 1;
      for (let f = 0; f < l; ++f) h *= e[c + f];
      o[u] = h;
    }
    return {
      outVals: o,
      outShape: i,
      outDtype: s
    };
  }
  function UNt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r;
    zt(i, "prod");
    const o = i.shape.length, l = Se(a, i.shape), u = wn(l, o);
    let c = l, h = i;
    const f = [];
    u != null && (h = bi({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: u
      }
    }), f.push(h), c = Rn(c.length, o));
    const d = e.data.get(h.dataId).values, { outVals: p, outShape: g, outDtype: v } = JK(h.shape, h.dtype, d, c);
    let m = g;
    return s && (m = Bn(g, l)), f.forEach((y) => e.disposeIntermediateTensorInfo(y)), e.makeTensorInfo(m, v, p);
  }
  const HNt = {
    kernelName: G_,
    backendName: "cpu",
    kernelFunc: UNt
  };
  function XNt(n, t, e) {
    n.forEach((r, i) => {
      if (r < 0 || r >= e) {
        const a = Nd(i, t.length, Yt(t)).join(",");
        throw new Error(`indices[${a}] = ${r} is not in [0, ${e})`);
      }
    });
  }
  function YNt(n, t) {
    for (let e = 0; e < n.length; ++e) {
      const r = n[e], i = e === n.length - 1 ? t : n[e + 1].length;
      if (r.length === 0) throw new Error("Ragged splits may not be empty");
      if (r[0] < 0) throw new Error("Ragged splits must be non-negative");
      if (r[r.length - 1] > i) throw new Error("Ragged splits must not point past values");
      for (let a = 1; a < r.length; ++a) if (r[a - 1] > r[a]) throw new Error("Ragged splits must be sorted in ascending order");
    }
  }
  function qNt(n, t, e, r) {
    const i = [];
    let a = 0;
    const s = t.length - 1 + e.length, o = new Array(s).fill(null).map(() => [
      0
    ]);
    YNt(e, r);
    let l = 1;
    for (let u = 0; u < t.length - 1; ++u) {
      l *= t[u];
      const c = t[u + 1];
      for (let h = 1; h < l + 1; ++h) o[u].push(h * c);
    }
    for (let u = 0; u < n.length; ++u) {
      let c = n[u], h = n[u] + 1;
      for (let f = 0; f < e.length; ++f) {
        const d = e[f], p = f + t.length - 1;
        if (p >= 0) {
          const g = o[p], v = g[g.length - 1] - d[c];
          for (let m = c; m < h; ++m) o[p].push(d[m + 1] + v);
        }
        c = d[c], h = d[h];
      }
      h !== c && (i.push([
        c,
        h
      ]), a += h - c);
    }
    return {
      outSplits: o,
      valueSlices: i,
      numValues: a
    };
  }
  function jNt(n) {
    const t = [];
    for (let e = 0; e < n.length; ++e) {
      const r = n[e].length, i = kn("int32", r);
      t.push(i), n[e].forEach((a, s) => i[s] = a);
    }
    return t;
  }
  function $V(n, t) {
    const e = n.slice(0, t);
    for (; e.length < t; ) e.push(1);
    for (let r = t; r < n.length; r++) e[t - 1] *= n[r];
    return e;
  }
  function KNt(n, t, e, r, i, a) {
    const s = $V(t, 2)[1], o = $V(a, 2)[1];
    let l = 0;
    for (const u of e) for (let c = u[0]; c < u[1]; ++c) {
      for (let h = 0; h < r; ++h) i[l * o + h] = n[c * s + h];
      ++l;
    }
  }
  function ZNt(n, t, e, r, i) {
    const a = t.slice();
    a[0] = i;
    const s = kn(e, lt(a)), o = n.length, l = o === 0 ? 0 : o / t[0];
    return KNt(n, t, r, l, s, a), [
      s,
      a
    ];
  }
  function QK(n, t, e, r, i, a, s, o) {
    if (n.length === 0) throw new Error("paramsNestedSplits must be non empty");
    if (t[0].length === 0) throw new Error("Split tensors must not be scalars");
    const l = t[0][0] - 1;
    if (XNt(a, s, l), r.length === 0) throw new Error("params.rank must be nonzero");
    const u = r[0], { outSplits: c, valueSlices: h, numValues: f } = qNt(a, s, n, u), d = jNt(c), p = ZNt(e, r, i, h, f);
    return [
      d,
      p[0],
      p[1]
    ];
  }
  const OV = 2147483647;
  function tZ(n, t, e, r, i, a, s) {
    if (t.length > 1) throw new Error("starts must be a scalar or vector");
    if (i.length > 1) throw new Error("limits must be a scalar or vector");
    if (s.length > 1) throw new Error("deltas must be a scalar or vector");
    const o = t.length === 0, l = i.length === 0, u = s.length === 0, c = [];
    o || c.push(t[0]), l || c.push(i[0]), u || c.push(s[0]);
    for (let v = 1; v < c.length; ++v) if (c[v] !== c[v - 1]) throw new Error("starts, limits, and deltas must have the same shape");
    const h = c.length === 0 ? 1 : c[0], f = kn("int32", h + 1);
    f[0] = 0;
    for (let v = 0; v < h; ++v) {
      const m = o ? n[0] : n[v], y = l ? r[0] : r[v], x = u ? a[0] : a[v];
      if (x === 0) throw new Error("Requires delta != 0");
      let b;
      if (x > 0 && y < m || x < 0 && y > m) b = 0;
      else if (b = Math.ceil(Math.abs((y - m) / x)), b > OV) throw new Error(`Requires ((limit - start) / delta) <= ${OV}`);
      f[v + 1] = f[v] + b;
    }
    const d = f[h], p = kn(e, d);
    let g = 0;
    for (let v = 0; v < h; ++v) {
      const m = f[v + 1] - f[v];
      let y = o ? n[0] : n[v];
      const x = u ? a[0] : a[v];
      for (let b = 0; b < m; ++b) p[g++] = y, y += x;
    }
    return [
      f,
      p
    ];
  }
  var la = Ya;
  class t1 {
    constructor(t, e, r, i, a, s, o, l, u, c) {
      this.shape = t, this.shapeShape = e, this.values = r, this.valuesShape = i, this.valuesDType = a, this.defaultValue = s, this.defaultValueShape = o, this.rowPartitionValues = l, this.rowPartitionValuesShapes = u, this.rowPartitionTypes = Bj(c), this.raggedRank = zj(this.rowPartitionTypes);
    }
    getRowPartitionTypeByDimension(t) {
      return this.rowPartitionTypes[0] === la.FIRST_DIM_SIZE ? this.rowPartitionTypes[t + 1] : this.rowPartitionTypes[t];
    }
    getRowPartitionTensor(t) {
      return this.rowPartitionTypes[0] === la.FIRST_DIM_SIZE ? this.rowPartitionValues[t + 1] : this.rowPartitionValues[t];
    }
    getMaxWidth(t) {
      const e = this.getRowPartitionTensor(t - 1);
      switch (this.getRowPartitionTypeByDimension(t - 1)) {
        case la.VALUE_ROWIDS:
          return t1.getMaxWidthValueRowID(e);
        case la.ROW_SPLITS:
          return t1.getMaxWidthRowSplit(e);
        default:
          throw new Error(`Cannot handle partition type ${la[this.getRowPartitionTypeByDimension(t - 1)]}`);
      }
    }
    static getMaxWidthRowSplit(t) {
      const e = t.length;
      if (e === 0 || e === 1) return 0;
      let r = 0;
      for (let i = 0; i < e - 1; ++i) {
        const a = t[i + 1] - t[i];
        a > r && (r = a);
      }
      return r;
    }
    static getMaxWidthValueRowID(t) {
      const e = t.length;
      if (e === 0) return 0;
      let r = 0, i = t[0], a = 0;
      for (let s = 1; s < e; ++s) {
        const o = t[s];
        o !== i && (i = o, a = Math.max(s - r, a), r = s);
      }
      return Math.max(e - r, a);
    }
    tensorShapeFromTensor(t, e, r = true) {
      if (e.length === 0) {
        if (t[0] === -1) return [];
        throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
      }
      return BV(t, r);
    }
    calculateOutputSize(t) {
      const e = this.valuesShape, r = this.defaultValueShape;
      Vj(r, e);
      const i = this.tensorShapeFromTensor(this.shape, this.shapeShape), s = Fj(this.raggedRank, i, e);
      s[0] < 0 && (s[0] = t);
      for (let o = 1; o <= this.raggedRank; ++o) s[o] < 0 && (s[o] = this.getMaxWidth(o));
      return s;
    }
    calculateFirstParentOutputIndex(t, e, r) {
      const i = Math.min(t, r), a = [];
      let s = 0;
      for (let o = 0; o < i; ++o, s += e) a.push(s);
      for (let o = i; o < t; ++o) a.push(-1);
      return B(a.length === t, () => "Final length of result must be equal to firstDimension."), a;
    }
    calculateOutputIndexRowSplit(t, e, r, i) {
      const a = t.length, s = [];
      for (let o = 0; o < a - 1; ++o) {
        const l = t[o + 1] - t[o];
        let u = Math.min(i, l), c = e[o];
        c === -1 && (u = 0);
        for (let h = 0; h < u; ++h) s.push(c), c += r;
        for (let h = 0; h < l - u; ++h) s.push(-1);
      }
      if (a > 0 && s.length !== t[a - 1]) throw new Error("Invalid row split size.");
      return s;
    }
    calculateOutputIndexValueRowID(t, e, r, i) {
      const a = t.length, s = [];
      if (a === 0) return [];
      let o = 0, l = t[0];
      if (l >= e.length) throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);
      let u = e[l];
      s.push(u);
      for (let c = 1; c < a; ++c) {
        const h = t[c];
        if (h === l) u >= 0 && (++o, o < i ? u += r : u = -1);
        else {
          if (o = 0, l = h, h >= e.length) throw new Error(`Got nextValueRowId=${h} which is not less than ${e.length}`);
          u = e[h];
        }
        s.push(u);
      }
      if (s.length !== t.length) throw new Error("Invalid row ids.");
      return s;
    }
    calculateOutputIndex(t, e, r, i) {
      const a = this.getRowPartitionTensor(t), s = this.getRowPartitionTypeByDimension(t);
      switch (s) {
        case la.VALUE_ROWIDS:
          return this.calculateOutputIndexValueRowID(a, e, r, i);
        case la.ROW_SPLITS:
          if (a.length - 1 > e.length) throw new Error(`Row partition size is greater than output size: ${a.length - 1} > ${e.length}`);
          return this.calculateOutputIndexRowSplit(a, e, r, i);
        default:
          throw new Error(`Unsupported partition type: ${la[s]}`);
      }
    }
    getFirstDimensionSize() {
      const t = this.rowPartitionValues[0];
      if (this.rowPartitionTypes.length === 0) throw new Error("No row_partition_types given.");
      const e = this.rowPartitionTypes[0];
      switch (e) {
        case la.FIRST_DIM_SIZE:
          return t[0];
        case la.VALUE_ROWIDS:
          throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
        case la.ROW_SPLITS:
          return this.rowPartitionValuesShapes[0][0] - 1;
        default:
          throw new Error(`Cannot handle type ${la[e]}`);
      }
    }
    compute() {
      if (this.rowPartitionValues[0].length <= 0) throw new Error("Invalid first partition input. Tensor requires at least one element.");
      const e = this.getFirstDimensionSize(), r = this.calculateOutputSize(e), i = new Array(this.raggedRank + 1);
      i[i.length - 1] = 1;
      for (let l = i.length - 2; l >= 0; --l) i[l] = i[l + 1] * r[l + 1];
      const a = BV(r, false), s = kn(this.valuesDType, lt(a));
      if (i[0] * r[0] > 0) {
        let l = this.calculateFirstParentOutputIndex(e, i[0], r[0]);
        for (let u = 1; u <= this.raggedRank; ++u) l = this.calculateOutputIndex(u - 1, l, i[u], r[u]);
        this.setOutput(this.raggedRank, l, s, a);
      }
      return [
        a,
        s
      ];
    }
    setOutput(t, e, r, i) {
      if (r.length === 0) return;
      const a = this.values, s = r;
      let o = i.slice();
      o = o.slice(t + 1);
      const l = lt(o), u = e.length;
      let c = this.defaultValue;
      if (c.length !== l && c.length !== 1) {
        const p = this.defaultValueShape;
        tt(() => {
          const g = Z(c, p);
          c = wg(g, o).dataSync();
        });
      }
      let h = 0, f = 0, d = 0;
      for (let p = 0; p <= u; ++p) {
        let g = p < u ? e[p] : -1;
        if (g === d) {
          ++d;
          continue;
        }
        if (f < d) {
          const v = a.subarray(h * l), m = s.subarray(f * l), y = (d - f) * l;
          FV(m, v, y);
        }
        if (p >= u) {
          const v = r.length;
          g = Math.floor(v / l);
        }
        if (g > d) if (this.defaultValue.length === 1) s.subarray(d * l, g * l).fill(this.defaultValue[0]), d = g;
        else for (; g > d; ) {
          const v = s.slice(d * l);
          FV(v, c, l), ++d;
        }
        g < 0 ? (h = p + 1, f = d) : (h = p, f = d, d = f + 1);
      }
    }
  }
  function FV(n, t, e) {
    for (let r = 0; r < e; r++) n[r] = t[r];
  }
  function BV(n, t) {
    const e = [];
    for (let r of n) {
      if (r < 0) {
        if (!t) throw new Error(`Dimension ${r} must be >= 0`);
        if (r < -1) throw new Error(`Dimension ${r} must be >= -1`);
        r = -1;
      }
      e.push(r);
    }
    return e;
  }
  function eZ(n, t, e, r, i, a, s, o, l, u) {
    return new t1(n, t, e, r, i, a, s, o, l, u).compute();
  }
  function nZ(n, t, e, r) {
    const i = n === t, a = n < t && e < 0, s = t < n && e > 1;
    if (i || a || s) return Er(0, r);
    const o = Math.abs(Math.ceil((t - n) / e)), l = Er(o, r);
    t < n && e === 1 && (e = -1), l[0] = n;
    for (let u = 1; u < l.length; u++) l[u] = l[u - 1] + e;
    return l;
  }
  const rZ = fo((n) => 1 / Math.sqrt(n)), JNt = vu(Lm, rZ), QNt = {
    kernelName: Lm,
    backendName: "cpu",
    kernelFunc: JNt
  };
  function Tc(n, t, e, r, i, a, s, o, l, u) {
    const c = [
      r / i,
      i
    ], h = n.values, f = t.values;
    if (r === 0) return we(e, t.dtype);
    const d = l instanceof xr ? l : we(c, t.dtype);
    typeof l == "string" || typeof l == "number" ? d.values.fill(l) : typeof l == "boolean" && d.values.fill(+l);
    for (let p = 0; p < a; p++) {
      const g = [];
      let v = 0;
      for (let m = 0; m < s; m++) {
        const y = h[p * s + m];
        g.push(y), v += y * o[m];
      }
      if (v < 0 || v >= r / i) throw new Error(`Invalid indices: ${g} does not index into ${e}`);
      for (let m = 0; m < i; m++) u ? d.values[v * i + m] += f[p * i + m] : d.values[v * i + m] = t.rank === 0 ? f[0] : f[p * i + m];
    }
    return d;
  }
  const tLt = fo((n) => 1 / (1 + Math.exp(-n))), iZ = Qe(Bm, (n) => 1 / (1 + Math.exp(-n))), eLt = {
    kernelName: Bm,
    backendName: "cpu",
    kernelFunc: iZ
  };
  function aZ(n, t, e, r, i) {
    const a = yR(r, t, e), s = lt(e), o = Yt(r);
    if (a) {
      const h = xR(t, o);
      return i === "string" ? n.slice(h, h + s) : n.subarray(h, h + s);
    }
    const l = i === "string" ? Zo(n) : n, u = we(r, i, l), c = we(e, i);
    for (let h = 0; h < c.size; ++h) {
      const f = c.indexToLoc(h), d = f.map((p, g) => p + t[g]);
      c.set(u.get(...d), ...f);
    }
    return i === "string" ? o7(c.values) : c.values;
  }
  function lh(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { begin: a, size: s } = r;
    zt(i, "slice");
    const [o, l] = fw(i, a, s);
    vR(i, o, l);
    const u = e.data.get(i.dataId).values, c = aZ(u, o, l, i.shape, i.dtype);
    return e.makeTensorInfo(l, i.dtype, c);
  }
  const nLt = {
    kernelName: q_,
    backendName: "cpu",
    kernelFunc: lh
  };
  function sZ(n, t, e, r, i, a, s) {
    const o = t[0], l = a[0], u = new Array(l), c = new Array(o), h = t[1];
    if (l === 0) {
      if (o !== 0) throw new Error(qj(o));
      const v = kn(e, 0), m = kn(i, 0);
      return [
        v,
        [
          0,
          h
        ],
        m,
        u,
        c
      ];
    }
    let f = true, d = 0;
    const p = new Array(l).fill(0);
    for (let v = 0; v < o; ++v) {
      const m = n[v * h];
      if (m < 0) throw new Error(jj(v, m));
      if (m >= l) throw new Error(Kj(v, m, l));
      ++p[m], f = f && m >= d, d = m;
    }
    let g = true;
    for (let v = 0; v < l; ++v) {
      const m = p[v] === 0;
      u[v] = m, g = g && !m, p[v] = Math.max(p[v], 1), v > 0 && (p[v] += p[v - 1]);
    }
    if (g && f) {
      const v = n, m = r;
      for (let y = 0; y < o; ++y) c[y] = y;
      return [
        v,
        [
          o,
          h
        ],
        m,
        u,
        c
      ];
    } else {
      const v = p[l - 1], m = kn(e, v * h), y = kn(i, v), x = new Array(l).fill(0);
      for (let b = 0; b < o; ++b) {
        const _ = n[b * h], w = x[_], S = (_ === 0 ? 0 : p[_ - 1]) + w;
        x[_]++;
        for (let I = 0; I < h; ++I) m[S * h + I] = n[b * h + I];
        y[S] = r[b], c[b] = S;
      }
      for (let b = 0; b < l; ++b) if (x[b] === 0) {
        const w = b === 0 ? 0 : p[b - 1];
        m[w * h + 0] = b;
        for (let S = 1; S < h; ++S) m[w * h + S] = 0;
        y[w] = s;
      }
      return [
        m,
        [
          v,
          h
        ],
        y,
        u,
        c
      ];
    }
  }
  function oZ(n, t, e, r, i) {
    const a = lt(r), s = t[0], o = i.length, l = [];
    let u = 1, c = -1;
    for (let v = 0; v < o; ++v) {
      const m = i[v];
      if (m === -1) {
        if (c !== -1) throw new Error(Zj(c, v));
        c = v, l.push(1);
      } else {
        if (m < 0) throw new Error(Jj(v, m));
        u *= m, l.push(m);
      }
    }
    if (c !== -1) {
      if (u <= 0) throw new Error(Qj());
      const v = Math.trunc(a / u);
      if (u * v !== a) throw new Error(t7(r, l));
      l[c] = v;
    }
    if (lt(l) !== a) throw new Error(e7(r, l));
    const f = r.length, d = [];
    if (f > 0) {
      d[f - 1] = 1;
      for (let v = f - 2; v >= 0; --v) d[v] = d[v + 1] * r[v + 1];
    }
    const p = [];
    if (o > 0) {
      p[o - 1] = 1;
      for (let v = o - 2; v >= 0; --v) p[v] = p[v + 1] * l[v + 1];
    }
    const g = kn(e, s * o);
    for (let v = 0; v < s; ++v) {
      let m = 0;
      for (let y = 0; y < f; ++y) m += n[v * f + y] * d[y];
      for (let y = 0; y < o; ++y) g[v * o + y] = Math.trunc(m / p[y]), m %= p[y];
    }
    return [
      g,
      [
        s,
        o
      ],
      l
    ];
  }
  function fN(n, t, e, r, i, a = false, s = 0) {
    const o = r.length, l = [
      t[0],
      n.length / t[0]
    ], u = l[1], h = o > 0 ? i[o - 1] + 1 : 0;
    if (h < 0) throw new Error(R2());
    const f = t.slice();
    f[0] = h;
    const d = f.reduce((x, b) => x * b, 1), p = kn(e, d);
    if (o === 0) return h > 0 && p.fill(s), [
      p,
      f
    ];
    if (h <= 0) throw new Error(R2());
    let g = 0, v = 1, m = 0, y = i[g];
    for (; ; ) {
      let x = 0;
      if (v < o) {
        if (x = i[v], y === x) {
          ++v;
          continue;
        }
        if (y >= x) throw new Error(n7());
      }
      if (y < 0 || y >= h) throw new Error(r7(y, h));
      y > m && p.fill(s, m * u, y * u);
      for (let b = g; b < v; ++b) {
        const _ = r[b];
        if (_ < 0 || _ >= l[0]) throw new Error(i7(b, r[b], l[0]));
        for (let w = 0; w < u; w++) p[y * u + w] += n[_ * u + w];
      }
      if (a) for (let b = 0; b < u; b++) p[y * u + b] /= v - g;
      if (g = v, ++v, m = y + 1, y = x, v > o) break;
    }
    return m < h && p.fill(s, m * u, h * u), [
      p,
      f
    ];
  }
  const rLt = fo((n) => Math.sqrt(n)), iLt = Qe(Vm, (n) => Math.sqrt(n)), aLt = {
    kernelName: Vm,
    backendName: "cpu",
    kernelFunc: iLt
  };
  const lZ = Ln((n, t) => {
    const e = n - t;
    return e * e;
  }), sLt = Qn(Gm, lZ), oLt = {
    kernelName: Gm,
    backendName: "cpu",
    kernelFunc: sLt
  };
  const uZ = fo((n, t) => {
    const { pattern: e, replaceGlobal: r, rewrite: i } = t;
    return n.replace(new RegExp(e, r ? "g" : ""), i);
  }), lLt = vu(MM, uZ), uLt = {
    kernelName: MM,
    backendName: "cpu",
    kernelFunc: lLt
  };
  function cZ(n, t, e, r) {
    const i = we(n, t.dtype);
    for (let a = 0; a < i.size; a++) {
      const s = i.indexToLoc(a), o = new Array(s.length);
      for (let l = 0; l < o.length; l++) o[l] = s[l] * e[l] + r[l];
      i.set(t.get(...o), ...s);
    }
    return i;
  }
  class cLt {
    constructor(t, e, r, i, a, s) {
      this.separator = Gl(t), this.nGramWidths = e, this.leftPad = Gl(r), this.rightPad = Gl(i), this.padWidth = a, this.preserveShort = s;
    }
    getPadWidth(t) {
      return Math.min(this.padWidth < 0 ? t - 1 : this.padWidth, t - 1);
    }
    getNumNGrams(t, e) {
      const r = this.getPadWidth(e);
      return Math.max(0, t + 2 * r - e + 1);
    }
    createNGrams(t, e, r, i, a, s) {
      for (let o = 0; o < a; ++o) {
        const l = this.getPadWidth(s), u = Math.max(0, l - o), c = Math.max(0, l - (a - (o + 1))), h = s - (u + c), f = e + (u > 0 ? 0 : o - l);
        let d = 0;
        d += u * this.leftPad.length;
        for (let y = 0; y < h; ++y) d += t[f + y].length;
        d += c * this.rightPad.length;
        const p = u + c + h - 1;
        d += p * this.separator.length, r[i + o] = new Uint8Array(d);
        const g = r[i + o];
        let v = 0;
        const m = (y) => y.forEach((x) => g[v++] = x);
        for (let y = 0; y < u; ++y) m(this.leftPad), m(this.separator);
        for (let y = 0; y < h - 1; ++y) m(t[f + y]), m(this.separator);
        if (h > 0) {
          m(t[f + h - 1]);
          for (let y = 0; y < c; ++y) m(this.separator), m(this.rightPad);
        } else {
          for (let y = 0; y < c - 1; ++y) m(this.rightPad), m(this.separator);
          m(this.rightPad);
        }
      }
    }
    compute(t, e) {
      const r = t.length, i = e.length;
      if (i > 0) {
        let l = e[0];
        if (l !== 0) throw new Error(`First split value must be 0, got ${l}`);
        for (let u = 1; u < i; ++u) {
          let c = e[u] >= l;
          if (c = c && e[u] <= r, !c) throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${r}]`);
          l = e[u];
        }
        if (l !== r) throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`);
      }
      const a = i - 1, s = kn("int32", i);
      if (r === 0 || i === 0) {
        const l = new Array(r);
        for (let u = 0; u <= a; ++u) s[u] = 0;
        return [
          l,
          s
        ];
      }
      s[0] = 0;
      for (let l = 1; l <= a; ++l) {
        const u = e[l] - e[l - 1];
        let c = 0;
        this.nGramWidths.forEach((h) => {
          c += this.getNumNGrams(u, h);
        }), this.preserveShort && u > 0 && c === 0 && (c = 1), s[l] = s[l - 1] + c;
      }
      const o = new Array(s[a]);
      for (let l = 0; l < a; ++l) {
        const u = e[l];
        let c = s[l];
        if (this.nGramWidths.forEach((h) => {
          const f = e[l + 1] - e[l], d = this.getNumNGrams(f, h);
          this.createNGrams(t, u, o, c, d, h), c += d;
        }), this.preserveShort && c === s[l]) {
          const h = e[l + 1] - e[l];
          if (h === 0) continue;
          const f = h + 2 * this.padWidth;
          this.createNGrams(t, u, o, c, 1, f);
        }
      }
      return [
        o,
        s
      ];
    }
  }
  function hZ(n, t, e, r, i, a, s, o) {
    return new cLt(e, r, i, a, s, o).compute(n, t);
  }
  function hLt(n, t, e, r) {
    if (!n.length) return;
    if (t.length === 0) {
      for (let a = 0; a < n.length; ++a) r.push(n.subarray(a, a + 1));
      return;
    }
    if (t.length === 1) {
      const a = t[0];
      let s = n.indexOf(a);
      for (; s !== -1; ) {
        const o = n.subarray(0, s);
        (!e || o.length !== 0) && r.push(o), n = n.subarray(s + 1), s = n.indexOf(a);
      }
      (!e || n.length !== 0) && r.push(n);
      return;
    }
    let i = 0;
    for (let a = 0; a < n.length + 1; a++) if (a === n.length || t.indexOf(n[a]) !== -1) {
      const s = n.subarray(i, a);
      (!e || s.length !== 0) && r.push(s), i = a + 1;
    }
  }
  function fZ(n, t, e) {
    const r = n.length, i = [];
    let a = 0, s = 0;
    const o = new Array(r);
    for (let f = 0; f < r; ++f) {
      const d = i.length;
      hLt(n[f], t, e, i);
      const p = i.length - d;
      o[f] = p, a += p, s = Math.max(s, p);
    }
    const l = kn("int32", a * 2), u = new Array(a), c = [
      r,
      s
    ];
    let h = 0;
    for (let f = 0; f < r; ++f) for (let d = 0; d < o[f]; ++d) l[h * 2] = f, l[h * 2 + 1] = d, u[h] = i[h], ++h;
    return [
      l,
      u,
      c
    ];
  }
  function dZ(n, t) {
    const e = kn("int32", n.length);
    for (let r = 0; r < n.length; ++r) e[r] = GSt(n[r]).modulo(t).getLowBitsUnsigned();
    return e;
  }
  const pZ = Ln((n, t) => n - t), fLt = lN((n, t, e, r) => ({
    real: n - e,
    imag: t - r
  })), dN = Qn(Wm, pZ, fLt), dLt = {
    kernelName: Wm,
    backendName: "cpu",
    kernelFunc: dN
  };
  function gZ(n, t) {
    const e = new Array(n.rank);
    for (let i = 0; i < e.length; i++) e[i] = n.shape[i] * t[i];
    const r = we(e, n.dtype);
    for (let i = 0; i < r.values.length; ++i) {
      const a = r.indexToLoc(i), s = new Array(n.rank);
      for (let l = 0; l < s.length; l++) s[l] = a[l] % n.shape[l];
      const o = n.locToIndex(s);
      r.values[i] = n.values[o];
    }
    return r;
  }
  const Qp = (n, t) => {
    const e = t.value - n.value;
    return e === 0 ? n.index - t.index : e;
  };
  function vZ(n, t, e = 0, r = n.length - 1) {
    for (; r > e; ) {
      if (r - e > 600) {
        const o = r - e + 1, l = t - e + 1, u = Math.log(o), c = 0.5 * Math.exp(2 * u / 3), h = 0.5 * Math.sqrt(u * c * (o - c) / o) * Math.sign(l - o / 2), f = Math.max(e, Math.floor(t - l * c / o + h)), d = Math.min(r, Math.floor(t + (o - l) * c / o + h));
        vZ(n, t, f, d);
      }
      const i = n[t];
      let a = e, s = r;
      for (gf(n, e, t), Qp(n[r], i) > 0 && gf(n, e, r); a < s; ) {
        for (gf(n, a, s), a++, s--; Qp(n[a], i) < 0; ) a = a + 1;
        for (; Qp(n[s], i) > 0; ) s = s - 1;
      }
      Qp(n[e], i) === 0 ? gf(n, e, s) : (s = s + 1, gf(n, s, r)), s <= t && (e = s + 1), t <= s && (r = s - 1);
    }
  }
  function mZ(n, t, e, r, i) {
    const a = t[t.length - 1], [s, o] = [
      n.length / a,
      a
    ], l = Dr(e, s * r), u = Dr("int32", s * r);
    for (let h = 0; h < s; h++) {
      const f = h * o, d = n.subarray(f, f + o);
      let p = new Array(d.length);
      d.forEach((y, x) => p[x] = {
        value: y,
        index: x
      }), r < p.length && (vZ(p, r), p = p.slice(0, r)), i && p.sort(Qp);
      const g = h * r, v = l.subarray(g, g + r), m = u.subarray(g, g + r);
      for (let y = 0; y < r; y++) v[y] = p[y].value, m[y] = p[y].index;
    }
    const c = t.slice();
    return c[c.length - 1] = r, [
      we(c, e, l),
      we(c, "int32", u)
    ];
  }
  function yZ(n, t, e, r) {
    const i = Se(t, e)[0], a = [
      1,
      e[0],
      1
    ];
    for (let p = 0; p < i; p++) a[0] *= e[p];
    a[1] = e[i];
    for (let p = i + 1; p < e.length; p++) a[2] *= e[p];
    const s = /* @__PURE__ */ new Map(), o = new Int32Array(e[i]), l = new xr(a, r, n), u = [], c = a[0] === 1 && a[2] === 1;
    for (let p = 0; p < e[i]; p++) {
      let g;
      if (c) g = n[p].toString();
      else {
        const m = [];
        for (let y = 0; y < a[0]; y++) for (let x = 0; x < a[2]; x++) m.push(l.get(y, p, x));
        g = m.join(",");
      }
      const v = s.get(g);
      if (v != null) o[p] = v;
      else {
        const m = s.size;
        s.set(g, m), o[p] = m, u.push(p);
      }
    }
    const h = a.slice();
    h[1] = s.size;
    const f = new xr(h, r);
    u.forEach((p, g) => {
      for (let v = 0; v < a[0]; v++) for (let m = 0; m < a[2]; m++) f.set(l.get(v, p, m), v, g, m);
    });
    const d = e.slice();
    return d[i] = h[1], {
      outputValues: f.values,
      outputShape: d,
      indices: o
    };
  }
  const pLt = Object.freeze(Object.defineProperty({
    __proto__: null,
    addImpl: AK,
    bincountImpl: uN,
    bincountReduceImpl: kK,
    bitwiseAndImpl: DK,
    castImpl: IK,
    ceilImpl: EK,
    concatImpl: MK,
    equalImpl: RK,
    expImpl: LK,
    expm1Impl: $K,
    floorDivImpl: FK,
    floorImpl: OK,
    gatherNdImpl: BK,
    gatherV2Impl: zK,
    greaterEqualImpl: GK,
    greaterImpl: VK,
    lessEqualImpl: UK,
    lessImpl: WK,
    linSpaceImpl: HK,
    logImpl: XK,
    maxImpl: YK,
    maximumImpl: qK,
    minimumImpl: jK,
    multiplyImpl: cN,
    negImpl: KK,
    notEqualImpl: ZK,
    prodImpl: JK,
    raggedGatherImpl: QK,
    raggedRangeImpl: tZ,
    raggedTensorToTensorImpl: eZ,
    rangeImpl: nZ,
    rsqrtImpl: rZ,
    scatterImpl: Tc,
    sigmoidImpl: tLt,
    simpleAbsImpl: TK,
    sliceImpl: aZ,
    sparseFillEmptyRowsImpl: sZ,
    sparseReshapeImpl: oZ,
    sparseSegmentReductionImpl: fN,
    sqrtImpl: rLt,
    squaredDifferenceImpl: lZ,
    staticRegexReplaceImpl: uZ,
    stridedSliceImpl: cZ,
    stringNGramsImpl: hZ,
    stringSplitImpl: fZ,
    stringToHashBucketFastImpl: dZ,
    subImpl: pZ,
    tileImpl: gZ,
    topKImpl: mZ,
    transposeImpl: hN,
    uniqueImpl: yZ
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  Oq("cpu", () => new Iw(), 1);
  const xZ = Qe(fm, (n) => n >= 0 ? n : Math.exp(n) - 1), gLt = {
    kernelName: fm,
    backendName: "cpu",
    kernelFunc: xZ
  };
  function bZ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { alpha: a } = r;
    zt([
      i
    ], "leakyRelu");
    const s = lt(i.shape), o = e.data.get(i.dataId).values, l = Dr("float32", s);
    for (let u = 0; u < o.length; u++) l[u] = o[u] < 0 ? a * o[u] : o[u];
    return e.makeTensorInfo(i.shape, "float32", l);
  }
  const vLt = {
    kernelName: w_,
    backendName: "cpu",
    kernelFunc: bZ
  };
  const mLt = Ln((n, t) => n < 0 ? t * n : n);
  function _Z(n) {
    const { inputs: t, backend: e } = n, { x: r, alpha: i } = t;
    zt([
      r,
      i
    ], "prelu");
    const a = e.data.get(r.dataId).values, s = e.data.get(i.dataId).values, [o, l] = mLt(r.shape, i.shape, a, s, "float32");
    return e.makeTensorInfo(l, "float32", o);
  }
  const yLt = {
    kernelName: V_,
    backendName: "cpu",
    kernelFunc: _Z
  };
  const wZ = Qe(Mm, (n) => Math.max(0, n)), xLt = {
    kernelName: Mm,
    backendName: "cpu",
    kernelFunc: wZ
  };
  const SZ = Qe(Rm, (n) => Math.min(Math.max(0, n), 6)), bLt = {
    kernelName: Rm,
    backendName: "cpu",
    kernelFunc: SZ
  };
  function e1(n, t, e, r, i) {
    if (e === "linear") return lo({
      inputs: {
        x: t
      },
      backend: n
    });
    if (e === "relu") return wZ({
      inputs: {
        x: t
      },
      backend: n
    });
    if (e === "elu") return xZ({
      inputs: {
        x: t
      },
      backend: n
    });
    if (e === "relu6") return SZ({
      inputs: {
        x: t
      },
      backend: n
    });
    if (e === "prelu") return _Z({
      inputs: {
        x: t,
        alpha: r
      },
      backend: n
    });
    if (e === "leakyrelu") return bZ({
      inputs: {
        x: t
      },
      backend: n,
      attrs: {
        alpha: i
      }
    });
    if (e === "sigmoid") return iZ({
      inputs: {
        x: t
      },
      backend: n
    });
    throw new Error(`Activation ${e} has not been implemented for the CPU backend.`);
  }
  function pn(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { shape: a } = r, s = lt(i.shape), o = XY(a, s), l = lt(o);
    B(s === l, () => `The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`), e.incRef(i.dataId);
    const u = e.data.get(i.dataId);
    if (u.complexTensorInfos != null) {
      const c = u.complexTensorInfos.real, h = u.complexTensorInfos.imag;
      c.shape = o, h.shape = o;
    }
    return {
      dataId: i.dataId,
      shape: o,
      dtype: i.dtype
    };
  }
  const _Lt = {
    kernelName: W_,
    backendName: "cpu",
    kernelFunc: pn
  };
  function CZ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { a: i, b: a } = t, { transposeA: s, transposeB: o } = r;
    zt([
      i,
      a
    ], "matMul");
    const l = i.shape.length, u = a.shape.length, c = s ? i.shape[l - 2] : i.shape[l - 1], h = o ? a.shape[u - 1] : a.shape[u - 2], f = s ? i.shape[l - 1] : i.shape[l - 2], d = o ? a.shape[u - 2] : a.shape[u - 1], p = i.shape.slice(0, -2), g = a.shape.slice(0, -2), v = lt(p), m = lt(g), x = ve(i.shape.slice(0, -2), a.shape.slice(0, -2)).concat([
      f,
      d
    ]);
    B(c === h, () => `Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${s} and transposeB=${o} must match.`);
    const b = s ? [
      v,
      c,
      f
    ] : [
      v,
      f,
      c
    ], _ = o ? [
      m,
      d,
      h
    ] : [
      m,
      h,
      d
    ], w = pn({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: b
      }
    }), S = pn({
      inputs: {
        x: a
      },
      backend: e,
      attrs: {
        shape: _
      }
    }), I = s ? w.shape[1] : w.shape[2], T = s ? w.shape[2] : w.shape[1], A = o ? S.shape[1] : S.shape[2], C = Math.max(v, m), D = e.data.get(w.dataId).values, E = e.data.get(S.dataId).values, M = Yt(w.shape), L = Yt(S.shape), [k, N, R] = s ? [
      M[0],
      1,
      M[1]
    ] : [
      M[0],
      M[1],
      1
    ], [$, O, F] = o ? [
      1,
      L[1],
      L[0]
    ] : [
      L[1],
      1,
      L[0]
    ], z = T * A, V = we([
      C,
      T,
      A
    ], w.dtype), U = V.values, X = e.blockSize;
    for (let at = 0; at < C; at++) {
      const pt = at % v, it = at % m;
      for (let et = 0; et < T; et += X) {
        const ft = Math.min(et + X, T);
        for (let ut = 0; ut < A; ut += X) {
          const gt = Math.min(ut + X, A);
          for (let kt = 0; kt < I; kt += X) {
            const At = Math.min(kt + X, I);
            for (let mt = et; mt < ft; mt++) for (let _t = ut; _t < gt; _t++) {
              let ee = 0;
              for (let G = kt; G < At; G++) {
                const H = D[pt * k + mt * N + G * R], dt = E[G * $ + _t * O + it * F];
                ee += H * dt;
              }
              U[at * z + (mt * A + _t)] += ee;
            }
          }
        }
      }
    }
    return e.disposeIntermediateTensorInfo(w), e.disposeIntermediateTensorInfo(S), e.makeTensorInfo(x, V.dtype, V.values);
  }
  const wLt = {
    kernelName: o_,
    backendName: "cpu",
    kernelFunc: CZ
  };
  function SLt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { a: i, b: a, bias: s, preluActivationWeights: o } = t, { transposeA: l, transposeB: u, activation: c, leakyreluAlpha: h } = r;
    let f, d, p;
    const g = [];
    f = CZ({
      inputs: {
        a: i,
        b: a
      },
      attrs: {
        transposeA: l,
        transposeB: u
      },
      backend: e
    }), s && (d = id({
      inputs: {
        a: f,
        b: s
      },
      backend: e
    }), g.push(f), f = d), c && (p = e1(e, f, c, o, h), g.push(f), f = p);
    for (const m of g) e.disposeIntermediateTensorInfo(m);
    return f;
  }
  const CLt = {
    kernelName: Pb,
    backendName: "cpu",
    kernelFunc: SLt
  };
  const TLt = Qe(Qv, (n) => Math.acos(n)), ILt = {
    kernelName: Qv,
    backendName: "cpu",
    kernelFunc: TLt
  };
  const ALt = Qe(tm, (n) => Math.acosh(n)), kLt = {
    kernelName: tm,
    backendName: "cpu",
    kernelFunc: ALt
  };
  function DLt(n) {
    const { inputs: t, backend: e } = n, r = t;
    zt(t, "addN");
    const i = r.map((o) => e.data.get(o.dataId).values), a = we(r[0].shape, r[0].dtype), s = a.values;
    for (let o = 0; o < r.length; o++) {
      const l = i[o];
      for (let u = 0; u < s.length; u++) s[u] += l[u];
    }
    return e.makeTensorInfo(a.shape, a.dtype, a.values);
  }
  const ELt = {
    kernelName: KE,
    backendName: "cpu",
    kernelFunc: DLt
  };
  function MLt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r;
    zt(i, "all");
    const o = Se(a, i.shape);
    let l = o;
    const u = wn(l, i.shape.length);
    let c = i;
    u != null && (c = bi({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: u
      }
    }), l = Rn(l.length, i.shape.length)), wr("all", l, c.shape.length);
    const [h, f] = hr(c.shape, l), d = lt(f), p = Er(lt(h), c.dtype), g = e.data.get(c.dataId).values;
    for (let m = 0; m < p.length; ++m) {
      const y = m * d;
      let x = g[y];
      for (let b = 0; b < d; ++b) {
        const _ = g[y + b];
        x = x && _;
      }
      p[m] = x;
    }
    u != null && e.disposeIntermediateTensorInfo(c);
    const v = e.makeTensorInfo(h, c.dtype, p);
    if (s) {
      const m = Bn(h, o), y = pn({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          shape: m
        }
      });
      return e.disposeIntermediateTensorInfo(v), y;
    }
    return v;
  }
  const RLt = {
    kernelName: ZE,
    backendName: "cpu",
    kernelFunc: MLt
  };
  function NLt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r;
    zt(i, "any");
    const o = Se(a, i.shape);
    let l = o;
    const u = wn(l, i.shape.length);
    let c = i;
    u != null && (c = bi({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: u
      }
    }), l = Rn(l.length, i.shape.length)), wr("any", l, c.shape.length);
    const [h, f] = hr(c.shape, l), d = lt(f), p = Er(lt(h), c.dtype), g = e.data.get(c.dataId).values;
    for (let m = 0; m < p.length; ++m) {
      const y = m * d;
      let x = g[y];
      for (let b = 0; b < d; ++b) {
        const _ = g[y + b];
        x = x || _;
      }
      p[m] = x;
    }
    u != null && e.disposeIntermediateTensorInfo(c);
    const v = e.makeTensorInfo(h, c.dtype, p);
    if (s) {
      const m = Bn(h, o), y = pn({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          shape: m
        }
      });
      return e.disposeIntermediateTensorInfo(v), y;
    }
    return v;
  }
  const LLt = {
    kernelName: JE,
    backendName: "cpu",
    kernelFunc: NLt
  };
  function PLt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a } = r;
    zt(i, "argMax");
    let s = Se(a, i.shape);
    const o = wn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = bi({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: o
      }
    }), u.push(l), s = Rn(s.length, l.shape.length)), s = [
      s[0]
    ], wr("argMax", s, l.shape.length);
    const [c, h] = hr(l.shape, s), f = lt(c), d = Er(f, "int32"), p = lt(h), g = e.data.get(l.dataId).values;
    for (let v = 0; v < d.length; ++v) {
      const m = v * p;
      let y = g[m], x = 0;
      for (let b = 0; b < p; ++b) {
        const _ = g[m + b];
        _ > y && (y = _, x = b);
      }
      d[v] = x;
    }
    return u.forEach((v) => e.disposeIntermediateTensorInfo(v)), e.makeTensorInfo(c, "int32", d);
  }
  const $Lt = {
    kernelName: r_,
    backendName: "cpu",
    kernelFunc: PLt
  };
  function OLt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a } = r;
    zt(i, "argMin");
    let s = Se(a, i.shape);
    const o = wn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = bi({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: o
      }
    }), u.push(l), s = Rn(s.length, l.shape.length)), s = [
      s[0]
    ], wr("argMin", s, l.shape.length);
    const [c, h] = hr(l.shape, s), f = lt(c), d = Er(f, "int32"), p = lt(h), g = e.data.get(l.dataId).values;
    for (let v = 0; v < d.length; ++v) {
      const m = v * p;
      let y = g[m], x = 0;
      for (let b = 0; b < p; ++b) {
        const _ = g[m + b];
        _ < y && (y = _, x = b);
      }
      d[v] = x;
    }
    return u.forEach((v) => e.disposeIntermediateTensorInfo(v)), e.makeTensorInfo(c, "int32", d);
  }
  const FLt = {
    kernelName: i_,
    backendName: "cpu",
    kernelFunc: OLt
  };
  const BLt = Qe(em, (n) => Math.asin(n)), zLt = {
    kernelName: em,
    backendName: "cpu",
    kernelFunc: BLt
  };
  const VLt = Qe(nm, (n) => Math.asinh(n)), GLt = {
    kernelName: nm,
    backendName: "cpu",
    kernelFunc: VLt
  };
  const WLt = Qe(rm, (n) => Math.atan(n)), ULt = {
    kernelName: rm,
    backendName: "cpu",
    kernelFunc: WLt
  };
  const HLt = Ln((n, t) => Math.atan2(n, t)), XLt = Qn(am, HLt), YLt = {
    kernelName: am,
    backendName: "cpu",
    kernelFunc: XLt
  };
  const qLt = Qe(im, (n) => Math.atanh(n)), jLt = {
    kernelName: im,
    backendName: "cpu",
    kernelFunc: qLt
  };
  function pN(n, t, e, r, i, a) {
    const s = i.strideHeight, o = i.strideWidth, l = i.dilationHeight, u = i.dilationWidth, c = i.effectiveFilterHeight, h = i.effectiveFilterWidth, f = i.padInfo.top, d = i.padInfo.left, p = a === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, g = we(i.outShape, e), v = g.values, m = i.outShape[1] * i.outShape[2] * i.outShape[3], y = i.outShape[2] * i.outShape[3], x = i.outShape[3];
    for (let b = 0; b < i.batchSize; ++b) {
      const _ = b * m, w = b * r[0];
      for (let S = 0; S < i.inChannels; ++S) for (let I = 0; I < i.outHeight; ++I) {
        const T = I * s - f, A = Math.max(0, T), C = Math.min(i.inHeight, c + T), D = _ + I * y;
        for (let E = 0; E < i.outWidth; ++E) {
          const M = E * o - d, L = Math.max(0, M), k = Math.min(i.inWidth, h + M);
          let N = p, R = 0, $ = 0;
          for (let F = A; F < C; F += l) {
            const z = w + F * r[1];
            for (let V = L; V < k; V += u) {
              const U = z + V * r[2], X = n[U + S];
              a === "max" && X > N ? N = X : a === "avg" && (R += X, $++);
            }
            if (isNaN(N)) break;
          }
          const O = D + E * x + S;
          v[O] = a === "avg" ? R / $ : N;
        }
      }
    }
    return g;
  }
  function TZ(n, t, e, r, i = false, a = false) {
    const s = we(r.outShape, "int32"), o = r.strideHeight, l = r.strideWidth, u = r.dilationHeight, c = r.dilationWidth, h = r.effectiveFilterHeight, f = r.effectiveFilterWidth, d = r.padInfo.top, p = r.padInfo.left, g = we(t, e, n);
    for (let v = 0; v < r.batchSize; ++v) for (let m = 0; m < r.inChannels; ++m) for (let y = 0; y < r.outHeight; ++y) {
      const x = y * o - d;
      let b = x;
      for (; b < 0; ) b += u;
      const _ = Math.min(r.inHeight, h + x);
      for (let w = 0; w < r.outWidth; ++w) {
        const S = w * l - p;
        let I = S;
        for (; I < 0; ) I += c;
        const T = Math.min(r.inWidth, f + S);
        let A = Number.NEGATIVE_INFINITY, C = -1;
        for (let D = b; D < _; D += u) {
          const E = D - x;
          for (let M = I; M < T; M += c) {
            const L = M - S, k = g.get(v, D, M, m);
            k > A && (A = k, i ? C = a ? ((v * r.inHeight + D) * r.inWidth + M) * r.inChannels + m : (D * r.inWidth + M) * r.inChannels + m : C = E * f + L);
          }
        }
        s.set(C, v, y, w, m);
      }
    }
    return s;
  }
  function IZ(n, t, e, r, i, a) {
    const s = i.strideDepth, o = i.strideHeight, l = i.strideWidth, u = i.dilationDepth, c = i.dilationHeight, h = i.dilationWidth, f = i.effectiveFilterDepth, d = i.effectiveFilterHeight, p = i.effectiveFilterWidth, g = i.padInfo.front, v = i.padInfo.top, m = i.padInfo.left, y = a === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, x = we(i.outShape, e), b = x.values, _ = i.outShape[1] * i.outShape[2] * i.outShape[3] * i.outShape[4], w = i.outShape[2] * i.outShape[3] * i.outShape[4], S = i.outShape[3] * i.outShape[4], I = i.outShape[4];
    for (let T = 0; T < i.batchSize; ++T) {
      const A = T * _, C = T * r[0];
      for (let D = 0; D < i.inChannels; ++D) for (let E = 0; E < i.outDepth; ++E) {
        const M = E * s - g;
        let L = M;
        for (; L < 0; ) L += u;
        const k = Math.min(i.inDepth, f + M), N = A + E * w;
        for (let R = 0; R < i.outHeight; ++R) {
          const $ = R * o - v;
          let O = $;
          for (; O < 0; ) O += c;
          const F = Math.min(i.inHeight, d + $), z = N + R * S;
          for (let V = 0; V < i.outWidth; ++V) {
            const U = V * l - m;
            let X = U;
            for (; X < 0; ) X += h;
            const at = Math.min(i.inWidth, p + U), pt = z + V * I;
            let it = y, et = 0, ft = 0;
            for (let gt = L; gt < k; gt += u) {
              const kt = C + gt * r[1];
              for (let At = O; At < F; At += c) {
                const mt = kt + At * r[2];
                for (let _t = X; _t < at; _t += h) {
                  const ee = mt + _t * r[3], G = n[ee + D];
                  if (a === "max" && G > it ? it = G : a === "avg" && (et += G, ft++), isNaN(it)) break;
                }
                if (isNaN(it)) break;
              }
              if (isNaN(it)) break;
            }
            const ut = pt + D;
            b[ut] = a === "avg" ? et / Math.max(ft, 1) : it;
          }
        }
      }
    }
    return x;
  }
  function KLt(n, t) {
    const e = we(t.outShape, "int32"), r = t.strideDepth, i = t.strideHeight, a = t.strideWidth, s = t.dilationDepth, o = t.dilationHeight, l = t.dilationWidth, u = t.effectiveFilterDepth, c = t.effectiveFilterHeight, h = t.effectiveFilterWidth, f = t.padInfo.front, d = t.padInfo.top, p = t.padInfo.left;
    for (let g = 0; g < t.batchSize; ++g) for (let v = 0; v < t.inChannels; ++v) for (let m = 0; m < t.outDepth; ++m) {
      const y = m * r - f;
      let x = y;
      for (; x < 0; ) x += s;
      const b = Math.min(t.inDepth, u + y);
      for (let _ = 0; _ < t.outHeight; ++_) {
        const w = _ * i - d;
        let S = w;
        for (; S < 0; ) S += o;
        const I = Math.min(t.inHeight, c + w);
        for (let T = 0; T < t.outWidth; ++T) {
          const A = T * a - p;
          let C = A;
          for (; C < 0; ) C += l;
          const D = Math.min(t.inWidth, h + A);
          let E = Number.NEGATIVE_INFINITY, M = -1;
          for (let L = x; L < b; L += s) {
            const k = L - y;
            for (let N = S; N < I; N += o) {
              const R = N - w;
              for (let $ = C; $ < D; $ += l) {
                const O = $ - A, F = n.get(g, L, N, $, v);
                F >= E && (E = F, M = k * c * h + R * c + O);
              }
            }
          }
          e.set(M, g, m, _, T, v);
        }
      }
    }
    return e;
  }
  function ZLt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t;
    zt(i, "avgPool");
    const { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, u = 1;
    B(Rr(s, u), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = Ra(i.shape, a, s, u, o, l);
    let h;
    if (c.filterWidth === 1 && c.filterHeight === 1 && Xe(c.inShape, c.outShape)) h = lo({
      inputs: {
        x: i
      },
      backend: e
    });
    else {
      const f = e.data.get(i.dataId).values, d = Yt(i.shape), p = pN(f, i.shape, i.dtype, d, c, "avg");
      h = e.makeTensorInfo(c.outShape, i.dtype, p.values);
    }
    return h;
  }
  const JLt = {
    kernelName: a_,
    backendName: "cpu",
    kernelFunc: ZLt
  };
  function QLt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { filterSize: a, strides: s, pad: o, dimRoundingMode: l, dataFormat: u } = r;
    zt(i, "avgPool3d");
    const c = rl(i.shape, a, s, 1, o, l, u), h = e.data.get(i.dataId).values, f = IZ(h, i.shape, i.dtype, Yt(i.shape), c, "avg");
    return e.makeTensorInfo(f.shape, "float32", f.values);
  }
  const tPt = {
    kernelName: s_,
    backendName: "cpu",
    kernelFunc: QLt
  };
  function ePt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, input: a } = t, { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = r;
    zt([
      i,
      a
    ], "avgPool3DGrad");
    const c = rl(a.shape, s, o, 1, l, u), h = c.strideDepth, f = c.strideHeight, d = c.strideWidth, p = c.filterDepth, g = c.filterHeight, v = c.filterWidth, m = c.dilationDepth, y = c.dilationHeight, x = c.dilationWidth, b = c.effectiveFilterDepth, _ = c.effectiveFilterHeight, w = c.effectiveFilterWidth, S = b - 1 - c.padInfo.front, I = w - 1 - c.padInfo.left, T = _ - 1 - c.padInfo.top, A = we(a.shape, "float32"), C = 1 / (p * g * v), D = e.bufferSync(i);
    for (let E = 0; E < c.batchSize; ++E) for (let M = 0; M < c.inChannels; ++M) for (let L = 0; L < c.inDepth; ++L) for (let k = 0; k < c.inHeight; ++k) for (let N = 0; N < c.inWidth; ++N) {
      const R = L - S, $ = k - T, O = N - I;
      let F = 0;
      for (let z = 0; z < b; z += m) {
        const V = (R + z) / h;
        if (!(V < 0 || V >= c.outDepth || Math.floor(V) !== V)) for (let U = 0; U < _; U += y) {
          const X = ($ + U) / f;
          if (!(X < 0 || X >= c.outHeight || Math.floor(X) !== X)) for (let at = 0; at < w; at += x) {
            const pt = (O + at) / d;
            if (pt < 0 || pt >= c.outWidth || Math.floor(pt) !== pt) continue;
            const it = D.get(E, V, X, pt, M);
            F += it;
          }
        }
      }
      A.set(F * C, E, L, k, N, M);
    }
    return e.makeTensorInfo(A.shape, A.dtype, A.values);
  }
  const nPt = {
    kernelName: tM,
    backendName: "cpu",
    kernelFunc: ePt
  };
  function rPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, input: a } = t, s = a;
    zt([
      i,
      a
    ], "avgPoolGrad");
    const { filterSize: o, strides: l, pad: u } = r, c = Ra(s.shape, o, l, 1, u), h = c.strideHeight, f = c.strideWidth, d = c.filterHeight, p = c.filterWidth, g = c.dilationHeight, v = c.dilationWidth, m = c.effectiveFilterHeight, y = c.effectiveFilterWidth, x = y - 1 - c.padInfo.left, b = m - 1 - c.padInfo.top, _ = we(s.shape, "float32"), w = 1 / (d * p), S = e.data.get(i.dataId).values, I = we(i.shape, "float32", S);
    for (let T = 0; T < c.batchSize; ++T) for (let A = 0; A < c.inChannels; ++A) for (let C = 0; C < c.inHeight; ++C) for (let D = 0; D < c.inWidth; ++D) {
      const E = C - b, M = D - x;
      let L = 0;
      for (let k = 0; k < m; k += g) {
        const N = (E + k) / h;
        if (!(N < 0 || N >= c.outHeight || Math.floor(N) !== N)) for (let R = 0; R < y; R += v) {
          const $ = (M + R) / f;
          if ($ < 0 || $ >= c.outWidth || Math.floor($) !== $) continue;
          const O = I.get(T, N, $, A);
          L += O;
        }
      }
      _.set(L * w, T, C, D, A);
    }
    return e.makeTensorInfo(_.shape, _.dtype, _.values);
  }
  const iPt = {
    kernelName: QE,
    backendName: "cpu",
    kernelFunc: rPt
  };
  function aPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, scale: a, offset: s, mean: o, variance: l } = t;
    B(o.shape.length === l.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), B(s == null || o.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), B(a == null || o.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), zt([
      i,
      o,
      l,
      a,
      s
    ], "batchNorm");
    let { varianceEpsilon: u } = r;
    u == null && (u = 1e-3);
    const c = e.data.get(i.dataId).values, h = e.data.get(o.dataId).values, f = e.data.get(l.dataId).values, d = a ? e.data.get(a.dataId).values : new Float32Array([
      1
    ]), p = s ? e.data.get(s.dataId).values : new Float32Array([
      0
    ]), g = new Float32Array(c.length), v = p.length, m = d.length, y = f.length, x = h.length;
    let b = 0, _ = 0, w = 0, S = 0;
    for (let I = 0; I < c.length; ++I) g[I] = p[b++] + (c[I] - h[_++]) * d[w++] / Math.sqrt(f[S++] + u), b >= v && (b = 0), _ >= x && (_ = 0), w >= m && (w = 0), S >= y && (S = 0);
    return e.makeTensorInfo(i.shape, i.dtype, g);
  }
  const sPt = {
    kernelName: x_,
    backendName: "cpu",
    kernelFunc: aPt
  };
  function oPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { blockShape: a, crops: s } = r;
    zt([
      i
    ], "batchToSpaceND");
    const o = a.reduce((m, y) => m * y), l = Qm(i.shape, a, o), u = ty(l.length, a.length), c = ey(i.shape, a, o), h = CR(s, a.length), f = TR(c, s, a.length), d = pn({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: l
      }
    }), p = bi({
      inputs: {
        x: d
      },
      backend: e,
      attrs: {
        perm: u
      }
    }), g = pn({
      inputs: {
        x: p
      },
      backend: e,
      attrs: {
        shape: c
      }
    }), v = lh({
      inputs: {
        x: g
      },
      backend: e,
      attrs: {
        begin: h,
        size: f
      }
    });
    return e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(p), e.disposeIntermediateTensorInfo(g), v;
  }
  const lPt = {
    kernelName: l_,
    backendName: "cpu",
    kernelFunc: oPt
  };
  function uPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, weights: a } = t, { size: s } = r, o = e.data.get(i.dataId).values, l = e.data.get(a.dataId).values, u = uN(o, l, a.dtype, a.shape, s);
    return e.makeTensorInfo([
      s
    ], a.dtype, u);
  }
  const cPt = {
    kernelName: eM,
    backendName: "cpu",
    kernelFunc: uPt
  };
  function hPt(n) {
    const { inputs: t, backend: e } = n, { s0: r, s1: i } = t, a = e.data.get(r.dataId).values, s = e.data.get(i.dataId).values, o = ve(Array.from(a), Array.from(s));
    return e.makeTensorInfo([
      o.length
    ], "int32", Int32Array.from(o));
  }
  const fPt = {
    kernelName: JY,
    backendName: "cpu",
    kernelFunc: hPt
  };
  const dPt = Qe(lm, (n, t) => {
    const e = t;
    return n > e.clipValueMax ? e.clipValueMax : n < e.clipValueMin ? e.clipValueMin : n;
  }), pPt = {
    kernelName: lm,
    backendName: "cpu",
    kernelFunc: dPt
  };
  const gPt = (n) => {
    const { x: t } = n.inputs, e = n.backend, r = new Float32Array(lt(t.shape)), i = e.data.get(t.dataId), a = i.complexTensorInfos.real, s = i.complexTensorInfos.imag, o = e.data.get(a.dataId).values, l = e.data.get(s.dataId).values;
    for (let u = 0; u < o.length; u++) {
      const c = o[u], h = l[u];
      r[u] = Math.hypot(c, h);
    }
    return e.makeOutput(r, t.shape, "float32");
  }, vPt = {
    kernelName: u_,
    backendName: "cpu",
    kernelFunc: gPt
  };
  function ad(n) {
    const { inputs: t, backend: e } = n, { input: r } = t, i = e.data.get(r.dataId).complexTensorInfos.imag, a = e.data.get(i.dataId).values;
    return e.makeTensorInfo(i.shape, i.dtype, a);
  }
  const mPt = {
    kernelName: xM,
    backendName: "cpu",
    kernelFunc: ad
  };
  function sd(n) {
    const { inputs: t, backend: e, attrs: r } = n, { axis: i } = r, a = Se(i, t[0].shape)[0], s = t.map((g) => g.shape);
    _R(s, a);
    let o = js(t.map((g) => g.shape), a);
    if (lt(o) === 0) return e.makeTensorInfo(o, t[0].dtype, []);
    const l = t.filter((g) => lt(g.shape) > 0);
    if (l.length === 1) return lo({
      inputs: {
        x: l[0]
      },
      backend: e
    });
    if (l[0].dtype === "complex64") {
      const g = l.map((b) => oh({
        inputs: {
          input: b
        },
        backend: e
      })), v = l.map((b) => ad({
        inputs: {
          input: b
        },
        backend: e
      })), m = sd({
        inputs: g,
        backend: e,
        attrs: {
          axis: a
        }
      }), y = sd({
        inputs: v,
        backend: e,
        attrs: {
          axis: a
        }
      }), x = Mi({
        inputs: {
          real: m,
          imag: y
        },
        backend: e
      });
      return g.forEach((b) => e.disposeIntermediateTensorInfo(b)), v.forEach((b) => e.disposeIntermediateTensorInfo(b)), e.disposeIntermediateTensorInfo(m), e.disposeIntermediateTensorInfo(y), x;
    }
    const u = l.map((g) => {
      const m = [
        -1,
        lt(g.shape.slice(a))
      ];
      return pn({
        inputs: {
          x: g
        },
        backend: e,
        attrs: {
          shape: m
        }
      });
    }), c = u.map((g) => ({
      vals: e.data.get(g.dataId).values,
      shape: g.shape
    }));
    o = js(u.map((g) => g.shape), 1);
    const h = u[0].shape[0] === 1, f = MK(c, o, t[0].dtype, h), d = js(l.map((g) => g.shape), a), p = e.makeTensorInfo(d, t[0].dtype, f);
    return u.forEach((g) => e.disposeIntermediateTensorInfo(g)), p;
  }
  const yPt = {
    kernelName: c_,
    backendName: "cpu",
    kernelFunc: sd
  };
  function AZ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a } = t, { strides: s, pad: o, dataFormat: l, dilations: u, dimRoundingMode: c } = r;
    zt([
      i,
      a
    ], "conv2d");
    const h = il(l), f = _r(i.shape, a.shape, s, u, o, c, false, h), d = f.filterHeight, p = f.filterWidth, g = f.dilationHeight, v = f.dilationWidth, m = f.padInfo.left, y = f.padInfo.top, x = f.dataFormat === "channelsLast", b = new xr(f.outShape, i.dtype), _ = Yt(i.shape), w = Yt(a.shape), S = _[0], I = x ? _[1] : _[2], T = x ? _[2] : 1, A = x ? 1 : _[1], C = b.strides[0], D = x ? b.strides[1] : b.strides[2], E = x ? b.strides[2] : 1, M = x ? 1 : b.strides[1], L = e.data.get(i.dataId).values, k = e.data.get(a.dataId).values, N = b.values;
    for (let R = 0; R < f.batchSize; ++R) {
      const $ = R * S, O = R * C;
      for (let F = 0; F < f.outHeight; ++F) {
        const z = O + F * D, V = F * f.strideHeight - y;
        for (let U = 0; U < d; ++U) {
          const X = V + U * g;
          if (X < 0 || X >= f.inHeight) continue;
          const at = U * w[0], pt = $ + X * I;
          for (let it = 0; it < f.outWidth; ++it) {
            const et = z + it * E, ft = it * f.strideWidth - m;
            for (let ut = 0; ut < p; ++ut) {
              const gt = ft + ut * v;
              if (gt < 0 || gt >= f.inWidth) continue;
              const kt = at + ut * w[1], At = pt + gt * T;
              let mt = kt;
              for (let _t = 0; _t < f.inChannels; ++_t) {
                const ee = L[At + _t * A];
                for (let G = 0; G < f.outChannels; ++G) N[et + G * M] += ee * k[mt + G];
                mt += f.outChannels;
              }
            }
          }
        }
      }
    }
    return e.makeTensorInfo(b.shape, b.dtype, N);
  }
  const xPt = {
    kernelName: h_,
    backendName: "cpu",
    kernelFunc: AZ
  };
  function bPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, dy: a } = t, { strides: s, pad: o, dataFormat: l, dimRoundingMode: u, filterShape: c } = r;
    zt([
      i,
      a
    ], "conv2dBackpropFilter");
    const h = il(l), f = _r(i.shape, c, s, 1, o, u, false, h), { strideHeight: d, strideWidth: p, filterHeight: g, filterWidth: v } = f, m = f.dataFormat === "channelsLast", y = new xr(f.filterShape, "float32"), x = f.padInfo.left, b = f.padInfo.top, _ = e.data.get(i.dataId).values, w = e.data.get(a.dataId).values, S = new xr(i.shape, i.dtype, _), I = new xr(a.shape, a.dtype, w);
    for (let T = 0; T < g; ++T) {
      const A = Math.max(0, Math.ceil((b - T) / d)), C = Math.min(f.outHeight, (f.inHeight + b - T) / d);
      for (let D = 0; D < v; ++D) {
        const E = Math.max(0, Math.ceil((x - D) / p)), M = Math.min(f.outWidth, (f.inWidth + x - D) / p);
        for (let L = 0; L < f.inChannels; ++L) for (let k = 0; k < f.outChannels; ++k) {
          let N = 0;
          for (let R = 0; R < f.batchSize; ++R) for (let $ = A; $ < C; ++$) {
            const O = T + $ * d - b;
            for (let F = E; F < M; ++F) {
              const z = D + F * p - x;
              m ? N += S.get(R, O, z, L) * I.get(R, $, F, k) : N += S.get(R, L, O, z) * I.get(R, k, $, F);
            }
          }
          y.set(N, T, D, L, k);
        }
      }
    }
    return e.makeTensorInfo(y.shape, y.dtype, y.values);
  }
  const _Pt = {
    kernelName: iM,
    backendName: "cpu",
    kernelFunc: bPt
  };
  function wPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, filter: a } = t, { inputShape: s, strides: o, pad: l, dataFormat: u, dimRoundingMode: c } = r;
    zt([
      i,
      a
    ], "conv2dBackpropInput");
    const h = Yt(a.shape), f = Yt(i.shape);
    let d = il(u);
    const p = _r(s, a.shape, o, 1, l, c, false, d), g = new xr(p.inShape, "float32"), v = g.values, m = e.data.get(i.dataId).values, y = e.data.get(a.dataId).values, [x, b, _] = h, { batchSize: w, filterHeight: S, filterWidth: I, inChannels: T, inHeight: A, inWidth: C, outChannels: D, outHeight: E, outWidth: M, strideHeight: L, strideWidth: k } = p;
    d = p.dataFormat;
    const N = S - 1 - p.padInfo.top, R = I - 1 - p.padInfo.left, $ = d === "channelsLast", O = g.strides[0], F = $ ? g.strides[1] : g.strides[2], z = $ ? g.strides[2] : 1, V = $ ? 1 : g.strides[1], U = f[0], X = $ ? f[1] : f[2], at = $ ? f[2] : 1, pt = $ ? 1 : f[1];
    for (let it = 0; it < w; ++it) for (let et = 0; et < T; ++et) for (let ft = 0; ft < A; ++ft) {
      const ut = ft - N, gt = Math.max(0, Math.ceil(ut / L)), kt = Math.min(E, (S + ut) / L);
      for (let At = 0; At < C; ++At) {
        const mt = At - R, _t = Math.max(0, Math.ceil(mt / k)), ee = Math.min(M, (I + mt) / k);
        let G = 0;
        for (let dt = gt; dt < kt; ++dt) {
          const Mt = dt * L - ut;
          for (let Ae = _t; Ae < ee; ++Ae) {
            const ie = Ae * k - mt, st = U * it + X * dt + at * Ae, xt = x * (S - 1 - Mt) + b * (I - 1 - ie) + _ * et;
            for (let Me = 0; Me < D; ++Me) {
              const je = m[st + pt * Me], $r = y[xt + Me];
              G += je * $r;
            }
          }
        }
        const H = O * it + F * ft + z * At + V * et;
        v[H] = G;
      }
    }
    return e.makeTensorInfo(g.shape, g.dtype, g.values);
  }
  const SPt = {
    kernelName: f_,
    backendName: "cpu",
    kernelFunc: wPt
  };
  function CPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a } = t, { strides: s, pad: o, dilations: l } = r;
    zt([
      i,
      a
    ], "conv3d");
    const u = cu(i.shape, a.shape, s, l, o), { filterDepth: c, filterHeight: h, filterWidth: f, dilationDepth: d, dilationHeight: p, dilationWidth: g, padInfo: v } = u, m = v.front, y = v.left, x = v.top, b = new xr(u.outShape, i.dtype), _ = e.data.get(i.dataId).values, w = e.data.get(a.dataId).values, S = b.values, I = Yt(i.shape), T = Yt(a.shape);
    for (let A = 0; A < u.batchSize; ++A) {
      const C = A * I[0], D = A * b.strides[0];
      for (let E = 0; E < u.outDepth; ++E) {
        const M = D + E * b.strides[1], L = E * u.strideDepth - m;
        for (let k = 0; k < c; ++k) {
          const N = L + k * d;
          if (N < 0 || N >= u.inDepth) continue;
          const R = k * T[0], $ = C + N * I[1];
          for (let O = 0; O < u.outHeight; ++O) {
            const F = M + O * b.strides[2], z = O * u.strideHeight - x;
            for (let V = 0; V < h; ++V) {
              const U = z + V * p;
              if (U < 0 || U >= u.inHeight) continue;
              const X = R + V * T[1], at = $ + U * I[2];
              for (let pt = 0; pt < u.outWidth; ++pt) {
                const it = F + pt * u.outChannels, et = pt * u.strideWidth - y;
                for (let ft = 0; ft < f; ++ft) {
                  const ut = et + ft * g;
                  if (ut < 0 || ut >= u.inWidth) continue;
                  const gt = X + ft * T[2], kt = at + ut * u.inChannels;
                  let At = gt;
                  for (let mt = 0; mt < u.inChannels; ++mt) {
                    const _t = _[kt + mt];
                    for (let ee = 0; ee < u.outChannels; ++ee) S[it + ee] += _t * w[At + ee];
                    At += u.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }
    return e.makeTensorInfo(b.shape, b.dtype, b.values);
  }
  const TPt = {
    kernelName: d_,
    backendName: "cpu",
    kernelFunc: CPt
  };
  function IPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, dy: a } = t, { strides: s, pad: o, filterShape: l } = r;
    zt([
      i,
      a
    ], "conv3dBackpropFilterV2");
    const u = Yt(i.shape), c = Yt(a.shape), h = cu(i.shape, l, s, 1, o), f = h.strideDepth, d = h.strideHeight, p = h.strideWidth, g = h.filterDepth, v = h.filterHeight, m = h.filterWidth, y = new xr(h.filterShape, "float32"), x = y.values, [b, _, w, S] = y.strides, I = e.data.get(a.dataId).values, [T, A, C, D] = c, E = e.data.get(i.dataId).values, [M, L, k, N] = u, R = h.padInfo.front, $ = h.padInfo.left, O = h.padInfo.top;
    for (let F = 0; F < g; ++F) {
      const z = Math.max(0, Math.ceil((R - F) / f)), V = Math.min(h.outDepth, (h.inDepth + R - F) / f), U = F * b;
      for (let X = 0; X < v; ++X) {
        const at = Math.max(0, Math.ceil((O - X) / d)), pt = Math.min(h.outHeight, (h.inHeight + O - X) / d), it = X * _ + U;
        for (let et = 0; et < m; ++et) {
          const ft = Math.max(0, Math.ceil(($ - et) / p)), ut = Math.min(h.outWidth, (h.inWidth + $ - et) / p), gt = et * w + it;
          for (let kt = 0; kt < h.inChannels; ++kt) {
            const At = kt * S + gt;
            for (let mt = 0; mt < h.outChannels; ++mt) {
              let _t = 0;
              for (let ee = 0; ee < h.batchSize; ++ee) {
                const G = ee * M, H = ee * T;
                for (let dt = z; dt < V; ++dt) {
                  const Ae = (F + dt * f - R) * L + G, ie = dt * A + H;
                  for (let st = at; st < pt; ++st) {
                    const Me = (X + st * d - O) * k + Ae, je = st * C + ie;
                    for (let $r = ft; $r < ut; ++$r) {
                      const ys = (et + $r * p - $) * N + Me, Zd = $r * D + je;
                      _t += E[ys + kt] * I[Zd + mt];
                    }
                  }
                }
              }
              x[At + mt] = _t;
            }
          }
        }
      }
    }
    return e.makeTensorInfo(y.shape, y.dtype, y.values);
  }
  const APt = {
    kernelName: aM,
    backendName: "cpu",
    kernelFunc: IPt
  };
  function kPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, filter: a } = t, { pad: s, strides: o, inputShape: l } = r;
    zt([
      i
    ], "conv3dBackpropInputV2");
    const u = Yt(i.shape), c = Yt(a.shape), h = cu(l, a.shape, o, 1, s), f = new xr(h.inShape, "float32"), d = f.values, [p, g, v, m] = f.strides, y = e.data.get(i.dataId).values, [x, b, _, w] = u, S = e.data.get(a.dataId).values, [I, T, A, C] = c, { batchSize: D, filterDepth: E, filterHeight: M, filterWidth: L, inChannels: k, inDepth: N, inHeight: R, inWidth: $, outChannels: O, outDepth: F, outHeight: z, outWidth: V, strideDepth: U, strideHeight: X, strideWidth: at } = h, pt = E - 1 - h.padInfo.front, it = M - 1 - h.padInfo.top, et = L - 1 - h.padInfo.left;
    for (let ft = 0; ft < D; ++ft) for (let ut = 0; ut < k; ++ut) for (let gt = 0; gt < N; ++gt) {
      const kt = gt - pt, At = Math.max(0, Math.ceil(kt / U)), mt = Math.min(F, (E + kt) / U);
      for (let _t = 0; _t < R; ++_t) {
        const ee = _t - it, G = Math.max(0, Math.ceil(ee / X)), H = Math.min(z, (M + ee) / X);
        for (let dt = 0; dt < $; ++dt) {
          const Mt = dt - et, Ae = Math.max(0, Math.ceil(Mt / at)), ie = Math.min(V, (L + Mt) / at);
          let st = 0;
          for (let xt = At; xt < mt; ++xt) {
            const Me = xt * U - kt;
            for (let je = G; je < H; ++je) {
              const $r = je * X - ee;
              for (let ms = Ae; ms < ie; ++ms) {
                const ys = ms * at - Mt, Zd = x * ft + b * xt + _ * je + w * ms, cL = I * (E - 1 - Me) + T * (M - 1 - $r) + A * (L - 1 - ys) + C * ut;
                for (let yy = 0; yy < O; ++yy) {
                  const Itt = y[Zd + yy], Att = S[cL + yy];
                  st += Itt * Att;
                }
              }
            }
          }
          d[p * ft + g * gt + v * _t + m * dt + ut] = st;
        }
      }
    }
    return e.makeTensorInfo(f.shape, f.dtype, f.values);
  }
  const DPt = {
    kernelName: sM,
    backendName: "cpu",
    kernelFunc: kPt
  };
  const EPt = Qe(um, (n) => Math.cos(n)), MPt = {
    kernelName: um,
    backendName: "cpu",
    kernelFunc: EPt
  };
  const RPt = Qe(cm, (n) => Math.cosh(n)), NPt = {
    kernelName: cm,
    backendName: "cpu",
    kernelFunc: RPt
  };
  function LPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { image: i, boxes: a, boxInd: s } = t, { cropSize: o, method: l, extrapolationValue: u } = r, [c, h, f, d] = i.shape, p = a.shape[0], [g, v] = o, m = we([
      p,
      g,
      v,
      d
    ], "float32"), y = e.data.get(a.dataId).values, x = e.data.get(s.dataId).values, b = e.data.get(i.dataId).values, _ = Yt(i.shape), w = Yt(m.shape);
    for (let S = 0; S < p; S++) {
      const I = S * 4, T = y[I], A = y[I + 1], C = y[I + 2], D = y[I + 3], E = x[S];
      if (E >= c) continue;
      const M = g > 1 ? (C - T) * (h - 1) / (g - 1) : 0, L = v > 1 ? (D - A) * (f - 1) / (v - 1) : 0;
      for (let k = 0; k < g; k++) {
        const N = g > 1 ? T * (h - 1) + k * M : 0.5 * (T + C) * (h - 1);
        if (N < 0 || N > h - 1) {
          for (let R = 0; R < v; R++) for (let $ = 0; $ < d; $++) {
            const O = $ + R * w[2] + k * w[1] + S * w[0];
            m.values[O] = u;
          }
          continue;
        }
        if (l === "bilinear") {
          const R = Math.floor(N), $ = Math.ceil(N), O = N - R;
          for (let F = 0; F < v; F++) {
            const z = v > 1 ? A * (f - 1) + F * L : 0.5 * (A + D) * (f - 1);
            if (z < 0 || z > f - 1) {
              for (let at = 0; at < d; at++) {
                const pt = at + F * w[2] + k * w[1] + S * w[0];
                m.values[pt] = u;
              }
              continue;
            }
            const V = Math.floor(z), U = Math.ceil(z), X = z - V;
            for (let at = 0; at < d; at++) {
              let pt = at + V * _[2] + R * _[1] + E * _[0];
              const it = b[pt];
              pt = at + U * _[2] + R * _[1] + E * _[0];
              const et = b[pt];
              pt = at + V * _[2] + $ * _[1] + E * _[0];
              const ft = b[pt];
              pt = at + U * _[2] + $ * _[1] + E * _[0];
              const ut = b[pt], gt = it + (et - it) * X, kt = ft + (ut - ft) * X;
              pt = at + F * w[2] + k * w[1] + S * w[0], m.values[pt] = gt + (kt - gt) * O;
            }
          }
        } else for (let R = 0; R < v; ++R) {
          const $ = v > 1 ? A * (f - 1) + R * L : 0.5 * (A + D) * (f - 1);
          if ($ < 0 || $ > f - 1) {
            for (let z = 0; z < d; z++) {
              const V = z + R * w[2] + k * w[1] + S * w[0];
              m.values[V] = u;
            }
            continue;
          }
          const O = Math.round($), F = Math.round(N);
          for (let z = 0; z < d; z++) {
            const V = z + O * _[2] + F * _[1] + E * _[0], U = z + R * w[2] + k * w[1] + S * w[0];
            m.values[U] = b[V];
          }
        }
      }
    }
    return e.makeTensorInfo(m.shape, m.dtype, m.values);
  }
  const PPt = {
    kernelName: lM,
    backendName: "cpu",
    kernelFunc: LPt
  };
  function $Pt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, exclusive: s, reverse: o } = r;
    zt(i, "cumprod");
    const l = wn([
      a
    ], i.shape.length);
    let u = i;
    l != null && (u = bi({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: l
      }
    }));
    const c = Rn(1, i.shape.length)[0];
    if (c !== u.shape.length - 1) throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length - 1} but got axis=${c}`);
    const h = $i(u.dtype, "int32"), f = YE(lt(u.shape), h), d = e.data.get(u.dataId).values, p = u.shape[u.shape.length - 1], g = o ? (m, y) => m + p - y - 1 : (m, y) => m + y;
    for (let m = 0; m < d.length; m += p) for (let y = 0; y < p; y++) {
      const x = g(m, y);
      if (y === 0) f[x] = s ? 1 : d[x];
      else {
        const b = g(m, y - 1);
        f[x] = s ? d[b] * f[b] : d[x] * f[b];
      }
    }
    const v = e.makeTensorInfo(u.shape, h, f);
    if (l != null) {
      const m = hu(l), y = bi({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          perm: m
        }
      });
      return e.disposeIntermediateTensorInfo(v), e.disposeIntermediateTensorInfo(u), y;
    }
    return v;
  }
  const OPt = {
    kernelName: oM,
    backendName: "cpu",
    kernelFunc: $Pt
  };
  function FPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, exclusive: s, reverse: o } = r;
    zt(i, "cumsum");
    const l = wn([
      a
    ], i.shape.length);
    let u = i;
    l != null && (u = bi({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: l
      }
    }));
    const c = Rn(1, i.shape.length)[0];
    if (c !== u.shape.length - 1) throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length - 1} but got axis=${c}`);
    const h = $i(u.dtype, "int32"), f = Er(lt(u.shape), h), d = e.data.get(u.dataId).values, p = u.shape[u.shape.length - 1], g = o ? (m, y) => m + p - y - 1 : (m, y) => m + y;
    for (let m = 0; m < d.length; m += p) for (let y = 0; y < p; y++) {
      const x = g(m, y);
      if (y === 0) f[x] = s ? 0 : d[x];
      else {
        const b = g(m, y - 1);
        f[x] = s ? d[b] + f[b] : d[x] + f[b];
      }
    }
    const v = e.makeTensorInfo(u.shape, h, f);
    if (l != null) {
      const m = hu(l), y = bi({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          perm: m
        }
      });
      return e.disposeIntermediateTensorInfo(v), e.disposeIntermediateTensorInfo(u), y;
    }
    return v;
  }
  const BPt = {
    kernelName: p_,
    backendName: "cpu",
    kernelFunc: FPt
  };
  function zPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, weights: a } = t, { size: s, binaryOutput: o } = r;
    if (i.shape.length === 1) {
      const l = e.data.get(i.dataId).values, u = e.data.get(a.dataId).values, c = uN(l, u, a.dtype, a.shape, s);
      return e.makeTensorInfo([
        s
      ], a.dtype, c);
    } else if (i.shape.length === 2) {
      const l = e.bufferSync(i), u = e.bufferSync(a), c = kK(l, u, s, o);
      return e.makeTensorInfo(c.shape, a.dtype, c.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`);
  }
  const VPt = {
    kernelName: uM,
    backendName: "cpu",
    kernelFunc: zPt
  };
  function GPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { blockSize: a, dataFormat: s } = r;
    B(s === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${s}`);
    const o = i.shape[0], l = i.shape[1], u = i.shape[2], c = i.shape[3], h = l * a, f = u * a, d = c / (a * a), p = e.data.get(i.dataId).values, g = new Float32Array(o * h * f * d);
    let v = 0;
    for (let m = 0; m < o; ++m) for (let y = 0; y < h; ++y) {
      const x = Math.floor(y / a), b = y % a;
      for (let _ = 0; _ < f; ++_) {
        const w = Math.floor(_ / a), S = _ % a, I = (b * a + S) * d;
        for (let T = 0; T < d; ++T) {
          const C = T + I + c * (w + u * (x + l * m));
          g[v++] = p[C];
        }
      }
    }
    return e.makeTensorInfo([
      o,
      h,
      f,
      d
    ], i.dtype, g);
  }
  const WPt = {
    kernelName: cM,
    backendName: "cpu",
    kernelFunc: GPt
  };
  function kZ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a } = t, { strides: s, pad: o, dilations: l, dimRoundingMode: u } = r;
    zt([
      i,
      a
    ], "depthwiseConv2DNative");
    const c = Yt(i.shape), h = Yt(a.shape);
    let f = l;
    f == null && (f = [
      1,
      1
    ]), B(Rr(s, f), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${f}'`);
    const d = _r(i.shape, a.shape, s, f, o, u, true), { filterHeight: p, filterWidth: g, dilationHeight: v, dilationWidth: m, padInfo: y } = d, x = y.left, b = y.top, _ = d.outChannels / d.inChannels, w = new xr(d.outShape, i.dtype), S = e.data.get(i.dataId).values, I = e.data.get(a.dataId).values, T = w.values;
    for (let A = 0; A < d.batchSize; ++A) {
      const C = A * c[0], D = A * w.strides[0];
      for (let E = 0; E < d.outHeight; ++E) {
        const M = D + E * w.strides[1], L = E * d.strideHeight - b;
        for (let k = 0; k < p; ++k) {
          const N = L + k * v;
          if (N < 0 || N >= d.inHeight) continue;
          const R = k * h[0], $ = C + N * c[1];
          for (let O = 0; O < d.outWidth; ++O) {
            const F = M + O * w.strides[2], z = O * d.strideWidth - x;
            for (let V = 0; V < g; ++V) {
              const U = z + V * m;
              if (U < 0 || U >= d.inWidth) continue;
              const X = R + V * h[1], at = $ + U * d.inChannels;
              let pt = F, it = X;
              for (let et = 0; et < d.inChannels; ++et) {
                const ft = S[at + et];
                for (let ut = 0; ut < _; ++ut) T[pt + ut] += ft * I[it + ut];
                pt += _, it += _;
              }
            }
          }
        }
      }
    }
    return e.makeTensorInfo(w.shape, w.dtype, w.values);
  }
  const UPt = {
    kernelName: g_,
    backendName: "cpu",
    kernelFunc: kZ
  };
  function HPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, dy: a } = t, { strides: s, dilations: o, pad: l, dimRoundingMode: u, filterShape: c } = r;
    zt([
      i,
      a
    ], "depthwiseConv2dNativeBackpropFilter");
    const h = _r(i.shape, c, s, o, l, u, true), { strideHeight: f, strideWidth: d, filterHeight: p, filterWidth: g } = h, v = new xr(h.filterShape, "float32"), m = h.padInfo.left, y = h.padInfo.top, x = h.outChannels / h.inChannels, b = e.data.get(i.dataId).values, _ = new xr(i.shape, i.dtype, b), w = e.data.get(a.dataId).values, S = new xr(a.shape, a.dtype, w);
    for (let I = 0; I < p; ++I) {
      const T = Math.max(0, Math.ceil((y - I) / f)), A = Math.min(h.outHeight, (h.inHeight + y - I) / f);
      for (let C = 0; C < g; ++C) {
        const D = Math.max(0, Math.ceil((m - C) / d)), E = Math.min(h.outWidth, (h.inWidth + m - C) / d);
        for (let M = 0; M < h.outChannels; ++M) {
          const L = Math.trunc(M / x), k = M % x;
          let N = 0;
          for (let R = 0; R < h.batchSize; ++R) for (let $ = T; $ < A; ++$) {
            const O = I + $ * f - y;
            for (let F = D; F < E; ++F) {
              const z = C + F * d - m;
              N += _.get(R, O, z, L) * S.get(R, $, F, M);
            }
          }
          v.set(N, I, C, L, k);
        }
      }
    }
    return e.makeTensorInfo(v.shape, v.dtype, v.values);
  }
  const XPt = {
    kernelName: hM,
    backendName: "cpu",
    kernelFunc: HPt
  };
  function YPt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, filter: a } = t, { strides: s, dilations: o, pad: l, dimRoundingMode: u, inputShape: c } = r;
    zt([
      i,
      a
    ], "depthwiseConv2DNativeBackpropInput");
    const h = Yt(i.shape), f = Yt(a.shape), d = _r(c, a.shape, s, o, l, u, true), p = new xr(d.inShape, "float32"), g = p.values, [v, m, y] = p.strides, x = e.data.get(i.dataId).values, [b, _, w] = h, S = e.data.get(a.dataId).values, [I, T, A] = f, { batchSize: C, filterHeight: D, filterWidth: E, inChannels: M, inHeight: L, inWidth: k, outChannels: N, outHeight: R, outWidth: $, strideHeight: O, strideWidth: F } = d, z = D - 1 - d.padInfo.top, V = E - 1 - d.padInfo.left, U = N / M;
    for (let X = 0; X < C; ++X) for (let at = 0; at < M; ++at) for (let pt = 0; pt < L; ++pt) {
      const it = pt - z, et = Math.max(0, Math.ceil(it / O)), ft = Math.min(R, (D + it) / O);
      for (let ut = 0; ut < k; ++ut) {
        const gt = ut - V, kt = Math.max(0, Math.ceil(gt / F)), At = Math.min($, (E + gt) / F);
        let mt = 0;
        for (let _t = et; _t < ft; ++_t) {
          const ee = _t * O - it;
          for (let G = kt; G < At; ++G) {
            const H = G * F - gt, dt = b * X + _ * _t + w * G, Mt = I * (D - 1 - ee) + T * (E - 1 - H) + A * at;
            for (let Ae = 0; Ae < U; ++Ae) {
              const ie = at * U + Ae, st = x[dt + ie], xt = S[Mt + Ae];
              mt += st * xt;
            }
          }
        }
        g[v * X + m * pt + y * ut + at] = mt;
      }
    }
    return e.makeTensorInfo(p.shape, p.dtype, p.values);
  }
  const qPt = {
    kernelName: fM,
    backendName: "cpu",
    kernelFunc: YPt
  };
  function jPt(n) {
    const { inputs: t, backend: e } = n, { x: r } = t, i = lt(r.shape), a = e.data.get(r.dataId).values, s = we([
      i,
      i
    ], r.dtype), o = s.values;
    for (let u = 0; u < a.length; u++) o[u * i + u] = a[u];
    const l = [
      ...r.shape,
      ...r.shape
    ];
    return e.makeTensorInfo(l, s.dtype, s.values);
  }
  const KPt = {
    kernelName: QY,
    backendName: "cpu",
    kernelFunc: jPt
  };
  const ZPt = {
    kernelName: v_,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, backend: t, attrs: e }) => {
      const { x: r, filter: i } = n, { strides: a, pad: s, dilations: o } = e, l = t, u = l.data.get(r.dataId).values, c = r.shape.length, h = l.data.get(i.dataId).values, f = i.shape.length, { batchSize: d, inHeight: p, inWidth: g, inChannels: v, outHeight: m, outWidth: y, padInfo: x, strideHeight: b, strideWidth: _, filterHeight: w, filterWidth: S, dilationHeight: I, dilationWidth: T, outShape: A } = qm(r.shape, i.shape, a, s, "NHWC", o), C = lt(A), D = A.length, E = kn(r.dtype, C);
      for (let L = 0; L < d; ++L) for (let k = 0; k < m; ++k) {
        const N = k * b - x.top;
        for (let R = 0; R < y; ++R) {
          const $ = R * _ - x.left;
          for (let O = 0; O < v; ++O) {
            let F = Number.MIN_SAFE_INTEGER;
            for (let V = 0; V < w; ++V) {
              const U = N + V * I;
              if (U >= 0 && U < p) for (let X = 0; X < S; ++X) {
                const at = $ + X * T;
                if (at >= 0 && at < g) {
                  const pt = Ys([
                    L,
                    U,
                    at,
                    O
                  ], c, Yt(r.shape)), it = Ys([
                    V,
                    X,
                    O
                  ], f, Yt(i.shape)), et = u[pt] + h[it];
                  et > F && (F = et);
                }
              }
            }
            const z = Ys([
              L,
              k,
              R,
              O
            ], D, Yt(A));
            E[z] = F;
          }
        }
      }
      return {
        dataId: l.write(bh(E, r.dtype), A, r.dtype),
        shape: A,
        dtype: r.dtype
      };
    }
  };
  const JPt = {
    kernelName: m2,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, backend: t, attrs: e }) => {
      const { x: r, filter: i, dy: a } = n, { strides: s, pad: o, dilations: l } = e, u = t, c = ns(r.shape, u.data.get(r.dataId).values), h = ns(i.shape, u.data.get(i.dataId).values), { batchSize: f, inHeight: d, inWidth: p, inChannels: g, outHeight: v, outWidth: m, padInfo: y, strideHeight: x, strideWidth: b, filterHeight: _, filterWidth: w, dilationHeight: S, dilationWidth: I, outShape: T } = qm(r.shape, i.shape, s, o, "NHWC", l);
      B(a.rank === T.length, () => `Error in ${m2}, dy must have the same rank as output ${T.length}, but got ${a.rank}`);
      const A = ns(T, u.data.get(a.dataId).values), C = jY(i.shape, i.dtype);
      for (let E = 0; E < f; ++E) for (let M = 0; M < v; ++M) {
        const L = M * x - y.top;
        for (let k = 0; k < m; ++k) {
          const N = k * b - y.left;
          for (let R = 0; R < g; ++R) {
            let $ = Number.MIN_SAFE_INTEGER, O = 0, F = 0;
            for (let z = 0; z < _; ++z) {
              const V = L + z * S;
              if (V >= 0 && V < d) for (let U = 0; U < w; ++U) {
                const X = N + U * I;
                if (X >= 0 && X < p) {
                  const at = c[E][V][X][R] + h[z][U][R];
                  at > $ && ($ = at, O = z, F = U);
                }
              }
            }
            C[O][F][R] += A[E][M][k][R];
          }
        }
      }
      return {
        dataId: u.write(bh(C, r.dtype), i.shape, i.dtype),
        shape: i.shape,
        dtype: i.dtype
      };
    }
  };
  const QPt = {
    kernelName: v2,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, backend: t, attrs: e }) => {
      const { x: r, filter: i, dy: a } = n, { strides: s, pad: o, dilations: l } = e, u = t, c = ns(r.shape, u.data.get(r.dataId).values), h = ns(i.shape, u.data.get(i.dataId).values), { batchSize: f, inHeight: d, inWidth: p, inChannels: g, outHeight: v, outWidth: m, padInfo: y, strideHeight: x, strideWidth: b, filterHeight: _, filterWidth: w, dilationHeight: S, dilationWidth: I, outShape: T } = qm(r.shape, i.shape, s, o, "NHWC", l);
      B(a.rank === T.length, () => `Error in ${v2}, dy must have the same rank as output ${T.length}, but got ${a.rank}`);
      const A = ns(T, u.data.get(a.dataId).values), C = jY(r.shape, r.dtype);
      for (let E = 0; E < f; ++E) for (let M = 0; M < v; ++M) {
        const L = M * x - y.top;
        for (let k = 0; k < m; ++k) {
          const N = k * b - y.left;
          for (let R = 0; R < g; ++R) {
            let $ = Number.MIN_SAFE_INTEGER, O = L < 0 ? 0 : L, F = N < 0 ? 0 : N;
            for (let z = 0; z < _; ++z) {
              const V = L + z * S;
              if (V >= 0 && V < d) for (let U = 0; U < w; ++U) {
                const X = N + U * I;
                if (X >= 0 && X < p) {
                  const at = c[E][V][X][R] + h[z][U][R];
                  at > $ && ($ = at, O = V, F = X);
                }
              }
            }
            C[E][O][F][R] += A[E][M][k][R];
          }
        }
      }
      return {
        dataId: u.write(bh(C, r.dtype), r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      };
    }
  };
  function t$t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { image: i } = t, { canvas: a, options: s } = r, { contextOptions: o, imageOptions: l } = s || {}, u = (l == null ? void 0 : l.alpha) || 1, c = (o == null ? void 0 : o.contextType) || "2d";
    if (c !== "2d") throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);
    const h = a.getContext(c, (o == null ? void 0 : o.contextAttributes) || {});
    if (h == null) throw new Error(`Could not get the context with ${c} type.`);
    const [f, d] = i.shape.slice(0, 2), p = i.shape.length === 2 ? 1 : i.shape[2], g = e.data.get(i.dataId).values, v = i.dtype === "float32" ? 255 : 1, m = new Uint8ClampedArray(d * f * 4);
    for (let x = 0; x < f * d; ++x) {
      const b = [
        0,
        0,
        0,
        255 * u
      ];
      for (let w = 0; w < p; w++) {
        const S = g[x * p + w];
        if (i.dtype === "float32") {
          if (S < 0 || S > 1) throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${S}.`);
        } else if (i.dtype === "int32" && (S < 0 || S > 255)) throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${S}.`);
        p === 1 ? (b[0] = S * v, b[1] = S * v, b[2] = S * v) : b[w] = S * v;
      }
      const _ = x * 4;
      m[_ + 0] = Math.round(b[0]), m[_ + 1] = Math.round(b[1]), m[_ + 2] = Math.round(b[2]), m[_ + 3] = Math.round(b[3]);
    }
    a.width = d, a.height = f;
    const y = new ImageData(m, d, f);
    return h.putImageData(y, 0, 0), i;
  }
  const e$t = {
    kernelName: ESt,
    backendName: "cpu",
    kernelFunc: t$t
  };
  function cy(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r;
    zt(i, "sum");
    let o;
    i.dtype === "bool" ? o = au({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        dtype: "int32"
      }
    }) : o = lo({
      inputs: {
        x: i
      },
      backend: e
    });
    const l = o.shape.length, u = Se(a, o.shape), c = wn(u, l);
    let h = u, f = o;
    c != null && (f = bi({
      inputs: {
        x: o
      },
      backend: e,
      attrs: {
        perm: c
      }
    }), h = Rn(h.length, l)), wr("sum", h, f.shape.length);
    const [d, p] = hr(f.shape, h), g = $i(f.dtype, "int32");
    let v = Qb(e, d, g);
    const m = lt(p), y = e.data.get(v.dataId).values, x = e.data.get(f.dataId).values;
    for (let b = 0; b < y.length; ++b) {
      const _ = b * m;
      let w = 0;
      for (let S = 0; S < m; ++S) w += x[_ + S];
      y[b] = w;
    }
    if (s) {
      const b = Bn(v.shape, u), _ = v;
      v = pn({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          shape: b
        }
      }), e.disposeIntermediateTensorInfo(_);
    }
    return e.disposeIntermediateTensorInfo(o), c != null && e.disposeIntermediateTensorInfo(f), v;
  }
  const n$t = {
    kernelName: j_,
    backendName: "cpu",
    kernelFunc: cy
  };
  function r$t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { equation: i } = r, a = t, { allDims: s, summedDims: o, idDims: l } = NR(i, a.length);
    PR(s.length, l, a);
    const { path: u, steps: c } = $R(o, l), h = c.length;
    let f = null, d = s.length;
    const p = [];
    for (let g = 0; g < h; ++g) {
      for (const v of c[g]) {
        const { permutationIndices: m, expandDims: y } = LR(d, l[v]);
        let x;
        OR(m) ? x = a[v] : (x = bi({
          inputs: {
            x: a[v]
          },
          backend: e,
          attrs: {
            perm: m
          }
        }), p.push(x));
        const b = x.shape.slice();
        for (let _ = 0; _ < y.length; ++_) b.splice(y[_], 0, 1);
        Xe(x.shape, b) || (x = pn({
          inputs: {
            x
          },
          backend: e,
          attrs: {
            shape: b
          }
        }), p.push(x)), f === null ? f = x : (f = Aw({
          inputs: {
            a: x,
            b: f
          },
          backend: e
        }), p.push(f));
      }
      g < h - 1 && (u[g] >= 0 && (f = cy({
        inputs: {
          x: f
        },
        backend: e,
        attrs: {
          axis: u[g] - (s.length - d),
          keepDims: false
        }
      }), p.push(f)), d--);
    }
    for (const g of p) g !== f && e.disposeIntermediateTensorInfo(g);
    return f;
  }
  const i$t = {
    kernelName: dM,
    backendName: "cpu",
    kernelFunc: r$t
  };
  function a$t(n) {
    const { inputs: t, backend: e } = n, { dy: r, y: i } = t;
    zt([
      r,
      i
    ], "eluGrad");
    const a = new Float32Array(lt(i.shape)), s = e.data.get(i.dataId).values, o = e.data.get(r.dataId).values;
    for (let l = 0; l < s.length; ++l) {
      const u = s[l];
      u >= 0 ? a[l] = o[l] : a[l] = o[l] * (u + 1);
    }
    return e.makeTensorInfo(i.shape, "float32", a);
  }
  const s$t = {
    kernelName: pM,
    backendName: "cpu",
    kernelFunc: a$t
  };
  const o$t = IR, l$t = AR, u$t = kR, c$t = DR, h$t = ER, f$t = MR, d$t = Qe(dm, (n) => {
    const t = Math.sign(n), e = Math.abs(n), r = 1 / (1 + o$t * e);
    return t * (1 - ((((f$t * r + h$t) * r + c$t) * r + u$t) * r + l$t) * r * Math.exp(-e * e));
  }), p$t = {
    kernelName: dm,
    backendName: "cpu",
    kernelFunc: d$t
  };
  function n1(n) {
    const { inputs: t, backend: e, attrs: r } = n, { input: i } = t, { dim: a } = r, s = i.shape.length, o = i.shape.slice();
    let l = a;
    return a < 0 && (B(-(s + 1) <= a, () => `Axis must be in the interval [${-(s + 1)}, ${s}]`), l = s + a + 1), o.splice(l, 0, 1), pn({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: o
      }
    });
  }
  const g$t = {
    kernelName: y_,
    backendName: "cpu",
    kernelFunc: n1
  };
  const v$t = Ln((n, t) => n / t), gN = Qn(hm, v$t), W2 = {
    kernelName: hm,
    backendName: "cpu",
    kernelFunc: gN
  };
  function DZ(n, t, e) {
    const r = n.shape, i = r[0], a = r[1], s = e.data.get(n.dataId), o = s.complexTensorInfos.real, l = s.complexTensorInfos.imag, u = [
      i,
      a
    ], c = lt(u), h = Dr("float32", c), f = Dr("float32", c);
    for (let v = 0; v < i; v++) {
      const m = lh({
        inputs: {
          x: o
        },
        backend: e,
        attrs: {
          begin: [
            v,
            0
          ],
          size: [
            1,
            a
          ]
        }
      }), y = lh({
        inputs: {
          x: l
        },
        backend: e,
        attrs: {
          begin: [
            v,
            0
          ],
          size: [
            1,
            a
          ]
        }
      }), x = Mi({
        inputs: {
          real: m,
          imag: y
        },
        backend: e
      }), { real: b, imag: _ } = m$t(x, t, e), w = Ko(b, _);
      for (let S = 0; S < a; S++) {
        const I = RR(w, S);
        h[v * a + S] = I.real, f[v * a + S] = I.imag;
      }
      e.disposeIntermediateTensorInfo(m), e.disposeIntermediateTensorInfo(y), e.disposeIntermediateTensorInfo(x);
    }
    const d = e.makeTensorInfo(u, "float32", h), p = e.makeTensorInfo(u, "float32", f), g = Mi({
      inputs: {
        real: d,
        imag: p
      },
      backend: e
    });
    return e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(p), g;
  }
  function m$t(n, t, e) {
    const r = lt(n.shape), i = e.data.get(n.dataId), a = e.data.get(i.complexTensorInfos.real.dataId).values, s = e.data.get(i.complexTensorInfos.imag.dataId).values;
    if (y$t(r)) {
      const o = U2(a, s, r, t, e), l = [
        n.shape[0],
        n.shape[1]
      ];
      if (t) {
        const u = e.makeTensorInfo(l, "float32", o.real), c = e.makeTensorInfo(l, "float32", o.imag), h = e.makeTensorInfo([], "float32", uu(r, "float32")), f = lo({
          inputs: {
            x: h
          },
          backend: e
        }), d = W2.kernelFunc({
          inputs: {
            a: u,
            b: h
          },
          backend: e
        }), p = W2.kernelFunc({
          inputs: {
            a: c,
            b: f
          },
          backend: e
        }), g = e.data.get(d.dataId).values, v = e.data.get(p.dataId).values;
        return e.disposeIntermediateTensorInfo(u), e.disposeIntermediateTensorInfo(c), e.disposeIntermediateTensorInfo(h), e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(p), {
          real: g,
          imag: v
        };
      }
      return o;
    } else {
      const o = Ko(a, s), l = x$t(o, r, t);
      return Gj(l);
    }
  }
  function y$t(n) {
    return (n & n - 1) === 0;
  }
  function U2(n, t, e, r, i) {
    if (e === 1) return {
      real: n,
      imag: t
    };
    const a = Ko(n, t), s = e / 2, o = Wj(a), l = o.real, u = o.imag, c = [
      l.length
    ], h = i.makeTensorInfo(c, "float32", l), f = i.makeTensorInfo(c, "float32", u), d = Mi({
      inputs: {
        real: h,
        imag: f
      },
      backend: i
    }), p = Uj(a), g = p.real, v = p.imag, m = [
      g.length
    ], y = i.makeTensorInfo(m, "float32", g), x = i.makeTensorInfo(m, "float32", v), b = Mi({
      inputs: {
        real: y,
        imag: x
      },
      backend: i
    }), _ = U2(l, u, s, r, i), w = _.real, S = _.imag, I = [
      w.length
    ], T = i.makeTensorInfo(I, "float32", w), A = i.makeTensorInfo(I, "float32", S), C = Mi({
      inputs: {
        real: T,
        imag: A
      },
      backend: i
    }), D = U2(g, v, s, r, i), E = D.real, M = D.imag, L = [
      E.length
    ], k = i.makeTensorInfo(L, "float32", E), N = i.makeTensorInfo(L, "float32", M), R = Mi({
      inputs: {
        real: k,
        imag: N
      },
      backend: i
    }), $ = Xj(e, r), O = [
      $.real.length
    ], F = i.makeTensorInfo(O, "float32", $.real), z = i.makeTensorInfo(O, "float32", $.imag), V = Mi({
      inputs: {
        real: F,
        imag: z
      },
      backend: i
    }), U = Aw({
      inputs: {
        a: V,
        b: R
      },
      backend: i
    }), X = id({
      inputs: {
        a: C,
        b: U
      },
      backend: i
    }), at = dN({
      inputs: {
        a: C,
        b: U
      },
      backend: i
    }), pt = oh({
      inputs: {
        input: X
      },
      backend: i
    }), it = oh({
      inputs: {
        input: at
      },
      backend: i
    }), et = ad({
      inputs: {
        input: X
      },
      backend: i
    }), ft = ad({
      inputs: {
        input: at
      },
      backend: i
    }), ut = sd({
      inputs: [
        pt,
        it
      ],
      backend: i,
      attrs: {
        axis: 0
      }
    }), gt = sd({
      inputs: [
        et,
        ft
      ],
      backend: i,
      attrs: {
        axis: 0
      }
    }), kt = i.data.get(ut.dataId).values, At = i.data.get(gt.dataId).values;
    return i.disposeIntermediateTensorInfo(h), i.disposeIntermediateTensorInfo(f), i.disposeIntermediateTensorInfo(d), i.disposeIntermediateTensorInfo(y), i.disposeIntermediateTensorInfo(x), i.disposeIntermediateTensorInfo(b), i.disposeIntermediateTensorInfo(T), i.disposeIntermediateTensorInfo(A), i.disposeIntermediateTensorInfo(C), i.disposeIntermediateTensorInfo(k), i.disposeIntermediateTensorInfo(N), i.disposeIntermediateTensorInfo(R), i.disposeIntermediateTensorInfo(F), i.disposeIntermediateTensorInfo(z), i.disposeIntermediateTensorInfo(V), i.disposeIntermediateTensorInfo(U), i.disposeIntermediateTensorInfo(X), i.disposeIntermediateTensorInfo(at), i.disposeIntermediateTensorInfo(pt), i.disposeIntermediateTensorInfo(et), i.disposeIntermediateTensorInfo(it), i.disposeIntermediateTensorInfo(ft), i.disposeIntermediateTensorInfo(ut), i.disposeIntermediateTensorInfo(gt), {
      real: kt,
      imag: At
    };
  }
  function x$t(n, t, e) {
    const r = new Float32Array(t * 2);
    for (let i = 0; i < t; i++) {
      let a = 0, s = 0;
      for (let o = 0; o < t; o++) {
        const l = Yj(i * o, t, e), u = RR(n, o);
        a += u.real * l.real - u.imag * l.imag, s += u.real * l.imag + u.imag * l.real;
      }
      e && (a /= t, s /= t), Hj(r, a, s, i);
    }
    return r;
  }
  function b$t(n) {
    const { inputs: t, backend: e } = n, { input: r } = t, i = lt(r.shape), a = r.shape[r.shape.length - 1], s = i / a, o = pn({
      inputs: {
        x: r
      },
      backend: e,
      attrs: {
        shape: [
          s,
          a
        ]
      }
    }), l = DZ(o, false, e), u = pn({
      inputs: {
        x: l
      },
      backend: e,
      attrs: {
        shape: r.shape
      }
    });
    return e.disposeIntermediateTensorInfo(o), e.disposeIntermediateTensorInfo(l), u;
  }
  const _$t = {
    kernelName: gM,
    backendName: "cpu",
    kernelFunc: b$t
  };
  function vN(n) {
    const { backend: t, attrs: e } = n, { shape: r, value: i, dtype: a } = e, s = a || Rd(i), o = kn(s, lt(r));
    return S$t(o, i, s), t.makeTensorInfo(r, s, o);
  }
  const w$t = {
    kernelName: vM,
    backendName: "cpu",
    kernelFunc: vN
  };
  function S$t(n, t, e) {
    n.fill(t);
  }
  const C$t = {
    kernelName: mM,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
      const { image: r } = n, i = e, a = Dr(r.dtype, lt(r.shape)), [s, o, l, u] = r.shape, c = i.data.get(r.dataId).values;
      for (let f = 0; f < s; f++) {
        const d = f * l * o * u;
        for (let p = 0; p < o; p++) {
          const g = p * (l * u);
          for (let v = 0; v < l; v++) {
            const m = v * u;
            for (let y = 0; y < u; y++) {
              const x = Math.round(l - v - 1), b = d + g + m + y;
              let _ = c[b];
              if (x >= 0 && x < l) {
                const w = x * u, S = d + g + w + y;
                _ = c[S];
              }
              a[b] = _;
            }
          }
        }
      }
      return {
        dataId: i.write(a, r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      };
    }
  };
  function T$t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = t, { strides: l, pad: u, dataFormat: c, dilations: h, dimRoundingMode: f, activation: d, leakyreluAlpha: p } = r;
    let g = AZ({
      inputs: {
        x: i,
        filter: a
      },
      backend: e,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: f
      }
    });
    if (s) {
      const v = g;
      if (c === "NCHW" && s.shape.length === 1 && s.shape[0] !== 1) {
        const m = pn({
          inputs: {
            x: s
          },
          backend: e,
          attrs: {
            shape: [
              s.shape[0],
              1,
              1
            ]
          }
        });
        g = id({
          inputs: {
            a: g,
            b: m
          },
          backend: e
        }), e.disposeIntermediateTensorInfo(m);
      } else g = id({
        inputs: {
          a: g,
          b: s
        },
        backend: e
      });
      e.disposeIntermediateTensorInfo(v);
    }
    if (d) {
      const v = g;
      if (c === "NCHW" && d === "prelu" && o.shape.length === 1 && o.shape[0] !== 1) {
        const m = pn({
          inputs: {
            x: o
          },
          backend: e,
          attrs: {
            shape: [
              o.shape[0],
              1,
              1
            ]
          }
        });
        g = e1(e, g, d, m, p), e.disposeIntermediateTensorInfo(m);
      } else g = e1(e, g, d, o, p);
      e.disposeIntermediateTensorInfo(v);
    }
    return g;
  }
  const I$t = {
    kernelName: $b,
    backendName: "cpu",
    kernelFunc: T$t
  };
  function A$t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = t, { strides: l, pad: u, dataFormat: c, dilations: h, dimRoundingMode: f, activation: d, leakyreluAlpha: p } = r;
    let g = kZ({
      inputs: {
        x: i,
        filter: a
      },
      backend: e,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: f
      }
    });
    if (s) {
      const v = g;
      g = id({
        inputs: {
          a: g,
          b: s
        },
        backend: e
      }), e.disposeIntermediateTensorInfo(v);
    }
    if (d) {
      const v = g;
      g = e1(e, g, d, o, p), e.disposeIntermediateTensorInfo(v);
    }
    return g;
  }
  const k$t = {
    kernelName: yq,
    backendName: "cpu",
    kernelFunc: A$t
  };
  function D$t(n) {
    const { inputs: t, backend: e } = n, { params: r, indices: i } = t, a = lt(r.shape), s = i.shape, o = s[s.length - 1], [l, u, c, h] = gR(r, i);
    if (u === 0) return e.makeTensorInfo(l, r.dtype, []);
    const f = e.data.get(i.dataId).values, d = e.bufferSync(r), p = BK(f, d, r.dtype, u, o, c, h, r.shape, a);
    return e.makeTensorInfo(l, r.dtype, p.values);
  }
  const E$t = {
    kernelName: tq,
    backendName: "cpu",
    kernelFunc: D$t
  };
  function M$t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, indices: a } = t, { axis: s, batchDims: o } = r;
    zt([
      i,
      a
    ], "gatherV2");
    const l = Se(s, i.shape)[0], u = e.data.get(a.dataId).values, c = i.shape[l];
    for (let b = 0; b < u.length; ++b) {
      const _ = u[b];
      B(_ <= c - 1 && _ >= 0, () => `GatherV2: the index value ${_} is not in [0, ${c - 1}]`);
    }
    let h = o;
    o == null && (h = 0);
    const f = lt(a.shape), d = BR(i, a, l, h), p = pn({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: [
          d.batchSize,
          d.outerSize,
          d.dimSize,
          d.sliceSize
        ]
      }
    }), g = pn({
      inputs: {
        x: a
      },
      backend: e,
      attrs: {
        shape: [
          d.batchSize,
          f / d.batchSize
        ]
      }
    }), v = [
      d.batchSize,
      d.outerSize,
      f / d.batchSize,
      d.sliceSize
    ], m = e.bufferSync(g), y = e.bufferSync(p), x = zK(y, m, v);
    return e.disposeIntermediateTensorInfo(p), e.disposeIntermediateTensorInfo(g), e.makeTensorInfo(d.outputShape, x.dtype, x.values);
  }
  const R$t = {
    kernelName: b_,
    backendName: "cpu",
    kernelFunc: M$t
  };
  function N$t(n) {
    const { inputs: t, backend: e } = n, { input: r } = t, i = lt(r.shape), a = r.shape[r.shape.length - 1], s = i / a, o = pn({
      inputs: {
        x: r
      },
      backend: e,
      attrs: {
        shape: [
          s,
          a
        ]
      }
    }), l = DZ(o, true, e), u = pn({
      inputs: {
        x: l
      },
      backend: e,
      attrs: {
        shape: r.shape
      }
    });
    return e.disposeIntermediateTensorInfo(o), e.disposeIntermediateTensorInfo(l), u;
  }
  const L$t = {
    kernelName: yM,
    backendName: "cpu",
    kernelFunc: N$t
  };
  const P$t = Qe(bm, (n) => Number.isFinite(n) ? 1 : 0, "bool"), $$t = {
    kernelName: bm,
    backendName: "cpu",
    kernelFunc: P$t
  };
  const O$t = Qe(_m, (n) => Math.abs(n) === 1 / 0 ? 1 : 0, "bool"), F$t = {
    kernelName: _m,
    backendName: "cpu",
    kernelFunc: O$t
  };
  const B$t = Qe(wm, (n) => Number.isNaN(n) ? 1 : 0, "bool"), z$t = {
    kernelName: wm,
    backendName: "cpu",
    kernelFunc: B$t
  };
  function V$t(n) {
    const { backend: t, attrs: e } = n, { start: r, stop: i, num: a } = e, s = HK(r, i, a);
    return t.makeTensorInfo([
      s.length
    ], "float32", s);
  }
  const G$t = {
    kernelName: eq,
    backendName: "cpu",
    kernelFunc: V$t
  };
  const W$t = Qe(Cm, (n) => Math.log1p(n)), U$t = {
    kernelName: Cm,
    backendName: "cpu",
    kernelFunc: W$t
  };
  const H$t = Ln((n, t) => n && t), X$t = Qn(T_, H$t, null, "bool"), Y$t = {
    kernelName: T_,
    backendName: "cpu",
    kernelFunc: X$t
  };
  const q$t = Qe(I_, (n) => n ? 0 : 1, "bool"), j$t = {
    kernelName: I_,
    backendName: "cpu",
    kernelFunc: q$t
  };
  const K$t = Ln((n, t) => n || t), Z$t = Qn(A_, K$t, null, "bool"), J$t = {
    kernelName: A_,
    backendName: "cpu",
    kernelFunc: Z$t
  };
  function Q$t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { depthRadius: a, bias: s, alpha: o, beta: l } = r;
    zt(i, "LRN");
    const u = i.shape[3], c = u - 1, h = e.data.get(i.dataId).values, f = lt(i.shape), d = new Float32Array(f);
    function p(g) {
      const v = g % u;
      let m = g - v + Math.max(0, v - a);
      const y = g - v + Math.min(v + a, c);
      let x = 0;
      for (; m <= y; m++) {
        const b = h[m];
        x += b * b;
      }
      return x;
    }
    for (let g = 0; g < f; g++) {
      const v = p(g), m = h[g] * Math.pow(s + o * v, -l);
      d[g] = m;
    }
    return e.makeTensorInfo(i.shape, i.dtype, d);
  }
  const tOt = {
    kernelName: k_,
    backendName: "cpu",
    kernelFunc: Q$t
  };
  function eOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, y: a, dy: s } = t, { depthRadius: o, bias: l, alpha: u, beta: c } = r;
    zt(s, "LRNGrad");
    const h = lt(s.shape), f = s.shape[3], d = e.data.get(s.dataId).values, p = e.data.get(i.dataId).values, g = e.data.get(a.dataId).values, v = new Float32Array(h), m = h;
    for (let y = 0; y < m; y++) {
      const x = y % f, b = y - x + Math.max(0, x - o), _ = y - x + Math.min(f, x + o + 1);
      let w = 0;
      for (let S = b; S < _; S++) w += Math.pow(p[S], 2);
      w = u * w + l;
      for (let S = b; S < _; S++) {
        let I = -2 * u * c * p[S] * g[y] / w;
        y === S && (I += Math.pow(w, -c)), I *= d[y], v[S] += I;
      }
    }
    return e.makeTensorInfo(s.shape, i.dtype, v);
  }
  const nOt = {
    kernelName: bM,
    backendName: "cpu",
    kernelFunc: eOt
  };
  function EZ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { reductionIndices: a, keepDims: s } = r, o = e;
    let l = i.shape;
    const u = l.length, c = Se(a, l);
    let h = c;
    const f = wn(h, u);
    let d = o.data.get(i.dataId).values;
    if (f != null) {
      const b = new Array(u);
      for (let _ = 0; _ < b.length; _++) b[_] = l[f[_]];
      d = hN(d, l, i.dtype, f, b), h = Rn(h.length, u), l = b;
    }
    zt(i, "max"), wr("max", h, u);
    const [p, g] = hr(l, h), v = lt(g), m = YK(d, v, p, i.dtype), y = o.write(m, p, i.dtype);
    let x = p;
    return s && (x = Bn(p, c)), {
      dataId: y,
      shape: x,
      dtype: i.dtype
    };
  }
  const rOt = {
    kernelName: D_,
    backendName: "cpu",
    kernelFunc: EZ
  };
  function iOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t;
    zt(i, "maxPool");
    const { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, u = 1;
    B(Rr(s, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = Ra(i.shape, a, s, u, o, l);
    let h;
    if (c.filterWidth === 1 && c.filterHeight === 1 && Xe(c.inShape, c.outShape)) h = lo({
      inputs: {
        x: i
      },
      backend: e
    });
    else {
      const f = e.data.get(i.dataId).values, d = Yt(i.shape), p = pN(f, i.shape, i.dtype, d, c, "max");
      h = e.makeTensorInfo(c.outShape, i.dtype, p.values);
    }
    return h;
  }
  const aOt = {
    kernelName: E_,
    backendName: "cpu",
    kernelFunc: iOt
  };
  function sOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { filterSize: a, strides: s, pad: o, dimRoundingMode: l, dataFormat: u } = r;
    zt(i, "maxPool3d");
    const c = rl(i.shape, a, s, 1, o, l, u), h = e.data.get(i.dataId).values, f = IZ(h, i.shape, i.dtype, Yt(i.shape), c, "max");
    return e.makeTensorInfo(f.shape, "float32", f.values);
  }
  const oOt = {
    kernelName: M_,
    backendName: "cpu",
    kernelFunc: sOt
  };
  function lOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, input: a } = t, { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = r;
    zt([
      i,
      a
    ], "maxPool3DGrad");
    const c = rl(a.shape, s, o, 1, l, u), h = e.bufferSync(a), f = KLt(h, c), d = c.strideDepth, p = c.strideHeight, g = c.strideWidth, v = c.dilationDepth, m = c.dilationHeight, y = c.dilationWidth, x = c.effectiveFilterDepth, b = c.effectiveFilterHeight, _ = c.effectiveFilterWidth, w = x - 1 - c.padInfo.front, S = _ - 1 - c.padInfo.left, I = b - 1 - c.padInfo.top, T = we(a.shape, "float32"), A = e.bufferSync(i);
    for (let C = 0; C < c.batchSize; ++C) for (let D = 0; D < c.inChannels; ++D) for (let E = 0; E < c.inDepth; ++E) for (let M = 0; M < c.inHeight; ++M) for (let L = 0; L < c.inWidth; ++L) {
      const k = E - w, N = M - I, R = L - S;
      let $ = 0;
      for (let O = 0; O < x; O += v) {
        const F = (k + O) / d;
        if (!(F < 0 || F >= c.outDepth || Math.floor(F) !== F)) for (let z = 0; z < b; z += m) {
          const V = (N + z) / p;
          if (!(V < 0 || V >= c.outHeight || Math.floor(V) !== V)) for (let U = 0; U < _; U += y) {
            const X = (R + U) / g;
            if (X < 0 || X >= c.outWidth || Math.floor(X) !== X) continue;
            const at = x * b * _ - 1 - f.get(C, F, V, X, D), pt = O * b * _ + z * _ + U, it = at === pt ? 1 : 0;
            if (it === 0) continue;
            const et = A.get(C, F, V, X, D);
            $ += et * it;
          }
        }
      }
      T.set($, C, E, M, L, D);
    }
    return e.makeTensorInfo(T.shape, T.dtype, T.values);
  }
  const uOt = {
    kernelName: wM,
    backendName: "cpu",
    kernelFunc: lOt
  };
  function cOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, input: a, output: s } = t, o = a;
    zt([
      a,
      s
    ], "maxPoolGrad");
    const { filterSize: l, strides: u, pad: c, dimRoundingMode: h } = r, f = Ra(o.shape, l, u, 1, c, h), d = e.data.get(o.dataId).values, p = we(f.outShape, o.dtype, TZ(d, o.shape, o.dtype, f).values), g = f.strideHeight, v = f.strideWidth, m = f.dilationHeight, y = f.dilationWidth, x = f.effectiveFilterHeight, b = f.effectiveFilterWidth, _ = b - 1 - f.padInfo.left, w = x - 1 - f.padInfo.top, S = we(o.shape, "float32"), I = e.data.get(i.dataId).values, T = we(i.shape, "float32", I);
    for (let A = 0; A < f.batchSize; ++A) for (let C = 0; C < f.inChannels; ++C) for (let D = 0; D < f.inHeight; ++D) for (let E = 0; E < f.inWidth; ++E) {
      const M = D - w, L = E - _;
      let k = 0;
      for (let N = 0; N < x; N += m) {
        const R = (M + N) / g;
        if (!(R < 0 || R >= f.outHeight || Math.floor(R) !== R)) for (let $ = 0; $ < b; $ += y) {
          const O = (L + $) / v;
          if (O < 0 || O >= f.outWidth || Math.floor(O) !== O) continue;
          const F = x * b - 1 - p.get(A, R, O, C), z = N * b + $, V = F === z ? 1 : 0;
          if (V === 0) continue;
          const U = T.get(A, R, O, C);
          k += U * V;
        }
      }
      S.set(k, A, D, E, C);
    }
    return e.makeTensorInfo(S.shape, S.dtype, S.values);
  }
  const hOt = {
    kernelName: _M,
    backendName: "cpu",
    kernelFunc: cOt
  };
  function fOt(n, t, e, r, i) {
    const a = Yt(t), s = pN(n, t, e, a, i, "max"), o = TZ(n, t, e, i, true, r);
    return [
      s.values,
      o.values
    ];
  }
  const dOt = {
    kernelName: nq,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
      const { x: r } = n, { filterSize: i, strides: a, pad: s, includeBatchInIndex: o } = t, l = e;
      zt(r, "MaxPoolWithArgmax");
      const u = l.data.get(r.dataId).values, c = Ra(r.shape, i, a, [
        1,
        1
      ], s), [h, f] = fOt(u, r.shape, r.dtype, o, c), d = l.write(h, c.outShape, r.dtype), p = l.write(f, c.outShape, r.dtype);
      return [
        {
          dataId: d,
          shape: c.outShape,
          dtype: r.dtype
        },
        {
          dataId: p,
          shape: c.outShape,
          dtype: "int32"
        }
      ];
    }
  };
  function pOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r, o = Se(a, i.shape), u = hr(i.shape, o)[1], c = lt(u), h = [], f = e.makeTensorInfo([], "float32", new Float32Array([
      c
    ]));
    h.push(f);
    const d = au({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        dtype: "float32"
      }
    });
    h.push(d);
    const p = gN({
      inputs: {
        a: d,
        b: f
      },
      backend: e
    });
    h.push(p);
    const g = cy({
      inputs: {
        x: p
      },
      backend: e,
      attrs: {
        axis: a,
        keepDims: s
      }
    });
    return h.forEach((v) => e.disposeIntermediateTensorInfo(v)), g;
  }
  const gOt = {
    kernelName: R_,
    backendName: "cpu",
    kernelFunc: pOt
  };
  function vOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r;
    zt(i, "min");
    const o = Se(a, i.shape);
    let l = o;
    const u = wn(l, i.shape.length);
    let c = i;
    u != null && (c = bi({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: u
      }
    }), l = Rn(l.length, i.shape.length)), wr("min", l, c.shape.length);
    const [h, f] = hr(c.shape, l), d = lt(f), p = Er(lt(h), c.dtype), g = e.data.get(c.dataId).values;
    for (let m = 0; m < p.length; ++m) {
      const y = m * d;
      let x = g[y];
      for (let b = 0; b < d; ++b) {
        const _ = g[y + b];
        (Number.isNaN(_) || _ < x) && (x = _);
      }
      p[m] = x;
    }
    u != null && e.disposeIntermediateTensorInfo(c);
    const v = e.makeTensorInfo(h, c.dtype, p);
    if (s) {
      const m = Bn(h, o), y = pn({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          shape: m
        }
      });
      return e.disposeIntermediateTensorInfo(v), y;
    }
    return v;
  }
  const mOt = {
    kernelName: N_,
    backendName: "cpu",
    kernelFunc: vOt
  };
  function yOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { paddings: a, mode: s } = r;
    zt(i, "mirrorPad");
    const o = a.map((x, b) => x[0] + i.shape[b] + x[1]), l = a.map((x) => x[0]), u = a.map((x, b) => x[0] + i.shape[b]), c = s === "reflect" ? 0 : 1, h = e.data.get(i.dataId).values, f = i.shape.length, d = Yt(i.shape), p = lt(o), g = o.length, v = Yt(o), m = Dr(i.dtype, p);
    for (let x = 0; x < p; x++) {
      let b = Nd(x, g, v);
      for (let w = 0; w < g; w++) b[w] < l[w] ? b[w] = l[w] * 2 - b[w] - c : b[w] >= u[w] && (b[w] = (u[w] - 1) * 2 - b[w] + c);
      b = b.map((w, S) => w - l[S]);
      const _ = Ys(b, f, d);
      m[x] = h[_];
    }
    return {
      dataId: e.write(m, o, i.dtype),
      shape: o,
      dtype: i.dtype
    };
  }
  const xOt = {
    kernelName: L_,
    backendName: "cpu",
    kernelFunc: yOt
  };
  const bOt = Ln((n, t) => {
    const e = n % t;
    return n < 0 && t < 0 || n >= 0 && t >= 0 ? e : (e + t) % t;
  }), _Ot = Qn(Am, bOt), wOt = {
    kernelName: Am,
    backendName: "cpu",
    kernelFunc: _Ot
  };
  function MZ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { logits: i } = t, { dim: a } = r, s = i.shape.length;
    let o = a;
    if (o === -1 && (o = s - 1), o !== s - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${s} and dim was ${o}`);
    const l = Se([
      o
    ], i.shape), u = EZ({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        reductionIndices: l,
        keepDims: false
      }
    }), c = Bn(u.shape, l), h = pn({
      inputs: {
        x: u
      },
      backend: e,
      attrs: {
        shape: c
      }
    }), f = dN({
      inputs: {
        a: i,
        b: h
      },
      backend: e
    }), d = PK({
      inputs: {
        x: f
      },
      backend: e
    }), p = cy({
      inputs: {
        x: d
      },
      backend: e,
      attrs: {
        axis: l,
        keepDims: false
      }
    }), g = pn({
      inputs: {
        x: p
      },
      backend: e,
      attrs: {
        shape: c
      }
    }), v = gN({
      inputs: {
        a: d,
        b: g
      },
      backend: e
    });
    return e.disposeIntermediateTensorInfo(u), e.disposeIntermediateTensorInfo(h), e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(p), e.disposeIntermediateTensorInfo(g), v;
  }
  const SOt = {
    kernelName: J_,
    backendName: "cpu",
    kernelFunc: MZ
  };
  function COt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { logits: i } = t, { numSamples: a, seed: s, normalized: o } = r;
    zt(i, "multinomial");
    const l = o ? i : MZ({
      inputs: {
        logits: i
      },
      backend: e,
      attrs: {
        dim: -1
      }
    }), u = l.shape[0], c = l.shape[1], h = e.data.get(l.dataId).values, f = [
      u,
      a
    ], d = Er(lt(f), "int32");
    for (let p = 0; p < u; ++p) {
      const g = p * c, v = new Float32Array(c - 1);
      v[0] = h[g];
      for (let x = 1; x < v.length; ++x) v[x] = v[x - 1] + h[g + x];
      const m = eR.alea(s.toString()), y = p * a;
      for (let x = 0; x < a; ++x) {
        const b = m();
        d[y + x] = v.length;
        for (let _ = 0; _ < v.length; _++) if (b < v[_]) {
          d[y + x] = _;
          break;
        }
      }
    }
    return o || e.disposeIntermediateTensorInfo(l), e.makeTensorInfo(f, "int32", d);
  }
  const TOt = {
    kernelName: rq,
    backendName: "cpu",
    kernelFunc: COt
  };
  const IOt = cR;
  function AOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { boxes: i, scores: a } = t, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l } = r;
    zt(i, "NonMaxSuppression");
    const u = e.data.get(i.dataId).values, c = e.data.get(a.dataId).values, { selectedIndices: h } = IOt(u, c, s, o, l);
    return e.makeTensorInfo([
      h.length
    ], "int32", new Int32Array(h));
  }
  const kOt = {
    kernelName: SM,
    backendName: "cpu",
    kernelFunc: AOt
  };
  const DOt = hR;
  function EOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { boxes: i, scores: a } = t, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, padToMaxOutputSize: u } = r;
    zt(i, "NonMaxSuppressionPadded");
    const c = e.data.get(i.dataId).values, h = e.data.get(a.dataId).values, { selectedIndices: f, validOutputs: d } = DOt(c, h, s, o, l, u);
    return [
      e.makeTensorInfo([
        f.length
      ], "int32", new Int32Array(f)),
      e.makeTensorInfo([], "int32", new Int32Array([
        d
      ]))
    ];
  }
  const MOt = {
    kernelName: CM,
    backendName: "cpu",
    kernelFunc: EOt
  };
  const ROt = fR;
  function NOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { boxes: i, scores: a } = t, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, softNmsSigma: u } = r;
    zt(i, "NonMaxSuppressionWithScore");
    const c = e.data.get(i.dataId).values, h = e.data.get(a.dataId).values, f = s, d = o, p = l, g = u, { selectedIndices: v, selectedScores: m } = ROt(c, h, f, d, p, g);
    return [
      e.makeTensorInfo([
        v.length
      ], "int32", new Int32Array(v)),
      e.makeTensorInfo([
        m.length
      ], "float32", new Float32Array(m))
    ];
  }
  const LOt = {
    kernelName: TM,
    backendName: "cpu",
    kernelFunc: NOt
  };
  function POt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { indices: i } = t, { dtype: a, depth: s, onValue: o, offValue: l } = r;
    zt(i, "oneHot");
    const u = lt(i.shape), c = new Float32Array(u * s);
    c.fill(l);
    const h = e.data.get(i.dataId).values;
    for (let f = 0; f < u; ++f) h[f] >= 0 && h[f] < s && (c[f * s + h[f]] = o);
    return e.makeTensorInfo([
      ...i.shape,
      s
    ], a, c);
  }
  const $Ot = {
    kernelName: F_,
    backendName: "cpu",
    kernelFunc: POt
  };
  function r1(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    if (r.dtype === "string") throw new Error("zerosLike is not supported for string tensors");
    if (r.dtype === "complex64") {
      const i = oh({
        inputs: {
          input: r
        },
        backend: e
      }), a = r1({
        inputs: {
          x: i
        },
        backend: e
      }), s = ad({
        inputs: {
          input: r
        },
        backend: e
      }), o = r1({
        inputs: {
          x: s
        },
        backend: e
      }), l = Mi({
        inputs: {
          real: a,
          imag: o
        },
        backend: e
      });
      return e.disposeIntermediateTensorInfo(i), e.disposeIntermediateTensorInfo(a), e.disposeIntermediateTensorInfo(s), e.disposeIntermediateTensorInfo(o), l;
    } else return vN({
      backend: e,
      attrs: {
        shape: r.shape,
        value: 0,
        dtype: r.dtype
      }
    });
  }
  const OOt = {
    kernelName: ew,
    backendName: "cpu",
    kernelFunc: r1
  };
  function RZ(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    if (r.dtype === "string") throw new Error("onesLike is not supported for string tensors");
    if (r.dtype === "complex64") {
      const i = oh({
        inputs: {
          input: r
        },
        backend: e
      }), a = RZ({
        inputs: {
          x: i
        },
        backend: e
      }), s = ad({
        inputs: {
          input: r
        },
        backend: e
      }), o = r1({
        inputs: {
          x: s
        },
        backend: e
      }), l = Mi({
        inputs: {
          real: a,
          imag: o
        },
        backend: e
      });
      return e.disposeIntermediateTensorInfo(i), e.disposeIntermediateTensorInfo(a), e.disposeIntermediateTensorInfo(s), e.disposeIntermediateTensorInfo(o), l;
    } else return vN({
      backend: e,
      attrs: {
        shape: r.shape,
        value: 1,
        dtype: r.dtype
      }
    });
  }
  const FOt = {
    kernelName: O_,
    backendName: "cpu",
    kernelFunc: RZ
  };
  function NZ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { axis: i } = r;
    if (t.length === 1) return n1({
      inputs: {
        input: t[0]
      },
      backend: e,
      attrs: {
        dim: i
      }
    });
    const a = t[0].shape, s = t[0].dtype;
    t.forEach((c) => {
      XE(a, c.shape, "All tensors passed to stack must have matching shapes"), B(s === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const o = [], l = t.map((c) => {
      const h = n1({
        inputs: {
          input: c
        },
        backend: e,
        attrs: {
          dim: i
        }
      });
      return o.push(h), h;
    }), u = sd({
      inputs: l,
      backend: e,
      attrs: {
        axis: i
      }
    });
    return o.forEach((c) => e.disposeIntermediateTensorInfo(c)), u;
  }
  const BOt = {
    kernelName: B_,
    backendName: "cpu",
    kernelFunc: NZ
  };
  function zOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { paddings: a, constantValue: s } = r;
    zt(i, "pad");
    const o = a.map((y, x) => y[0] + i.shape[x] + y[1]), l = a.map((y) => y[0]), u = e.data.get(i.dataId).values, c = lt(i.shape), h = i.shape.length, f = Yt(i.shape), d = lt(o), p = o.length, g = Yt(o), v = Dr(i.dtype, d);
    s !== 0 && v.fill(s);
    for (let y = 0; y < c; y++) {
      const b = Nd(y, h, f).map((w, S) => w + l[S]), _ = Ys(b, p, g);
      v[_] = u[y];
    }
    return {
      dataId: e.write(v, o, i.dtype),
      shape: o,
      dtype: i.dtype
    };
  }
  const LZ = {
    kernelName: z_,
    backendName: "cpu",
    kernelFunc: zOt
  };
  const VOt = Ln((n, t) => Math.pow(n, t)), GOt = Qn(Dm, VOt), WOt = {
    kernelName: Dm,
    backendName: "cpu",
    kernelFunc: GOt
  };
  function UOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { paramsNestedSplits: i, paramsDenseValues: a, indices: s } = t, { outputRaggedRank: o } = r, l = i.map((m) => e.data.get(m.dataId).values), u = i.map((m) => m.shape), c = e.data.get(a.dataId).values, h = e.data.get(s.dataId).values, [f, d, p] = QK(l, u, c, a.shape, a.dtype, h, s.shape), g = f.map((m) => e.makeTensorInfo([
      m.length
    ], "int32", m)), v = e.makeTensorInfo(p, a.dtype, d);
    return g.concat([
      v
    ]);
  }
  const HOt = {
    kernelName: iq,
    backendName: "cpu",
    kernelFunc: UOt
  };
  function XOt(n) {
    const { inputs: t, backend: e } = n, { starts: r, limits: i, deltas: a } = t, s = e.data.get(r.dataId).values, o = e.data.get(i.dataId).values, l = e.data.get(a.dataId).values, [u, c] = tZ(s, r.shape, r.dtype, o, i.shape, l, a.shape), h = e.makeTensorInfo([
      u.length
    ], "int32", u), f = e.makeTensorInfo([
      c.length
    ], r.dtype, c);
    return [
      h,
      f
    ];
  }
  const YOt = {
    kernelName: aq,
    backendName: "cpu",
    kernelFunc: XOt
  };
  function qOt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { shape: i, values: a, defaultValue: s, rowPartitionTensors: o } = t, { rowPartitionTypes: l } = r, u = e.data.get(i.dataId).values, c = e.data.get(a.dataId).values, h = e.data.get(s.dataId).values, f = o.map((v) => e.data.get(v.dataId).values), d = o.map((v) => v.shape), [p, g] = eZ(u, i.shape, c, a.shape, a.dtype, h, s.shape, f, d, l);
    return e.makeTensorInfo(p, a.dtype, g);
  }
  const jOt = {
    kernelName: sq,
    backendName: "cpu",
    kernelFunc: qOt
  };
  function KOt(n) {
    const { backend: t, attrs: e } = n, { start: r, stop: i, dtype: a, step: s } = e, o = nZ(r, i, s, a);
    return t.makeTensorInfo([
      o.length
    ], a, o);
  }
  const ZOt = {
    kernelName: IM,
    backendName: "cpu",
    kernelFunc: KOt
  };
  const JOt = Qe(Em, (n) => 1 / n), QOt = {
    kernelName: Em,
    backendName: "cpu",
    kernelFunc: JOt
  };
  function tFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { images: i } = t, { alignCorners: a, halfPixelCenters: s, size: o } = r;
    zt(i, "resizeBilinear");
    const l = Yt(i.shape), [u, c] = o, [h, f, d, p] = i.shape, g = e.data.get(i.dataId).values, v = new Float32Array(lt([
      h,
      u,
      c,
      p
    ])), m = [
      a && u > 1 ? f - 1 : f,
      a && c > 1 ? d - 1 : d
    ], y = [
      a && u > 1 ? u - 1 : u,
      a && c > 1 ? c - 1 : c
    ];
    let x = 0;
    const b = m[0] / y[0], _ = m[1] / y[1];
    for (let w = 0; w < h; w++) for (let S = 0; S < u; S++) {
      let I;
      s ? I = b * (S + 0.5) - 0.5 : I = b * S;
      const T = Math.max(0, Math.floor(I)), A = I - T, C = Math.min(f - 1, Math.ceil(I)), D = w * l[0] + T * l[1], E = w * l[0] + C * l[1];
      for (let M = 0; M < c; M++) {
        let L;
        s ? L = _ * (M + 0.5) - 0.5 : L = _ * M;
        const k = Math.max(0, Math.floor(L)), N = L - k, R = Math.min(d - 1, Math.ceil(L)), $ = D + k * l[2], O = E + k * l[2], F = D + R * l[2], z = E + R * l[2];
        for (let V = 0; V < p; V++) {
          const U = g[$ + V], X = g[O + V], at = g[F + V], pt = g[z + V], it = U + (at - U) * N, et = X + (pt - X) * N, ft = it + (et - it) * A;
          v[x++] = ft;
        }
      }
    }
    return e.makeTensorInfo([
      h,
      u,
      c,
      p
    ], "float32", v);
  }
  const eFt = {
    kernelName: H_,
    backendName: "cpu",
    kernelFunc: tFt
  };
  function nFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { images: i, dy: a } = t, { alignCorners: s } = r;
    zt([
      a,
      i
    ], "resizeBilinearGrad");
    const o = Yt(i.shape), [l, u, c, h] = i.shape, [, f, d] = a.shape, p = new Float32Array(l * u * c * h), g = [
      s && f > 1 ? u - 1 : u,
      s && d > 1 ? c - 1 : c
    ], v = [
      s && f > 1 ? f - 1 : f,
      s && d > 1 ? d - 1 : d
    ], m = g[0] / v[0], y = g[1] / v[1], x = e.data.get(a.dataId).values;
    let b = 0;
    for (let _ = 0; _ < l; _++) {
      const w = _ * o[0];
      for (let S = 0; S < f; S++) {
        const I = S * m, T = Math.floor(I), A = Math.min(Math.ceil(I), u - 1), C = w + T * o[1], D = w + A * o[1], E = I - T, M = 1 - E;
        for (let L = 0; L < d; L++) {
          const k = L * y, N = Math.floor(k), R = Math.min(Math.ceil(k), c - 1), $ = k - N, O = 1 - $, F = C + N * o[2], z = C + R * o[2], V = D + N * o[2], U = D + R * o[2], X = M * O, at = M * $, pt = E * O, it = E * $;
          for (let et = 0; et < h; et++) {
            const ft = x[b++];
            p[F + et] += ft * X, p[z + et] += ft * at, p[V + et] += ft * pt, p[U + et] += ft * it;
          }
        }
      }
    }
    return e.makeTensorInfo([
      l,
      c,
      u,
      h
    ], "float32", p);
  }
  const rFt = {
    kernelName: DM,
    backendName: "cpu",
    kernelFunc: nFt
  };
  function iFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { images: i } = t, { alignCorners: a, halfPixelCenters: s, size: o } = r;
    zt(i, "resizeNearestNeighbor");
    const l = Yt(i.shape), [u, c] = o, [h, f, d, p] = i.shape, g = e.data.get(i.dataId).values, v = new Float32Array(h * u * c * p), m = [
      a && u > 1 ? f - 1 : f,
      a && c > 1 ? d - 1 : d
    ], y = [
      a && u > 1 ? u - 1 : u,
      a && c > 1 ? c - 1 : c
    ], x = m[0] / y[0], b = m[1] / y[1];
    let _ = 0;
    for (let w = 0; w < h; w++) {
      const S = w * l[0];
      for (let I = 0; I < u; I++) {
        const T = s ? x * (I + 0.5) : x * I;
        let A = Math.min(f - 1, a ? Math.round(T) : Math.floor(T));
        s && (A = Math.max(0, A));
        const C = S + A * l[1];
        for (let D = 0; D < c; D++) {
          const E = s ? b * (D + 0.5) : b * D;
          let M = Math.min(d - 1, a ? Math.round(E) : Math.floor(E));
          s && (M = Math.max(0, M));
          const L = C + M * l[2];
          for (let k = 0; k < p; k++) {
            const N = g[L + k];
            v[_++] = N;
          }
        }
      }
    }
    return e.makeTensorInfo([
      h,
      u,
      c,
      p
    ], i.dtype, v);
  }
  const aFt = {
    kernelName: U_,
    backendName: "cpu",
    kernelFunc: iFt
  };
  function sFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { images: i, dy: a } = t, { alignCorners: s } = r;
    zt([
      a,
      i
    ], "resizeNearestNeighborGrad");
    const o = Yt(i.shape), l = Yt(a.shape), [u, c, h, f] = i.shape, [, d, p] = a.shape, g = new Float32Array(u * c * h * f), v = e.data.get(a.dataId).values, m = [
      s && d > 1 ? c - 1 : c,
      s && p > 1 ? h - 1 : h
    ], y = [
      s && d > 1 ? d - 1 : d,
      s && p > 1 ? p - 1 : p
    ], x = m[0] / y[0], b = m[1] / y[1], _ = 1 / x, w = 1 / b, S = Math.ceil(_) * 2 + 2, I = Math.ceil(w) * 2 + 2;
    for (let T = 0; T < u; T++) {
      const A = T * o[0];
      for (let C = 0; C < c; C++) {
        const D = A + C * o[1], E = Math.floor(C * _), M = Math.floor(E - S / 2);
        for (let L = 0; L < h; L++) {
          const k = D + L * o[2], N = Math.floor(L * w), R = Math.floor(N - I / 2);
          for (let $ = 0; $ < f; $++) {
            let O = 0;
            for (let F = 0; F < S; F++) {
              const z = F + M;
              if (z < 0 || z >= d) continue;
              const V = A + z * l[1], U = z * x, X = Math.min(c - 1, s ? Math.round(U) : Math.floor(U));
              if (C === X) for (let at = 0; at < I; at++) {
                const pt = at + R;
                if (pt < 0 || pt >= p) continue;
                const it = V + pt * l[2], et = pt * b, ft = Math.min(h - 1, s ? Math.round(et) : Math.floor(et));
                L === ft && (O += v[it + $]);
              }
            }
            g[k + $] = O;
          }
        }
      }
    }
    return e.makeTensorInfo(i.shape, i.dtype, g);
  }
  const oFt = {
    kernelName: kM,
    backendName: "cpu",
    kernelFunc: sFt
  };
  function lFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { dims: a } = r;
    zt(i, "reverse");
    const s = i.shape.length, o = Se(a, i.shape);
    if (s === 0) return lo({
      inputs: {
        x: i
      },
      backend: e
    });
    const l = new xr(i.shape, i.dtype), u = e.bufferSync(i);
    for (let c = 0; c < l.size; c++) {
      const h = l.indexToLoc(c), f = h.slice();
      o.forEach((d) => f[d] = i.shape[d] - 1 - f[d]), l.set(u.get(...f), ...h);
    }
    return e.makeTensorInfo(l.shape, l.dtype, l.values);
  }
  const uFt = {
    kernelName: X_,
    backendName: "cpu",
    kernelFunc: lFt
  };
  const cFt = {
    kernelName: $M,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
      const { image: r } = n, { radians: i, fillValue: a, center: s } = t, o = e, l = Dr(r.dtype, lt(r.shape)), [u, c, h, f] = r.shape, [d, p] = SR(s, c, h), g = 255, v = Math.sin(i), m = Math.cos(i), y = o.data.get(r.dataId).values;
      for (let b = 0; b < u; b++) {
        const _ = b * h * c * f;
        for (let w = 0; w < c; w++) {
          const S = w * (h * f);
          for (let I = 0; I < h; I++) {
            const T = I * f;
            for (let A = 0; A < f; A++) {
              const C = [
                u,
                w,
                I,
                A
              ], D = C[2], E = C[1];
              let M = (D - d) * m - (E - p) * v, L = (D - d) * v + (E - p) * m;
              M = Math.round(M + d), L = Math.round(L + p);
              let k = a;
              if (typeof a != "number" && (A === 3 ? k = g : k = a[A]), M >= 0 && M < h && L >= 0 && L < c) {
                const R = L * (h * f), $ = M * f, O = _ + R + $ + A;
                k = y[O];
              }
              const N = _ + S + T + A;
              l[N] = k;
            }
          }
        }
      }
      return {
        dataId: o.write(l, r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      };
    }
  };
  const hFt = Qe(Nm, (n) => {
    const t = Math.floor(n);
    return n - t < 0.5 ? Math.floor(n) : n - t > 0.5 ? Math.ceil(n) : t % 2 === 0 ? t : t + 1;
  }), fFt = {
    kernelName: Nm,
    backendName: "cpu",
    kernelFunc: hFt
  };
  function dFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { indices: i, updates: a } = t, { shape: s } = r, { sliceRank: o, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Sh(a, i, s), f = true, d = e.bufferSync(i), p = e.bufferSync(a), g = Tc(d, p, s, h, u, l, o, c, 0, f);
    return e.makeTensorInfo(s, g.dtype, g.values);
  }
  const pFt = {
    kernelName: oq,
    backendName: "cpu",
    kernelFunc: dFt
  };
  function gFt(n, t) {
    let e = 0, r = n.length, i = 0;
    for (; e < r; ) i = Math.floor((e + r) / 2), n[i] < t ? e = i + 1 : r = i;
    return r;
  }
  function vFt(n, t) {
    let e = 0, r = n.length, i = 0;
    for (; e < r; ) i = Math.floor((e + r) / 2), n[i] <= t ? e = i + 1 : r = i;
    return r;
  }
  function mFt(n, t, e, r, i, a) {
    const s = kn("int32", e * i);
    for (let o = 0; o < e; ++o) {
      const l = n.slice(o * r, (o + 1) * r), u = o * i;
      for (let c = 0; c < i; ++c) s[u + c] = a === "left" ? gFt(l, t[c + u]) : vFt(l, t[c + u]);
    }
    return s;
  }
  function yFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { sortedSequence: i, values: a } = t, { side: s } = r, o = e.data.get(i.dataId).values, l = e.data.get(a.dataId).values, u = mFt(o, l, i.shape[0], i.shape[1], a.shape[1], s);
    return e.makeTensorInfo(a.shape, "int32", u);
  }
  const xFt = {
    kernelName: uq,
    backendName: "cpu",
    kernelFunc: yFt
  };
  function bFt(n) {
    const { inputs: t, backend: e } = n, { condition: r, t: i, e: a } = t;
    zt([
      r,
      i,
      a
    ], "select");
    const s = r.shape.length, o = e.data.get(r.dataId).values, l = e.data.get(i.dataId).values, u = e.data.get(a.dataId).values, c = $i(i.dtype, a.dtype), h = Er(lt(i.shape), c);
    let f = 0;
    const d = s === 0 || s > 1 || i.shape.length === 1 ? 1 : lt(i.shape.slice(1));
    for (let p = 0; p < o.length; p++) for (let g = 0; g < d; g++) o[p] === 1 ? h[f++] = l[p] : h[f++] = u[p];
    return e.makeTensorInfo(i.shape, c, h);
  }
  const _Ft = {
    kernelName: Y_,
    backendName: "cpu",
    kernelFunc: bFt
  };
  const wFt = pw, SFt = gw, CFt = Qe(Pm, (n) => n >= 0 ? SFt * n : wFt * (Math.exp(n) - 1)), TFt = {
    kernelName: Pm,
    backendName: "cpu",
    kernelFunc: CFt
  };
  const IFt = Qe(Fm, (n) => n < 0 ? -1 : n > 0 ? 1 : 0), AFt = {
    kernelName: Fm,
    backendName: "cpu",
    kernelFunc: IFt
  };
  const kFt = Qe($m, (n) => Math.sin(n)), DFt = {
    kernelName: $m,
    backendName: "cpu",
    kernelFunc: kFt
  };
  const EFt = Qe(Om, (n) => Math.sinh(n)), MFt = {
    kernelName: Om,
    backendName: "cpu",
    kernelFunc: EFt
  };
  const RFt = 11920928955078125e-23, zV = Math.log(RFt) + 2, NFt = Qe(zm, (n) => {
    const t = n > -zV, e = n < zV, r = Math.exp(n);
    let i;
    return e ? i = r : t ? i = n : i = Math.log(1 + r), i;
  }), LFt = {
    kernelName: zm,
    backendName: "cpu",
    kernelFunc: NFt
  };
  function PFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { blockShape: a, paddings: s } = r;
    zt([
      i
    ], "spaceToBatchND");
    const o = lt(a), l = [
      [
        0,
        0
      ]
    ];
    l.push(...s);
    for (let w = 1 + a.length; w < i.shape.length; ++w) l.push([
      0,
      0
    ]);
    const u = LZ.kernelFunc({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        paddings: l,
        constantValue: 0
      }
    }), c = Qm(u.shape, a, o, false), h = ty(c.length, a.length, false), f = ey(u.shape, a, o, false), g = pn({
      inputs: {
        x: u
      },
      backend: e,
      attrs: {
        shape: c
      }
    }), y = bi({
      inputs: {
        x: g
      },
      backend: e,
      attrs: {
        perm: h
      }
    }), _ = pn({
      inputs: {
        x: y
      },
      backend: e,
      attrs: {
        shape: f
      }
    });
    return e.disposeIntermediateTensorInfo(u), e.disposeIntermediateTensorInfo(g), e.disposeIntermediateTensorInfo(y), _;
  }
  const $Ft = {
    kernelName: K_,
    backendName: "cpu",
    kernelFunc: PFt
  };
  function OFt(n) {
    const { inputs: t, backend: e } = n, { indices: r, values: i, denseShape: a, defaultValue: s } = t;
    if (a.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);
    if (r.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Values must be a vector, saw:
        ${i.shape}`);
    if (s.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${s.shape}`);
    const o = e.data.get(r.dataId).values, l = e.data.get(i.dataId).values, u = e.data.get(a.dataId).values, c = e.data.get(s.dataId).values[0], [h, f, d, p, g] = sZ(o, r.shape, r.dtype, l, i.dtype, u, c);
    return [
      e.makeTensorInfo(f, r.dtype, h),
      e.makeTensorInfo([
        f[0]
      ], i.dtype, d),
      e.makeTensorInfo([
        p.length
      ], "bool", new Uint8Array(p.map((v) => Number(v)))),
      e.makeTensorInfo([
        g.length
      ], r.dtype, new Int32Array(g))
    ];
  }
  const FFt = {
    kernelName: cq,
    backendName: "cpu",
    kernelFunc: OFt
  };
  function BFt(n) {
    const { inputs: t, backend: e } = n, { inputIndices: r, inputShape: i, newShape: a } = t;
    if (r.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${a.shape}`);
    const s = Array.from(e.data.get(i.dataId).values), o = e.data.get(r.dataId).values, l = Array.from(e.data.get(a.dataId).values), [u, c, h] = oZ(o, r.shape, r.dtype, s, l);
    return [
      e.makeTensorInfo(c, r.dtype, u),
      e.makeTensorInfo([
        h.length
      ], a.dtype, new Int32Array(h))
    ];
  }
  const zFt = {
    kernelName: hq,
    backendName: "cpu",
    kernelFunc: BFt
  };
  function VFt(n) {
    const { inputs: t, backend: e } = n, { data: r, indices: i, segmentIds: a } = t;
    if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (i.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);
    if (i.shape[0] !== a.shape[0]) throw new Error("segmentIds and indices should have same size.");
    const s = e.data.get(r.dataId).values, o = e.data.get(i.dataId).values, l = e.data.get(a.dataId).values, [u, c] = fN(s, r.shape, r.dtype, o, l, true);
    return e.makeTensorInfo(c, r.dtype, u);
  }
  const GFt = {
    kernelName: fq,
    backendName: "cpu",
    kernelFunc: VFt
  };
  function WFt(n) {
    const { inputs: t, backend: e } = n, { data: r, indices: i, segmentIds: a } = t;
    if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (i.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);
    if (i.shape[0] !== a.shape[0]) throw new Error("segmentIds and indices should have same size.");
    const s = e.data.get(r.dataId).values, o = e.data.get(i.dataId).values, l = e.data.get(a.dataId).values, [u, c] = fN(s, r.shape, r.dtype, o, l);
    return e.makeTensorInfo(c, r.dtype, u);
  }
  const UFt = {
    kernelName: dq,
    backendName: "cpu",
    kernelFunc: WFt
  };
  function HFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { sparseIndices: i, sparseValues: a, defaultValue: s } = t, { outputShape: o } = r, { sliceRank: l, numUpdates: u, sliceSize: c, strides: h, outputSize: f } = Sh(a, i, o), d = false, p = e.bufferSync(i);
    let g;
    switch (a.dtype) {
      case "bool": {
        const v = e.bufferSync(a), m = !!e.data.get(s.dataId).values[0];
        g = Tc(p, v, o, f, c, u, l, h, m, d);
        break;
      }
      case "float32": {
        const v = e.bufferSync(a), m = e.data.get(s.dataId).values[0];
        g = Tc(p, v, o, f, c, u, l, h, m, d);
        break;
      }
      case "int32": {
        const v = e.bufferSync(a), m = e.data.get(s.dataId).values[0];
        g = Tc(p, v, o, f, c, u, l, h, m, d);
        break;
      }
      case "string": {
        const v = e.bufferSync(a), m = tu(e.data.get(s.dataId).values[0]);
        g = Tc(p, v, o, f, c, u, l, h, m, d);
        break;
      }
      default:
        throw new Error(`Unsupported type ${a.dtype}`);
    }
    return e.makeTensorInfo(o, g.dtype, g.values);
  }
  const XFt = {
    kernelName: pq,
    backendName: "cpu",
    kernelFunc: HFt
  };
  function YFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { numOrSizeSplits: a, axis: s } = r, o = Se(s, i.shape)[0], l = FR(i, a, o), u = new Array(i.shape.length).fill(0), c = i.shape.slice();
    return l.map((h) => {
      const f = [
        ...c
      ];
      f[o] = h;
      const d = lh({
        inputs: {
          x: i
        },
        backend: e,
        attrs: {
          begin: u,
          size: f
        }
      });
      return u[o] += h, d;
    });
  }
  const qFt = {
    kernelName: Z_,
    backendName: "cpu",
    kernelFunc: YFt
  };
  const jFt = {
    kernelName: EM,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, backend: t }) => {
      const { x: e } = n, r = t;
      zt(e, "square");
      const i = r.data.get(e.dataId).values, a = new Float32Array(i.length);
      for (let o = 0; o < i.length; ++o) {
        const l = i[o];
        a[o] = l * l;
      }
      return {
        dataId: r.write(a, e.shape, e.dtype),
        shape: e.shape,
        dtype: e.dtype
      };
    }
  };
  const KFt = Qe(Ym, (n, t) => {
    const e = t;
    return isNaN(n) ? NaN : n > 0 ? 1 : e.alpha;
  }), ZFt = {
    kernelName: Ym,
    backendName: "cpu",
    kernelFunc: KFt
  };
  function JFt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { begin: a, end: s, strides: o, beginMask: l, endMask: u, ellipsisMask: c, newAxisMask: h, shrinkAxisMask: f } = r;
    zt(i, "stridedSlice");
    const { finalShapeSparse: d, finalShape: p, isIdentity: g, sliceDim0: v, isSimpleSlice: m, begin: y, end: x, strides: b } = bR(i.shape, a, s, o, l, u, c, h, f);
    let _;
    if (g) _ = pn({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: p
      }
    });
    else if (v || m) {
      B(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
      const w = mR(y, x, b), S = lh({
        inputs: {
          x: i
        },
        backend: e,
        attrs: {
          begin: y,
          size: w
        }
      });
      _ = pn({
        inputs: {
          x: S
        },
        backend: e,
        attrs: {
          shape: p
        }
      }), e.disposeIntermediateTensorInfo(S);
    } else {
      const w = e.bufferSync(i), S = cZ(d, w, b, y);
      _ = e.makeTensorInfo(p, S.dtype, S.values);
    }
    return _;
  }
  const QFt = {
    kernelName: RM,
    backendName: "cpu",
    kernelFunc: JFt
  };
  function tBt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { separator: i, nGramWidths: a, leftPad: s, rightPad: o, padWidth: l, preserveShortSequences: u } = r, { data: c, dataSplits: h } = t, f = e.data.get(c.dataId).values, d = e.data.get(h.dataId).values, [p, g] = hZ(f, d, i, a, s, o, l, u);
    return [
      e.makeTensorInfo([
        p.length
      ], "string", p),
      e.makeTensorInfo(h.shape, "int32", g)
    ];
  }
  const eBt = {
    kernelName: gq,
    backendName: "cpu",
    kernelFunc: tBt
  };
  function nBt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { skipEmpty: i } = r, { input: a, delimiter: s } = t;
    if (a.dtype !== "string") throw new Error("Input must be of datatype string");
    if (a.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${a.shape}`);
    if (s.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);
    const o = e.data.get(a.dataId).values, l = e.data.get(s.dataId).values[0], [u, c, h] = fZ(o, l, i), f = c.length;
    return [
      e.makeTensorInfo([
        f,
        2
      ], "int32", u),
      e.makeTensorInfo([
        f
      ], "string", c),
      e.makeTensorInfo([
        2
      ], "int32", new Int32Array(h))
    ];
  }
  const rBt = {
    kernelName: vq,
    backendName: "cpu",
    kernelFunc: nBt
  };
  function iBt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { numBuckets: i } = r, { input: a } = t;
    if (a.dtype !== "string") throw new Error("Input must be of datatype string");
    if (i <= 0) throw new Error("Number of buckets must be at least 1");
    const s = e.data.get(a.dataId).values, o = dZ(s, i);
    return e.makeTensorInfo(a.shape, "int32", o);
  }
  const aBt = {
    kernelName: mq,
    backendName: "cpu",
    kernelFunc: iBt
  };
  const sBt = Qe(Um, (n) => Math.tan(n)), oBt = {
    kernelName: Um,
    backendName: "cpu",
    kernelFunc: sBt
  };
  const lBt = Qe(Hm, (n) => Math.tanh(n)), uBt = {
    kernelName: Hm,
    backendName: "cpu",
    kernelFunc: lBt
  };
  function cBt(n) {
    const { inputs: t, backend: e } = n, { tensor: r, indices: i, updates: a } = t, { sliceRank: s, numUpdates: o, sliceSize: l, strides: u, outputSize: c } = Sh(a, i, r.shape), h = false, f = e.bufferSync(i), d = e.bufferSync(a), p = e.bufferSync(r), g = Tc(f, d, r.shape, c, l, o, s, u, p, h);
    return e.makeTensorInfo(r.shape, g.dtype, g.values);
  }
  const hBt = {
    kernelName: lq,
    backendName: "cpu",
    kernelFunc: cBt
  };
  function fBt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { reps: a } = r;
    zt(i, "tile");
    const s = gZ(e.bufferSync(i), a);
    return e.makeTensorInfo(s.shape, s.dtype, s.values);
  }
  const dBt = {
    kernelName: Xm,
    backendName: "cpu",
    kernelFunc: fBt
  };
  function pBt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { k: a, sorted: s } = r;
    zt(i, "topk");
    const o = e.data.get(i.dataId).values, [l, u] = mZ(o, i.shape, i.dtype, a, s);
    return [
      e.makeTensorInfo(l.shape, l.dtype, l.values),
      e.makeTensorInfo(u.shape, u.dtype, u.values)
    ];
  }
  const gBt = {
    kernelName: NM,
    backendName: "cpu",
    kernelFunc: pBt
  };
  function vBt(n) {
    const { inputs: t, attrs: e, backend: r } = n, { image: i, transforms: a } = t, { interpolation: s, fillMode: o, fillValue: l, outputShape: u } = e, [c, h, f, d] = i.shape, [p, g] = u ?? [
      h,
      f
    ], v = [
      c,
      p,
      g,
      d
    ], m = Yt(i.shape), y = m[0], x = m[1], b = m[2], _ = Yt(v), w = _[0], S = _[1], I = _[2], T = Dr(i.dtype, lt(v));
    T.fill(l);
    const A = r.data.get(i.dataId).values, C = r.data.get(a.dataId).values;
    for (let E = 0; E < c; ++E) {
      const M = a.shape[0] === 1 ? C : C.subarray(E * 8, E * 8 + 8);
      for (let L = 0; L < p; ++L) for (let k = 0; k < g; ++k) for (let N = 0; N < d; ++N) {
        let R;
        const $ = M[6] * k + M[7] * L + 1;
        if ($ === 0) continue;
        const O = (M[0] * k + M[1] * L + M[2]) / $, F = (M[3] * k + M[4] * L + M[5]) / $, z = VV(O, f, o), V = VV(F, h, o);
        switch (s) {
          case "nearest":
            R = wBt(A, h, f, y, x, b, E, V, z, N, l);
            break;
          case "bilinear":
            R = SBt(A, h, f, y, x, b, E, V, z, N, l);
            break;
          default:
            throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${s}`);
        }
        const U = E * w + L * S + k * I + N;
        T[U] = R;
      }
      return r.makeTensorInfo(v, i.dtype, T);
    }
    return {
      dataId: r.write(T, v, i.dtype),
      shape: i.shape,
      dtype: i.dtype
    };
  }
  const mBt = {
    kernelName: LM,
    backendName: "cpu",
    kernelFunc: vBt
  };
  function VV(n, t, e) {
    switch (e) {
      case "reflect":
        return yBt(n, t);
      case "wrap":
        return xBt(n, t);
      case "nearest":
        return _Bt(n, t);
      case "constant":
      default:
        return bBt(n);
    }
  }
  function yBt(n, t) {
    let e = n;
    if (e < 0) if (t <= 1) e = 0;
    else {
      const r = 2 * t;
      e < r && (e = r * Math.trunc(-e / r) + e), e = e < -t ? e + r : -e - 1;
    }
    else if (e > t - 1) if (t <= 1) e = 0;
    else {
      const r = 2 * t;
      e -= r * Math.trunc(e / r), e >= t && (e = r - e - 1);
    }
    return Kc(0, e, t - 1);
  }
  function xBt(n, t) {
    let e = n;
    if (e < 0) if (t <= 1) e = 0;
    else {
      const r = t - 1;
      e += t * (Math.trunc(-e / r) + 1);
    }
    else if (e > t - 1) if (t <= 1) e = 0;
    else {
      const r = t - 1;
      e -= t * Math.trunc(e / r);
    }
    return Kc(0, e, t - 1);
  }
  function bBt(n, t) {
    return n;
  }
  function _Bt(n, t) {
    return Kc(0, n, t - 1);
  }
  function tg(n, t, e, r, i, a, s, o, l, u, c) {
    const h = s * r + o * i + l * a + u;
    return 0 <= o && o < t && 0 <= l && l < e ? n[h] : c;
  }
  function wBt(n, t, e, r, i, a, s, o, l, u, c) {
    const h = Math.round(o), f = Math.round(l);
    return tg(n, t, e, r, i, a, s, h, f, u, c);
  }
  function SBt(n, t, e, r, i, a, s, o, l, u, c) {
    const h = Math.floor(o), f = Math.floor(l), d = h + 1, p = f + 1, g = (p - l) * tg(n, t, e, r, i, a, s, h, f, u, c) + (l - f) * tg(n, t, e, r, i, a, s, h, p, u, c), v = (p - l) * tg(n, t, e, r, i, a, s, d, f, u, c) + (l - f) * tg(n, t, e, r, i, a, s, d, p, u, c);
    return (d - o) * g + (o - h) * v;
  }
  function CBt(n) {
    const { inputs: t, attrs: e, backend: r } = n, { axis: i } = e, { x: a } = t;
    zt(a, "unique");
    const s = r.data.get(a.dataId).values, { outputValues: o, outputShape: l, indices: u } = yZ(s, i, a.shape, a.dtype);
    return [
      r.makeTensorInfo(l, a.dtype, o),
      r.makeTensorInfo([
        u.length
      ], "int32", u)
    ];
  }
  const TBt = {
    kernelName: PM,
    backendName: "cpu",
    kernelFunc: CBt
  };
  function IBt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { value: i } = t;
    let { axis: a } = r;
    a < 0 && (a += i.shape.length);
    const s = i.shape.length, o = i.shape[a], l = new Array(s - 1);
    let u = 0;
    for (let d = 0; d < s; d++) d !== a && (l[u++] = i.shape[d]);
    const c = new Array(s).fill(0), h = i.shape.slice();
    h[a] = 1;
    const f = new Array(o);
    for (let d = 0; d < f.length; d++) {
      c[a] = d;
      const p = lh({
        inputs: {
          x: i
        },
        backend: e,
        attrs: {
          begin: c,
          size: h
        }
      });
      f[d] = pn({
        inputs: {
          x: p
        },
        backend: e,
        attrs: {
          shape: l
        }
      }), e.disposeIntermediateTensorInfo(p);
    }
    return f;
  }
  const ABt = {
    kernelName: Q_,
    backendName: "cpu",
    kernelFunc: IBt
  };
  function kBt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, segmentIds: a } = t, { numSegments: s } = r;
    zt(i, "unsortedSegmentSum");
    const o = i.shape.length, l = a.shape.length, u = [], c = [], h = o - l;
    let f = a;
    for (let p = 0; p < h; ++p) {
      const g = n1({
        inputs: {
          input: f
        },
        backend: e,
        attrs: {
          dim: p + 1
        }
      });
      f = g, c.push(g);
    }
    for (let p = 0; p < s; ++p) {
      const g = uu(p, "int32"), v = e.makeTensorInfo([], "int32", g), m = NK({
        inputs: {
          a: v,
          b: f
        },
        backend: e
      }), y = au({
        inputs: {
          x: m
        },
        backend: e,
        attrs: {
          dtype: "float32"
        }
      }), x = Aw({
        inputs: {
          a: y,
          b: i
        },
        backend: e
      }), b = cy({
        inputs: {
          x
        },
        backend: e,
        attrs: {
          axis: 0,
          keepDims: false
        }
      });
      u.push(b), c.push(v), c.push(m), c.push(y), c.push(x), c.push(b);
    }
    const d = NZ({
      inputs: u,
      backend: e,
      attrs: {
        axis: 0
      }
    });
    return c.forEach((p) => e.disposeIntermediateTensorInfo(p)), d;
  }
  const DBt = {
    kernelName: tw,
    backendName: "cpu",
    kernelFunc: kBt
  };
  const EBt = [
    CLt,
    iNt,
    ILt,
    kLt,
    cNt,
    ELt,
    RLt,
    LLt,
    $Lt,
    FLt,
    zLt,
    GLt,
    ULt,
    YLt,
    jLt,
    JLt,
    tPt,
    nPt,
    iPt,
    wLt,
    sPt,
    lPt,
    cPt,
    fNt,
    fPt,
    lNt,
    pNt,
    pPt,
    aNt,
    vPt,
    yPt,
    xPt,
    _Pt,
    SPt,
    TPt,
    APt,
    DPt,
    MPt,
    NPt,
    PPt,
    OPt,
    BPt,
    VPt,
    WPt,
    UPt,
    XPt,
    qPt,
    KPt,
    ZPt,
    JPt,
    QPt,
    e$t,
    i$t,
    gLt,
    s$t,
    gNt,
    p$t,
    vNt,
    g$t,
    yNt,
    _$t,
    w$t,
    C$t,
    bNt,
    wNt,
    I$t,
    k$t,
    E$t,
    R$t,
    CNt,
    INt,
    sNt,
    L$t,
    mPt,
    $$t,
    F$t,
    z$t,
    vLt,
    kNt,
    ENt,
    G$t,
    RNt,
    U$t,
    Y$t,
    j$t,
    J$t,
    tOt,
    nOt,
    rOt,
    LNt,
    aOt,
    oOt,
    uOt,
    hOt,
    dOt,
    gOt,
    mOt,
    $Nt,
    xOt,
    wOt,
    TOt,
    FNt,
    zNt,
    kOt,
    MOt,
    LOt,
    GNt,
    $Ot,
    FOt,
    BOt,
    LZ,
    WOt,
    yLt,
    HNt,
    HOt,
    YOt,
    jOt,
    ZOt,
    oNt,
    W2,
    QOt,
    xLt,
    bLt,
    _Lt,
    eFt,
    rFt,
    aFt,
    oFt,
    uFt,
    cFt,
    fFt,
    QNt,
    pFt,
    xFt,
    _Ft,
    TFt,
    eLt,
    AFt,
    DFt,
    MFt,
    nLt,
    SOt,
    LFt,
    $Ft,
    FFt,
    zFt,
    GFt,
    UFt,
    XFt,
    qFt,
    aLt,
    jFt,
    oLt,
    uLt,
    ZFt,
    QFt,
    eBt,
    rBt,
    aBt,
    dLt,
    n$t,
    oBt,
    uBt,
    hBt,
    dBt,
    gBt,
    mBt,
    WNt,
    TBt,
    ABt,
    DBt,
    OOt
  ];
  for (const n of EBt) xq(n);
  const gc = {}, A0 = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
  };
  function MBt(n, t) {
    gc[n] = t;
  }
  function cs(n, t) {
    if (!(n in gc) || t != null) {
      const r = NBt(n, t);
      if (r !== null) gc[n] = r;
      else return console.log("Could not get context for WebGL version", n), null;
    }
    const e = gc[n];
    return e == null || e.isContextLost() ? (delete gc[n], cs(n)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), gc[n]);
  }
  function RBt(n) {
    if (!nt().getBool("IS_SAFARI") && typeof OffscreenCanvas < "u" && n === 2) return new OffscreenCanvas(300, 150);
    if (typeof document < "u") return document.createElement("canvas");
    throw new Error("Cannot create a canvas in this context");
  }
  function NBt(n, t) {
    if (n !== 1 && n !== 2) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    const e = t ?? RBt(n);
    return e.addEventListener("webglcontextlost", (r) => {
      r.preventDefault(), delete gc[n];
    }, false), nt().getBool("SOFTWARE_WEBGL_ENABLED") && (A0.failIfMajorPerformanceCaveat = false), n === 1 ? e.getContext("webgl", A0) || e.getContext("experimental-webgl", A0) : e.getContext("webgl2", A0);
  }
  var yv;
  (function(n) {
    n[n.DENSE = 0] = "DENSE", n[n.SHARED_BATCH = 1] = "SHARED_BATCH";
  })(yv || (yv = {}));
  var Hi;
  (function(n) {
    n[n.RENDER = 0] = "RENDER", n[n.UPLOAD = 1] = "UPLOAD", n[n.PIXELS = 2] = "PIXELS", n[n.DOWNLOAD = 3] = "DOWNLOAD";
  })(Hi || (Hi = {}));
  var vr;
  (function(n) {
    n[n.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", n[n.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", n[n.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", n[n.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", n[n.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
  })(vr || (vr = {}));
  function hy(n, t) {
    return [
      t,
      n
    ];
  }
  function LBt(n, t) {
    return n * t;
  }
  function k0(n) {
    const t = lt(n), e = Math.ceil(t / 4);
    return f2(e);
  }
  function Vd(n, t) {
    return [
      Math.max(1, Math.ceil(t / 2)),
      Math.max(1, Math.ceil(n / 2))
    ];
  }
  function PBt(n, t) {
    const [e, r] = Vd(n, t);
    return e * r * 4;
  }
  function mN(n, t) {
    const e = n;
    let r, i, a, s, o, l, u, c, h, f;
    return nt().getNumber("WEBGL_VERSION") === 2 ? (r = e.R32F, i = e.R16F, a = e.RGBA16F, s = e.RGBA32F, o = e.RED, u = 4, c = 1, h = e.HALF_FLOAT, f = e.FLOAT, l = e.RGBA8) : (r = n.RGBA, i = n.RGBA, a = n.RGBA, s = e.RGBA, o = n.RGBA, u = 4, c = 4, h = t != null ? t.HALF_FLOAT_OES : null, f = n.FLOAT, l = n.RGBA), {
      internalFormatFloat: r,
      internalFormatHalfFloat: i,
      internalFormatPackedHalfFloat: a,
      internalFormatPackedFloat: s,
      textureFormatFloat: o,
      downloadTextureFormat: l,
      downloadUnpackNumChannels: u,
      defaultNumChannels: c,
      textureTypeHalfFloat: h,
      textureTypeFloat: f
    };
  }
  function Dt(n, t) {
    const e = t();
    return nt().getBool("DEBUG") && $Bt(n), e;
  }
  function $Bt(n) {
    const t = n.getError();
    if (t !== n.NO_ERROR) throw new Error("WebGL Error: " + zBt(n, t));
  }
  const OBt = 596e-10, FBt = 65504;
  function BBt(n) {
    return !!(nt().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || n === 0 || OBt < Math.abs(n) && Math.abs(n) < FBt);
  }
  function zBt(n, t) {
    switch (t) {
      case n.NO_ERROR:
        return "NO_ERROR";
      case n.INVALID_ENUM:
        return "INVALID_ENUM";
      case n.INVALID_VALUE:
        return "INVALID_VALUE";
      case n.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case n.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case n.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case n.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return `Unknown error code ${t}`;
    }
  }
  function D0(n, t) {
    return al(n, () => n.getExtension(t), 'Extension "' + t + '" not supported on this browser.');
  }
  function VBt(n, t) {
    const e = al(n, () => n.createShader(n.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
    if (Dt(n, () => n.shaderSource(e, t)), Dt(n, () => n.compileShader(e)), n.getShaderParameter(e, n.COMPILE_STATUS) === false) throw console.log(n.getShaderInfoLog(e)), new Error("Failed to compile vertex shader.");
    return e;
  }
  function GBt(n, t) {
    const e = al(n, () => n.createShader(n.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
    if (Dt(n, () => n.shaderSource(e, t)), Dt(n, () => n.compileShader(e)), nt().get("ENGINE_COMPILE_ONLY")) return e;
    if (n.getShaderParameter(e, n.COMPILE_STATUS) === false) throw PZ(t, n.getShaderInfoLog(e)), new Error("Failed to compile fragment shader.");
    return e;
  }
  const WBt = /ERROR: [0-9]+:([0-9]+):/g;
  function PZ(n, t) {
    const e = WBt.exec(t);
    if (e == null) {
      console.log(`Couldn't parse line number in error: ${t}`), console.log(n);
      return;
    }
    const r = +e[1], i = n.split(`
`), a = i.length.toString().length + 2, s = i.map((h, f) => Lf((f + 1).toString(), a) + h);
    let o = 0;
    for (let h = 0; h < s.length; h++) o = Math.max(s[h].length, o);
    const l = s.slice(0, r - 1), u = s.slice(r - 1, r), c = s.slice(r);
    console.log(l.join(`
`)), console.log(t.split(`
`)[0]), console.log(`%c ${Lf(u[0], o)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c.join(`
`));
  }
  function UBt(n) {
    return al(n, () => n.createProgram(), "Unable to create WebGLProgram.");
  }
  function HBt(n, t) {
    if (Dt(n, () => n.linkProgram(t)), !nt().get("ENGINE_COMPILE_ONLY") && n.getProgramParameter(t, n.LINK_STATUS) === false) throw console.log(n.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
  }
  function IT(n, t) {
    if (Dt(n, () => n.validateProgram(t)), n.getProgramParameter(t, n.VALIDATE_STATUS) === false) throw console.log(n.getProgramInfoLog(t)), new Error("Shader program validation failed.");
  }
  function XBt(n, t) {
    const e = al(n, () => n.createBuffer(), "Unable to create WebGLBuffer");
    return Dt(n, () => n.bindBuffer(n.ARRAY_BUFFER, e)), Dt(n, () => n.bufferData(n.ARRAY_BUFFER, t, n.STATIC_DRAW)), e;
  }
  function YBt(n, t) {
    const e = al(n, () => n.createBuffer(), "Unable to create WebGLBuffer");
    return Dt(n, () => n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e)), Dt(n, () => n.bufferData(n.ELEMENT_ARRAY_BUFFER, t, n.STATIC_DRAW)), e;
  }
  function qBt(n) {
    return al(n, () => n.createTexture(), "Unable to create WebGLTexture.");
  }
  function jBt(n, t) {
    const e = nt().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (n <= 0 || t <= 0) {
      const r = `[${n}x${t}]`;
      throw new Error("Requested texture size " + r + " is invalid.");
    }
    if (n > e || t > e) {
      const r = `[${n}x${t}]`, i = `[${e}x${e}]`;
      throw new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU " + i + ".");
    }
  }
  function KBt(n) {
    return al(n, () => n.createFramebuffer(), "Unable to create WebGLFramebuffer.");
  }
  function GV(n, t, e, r, i, a, s) {
    const o = n.getAttribLocation(t, e);
    return o === -1 ? false : (Dt(n, () => n.bindBuffer(n.ARRAY_BUFFER, r)), Dt(n, () => n.vertexAttribPointer(o, i, n.FLOAT, false, a, s)), Dt(n, () => n.enableVertexAttribArray(o)), true);
  }
  function ZBt(n, t, e) {
    n3t(n, e), Dt(n, () => n.activeTexture(n.TEXTURE0 + e)), Dt(n, () => n.bindTexture(n.TEXTURE_2D, t));
  }
  function JBt(n, t, e) {
    return al(n, () => n.getUniformLocation(t, e), 'uniform "' + e + '" not present in program.');
  }
  function QBt(n, t, e) {
    return n.getUniformLocation(t, e);
  }
  function t3t(n, t, e, r) {
    Dt(n, () => ZBt(n, t, r)), Dt(n, () => n.uniform1i(e, r));
  }
  function AT(n, t, e) {
    Dt(n, () => n.bindFramebuffer(n.FRAMEBUFFER, e)), Dt(n, () => n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0));
  }
  function WV(n, t) {
    Dt(n, () => n.bindFramebuffer(n.FRAMEBUFFER, t)), Dt(n, () => n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, null, 0));
  }
  function E0(n) {
    const t = n.checkFramebufferStatus(n.FRAMEBUFFER);
    if (t !== n.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + e3t(n, t));
  }
  function e3t(n, t) {
    switch (t) {
      case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case n.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return `unknown error ${t}`;
    }
  }
  function al(n, t, e) {
    const r = Dt(n, () => t());
    if (r == null) throw new Error(e);
    return r;
  }
  function n3t(n, t) {
    const e = n.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r = t + n.TEXTURE0;
    if (r < n.TEXTURE0 || r > e) {
      const i = `[gl.TEXTURE0, gl.TEXTURE${e}]`;
      throw new Error(`textureUnit must be in ${i}.`);
    }
  }
  function od(n, t = 2) {
    return lt(n.slice(0, n.length - t));
  }
  function ld(n) {
    if (n.length === 0) throw Error("Cannot get rows and columns of an empty shape array.");
    return [
      n.length > 1 ? n[n.length - 2] : 1,
      n[n.length - 1]
    ];
  }
  function M0(n) {
    let t = [
      1,
      1,
      1
    ];
    return n.length === 0 || n.length === 1 && n[0] === 1 || (t = [
      od(n),
      ...ld(n)
    ]), t;
  }
  function r3t(n, t = false) {
    let e = nt().getNumber("WEBGL_MAX_TEXTURE_SIZE"), r = nt().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
    r === 1 / 0 && nt().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (r = e / 2), t && (e = e * 2, r = r * 2, n = n.map((o, l) => l >= n.length - 2 ? HE(n[l]) : n[l]), n.length === 1 && (n = [
      2,
      n[0]
    ])), n.length !== 2 && (n = lu(n).newShape);
    let i = lt(n), a = null;
    n.length <= 1 && i <= e ? a = [
      1,
      i
    ] : n.length === 2 && n[0] <= e && n[1] <= e ? a = n : n.length === 3 && n[0] * n[1] <= e && n[2] <= e ? a = [
      n[0] * n[1],
      n[2]
    ] : n.length === 3 && n[0] <= e && n[1] * n[2] <= e ? a = [
      n[0],
      n[1] * n[2]
    ] : n.length === 4 && n[0] * n[1] * n[2] <= e && n[3] <= e ? a = [
      n[0] * n[1] * n[2],
      n[3]
    ] : n.length === 4 && n[0] <= e && n[1] * n[2] * n[3] <= e && (a = [
      n[0],
      n[1] * n[2] * n[3]
    ]);
    const s = a != null && Math.max(...a) > r && Math.min(...a) <= (t ? 2 : 1) && Math.min(...a) > 0;
    if (a == null || s) if (t) {
      const o = od(n);
      let l = 2, u = 2;
      n.length && ([l, u] = ld(n)), i = o * (l / 2) * (u / 2), a = f2(i).map((c) => c * 2);
    } else a = f2(i);
    return a;
  }
  function R0(n) {
    return n % 2 === 0;
  }
  function i1(n, t) {
    if (n = n.slice(-2), t = t.slice(-2), Xe(n, t) || !n.length || !t.length || n[0] === 0 || n[1] === 0 || t[0] === 0 || t[1] === 0) return true;
    if (n.length !== t.length) {
      const e = n[n.length - 1], r = t[t.length - 1];
      if (e === r || R0(e) && R0(r) && (n[0] === 1 || t[0] === 1)) return true;
    }
    return n[1] === t[1] && R0(n[0]) && R0(t[0]);
  }
  let kT, DT;
  function i3t(n) {
    if (kT == null) {
      const t = cs(n);
      kT = t.getParameter(t.MAX_TEXTURE_SIZE);
    }
    return kT;
  }
  function a3t(n) {
    if (DT == null) {
      const t = cs(n);
      DT = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, DT);
  }
  function s3t(n) {
    if (n === 0) return 0;
    let t;
    const e = cs(n);
    return Sa(e, "EXT_disjoint_timer_query_webgl2") && n === 2 ? t = 2 : Sa(e, "EXT_disjoint_timer_query") ? t = 1 : t = 0, t;
  }
  function Sa(n, t) {
    return n.getExtension(t) != null;
  }
  function UV(n) {
    try {
      if (cs(n) != null) return true;
    } catch (t) {
      return console.log("Error when getting WebGL context: ", t), false;
    }
    return false;
  }
  function o3t(n) {
    if (n === 0) return false;
    const t = cs(n);
    if (n === 1) {
      if (!Sa(t, "OES_texture_float")) return false;
    } else if (!Sa(t, "EXT_color_buffer_float")) return false;
    return H2(t);
  }
  function l3t(n) {
    if (n === 0) return false;
    const t = cs(n);
    if (n === 1) {
      if (!Sa(t, "OES_texture_float") || !Sa(t, "WEBGL_color_buffer_float")) return false;
    } else {
      if (Sa(t, "EXT_color_buffer_float")) return H2(t);
      const r = "EXT_color_buffer_half_float";
      if (Sa(t, r)) {
        const i = t.getExtension(r);
        return u3t(t, i);
      }
      return false;
    }
    return H2(t);
  }
  function H2(n) {
    const t = mN(n), e = n.createTexture();
    n.bindTexture(n.TEXTURE_2D, e), n.texImage2D(n.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
    const a = n.createFramebuffer();
    n.bindFramebuffer(n.FRAMEBUFFER, a), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0);
    const s = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
    return n.bindTexture(n.TEXTURE_2D, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteTexture(e), n.deleteFramebuffer(a), s;
  }
  function u3t(n, t) {
    const e = mN(n, t), r = n.createTexture();
    n.bindTexture(n.TEXTURE_2D, r), n.texImage2D(n.TEXTURE_2D, 0, e.internalFormatHalfFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeHalfFloat, null);
    const s = n.createFramebuffer();
    n.bindFramebuffer(n.FRAMEBUFFER, s), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, r, 0);
    const o = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
    return n.bindTexture(n.TEXTURE_2D, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteTexture(r), n.deleteFramebuffer(s), o;
  }
  function c3t(n) {
    return n !== 2 ? false : cs(n).fenceSync != null;
  }
  function fy(n, t) {
    Array.isArray(n) || (n = [
      n
    ]), n.forEach((e) => {
      e != null && B(e.dtype !== "complex64", () => `${t} does not support complex64 tensors in the WebGL backend.`);
    });
  }
  const Gt = nt();
  Gt.registerFlag("HAS_WEBGL", () => Gt.getNumber("WEBGL_VERSION") > 0);
  Gt.registerFlag("WEBGL_VERSION", () => UV(2) ? 2 : UV(1) ? 1 : 0);
  Gt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
  Gt.registerFlag("WEBGL_BUFFER_SUPPORTED", () => Gt.get("WEBGL_VERSION") === 2);
  Gt.registerFlag("WEBGL_CPU_FORWARD", () => true);
  Gt.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
  Gt.registerFlag("WEBGL_PACK", () => Gt.getBool("HAS_WEBGL"));
  Gt.registerFlag("WEBGL_PACK_NORMALIZATION", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_PACK_CLIP", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_PACK_REDUCE", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_LAZILY_UNPACK", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_CONV_IM2COL", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", () => Gt.getBool("WEBGL_PACK"));
  Gt.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => i3t(Gt.getNumber("WEBGL_VERSION")));
  Gt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => a3t(Gt.getNumber("WEBGL_VERSION")));
  Gt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    const n = Gt.getNumber("WEBGL_VERSION");
    return n === 0 ? 0 : s3t(n);
  });
  Gt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => Gt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !Rq());
  Gt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => o3t(Gt.getNumber("WEBGL_VERSION")));
  Gt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => Gt.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : Gt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));
  Gt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => l3t(Gt.getNumber("WEBGL_VERSION")));
  Gt.registerFlag("WEBGL_FENCE_API_ENABLED", () => c3t(Gt.getNumber("WEBGL_VERSION")));
  Gt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => Gt.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0);
  Gt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (n) => {
    if (typeof n != "number") throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);
    if (n < 0 && n !== -1) throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`);
  });
  Gt.registerFlag("WEBGL_FLUSH_THRESHOLD", () => Rq() ? 1 : -1, (n) => {
    if (typeof n != "number") throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);
    if (n < 0 && n !== -1) throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`);
  });
  Gt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  Gt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
  Gt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
  Gt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
  Gt.registerFlag("WEBGL_EXP_CONV", () => false);
  Gt.registerFlag("SOFTWARE_WEBGL_ENABLED", () => Gt.getBool("IS_TEST"));
  Gt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0);
  Gt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false);
  Gt.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false);
  Gt.registerFlag("ENGINE_COMPILE_ONLY", () => false);
  function ti() {
    let n, t, e, r, i, a, s, o, l, u;
    return nt().getNumber("WEBGL_VERSION") === 2 ? (n = "#version 300 es", t = "in", e = "out", r = "in", i = "texture", a = "outputColor", s = "out vec4 outputColor;", o = nt().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "", l = "", u = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (n = "", t = "attribute", e = "varying", r = "varying", i = "texture2D", a = "gl_FragColor", s = "", o = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, l = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, u = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), {
      version: n,
      attribute: t,
      varyingVs: e,
      varyingFs: r,
      texture2D: i,
      output: a,
      defineOutput: s,
      defineSpecialNaN: o,
      defineSpecialInf: l,
      defineRound: u
    };
  }
  function Ih(n, t, e = "index") {
    const r = Yt(t);
    return r.map((i, a) => {
      const s = `int ${n[a]} = ${e} / ${i}`, o = a === r.length - 1 ? `int ${n[a + 1]} = ${e} - ${n[a]} * ${i}` : `index -= ${n[a]} * ${i}`;
      return `${s}; ${o};`;
    }).join("");
  }
  function kw(n, t, e = "index") {
    const r = Yt(t);
    return r.map((i, a) => {
      const s = `int ${n[a]} = ${e} / outShapeStrides[${a}]`, o = a === r.length - 1 ? `int ${n[a + 1]} = ${e} - ${n[a]} * outShapeStrides[${a}]` : `index -= ${n[a]} * outShapeStrides[${a}]`;
      return `${s}; ${o};`;
    }).join("");
  }
  function h3t(n, t) {
    const e = n.length, r = n.map((a) => `${t}[${a}]`), i = new Array(e - 1);
    i[e - 2] = r[e - 1];
    for (let a = e - 3; a >= 0; --a) i[a] = `(${i[a + 1]} * ${r[a + 1]})`;
    return i;
  }
  function f3t(n, t, e = "index") {
    const r = n.map((a, s) => s), i = h3t(r, t);
    return i.map((a, s) => {
      const o = `int ${n[s]} = ${e} / ${i[s]}`, l = s === i.length - 1 ? `int ${n[s + 1]} = ${e} - ${n[s]} * ${i[s]}` : `index -= ${n[s]} * ${i[s]}`;
      return `${o}; ${l};`;
    }).join("");
  }
  function yN(n) {
    const t = Yt(n).map((e) => e.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`;
  }
  function xN() {
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
  }
  const $Z = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
  const { getBroadcastDims: OZ } = eDt;
  function d3t(n, t, e) {
    const r = [];
    if (n.forEach((d) => {
      const p = lt(d.shapeInfo.logicalShape);
      if (d.shapeInfo.isUniform ? r.push(`uniform float ${d.name}${p > 1 ? `[${p}]` : ""};`) : (r.push(`uniform sampler2D ${d.name};`), r.push(`uniform int offset${d.name};`)), e.enableShapeUniforms) {
        const { uniformShape: g } = bN(e.packedInputs, d.shapeInfo.logicalShape, d.shapeInfo.texShape);
        switch (g.length) {
          case 1:
            r.push(`uniform int ${d.name}Shape;`);
            break;
          case 2:
            r.push(`uniform ivec2 ${d.name}Shape;`);
            break;
          case 3:
            r.push(`uniform ivec3 ${d.name}Shape;`);
            break;
          case 4:
            r.push(`uniform ivec4 ${d.name}Shape;`);
            break;
        }
        r.push(`uniform ivec2 ${d.name}TexShape;`);
      }
    }), e.enableShapeUniforms) {
      switch (t.logicalShape.length) {
        case 1:
          r.push("uniform int outShape;");
          break;
        case 2:
          r.push("uniform ivec2 outShape;"), r.push("uniform int outShapeStrides;");
          break;
        case 3:
          r.push("uniform ivec3 outShape;"), r.push("uniform ivec2 outShapeStrides;");
          break;
        case 4:
          r.push("uniform ivec4 outShape;"), r.push("uniform ivec3 outShapeStrides;");
          break;
      }
      r.push("uniform ivec2 outTexShape;");
    }
    e.customUniforms && e.customUniforms.forEach((d) => {
      r.push(`uniform ${d.type} ${d.name}${d.arrayIndex ? `[${d.arrayIndex}]` : ""};`);
    });
    const i = r.join(`
`), a = n.map((d) => p3t(d, t, e.packedInputs, e.enableShapeUniforms)).join(`
`), s = t.texShape, o = ti(), l = m3t(o);
    let u, c, h = b3t(o);
    return t.isPacked ? (u = g3t(t.logicalShape, s, e.enableShapeUniforms), c = x3t(o)) : (u = v3t(t.logicalShape, s, e.enableShapeUniforms), c = y3t(o)), e.packedInputs && (h += C3t), [
      h,
      l,
      c,
      i,
      u,
      a,
      e.userCode
    ].join(`
`);
  }
  function Gd(n, t = false) {
    const e = n.shapeInfo.logicalShape;
    switch (e.length) {
      case 0:
        return $3t(n, t);
      case 1:
        return F3t(n, t);
      case 2:
        return z3t(n, t);
      case 3:
        return G3t(n, t);
      case 4:
        return U3t(n, t);
      case 5:
        return H3t(n);
      case 6:
        return X3t(n);
      default:
        throw new Error(`${e.length}-D input sampling is not yet supported`);
    }
  }
  function FZ(n, t) {
    switch (n.shapeInfo.logicalShape.length) {
      case 0:
        return P3t(n);
      case 1:
        return O3t(n, t);
      case 2:
        return B3t(n, t);
      case 3:
        return V3t(n, t);
      default:
        return W3t(n, t);
    }
  }
  function p3t(n, t, e = false, r) {
    let i = "";
    e ? i += FZ(n, r) : i += Gd(n, r);
    const a = n.shapeInfo.logicalShape, s = t.logicalShape;
    return a.length <= s.length && (e ? i += Y3t(n, t) : i += q3t(n, t)), i;
  }
  function g3t(n, t, e) {
    switch (n.length) {
      case 0:
        return BZ();
      case 1:
        return T3t(n, t, e);
      case 2:
        return N3t(n, t, e);
      case 3:
        return A3t(n, t, e);
      default:
        return D3t(n, t, e);
    }
  }
  function v3t(n, t, e) {
    switch (n.length) {
      case 0:
        return BZ();
      case 1:
        return I3t(n, t, e);
      case 2:
        return L3t(n, t, e);
      case 3:
        return k3t(n, t, e);
      case 4:
        return E3t(n, t, e);
      case 5:
        return M3t(n, t);
      case 6:
        return R3t(n, t);
      default:
        throw new Error(`${n.length}-D output sampling is not yet supported`);
    }
  }
  function m3t(n) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `;
  }
  function y3t(n) {
    return `
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `;
  }
  function x3t(n) {
    return `
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `;
  }
  function b3t(n) {
    return `${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${_3t}
    ${w3t}
    ${S3t}
  `;
  }
  const _3t = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, w3t = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, S3t = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, C3t = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
  function BZ() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
  }
  function T3t(n, t, e) {
    const r = [
      Math.ceil(t[0] / 2),
      Math.ceil(t[1] / 2)
    ];
    return r[0] === 1 ? e ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    ` : r[1] === 1 ? e ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    ` : e ? `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `;
  }
  function I3t(n, t, e) {
    return t[0] === 1 ? e ? `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    ` : t[1] === 1 ? e ? `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    ` : e ? `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `;
  }
  function A3t(n, t, e) {
    if (e) return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
    const r = [
      Math.ceil(t[0] / 2),
      Math.ceil(t[1] / 2)
    ], i = Math.ceil(n[2] / 2), a = i * Math.ceil(n[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  function k3t(n, t, e) {
    if (e) return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${kw([
      "r",
      "c",
      "d"
    ], n)}
    return ivec3(r, c, d);
  }
`;
    const r = Ih([
      "r",
      "c",
      "d"
    ], n);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `;
  }
  function D3t(n, t, e) {
    if (e) return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
    const r = [
      Math.ceil(t[0] / 2),
      Math.ceil(t[1] / 2)
    ], i = Math.ceil(n[n.length - 1] / 2), a = i * Math.ceil(n[n.length - 2] / 2);
    let s = a, o = "", l = "b, r, c";
    for (let u = 2; u < n.length - 1; u++) s *= n[n.length - u - 1], o = `
      int b${u} = index / ${s};
      index -= b${u} * ${s};
    ` + o, l = `b${u}, ` + l;
    return `
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `;
  }
  function E3t(n, t, e) {
    if (e) return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${kw([
      "r",
      "c",
      "d",
      "d2"
    ], n)}
      return ivec4(r, c, d, d2);
    }
  `;
    const r = Ih([
      "r",
      "c",
      "d",
      "d2"
    ], n);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  function M3t(n, t) {
    const e = Ih([
      "r",
      "c",
      "d",
      "d2",
      "d3"
    ], n);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
  }
  function R3t(n, t) {
    const e = Ih([
      "r",
      "c",
      "d",
      "d2",
      "d3",
      "d4"
    ], n);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
  }
  function N3t(n, t, e) {
    const r = [
      Math.ceil(t[0] / 2),
      Math.ceil(t[1] / 2)
    ];
    if (Xe(n, t)) return e ? `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;
    const i = Math.ceil(n[1] / 2);
    return e ? `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `;
  }
  function L3t(n, t, e) {
    return Xe(n, t) ? e ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    ` : n[1] === 1 ? e ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : n[0] === 1 ? e ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : e ? `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `;
  }
  function Ah(n) {
    return `offset${n}`;
  }
  function P3t(n) {
    const t = n.name, e = "get" + t.charAt(0).toUpperCase() + t.slice(1), r = ti();
    return `
    vec4 ${e}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `;
  }
  function $3t(n, t) {
    const e = n.name, r = "get" + e.charAt(0).toUpperCase() + e.slice(1);
    if (n.shapeInfo.isUniform) return `float ${r}() {return ${e};}`;
    const [i, a] = n.shapeInfo.texShape;
    if (i === 1 && a === 1) return `
      float ${r}() {
        return sampleTexture(${e}, halfCR);
      }
    `;
    const s = Ah(e);
    if (t) return `
    float ${r}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${s});
      return sampleTexture(${e}, uv);
    }
  `;
    const [o, l] = n.shapeInfo.texShape;
    return `
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${s});
      return sampleTexture(${e}, uv);
    }
  `;
  }
  function O3t(n, t) {
    const e = n.name, r = "get" + e.charAt(0).toUpperCase() + e.slice(1), i = n.shapeInfo.texShape, a = ti();
    if (t) return `
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${e}, uv);
    }
  `;
    const s = [
      Math.ceil(i[0] / 2),
      Math.ceil(i[1] / 2)
    ];
    return `
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${s[0]}, ${s[1]}, index);
      return ${a.texture2D}(${e}, uv);
    }
  `;
  }
  function F3t(n, t) {
    const e = n.name, r = "get" + e.charAt(0).toUpperCase() + e.slice(1);
    if (n.shapeInfo.isUniform) return `
      float ${r}(int index) {
        ${Wd(n)}
      }
    `;
    const i = n.shapeInfo.texShape, a = i[0], s = i[1];
    if (s === 1 && a === 1) return `
      float ${r}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;
    const o = Ah(e);
    return s === 1 ? t ? `
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    ` : `
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${e}, uv);
      }
    ` : a === 1 ? t ? `
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    ` : `
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${s}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    ` : t ? `
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${o});
      return sampleTexture(${e}, uv);
    }
  ` : `
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${s}, index + ${o});
      return sampleTexture(${e}, uv);
    }
  `;
  }
  function B3t(n, t) {
    const e = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = n.shapeInfo.texShape, s = a[0], o = a[1], l = ti();
    if (a != null && Xe(e, a)) return t ? `
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    ` : `
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${s}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;
    if (t) return `
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;
    const u = [
      Math.ceil(a[0] / 2),
      Math.ceil(a[1] / 2)
    ], c = Math.ceil(e[1] / 2);
    return `
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;
  }
  function z3t(n, t) {
    const e = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = n.shapeInfo.texShape;
    if (a != null && Xe(e, a)) {
      if (t) return `
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;
      const f = a[0], d = a[1];
      return `
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `;
    }
    const { newShape: s, keptDims: o } = lu(e), l = s;
    if (l.length < e.length) {
      const f = Ud(n, l), d = [
        "row",
        "col"
      ];
      return `
      ${Gd(f, t)}
      float ${i}(int row, int col) {
        return ${i}(${Hd(d, o)});
      }
    `;
    }
    if (n.shapeInfo.isUniform) return `
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Wd(n)}
      }
    `;
    const u = a[0], c = a[1], h = Ah(r);
    return c === 1 ? t ? `
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    ` : `
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  ` : u === 1 ? t ? `
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    ` : `
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  ` : t ? `
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    ` : `
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`;
  }
  function V3t(n, t) {
    const e = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = n.shapeInfo.texShape, s = [
      Math.ceil(a[0] / 2),
      Math.ceil(a[1] / 2)
    ];
    if (e[0] === 1) {
      const f = e.slice(1), d = [
        1,
        2
      ], p = Ud(n, f), g = [
        "b",
        "row",
        "col"
      ];
      return `
        ${FZ(p, t)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Hd(g, d)});
        }
      `;
    }
    const o = ti();
    if (t) return `
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;
    const l = s[0], u = s[1], c = Math.ceil(e[2] / 2), h = c * Math.ceil(e[1] / 2);
    return `
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;
  }
  function G3t(n, t) {
    const e = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = e[1] * e[2], s = e[2], { newShape: o, keptDims: l } = lu(e), u = o;
    if (u.length < e.length) {
      const g = Ud(n, u), v = [
        "row",
        "col",
        "depth"
      ];
      return `
        ${Gd(g, t)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Hd(v, l)});
        }
      `;
    }
    if (n.shapeInfo.isUniform) return `
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${s}, 1)));
        ${Wd(n)}
      }
    `;
    const c = n.shapeInfo.texShape, h = c[0], f = c[1], d = n.shapeInfo.flatOffset;
    if (f === a && d == null) return t ? `
      float ${i}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    ` : `
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${s}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;
    if (f === s && d == null) return t ? `
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    ` : `
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;
    const p = Ah(r);
    return t ? `
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    ` : `
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${s} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `;
  }
  function W3t(n, t) {
    const e = n.name, r = "get" + e.charAt(0).toUpperCase() + e.slice(1), i = ti();
    if (t) return `
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${e}, uv);
    }
  `;
    const a = n.shapeInfo.logicalShape, s = a.length, o = n.shapeInfo.texShape, l = [
      Math.ceil(o[0] / 2),
      Math.ceil(o[1] / 2)
    ], u = l[0], c = l[1], h = Math.ceil(a[s - 1] / 2);
    let f = h * Math.ceil(a[s - 2] / 2), d = "int b, int row, int col", p = `b * ${f} + (row / 2) * ${h} + (col / 2)`;
    for (let g = 2; g < s - 1; g++) d = `int b${g}, ` + d, f *= a[s - g - 1], p = `b${g} * ${f} + ` + p;
    return `
    vec4 ${r}(${d}) {
      int index = ${p};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${i.texture2D}(${e}, uv);
    }
  `;
  }
  function U3t(n, t) {
    const e = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = e[3], s = e[2] * a, o = e[1] * s, { newShape: l, keptDims: u } = lu(e);
    if (l.length < e.length) {
      const y = Ud(n, l), x = [
        "row",
        "col",
        "depth",
        "depth2"
      ];
      return `
      ${Gd(y, t)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Hd(x, u)});
      }
    `;
    }
    if (n.shapeInfo.isUniform) return `
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${s}, ${a}, 1)));
        ${Wd(n)}
      }
    `;
    const c = n.shapeInfo.flatOffset, h = n.shapeInfo.texShape, f = h[0], d = h[1], p = `int stride2 = ${r}Shape[3];`, g = `int stride1 = ${r}Shape[2] * stride2;`, v = `int stride0 = ${r}Shape[1] * stride1;`;
    if (d === o && c == null) return t ? `
      float ${i}(int row, int col, int depth, int depth2) {
        ${p}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    ` : `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${s}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;
    if (d === a && c == null) return t ? `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    ` : `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1] * e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;
    const m = Ah(r);
    return t ? `
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${g}
      ${v}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${m});
      return sampleTexture(${r}, uv);
    }
  ` : `
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${s} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${m});
      return sampleTexture(${r}, uv);
    }
  `;
  }
  function H3t(n) {
    const t = n.shapeInfo.logicalShape, e = n.name, r = "get" + e.charAt(0).toUpperCase() + e.slice(1), i = t[4], a = t[3] * i, s = t[2] * a, o = t[1] * s, { newShape: l, keptDims: u } = lu(t);
    if (l.length < t.length) {
      const g = Ud(n, l), v = [
        "row",
        "col",
        "depth",
        "depth2",
        "depth3"
      ];
      return `
      ${Gd(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Hd(v, u)});
      }
    `;
    }
    if (n.shapeInfo.isUniform) return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${s}, ${a}, ${i})) +
          depth3;
        ${Wd(n)}
      }
    `;
    const c = n.shapeInfo.flatOffset, h = n.shapeInfo.texShape, f = h[0], d = h[1];
    if (d === o && c == null) return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${s}, ${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;
    if (d === i && c == null) return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3]},
               ${t[2] * t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;
    const p = Ah(e);
    return `
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${s} + depth * ${a} +
          depth2 * ${i} + depth3 + ${p};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `;
  }
  function X3t(n) {
    const t = n.shapeInfo.logicalShape, e = n.name, r = "get" + e.charAt(0).toUpperCase() + e.slice(1), { newShape: i, keptDims: a } = lu(t);
    if (i.length < t.length) {
      const v = Ud(n, i), m = [
        "row",
        "col",
        "depth",
        "depth2",
        "depth3",
        "depth4"
      ];
      return `
      ${Gd(v)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Hd(m, a)});
      }
    `;
    }
    const s = t[5], o = t[4] * s, l = t[3] * o, u = t[2] * l, c = t[1] * u;
    if (n.shapeInfo.isUniform) return `
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${s}, 1)));
        ${Wd(n)}
      }
    `;
    const h = n.shapeInfo.flatOffset, f = n.shapeInfo.texShape, d = f[0], p = f[1];
    if (p === c && h == null) return `
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${s})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;
    if (p === s && h == null) return `
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3] * t[4]},
               ${t[2] * t[3] * t[4]},
               ${t[3] * t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;
    const g = Ah(e);
    return `
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${s} + depth4 + ${g};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${e}, uv);
    }
  `;
  }
  function Wd(n) {
    const t = n.name, e = lt(n.shapeInfo.logicalShape);
    return e < 2 ? `return ${t};` : `
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `;
  }
  function Y3t(n, t) {
    const e = n.name, r = e.charAt(0).toUpperCase() + e.slice(1), i = "get" + r + "AtOutCoords", a = n.shapeInfo.logicalShape.length, s = t.logicalShape.length, o = OZ(n.shapeInfo.logicalShape, t.logicalShape), l = sn(s), u = s - a;
    let c;
    const h = [
      "x",
      "y",
      "z",
      "w",
      "u",
      "v"
    ];
    a === 0 ? c = "" : s < 2 && o.length >= 1 ? c = "coords = 0;" : c = o.map((y) => `coords.${h[y + u]} = 0;`).join(`
`);
    let f = "";
    s < 2 && a > 0 ? f = "coords" : f = n.shapeInfo.logicalShape.map((y, x) => `coords.${h[x + u]}`).join(", ");
    let d = "return outputValue;";
    const g = lt(n.shapeInfo.logicalShape) === 1, m = lt(t.logicalShape) === 1;
    if (a === 1 && !g && !m) d = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    else if (g && !m) s === 1 ? d = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : d = `
        return vec4(outputValue.x);
      `;
    else if (o.length) {
      const y = a - 2, x = a - 1;
      o.indexOf(y) > -1 && o.indexOf(x) > -1 ? d = "return vec4(outputValue.x);" : o.indexOf(y) > -1 ? d = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : o.indexOf(x) > -1 && (d = "return vec4(outputValue.xx, outputValue.zz);");
    }
    return `
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `;
  }
  function q3t(n, t) {
    const e = n.name, r = e.charAt(0).toUpperCase() + e.slice(1), i = "get" + r + "AtOutCoords", a = t.texShape, s = n.shapeInfo.texShape, o = n.shapeInfo.logicalShape.length, l = t.logicalShape.length;
    if (!n.shapeInfo.isUniform && o === l && n.shapeInfo.flatOffset == null && Xe(s, a)) return `
      float ${i}() {
        return sampleTexture(${e}, resultUV);
      }
    `;
    const u = sn(l), c = OZ(n.shapeInfo.logicalShape, t.logicalShape), h = l - o;
    let f;
    const d = [
      "x",
      "y",
      "z",
      "w",
      "u",
      "v"
    ];
    o === 0 ? f = "" : l < 2 && c.length >= 1 ? f = "coords = 0;" : f = c.map((g) => `coords.${d[g + h]} = 0;`).join(`
`);
    let p = "";
    return l < 2 && o > 0 ? p = "coords" : p = n.shapeInfo.logicalShape.map((g, v) => `coords.${d[v + h]}`).join(", "), `
    float ${i}() {
      ${u} coords = getOutputCoords();
      ${f}
      return get${r}(${p});
    }
  `;
  }
  function sn(n) {
    if (n <= 1) return "int";
    if (n === 2) return "ivec2";
    if (n === 3) return "ivec3";
    if (n === 4) return "ivec4";
    if (n === 5) return "ivec5";
    if (n === 6) return "ivec6";
    throw Error(`GPU for rank ${n} is not yet supported`);
  }
  function bN(n, t, e) {
    const { newShape: r, keptDims: i } = lu(t), a = t.length, s = n && a === 3 && t[0] === 1, o = s ? t.slice(1) : r, l = !n && a > 1 && !Xe(t, e) && r.length < a || s;
    return {
      useSqueezeShape: l,
      uniformShape: l ? o : t,
      keptDims: i
    };
  }
  function Ud(n, t) {
    const e = JSON.parse(JSON.stringify(n));
    return e.shapeInfo.logicalShape = t, e;
  }
  function Hd(n, t) {
    return t.map((e) => n[e]).join(", ");
  }
  function j3t(n, t, e, r) {
    const i = e.map((c, h) => {
      const f = {
        logicalShape: c.shape,
        texShape: c.isUniform ? null : c.texData.texShape,
        isUniform: c.isUniform,
        isPacked: c.isUniform ? false : c.texData.isPacked,
        flatOffset: null
      };
      return c.texData != null && c.texData.slice != null && c.texData.slice.flatOffset > 0 && (f.flatOffset = c.texData.slice.flatOffset), {
        name: t.variableNames[h],
        shapeInfo: f
      };
    }), a = i.map((c) => c.shapeInfo), s = {
      logicalShape: r.shape,
      texShape: r.texData.texShape,
      isUniform: false,
      isPacked: r.texData.isPacked,
      flatOffset: null
    }, o = d3t(i, s, t), l = GBt(n.gl, o), u = n.createProgram(l);
    return nt().get("ENGINE_COMPILE_ONLY") ? {
      program: t,
      fragmentShader: l,
      source: o,
      webGLProgram: u,
      inShapeInfos: a,
      outShapeInfo: s,
      variablesLocations: null,
      customUniformLocations: null,
      infLoc: null,
      nanLoc: null,
      outShapeLocation: null,
      outShapeStridesLocation: null,
      outTexShapeLocation: null
    } : (n.buildVao(u), Object.assign({
      program: t,
      fragmentShader: l,
      source: o,
      webGLProgram: u,
      inShapeInfos: a,
      outShapeInfo: s
    }, zZ(n, t, u)));
  }
  function zZ(n, t, e) {
    const r = [], i = [];
    let a, s, o, l = null, u = null;
    u = n.getUniformLocation(e, "NAN", false), nt().getNumber("WEBGL_VERSION") === 1 && (l = n.getUniformLocation(e, "INFINITY", false));
    const c = false;
    for (const h of t.variableNames) {
      const f = {
        name: h,
        uniform: n.getUniformLocation(e, h, c),
        offset: n.getUniformLocation(e, `offset${h}`, c)
      };
      t.enableShapeUniforms && (f.shape = n.getUniformLocation(e, `${h}Shape`, c), f.texShape = n.getUniformLocation(e, `${h}TexShape`, c)), r.push(f);
    }
    if (t.enableShapeUniforms && (a = n.getUniformLocation(e, "outShape", c), o = n.getUniformLocation(e, "outShapeStrides", c), s = n.getUniformLocation(e, "outTexShape", c)), t.customUniforms) for (const h of t.customUniforms) i.push(n.getUniformLocation(e, h.name, c));
    return {
      variablesLocations: r,
      customUniformLocations: i,
      infLoc: l,
      nanLoc: u,
      outShapeLocation: a,
      outShapeStridesLocation: o,
      outTexShapeLocation: s
    };
  }
  function HV(n, t) {
    if (n.length !== t.length) throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);
    n.forEach((e, r) => {
      const i = e.logicalShape, a = t[r], s = a.shape;
      if (!Xe(i, s)) throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${s} must match`);
      if (e.isUniform && a.isUniform) return;
      const o = e.texShape, l = a.isUniform ? null : a.texData.texShape;
      if (!Xe(o, l)) throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`);
    });
  }
  function K3t(n, t, e, r, i) {
    t.program.enableShapeUniforms || (HV(t.inShapeInfos, e), HV([
      t.outShapeInfo
    ], [
      r
    ]));
    const a = r.texData.texture, s = r.texData.texShape;
    r.texData.isPacked ? n.setOutputPackedMatrixTexture(a.texture, s[0], s[1]) : n.setOutputMatrixTexture(a.texture, s[0], s[1]), n.setProgram(t.webGLProgram), n.bindVertexArray(t.webGLProgram.vao), nt().getNumber("WEBGL_VERSION") === 1 && t.infLoc !== null && n.gl.uniform1f(t.infLoc, 1 / 0), t.nanLoc !== null && n.gl.uniform1f(t.nanLoc, NaN);
    for (let l = 0; l < e.length; ++l) {
      const u = e[l], { uniform: c, offset: h, shape: f, texShape: d } = t.variablesLocations[l];
      if (f) {
        const { uniformShape: p } = bN(t.program.packedInputs, u.shape, u.texData.texShape);
        switch (p.length) {
          case 1:
            n.gl.uniform1iv(f, new Int32Array(p));
            break;
          case 2:
            n.gl.uniform2iv(f, new Int32Array(p));
            break;
          case 3:
            n.gl.uniform3iv(f, new Int32Array(p));
            break;
          case 4:
            n.gl.uniform4iv(f, new Int32Array(p));
            break;
        }
      }
      if (d && n.gl.uniform2i(d, u.texData.texShape[0], u.texData.texShape[1]), c != null) {
        if (u.isUniform) {
          if (lt(u.shape) < 2) n.gl.uniform1f(c, u.uniformValues[0]);
          else {
            let p = u.uniformValues;
            p instanceof Float32Array || (p = new Float32Array(p)), n.gl.uniform1fv(c, p);
          }
          continue;
        }
        u.texData.slice != null && h != null && n.gl.uniform1i(h, u.texData.slice.flatOffset), n.setInputMatrixTexture(u.texData.texture.texture, c, l);
      }
    }
    const o = t.outShapeLocation;
    if (o) switch (r.shape.length) {
      case 1:
        n.gl.uniform1iv(o, new Int32Array(r.shape));
        break;
      case 2:
        n.gl.uniform2iv(o, new Int32Array(r.shape));
        break;
      case 3:
        n.gl.uniform3iv(o, new Int32Array(r.shape));
        break;
      case 4:
        n.gl.uniform4iv(o, new Int32Array(r.shape));
        break;
    }
    if (t.outShapeStridesLocation) {
      const l = Yt(r.shape);
      switch (r.shape.length) {
        case 2:
          n.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(l));
          break;
        case 3:
          n.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(l));
          break;
        case 4:
          n.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(l));
          break;
      }
    }
    if (t.outTexShapeLocation && n.gl.uniform2i(t.outTexShapeLocation, r.texData.texShape[0], r.texData.texShape[1]), t.program.customUniforms && i) for (let l = 0; l < t.program.customUniforms.length; ++l) {
      const u = t.program.customUniforms[l], c = t.customUniformLocations[l], h = i[l];
      if (u.type === "float") n.gl.uniform1fv(c, h);
      else if (u.type === "vec2") n.gl.uniform2fv(c, h);
      else if (u.type === "vec3") n.gl.uniform3fv(c, h);
      else if (u.type === "vec4") n.gl.uniform4fv(c, h);
      else if (u.type === "int") n.gl.uniform1iv(c, h);
      else if (u.type === "ivec2") n.gl.uniform2iv(c, h);
      else if (u.type === "ivec3") n.gl.uniform3iv(c, h);
      else if (u.type === "ivec4") n.gl.uniform4iv(c, h);
      else throw Error(`uniform type ${u.type} is not supported yet.`);
    }
    n.executeProgram();
  }
  function Z3t(n, t, e) {
    let r = "";
    t.concat(e).forEach((s) => {
      const o = s.texData != null && s.texData.slice != null && s.texData.slice.flatOffset > 0;
      if (n.enableShapeUniforms && !s.isUniform) {
        const l = s.texData.texShape, { useSqueezeShape: u, uniformShape: c, keptDims: h } = bN(n.packedInputs, s.shape, l);
        let f = "", d = "", p = "";
        if (c.length === 1 && n.packedInputs) {
          const _ = [
            Math.ceil(l[0] / 2),
            Math.ceil(l[1] / 2)
          ];
          f = `${_[0] > 1}_${_[1] > 1}`;
        } else if (c.length === 2 && !n.packedInputs) d = `${c[0] > 1}_${c[1] > 1}`;
        else if (c.length > 2 && !n.packedInputs) {
          const _ = Yt(c);
          p = `${_[0] === l[1]}_${_[_.length - 1] === l[1]}`;
        }
        const g = s.shape.length, v = c.length === 2 && Xe(s.shape, l), m = lt(s.shape) === 1, y = ed(s.shape, e.shape), x = !n.packedInputs && g === e.shape.length && Xe(l, e.texData.texShape), b = n.packedInputs || c.length > 2 ? "" : `${l[0] > 1}_${l[1] > 1}`;
        r += `${g}_${x}_${u ? h : ""}_${c.length}_${m}_${y}_${v}_${f}_${d}_${p}_${b}_${o}`;
      } else {
        const l = s.isUniform ? "uniform" : s.texData.texShape;
        r += `${s.shape}_${l}_${o}`;
      }
    });
    const i = n.userCode;
    let a = n.constructor.name;
    return a += "_" + r + "_" + i + `${nt().getNumber("WEBGL_VERSION")}`, a;
  }
  function Lr(n) {
    return nt().getBool("WEBGL_USE_SHAPES_UNIFORMS") && n <= 4;
  }
  class J3t {
    constructor(t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = yv.DENSE, this.customUniforms = [
        {
          name: "texShape",
          type: "ivec2"
        }
      ];
      const e = ti();
      this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? kw([
        "r",
        "c",
        "d"
      ], t) : Ih([
        "r",
        "c",
        "d"
      ], t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `;
    }
  }
  class Q3t {
    constructor(t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = yv.DENSE, this.customUniforms = [
        {
          name: "texShape",
          type: "ivec2"
        }
      ];
      const e = ti();
      this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? kw([
        "r",
        "c",
        "d"
      ], t) : Ih([
        "r",
        "c",
        "d"
      ], t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `;
    }
  }
  class tzt {
    constructor(t) {
      this.variableNames = [
        "A"
      ], this.outTexUsage = Hi.DOWNLOAD;
      const e = ti();
      this.outputShape = t, this.userCode = `
      ${$Z}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `;
    }
  }
  class ezt {
    constructor(t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = Hi.DOWNLOAD;
      const e = ti();
      this.outputShape = t, this.userCode = `
      ${$Z}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `;
    }
  }
  const nzt = {
    R: 0,
    G: 1,
    B: 2,
    A: 3
  };
  class XV {
    constructor(t, e = false, r = "RGBA") {
      this.variableNames = [
        "A"
      ], this.customUniforms = [
        {
          name: "texShape",
          type: "ivec2"
        }
      ];
      const i = ti();
      this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length);
      let a = "result";
      e && (a = "floor(result * 255. + 0.5)");
      let s = "";
      for (let o = 0; o < r.length; o++) {
        const l = r[o];
        s += `
          if(offset == ${o}) {
            result = values[${nzt[l]}];
          }`;
      }
      this.userCode = `
      ${this.enableShapeUniforms ? xN() : yN(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${s}
        }
        ${i.output} = vec4(${a}, 0., 0., 0.);
      }
    `;
    }
  }
  class rzt {
    constructor(t, e = false) {
      this.variableNames = [
        "A"
      ], this.packedInputs = false, this.packedOutput = true, this.customUniforms = [
        {
          name: "texShape",
          type: "ivec2"
        }
      ];
      const r = ti();
      this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length);
      let i = "", a = "result";
      e && (a = "floor(result * 255. + 0.5)");
      for (let s = 0; s <= 1; s++) for (let o = 0; o <= 1; o++) {
        const l = s * 2 + o;
        i += `
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms ? "outShape[2]" : `${t[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms ? "outShape[1]" : `${t[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `;
      }
      this.userCode = `
        ${this.enableShapeUniforms ? xN() : yN(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${r.output} = ${a};
        }
    `;
    }
  }
  function izt(n) {
    const t = ti(), e = `${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return VBt(n, e);
  }
  function azt(n) {
    const t = new Float32Array([
      -1,
      1,
      0,
      0,
      1,
      -1,
      -1,
      0,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      -1,
      0,
      1,
      0
    ]);
    return XBt(n, t);
  }
  function szt(n) {
    const t = new Uint16Array([
      0,
      1,
      2,
      2,
      1,
      3
    ]);
    return YBt(n, t);
  }
  function dy(n, t, e, r, i, a) {
    jBt(t, e);
    const s = qBt(n), o = n.TEXTURE_2D;
    return Dt(n, () => n.bindTexture(o, s)), Dt(n, () => n.texParameteri(o, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE)), Dt(n, () => n.texParameteri(o, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE)), Dt(n, () => n.texParameteri(o, n.TEXTURE_MIN_FILTER, n.NEAREST)), Dt(n, () => n.texParameteri(o, n.TEXTURE_MAG_FILTER, n.NEAREST)), nt().getNumber("WEBGL_VERSION") === 1 ? Dt(n, () => n.texImage2D(o, 0, r, t, e, 0, i, a, null)) : Dt(n, () => n.texStorage2D(o, 1, r, t, e)), Dt(n, () => n.bindTexture(n.TEXTURE_2D, null)), {
      texture: s,
      texShape: [
        e,
        t
      ]
    };
  }
  function VZ(n) {
    return n.internalFormatFloat;
  }
  function ozt(n, t, e, r) {
    const [i, a] = hy(t, e);
    return dy(n, i, a, VZ(r), r.textureFormatFloat, n.FLOAT);
  }
  function GZ(n) {
    return n.internalFormatHalfFloat;
  }
  function lzt(n, t, e, r) {
    const [i, a] = hy(t, e);
    return dy(n, i, a, GZ(r), r.textureFormatFloat, r.textureTypeHalfFloat);
  }
  function WZ(n) {
    return n.downloadTextureFormat;
  }
  function uzt(n, t, e, r) {
    const [i, a] = hy(t, e);
    return dy(n, i, a, WZ(r), n.RGBA, n.UNSIGNED_BYTE);
  }
  function UZ(n) {
    return n.internalFormatPackedFloat;
  }
  function czt(n, t, e, r) {
    const [i, a] = Vd(t, e);
    return dy(n, i, a, UZ(r), n.RGBA, n.FLOAT);
  }
  function HZ(n) {
    return n.internalFormatPackedHalfFloat;
  }
  function hzt(n, t, e, r) {
    const [i, a] = Vd(t, e);
    return dy(n, i, a, HZ(r), n.RGBA, r.textureTypeHalfFloat);
  }
  function fzt(n, t, e) {
    return Dt(n, () => n.bindBuffer(n.ARRAY_BUFFER, e)), GV(n, t, "clipSpacePos", e, 3, 20, 0) && GV(n, t, "uv", e, 2, 20, 12);
  }
  function dzt(n, t, e, r, i, a) {
    Dt(n, () => n.bindTexture(n.TEXTURE_2D, t));
    let s, o, l;
    i instanceof Uint8Array ? (s = new Uint8Array(e * r * 4), o = n.UNSIGNED_BYTE, l = n.RGBA) : (s = new Float32Array(e * r * 4), o = n.FLOAT, l = a.internalFormatPackedFloat), s.set(i), nt().getNumber("WEBGL_VERSION") === 2 ? Dt(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e, r, n.RGBA, o, s)) : Dt(n, () => n.texImage2D(n.TEXTURE_2D, 0, l, e, r, 0, n.RGBA, o, s)), Dt(n, () => n.bindTexture(n.TEXTURE_2D, null));
  }
  function pzt(n, t, e) {
    Dt(n, () => n.bindTexture(n.TEXTURE_2D, t)), e.data instanceof Uint8Array ? nt().getNumber("WEBGL_VERSION") === 2 ? Dt(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.width, e.height, n.RGBA, n.UNSIGNED_BYTE, e.data)) : Dt(n, () => n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, e.width, e.height, 0, n.RGBA, n.UNSIGNED_BYTE, e.data)) : nt().getNumber("WEBGL_VERSION") === 2 ? Dt(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, e)) : Dt(n, () => n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, e)), Dt(n, () => n.bindTexture(n.TEXTURE_2D, null));
  }
  function gzt(n, t, e, r) {
    const i = n.createBuffer();
    Dt(n, () => n.bindBuffer(n.PIXEL_PACK_BUFFER, i));
    const o = 4 * 4 * t * e;
    return Dt(n, () => n.bufferData(n.PIXEL_PACK_BUFFER, o, n.STREAM_READ)), Dt(n, () => n.readPixels(0, 0, e, t, n.RGBA, n.FLOAT, 0)), Dt(n, () => n.bindBuffer(n.PIXEL_PACK_BUFFER, null)), i;
  }
  function vzt(n, t, e) {
    const r = n, i = new Float32Array(e);
    return r.bindBuffer(r.PIXEL_PACK_BUFFER, t), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, i), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), i;
  }
  function mzt(n, t, e, r) {
    const [i, a] = hy(t, e), s = 4, o = new Uint8Array(LBt(t * e, s));
    return Dt(n, () => n.readPixels(0, 0, i, a, r.downloadTextureFormat, n.UNSIGNED_BYTE, o)), new Float32Array(o.buffer);
  }
  function yzt(n, t, e, r, i, a, s, o) {
    const l = n, u = new Float32Array(PBt(a, s));
    return l.bindBuffer(l.PIXEL_PACK_BUFFER, t), l.getBufferSubData(l.PIXEL_PACK_BUFFER, 0, u), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), u;
  }
  function xzt(n, t, e) {
    const r = new Float32Array(t * e * 4);
    return Dt(n, () => n.readPixels(0, 0, e, t, n.RGBA, n.FLOAT, r)), r;
  }
  class ET {
    constructor(t) {
      this.outputTexture = null, this.program = null, this.disposed = false, this.itemsToPoll = [];
      const e = nt().getNumber("WEBGL_VERSION");
      if (t != null ? (this.gl = t, MBt(e, t)) : this.gl = cs(e), t = this.gl, nt().getNumber("WEBGL_VERSION") === 2) {
        const a = t;
        this.createVertexArray = () => Dt(a, () => a.createVertexArray()), this.bindVertexArray = (s) => Dt(a, () => a.bindVertexArray(s)), this.deleteVertexArray = (s) => Dt(a, () => a.deleteVertexArray(s)), this.getVertexArray = () => Dt(a, () => a.getParameter(a.VERTEX_ARRAY_BINDING));
      } else if (t != null) {
        const a = t.getExtension("OES_vertex_array_object");
        if (a == null) throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
        this.createVertexArray = () => Dt(t, () => a.createVertexArrayOES()), this.bindVertexArray = (s) => Dt(t, () => a.bindVertexArrayOES(s)), this.deleteVertexArray = (s) => Dt(t, () => a.deleteVertexArrayOES(s)), this.getVertexArray = () => Dt(t, () => t.getParameter(a.VERTEX_ARRAY_BINDING_OES));
      }
      let r = "WEBGL_color_buffer_float";
      const i = "EXT_color_buffer_half_float";
      if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), nt().getNumber("WEBGL_VERSION") === 1) {
        const a = "OES_texture_float", s = "OES_texture_half_float";
        if (this.textureFloatExtension = D0(this.gl, a), Sa(this.gl, s)) this.textureHalfFloatExtension = D0(this.gl, s);
        else if (nt().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        if (this.colorBufferFloatExtension = this.gl.getExtension(r), Sa(this.gl, i)) this.colorBufferHalfFloatExtension = D0(this.gl, i);
        else if (nt().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      } else if (r = "EXT_color_buffer_float", Sa(this.gl, r)) this.colorBufferFloatExtension = this.gl.getExtension(r);
      else if (Sa(this.gl, i)) this.colorBufferHalfFloatExtension = this.gl.getExtension(i);
      else throw new Error("GL context does not support color renderable floats");
      this.vertexBuffer = azt(this.gl), this.indexBuffer = szt(this.gl), this.framebuffer = KBt(this.gl), this.textureConfig = mN(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
      return nt().getBool("DEBUG");
    }
    dispose() {
      if (this.disposed) return;
      this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      const t = this.gl;
      Dt(t, () => t.finish()), Dt(t, () => t.bindFramebuffer(t.FRAMEBUFFER, null)), Dt(t, () => t.deleteFramebuffer(this.framebuffer)), Dt(t, () => t.bindBuffer(t.ARRAY_BUFFER, null)), Dt(t, () => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)), Dt(t, () => t.deleteBuffer(this.indexBuffer)), this.disposed = true;
    }
    createFloat32MatrixTexture(t, e) {
      return this.throwIfDisposed(), ozt(this.gl, t, e, this.textureConfig);
    }
    createFloat16MatrixTexture(t, e) {
      return this.throwIfDisposed(), lzt(this.gl, t, e, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(t, e) {
      return this.throwIfDisposed(), uzt(this.gl, t, e, this.textureConfig);
    }
    uploadPixelDataToTexture(t, e) {
      this.throwIfDisposed(), pzt(this.gl, t, e);
    }
    uploadDenseMatrixToTexture(t, e, r, i) {
      this.throwIfDisposed(), dzt(this.gl, t, e, r, i, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(t, e) {
      return this.throwIfDisposed(), hzt(this.gl, t, e, this.textureConfig);
    }
    createPackedMatrixTexture(t, e) {
      return this.throwIfDisposed(), czt(this.gl, t, e, this.textureConfig);
    }
    deleteMatrixTexture(t) {
      this.throwIfDisposed(), this.outputTexture === t && (WV(this.gl, this.framebuffer), this.outputTexture = null), Dt(this.gl, () => this.gl.deleteTexture(t));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(t, e, r) {
      return this.downloadMatrixDriver(t, () => mzt(this.gl, e, r, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(t, e, r, i, a, s) {
      return yzt(this.gl, t, e, r, i, a, s, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(t, e) {
      return vzt(this.gl, t, e);
    }
    createBufferFromTexture(t, e, r) {
      this.bindTextureToFrameBuffer(t);
      const i = gzt(this.gl, e, r, this.textureConfig);
      return this.unbindTextureToFrameBuffer(), i;
    }
    createAndWaitForFence() {
      const t = this.createFence(this.gl);
      return this.pollFence(t);
    }
    createFence(t) {
      let e, r;
      if (nt().getBool("WEBGL_FENCE_API_ENABLED")) {
        const i = t, a = i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
        t.flush(), r = () => {
          const s = i.clientWaitSync(a, 0, 0);
          return s === i.ALREADY_SIGNALED || s === i.CONDITION_SATISFIED;
        }, e = a;
      } else nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(), this.endQuery(), r = () => this.isQueryAvailable(e, nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : r = () => true;
      return {
        query: e,
        isFencePassed: r
      };
    }
    downloadMatrixFromPackedTexture(t, e, r) {
      return this.downloadMatrixDriver(t, () => xzt(this.gl, e, r));
    }
    createProgram(t) {
      this.throwIfDisposed();
      const e = this.gl;
      this.vertexShader == null && (this.vertexShader = izt(e));
      const r = UBt(e);
      Dt(e, () => e.attachShader(r, this.vertexShader)), Dt(e, () => e.attachShader(r, t)), HBt(e, r);
      const i = Object.assign(r, {
        vao: this.createVertexArray()
      });
      return this.debug && IT(e, i), i;
    }
    buildVao(t) {
      this.setProgram(t), this.bindVertexArray(t.vao);
      const e = this.gl;
      Dt(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer)), fzt(e, t, this.vertexBuffer);
    }
    deleteProgram(t) {
      this.throwIfDisposed(), t === this.program && (this.program = null), t != null && (Dt(this.gl, () => this.gl.deleteProgram(t)), this.deleteVertexArray(t.vao));
    }
    setProgram(t) {
      this.throwIfDisposed(), this.program = t, this.program != null && this.debug && IT(this.gl, this.program), Dt(this.gl, () => this.gl.useProgram(t));
    }
    getUniformLocation(t, e, r = true) {
      return this.throwIfDisposed(), r ? JBt(this.gl, t, e) : QBt(this.gl, t, e);
    }
    getAttributeLocation(t, e) {
      return this.throwIfDisposed(), Dt(this.gl, () => this.gl.getAttribLocation(t, e));
    }
    getUniformLocationNoThrow(t, e) {
      return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);
    }
    setInputMatrixTexture(t, e, r) {
      this.throwIfDisposed(), this.throwIfNoProgram(), t3t(this.gl, t, e, r);
    }
    setOutputMatrixTexture(t, e, r) {
      this.setOutputMatrixTextureDriver(t, r, e);
    }
    setOutputPackedMatrixTexture(t, e, r) {
      this.throwIfDisposed();
      const [i, a] = Vd(e, r);
      this.setOutputMatrixTextureDriver(t, i, a);
    }
    setOutputMatrixWriteRegion(t, e, r, i) {
      this.setOutputMatrixWriteRegionDriver(r, t, i, e);
    }
    setOutputPackedMatrixWriteRegion(t, e, r, i) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
    debugValidate() {
      this.program != null && IT(this.gl, this.program), E0(this.gl);
    }
    executeProgram() {
      this.throwIfDisposed(), this.throwIfNoProgram();
      const t = this.gl;
      if (this.debug) {
        const e = this.getVertexArray();
        console.assert(e === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate();
      }
      Dt(t, () => t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
      this.throwIfDisposed(), Dt(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
      return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = D0(this.gl, nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
      return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
      return this.getQueryTimerExtension();
    }
    beginQuery() {
      if (nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const r = this.gl, i = this.getQueryTimerExtensionWebGL2(), a = r.createQuery();
        return r.beginQuery(i.TIME_ELAPSED_EXT, a), a;
      }
      const t = this.getQueryTimerExtensionWebGL1(), e = t.createQueryEXT();
      return t.beginQueryEXT(t.TIME_ELAPSED_EXT, e), e;
    }
    endQuery() {
      if (nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const e = this.gl, r = this.getQueryTimerExtensionWebGL2();
        e.endQuery(r.TIME_ELAPSED_EXT);
        return;
      }
      const t = this.getQueryTimerExtensionWebGL1();
      t.endQueryEXT(t.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(t) {
      return await kz(() => this.disposed || this.isQueryAvailable(t, nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(t, nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }
    getQueryTime(t, e) {
      if (e === 0) return null;
      if (e === 2) {
        const r = this.gl;
        return r.getQueryParameter(t, r.QUERY_RESULT) / 1e6;
      } else {
        const r = this.getQueryTimerExtensionWebGL1();
        return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;
      }
    }
    isQueryAvailable(t, e) {
      if (e === 0) return true;
      if (e === 2) {
        const r = this.gl, i = this.getQueryTimerExtensionWebGL2(), a = r.getQueryParameter(t, r.QUERY_RESULT_AVAILABLE);
        return this.disjoint == null && (this.disjoint = this.gl.getParameter(i.GPU_DISJOINT_EXT)), a && !this.disjoint;
      } else {
        const r = this.getQueryTimerExtensionWebGL1(), i = r.getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT);
        return this.disjoint == null && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), i && !this.disjoint;
      }
    }
    pollFence(t) {
      return new Promise((e) => {
        this.addItemToPoll(() => t.isFencePassed(), () => e());
      });
    }
    pollItems() {
      const t = bzt(this.itemsToPoll.map((e) => e.isDoneFn));
      for (let e = 0; e <= t; ++e) {
        const { resolveFn: r } = this.itemsToPoll[e];
        r();
      }
      this.itemsToPoll = this.itemsToPoll.slice(t + 1);
    }
    addItemToPoll(t, e) {
      if (this.itemsToPoll.push({
        isDoneFn: t,
        resolveFn: e
      }), this.itemsToPoll.length > 1) return;
      let r;
      "setTimeoutCustom" in nt().platform && (r = nt().platform.setTimeoutCustom.bind(nt().platform)), kz(() => (this.pollItems(), this.itemsToPoll.length === 0), () => 0, null, r);
    }
    bindTextureToFrameBuffer(t) {
      this.throwIfDisposed(), AT(this.gl, t, this.framebuffer), this.debug && E0(this.gl);
    }
    unbindTextureToFrameBuffer() {
      this.outputTexture != null ? (AT(this.gl, this.outputTexture, this.framebuffer), this.debug && E0(this.gl)) : WV(this.gl, this.framebuffer);
    }
    downloadMatrixDriver(t, e) {
      this.bindTextureToFrameBuffer(t);
      const r = e();
      return this.unbindTextureToFrameBuffer(), r;
    }
    setOutputMatrixTextureDriver(t, e, r) {
      this.throwIfDisposed();
      const i = this.gl;
      AT(i, t, this.framebuffer), this.debug && E0(i), this.outputTexture = t, Dt(i, () => i.viewport(0, 0, e, r)), Dt(i, () => i.scissor(0, 0, e, r));
    }
    setOutputMatrixWriteRegionDriver(t, e, r, i) {
      this.throwIfDisposed(), Dt(this.gl, () => this.gl.scissor(t, e, r, i));
    }
    throwIfDisposed() {
      if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
    }
    throwIfNoProgram() {
      if (this.program == null) throw new Error("No GPU program is currently set.");
    }
  }
  function bzt(n) {
    let t = 0;
    for (; t < n.length && n[t](); ++t) ;
    return t - 1;
  }
  const { addImpl: _zt, bincountImpl: XZ, bincountReduceImpl: wzt, bitwiseAndImpl: Szt, castImpl: Czt, ceilImpl: Tzt, concatImpl: Izt, equalImpl: Azt, expImpl: kzt, expm1Impl: Dzt, floorImpl: Ezt, gatherNdImpl: Mzt, gatherV2Impl: Rzt, greaterImpl: Nzt, greaterEqualImpl: Lzt, lessImpl: Pzt, lessEqualImpl: $zt, linSpaceImpl: Ozt, logImpl: Fzt, maxImpl: Bzt, maximumImpl: zzt, minimumImpl: Vzt, multiplyImpl: Gzt, negImpl: Wzt, notEqualImpl: Uzt, prodImpl: Hzt, raggedGatherImpl: Xzt, raggedRangeImpl: Yzt, raggedTensorToTensorImpl: qzt, rangeImpl: jzt, rsqrtImpl: Kzt, scatterImpl: Zzt, sigmoidImpl: Jzt, simpleAbsImpl: YZ, sliceImpl: Qzt, sparseFillEmptyRowsImpl: tVt, sparseReshapeImpl: eVt, sparseSegmentReductionImpl: qZ, sqrtImpl: nVt, staticRegexReplaceImpl: rVt, stridedSliceImpl: iVt, stringNGramsImpl: aVt, stringSplitImpl: sVt, stringToHashBucketFastImpl: oVt, subImpl: lVt, tileImpl: uVt, topKImpl: cVt, transposeImpl: _N, uniqueImpl: hVt } = pLt;
  function jZ(n, t) {
    return [
      "x",
      "y",
      "z",
      "w",
      "u",
      "v"
    ].slice(0, t).map((e) => `${n}.${e}`);
  }
  function Hr(n, t) {
    return t === 1 ? [
      n
    ] : jZ(n, t);
  }
  function fVt(n, t) {
    if (n === 1) return "rc";
    let e = "";
    for (let r = 0; r < n; r++) e += t[r], r < n - 1 && (e += ",");
    return e;
  }
  class dVt {
    constructor(t) {
      if (this.variableNames = [
        "A"
      ], this.packedInputs = false, this.packedOutput = true, this.outputShape = t, this.rank = t.length, this.enableShapeUniforms = Lr(this.outputShape.length), this.rank === 0) this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
      else {
        const e = Hr("rc", this.rank), r = sn(this.rank), i = this.getOutOfBoundsCondition(e), a = this.getSetup(e), s = this.getOutput(e);
        this.userCode = `
        void main() {
          ${r} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${s}));
          }
        }
      `;
      }
    }
    getSourceCoordsArr(t) {
      const e = [];
      for (let r = 0; r <= 1; r++) for (let i = 0; i <= 1; i++) {
        let a = `${r === 0 ? "r" : "rp1"}, ${i === 0 ? "c" : "cp1"}`;
        for (let s = 2; s < this.rank; s++) a = `${t[t.length - 1 - s]},` + a;
        e.push(a);
      }
      return e;
    }
    getOutOfBoundsCondition(t) {
      if (this.rank === 1) return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
      let e = "";
      for (let r = this.rank - 2; r < this.rank; r++) e += `${t[r]} >= ${this.enableShapeUniforms ? `outShape[${r}]` : this.outputShape[r]}`, r < this.rank - 1 && (e += "||");
      return e;
    }
    getSetup(t) {
      if (this.rank === 1) return "";
      const e = t.slice(-2), r = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1], i = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
      return `
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${i};
    `;
    }
    getOutput(t) {
      const e = this.getSourceCoordsArr(t);
      return this.rank === 1 ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`;
    }
  }
  class KZ {
    constructor(t, e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "inputShape",
          type: "ivec3"
        }
      ], this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length);
      let r = "";
      for (let i = 0; i < 4; i++) {
        let a = "thisRC = rc;";
        i % 2 === 1 && (a += "thisRC.z += 1;"), i > 1 && (a += "thisRC.y += 1;"), r += `
        ${a}
        ${i > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? "}" : ""}
      `;
      }
      this.userCode = `
      ${pVt(e, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? xN() : yN(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : t[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : t[2]};

        ${r}

        setOutput(result);
      }
    `;
    }
  }
  function pVt(n, t) {
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t ? f3t([
      "r",
      "c",
      "d"
    ], "inputShape") : Ih([
      "r",
      "c",
      "d"
    ], n)}
      return ivec3(r, c, d);
    }
  `;
  }
  class gVt {
    constructor(t) {
      this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.usedTextures = {}, this.logEnabled = false;
    }
    acquireTexture(t, e, r) {
      const i = qV(e, r), a = jV(t, i, r);
      a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []);
      const s = YV(t, i, this.gpgpu.gl, this.gpgpu.textureConfig, r);
      if (this.freeTextures[a].length > 0) {
        this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= s, this.log();
        const l = this.freeTextures[a].pop();
        return this.usedTextures[a].push(l), l;
      }
      let o;
      return i === vr.PACKED_2X2_FLOAT32 ? o = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : i === vr.PACKED_2X2_FLOAT16 ? o = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : i === vr.UNPACKED_FLOAT32 ? o = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : i === vr.UNPACKED_FLOAT16 ? o = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : i === vr.PACKED_4X1_UNSIGNED_BYTE && (o = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[a].push(o), this.numUsedTextures++, this._numBytesAllocated += s, this.log(), o;
    }
    releaseTexture(t, e, r, i) {
      if (this.freeTextures == null) return;
      const a = qV(r, i), s = jV(e, a, i);
      s in this.freeTextures || (this.freeTextures[s] = []);
      const o = YV(e, a, this.gpgpu.gl, this.gpgpu.textureConfig, i), l = nt().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
      l !== -1 && this._numBytesAllocated > l ? (this.gpgpu.deleteMatrixTexture(t.texture), this._numBytesAllocated -= o) : (this.freeTextures[s].push(t), this.numFreeTextures++, this._numBytesFree += o), this.numUsedTextures--;
      const u = this.usedTextures[s], c = u && u.indexOf(t);
      if (c == null || c < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      u[c] = u[u.length - 1], u.pop(), this.log();
    }
    log() {
      if (!this.logEnabled) return;
      const t = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${t})`);
      const e = this._numBytesFree / this._numBytesAllocated;
      console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * e)}%)`);
    }
    get numBytesAllocated() {
      return this._numBytesAllocated;
    }
    get numBytesFree() {
      return this._numBytesFree;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      if (this.freeTextures != null) {
        for (const t in this.freeTextures) this.freeTextures[t].forEach((e) => {
          this.gpgpu.deleteMatrixTexture(e.texture);
        });
        for (const t in this.usedTextures) this.usedTextures[t].forEach((e) => {
          this.gpgpu.deleteMatrixTexture(e.texture);
        });
        this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
      }
    }
  }
  function vVt(n, t) {
    const e = n;
    if (t === e.R32F) return 4;
    if (t === e.R16F) return 2;
    if (t === e.RGBA32F) return 16;
    if (t === n.RGBA) return 16;
    if (t === e.RGBA16F) return 8;
    if (t === e.RGBA8) return 4;
    throw new Error(`Unknown internal format ${t}`);
  }
  function YV(n, t, e, r, i) {
    const a = mVt(t, r);
    let s;
    if (i) {
      const [l, u] = Vd(n[0], n[1]);
      s = l * u;
    } else {
      const [l, u] = hy(n[0], n[1]);
      s = l * u;
    }
    const o = vVt(e, a);
    return s * o;
  }
  function mVt(n, t) {
    switch (n) {
      case vr.PACKED_2X2_FLOAT32:
        return UZ(t);
      case vr.PACKED_2X2_FLOAT16:
        return HZ(t);
      case vr.UNPACKED_FLOAT32:
        return VZ(t);
      case vr.UNPACKED_FLOAT16:
        return GZ(t);
      case vr.PACKED_4X1_UNSIGNED_BYTE:
        return WZ(t);
      default:
        throw new Error(`Unknown physical texture type ${n}`);
    }
  }
  function yVt(n) {
    return nt().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? n ? vr.PACKED_2X2_FLOAT32 : vr.UNPACKED_FLOAT32 : n ? vr.PACKED_2X2_FLOAT16 : vr.UNPACKED_FLOAT16;
  }
  function qV(n, t) {
    if (n === Hi.UPLOAD) return vr.PACKED_2X2_FLOAT32;
    if (n === Hi.RENDER || n == null) return yVt(t);
    if (n === Hi.DOWNLOAD || n === Hi.PIXELS) return vr.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error(`Unknown logical texture type ${n}`);
  }
  function jV(n, t, e) {
    return `${n[0]}_${n[1]}_${t}_${e}`;
  }
  class Gs {
    constructor(t, e) {
      this.variableNames = [
        "A"
      ], this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length), this.userCode = `
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  }
  const La = "if (isnan(x)) return x;", xVt = "return x;", KV = "return abs(x);", bVt = "return (x >= 0.0) ? x : (exp(x) - 1.0);", _Vt = La + `
  return (x < 0.0) ? 0.0 : x;
`, wVt = La + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, wl = "return x;", SVt = "return 1.0 / (1.0 + exp(-1.0 * x));";
  const CVt = "return x;", TVt = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, IVt = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, AVt = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, kVt = "return 1.0 / (1.0 + exp(-1.0 * x));";
  class Ll {
    constructor(t, e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length), this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  }
  class DVt {
    constructor(t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = false, this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length);
      const e = t.length, r = Hr("rc", e), i = sn(e), a = fVt(e, r), s = r.slice(-2), o = e <= 1 ? "rc" : `vec2(${s.join(",")})`;
      this.userCode = `
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `;
    }
  }
  const EVt = bj, MVt = 1e-7, RVt = 1e-4, N0 = {};
  function NVt(n) {
    return n in N0 || (N0[n] = {}), N0[n];
  }
  const LVt = nt().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"), PVt = 600;
  function $Vt() {
    return nt().global.screen == null ? 1024 : nt().global.screen.height * nt().global.screen.width * window.devicePixelRatio * PVt / 1024 / 1024;
  }
  class Dw extends UE {
    nextDataId() {
      return Dw.nextDataId++;
    }
    constructor(t) {
      if (super(), this.pendingRead = /* @__PURE__ */ new WeakMap(), this.pendingDisposal = /* @__PURE__ */ new WeakSet(), this.dataRefCount = /* @__PURE__ */ new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = false, this.pendingDeletes = 0, this.disposed = false, !nt().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
      let e;
      if (t != null) {
        if (t instanceof ET) e = t;
        else {
          const r = cs(nt().getNumber("WEBGL_VERSION"), t);
          e = new ET(r);
        }
        this.binaryCache = {}, this.gpgpuCreatedLocally = false;
      } else {
        const r = cs(nt().getNumber("WEBGL_VERSION"));
        e = new ET(r), this.binaryCache = NVt(nt().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = true;
      }
      this.gpgpu = e, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new gVt(this.gpgpu), this.numMBBeforeWarning = $Vt(), this.texData = new UY(this, Es());
    }
    numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
    writeTexture(t, e, r, i, a, s) {
      const o = this.makeTensorInfo(e, r), l = this.texData.get(o.dataId);
      l.isPacked = false, l.texture = {
        texture: t,
        texShape: [
          i,
          a
        ]
      }, l.texShape = [
        i,
        a
      ];
      const u = M0(e), c = new XV(u, false, s), h = this.runWebGLProgram(c, [
        o
      ], r, [
        [
          i,
          a
        ]
      ]);
      return h.shape = e, l.texture = null, this.disposeIntermediateTensorInfo(o), h.dataId;
    }
    write(t, e, r) {
      if ((nt().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || nt().getBool("DEBUG")) && this.checkNumericalProblems(t), r === "complex64" && t != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      const i = {
        id: this.nextDataId()
      };
      return this.texData.set(i, {
        shape: e,
        dtype: r,
        values: t,
        usage: Hi.UPLOAD,
        refCount: 1
      }), i;
    }
    refCount(t) {
      return this.texData.has(t) ? this.texData.get(t).refCount : 0;
    }
    incRef(t) {
      const e = this.texData.get(t);
      e.refCount++;
    }
    decRef(t) {
      if (this.texData.has(t)) {
        const e = this.texData.get(t);
        e.refCount--;
      }
    }
    move(t, e, r, i, a) {
      if (nt().getBool("DEBUG") && this.checkNumericalProblems(e), i === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.texData.set(t, {
        shape: r,
        dtype: i,
        values: e,
        usage: Hi.UPLOAD,
        refCount: a
      });
    }
    disposeIntermediateTensorInfo(t) {
      this.disposeData(t.dataId);
    }
    readSync(t) {
      const e = this.texData.get(t), { values: r, dtype: i, complexTensorInfos: a, slice: s, shape: o, isPacked: l } = e;
      if (s != null) {
        let f;
        l ? f = new Ll(o, wl) : f = new Gs(o, wl);
        const d = this.runWebGLProgram(f, [
          {
            dataId: t,
            shape: o,
            dtype: i
          }
        ], i), p = this.readSync(d.dataId);
        return this.disposeIntermediateTensorInfo(d), p;
      }
      if (r != null) return this.convertAndCacheOnCPU(t);
      if (i === "string") return r;
      const u = this.activeTimers != null;
      let c;
      u && (c = si());
      let h;
      if (i === "complex64") {
        const f = this.readSync(a.real.dataId), d = this.readSync(a.imag.dataId);
        h = Ko(f, d);
      } else h = this.getValuesFromTexture(t);
      return u && (this.downloadWaitMs += si() - c), this.convertAndCacheOnCPU(t, h);
    }
    async read(t) {
      if (this.pendingRead.has(t)) {
        const p = this.pendingRead.get(t);
        return new Promise((g) => p.push(g));
      }
      const e = this.texData.get(t), { values: r, shape: i, slice: a, dtype: s, complexTensorInfos: o, isPacked: l } = e;
      if (a != null) {
        let p;
        l ? p = new Ll(i, wl) : p = new Gs(i, wl);
        const g = this.runWebGLProgram(p, [
          {
            dataId: t,
            shape: i,
            dtype: s
          }
        ], s), v = this.read(g.dataId);
        return this.disposeIntermediateTensorInfo(g), v;
      }
      if (r != null) return this.convertAndCacheOnCPU(t);
      if (nt().getBool("DEBUG") && !nt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && nt().getNumber("WEBGL_VERSION") === 2) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
      let u = null, c;
      if (s !== "complex64" && nt().get("WEBGL_BUFFER_SUPPORTED")) {
        c = this.decode(t);
        const p = this.texData.get(c.dataId);
        u = this.gpgpu.createBufferFromTexture(p.texture.texture, ...k0(i));
      }
      this.pendingRead.set(t, []), s !== "complex64" && await this.gpgpu.createAndWaitForFence();
      let h;
      if (s === "complex64") {
        const p = await Promise.all([
          this.read(o.real.dataId),
          this.read(o.imag.dataId)
        ]), g = p[0], v = p[1];
        h = Ko(g, v);
      } else if (u == null) h = this.getValuesFromTexture(t);
      else {
        const p = lt(i);
        h = this.gpgpu.downloadFloat32MatrixFromBuffer(u, p);
      }
      if (c != null && this.disposeIntermediateTensorInfo(c), u != null) {
        const p = this.gpgpu.gl;
        Dt(p, () => p.deleteBuffer(u));
      }
      const f = this.convertAndCacheOnCPU(t, h), d = this.pendingRead.get(t);
      return this.pendingRead.delete(t), d.forEach((p) => p(f)), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t) && Es().removeDataId(t, this), this.pendingDeletes--), f;
    }
    readToGPU(t, e = {}) {
      const r = this.texData.get(t), { values: i, shape: a, slice: s, dtype: o, isPacked: l, texture: u } = r;
      if (o === "complex64") throw new Error("Does not support reading texture for complex64 dtype.");
      if (s != null) {
        let d;
        l ? d = new Ll(a, wl) : d = new Gs(a, wl);
        const p = this.runWebGLProgram(d, [
          {
            dataId: t,
            shape: a,
            dtype: o
          }
        ], o), g = this.readToGPU(p, e);
        return this.disposeIntermediateTensorInfo(p), g;
      }
      if (u == null) throw i != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
      const c = this.decode(t, e.customTexShape), h = Es().makeTensorFromTensorInfo(c), f = this.texData.get(c.dataId);
      return Object.assign({
        tensorRef: h
      }, f.texture);
    }
    bufferSync(t) {
      const e = this.readSync(t.dataId);
      if (t.dtype === "string") try {
        const r = e.map((i) => tu(i));
        return we(t.shape, t.dtype, r);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return we(t.shape, t.dtype, e);
    }
    checkNumericalProblems(t) {
      if (t != null) for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!BBt(r)) throw nt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${r} cannot be represented on this device.`);
      }
    }
    getValuesFromTexture(t) {
      const { shape: e, dtype: r, isPacked: i } = this.texData.get(t), a = lt(e);
      if (nt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        const f = this.decode(t), d = this.texData.get(f.dataId), p = this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture, ...k0(e)).subarray(0, a);
        return this.disposeIntermediateTensorInfo(f), p;
      }
      const s = nt().getBool("WEBGL_PACK") && i === true, o = s ? M0(e) : e, l = s ? new ezt(o) : new tzt(o), u = this.runWebGLProgram(l, [
        {
          shape: o,
          dtype: r,
          dataId: t
        }
      ], "float32"), c = this.texData.get(u.dataId), h = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture, c.texShape[0], c.texShape[1]).subarray(0, a);
      return this.disposeIntermediateTensorInfo(u), h;
    }
    timerAvailable() {
      return nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    time(t) {
      const e = this.activeTimers, r = [];
      let i = false;
      this.programTimersStack == null ? (this.programTimersStack = r, i = true) : this.activeTimers.push(r), this.activeTimers = r, t();
      const a = Zc(this.activeTimers.map((l) => l.query)).filter((l) => l != null), s = Zc(this.activeTimers.map((l) => l.name)).filter((l) => l != null);
      this.activeTimers = e, i && (this.programTimersStack = null);
      const o = {
        uploadWaitMs: this.uploadWaitMs,
        downloadWaitMs: this.downloadWaitMs,
        kernelMs: null,
        wallMs: null
      };
      return (async () => {
        if (nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          const l = await Promise.all(a);
          o.kernelMs = mSt(l), o.getExtraProfileInfo = () => l.map((u, c) => ({
            name: s[c],
            ms: u
          })).map((u) => `${u.name}: ${u.ms}`).join(", ");
        } else o.kernelMs = {
          error: "WebGL query timers are not supported in this environment."
        };
        return this.uploadWaitMs = 0, this.downloadWaitMs = 0, o;
      })();
    }
    memory() {
      return {
        unreliable: false,
        numBytesInGPU: this.numBytesInGPU,
        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
        numBytesInGPUFree: this.textureManager.numBytesFree
      };
    }
    startTimer() {
      return nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
        startMs: si(),
        endMs: null
      };
    }
    endTimer(t) {
      return nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = si(), t);
    }
    async getQueryTime(t) {
      if (nt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) return this.gpgpu.waitForQueryAndGetTime(t);
      const e = t;
      return e.endMs - e.startMs;
    }
    disposeData(t, e = false) {
      if (this.pendingDisposal.has(t)) return false;
      if (!this.texData.has(t)) return true;
      if (e ? this.texData.get(t).refCount = 0 : this.texData.get(t).refCount--, !e && this.texData.get(t).refCount > 0) return false;
      if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), this.pendingDeletes++, false;
      this.releaseGPUData(t);
      const { complexTensorInfos: r } = this.texData.get(t);
      return r != null && (this.disposeData(r.real.dataId, e), this.disposeData(r.imag.dataId, e)), this.texData.delete(t), true;
    }
    releaseGPUData(t) {
      const { texture: e, dtype: r, texShape: i, usage: a, isPacked: s, slice: o } = this.texData.get(t), l = o && o.origDataId || t, u = this.dataRefCount.get(l);
      u > 1 ? this.dataRefCount.set(l, u - 1) : (this.dataRefCount.delete(l), e != null && (this.numBytesInGPU -= this.computeBytes(i, r), this.textureManager.releaseTexture(e, i, a, s)));
      const c = this.texData.get(t);
      c.texture = null, c.texShape = null, c.isPacked = false, c.slice = null;
    }
    getTexture(t) {
      return this.uploadToGPU(t), this.texData.get(t).texture.texture;
    }
    getDataInfo(t) {
      return this.texData.get(t);
    }
    shouldExecuteOnCPU(t, e = LVt) {
      return nt().getBool("WEBGL_CPU_FORWARD") && t.every((r) => this.texData.get(r.dataId).texture == null && lt(r.shape) < e);
    }
    getGPGPUContext() {
      return this.gpgpu;
    }
    where(t) {
      Wi("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      const e = t.dataSync();
      return EVt(t.shape, e);
    }
    packedUnaryOp(t, e, r) {
      const i = new Ll(t.shape, e), a = this.compileAndRun(i, [
        t
      ], r);
      return Es().makeTensorFromTensorInfo(a);
    }
    abs(t) {
      if (this.shouldExecuteOnCPU([
        t
      ]) && t.dtype !== "complex64") {
        const i = YZ(this.texData.get(t.dataId).values);
        return this.makeOutput(t.shape, t.dtype, i);
      }
      if (nt().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, KV, t.dtype);
      const e = new Gs(t.shape, KV), r = this.compileAndRun(e, [
        t
      ]);
      return Es().makeTensorFromTensorInfo(r);
    }
    makeTensorInfo(t, e, r) {
      let i;
      if (e === "string" && r != null && r.length > 0 && Jv(r[0])) {
        const a = r.map((s) => Gl(s));
        i = this.write(a, t, e);
      } else i = this.write(r, t, e);
      return this.texData.get(i).usage = null, {
        dataId: i,
        shape: t,
        dtype: e
      };
    }
    makeOutput(t, e, r) {
      return Es().makeTensorFromTensorInfo(this.makeTensorInfo(t, e, r), this);
    }
    unpackTensor(t) {
      const e = new DVt(t.shape);
      return this.runWebGLProgram(e, [
        t
      ], t.dtype);
    }
    packTensor(t) {
      const e = new dVt(t.shape);
      return this.runWebGLProgram(e, [
        t
      ], t.dtype, null, true);
    }
    packedReshape(t, e) {
      const r = [
        od(t.shape),
        ...ld(t.shape)
      ], i = {
        dtype: t.dtype,
        shape: r,
        dataId: t.dataId
      }, a = [
        od(e),
        ...ld(e)
      ], s = new KZ(a, r), o = true, l = [
        r
      ], u = this.runWebGLProgram(s, [
        i
      ], t.dtype, l, o);
      return {
        dataId: u.dataId,
        shape: e,
        dtype: u.dtype
      };
    }
    decode(t, e) {
      const r = this.texData.get(t), { isPacked: i, shape: a, dtype: s } = r;
      if (e != null) {
        const f = lt(a), d = e[0] * e[1] * 4;
        B(f <= d, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
      }
      const o = M0(a);
      let l;
      i ? l = new Q3t(o) : l = new J3t(o);
      const u = true, c = [
        e ?? k0(o)
      ], h = this.runWebGLProgram(l, [
        {
          shape: o,
          dtype: s,
          dataId: t
        }
      ], s, c, u, e);
      return {
        dtype: s,
        shape: a,
        dataId: h.dataId
      };
    }
    runWebGLProgram(t, e, r, i, a = false, s) {
      const o = this.makeTensorInfo(t.outputShape, r), l = this.texData.get(o.dataId);
      if (t.packedOutput && (l.isPacked = true), t.outPackingScheme === yv.DENSE) {
        const m = s ?? k0(t.outputShape);
        l.texShape = m.map((y) => y * 2);
      }
      if (t.outTexUsage != null && (l.usage = t.outTexUsage), lt(o.shape) === 0) return l.values = Dr(o.dtype, 0), o;
      const u = [], c = e.map((m) => {
        if (m.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
        let y = this.texData.get(m.dataId);
        if (y.texture == null) {
          if (!t.packedInputs && lt(m.shape) <= nt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
            shape: m.shape,
            texData: null,
            isUniform: true,
            uniformValues: y.values
          };
          t.packedInputs && (y.isPacked = true, y.shape = m.shape);
        }
        if (this.uploadToGPU(m.dataId), !!y.isPacked != !!t.packedInputs) m = y.isPacked ? this.unpackTensor(m) : this.packTensor(m), u.push(m), y = this.texData.get(m.dataId);
        else if (y.isPacked && !i1(y.shape, m.shape)) {
          const x = m, b = m.shape;
          m.shape = y.shape, m = this.packedReshape(m, b), u.push(m), y = this.texData.get(m.dataId), x.shape = b;
        }
        return {
          shape: m.shape,
          texData: y,
          isUniform: false
        };
      });
      this.uploadToGPU(o.dataId);
      const h = {
        shape: o.shape,
        texData: l,
        isUniform: false
      }, f = Z3t(t, c, h), d = this.getAndSaveBinary(f, () => j3t(this.gpgpu, t, c, h)), p = this.activeTimers != null;
      let g;
      p && (g = this.startTimer()), nt().get("ENGINE_COMPILE_ONLY") || K3t(this.gpgpu, d, c, h, i), u.forEach((m) => this.disposeIntermediateTensorInfo(m)), p && (g = this.endTimer(g), this.activeTimers.push({
        name: t.constructor.name,
        query: this.getQueryTime(g)
      }));
      const v = nt().getNumber("WEBGL_FLUSH_THRESHOLD");
      if (v > 0) {
        const m = si();
        m - this.lastGlFlushTime > v && (this.gpgpu.gl.flush(), this.lastGlFlushTime = m);
      }
      if (!nt().getBool("WEBGL_LAZILY_UNPACK") && l.isPacked && a === false) {
        const m = this.unpackTensor(o);
        return this.disposeIntermediateTensorInfo(o), m;
      }
      return o;
    }
    compileAndRun(t, e, r, i, a = false) {
      return r = r || e[0].dtype, this.runWebGLProgram(t, e, r, i, a);
    }
    getAndSaveBinary(t, e) {
      return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t];
    }
    getTextureManager() {
      return this.textureManager;
    }
    dispose() {
      this.disposed || (nt().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((e) => {
        this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram), delete this.binaryCache[e];
      }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
    }
    floatPrecision() {
      return this.floatPrecisionValue == null && (this.floatPrecisionValue = tt(() => {
        if (!nt().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
          const t = nt().getBool("DEBUG");
          nt().set("DEBUG", false);
          const e = this.abs(Ue(1e-8)).dataSync()[0];
          if (nt().set("DEBUG", t), e > 0) return 32;
        }
        return 16;
      })), this.floatPrecisionValue;
    }
    epsilon() {
      return this.floatPrecision() === 32 ? MVt : RVt;
    }
    uploadToGPU(t) {
      const e = this.texData.get(t), { shape: r, dtype: i, values: a, texture: s, usage: o, isPacked: l } = e;
      if (s != null) return;
      const u = this.activeTimers != null;
      let c;
      u && (c = si());
      let h = e.texShape;
      if (h == null && (h = r3t(r, l), e.texShape = h), a != null) {
        const f = M0(r);
        let d, p = h[1], g = h[0];
        const v = a instanceof Uint8Array || a instanceof Uint8ClampedArray;
        (l || !v) && ([p, g] = Vd(h[0], h[1])), l ? d = new rzt(f, v) : d = new XV(f, v);
        const m = v ? [
          g,
          p
        ] : h, y = this.makeTensorInfo(m, i), x = this.texData.get(y.dataId);
        v ? x.usage = Hi.PIXELS : x.usage = Hi.UPLOAD, x.texShape = m, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId), p, g, a);
        const b = [
          [
            g,
            p
          ]
        ], w = this.runWebGLProgram(d, [
          y
        ], i, b, true), S = this.texData.get(w.dataId);
        e.texShape = S.texShape, e.isPacked = S.isPacked, e.usage = S.usage, nt().get("ENGINE_COMPILE_ONLY") ? this.disposeData(w.dataId) : (e.texture = S.texture, e.values = null, this.texData.delete(w.dataId)), this.disposeIntermediateTensorInfo(y), u && (this.uploadWaitMs += si() - c);
      } else {
        const f = this.acquireTexture(h, o, i, l);
        e.texture = f;
      }
    }
    convertAndCacheOnCPU(t, e) {
      const r = this.texData.get(t), { dtype: i } = r;
      return e != null && (r.values = OVt(e, i)), r.values;
    }
    acquireTexture(t, e, r, i) {
      if (this.numBytesInGPU += this.computeBytes(t, r), !this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
        const a = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true, console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`);
      }
      return this.textureManager.acquireTexture(t, e, i);
    }
    computeBytes(t, e) {
      return t[0] * t[1] * Lb(e);
    }
    checkCompileCompletion() {
      for (const [, t] of Object.entries(this.binaryCache)) this.checkCompletion_(t);
    }
    async checkCompileCompletionAsync() {
      const t = [];
      if (this.gpgpu.parallelCompilationExtension) {
        for (const [, e] of Object.entries(this.binaryCache)) t.push(this.checkCompletionAsync_(e));
        return Promise.all(t);
      } else {
        for (const [, e] of Object.entries(this.binaryCache)) {
          const r = new Promise((i) => {
            try {
              this.checkCompletion_(e), i(true);
            } catch (a) {
              throw a;
            }
          });
          t.push(r);
        }
        return Promise.all(t);
      }
    }
    async checkCompletionAsync_(t) {
      return this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(t) : (await Oj(), this.checkCompletionAsync_(t));
    }
    checkCompletion_(t) {
      if (this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)), this.gpgpu.gl.getShaderParameter(t.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false ? (PZ(t.source, this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)), new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
      return true;
    }
    getUniformLocations() {
      for (const t of Object.values(this.binaryCache)) {
        this.gpgpu.buildVao(t.webGLProgram);
        const { variablesLocations: e, customUniformLocations: r, infLoc: i, nanLoc: a, outShapeLocation: s, outShapeStridesLocation: o, outTexShapeLocation: l } = zZ(this.gpgpu, t.program, t.webGLProgram);
        t.variablesLocations = e, t.customUniformLocations = r, t.infLoc = i, t.nanLoc = a, t.outShapeLocation = s, t.outShapeStridesLocation = o, t.outTexShapeLocation = l;
      }
    }
    createTensorFromGPUData(t, e, r) {
      t.channels = t.channels || "RGBA";
      const { texture: i, height: a, width: s, channels: o } = t, l = Es().backend;
      if (!l.gpgpu.gl.isTexture(i)) throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
      const u = l.writeTexture(i, e, r, a, s, o);
      return Es().makeTensorFromDataId(u, e, r, l);
    }
  }
  Dw.nextDataId = 0;
  function OVt(n, t) {
    if (t === "float32" || t === "complex64") return n;
    if (t === "int32" || t === "bool") {
      const e = t === "int32" ? new Int32Array(n.length) : new Uint8Array(n.length);
      for (let r = 0; r < e.length; ++r) e[r] = Math.round(n[r]);
      return e;
    } else throw new Error(`Unknown dtype ${t}`);
  }
  Nq() && Oq("webgl", () => new Dw(), 2);
  const wN = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
  class uh {
    constructor(t, e, r) {
      this.variableNames = [
        "A",
        "B"
      ], this.outputShape = ve(e, r), this.enableShapeUniforms = Lr(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
  }
  const kh = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
  class Xd {
    constructor(t, e, r, i = false) {
      this.variableNames = [
        "A",
        "B"
      ], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = ve(e, r);
      const a = this.outputShape.length;
      this.enableShapeUniforms = Lr(a);
      let s = "";
      if (i) if (a === 0 || lt(this.outputShape) === 1) s = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
      else if (s = `
          ${sn(a)} coords = getOutputCoords();
        `, a === 1) this.enableShapeUniforms ? s += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          ` : s += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
      else {
        const l = Hr("coords", a);
        this.enableShapeUniforms ? s += `
            bool nextRowOutOfBounds =
              (${l[a - 2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a - 1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : s += `
            bool nextRowOutOfBounds =
              (${l[a - 2]} + 1) >= ${this.outputShape[a - 2]};
            bool nextColOutOfBounds =
              (${l[a - 1]} + 1) >= ${this.outputShape[a - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
      }
      this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `;
    }
  }
  function Fi(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    return e.incRef(r.dataId), {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  const FVt = {
    kernelName: xm,
    backendName: "webgl",
    kernelFunc: Fi
  };
  function mu(n) {
    const { inputs: t, backend: e } = n, { real: r, imag: i } = t, a = e.makeTensorInfo(r.shape, "complex64"), s = e.texData.get(a.dataId), o = Fi({
      inputs: {
        x: r
      },
      backend: e
    }), l = Fi({
      inputs: {
        x: i
      },
      backend: e
    });
    return s.complexTensorInfos = {
      real: o,
      imag: l
    }, a;
  }
  const BVt = {
    kernelName: rM,
    backendName: "webgl",
    kernelFunc: mu
  };
  const ZZ = "return (a < 0.) ? b * a : a;", JZ = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function zVt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { alpha: a } = r, s = e.makeTensorInfo([], "float32", uu(a, "float32")), o = nt().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Xd(JZ, i.shape, s.shape) : new uh(ZZ, i.shape, s.shape), l = e.runWebGLProgram(o, [
      i,
      s
    ], "float32");
    return e.disposeIntermediateTensorInfo(s), l;
  }
  const VVt = {
    kernelName: w_,
    backendName: "webgl",
    kernelFunc: zVt
  };
  const QZ = "return (a < 0.) ? b * a : a;", tJ = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function GVt(n) {
    const { inputs: t, backend: e } = n, { x: r, alpha: i } = t, a = nt().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Xd(tJ, r.shape, i.shape) : new uh(QZ, r.shape, i.shape);
    return e.runWebGLProgram(a, [
      r,
      i
    ], "float32");
  }
  const WVt = {
    kernelName: V_,
    backendName: "webgl",
    kernelFunc: GVt
  };
  const Yd = "if (isnan(x)) return x;";
  function Be({ opSnippet: n, packedOpSnippet: t, cpuKernelImpl: e, dtype: r }) {
    return ({ inputs: i, backend: a }) => {
      const { x: s } = i, o = a, l = r || s.dtype;
      if (o.shouldExecuteOnCPU([
        s
      ]) && e != null) {
        const h = o.texData.get(s.dataId), f = e(h.values, l);
        return o.makeTensorInfo(s.shape, l, f);
      }
      const u = nt().getBool("WEBGL_PACK_UNARY_OPERATIONS") && t != null;
      let c;
      return u ? c = new Ll(s.shape, t) : c = new Gs(s.shape, n), o.runWebGLProgram(c, [
        s
      ], l);
    };
  }
  function Sr({ opSnippet: n, packedOpSnippet: t, checkOutOfBounds: e = false, supportsComplex: r = false, cpuKernelImpl: i, dtype: a }) {
    return ({ inputs: s, backend: o }) => {
      const { a: l, b: u } = s, c = o;
      if (r && l.dtype === "complex64") {
        const p = c.texData.get(l.dataId), g = c.texData.get(u.dataId), [v, m] = [
          [
            p.complexTensorInfos.real,
            g.complexTensorInfos.real
          ],
          [
            p.complexTensorInfos.imag,
            g.complexTensorInfos.imag
          ]
        ].map((x) => {
          const [b, _] = x, w = {
            dataId: b.dataId,
            dtype: b.dtype,
            shape: l.shape
          }, S = {
            dataId: _.dataId,
            dtype: _.dtype,
            shape: u.shape
          }, I = new uh(n, l.shape, u.shape);
          return c.runWebGLProgram(I, [
            w,
            S
          ], $i(b.dtype, _.dtype));
        }), y = mu({
          inputs: {
            real: v,
            imag: m
          },
          backend: c
        });
        return c.disposeIntermediateTensorInfo(v), c.disposeIntermediateTensorInfo(m), y;
      }
      const h = a || $i(l.dtype, u.dtype);
      if ((l.dtype === "string" || u.dtype === "string" || c.shouldExecuteOnCPU([
        l,
        u
      ])) && i != null) {
        const p = c.texData.get(l.dataId).values, g = c.texData.get(u.dataId).values, v = l.dtype === "string" ? Zo(p) : p, m = l.dtype === "string" ? Zo(g) : g, [y, x] = i(l.shape, u.shape, v, m, h), b = c.makeTensorInfo(x, h), _ = c.texData.get(b.dataId);
        return _.values = y, b;
      }
      const f = nt().getBool("WEBGL_PACK_BINARY_OPERATIONS") && t != null;
      let d;
      return f ? d = new Xd(t, l.shape, u.shape, e) : d = new uh(n, l.shape, u.shape), c.runWebGLProgram(d, [
        l,
        u
      ], h);
    };
  }
  function xv(n, t = false) {
    if (n === "linear") return t ? CVt : xVt;
    if (n === "relu") return t ? IVt : _Vt;
    if (n === "elu") return t ? TVt : bVt;
    if (n === "relu6") return t ? AVt : wVt;
    if (n === "prelu") return t ? tJ : QZ;
    if (n === "leakyrelu") return t ? JZ : ZZ;
    if (n === "sigmoid") return t ? kVt : SVt;
    throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`);
  }
  class eJ {
    constructor(t, e, r, i = false, a = false, s = false, o = null, l = false, u = false) {
      this.variableNames = [
        "matrixA",
        "matrixB"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = r, this.enableShapeUniforms = Lr(this.outputShape.length);
      const c = i ? t[1] : t[2], h = Math.ceil(c / 2), f = i ? "i * 2, rc.y" : "rc.y, i * 2", d = a ? "rc.z, i * 2" : "i * 2, rc.z", p = i ? [
        "a.xxyy",
        "a.zzww"
      ] : [
        "a.xxzz",
        "a.yyww"
      ], g = a ? [
        "b.xzxz",
        "b.ywyw"
      ] : [
        "b.xyxy",
        "b.zwzw"
      ];
      let v = "", m = "";
      o && (l ? v = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }` : u ? v = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }` : v = `vec4 activation(vec4 x) {
          ${o}
        }`, m = "result = activation(result);");
      const y = s ? "result += getBiasAtOutCoords();" : "";
      s && this.variableNames.push("bias"), l && this.variableNames.push("preluActivationWeights"), u && this.variableNames.push("leakyreluAlpha");
      let x = "rc.x", b = "rc.x";
      t[0] < e[0] ? x = `imod(rc.x, ${t[0]})` : e[0] < t[0] && (b = `imod(rc.x, ${e[0]})`), this.userCode = `
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${b};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${g[0]});
          result += (${p[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${m}

        setOutput(result);
      }
    `;
    }
  }
  const ZV = {
    REAL: "return areal * breal - aimag * bimag;",
    IMAG: "return areal * bimag + aimag * breal;"
  };
  class JV {
    constructor(t, e, r) {
      this.variableNames = [
        "AReal",
        "AImag",
        "BReal",
        "BImag"
      ], this.outputShape = ve(e, r), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
  }
  const QV = "return a * b;";
  function SN(n) {
    const { inputs: t, backend: e } = n, { a: r, b: i } = t, a = $i(r.dtype, i.dtype);
    if (r.dtype === "complex64") {
      const o = e.texData.get(r.dataId), l = e.texData.get(i.dataId), u = new JV(ZV.REAL, r.shape, i.shape), c = new JV(ZV.IMAG, r.shape, i.shape), h = [
        {
          dataId: o.complexTensorInfos.real.dataId,
          dtype: o.complexTensorInfos.real.dtype,
          shape: r.shape
        },
        {
          dataId: o.complexTensorInfos.imag.dataId,
          dtype: o.complexTensorInfos.imag.dtype,
          shape: r.shape
        },
        {
          dataId: l.complexTensorInfos.real.dataId,
          dtype: l.complexTensorInfos.real.dtype,
          shape: i.shape
        },
        {
          dataId: l.complexTensorInfos.imag.dataId,
          dtype: l.complexTensorInfos.imag.dtype,
          shape: i.shape
        }
      ], f = e.runWebGLProgram(u, h, "float32"), d = e.runWebGLProgram(c, h, "float32"), p = mu({
        inputs: {
          real: f,
          imag: d
        },
        backend: e
      });
      return e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(d), p;
    }
    if (e.shouldExecuteOnCPU([
      r,
      i
    ])) {
      const o = e.texData.get(r.dataId), l = e.texData.get(i.dataId), [u, c] = Gzt(r.shape, i.shape, o.values, l.values, a), h = e.makeTensorInfo(c, a), f = e.texData.get(h.dataId);
      return f.values = u, h;
    }
    let s;
    return nt().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? s = new Xd(QV, r.shape, i.shape) : s = new uh(QV, r.shape, i.shape), e.runWebGLProgram(s, [
      r,
      i
    ], a);
  }
  const UVt = {
    kernelName: km,
    backendName: "webgl",
    kernelFunc: SN
  };
  function HVt(n, t, e) {
    const r = [
      od(n.shape),
      ...ld(n.shape)
    ], i = {
      dtype: n.dtype,
      shape: r,
      dataId: n.dataId
    }, a = [
      od(t),
      ...ld(t)
    ], s = new KZ(a, r), o = true, l = [
      r
    ], u = e.runWebGLProgram(s, [
      i
    ], n.dtype, l, o);
    return {
      dataId: u.dataId,
      shape: t,
      dtype: u.dtype
    };
  }
  function Tt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { shape: a } = r, s = e, o = lt(i.shape), l = XY(a, o), u = lt(l);
    B(o === u, () => `The new shape (${l}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);
    const c = s.texData.get(i.dataId);
    return c.isPacked && !i1(i.shape, l) && !(c.texture !== null && i1(c.shape, l)) ? HVt(i, l, s) : (s.incRef(i.dataId), {
      dataId: i.dataId,
      shape: l,
      dtype: i.dtype
    });
  }
  const XVt = {
    kernelName: W_,
    backendName: "webgl",
    kernelFunc: Tt
  };
  class tG {
    constructor(t, e) {
      this.variableNames = [
        "x"
      ];
      const { windowSize: r, batchSize: i, inSize: a, outSize: s } = t;
      this.outputShape = [
        i,
        s
      ];
      const o = Math.floor(r / 4) * 4, l = r % 4;
      let u = "sumValue += dot(values, ones);";
      if (e != null) {
        const h = 1 / e;
        u = `sumValue += dot(values * ${Jf(h) ? h.toPrecision(2) : h}, ones);`;
      }
      let c = "";
      a % r > 0 && (c = `
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${l === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `;
    }
  }
  class YVt {
    constructor(t, e) {
      this.variableNames = [
        "x"
      ];
      const { windowSize: r, batchSize: i, inSize: a, outSize: s } = t;
      this.outputShape = [
        i,
        s
      ];
      let o = "0.0", l = "";
      e === "prod" ? o = "1.0" : e === "min" ? (o = "1.0 / 1e-20", l = "min") : e === "max" && (o = "-1.0 / 1e-20", l = "max");
      let u = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      e === "sum" ? u = "sumValue" : e === "prod" ? u = "prodValue" : e === "all" ? u = "allValue" : e === "any" && (u = "anyValue");
      const c = Math.floor(r / 4) * 4, h = r % 4;
      let f = `
      if (${e === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${e === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e === "min"} || ${e === "max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, d = "vec4";
      e === "all" ? (o = "1.0", f = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, d = "bvec4") : e === "any" && (o = "0.0", f = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, d = "bvec4");
      let p = "";
      a % r > 0 && (p = `
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${h === 1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h === 2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h === 3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${u});
      }
    `;
    }
  }
  function qVt(n) {
    const t = [];
    for (; t.length === 0 || t[t.length - 1].outSize !== 1; ) {
      const e = t.length ? t[t.length - 1].outSize : n[1], r = dw(e);
      t.push({
        inSize: e,
        windowSize: r,
        outSize: Math.ceil(e / r)
      });
    }
    return t;
  }
  function Dh(n, t, e, r) {
    const i = qVt(n.shape);
    let a = n;
    for (let s = 0; s < i.length; s++) {
      const { inSize: o, windowSize: l, outSize: u } = i[s];
      let c, h;
      e === "mean" ? c = s === 0 ? new tG({
        windowSize: l,
        inSize: o,
        batchSize: n.shape[0],
        outSize: u
      }, o) : new tG({
        windowSize: l,
        inSize: o,
        batchSize: n.shape[0],
        outSize: u
      }) : c = new YVt({
        windowSize: l,
        inSize: o,
        batchSize: n.shape[0],
        outSize: u
      }, e), h = a, a = r.runWebGLProgram(c, [
        a
      ], t), h.dataId !== n.dataId && r.disposeIntermediateTensorInfo(h);
    }
    return a;
  }
  class jVt {
    constructor(t, e) {
      this.variableNames = [
        "A"
      ];
      const r = new Array(t.length);
      for (let s = 0; s < r.length; s++) r[s] = t[e[s]];
      this.outputShape = r, this.rank = r.length;
      const i = sn(this.rank), a = KVt(e);
      this.userCode = `
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `;
    }
  }
  function KVt(n) {
    const t = n.length;
    if (t > 6) throw Error(`Transpose for rank ${t} is not yet supported`);
    const e = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w",
      "resRC.u",
      "resRC.v"
    ], r = new Array(t);
    for (let i = 0; i < n.length; i++) r[n[i]] = e[i];
    return r.join();
  }
  class ZVt {
    constructor(t, e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true;
      const r = new Array(t.length);
      for (let c = 0; c < r.length; c++) r[c] = t[e[c]];
      if (this.outputShape = r, this.rank = r.length, this.rank > 6) throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
      const i = sn(this.rank), a = jZ("rc", this.rank), s = new Array(this.rank);
      for (let c = 0; c < e.length; c++) s[e[c]] = a[c];
      const o = `vec2(${s.slice(-2).join()})`, l = `++${a[this.rank - 1]} < ${r[this.rank - 1]}`, u = `getChannel(getA(${s.join()}), ${o})`;
      this.userCode = `
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${a[this.rank - 1]};
      if(++${a[this.rank - 2]} < ${r[this.rank - 2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `;
    }
  }
  function Ew(n, t, e) {
    const r = nt().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ZVt(n.shape, t) : new jVt(n.shape, t);
    return e.runWebGLProgram(r, [
      n
    ], n.dtype);
  }
  function JVt(n, t, e, r) {
    const i = t, a = n.shape.length, s = Se(i, n.shape);
    let o = s;
    const l = wn(o, a), u = l != null;
    let c = n;
    u && (c = Ew(n, l, r), o = Rn(o.length, a)), wr("sum", o, a);
    const [h, f] = hr(c.shape, o);
    let d = h;
    e && (d = Bn(h, s));
    const p = lt(f), v = lt(n.shape) / p, m = Tt({
      inputs: {
        x: c
      },
      attrs: {
        shape: [
          v,
          p
        ]
      },
      backend: r
    }), y = OM(n.dtype), x = Dh(m, y, "sum", r), b = Tt({
      inputs: {
        x
      },
      attrs: {
        shape: d
      },
      backend: r
    });
    return r.disposeIntermediateTensorInfo(m), r.disposeIntermediateTensorInfo(x), u && r.disposeIntermediateTensorInfo(c), b;
  }
  function Mw(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r;
    return JVt(i, a, s, e);
  }
  const QVt = {
    kernelName: j_,
    backendName: "webgl",
    kernelFunc: Mw
  };
  function Jr(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { perm: a } = r, s = e, o = i.shape.length, l = new Array(o);
    for (let c = 0; c < l.length; c++) l[c] = i.shape[a[c]];
    let u;
    if (s.shouldExecuteOnCPU([
      i
    ])) {
      const h = s.texData.get(i.dataId).values, f = _N(h, i.shape, i.dtype, a, l);
      u = s.makeTensorInfo(l, i.dtype);
      const d = s.texData.get(u.dataId);
      d.values = f;
    } else u = Ew(i, a, s);
    return u;
  }
  const tGt = {
    kernelName: Pf,
    backendName: "webgl",
    kernelFunc: Jr
  };
  const nJ = 1e3;
  function a1({ a: n, b: t, transposeA: e, transposeB: r, backend: i, bias: a = null, preluActivationWeights: s = null, leakyreluAlpha: o = 0, activation: l = null }) {
    const u = n.shape.length, c = t.shape.length, h = e ? n.shape[u - 2] : n.shape[u - 1], f = r ? t.shape[c - 1] : t.shape[c - 2], d = e ? n.shape[u - 1] : n.shape[u - 2], p = r ? t.shape[c - 2] : t.shape[c - 1], g = n.shape.slice(0, -2), v = t.shape.slice(0, -2), m = lt(g), y = lt(v), b = ve(n.shape.slice(0, -2), t.shape.slice(0, -2)).concat([
      d,
      p
    ]);
    B(h === f, () => `Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);
    const _ = e ? [
      m,
      h,
      d
    ] : [
      m,
      d,
      h
    ], w = r ? [
      y,
      p,
      f
    ] : [
      y,
      f,
      p
    ], S = Tt({
      inputs: {
        x: n
      },
      backend: i,
      attrs: {
        shape: _
      }
    }), I = Tt({
      inputs: {
        x: t
      },
      backend: i,
      attrs: {
        shape: w
      }
    }), T = [
      S,
      I
    ], A = Math.max(m, y), C = e ? S.shape[1] : S.shape[2], D = a != null, E = s != null, M = l === "leakyrelu", L = l != null ? xv(l, true) : null, k = D || E || M || L != null;
    let N;
    if ((d === 1 || p === 1) && C > nJ && k === false) {
      let $ = S, O = I;
      e && ($ = Jr({
        inputs: {
          x: S
        },
        backend: i,
        attrs: {
          perm: [
            0,
            2,
            1
          ]
        }
      }), T.push($)), r && (O = Jr({
        inputs: {
          x: I
        },
        backend: i,
        attrs: {
          perm: [
            0,
            2,
            1
          ]
        }
      }), T.push(O));
      const F = p !== 1, z = p === 1;
      let V = $;
      F && (V = Tt({
        inputs: {
          x: $
        },
        backend: i,
        attrs: {
          shape: [
            A,
            C,
            1
          ]
        }
      }), T.push(V));
      const U = p === 1 ? 2 : 1;
      let X = O;
      z && (X = Tt({
        inputs: {
          x: O
        },
        backend: i,
        attrs: {
          shape: [
            A,
            1,
            C
          ]
        }
      }), T.push(X));
      const at = SN({
        inputs: {
          a: V,
          b: X
        },
        backend: i
      });
      N = Mw({
        inputs: {
          x: at
        },
        backend: i,
        attrs: {
          axis: U,
          keepDims: true
        }
      }), T.push(at);
    } else {
      const $ = $i(n.dtype, t.dtype), O = new eJ(_, w, [
        A,
        d,
        p
      ], e, r, D, L, E, M), F = [
        S,
        I
      ];
      if (a != null && F.push(a), E && F.push(s), M) {
        const z = i.makeTensorInfo([], "float32", uu(o, "float32"));
        F.push(z), T.push(z);
      }
      N = i.runWebGLProgram(O, F, $);
    }
    const R = Tt({
      inputs: {
        x: N
      },
      backend: i,
      attrs: {
        shape: b
      }
    });
    T.push(N);
    for (const $ of T) i.disposeIntermediateTensorInfo($);
    return R;
  }
  function eGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { a: i, b: a, bias: s, preluActivationWeights: o } = t, { transposeA: l, transposeB: u, activation: c, leakyreluAlpha: h } = r;
    return a1({
      a: i,
      b: a,
      transposeA: l,
      transposeB: u,
      backend: e,
      bias: s,
      preluActivationWeights: o,
      leakyreluAlpha: h,
      activation: c
    });
  }
  const nGt = {
    kernelName: Pb,
    backendName: "webgl",
    kernelFunc: eGt
  };
  const eG = "return abs(x);";
  function rGt(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    if (e.shouldExecuteOnCPU([
      r
    ]) && r.dtype !== "complex64") {
      const a = e.texData.get(r.dataId), s = YZ(a.values);
      return e.makeTensorInfo(r.shape, r.dtype, s);
    }
    let i;
    return nt().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? i = new Ll(r.shape, eG) : i = new Gs(r.shape, eG), e.runWebGLProgram(i, [
      r
    ], r.dtype);
  }
  const iGt = {
    kernelName: n_,
    backendName: "webgl",
    kernelFunc: rGt
  };
  const aGt = La + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`, sGt = Be({
    opSnippet: aGt
  }), oGt = {
    kernelName: Qv,
    backendName: "webgl",
    kernelFunc: sGt
  };
  const lGt = La + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`, uGt = Be({
    opSnippet: lGt
  }), cGt = {
    kernelName: tm,
    backendName: "webgl",
    kernelFunc: uGt
  };
  const nG = "return a + b;", hGt = Sr({
    opSnippet: nG,
    packedOpSnippet: nG,
    supportsComplex: true,
    cpuKernelImpl: _zt
  }), fGt = {
    kernelName: Ld,
    backendName: "webgl",
    kernelFunc: hGt
  };
  class dGt {
    constructor(t, e) {
      this.outputShape = [], this.outputShape = t, this.variableNames = e.map((a, s) => `T${s}`);
      const r = [];
      this.variableNames.forEach((a) => {
        r.push(`float v${a} = get${a}AtOutCoords();`);
      });
      const i = this.variableNames.map((a) => `v${a}`).join(" + ");
      this.userCode = `
      void main() {
        ${r.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `;
    }
  }
  class pGt {
    constructor(t, e) {
      this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.variableNames = e.map((a, s) => `T${s}`);
      const r = [];
      this.variableNames.forEach((a) => {
        r.push(`vec4 v${a} = get${a}AtOutCoords();`);
      });
      const i = this.variableNames.map((a) => `v${a}`).join(" + ");
      this.userCode = `
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `;
    }
  }
  function Mx(n) {
    const { inputs: t, backend: e } = n, r = t;
    if (r.length === 1) return Fi({
      inputs: {
        x: r[0]
      },
      backend: e
    });
    if (r.length > nt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      const l = Math.floor(r.length / 2), u = Mx({
        inputs: r.slice(0, l),
        backend: e
      }), c = Mx({
        inputs: r.slice(l),
        backend: e
      });
      return Mx({
        inputs: [
          u,
          c
        ],
        backend: e
      });
    }
    const i = r.map((l) => l.dtype).reduce((l, u) => $i(l, u)), a = r.map((l) => l.shape), o = nt().getBool("WEBGL_PACK") ? new pGt(r[0].shape, a) : new dGt(r[0].shape, a);
    return e.runWebGLProgram(o, r, i);
  }
  const gGt = {
    kernelName: KE,
    backendName: "webgl",
    kernelFunc: Mx
  };
  function vGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r, o = i.shape.length, l = Se(a, i.shape);
    let u = l;
    const c = wn(u, o);
    let h = i;
    c != null && (h = Jr({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: c
      }
    }), u = Rn(u.length, o)), wr("all", u, o);
    const [f, d] = hr(h.shape, u), p = lt(d), g = Tt({
      inputs: {
        x: h
      },
      backend: e,
      attrs: {
        shape: [
          -1,
          p
        ]
      }
    }), v = Dh(g, g.dtype, "all", e);
    let m;
    if (s) {
      const y = Bn(f, l);
      m = Tt({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          shape: y
        }
      });
    } else m = Tt({
      inputs: {
        x: v
      },
      backend: e,
      attrs: {
        shape: f
      }
    });
    return e.disposeIntermediateTensorInfo(g), e.disposeIntermediateTensorInfo(v), c != null && e.disposeIntermediateTensorInfo(h), m;
  }
  const mGt = {
    kernelName: ZE,
    backendName: "webgl",
    kernelFunc: vGt
  };
  function yGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r, o = i.shape.length, l = Se(a, i.shape);
    let u = l;
    const c = wn(u, o);
    let h = i;
    c != null && (h = Jr({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: c
      }
    }), u = Rn(u.length, o)), wr("any", u, o);
    const [f, d] = hr(h.shape, u), p = lt(d), g = Tt({
      inputs: {
        x: h
      },
      backend: e,
      attrs: {
        shape: [
          -1,
          p
        ]
      }
    }), v = Dh(g, g.dtype, "any", e);
    let m;
    if (s) {
      const y = Bn(f, l);
      m = Tt({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          shape: y
        }
      });
    } else m = Tt({
      inputs: {
        x: v
      },
      backend: e,
      attrs: {
        shape: f
      }
    });
    return e.disposeIntermediateTensorInfo(g), e.disposeIntermediateTensorInfo(v), c != null && e.disposeIntermediateTensorInfo(h), m;
  }
  const xGt = {
    kernelName: JE,
    backendName: "webgl",
    kernelFunc: yGt
  };
  class bGt {
    constructor(t, e, r) {
      this.variableNames = [
        "A"
      ];
      const { windowSize: i, batchSize: a, outSize: s } = t;
      r || this.variableNames.push("bestIndicesA"), this.outputShape = [
        a,
        s
      ];
      const o = e === "max" ? ">" : "<", l = r ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
  }
  class _Gt {
    constructor(t, e, r, i) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, B(t.length > 2, () => `Packed arg${r.charAt(0).toUpperCase() + r.slice(1)} supports only inputs with rank above 2.`);
      const a = t[t.length - 1], s = Math.ceil(a / e);
      this.outputShape = t.slice(0, -1), s > 1 && this.outputShape.push(s), i || this.variableNames.push("bestIndicesA");
      const o = this.outputShape, l = o.length, u = sn(l), c = Hr("coords", l);
      let h, f;
      if (s === 1) {
        f = l + 1;
        const I = sn(f);
        h = `
        ${I} sourceLocR = ${I}(${c.join()}, 0);
        ++${c[l - 1]};
        ${I} sourceLocG = ${I}(${c.join()}, 0);
        ++${c[l - 2]};
        ${I} sourceLocA = ${I}(${c.join()}, 0);
        --${c[l - 1]};
        ${I} sourceLocB = ${I}(${c.join()}, 0);
        --${c[l - 2]};`;
      } else f = l, h = `
        ${u} sourceLocR = coords;
        ++${c[l - 1]};
        ${u} sourceLocG = coords;
        ++${c[l - 2]};
        ${u} sourceLocA = coords;
        --${c[l - 1]};
        ${u} sourceLocB = coords;
        --${c[l - 2]};`;
      const d = [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
      ].slice(0, f), p = "." + d[f - 1], g = d.map((I) => "int " + I), v = Hr("sourceLocR", f - 1).concat("inIdx.r"), m = Hr("sourceLocG", f - 1).concat("inIdx.g"), y = Hr("sourceLocB", f - 1).concat("inIdx.b"), x = Hr("sourceLocA", f - 1).concat("inIdx.a"), b = r === "max" ? "greaterThan" : "lessThan", _ = i ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()})));`, w = `vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${m.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`, S = i ? "" : `
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;
      this.userCode = `
      float getAChannel(${g.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${S}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l - 1]} < ${o[l - 1] - 1};
        bool hasNextRow = ${c[l - 2]} < ${o[l - 2] - 1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
  }
  function rJ(n, t, e, r = null) {
    let i = t.shape[0], a = t.shape[1];
    r != null && (i = r.shape[0], a = r.shape[1]);
    const s = dw(a), o = {
      windowSize: s,
      inSize: a,
      batchSize: i,
      outSize: Math.ceil(a / s)
    }, l = new bGt(o, e, r == null), u = [
      t
    ];
    r != null && u.push(r);
    const c = n.runWebGLProgram(l, u, "int32");
    if (c.shape[1] === 1) return c;
    const h = rJ(n, t, e, c);
    return n.disposeIntermediateTensorInfo(c), h;
  }
  function iJ(n, t, e, r = null) {
    const i = r != null ? r.shape : t.shape, a = i[i.length - 1], s = dw(a), o = new _Gt(i, s, e, r == null), l = r == null ? [
      t
    ] : [
      t,
      r
    ], u = n.runWebGLProgram(o, l, "int32");
    if (u.shape.length === t.shape.length) {
      const c = iJ(n, t, e, u);
      return n.disposeIntermediateTensorInfo(u), c;
    }
    return u;
  }
  function aJ(n, t, e, r) {
    const i = [
      e
    ];
    if (wr("arg" + r.charAt(0).toUpperCase() + r.slice(1), i, t.shape.length), !nt().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
      const a = [], s = n.texData.get(t.dataId), o = s !== null && s.isPacked;
      let l = t;
      o && (l = n.unpackTensor(t), a.push(l));
      const [u, c] = hr(l.shape, i), h = lt(c), f = Tt({
        inputs: {
          x: l
        },
        backend: n,
        attrs: {
          shape: [
            -1,
            h
          ]
        }
      });
      a.push(f);
      const d = rJ(n, f, r);
      a.push(d);
      const p = Tt({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          shape: u
        }
      });
      return a.forEach((g) => n.disposeIntermediateTensorInfo(g)), p;
    }
    return iJ(n, t, r);
  }
  function wGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a } = r;
    let s = Se(a, i.shape);
    const o = wn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = Jr({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: o
      }
    }), u.push(l), s = Rn(s.length, l.shape.length)), wr("argMax", [
      s[0]
    ], l.shape.length);
    const c = aJ(e, l, s[0], "max");
    return u.forEach((h) => e.disposeIntermediateTensorInfo(h)), c;
  }
  const SGt = {
    kernelName: r_,
    backendName: "webgl",
    kernelFunc: wGt
  };
  function CGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a } = r;
    let s = Se(a, i.shape);
    const o = wn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = Jr({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: o
      }
    }), u.push(l), s = Rn(s.length, l.shape.length)), wr("argMin", [
      s[0]
    ], l.shape.length);
    const c = aJ(e, l, s[0], "min");
    return u.forEach((h) => e.disposeIntermediateTensorInfo(h)), c;
  }
  const TGt = {
    kernelName: i_,
    backendName: "webgl",
    kernelFunc: CGt
  };
  const IGt = La + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`, AGt = Be({
    opSnippet: IGt
  }), kGt = {
    kernelName: em,
    backendName: "webgl",
    kernelFunc: AGt
  };
  const DGt = La + "return log(x + sqrt(x * x + 1.0));", EGt = Be({
    opSnippet: DGt
  }), MGt = {
    kernelName: nm,
    backendName: "webgl",
    kernelFunc: EGt
  };
  const RGt = La + `
  return atan(x);
`, NGt = Be({
    opSnippet: RGt
  }), LGt = {
    kernelName: rm,
    backendName: "webgl",
    kernelFunc: NGt
  };
  const PGt = wN + `
  return atan(a, b);
`, $Gt = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + kh + `
  return result;
`, OGt = Sr({
    opSnippet: PGt,
    packedOpSnippet: $Gt
  }), FGt = {
    kernelName: am,
    backendName: "webgl",
    kernelFunc: OGt
  };
  const BGt = La + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`, zGt = Be({
    opSnippet: BGt
  }), VGt = {
    kernelName: im,
    backendName: "webgl",
    kernelFunc: zGt
  };
  class bv {
    constructor(t, e, r, i = false, a = false) {
      if (this.variableNames = [
        "x"
      ], e === "avg" && r) throw new Error("Cannot compute positions for average pool.");
      const s = t.filterWidth, o = t.strideHeight, l = t.strideWidth, u = t.dilationHeight, c = t.dilationWidth, h = t.effectiveFilterHeight, f = t.effectiveFilterWidth, d = t.padInfo.top, p = t.padInfo.left;
      this.outputShape = t.outShape;
      const g = e === "avg", v = `((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`, m = `(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;
      let y = "0.0";
      if (g || (y = "-1.0 / 1e-20"), r) {
        const I = ">=";
        this.userCode = `
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${d}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i ? a ? v : m : `wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const x = "max";
      let b = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      e === "avg" && (b = "avgValue / max(count, 1.0)");
      const _ = Math.floor(s / 4) * 4, w = s % 4, S = `
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${d}, ${p});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${S}
          }

          int xC = xCCorner + ${_};
          if (${w === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${w === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${w === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${S}
          }
        }
        setOutput(${b});
      }
    `;
    }
  }
  class CN {
    constructor(t, e, r, i = false, a = false) {
      if (this.variableNames = [
        "x"
      ], e === "avg" && r) throw new Error("Cannot compute positions for average pool.");
      const s = t.filterWidth, o = t.strideDepth, l = t.strideHeight, u = t.strideWidth, c = t.dilationDepth, h = t.dilationHeight, f = t.dilationWidth, d = t.effectiveFilterDepth, p = t.effectiveFilterHeight, g = t.effectiveFilterWidth, v = t.padInfo.front, m = t.padInfo.top, y = t.padInfo.left;
      this.outputShape = t.outShape;
      const x = e === "avg";
      let b = "0.0";
      if (x || (b = "-1.0 / 1e-20"), r) {
        const A = ">=";
        this.userCode = `
        const ivec3 strides =
            ivec3(${o}, ${l}, ${u});
        const ivec3 pads = ivec3(${v}, ${m}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i ? a ? `(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `wD * ${p} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const _ = "max";
      let w = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      e === "avg" && (w = "avgValue / max(count, 1.0)");
      const S = Math.floor(s / 4) * 4, I = s % 4, T = `
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec3 strides =
        ivec3(${o}, ${l}, ${u});
      const ivec3 pads = ivec3(${v}, ${m}, ${y});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${S}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${T}
            }

            int xC = xCCorner + ${S};
            if (${I === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${I === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${I === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${T}
            }
          }
        }
        setOutput(${w});
      }
    `;
    }
  }
  function GGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t;
    fy(i, "avgPool");
    const { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, u = 1;
    B(Rr(s, u), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = Ra(i.shape, a, s, u, o, l);
    if (c.filterWidth === 1 && c.filterHeight === 1 && Xe(c.inShape, c.outShape)) return Fi({
      inputs: {
        x: i
      },
      backend: e
    });
    const h = new bv(c, "avg", false);
    return e.runWebGLProgram(h, [
      i
    ], "float32");
  }
  const WGt = {
    kernelName: a_,
    backendName: "webgl",
    kernelFunc: GGt
  };
  function UGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { filterSize: a, strides: s, pad: o, dimRoundingMode: l, dataFormat: u } = r, c = [
      1,
      1,
      1
    ], h = rl(i.shape, a, s, c, o, l, u), f = new CN(h, "avg", false);
    return e.runWebGLProgram(f, [
      i
    ], "float32");
  }
  const HGt = {
    kernelName: s_,
    backendName: "webgl",
    kernelFunc: UGt
  };
  class XGt {
    constructor(t) {
      this.variableNames = [
        "dy"
      ], this.outputShape = t.inShape;
      const e = t.filterHeight, r = t.filterWidth, i = t.strideHeight, a = t.strideWidth, s = t.dilationHeight, o = t.dilationWidth, l = t.effectiveFilterHeight, u = t.effectiveFilterWidth, c = l - 1 - t.padInfo.top, h = u - 1 - t.padInfo.left, f = 1 / (e * r);
      this.userCode = `
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class YGt {
    constructor(t) {
      this.variableNames = [
        "dy"
      ], this.outputShape = t.inShape;
      const e = t.filterDepth, r = t.filterHeight, i = t.filterWidth, a = t.strideDepth, s = t.strideHeight, o = t.strideWidth, l = t.dilationDepth, u = t.dilationHeight, c = t.dilationWidth, h = t.effectiveFilterDepth, f = t.effectiveFilterHeight, d = t.effectiveFilterWidth, p = h - 1 - t.padInfo.front, g = f - 1 - t.padInfo.top, v = d - 1 - t.padInfo.left, m = 1 / (e * r * i);
      this.userCode = `
      const ivec3 pads = ivec3(${p}, ${g}, ${v});
      const float avgMultiplier = float(${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  function qGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, input: a } = t, s = a, { filterSize: o, strides: l, pad: u, dimRoundingMode: c } = r, h = [
      1,
      1,
      1
    ], f = rl(s.shape, o, l, h, u, c), d = new YGt(f);
    return e.runWebGLProgram(d, [
      i
    ], s.dtype);
  }
  const jGt = {
    kernelName: tM,
    backendName: "webgl",
    kernelFunc: qGt
  };
  function KGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, input: a } = t, s = a;
    fy([
      i,
      a
    ], "avgPoolGrad");
    const { filterSize: o, strides: l, pad: u } = r, c = Ra(s.shape, o, l, 1, u), h = new XGt(c);
    return e.runWebGLProgram(h, [
      i
    ], s.dtype);
  }
  const ZGt = {
    kernelName: QE,
    backendName: "webgl",
    kernelFunc: KGt
  };
  function JGt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { a: i, b: a } = t, { transposeA: s, transposeB: o } = r;
    return a1({
      a: i,
      b: a,
      transposeA: s,
      transposeB: o,
      backend: e
    });
  }
  const QGt = {
    kernelName: o_,
    backendName: "webgl",
    kernelFunc: JGt
  };
  class t4t {
    constructor(t, e, r, i, a, s) {
      this.outputShape = [], this.variableNames = [
        "x",
        "mean",
        "variance"
      ], ve(t, e), ve(t, r);
      let o = "0.0";
      i != null && (ve(t, i), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
      let l = "1.0";
      a != null && (ve(t, a), this.variableNames.push("scale"), l = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
  }
  class e4t {
    constructor(t, e, r, i, a, s) {
      this.packedInputs = true, this.packedOutput = true, this.variableNames = [
        "x",
        "mean",
        "variance"
      ], ve(t, e), ve(t, r);
      let o = "vec4(0.0)";
      i != null && (ve(t, i), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
      let l = "vec4(1.0)";
      a != null && (ve(t, a), this.variableNames.push("scale"), l = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = `
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
  }
  const n4t = ({ inputs: n, backend: t, attrs: e }) => {
    const { x: r, mean: i, variance: a, offset: s, scale: o } = n;
    B(i.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), B(s == null || i.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), B(o == null || i.shape.length === o.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let { varianceEpsilon: l } = e;
    l == null && (l = 1e-3);
    const u = [
      r,
      i,
      a
    ];
    let c = null;
    s != null && (c = s.shape, u.push(s));
    let h = null;
    o != null && (h = o.shape, u.push(o));
    const f = nt().getBool("WEBGL_PACK_NORMALIZATION") ? new e4t(r.shape, i.shape, a.shape, c, h, l) : new t4t(r.shape, i.shape, a.shape, c, h, l);
    return t.runWebGLProgram(f, u, u[0].dtype);
  }, r4t = {
    kernelName: x_,
    backendName: "webgl",
    kernelFunc: n4t
  };
  class i4t {
    constructor(t) {
      this.variableNames = [
        "source"
      ], this.outputShape = t, this.rank = t.length;
      const e = sn(this.rank);
      this.customUniforms = [
        {
          name: "start",
          arrayIndex: this.rank,
          type: "int"
        }
      ];
      const r = a4t(this.rank);
      let i;
      const a = t.map((s, o) => `sourceLoc.${X2[o]} = start[${o}] + coords.${X2[o]};`);
      i = `
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${a.join(`
`)}
      `, this.userCode = `
      void main() {
        ${i}
        setOutput(getSource(${r}));
      }
    `;
    }
  }
  const X2 = [
    "x",
    "y",
    "z",
    "w",
    "u",
    "v"
  ];
  function a4t(n) {
    if (n === 1) return "sourceLoc";
    if (n <= 6) return X2.slice(0, n).map((t) => "sourceLoc." + t).join(",");
    throw Error(`Slicing for rank ${n} is not yet supported`);
  }
  class s4t {
    constructor(t) {
      this.variableNames = [
        "source"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.rank = t.length, this.customUniforms = [
        {
          name: "start",
          arrayIndex: this.rank,
          type: "int"
        }
      ];
      const e = sn(this.rank), r = Hr("coords", this.rank), i = Hr("sourceLoc", this.rank), a = this.rank === 1 ? "sourceLoc" : `vec2(${i.slice(-2).join()})`, s = `getChannel(getSource(${i.join()}), ${a})`, o = `
      result.x = ${s};
      if (++${r[this.rank - 1]} < ${t[this.rank - 1]}) {
        ++${i[this.rank - 1]};
        result.y = ${s};
        --${i[this.rank - 1]};
      }
    `, l = this.rank === 1 ? "" : `
      --${r[this.rank - 1]};
      if (++${r[this.rank - 2]} < ${t[this.rank - 2]}) {
        ++${i[this.rank - 2]};
        result.z = ${s};
        if (++${r[this.rank - 1]} < ${t[this.rank - 1]}) {
          ++${i[this.rank - 1]};
          result.w = ${s};
        }
      }
    `, u = this.rank <= 4 ? `sourceLoc = coords +
            ${e}(${t.map((c, h) => `start[${h}]`).join()});` : t.map((c, h) => `${i[h]} = ${r[h]} + start[${h}];`).join(`
`);
      this.userCode = `
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `;
    }
  }
  function o4t(n, t, e, r) {
    const i = r.texData.get(n.dataId), a = r.makeTensorInfo(e, n.dtype), s = r.texData.get(a.dataId);
    Object.assign(s, i), s.refCount = 1, s.shape = e, s.dtype = n.dtype;
    let o = xR(t, Yt(n.shape));
    i.slice && (o += i.slice.flatOffset), s.slice = {
      flatOffset: o,
      origDataId: i.slice && i.slice.origDataId || n.dataId
    };
    const l = r.dataRefCount.get(s.slice.origDataId) || 1;
    return r.dataRefCount.set(s.slice.origDataId, l + 1), a;
  }
  function qd(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { begin: a, size: s } = r, [o, l] = fw(i, a, s);
    if (vR(i, o, l), lt(l) === 0) return e.makeTensorInfo(l, i.dtype, []);
    if (e.shouldExecuteOnCPU([
      i
    ]) || i.dtype === "string") {
      const h = e.texData.get(i.dataId), f = Qzt(h.values, o, l, i.shape, i.dtype);
      return e.makeTensorInfo(l, i.dtype, f);
    }
    const { isPacked: u } = e.texData.get(i.dataId), c = yR(i.shape, o, l);
    if (u || !c) {
      const h = nt().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new s4t(l) : new i4t(l), f = [
        o
      ];
      return e.runWebGLProgram(h, [
        i
      ], i.dtype, f);
    }
    return e.uploadToGPU(i.dataId), o4t(i, o, l, e);
  }
  const l4t = {
    kernelName: q_,
    backendName: "webgl",
    kernelFunc: qd
  };
  const u4t = (n) => {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { blockShape: a, crops: s } = r;
    B(i.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
    const o = a.reduce((y, x) => y * x), l = Qm(i.shape, a, o), u = ty(l.length, a.length), c = ey(i.shape, a, o), h = CR(s, a.length), f = TR(c, s, a.length), d = [], p = Tt({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: l
      }
    }), g = Jr({
      inputs: {
        x: p
      },
      backend: e,
      attrs: {
        perm: u
      }
    }), v = Tt({
      inputs: {
        x: g
      },
      backend: e,
      attrs: {
        shape: c
      }
    }), m = qd({
      inputs: {
        x: v
      },
      backend: e,
      attrs: {
        begin: h,
        size: f
      }
    });
    return d.push(p), d.push(g), d.push(v), d.forEach((y) => e.disposeIntermediateTensorInfo(y)), m;
  }, c4t = {
    kernelName: l_,
    backendName: "webgl",
    kernelFunc: u4t
  };
  function h4t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, weights: a } = t, { size: s } = r, o = e.readSync(i.dataId), l = e.readSync(a.dataId), u = XZ(o, l, a.dtype, a.shape, s);
    return e.makeTensorInfo([
      s
    ], a.dtype, u);
  }
  const f4t = {
    kernelName: eM,
    backendName: "webgl",
    kernelFunc: h4t
  };
  const d4t = `
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`, p4t = `
  return float(int(a.r) & int(b.r));
`;
  function g4t(n) {
    const { inputs: t, backend: e } = n, { a: r, b: i } = t, a = nt().getBool("WEBGL_PACK_BINARY_OPERATIONS"), s = nt().getNumber("WEBGL_VERSION");
    if (e.shouldExecuteOnCPU([
      r,
      i
    ]) || s === 1) {
      const l = e.texData.get(r.dataId).values, u = e.texData.get(i.dataId).values, [c, h] = Szt(r.shape, i.shape, l, u, r.dtype), f = e.makeTensorInfo(h, r.dtype), d = e.texData.get(f.dataId);
      return d.values = c, f;
    }
    let o;
    return a ? o = new Xd(d4t, r.shape, i.shape, false) : o = new uh(p4t, r.shape, i.shape), e.runWebGLProgram(o, [
      r,
      i
    ], r.dtype);
  }
  const v4t = {
    kernelName: nM,
    backendName: "webgl",
    kernelFunc: g4t
  };
  function m4t(n) {
    const { inputs: t, backend: e } = n, { s0: r, s1: i } = t, a = e.readSync(r.dataId), s = e.readSync(i.dataId), o = ve(Array.from(a), Array.from(s));
    return e.makeTensorInfo([
      o.length
    ], "int32", Int32Array.from(o));
  }
  const y4t = {
    kernelName: JY,
    backendName: "webgl",
    kernelFunc: m4t
  };
  const x4t = "return float(a != b);", sJ = Sr({
    opSnippet: x4t,
    cpuKernelImpl: Uzt,
    dtype: "bool"
  }), b4t = {
    kernelName: $_,
    backendName: "webgl",
    kernelFunc: sJ
  };
  function py(n) {
    const { inputs: t, backend: e } = n, { input: r } = t, i = e.texData.get(r.dataId);
    return Fi({
      inputs: {
        x: i.complexTensorInfos.real
      },
      backend: e
    });
  }
  const _4t = {
    kernelName: AM,
    backendName: "webgl",
    kernelFunc: py
  };
  const w4t = "return float(int(x));";
  function S4t(n, t) {
    const e = new Gs(n.shape, w4t), r = t.runWebGLProgram(e, [
      n
    ], "int32");
    return {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  function Y2(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { dtype: a } = r;
    if (a === "complex64") {
      if (i.dtype === "complex64") return Fi({
        inputs: {
          x: i
        },
        backend: e
      });
      const s = rr(i.shape), o = Y2({
        inputs: {
          x: i
        },
        backend: e,
        attrs: {
          dtype: "float32"
        }
      }), l = mu({
        inputs: {
          real: o,
          imag: s
        },
        backend: e
      });
      return s.dispose(), e.disposeIntermediateTensorInfo(o), l;
    }
    if (i.dtype === "complex64") {
      const s = py({
        inputs: {
          input: i
        },
        backend: e
      }), o = Y2({
        inputs: {
          x: s
        },
        backend: e,
        attrs: {
          dtype: a
        }
      });
      return e.disposeIntermediateTensorInfo(s), o;
    }
    if (!YY(i.dtype, a)) {
      const s = Fi({
        inputs: {
          x: i
        },
        backend: e
      });
      return {
        dataId: s.dataId,
        shape: s.shape,
        dtype: a
      };
    }
    if (e.shouldExecuteOnCPU([
      i
    ])) {
      const s = e.texData.get(i.dataId).values, [o, l, u] = Czt(s, i.shape, i.dtype, a);
      return e.makeTensorInfo(o, l, u);
    }
    if (a === "int32") return S4t(i, e);
    if (a === "bool") {
      const s = e.makeTensorInfo([], "bool", Dr("bool", 1)), l = sJ({
        inputs: {
          a: i,
          b: s
        },
        backend: e
      });
      return e.disposeIntermediateTensorInfo(s), l;
    }
    throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`);
  }
  const C4t = {
    kernelName: sm,
    backendName: "webgl",
    kernelFunc: Y2
  };
  const rG = "return ceil(x);", T4t = Be({
    opSnippet: rG,
    packedOpSnippet: rG,
    cpuKernelImpl: Tzt
  }), I4t = {
    kernelName: om,
    backendName: "webgl",
    kernelFunc: T4t
  };
  class A4t {
    constructor(t) {
      this.variableNames = [
        "A"
      ], this.customUniforms = [
        {
          name: "minVal",
          type: "float"
        },
        {
          name: "maxVal",
          type: "float"
        }
      ], this.outputShape = t, this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
  }
  class k4t {
    constructor(t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "minVal",
          type: "float"
        },
        {
          name: "maxVal",
          type: "float"
        }
      ], this.outputShape = t, this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
  }
  function D4t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { clipValueMin: a, clipValueMax: s } = r;
    let o;
    nt().getBool("WEBGL_PACK_CLIP") ? o = new k4t(i.shape) : o = new A4t(i.shape);
    const l = [
      [
        a
      ],
      [
        s
      ]
    ];
    return e.runWebGLProgram(o, [
      i
    ], i.dtype, l);
  }
  const E4t = {
    kernelName: lm,
    backendName: "webgl",
    kernelFunc: D4t
  };
  class M4t {
    constructor(t) {
      this.variableNames = [
        "real",
        "imag"
      ], this.outputShape = t, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
  }
  function iG(n, t) {
    return {
      dataId: t.dataId,
      dtype: t.dtype,
      shape: n.shape
    };
  }
  function R4t(n) {
    const { inputs: t, backend: e } = n, { x: r } = t, i = e.texData.get(r.dataId), a = new M4t(r.shape), s = [
      iG(r, i.complexTensorInfos.real),
      iG(r, i.complexTensorInfos.imag)
    ];
    return e.runWebGLProgram(a, s, s[0].dtype);
  }
  const N4t = {
    kernelName: u_,
    backendName: "webgl",
    kernelFunc: R4t
  };
  class L4t {
    constructor(t) {
      this.outputShape = [], this.outputShape = js(t, 1), this.variableNames = t.map((s, o) => `T${o}`);
      const e = new Array(t.length - 1);
      e[0] = t[0][1];
      for (let s = 1; s < e.length; s++) e[s] = e[s - 1] + t[s][1];
      const r = [
        `if (yC < ${e[0]}) setOutput(getT0(yR, yC));`
      ];
      for (let s = 1; s < e.length; s++) {
        const o = e[s - 1];
        r.push(`else if (yC < ${e[s]}) setOutput(getT${s}(yR, yC-${o}));`);
      }
      const i = e.length, a = e[e.length - 1];
      r.push(`else setOutput(getT${i}(yR, yC-${a}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `;
    }
  }
  class P4t {
    constructor(t, e) {
      this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = js(t, e);
      const r = this.outputShape, i = r.length, a = sn(i), s = Hr("coords", i), o = [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
      ].slice(0, i);
      this.variableNames = t.map((g, v) => `T${v}`);
      const l = new Array(t.length - 1);
      l[0] = t[0][e];
      for (let g = 1; g < l.length; g++) l[g] = l[g - 1] + t[g][e];
      const u = o[e], c = o.slice(-2), h = o.join();
      let f = `if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;
      for (let g = 1; g < l.length; g++) {
        const v = l[g - 1];
        f += `
        if (${u} < ${l[g]}  && ${u} >= ${l[g - 1]}) {
          return getChannel(
            getT${g}(${L0(o, u, v)}),
            vec2(${L0(c, u, v)}));
        }`;
      }
      const d = l.length, p = l[l.length - 1];
      f += `
        return getChannel(
          getT${d}(${L0(o, u, p)}),
          vec2(${L0(c, u, p)}));`, this.userCode = `
      float getValue(${o.map((g) => "int " + g)}) {
        ${f}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[i - 1]} = ${s[i - 1]} + 1;
        if (${s[i - 1]} < ${r[i - 1]}) {
          result.g = getValue(${s});
        }

        ${s[i - 2]} = ${s[i - 2]} + 1;
        if (${s[i - 2]} < ${r[i - 2]}) {
          result.a = getValue(${s});
        }

        ${s[i - 1]} = ${s[i - 1]} - 1;
        if (${s[i - 2]} < ${r[i - 2]} &&
            ${s[i - 1]} < ${r[i - 1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `;
    }
  }
  function L0(n, t, e) {
    const r = n.indexOf(t);
    return n.map((a, s) => s === r ? `${a} - ${e}` : a).join();
  }
  function Rw(n) {
    const { inputs: t, backend: e } = n, { input: r } = t, i = e.texData.get(r.dataId);
    return Fi({
      inputs: {
        x: i.complexTensorInfos.imag
      },
      backend: e
    });
  }
  const $4t = {
    kernelName: xM,
    backendName: "webgl",
    kernelFunc: Rw
  };
  function eg(n, t, e) {
    const r = n[0].dtype;
    if (r === "complex64") {
      const d = n.map((y) => py({
        inputs: {
          input: y
        },
        backend: e
      })), p = n.map((y) => Rw({
        inputs: {
          input: y
        },
        backend: e
      })), g = eg(d, t, e), v = eg(p, t, e), m = mu({
        inputs: {
          real: g,
          imag: v
        },
        backend: e
      });
      return d.forEach((y) => e.disposeIntermediateTensorInfo(y)), p.forEach((y) => e.disposeIntermediateTensorInfo(y)), e.disposeIntermediateTensorInfo(g), e.disposeIntermediateTensorInfo(v), m;
    }
    let i = e.shouldExecuteOnCPU(n);
    if (r === "string" && (i = true), i) {
      const d = n.map((b) => {
        const w = [
          -1,
          lt(b.shape.slice(t))
        ];
        return Tt({
          inputs: {
            x: b
          },
          backend: e,
          attrs: {
            shape: w
          }
        });
      }), p = d.map((b) => ({
        vals: e.readSync(b.dataId),
        shape: b.shape
      })), g = js(d.map((b) => b.shape), 1), v = d[0].shape[0] === 1, m = Izt(p, g, r, v), y = js(n.map((b) => b.shape), t), x = e.makeTensorInfo(y, r, m);
      return d.forEach((b) => e.disposeIntermediateTensorInfo(b)), x;
    }
    const a = n.filter((d) => lt(d.shape) > 0), s = nt().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && a[0].shape.length > 1;
    if (a.length === 1) {
      const d = s ? new Gs(n[0].shape, wl) : new Ll(n[0].shape, wl);
      return e.runWebGLProgram(d, n, r);
    }
    const o = nt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
    if (a.length > o) {
      const d = [];
      for (let g = 0; g < a.length; g += o) {
        const v = a.slice(g, g + o);
        d.push(eg(v, t, e));
      }
      const p = eg(d, t, e);
      for (const g of d) e.disposeIntermediateTensorInfo(g);
      return p;
    }
    if (s) {
      const d = new P4t(a.map((p) => p.shape), t);
      return e.runWebGLProgram(d, a, r);
    }
    const { tensors2D: l, outShape: u } = O4t(a, t, e), c = new L4t(l.map((d) => d.shape)), h = e.runWebGLProgram(c, l, r);
    l.forEach((d) => e.disposeIntermediateTensorInfo(d));
    const f = Tt({
      inputs: {
        x: h
      },
      attrs: {
        shape: u
      },
      backend: e
    });
    return e.disposeIntermediateTensorInfo(h), f;
  }
  function O4t(n, t, e) {
    const r = js(n.map((a) => a.shape), t);
    return {
      tensors2D: n.map((a) => Tt({
        inputs: {
          x: a
        },
        attrs: {
          shape: [
            -1,
            lt(a.shape.slice(t))
          ]
        },
        backend: e
      })),
      outShape: r
    };
  }
  function oJ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { axis: i } = r, a = Se(i, t[0].shape)[0], s = t.map((u) => u.shape);
    _R(s, a);
    const o = js(t.map((u) => u.shape), a);
    if (lt(o) === 0) return e.makeTensorInfo(o, t[0].dtype, []);
    const l = t.filter((u) => lt(u.shape) > 0);
    return l.length === 1 ? Fi({
      inputs: {
        x: l[0]
      },
      backend: e
    }) : eg(l, a, e);
  }
  const F4t = {
    kernelName: c_,
    backendName: "webgl",
    kernelFunc: oJ
  };
  class lJ {
    constructor(t, e = false, r = null, i = false, a = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.outputShape = t.outShape;
      const s = t.padInfo.top, o = t.padInfo.left, l = t.strideHeight, u = t.strideWidth, c = t.dilationHeight, h = t.dilationWidth, f = t.filterHeight, d = t.filterWidth, p = Math.floor(t.inChannels / 4) * 4, g = t.inChannels % 4, v = t.dataFormat === "channelsLast", m = v ? 1 : 2, y = v ? 2 : 3, x = v ? 3 : 1;
      let b = "", _ = "";
      r && (i ? b = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : a ? b = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : b = `
          float activation(float x) {
            ${r}
          }
        `, _ = "result = activation(result);");
      const w = e ? "result += getBiasAtOutCoords();" : "";
      e && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${b}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${m}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g === 1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${g === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${_}
        setOutput(result);
      }
    `;
    }
  }
  class B4t {
    constructor(t) {
      this.variableNames = [
        "x",
        "W"
      ], this.outputShape = t.outShape;
      const e = t.padInfo.front, r = t.padInfo.top, i = t.padInfo.left, a = t.strideDepth, s = t.strideHeight, o = t.strideWidth, l = t.dilationDepth, u = t.dilationHeight, c = t.dilationWidth, h = t.filterDepth, f = t.filterHeight, d = t.filterWidth, p = Math.floor(t.inChannels / 4) * 4, g = t.inChannels % 4;
      this.userCode = `
      const ivec3 strides = ivec3(${a}, ${s}, ${o});
      const ivec3 pads = ivec3(${e}, ${r}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${g === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class uJ {
    constructor(t, e = false, r = null, i = false, a = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "pads",
          type: "ivec2"
        },
        {
          name: "strides",
          type: "ivec2"
        },
        {
          name: "dilations",
          type: "ivec2"
        },
        {
          name: "inDims",
          type: "ivec2"
        }
      ], this.outputShape = t.outShape, this.enableShapeUniforms = Lr(this.outputShape.length);
      const s = t.padInfo.left, o = t.strideWidth, l = t.dilationWidth, u = t.filterHeight, c = t.filterWidth, h = c;
      let f = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
      for (let v = 0; v < c; v++) f += `
           vec4 xTexelC${v * 2};
           int xTexelC${v * 2}Ready;
           vec4 xTexelC${v * 2 + 1};
           int xTexelC${v * 2 + 1}Ready;
           vec4 xC${v};`;
      f += `
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;
      for (let v = 0; v < c; v++) f += `
           xTexelC${v * 2} = vec4(0.0);
           xTexelC${v * 2}Ready = 0;
           xTexelC${v * 2 + 1} = vec4(0.0);
           xTexelC${v * 2 + 1}Ready = 0;
           xC${v} = vec4(0.0);`;
      f += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
      for (let v = 0; v < (h + 1) / 2; v++) {
        const m = v * 2;
        if (f += `
           xC = xCCorner + ${m * l};
           `, o === 1) {
          if (m < c && (s % 2 === 1 ? (f += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }
               `, l === 1 && m > 0 ? f += `
                 xC${m} = vec4(xTexelC${m - 2}.zw, xTexelC${m}.xy);
                 ` : f += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${m} = vec4(previous.zw, xTexelC${m}.xy);
                   } else {
                     xC${m} = vec4(0.0, 0.0, xTexelC${m}.xy);
                   }
                   `) : f += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xC${m} = xTexelC${m};
                 `, m + 1 < c)) {
            const y = s % 2 === 0 ? HE(l) : l;
            l % 2 === 0 && s % 2 === 1 || l % 2 !== 0 && s % 2 !== 1 ? (f += `
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m + 1}Ready == 0) {
                     xTexelC${m + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${m + 1}.zw = vec2(0.0);
                     }
                     xTexelC${m + 1}Ready = 1;
                   }
                   `, l > 1 ? f += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${m + 1} = vec4(previous.zw, xTexelC${m + 1}.xy);
                     } else {
                      xC${m + 1} = vec4(0.0, 0.0, xTexelC${m + 1}.xy);
                     }
                     ` : f += `
                     xC${m + 1} = vec4(xTexelC${m}.zw, xTexelC${m + 1}.xy);
                     `) : y === 1 ? f += `
                     xC${m + 1} = xTexelC${m};
                     ` : f += `
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m + 1}Ready == 0) {
                       xTexelC${m + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${m + 1}.zw = vec2(0.0);
                       }
                       xTexelC${m + 1}Ready = 1;
                     }

                     xC${m + 1} = xTexelC${m + 1};
                     `;
          }
        } else m < c && (s % 2 === 1 ? (f += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${m + 1}Ready == 0) {
                   xTexelC${m + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${m + 1}.zw = vec2(0.0);
                   }
                   xTexelC${m + 1}Ready = 1;
                 }

                 xC${m} = vec4(xTexelC${m}.zw, xTexelC${m + 1}.zw);
               `, m + 1 < c && (f += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${m + 1} = vec4(xTexelC${m + 1}.xy, final.xy);
                 `)) : (f += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m + 1}Ready == 0) {
                   xTexelC${m + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m + 1}.zw = vec2(0.);
                   }
                   xTexelC${m + 1}Ready = 1;
                 }

                 xC${m} = vec4(
                   xTexelC${m}.xy, xTexelC${m + 1}.xy);
               `, m + 1 < c && (f += `
                   xC${m + 1} = vec4(xTexelC${m}.zw, xTexelC${m + 1}.zw);
                 `)));
        m < c && (f += `
             wTexel = getW(r, ${m}, d1, d2);
             dotProd += xC${m}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${m}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `, m + 1 < c && (f += `
               wTexel = getW(r, ${m + 1}, d1, d2);
               dotProd += xC${m + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${m + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `));
      }
      f += `
     }
   `, f += `
     }
   `, f += `
     }
   `;
      let d = "", p = "";
      r && (i ? d = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }` : a ? d = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }` : d = `vec4 activation(vec4 x) {
           ${r}
         }`, p = "result = activation(result);");
      const g = e ? "result += getBiasAtOutCoords();" : "";
      e && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = `
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${p}
         setOutput(result);
       }
     `;
    }
  }
  class z4t {
    constructor(t, e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "inputShape",
          type: "ivec4"
        },
        {
          name: "pad",
          type: "ivec2"
        },
        {
          name: "stride",
          type: "ivec2"
        },
        {
          name: "dilation",
          type: "ivec2"
        },
        {
          name: "inChannels",
          type: "int"
        },
        {
          name: "itemsPerBlockRow",
          type: "int"
        },
        {
          name: "outWidth",
          type: "int"
        }
      ], this.outputShape = t, this.enableShapeUniforms = Lr(this.outputShape.length);
      const { dataFormat: r } = e, i = ti(), a = r === "channelsLast", s = a ? 1 : 2, o = a ? 2 : 3, l = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;
      let u = "";
      for (let c = 0; c <= 1; c++) for (let h = 0; h <= 1; h++) u += `
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c * 2 + h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c * 2 + h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
      this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${i.output} = result;
      }
    `;
    }
  }
  function s1(n, t) {
    const e = n.length;
    return e >= 3 ? t ? [
      ...n.slice(0, -3),
      n[e - 3] * n[e - 2],
      n[e - 1]
    ] : [
      ...n.slice(0, -3),
      n[e - 3],
      n[e - 2] * n[e - 1]
    ] : !t && e === 1 && n[0] > 1 ? [
      n[0],
      1
    ] : null;
  }
  function cJ({ x: n, filter: t, convInfo: e, backend: r, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: s = 0, activation: o = null }) {
    const l = n.shape, u = r.texData.get(n.dataId), c = e.inChannels, h = l[0] * l[1] * l[2], f = e.outChannels, d = e.dataFormat === "channelsLast", p = false, g = false;
    let v;
    const m = [];
    if (a != null) {
      const b = s1(a.shape, d);
      b != null && (a = Tt({
        inputs: {
          x: a
        },
        backend: r,
        attrs: {
          shape: b
        }
      }), m.push(a));
    }
    if (i != null) {
      const b = s1(i.shape, d);
      b != null && (i = Tt({
        inputs: {
          x: i
        },
        backend: r,
        attrs: {
          shape: b
        }
      }), m.push(i));
    }
    if (!((h === 1 || f === 1) && c > nJ) && u.isPacked && d && u.texture != null && l[2] % 2 !== 0 && Xe(u.shape.slice(-3), l.slice(-3))) {
      const b = l[0] * l[1] * (l[2] + 1), _ = {
        dataId: n.dataId,
        shape: [
          1,
          b,
          e.inChannels
        ],
        dtype: n.dtype
      }, w = u.shape;
      u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, B(i1(u.shape, _.shape), () => `packed reshape ${u.shape} to ${_.shape} isn't free`);
      const S = Tt({
        inputs: {
          x: t
        },
        backend: r,
        attrs: {
          shape: [
            1,
            e.inChannels,
            e.outChannels
          ]
        }
      });
      m.push(S);
      const I = a1({
        a: _,
        b: S,
        backend: r,
        transposeA: p,
        transposeB: g,
        bias: i,
        activation: o,
        preluActivationWeights: a,
        leakyreluAlpha: s
      }), T = r.texData.get(I.dataId);
      B(T.isPacked, () => "batchMatMul result is expected to be packed"), u.shape = w, T.shape = e.outShape, v = Fi({
        inputs: {
          x: I
        },
        backend: r
      }), v.shape = e.outShape, m.push(I);
    } else {
      const b = e.outHeight * e.outWidth, _ = Tt({
        inputs: {
          x: n
        },
        backend: r,
        attrs: {
          shape: d ? [
            e.batchSize,
            b,
            e.inChannels
          ] : [
            e.batchSize,
            e.inChannels,
            b
          ]
        }
      }), w = Tt({
        inputs: {
          x: t
        },
        backend: r,
        attrs: {
          shape: [
            1,
            e.inChannels,
            e.outChannels
          ]
        }
      }), S = a1({
        a: d ? _ : w,
        b: d ? w : _,
        transposeA: !d,
        transposeB: g,
        backend: r,
        bias: i,
        activation: o,
        preluActivationWeights: a,
        leakyreluAlpha: s
      });
      v = Tt({
        inputs: {
          x: S
        },
        backend: r,
        attrs: {
          shape: e.outShape
        }
      }), m.push(_), m.push(w), m.push(S);
    }
    for (const b of m) r.disposeIntermediateTensorInfo(b);
    return v;
  }
  function hJ({ x: n, filter: t, convInfo: e, backend: r, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: s = 0, activation: o = null }) {
    const { filterWidth: l, filterHeight: u, inChannels: c, outWidth: h, outHeight: f, dataFormat: d } = e, p = d === "channelsLast", g = l * u * c, v = f * h, m = [
      e.batchSize,
      g,
      v
    ], y = true, x = false, b = [];
    if (a != null) {
      const R = s1(a.shape, p);
      R != null && (a = Tt({
        inputs: {
          x: a
        },
        backend: r,
        attrs: {
          shape: R
        }
      }), b.push(a));
    }
    if (i != null) {
      const R = s1(i.shape, p);
      R != null && (i = Tt({
        inputs: {
          x: i
        },
        backend: r,
        attrs: {
          shape: R
        }
      }), b.push(i));
    }
    const _ = Tt({
      inputs: {
        x: t
      },
      backend: r,
      attrs: {
        shape: [
          1,
          g,
          lt(t.shape) / g
        ]
      }
    });
    b.push(_);
    const w = new z4t(m, e), S = [
      n.shape,
      [
        e.padInfo.top,
        e.padInfo.left
      ],
      [
        e.strideHeight,
        e.strideWidth
      ],
      [
        e.dilationHeight,
        e.dilationWidth
      ],
      [
        e.inChannels
      ],
      [
        e.filterWidth * e.inChannels
      ],
      [
        e.outWidth
      ]
    ], I = r.runWebGLProgram(w, [
      n
    ], "float32", S), T = Tt({
      inputs: {
        x: I
      },
      backend: r,
      attrs: {
        shape: m
      }
    });
    b.push(I), b.push(T);
    const A = i != null, C = a != null, D = o === "leakyrelu", E = o ? xv(o, true) : null, M = new eJ(p ? T.shape : _.shape, p ? _.shape : T.shape, p ? [
      e.batchSize,
      v,
      e.outChannels
    ] : [
      e.batchSize,
      e.outChannels,
      v
    ], y, x, A, E, C, D), L = p ? [
      T,
      _
    ] : [
      _,
      T
    ];
    if (i && L.push(i), C && L.push(a), D) {
      const R = r.makeTensorInfo([], "float32", uu(s, "float32"));
      L.push(R), b.push(R);
    }
    const k = r.runWebGLProgram(M, L, "float32"), N = Tt({
      inputs: {
        x: k
      },
      backend: r,
      attrs: {
        shape: e.outShape
      }
    });
    b.push(k);
    for (const R of b) r.disposeIntermediateTensorInfo(R);
    return N;
  }
  function V4t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a } = t, { strides: s, pad: o, dataFormat: l, dilations: u, dimRoundingMode: c } = r, h = il(l), f = _r(i.shape, a.shape, s, u, o, c, false, h);
    let d;
    if (f.filterHeight === 1 && f.filterWidth === 1 && f.dilationHeight === 1 && f.dilationWidth === 1 && f.strideHeight === 1 && f.strideWidth === 1 && (f.padInfo.type === "SAME" || f.padInfo.type === "VALID")) d = cJ({
      x: i,
      filter: a,
      convInfo: f,
      backend: e
    });
    else if (f.strideWidth <= 2 && h === "channelsLast" && nt().getBool("WEBGL_EXP_CONV")) {
      const g = new uJ(f), v = [
        [
          f.padInfo.top,
          f.padInfo.left
        ],
        [
          f.strideHeight,
          f.strideWidth
        ],
        [
          f.dilationHeight,
          f.dilationWidth
        ],
        [
          f.inHeight,
          f.inWidth
        ]
      ];
      d = e.runWebGLProgram(g, [
        i,
        a
      ], "float32", v);
    } else if (nt().getBool("WEBGL_CONV_IM2COL")) d = hJ({
      x: i,
      filter: a,
      convInfo: f,
      backend: e
    });
    else {
      const g = new lJ(f);
      d = e.runWebGLProgram(g, [
        i,
        a
      ], "float32");
    }
    const p = Tt({
      inputs: {
        x: d
      },
      backend: e,
      attrs: {
        shape: f.outShape
      }
    });
    return e.disposeIntermediateTensorInfo(d), p;
  }
  const G4t = {
    kernelName: h_,
    backendName: "webgl",
    kernelFunc: V4t
  };
  class W4t {
    constructor(t) {
      this.variableNames = [
        "x",
        "dy"
      ], this.outputShape = t.filterShape;
      const e = t.strideHeight, r = t.strideWidth, i = t.padInfo.top, a = t.padInfo.left, s = t.dataFormat === "channelsLast";
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${i};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${s ? `float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);` : `float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class U4t {
    constructor(t) {
      this.variableNames = [
        "dy",
        "W"
      ], this.outputShape = t.inShape;
      const e = t.filterHeight, r = t.filterWidth, i = t.strideHeight, a = t.strideWidth, s = t.dataFormat === "channelsLast", o = e - 1 - t.padInfo.top, l = r - 1 - t.padInfo.left, u = s ? 1 : 2, c = s ? 2 : 3, h = s ? 3 : 1;
      this.userCode = `
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class H4t {
    constructor(t) {
      this.variableNames = [
        "x",
        "dy"
      ], this.outputShape = t.filterShape;
      const e = t.strideDepth, r = t.strideHeight, i = t.strideWidth, a = t.padInfo.front, s = t.padInfo.top, o = t.padInfo.left;
      this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${a};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${s};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${o};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class X4t {
    constructor(t) {
      this.variableNames = [
        "dy",
        "W"
      ], this.outputShape = t.inShape;
      const e = t.filterDepth, r = t.filterHeight, i = t.filterWidth, a = t.strideDepth, s = t.strideHeight, o = t.strideWidth, l = e - 1 - t.padInfo.front, u = r - 1 - t.padInfo.top, c = i - 1 - t.padInfo.left;
      this.userCode = `
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  function Y4t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, dy: a } = t, { strides: s, pad: o, dataFormat: l, dimRoundingMode: u, filterShape: c } = r, h = il(l), f = _r(i.shape, c, s, 1, o, u, false, h), d = new W4t(f);
    return e.runWebGLProgram(d, [
      i,
      a
    ], "float32");
  }
  const q4t = {
    kernelName: iM,
    backendName: "webgl",
    kernelFunc: Y4t
  };
  class j4t {
    constructor(t) {
      this.variableNames = [
        "dy",
        "W"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "strides",
          type: "vec2"
        }
      ], this.outputShape = t.inShape, this.enableShapeUniforms = Lr(this.outputShape.length);
      const e = t.filterHeight, r = t.filterWidth, i = e - 1 - t.padInfo.top, a = r - 1 - t.padInfo.left;
      this.userCode = `
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
    }
  }
  function K4t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, filter: a } = t, { inputShape: s, strides: o, pad: l, dataFormat: u, dimRoundingMode: c } = r, h = il(u), f = _r(s, a.shape, o, 1, l, c, false, h);
    if (nt().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && h === "channelsLast") {
      const d = [
        [
          f.strideHeight,
          f.strideWidth
        ]
      ], p = new j4t(f);
      return e.runWebGLProgram(p, [
        i,
        a
      ], "float32", d);
    } else {
      const d = new U4t(f);
      return e.runWebGLProgram(d, [
        i,
        a
      ], "float32");
    }
  }
  const Z4t = {
    kernelName: f_,
    backendName: "webgl",
    kernelFunc: K4t
  };
  function J4t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a } = t, { strides: s, pad: o, dilations: l } = r, u = cu(i.shape, a.shape, s, l, o), c = new B4t(u);
    return e.runWebGLProgram(c, [
      i,
      a
    ], "float32");
  }
  const Q4t = {
    kernelName: d_,
    backendName: "webgl",
    kernelFunc: J4t
  };
  function tWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, dy: a } = t, { strides: s, pad: o, filterShape: l } = r, u = cu(i.shape, l, s, 1, o), c = new H4t(u);
    return e.runWebGLProgram(c, [
      i,
      a
    ], "float32");
  }
  const eWt = {
    kernelName: aM,
    backendName: "webgl",
    kernelFunc: tWt
  };
  function nWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, filter: a } = t, { pad: s, strides: o, inputShape: l } = r, u = cu(l, a.shape, o, 1, s), c = new X4t(u);
    return e.runWebGLProgram(c, [
      i,
      a
    ], "float32");
  }
  const rWt = {
    kernelName: sM,
    backendName: "webgl",
    kernelFunc: nWt
  };
  const iWt = Yd + `
  return cos(x);
`, aWt = `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${kh}
  return result;
`, sWt = Be({
    opSnippet: iWt,
    packedOpSnippet: aWt
  }), oWt = {
    kernelName: um,
    backendName: "webgl",
    kernelFunc: sWt
  };
  const lWt = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`, uWt = Be({
    opSnippet: lWt
  }), cWt = {
    kernelName: cm,
    backendName: "webgl",
    kernelFunc: uWt
  };
  class hWt {
    constructor(t, e, r, i, a) {
      this.variableNames = [
        "Image",
        "Boxes",
        "BoxInd"
      ], this.outputShape = [];
      const [s, o, l, u] = t, [c] = e, [h, f] = r;
      this.outputShape = [
        c,
        h,
        f,
        u
      ];
      const d = i === "bilinear" ? 1 : 0, [p, g] = [
        `${o - 1}.0`,
        `${l - 1}.0`
      ], [v, m, y] = h > 1 ? [
        `${(o - 1) / (h - 1)}`,
        "(y2-y1) * height_ratio",
        `y1*${p} + float(y)*(height_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (y1+y2) * ${p}`
      ], [x, b, _] = f > 1 ? [
        `${(l - 1) / (f - 1)}`,
        "(x2-x1) * width_ratio",
        `x1*${g} + float(x)*(width_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (x1+x2) * ${g}`
      ];
      this.userCode = `
      const float height_ratio = float(${v});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${m};
        float width_scale = ${b};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
  }
  const fWt = (n) => {
    const { inputs: t, backend: e, attrs: r } = n, { image: i, boxes: a, boxInd: s } = t, { cropSize: o, method: l, extrapolationValue: u } = r, c = new hWt(i.shape, a.shape, o, l, u);
    return e.runWebGLProgram(c, [
      i,
      a,
      s
    ], "float32");
  }, dWt = {
    kernelName: lM,
    backendName: "webgl",
    kernelFunc: fWt
  };
  var _v;
  (function(n) {
    n.Prod = "*", n.Sum = "+";
  })(_v || (_v = {}));
  class aG {
    constructor(t, e, r, i) {
      this.op = t, this.outputShape = e, this.variableNames = [
        "x"
      ], this.customUniforms = [
        {
          name: "index",
          type: "float"
        }
      ];
      const a = this.outputShape.length, s = this.op === _v.Prod ? "1.0" : "0.0", o = r ? s : `getX(${sG(a, "coords", this.op)})`, l = this.outputShape[this.outputShape.length - 1];
      let u = "", c = "";
      r ? (u = i ? `end != ${l - 1}` : "end != 0", c = i ? "end + 1" : "end - 1") : (u = i ? `end + pow2 < ${l}` : "end >= pow2", c = i ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${sn(a)} coords = getOutputCoords();
        int end = ${oG(a, "coords", this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${oG(a, "coords", this.op)} = idx;
          val ${this.op}= getX(${sG(a, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
    }
  }
  function sG(n, t, e) {
    if (n === 1) return `${t}`;
    if (n === 2) return `${t}.x, ${t}.y`;
    if (n === 3) return `${t}.x, ${t}.y, ${t}.z`;
    if (n === 4) return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
    throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`);
  }
  function oG(n, t, e) {
    if (n === 1) return `${t}`;
    if (n === 2) return `${t}.y`;
    if (n === 3) return `${t}.z`;
    if (n === 4) return `${t}.w`;
    throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`);
  }
  function fJ(n, t, e, r, i, a) {
    const s = t.shape.length, o = wn([
      r
    ], s);
    let l = t;
    o != null && (l = Jr({
      inputs: {
        x: t
      },
      backend: e,
      attrs: {
        perm: o
      }
    }));
    const u = Rn(1, s)[0];
    if (u !== s - 1) throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length - 1} but got axis=${r}`);
    const c = l.shape[u];
    let h = Fi({
      inputs: {
        x: l
      },
      backend: e
    });
    for (let f = 0; f <= Math.ceil(Math.log2(c)) - 1; f++) {
      const d = new aG(n, l.shape, false, a), p = [
        [
          f
        ]
      ], g = h;
      h = e.runWebGLProgram(d, [
        h
      ], h.dtype, p), e.disposeIntermediateTensorInfo(g);
    }
    if (i) {
      const f = new aG(n, l.shape, i, a), d = h;
      h = e.runWebGLProgram(f, [
        h
      ], h.dtype), e.disposeIntermediateTensorInfo(d);
    }
    if (o != null) {
      const f = hu(o), d = Jr({
        inputs: {
          x: h
        },
        backend: e,
        attrs: {
          perm: f
        }
      });
      return e.disposeIntermediateTensorInfo(h), e.disposeIntermediateTensorInfo(l), d;
    }
    return h;
  }
  function pWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, exclusive: s, reverse: o } = r;
    return fJ(_v.Prod, i, e, a, s, o);
  }
  const gWt = {
    kernelName: oM,
    backendName: "webgl",
    kernelFunc: pWt
  };
  function vWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, exclusive: s, reverse: o } = r;
    return fJ(_v.Sum, i, e, a, s, o);
  }
  const mWt = {
    kernelName: p_,
    backendName: "webgl",
    kernelFunc: vWt
  };
  function yWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, weights: a } = t, { size: s, binaryOutput: o } = r;
    if (i.shape.length === 1) {
      const l = e.readSync(i.dataId), u = e.readSync(a.dataId), c = XZ(l, u, a.dtype, a.shape, s);
      return e.makeTensorInfo([
        s
      ], a.dtype, c);
    } else if (i.shape.length === 2) {
      const l = e.bufferSync(i), u = e.bufferSync(a), c = wzt(l, u, s, o);
      return e.makeTensorInfo(c.shape, a.dtype, c.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`);
  }
  const xWt = {
    kernelName: uM,
    backendName: "webgl",
    kernelFunc: yWt
  };
  class bWt {
    constructor(t, e, r) {
      this.variableNames = [
        "x"
      ], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = r, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
      return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
      return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
    }
    getInputSamplingString() {
      return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
  }
  function _Wt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { blockSize: a, dataFormat: s } = r, o = i.shape[0], l = s === "NHWC" ? i.shape[1] : i.shape[2], u = s === "NHWC" ? i.shape[2] : i.shape[3], c = s === "NHWC" ? i.shape[3] : i.shape[1], h = l * a, f = u * a, d = c / (a * a), p = s === "NHWC" ? [
      o,
      h,
      f,
      d
    ] : [
      o,
      d,
      h,
      f
    ], g = new bWt(p, a, s);
    return e.runWebGLProgram(g, [
      i
    ], i.dtype);
  }
  const wWt = {
    kernelName: cM,
    backendName: "webgl",
    kernelFunc: _Wt
  };
  class dJ {
    constructor(t, e = false, r = null, i = false, a = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.customUniforms = [
        {
          name: "pads",
          type: "ivec2"
        },
        {
          name: "strides",
          type: "ivec2"
        },
        {
          name: "dilations",
          type: "ivec2"
        },
        {
          name: "inDims",
          type: "ivec2"
        }
      ], this.outputShape = t.outShape, this.enableShapeUniforms = Lr(this.outputShape.length);
      const s = t.filterHeight, o = t.filterWidth, l = t.outChannels / t.inChannels;
      let u = "", c = "";
      r && (i ? u = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : a ? u = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : u = `
          float activation(float x) {
            ${r}
          }
        `, c = "result = activation(result);");
      const h = e ? "result += getBiasAtOutCoords();" : "";
      e && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `;
    }
  }
  class pJ {
    constructor(t, e = false, r = null, i = false, a = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "pads",
          type: "ivec2"
        },
        {
          name: "strides",
          type: "ivec2"
        },
        {
          name: "dilations",
          type: "ivec2"
        },
        {
          name: "inDims",
          type: "ivec2"
        }
      ], this.outputShape = t.outShape, this.enableShapeUniforms = Lr(this.outputShape.length);
      const s = t.outChannels / t.inChannels, o = t.padInfo.left, l = t.strideWidth, u = t.dilationWidth, c = t.filterHeight, h = t.filterWidth, f = h;
      let d = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
      for (let m = 0; m < h; m++) d += `
          vec4 xTexelC${m * 2};
          int xTexelC${m * 2}Ready;
          vec4 xTexelC${m * 2 + 1};
          int xTexelC${m * 2 + 1}Ready;
          vec4 xC${m};`;
      d += `
    for (int r = 0; r < ${c}; r++) {
      `;
      for (let m = 0; m < h; m++) d += `
          xTexelC${m * 2} = vec4(0.0);
          xTexelC${m * 2}Ready = 0;
          xTexelC${m * 2 + 1} = vec4(0.0);
          xTexelC${m * 2 + 1}Ready = 0;
          xC${m} = vec4(0.0);`;
      d += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
      for (let m = 0; m < (f + 1) / 2; m++) {
        const y = m * 2;
        if (d += `
          xC = xCCorner + ${y * u};
          `, l === 1) {
          if (y < h && (o % 2 === 1 ? (d += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `, u === 1 && y > 0 ? d += `
                xC${y} = vec4(xTexelC${y - 2}.zw, xTexelC${y}.xy);
                ` : d += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `) : d += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `, y + 1 < h)) {
            const x = o % 2 === 0 ? HE(u) : u;
            u % 2 === 0 && o % 2 === 1 || u % 2 !== 0 && o % 2 !== 1 ? (d += `
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                    xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y + 1}.zw = vec2(0.0);
                    }
                    xTexelC${y + 1}Ready = 1;
                  }
                  `, u > 1 ? d += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y + 1} = vec4(previous.zw, xTexelC${y + 1}.xy);
                    } else {
                     xC${y + 1} = vec4(0.0, 0.0, xTexelC${y + 1}.xy);
                    }
                    ` : d += `
                    xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.xy);
                    `) : x === 1 ? d += `
                    xC${y + 1} = xTexelC${y};
                    ` : d += `
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                      xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y + 1}.zw = vec2(0.0);
                      }
                      xTexelC${y + 1}Ready = 1;
                    }

                    xC${y + 1} = xTexelC${y + 1};
                    `;
          }
        } else y < h && (o % 2 === 1 ? (d += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y + 1}Ready == 0) {
                  xTexelC${y + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y + 1}.zw = vec2(0.0);
                  }
                  xTexelC${y + 1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
              `, y + 1 < h && (d += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y + 1} = vec4(xTexelC${y + 1}.xy, final.xy);
                `)) : (d += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                  xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y + 1}.zw = vec2(0.);
                  }
                  xTexelC${y + 1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y + 1}.xy);
              `, y + 1 < h && (d += `
                  xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
                `)));
        y < h && (d += `
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `, y + 1 < h && (d += `
              wTexel = getW(r, ${y + 1}, d1, q);
              dotProd += xC${y + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
      }
      d += `
    }
  `, d += `
      }
    `;
      let p = "", g = "";
      r && (i ? p = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : a ? p = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : p = `vec4 activation(vec4 x) {
          ${r}
        }`, g = "result = activation(result);");
      const v = e ? "result += getBiasAtOutCoords();" : "";
      e && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${g}
        setOutput(result);
      }
    `;
    }
  }
  function SWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a } = t, { strides: s, pad: o, dilations: l, dimRoundingMode: u } = r;
    let c = l;
    c == null && (c = [
      1,
      1
    ]), B(Rr(s, c), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);
    const h = _r(i.shape, a.shape, s, c, o, u, true);
    let f;
    nt().getBool("WEBGL_PACK_DEPTHWISECONV") && h.strideWidth <= 2 && h.outChannels / h.inChannels === 1 ? f = new pJ(h) : f = new dJ(h);
    const d = [
      [
        h.padInfo.top,
        h.padInfo.left
      ],
      [
        h.strideHeight,
        h.strideWidth
      ],
      [
        h.dilationHeight,
        h.dilationWidth
      ],
      [
        h.inHeight,
        h.inWidth
      ]
    ];
    return e.runWebGLProgram(f, [
      i,
      a
    ], "float32", d);
  }
  const CWt = {
    kernelName: g_,
    backendName: "webgl",
    kernelFunc: SWt
  };
  class TWt {
    constructor(t) {
      this.variableNames = [
        "x",
        "dy"
      ], this.outputShape = t.filterShape;
      const e = t.strideHeight, r = t.strideWidth, i = t.padInfo.top, a = t.padInfo.left, s = t.outChannels / t.inChannels;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${i};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class IWt {
    constructor(t) {
      this.variableNames = [
        "dy",
        "W"
      ], this.outputShape = t.inShape;
      const e = t.filterHeight, r = t.filterWidth, i = t.strideHeight, a = t.strideWidth, s = e - 1 - t.padInfo.top, o = r - 1 - t.padInfo.left, l = t.outChannels / t.inChannels;
      this.userCode = `
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  function AWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, dy: a } = t, { strides: s, dilations: o, pad: l, dimRoundingMode: u, filterShape: c } = r, h = _r(i.shape, c, s, o, l, u, true), f = new TWt(h);
    return e.runWebGLProgram(f, [
      i,
      a
    ], "float32");
  }
  const kWt = {
    kernelName: hM,
    backendName: "webgl",
    kernelFunc: AWt
  };
  function DWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, filter: a } = t, { strides: s, dilations: o, pad: l, dimRoundingMode: u, inputShape: c } = r, h = _r(c, a.shape, s, o, l, u, true), f = new IWt(h);
    return e.runWebGLProgram(f, [
      i,
      a
    ], "float32");
  }
  const EWt = {
    kernelName: fM,
    backendName: "webgl",
    kernelFunc: DWt
  };
  class MWt {
    constructor(t) {
      this.variableNames = [
        "X"
      ], this.outputShape = [
        t,
        t
      ], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
  }
  function RWt(n) {
    const { inputs: t, backend: e } = n, { x: r } = t, i = [
      ...r.shape,
      ...r.shape
    ], a = lt(r.shape), s = Tt({
      inputs: {
        x: r
      },
      backend: e,
      attrs: {
        shape: [
          a
        ]
      }
    }), o = new MWt(a), l = e.runWebGLProgram(o, [
      s
    ], s.dtype), u = Tt({
      inputs: {
        x: l
      },
      backend: e,
      attrs: {
        shape: i
      }
    });
    return e.disposeIntermediateTensorInfo(s), e.disposeIntermediateTensorInfo(l), u;
  }
  const NWt = {
    kernelName: QY,
    backendName: "webgl",
    kernelFunc: RWt
  };
  class LWt {
    constructor(t) {
      this.variableNames = [
        "x",
        "W"
      ], this.outputShape = t.outShape;
      const { inHeight: e, inWidth: r, padInfo: i, strideHeight: a, strideWidth: s, filterHeight: o, filterWidth: l, dilationHeight: u, dilationWidth: c } = t, { top: h, left: f } = i;
      this.userCode = `
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${h}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
  }
  function PWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a } = t, { strides: s, pad: o, dilations: l } = r, u = qm(i.shape, a.shape, s, o, "NHWC", l);
    let c;
    const h = new LWt(u);
    c = e.runWebGLProgram(h, [
      i,
      a
    ], "float32");
    const f = Tt({
      inputs: {
        x: c
      },
      backend: e,
      attrs: {
        shape: u.outShape
      }
    });
    return e.disposeIntermediateTensorInfo(c), f;
  }
  const $Wt = {
    kernelName: v_,
    backendName: "webgl",
    kernelFunc: PWt
  };
  function OWt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { equation: i } = r, a = t, { allDims: s, summedDims: o, idDims: l } = NR(i, a.length);
    PR(s.length, l, a);
    const { path: u, steps: c } = $R(o, l), h = c.length;
    let f = null, d = s.length;
    const p = [];
    for (let g = 0; g < h; ++g) {
      for (const v of c[g]) {
        const { permutationIndices: m, expandDims: y } = LR(d, l[v]);
        let x;
        OR(m) ? x = a[v] : (x = Jr({
          inputs: {
            x: a[v]
          },
          backend: e,
          attrs: {
            perm: m
          }
        }), p.push(x));
        const b = x.shape.slice();
        for (let _ = 0; _ < y.length; ++_) b.splice(y[_], 0, 1);
        Xe(x.shape, b) || (x = Tt({
          inputs: {
            x
          },
          backend: e,
          attrs: {
            shape: b
          }
        }), p.push(x)), f === null ? f = x : (f = SN({
          inputs: {
            a: x,
            b: f
          },
          backend: e
        }), p.push(f));
      }
      g < h - 1 && (u[g] >= 0 && (f = Mw({
        inputs: {
          x: f
        },
        backend: e,
        attrs: {
          axis: u[g] - (s.length - d),
          keepDims: false
        }
      }), p.push(f)), d--);
    }
    for (const g of p) g !== f && e.disposeIntermediateTensorInfo(g);
    return f;
  }
  const FWt = {
    kernelName: dM,
    backendName: "webgl",
    kernelFunc: OWt
  };
  const BWt = "return (x >= 0.0) ? x : (exp(x) - 1.0);", zWt = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, VWt = Be({
    opSnippet: BWt,
    packedOpSnippet: zWt
  }), GWt = {
    kernelName: fm,
    backendName: "webgl",
    kernelFunc: VWt
  };
  const WWt = "return (b >= 0.0) ? a : a * (b + 1.0);", UWt = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`, HWt = (n) => {
    const { inputs: t, backend: e } = n, { dy: r, y: i } = t, a = nt().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Xd(UWt, r.shape, i.shape) : new uh(WWt, r.shape, i.shape);
    return e.runWebGLProgram(a, [
      r,
      i
    ], r.dtype);
  }, XWt = {
    kernelName: pM,
    backendName: "webgl",
    kernelFunc: HWt
  };
  const YWt = `
  return vec4(equal(a, b));
`, qWt = "return float(a == b);", jWt = Sr({
    opSnippet: qWt,
    packedOpSnippet: YWt,
    dtype: "bool",
    cpuKernelImpl: Azt
  }), KWt = {
    kernelName: m_,
    backendName: "webgl",
    kernelFunc: jWt
  };
  const ZWt = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${IR};
  float a1 = ${AR};
  float a2 = ${kR};
  float a3 = ${DR};
  float a4 = ${ER};
  float a5 = ${MR};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`, JWt = Be({
    opSnippet: ZWt
  }), QWt = {
    kernelName: dm,
    backendName: "webgl",
    kernelFunc: JWt
  };
  const tUt = Yd + `
  return exp(x);
`, eUt = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, gJ = Be({
    opSnippet: tUt,
    packedOpSnippet: eUt,
    cpuKernelImpl: kzt,
    dtype: "float32"
  }), nUt = {
    kernelName: pm,
    backendName: "webgl",
    kernelFunc: gJ
  };
  function q2(n) {
    const { inputs: t, attrs: e, backend: r } = n, { dim: i } = e, { input: a } = t, s = a.shape.length, o = a.shape.slice();
    let l = i;
    return i < 0 && (B(-(s + 1) <= i, () => `Axis must be in the interval [${-(s + 1)}, ${s}]`), l = s + i + 1), o.splice(l, 0, 1), Tt({
      inputs: {
        x: a
      },
      backend: r,
      attrs: {
        shape: o
      }
    });
  }
  const rUt = {
    kernelName: y_,
    backendName: "webgl",
    kernelFunc: q2
  };
  const lG = "return exp(x) - 1.0;", iUt = Be({
    opSnippet: lG,
    packedOpSnippet: lG,
    cpuKernelImpl: Dzt
  }), aUt = {
    kernelName: gm,
    backendName: "webgl",
    kernelFunc: iUt
  };
  class uG {
    constructor(t, e, r) {
      this.variableNames = [
        "real",
        "imag"
      ];
      const i = e[1];
      this.outputShape = e;
      const a = r ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`, s = r ? `${i}.0` : "1.0";
      let o;
      if (t === "real") o = "return real * expR - imag * expI;";
      else if (t === "imag") o = "return real * expI + imag * expR;";
      else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);
      this.userCode = `
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
  }
  function vJ(n, t, e) {
    const r = e.texData.get(n.dataId), i = lt(n.shape), a = n.shape[n.shape.length - 1], s = i / a, o = Tt({
      inputs: {
        x: n
      },
      backend: e,
      attrs: {
        shape: [
          s,
          a
        ]
      }
    }), l = o.shape, u = new uG("real", l, t), c = new uG("imag", l, t), h = [
      {
        dataId: r.complexTensorInfos.real.dataId,
        dtype: r.complexTensorInfos.real.dtype,
        shape: l
      },
      {
        dataId: r.complexTensorInfos.imag.dataId,
        dtype: r.complexTensorInfos.imag.dtype,
        shape: l
      }
    ], f = e.runWebGLProgram(u, h, "float32"), d = e.runWebGLProgram(c, h, "float32"), p = mu({
      inputs: {
        real: f,
        imag: d
      },
      backend: e
    });
    e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(d);
    const g = Tt({
      inputs: {
        x: p
      },
      backend: e,
      attrs: {
        shape: n.shape
      }
    });
    return e.disposeIntermediateTensorInfo(o), e.disposeIntermediateTensorInfo(p), g;
  }
  function sUt(n) {
    const { inputs: t, backend: e } = n, { input: r } = t;
    return vJ(r, false, e);
  }
  const oUt = {
    kernelName: gM,
    backendName: "webgl",
    kernelFunc: sUt
  };
  class lUt {
    constructor(t, e) {
      this.outputShape = [], this.customUniforms = [
        {
          name: "value",
          type: "float"
        }
      ], this.variableNames = [
        "x"
      ], this.outputShape = t, this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
  }
  function gy(n) {
    const { backend: t, attrs: e } = n, { shape: r, value: i } = e;
    let { dtype: a } = e;
    if (a = a || Rd(i), a === "string") {
      const s = kn(a, lt(r));
      return s.fill(i), t.makeTensorInfo(r, a, s);
    } else {
      const s = new lUt(r, i), o = [
        [
          i
        ]
      ];
      return t.runWebGLProgram(s, [], a, o);
    }
  }
  const uUt = {
    kernelName: vM,
    backendName: "webgl",
    kernelFunc: gy
  };
  class cUt {
    constructor(t) {
      this.variableNames = [
        "Image"
      ], this.outputShape = [];
      const e = t[2];
      this.outputShape = t, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  }
  const hUt = {
    kernelName: mM,
    backendName: "webgl",
    kernelFunc: ({ inputs: n, backend: t }) => {
      const { image: e } = n, r = t, i = new cUt(e.shape);
      return r.runWebGLProgram(i, [
        e
      ], e.dtype);
    }
  };
  const cG = "return floor(x);", fUt = Be({
    opSnippet: cG,
    packedOpSnippet: cG,
    cpuKernelImpl: Ezt
  }), dUt = {
    kernelName: vm,
    backendName: "webgl",
    kernelFunc: fUt
  };
  const pUt = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`, gUt = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`, vUt = Sr({
    opSnippet: pUt,
    packedOpSnippet: gUt,
    dtype: "int32"
  }), mUt = {
    kernelName: mm,
    backendName: "webgl",
    kernelFunc: vUt
  };
  class yUt {
    constructor(t) {
      this.variableNames = [
        "A"
      ];
      const e = ti(), [r, i] = t;
      this.outputShape = t, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
  }
  class xUt {
    constructor(t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = false, this.packedOutput = true;
      const e = ti(), [r, i] = t;
      this.outputShape = t, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${r}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `;
    }
  }
  const bUt = {
    kernelName: RSt,
    backendName: "webgl",
    kernelFunc: _Ut
  };
  let rf, MT = nt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function _Ut(n) {
    const { inputs: t, backend: e, attrs: r } = n;
    let { pixels: i } = t;
    const { numChannels: a } = r, s = typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement, o = typeof HTMLImageElement < "u" && i instanceof HTMLImageElement, [l, u] = s ? [
      i.videoWidth,
      i.videoHeight
    ] : [
      i.width,
      i.height
    ], c = [
      u,
      l
    ], h = [
      u,
      l,
      a
    ];
    if (o || s) {
      const g = nt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
      (rf == null || g !== MT) && (MT = g, rf = document.createElement("canvas").getContext("2d", {
        willReadFrequently: MT
      })), rf.canvas.width = l, rf.canvas.height = u, rf.drawImage(i, 0, 0, l, u), i = rf.canvas;
    }
    const f = e.makeTensorInfo(c, "int32");
    e.texData.get(f.dataId).usage = Hi.PIXELS, e.gpgpu.uploadPixelDataToTexture(e.getTexture(f.dataId), i);
    const d = nt().getBool("WEBGL_PACK") ? new xUt(h) : new yUt(h), p = e.runWebGLProgram(d, [
      f
    ], "int32");
    return e.disposeData(f.dataId), p;
  }
  function wUt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = t, { strides: l, pad: u, dataFormat: c, dilations: h, dimRoundingMode: f, activation: d, leakyreluAlpha: p } = r, g = il(c), v = _r(i.shape, a.shape, l, h, u, f, false, g);
    let m;
    const y = [], x = s != null, b = o != null, _ = d === "leakyrelu", w = () => {
      const I = [
        i,
        a
      ], T = (A, C) => {
        if (C === "NCHW" && A.shape.length === 1 && A.shape[0] !== 1) {
          const D = Tt({
            inputs: {
              x: A
            },
            backend: e,
            attrs: {
              shape: [
                A.shape[0],
                1,
                1
              ]
            }
          });
          return y.push(D), D;
        }
        return A;
      };
      if (x && I.push(T(s, c)), b && I.push(T(o, c)), _) {
        const A = e.makeTensorInfo([], "float32", uu(p, "float32"));
        I.push(A), y.push(A);
      }
      return I;
    };
    if (v.filterHeight === 1 && v.filterWidth === 1 && v.dilationHeight === 1 && v.dilationWidth === 1 && v.strideHeight === 1 && v.strideWidth === 1 && (v.padInfo.type === "SAME" || v.padInfo.type === "VALID")) m = cJ({
      x: i,
      filter: a,
      convInfo: v,
      backend: e,
      bias: s,
      activation: d,
      preluActivationWeights: o,
      leakyreluAlpha: p
    });
    else if (v.strideWidth <= 2 && g === "channelsLast" && nt().getBool("WEBGL_EXP_CONV")) {
      const I = d ? xv(d, true) : null, T = new uJ(v, x, I, b, _), A = [
        [
          v.padInfo.top,
          v.padInfo.left
        ],
        [
          v.strideHeight,
          v.strideWidth
        ],
        [
          v.dilationHeight,
          v.dilationWidth
        ],
        [
          v.inHeight,
          v.inWidth
        ]
      ], C = w();
      m = e.runWebGLProgram(T, C, "float32", A);
    } else if (nt().getBool("WEBGL_CONV_IM2COL")) m = hJ({
      x: i,
      filter: a,
      convInfo: v,
      backend: e,
      bias: s,
      activation: d,
      preluActivationWeights: o,
      leakyreluAlpha: p
    });
    else {
      const I = d ? xv(d, false) : null, T = new lJ(v, x, I, b, _), A = w();
      m = e.runWebGLProgram(T, A, "float32");
    }
    const S = Tt({
      inputs: {
        x: m
      },
      backend: e,
      attrs: {
        shape: v.outShape
      }
    });
    return y.push(m), y.forEach((I) => e.disposeIntermediateTensorInfo(I)), S;
  }
  const SUt = {
    kernelName: $b,
    backendName: "webgl",
    kernelFunc: wUt
  };
  function CUt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = t, { strides: l, pad: u, dilations: c, dimRoundingMode: h, activation: f, leakyreluAlpha: d } = r, p = [];
    let g = c;
    g == null && (g = [
      1,
      1
    ]), B(Rr(l, g), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);
    const v = _r(i.shape, a.shape, l, g, u, h, true), m = nt().getBool("WEBGL_PACK_DEPTHWISECONV") && v.strideWidth <= 2 && v.outChannels / v.inChannels === 1, y = f ? xv(f, m) : null, x = [
      i,
      a
    ], b = s != null, _ = o != null, w = f === "leakyrelu";
    if (b && x.push(s), _ && x.push(o), w) {
      const A = e.makeTensorInfo([], "float32", uu(d, "float32"));
      x.push(A), p.push(A);
    }
    let S;
    m ? S = new pJ(v, b, y, _, w) : S = new dJ(v, b, y, _, w);
    const I = [
      [
        v.padInfo.top,
        v.padInfo.left
      ],
      [
        v.strideHeight,
        v.strideWidth
      ],
      [
        v.dilationHeight,
        v.dilationWidth
      ],
      [
        v.inHeight,
        v.inWidth
      ]
    ], T = e.runWebGLProgram(S, x, "float32", I);
    return p.forEach((A) => e.disposeIntermediateTensorInfo(A)), T;
  }
  const TUt = {
    kernelName: yq,
    backendName: "webgl",
    kernelFunc: CUt
  };
  class IUt {
    constructor(t, e, r, i) {
      this.sliceDim = t, this.strides = e, this.paramsShape = i, this.variableNames = [
        "x",
        "indices"
      ], this.outputShape = r;
      const a = sn(r.length);
      let s = `
    int index;`;
      for (let o = 0; o < this.sliceDim; o++) s += `
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;
      this.userCode = `
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
    }
  }
  function AUt(n) {
    const { inputs: t, backend: e } = n, { params: r, indices: i } = t, a = i.shape, s = a[a.length - 1], o = lt(r.shape), [l, u, c, h] = gR(r, i), f = Tt({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: [
          u,
          s
        ]
      }
    }), d = Tt({
      inputs: {
        x: r
      },
      backend: e,
      attrs: {
        shape: [
          lt(r.shape) / c,
          c
        ]
      }
    });
    if (e.shouldExecuteOnCPU([
      r,
      i
    ]) || r.dtype === "string") {
      const m = e.readSync(i.dataId), y = e.bufferSync(r), x = Mzt(m, y, r.dtype, u, s, c, h, r.shape, o);
      return e.makeTensorInfo(l, r.dtype, x.values);
    }
    const p = new IUt(s, h, [
      u,
      c
    ], r.shape), g = e.runWebGLProgram(p, [
      d,
      f
    ], d.dtype), v = Tt({
      inputs: {
        x: g
      },
      backend: e,
      attrs: {
        shape: l
      }
    });
    return e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(g), v;
  }
  const kUt = {
    kernelName: tq,
    backendName: "webgl",
    kernelFunc: AUt
  };
  class DUt {
    constructor(t, e) {
      this.variableNames = [
        "A",
        "indices"
      ], this.outputShape = e, this.rank = e.length;
      const r = sn(this.rank), i = EUt(t);
      this.userCode = `
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `;
    }
  }
  function EUt(n, t) {
    const e = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w"
    ], r = [];
    for (let i = 0; i < n.length; i++) i === 2 ? r.push("index") : r.push(`${e[i]}`);
    return r.join();
  }
  function mJ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, indices: a } = t, { axis: s, batchDims: o } = r, l = Se(s, i.shape)[0];
    if (nt().get("DEBUG")) {
      const y = e.readSync(a.dataId), x = i.shape[l];
      for (let b = 0; b < y.length; ++b) {
        const _ = y[b];
        B(_ <= x - 1 && _ >= 0, () => `GatherV2: the index value ${_} is not in [0, ${x - 1}]`);
      }
    }
    const u = BR(i, a, l, o), c = lt(a.shape), h = [], f = Tt({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: [
          u.batchSize,
          u.outerSize,
          u.dimSize,
          u.sliceSize
        ]
      }
    }), d = Tt({
      inputs: {
        x: a
      },
      backend: e,
      attrs: {
        shape: [
          u.batchSize,
          c / u.batchSize
        ]
      }
    });
    h.push(f), h.push(d);
    const p = [
      u.batchSize,
      u.outerSize,
      c / u.batchSize,
      u.sliceSize
    ];
    if (e.shouldExecuteOnCPU([
      i,
      a
    ]) || i.dtype === "string") {
      const y = e.bufferSync(d), x = e.bufferSync(f), b = Rzt(x, y, p);
      return h.forEach((_) => e.disposeIntermediateTensorInfo(_)), e.makeTensorInfo(u.outputShape, b.dtype, b.values);
    }
    const g = new DUt(f.shape, p), v = e.runWebGLProgram(g, [
      f,
      d
    ], f.dtype);
    h.push(v);
    const m = Tt({
      inputs: {
        x: v
      },
      backend: e,
      attrs: {
        shape: u.outputShape
      }
    });
    return h.forEach((y) => e.disposeIntermediateTensorInfo(y)), m;
  }
  const MUt = {
    kernelName: b_,
    backendName: "webgl",
    kernelFunc: mJ
  };
  const RUt = "return float(a > b);", NUt = `
  return vec4(greaterThan(a, b));
`, LUt = Sr({
    opSnippet: RUt,
    packedOpSnippet: NUt,
    cpuKernelImpl: Nzt,
    dtype: "bool"
  }), PUt = {
    kernelName: __,
    backendName: "webgl",
    kernelFunc: LUt
  };
  const $Ut = "return float(a >= b);", OUt = `
  return vec4(greaterThanEqual(a, b));
`, FUt = Sr({
    opSnippet: $Ut,
    packedOpSnippet: OUt,
    dtype: "bool",
    cpuKernelImpl: Lzt
  }), BUt = {
    kernelName: ym,
    backendName: "webgl",
    kernelFunc: FUt
  };
  function zUt(n) {
    const { inputs: t, backend: e } = n, { input: r } = t;
    return vJ(r, true, e);
  }
  const VUt = {
    kernelName: yM,
    backendName: "webgl",
    kernelFunc: zUt
  };
  const GUt = "return float(!isnan(x) && !isinf(x));", WUt = Be({
    opSnippet: GUt,
    dtype: "bool"
  }), UUt = {
    kernelName: bm,
    backendName: "webgl",
    kernelFunc: WUt
  };
  const HUt = "return float(isinf(x));", XUt = Be({
    opSnippet: HUt,
    dtype: "bool"
  }), YUt = {
    kernelName: _m,
    backendName: "webgl",
    kernelFunc: XUt
  };
  const qUt = "return float(isnan(x));", jUt = Be({
    opSnippet: qUt,
    dtype: "bool"
  }), KUt = {
    kernelName: wm,
    backendName: "webgl",
    kernelFunc: jUt
  };
  const ZUt = "return float(a < b);", JUt = `
  return vec4(lessThan(a, b));
`, QUt = Sr({
    opSnippet: ZUt,
    packedOpSnippet: JUt,
    cpuKernelImpl: Pzt,
    dtype: "bool"
  }), t5t = {
    kernelName: S_,
    backendName: "webgl",
    kernelFunc: QUt
  };
  const e5t = "return float(a <= b);", n5t = `
  return vec4(lessThanEqual(a, b));
`, r5t = Sr({
    opSnippet: e5t,
    packedOpSnippet: n5t,
    cpuKernelImpl: $zt,
    dtype: "bool"
  }), i5t = {
    kernelName: C_,
    backendName: "webgl",
    kernelFunc: r5t
  };
  function a5t(n) {
    const { backend: t, attrs: e } = n, { start: r, stop: i, num: a } = e, s = Ozt(r, i, a);
    return t.makeTensorInfo([
      s.length
    ], "float32", s);
  }
  const s5t = {
    kernelName: eq,
    backendName: "webgl",
    kernelFunc: a5t
  };
  const o5t = Yd + `
  return x < 0.0 ? 0./0. : log(x);
`, l5t = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`, u5t = Be({
    opSnippet: o5t,
    packedOpSnippet: l5t,
    cpuKernelImpl: Fzt
  }), c5t = {
    kernelName: Sm,
    backendName: "webgl",
    kernelFunc: u5t
  };
  const h5t = Yd + `
  return log(1.0 + x);
`, f5t = Be({
    opSnippet: h5t
  }), d5t = {
    kernelName: Cm,
    backendName: "webgl",
    kernelFunc: f5t
  };
  const p5t = "return float(a >= 1.0 && b >= 1.0);", g5t = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`, v5t = Sr({
    opSnippet: p5t,
    packedOpSnippet: g5t,
    dtype: "bool"
  }), m5t = {
    kernelName: T_,
    backendName: "webgl",
    kernelFunc: v5t
  };
  const y5t = "return float(!(x >= 1.0));", x5t = Be({
    opSnippet: y5t
  }), b5t = {
    kernelName: I_,
    backendName: "webgl",
    kernelFunc: x5t
  };
  const _5t = "return float(a >= 1.0 || b >= 1.0);", w5t = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`, S5t = Sr({
    opSnippet: _5t,
    packedOpSnippet: w5t,
    dtype: "bool"
  }), C5t = {
    kernelName: A_,
    backendName: "webgl",
    kernelFunc: S5t
  };
  class T5t {
    constructor(t, e, r, i, a) {
      this.variableNames = [
        "x"
      ], this.outputShape = [];
      const s = e, o = t[3] - 1;
      this.outputShape = t;
      let l;
      const u = `float(${r}) + float(${i}) * sum`;
      a === 0.5 ? l = `inversesqrt(${u})` : a === 1 ? l = `1.0/(${u})` : l = `exp(log(${u}) * float(-${a}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `;
    }
  }
  class I5t {
    constructor(t, e, r, i, a) {
      this.variableNames = [
        "x"
      ], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
      const s = e, o = t[3] - 1;
      this.outputShape = t;
      let l;
      const u = `float(${r}) + float(${i}) * sum`;
      a === 0.5 ? l = `inversesqrt(${u})` : a === 1 ? l = `1.0/(${u})` : l = `exp(log(${u}) * float(-${a}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `;
    }
  }
  const A5t = (n) => {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { depthRadius: a, bias: s, alpha: o, beta: l } = r, u = nt().getBool("WEBGL_PACK_NORMALIZATION") ? new I5t(i.shape, a, s, o, l) : new T5t(i.shape, a, s, o, l);
    return e.runWebGLProgram(u, [
      i
    ], i.dtype);
  }, k5t = {
    kernelName: k_,
    backendName: "webgl",
    kernelFunc: A5t
  };
  class D5t {
    constructor(t, e, r, i, a) {
      this.variableNames = [
        "inputImage",
        "outputImage",
        "dy"
      ], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = r, this.alpha = i, this.beta = a, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
  }
  const E5t = (n) => {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, y: a, dy: s } = t, { depthRadius: o, bias: l, alpha: u, beta: c } = r, h = new D5t(i.shape, o, l, u, c);
    return e.runWebGLProgram(h, [
      i,
      a,
      s
    ], i.dtype);
  }, M5t = {
    kernelName: bM,
    backendName: "webgl",
    kernelFunc: E5t
  };
  function R5t(n, t, e, r) {
    const i = lt(t), s = lt(n.shape) / i, o = Tt({
      inputs: {
        x: n
      },
      attrs: {
        shape: [
          s,
          i
        ]
      },
      backend: r
    }), l = Dh(o, n.dtype, "max", r), u = Tt({
      inputs: {
        x: l
      },
      attrs: {
        shape: e
      },
      backend: r
    });
    return r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(l), u;
  }
  function yJ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { reductionIndices: a, keepDims: s } = r, o = i.shape.length, l = Se(a, i.shape);
    let u = l;
    const c = wn(u, o), h = c != null, f = e.shouldExecuteOnCPU([
      i
    ]);
    let d = i;
    if (h) {
      if (f) {
        const x = e.texData.get(d.dataId).values, b = new Array(o);
        for (let S = 0; S < b.length; S++) b[S] = i.shape[c[S]];
        const _ = _N(x, i.shape, i.dtype, c, b);
        d = e.makeTensorInfo(b, i.dtype);
        const w = e.texData.get(d.dataId);
        w.values = _;
      } else d = Ew(i, c, e);
      u = Rn(u.length, o);
    }
    wr("max", u, o);
    const [p, g] = hr(d.shape, u);
    let v = p;
    s && (v = Bn(p, l));
    let m;
    if (f) {
      const x = e.texData.get(d.dataId).values, b = Bzt(x, lt(g), v, i.dtype);
      m = e.makeTensorInfo(v, i.dtype);
      const _ = e.texData.get(m.dataId);
      _.values = b;
    } else m = R5t(d, g, v, e);
    return h && e.disposeIntermediateTensorInfo(d), m;
  }
  const N5t = {
    kernelName: D_,
    backendName: "webgl",
    kernelFunc: yJ
  };
  const L5t = wN + `
  return max(a, b);
`, P5t = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + kh + `
  return result;
`, $5t = Sr({
    opSnippet: L5t,
    packedOpSnippet: P5t,
    cpuKernelImpl: zzt
  }), O5t = {
    kernelName: Tm,
    backendName: "webgl",
    kernelFunc: $5t
  };
  function F5t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t;
    fy(i, "maxPool");
    const { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, u = 1;
    B(Rr(s, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = Ra(i.shape, a, s, u, o, l);
    if (c.filterWidth === 1 && c.filterHeight === 1 && Xe(c.inShape, c.outShape)) return Fi({
      inputs: {
        x: i
      },
      backend: e
    });
    const h = new bv(c, "max", false);
    return e.runWebGLProgram(h, [
      i
    ], i.dtype);
  }
  const B5t = {
    kernelName: E_,
    backendName: "webgl",
    kernelFunc: F5t
  };
  function z5t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { filterSize: a, strides: s, pad: o, dataFormat: l, dimRoundingMode: u } = r, c = [
      1,
      1,
      1
    ], h = rl(i.shape, a, s, c, o, u, l), f = new CN(h, "max", false);
    return e.runWebGLProgram(f, [
      i
    ], i.dtype);
  }
  const V5t = {
    kernelName: M_,
    backendName: "webgl",
    kernelFunc: z5t
  };
  class G5t {
    constructor(t) {
      this.variableNames = [
        "dy",
        "maxPos"
      ], this.outputShape = t.inShape;
      const e = t.strideHeight, r = t.strideWidth, i = t.dilationHeight, a = t.effectiveFilterHeight, s = t.effectiveFilterWidth, o = a - 1 - t.padInfo.top, l = s - 1 - t.padInfo.left, u = a * s - 1;
      this.userCode = `
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class W5t {
    constructor(t) {
      this.variableNames = [
        "dy",
        "maxPos"
      ], this.outputShape = t.inShape;
      const e = t.strideDepth, r = t.strideHeight, i = t.strideWidth, a = t.dilationDepth, s = t.dilationHeight, o = t.dilationWidth, l = t.effectiveFilterDepth, u = t.effectiveFilterHeight, c = t.effectiveFilterWidth, h = l - 1 - t.padInfo.front, f = u - 1 - t.padInfo.top, d = c - 1 - t.padInfo.left, p = l * u * c - 1;
      this.userCode = `
      const ivec3 pads = ivec3(${h}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  function U5t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, input: a } = t, s = a, { filterSize: o, strides: l, pad: u, dimRoundingMode: c } = r, h = [
      1,
      1,
      1
    ], f = rl(s.shape, o, l, h, u, c), d = new CN(f, "max", true), p = e.runWebGLProgram(d, [
      s
    ], s.dtype), g = new W5t(f), v = e.runWebGLProgram(g, [
      i,
      p
    ], s.dtype);
    return e.disposeIntermediateTensorInfo(p), v;
  }
  const H5t = {
    kernelName: wM,
    backendName: "webgl",
    kernelFunc: U5t
  };
  function X5t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { dy: i, input: a, output: s } = t, o = a;
    fy([
      a,
      s
    ], "maxPoolGrad");
    const { filterSize: l, strides: u, pad: c, dimRoundingMode: h } = r, f = Ra(o.shape, l, u, 1, c, h), d = true, p = new bv(f, "max", d), g = e.runWebGLProgram(p, [
      o
    ], o.dtype), v = new G5t(f), m = e.runWebGLProgram(v, [
      i,
      g
    ], o.dtype);
    return e.disposeIntermediateTensorInfo(g), m;
  }
  const Y5t = {
    kernelName: _M,
    backendName: "webgl",
    kernelFunc: X5t
  };
  function q5t(n, t, e, r) {
    let i = new bv(e, "max", false);
    const a = r.runWebGLProgram(i, [
      n
    ], "float32");
    i = new bv(e, "max", true, true, t);
    const s = r.runWebGLProgram(i, [
      n
    ], "float32");
    return [
      a,
      s
    ];
  }
  const j5t = {
    kernelName: nq,
    backendName: "webgl",
    kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
      const { x: r } = n, { filterSize: i, strides: a, pad: s, includeBatchInIndex: o } = t, l = e;
      B(r.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);
      const u = [
        1,
        1
      ];
      B(Rr(a, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
      const c = Ra(r.shape, i, a, u, s), [h, f] = q5t(r, o, c, l);
      return [
        h,
        f
      ];
    }
  };
  function K5t(n, t, e, r) {
    const i = lt(t), s = lt(n.shape) / i, o = Tt({
      inputs: {
        x: n
      },
      attrs: {
        shape: [
          s,
          i
        ]
      },
      backend: r
    }), l = Dh(o, "float32", "mean", r), u = Tt({
      inputs: {
        x: l
      },
      attrs: {
        shape: e
      },
      backend: r
    });
    return r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(l), u;
  }
  const Z5t = {
    kernelName: R_,
    backendName: "webgl",
    kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
      const { x: r } = n, { keepDims: i, axis: a } = t, s = e, o = r.shape.length, l = Se(a, r.shape);
      let u = l;
      const c = wn(u, o), h = c != null, f = s.shouldExecuteOnCPU([
        r
      ]), d = [];
      let p = r;
      if (h) {
        if (f) {
          const b = s.texData.get(p.dataId).values, _ = new Array(o);
          for (let I = 0; I < _.length; I++) _[I] = r.shape[c[I]];
          const w = _N(b, r.shape, r.dtype, c, _);
          p = s.makeTensorInfo(_, r.dtype);
          const S = s.texData.get(p.dataId);
          S.values = w;
        } else p = Ew(r, c, s);
        d.push(p), u = Rn(u.length, o);
      }
      wr("sum", u, o);
      const [g, v] = hr(p.shape, u);
      let m = g;
      i && (m = Bn(g, l));
      const y = K5t(p, v, m, s);
      for (const x of d) s.disposeIntermediateTensorInfo(x);
      return y;
    }
  };
  function J5t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r, o = i.shape.length, l = Se(a, i.shape);
    let u = l;
    const c = wn(u, o);
    let h = i;
    c != null && (h = Jr({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: c
      }
    }), u = Rn(u.length, i.shape.length)), wr("min", u, o);
    const [f, d] = hr(h.shape, u), p = lt(d), g = Tt({
      inputs: {
        x: h
      },
      backend: e,
      attrs: {
        shape: [
          -1,
          p
        ]
      }
    }), v = Dh(g, g.dtype, "min", e);
    let m;
    if (s) {
      const y = Bn(f, l);
      m = Tt({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          shape: y
        }
      });
    } else m = Tt({
      inputs: {
        x: v
      },
      backend: e,
      attrs: {
        shape: f
      }
    });
    return e.disposeIntermediateTensorInfo(g), e.disposeIntermediateTensorInfo(v), c != null && e.disposeIntermediateTensorInfo(h), m;
  }
  const Q5t = {
    kernelName: N_,
    backendName: "webgl",
    kernelFunc: J5t
  };
  const tHt = wN + `
  return min(a, b);
`, eHt = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + kh + `
  return result;
`, nHt = Sr({
    opSnippet: tHt,
    packedOpSnippet: eHt,
    cpuKernelImpl: Vzt
  }), rHt = {
    kernelName: Im,
    backendName: "webgl",
    kernelFunc: nHt
  };
  class iHt {
    constructor(t, e, r) {
      this.variableNames = [
        "x"
      ], this.outputShape = e.map((c, h) => c[0] + t[h] + c[1]);
      const i = t.length, a = sn(i), s = e.map((c) => c[0]).join(","), o = e.map((c, h) => c[0] + t[h]).join(","), l = [
        "coords[0]",
        "coords[1]",
        "coords[2]",
        "coords[3]"
      ].slice(0, i), u = r === "reflect" ? 0 : 1;
      if (i === 1) {
        this.userCode = `
        int start = ${s};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;
        return;
      }
      this.userCode = `
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `;
    }
  }
  class aHt {
    constructor(t, e, r) {
      this.variableNames = [
        "x"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = e.map((p, g) => p[0] + t[g] + p[1]);
      const i = t.length, a = sn(i), s = e.map((p) => p[0]).join(","), o = e.map((p, g) => p[0] + t[g]).join(","), l = Hr("rc", i), u = Hr("source", i), c = `${l[i - 1]} < ${this.outputShape[i - 1]}`, h = i === 1 ? "source" : `vec2(${u.slice(-2).join()})`, f = r === "reflect" ? 0 : 1;
      let d = "";
      if (i === 1) {
        const p = `
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;
        d = `
        ${a} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[i - 1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `;
      } else {
        const p = `
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;
        d = `
        ${a} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[i - 1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[i - 2]} += 1;
        if(${l[i - 2]} < ${this.outputShape[i - 2]}) {
          ${p}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[i - 1]} += 1;
          if(${c}) {
            ${p}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `;
      }
      this.userCode = `
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `;
    }
  }
  const sHt = ({ inputs: n, backend: t, attrs: e }) => {
    const { x: r } = n, { paddings: i, mode: a } = e, s = nt().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new aHt(r.shape, i, a) : new iHt(r.shape, i, a);
    return t.runWebGLProgram(s, [
      r
    ], r.dtype);
  }, oHt = {
    kernelName: L_,
    backendName: "webgl",
    kernelFunc: sHt
  };
  const lHt = `if (b == 0.0) return NAN;
  return mod(a, b);`, uHt = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + kh + `
  return result;
`, cHt = Sr({
    opSnippet: lHt,
    packedOpSnippet: uHt
  }), hHt = {
    kernelName: Am,
    backendName: "webgl",
    kernelFunc: cHt
  };
  class fHt {
    constructor(t, e, r) {
      this.variableNames = [
        "probs"
      ], this.customUniforms = [
        {
          name: "seed",
          type: "float"
        }
      ], this.outputShape = [
        t,
        r
      ], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e - 1}));
      }
    `;
    }
  }
  const dHt = `
if (a == b) {
  return 1.0;
};
return a / b;`, pHt = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`, xJ = Sr({
    opSnippet: dHt,
    packedOpSnippet: pHt,
    checkOutOfBounds: true
  }), gHt = {
    kernelName: hm,
    backendName: "webgl",
    kernelFunc: xJ
  };
  const hG = "return a - b;", bJ = Sr({
    opSnippet: hG,
    packedOpSnippet: hG,
    supportsComplex: true,
    cpuKernelImpl: lVt
  }), vHt = {
    kernelName: Wm,
    backendName: "webgl",
    kernelFunc: bJ
  };
  function _J(n) {
    const { inputs: t, backend: e, attrs: r } = n, { logits: i } = t, { dim: a } = r, s = Se([
      a
    ], i.shape), o = yJ({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        reductionIndices: s,
        keepDims: false
      }
    }), l = Bn(o.shape, s), u = Tt({
      inputs: {
        x: o
      },
      backend: e,
      attrs: {
        shape: l
      }
    }), c = bJ({
      inputs: {
        a: i,
        b: u
      },
      backend: e
    }), h = gJ({
      inputs: {
        x: c
      },
      backend: e
    }), f = Mw({
      inputs: {
        x: h
      },
      backend: e,
      attrs: {
        axis: s,
        keepDims: false
      }
    }), d = Tt({
      inputs: {
        x: f
      },
      backend: e,
      attrs: {
        shape: l
      }
    }), p = xJ({
      inputs: {
        a: h,
        b: d
      },
      backend: e
    });
    return e.disposeIntermediateTensorInfo(o), e.disposeIntermediateTensorInfo(u), e.disposeIntermediateTensorInfo(c), e.disposeIntermediateTensorInfo(h), e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(d), p;
  }
  const mHt = {
    kernelName: J_,
    backendName: "webgl",
    kernelFunc: _J
  };
  function yHt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { logits: i } = t, { numSamples: a, seed: s, normalized: o } = r, l = o ? i : _J({
      inputs: {
        logits: i
      },
      backend: e,
      attrs: {
        dim: i.shape.length - 1
      }
    }), u = l.shape[0], c = l.shape[1], h = new fHt(u, c, a), f = [
      [
        s
      ]
    ], d = e.runWebGLProgram(h, [
      l
    ], "int32", f);
    return o || e.disposeIntermediateTensorInfo(l), d;
  }
  const xHt = {
    kernelName: rq,
    backendName: "webgl",
    kernelFunc: yHt
  };
  const bHt = La + `
  return -x;
`, _Ht = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  function wHt(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    if (e.shouldExecuteOnCPU([
      r
    ])) {
      const a = e.texData.get(r.dataId), [s, o] = Wzt(a.values, r.shape, r.dtype);
      return e.makeTensorInfo(o, r.dtype, s);
    }
    let i;
    return nt().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? i = new Ll(r.shape, _Ht) : i = new Gs(r.shape, bHt), e.runWebGLProgram(i, [
      r
    ], r.dtype);
  }
  const SHt = {
    kernelName: P_,
    backendName: "webgl",
    kernelFunc: wHt
  };
  const CHt = cR;
  function THt(n) {
    Wi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: t, backend: e, attrs: r } = n, { boxes: i, scores: a } = t, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l } = r, u = e.readSync(i.dataId), c = e.readSync(a.dataId), { selectedIndices: h } = CHt(u, c, s, o, l);
    return e.makeTensorInfo([
      h.length
    ], "int32", new Int32Array(h));
  }
  const IHt = {
    kernelName: SM,
    backendName: "webgl",
    kernelFunc: THt
  };
  const AHt = hR;
  function kHt(n) {
    Wi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: t, backend: e, attrs: r } = n, { boxes: i, scores: a } = t, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, padToMaxOutputSize: u } = r, c = e.readSync(i.dataId), h = e.readSync(a.dataId), { selectedIndices: f, validOutputs: d } = AHt(c, h, s, o, l, u);
    return [
      e.makeTensorInfo([
        f.length
      ], "int32", new Int32Array(f)),
      e.makeTensorInfo([], "int32", new Int32Array([
        d
      ]))
    ];
  }
  const DHt = {
    kernelName: CM,
    backendName: "webgl",
    kernelFunc: kHt
  };
  const EHt = fR;
  function MHt(n) {
    Wi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: t, backend: e, attrs: r } = n, { boxes: i, scores: a } = t, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, softNmsSigma: u } = r, c = e.readSync(i.dataId), h = e.readSync(a.dataId), f = s, d = o, p = l, g = u, { selectedIndices: v, selectedScores: m } = EHt(c, h, f, d, p, g);
    return [
      e.makeTensorInfo([
        v.length
      ], "int32", new Int32Array(v)),
      e.makeTensorInfo([
        m.length
      ], "float32", new Float32Array(m))
    ];
  }
  const RHt = {
    kernelName: TM,
    backendName: "webgl",
    kernelFunc: MHt
  };
  class NHt {
    constructor(t, e, r, i) {
      this.variableNames = [
        "indices"
      ], this.outputShape = [
        t,
        e
      ], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${r}),
                      float(index == coords.y)));
      }
    `;
    }
  }
  const LHt = (n) => {
    const { inputs: t, backend: e, attrs: r } = n, { indices: i } = t, { dtype: a, depth: s, onValue: o, offValue: l } = r, u = lt(i.shape), c = new NHt(u, s, o, l), h = Tt({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: [
          u
        ]
      }
    }), f = e.runWebGLProgram(c, [
      h
    ], a);
    e.disposeIntermediateTensorInfo(h);
    const d = [
      ...i.shape,
      s
    ], p = Tt({
      inputs: {
        x: f
      },
      backend: e,
      attrs: {
        shape: d
      }
    });
    return e.disposeIntermediateTensorInfo(f), p;
  }, PHt = {
    kernelName: F_,
    backendName: "webgl",
    kernelFunc: LHt
  };
  function o1(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    if (r.dtype === "complex64") {
      const i = py({
        inputs: {
          input: r
        },
        backend: e
      }), a = o1({
        inputs: {
          x: i
        },
        backend: e
      }), s = Rw({
        inputs: {
          input: r
        },
        backend: e
      }), o = o1({
        inputs: {
          x: s
        },
        backend: e
      }), l = mu({
        inputs: {
          real: a,
          imag: o
        },
        backend: e
      });
      return e.disposeIntermediateTensorInfo(i), e.disposeIntermediateTensorInfo(a), e.disposeIntermediateTensorInfo(s), e.disposeIntermediateTensorInfo(o), l;
    } else return gy({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: r.dtype === "string" ? "" : 0
      },
      backend: e
    });
  }
  const $Ht = {
    kernelName: ew,
    backendName: "webgl",
    kernelFunc: o1
  };
  function wJ(n) {
    const { inputs: t, backend: e } = n, { x: r } = t;
    if (r.dtype === "string") throw new Error("onesLike is not supported under string dtype");
    if (r.dtype === "complex64") {
      const i = py({
        inputs: {
          input: r
        },
        backend: e
      }), a = wJ({
        inputs: {
          x: i
        },
        backend: e
      }), s = Rw({
        inputs: {
          input: r
        },
        backend: e
      }), o = o1({
        inputs: {
          x: s
        },
        backend: e
      }), l = mu({
        inputs: {
          real: a,
          imag: o
        },
        backend: e
      });
      return e.disposeIntermediateTensorInfo(i), e.disposeIntermediateTensorInfo(a), e.disposeIntermediateTensorInfo(s), e.disposeIntermediateTensorInfo(o), l;
    } else return gy({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: 1
      },
      backend: e
    });
  }
  const OHt = {
    kernelName: O_,
    backendName: "webgl",
    kernelFunc: wJ
  };
  function FHt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { axis: i } = r;
    if (t.length === 1) return q2({
      inputs: {
        input: t[0]
      },
      backend: e,
      attrs: {
        dim: i
      }
    });
    const a = t[0].shape, s = t[0].dtype;
    t.forEach((c) => {
      XE(a, c.shape, "All tensors passed to stack must have matching shapes"), B(s === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const o = [], l = t.map((c) => {
      const h = q2({
        inputs: {
          input: c
        },
        backend: e,
        attrs: {
          dim: i
        }
      });
      return o.push(h), h;
    }), u = oJ({
      inputs: l,
      backend: e,
      attrs: {
        axis: i
      }
    });
    return o.forEach((c) => e.disposeIntermediateTensorInfo(c)), u;
  }
  const BHt = {
    kernelName: B_,
    backendName: "webgl",
    kernelFunc: FHt
  };
  class zHt {
    constructor(t, e, r) {
      this.variableNames = [
        "x"
      ], this.customUniforms = [
        {
          name: "value",
          type: "float"
        }
      ], this.outputShape = e.map((u, c) => u[0] + t[c] + u[1]);
      const i = t.length, a = sn(i), s = e.map((u) => u[0]).join(","), o = e.map((u, c) => u[0] + t[c]).join(","), l = [
        "coords[0]",
        "coords[1]",
        "coords[2]",
        "coords[3]"
      ].slice(0, i);
      if (i === 1) {
        this.userCode = `
        int start = ${s};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
        return;
      }
      this.userCode = `
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `;
    }
  }
  class VHt {
    constructor(t, e, r) {
      this.variableNames = [
        "x"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "value",
          type: "float"
        }
      ], this.outputShape = e.map((g, v) => g[0] + t[v] + g[1]);
      const i = t.length, a = sn(i), s = e.map((g) => g[0]).join(","), o = e.map((g, v) => g[0] + t[v]).join(","), l = Hr("rc", i), u = Hr("source", i), c = `${l[i - 1]} < ${this.outputShape[i - 1]}`, h = i === 1 ? "source" : `vec2(${u.slice(-2).join()})`, f = [
        `${a} rc = outputLoc;`,
        `${l[i - 1]} += 1;
       if(${c}) {
      `,
        i === 1 ? "" : `}
       rc = outputLoc;
       ${l[i - 2]} += 1;
       if(${l[i - 2]} < ${this.outputShape[i - 2]}) {`,
        i === 1 ? "" : `  ${l[i - 1]} += 1;
         if(${c}) {`
      ], d = i === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
      let p = "";
      for (let g = 0, v = i === 1 ? 2 : 4; g < v; g++) p += `
        ${f[g]}
        if (${d}) {
          result[${g}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${h});
        }
      `;
      p += i === 1 ? "} " : "}}", this.userCode = `
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `;
    }
  }
  const SJ = (n) => {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { paddings: a, constantValue: s } = r;
    if (lt(i.shape) === 0) {
      const u = a.map((c, h) => c[0] + i.shape[h] + c[1]);
      return gy({
        backend: e,
        attrs: {
          shape: u,
          value: s,
          dtype: i.dtype
        }
      });
    }
    const o = nt().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new VHt(i.shape, a, s) : new zHt(i.shape, a, s), l = [
      [
        s
      ]
    ];
    return e.runWebGLProgram(o, [
      i
    ], i.dtype, l);
  }, GHt = {
    kernelName: z_,
    backendName: "webgl",
    kernelFunc: SJ
  };
  const WHt = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`, UHt = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + kh + `
  return result;
`, HHt = Sr({
    opSnippet: WHt,
    packedOpSnippet: UHt
  }), XHt = {
    kernelName: Dm,
    backendName: "webgl",
    kernelFunc: HHt
  };
  function YHt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { axis: a, keepDims: s } = r, o = i.shape.length, l = [], u = Se(a, i.shape);
    let c = u;
    const h = wn(c, o);
    let f = i;
    h != null && (f = Jr({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: h
      }
    }), c = Rn(c.length, o), l.push(f)), wr("prod", c, o);
    let d;
    if (e.shouldExecuteOnCPU([
      f
    ])) {
      const p = e.texData.get(f.dataId).values, { outVals: g, outShape: v, outDtype: m } = Hzt(f.shape, f.dtype, p, c);
      d = e.makeTensorInfo(v, m, g);
    } else {
      const [p, g] = hr(f.shape, c), v = lt(g), m = Tt({
        inputs: {
          x: f
        },
        backend: e,
        attrs: {
          shape: [
            -1,
            v
          ]
        }
      }), y = OM(i.dtype), x = Dh(m, y, "prod", e);
      d = Tt({
        inputs: {
          x
        },
        backend: e,
        attrs: {
          shape: p
        }
      }), l.push(m), l.push(x);
    }
    if (s) {
      l.push(d);
      const p = Bn(d.shape, u);
      d = Tt({
        inputs: {
          x: d
        },
        backend: e,
        attrs: {
          shape: p
        }
      });
    }
    return l.forEach((p) => e.disposeIntermediateTensorInfo(p)), d;
  }
  const qHt = {
    kernelName: G_,
    backendName: "webgl",
    kernelFunc: YHt
  };
  function jHt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { paramsNestedSplits: i, paramsDenseValues: a, indices: s } = t, { outputRaggedRank: o } = r, l = i.map((m) => e.readSync(m.dataId)), u = i.map((m) => m.shape), c = e.readSync(a.dataId), h = e.readSync(s.dataId), [f, d, p] = Xzt(l, u, c, a.shape, a.dtype, h, s.shape, o), g = f.map((m) => e.makeTensorInfo([
      m.length
    ], "int32", m)), v = e.makeTensorInfo(p, a.dtype, d);
    return g.concat([
      v
    ]);
  }
  const KHt = {
    kernelName: iq,
    backendName: "webgl",
    kernelFunc: jHt
  };
  function ZHt(n) {
    const { inputs: t, backend: e } = n, { starts: r, limits: i, deltas: a } = t, s = e.readSync(r.dataId), o = e.readSync(i.dataId), l = e.readSync(a.dataId), [u, c] = Yzt(s, r.shape, r.dtype, o, i.shape, l, a.shape), h = e.makeTensorInfo([
      u.length
    ], "int32", u), f = e.makeTensorInfo([
      c.length
    ], r.dtype, c);
    return [
      h,
      f
    ];
  }
  const JHt = {
    kernelName: aq,
    backendName: "webgl",
    kernelFunc: ZHt
  };
  function QHt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { shape: i, values: a, defaultValue: s, rowPartitionTensors: o } = t, { rowPartitionTypes: l } = r, u = e.readSync(i.dataId), c = e.readSync(a.dataId), h = e.readSync(s.dataId), f = o.map((v) => e.readSync(v.dataId)), d = o.map((v) => v.shape), [p, g] = qzt(u, i.shape, c, a.shape, a.dtype, h, s.shape, f, d, l);
    return e.makeTensorInfo(p, a.dtype, g);
  }
  const t6t = {
    kernelName: sq,
    backendName: "webgl",
    kernelFunc: QHt
  };
  const CJ = (n) => {
    const { backend: t, attrs: e } = n, { start: r, stop: i, step: a, dtype: s } = e, o = jzt(r, i, a, s);
    return t.makeTensorInfo([
      o.length
    ], s, o);
  }, e6t = {
    kernelName: IM,
    backendName: "webgl",
    kernelFunc: CJ
  };
  const n6t = "return 1.0 / x;", r6t = Be({
    opSnippet: n6t
  }), i6t = {
    kernelName: Em,
    backendName: "webgl",
    kernelFunc: r6t
  };
  const a6t = La + `
  return (x < 0.0) ? 0.0 : x;
`, s6t = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, o6t = Be({
    opSnippet: a6t,
    packedOpSnippet: s6t
  }), l6t = {
    kernelName: Mm,
    backendName: "webgl",
    kernelFunc: o6t
  };
  const u6t = La + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, c6t = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, h6t = Be({
    opSnippet: u6t,
    packedOpSnippet: c6t
  }), f6t = {
    kernelName: Rm,
    backendName: "webgl",
    kernelFunc: h6t
  };
  class d6t {
    constructor(t, e, r, i, a) {
      this.variableNames = [
        "A"
      ], this.outputShape = [];
      const [s, o, l, u] = t;
      this.outputShape = [
        s,
        e,
        r,
        u
      ];
      const c = [
        i && e > 1 ? o - 1 : o,
        i && r > 1 ? l - 1 : l
      ], h = [
        i && e > 1 ? e - 1 : e,
        i && r > 1 ? r - 1 : r
      ];
      let f;
      a ? f = "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : f = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0] / h[0]},
          ${c[1] / h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
  }
  class p6t {
    constructor(t, e, r, i, a) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      const [s, o, l, u] = t;
      this.outputShape = [
        s,
        e,
        r,
        u
      ];
      const c = [
        i && e > 1 ? o - 1 : o,
        i && r > 1 ? l - 1 : l
      ], h = [
        i && e > 1 ? e - 1 : e,
        i && r > 1 ? r - 1 : r
      ];
      let f;
      a ? f = "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : f = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0] / h[0]},
          ${c[1] / h[1]},
          ${c[1] / h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u - 1};
        bool hasNextRow = coords.z < ${r - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
  }
  function g6t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { images: i } = t, { alignCorners: a, halfPixelCenters: s, size: o } = r, [l, u] = o, c = nt().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new p6t(i.shape, l, u, a, s) : new d6t(i.shape, l, u, a, s);
    return e.runWebGLProgram(c, [
      i
    ], "float32");
  }
  const v6t = {
    kernelName: H_,
    backendName: "webgl",
    kernelFunc: g6t
  };
  class m6t {
    constructor(t, e, r) {
      this.variableNames = [
        "dy"
      ], this.outputShape = [], this.outputShape = e;
      const [, i, a] = e, [, s, o] = t, l = [
        r && s > 1 ? i - 1 : i,
        r && o > 1 ? a - 1 : a
      ], u = [
        r && s > 1 ? s - 1 : s,
        r && o > 1 ? o - 1 : o
      ], c = l[0] / u[0], h = l[1] / u[1], f = 1 / c, d = 1 / h, p = Math.ceil(f) * 2 + 2, g = Math.ceil(d) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  }
  function y6t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { images: i, dy: a } = t, { alignCorners: s } = r, o = new m6t(a.shape, i.shape, s);
    return e.runWebGLProgram(o, [
      a
    ], a.dtype);
  }
  const x6t = {
    kernelName: DM,
    backendName: "webgl",
    kernelFunc: y6t
  };
  class b6t {
    constructor(t, e, r, i, a) {
      this.variableNames = [
        "A"
      ], this.outputShape = [];
      const [s, o, l, u] = t;
      this.outputShape = [
        s,
        e,
        r,
        u
      ];
      const c = [
        i && e > 1 ? o - 1 : o,
        i && r > 1 ? l - 1 : l
      ], h = [
        i && e > 1 ? e - 1 : e,
        i && r > 1 ? r - 1 : r
      ], f = i ? "0.5" : "0.0";
      let d;
      a ? d = "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : d = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0] / h[0]},
          ${c[1] / h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
  }
  class _6t {
    constructor(t, e, r, i, a) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      const [s, o, l, u] = t;
      this.outputShape = [
        s,
        e,
        r,
        u
      ];
      const c = [
        i && e > 1 ? o - 1 : o,
        i && r > 1 ? l - 1 : l
      ], h = [
        i && e > 1 ? e - 1 : e,
        i && r > 1 ? r - 1 : r
      ], f = i ? "0.5" : "0.0";
      let d;
      a ? d = "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : d = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0] / h[0]},
          ${c[1] / h[1]},
          ${c[1] / h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u - 1};
        bool hasNextRow = coords.z < ${r - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
  }
  function w6t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { images: i } = t, { alignCorners: a, halfPixelCenters: s, size: o } = r, [l, u] = o, c = nt().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new _6t(i.shape, l, u, a, s) : new b6t(i.shape, l, u, a, s);
    return e.runWebGLProgram(c, [
      i
    ], i.dtype);
  }
  const S6t = {
    kernelName: U_,
    backendName: "webgl",
    kernelFunc: w6t
  };
  class C6t {
    constructor(t, e, r) {
      this.variableNames = [
        "dy"
      ], this.outputShape = [], this.outputShape = e;
      const [, i, a] = e, [, s, o] = t, l = [
        r && s > 1 ? i - 1 : i,
        r && o > 1 ? a - 1 : a
      ], u = [
        r && s > 1 ? s - 1 : s,
        r && o > 1 ? o - 1 : o
      ], c = l[0] / u[0], h = l[1] / u[1], f = 1 / c, d = 1 / h, p = Math.ceil(f) * 2 + 2, g = Math.ceil(d) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  }
  function T6t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { images: i, dy: a } = t, { alignCorners: s } = r, o = new C6t(a.shape, i.shape, s);
    return e.runWebGLProgram(o, [
      a
    ], a.dtype);
  }
  const I6t = {
    kernelName: kM,
    backendName: "webgl",
    kernelFunc: T6t
  };
  class A6t {
    constructor(t, e) {
      this.variableNames = [
        "x"
      ];
      const r = t.length;
      if (r > 4) throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);
      if (this.outputShape = t, r === 1) {
        this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;
        return;
      }
      const i = (o) => e.indexOf(o) !== -1 && t[o] !== 1 ? `${t[o]} - coords[${o}] - 1` : `coords[${o}]`, a = t.map((o, l) => i(l)).join(","), s = sn(r);
      this.userCode = `
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `;
    }
  }
  class k6t {
    constructor(t, e) {
      this.variableNames = [
        "x"
      ], this.packedInputs = true, this.packedOutput = true;
      const r = t.length;
      if (r > 4) throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);
      this.outputShape = t;
      const i = Hr("rc", r), a = `${i[r - 1]} + 1 < ${this.outputShape[r - 1]}`, s = `${i[r - 2]} + 1 < ${this.outputShape[r - 2]}`, o = sn(r);
      r === 1 ? this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : this.userCode = `
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${a}){
            result.g = ${u(i.slice())};
          }
          if(${s}) {
            result.b = ${c(i.slice())};
            if(${a}) {
              result.a = ${h(i.slice())};
            }
          }
          setOutput(result);
        }
    `;
      function l(p) {
        return f(p);
      }
      function u(p) {
        return p[r - 1] = "(" + p[r - 1] + " + 1)", f(p);
      }
      function c(p) {
        return p[r - 2] = "(" + p[r - 2] + " + 1)", f(p);
      }
      function h(p) {
        return p[r - 1] = "(" + p[r - 1] + " + 1)", p[r - 2] = "(" + p[r - 2] + " + 1)", f(p);
      }
      function f(p) {
        const g = t.map((y, x) => d(x, p)), v = g.join(","), m = g.slice(-2).join(",");
        return `getChannel(getX(${v}), vec2(${m}))`;
      }
      function d(p, g) {
        return e.indexOf(p) !== -1 && t[p] !== 1 ? `${t[p]} - ${g[p]} - 1` : `${g[p]}`;
      }
    }
  }
  function D6t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { dims: a } = r, s = i.shape.length, o = Se(a, i.shape);
    if (s === 0) return Fi({
      inputs: {
        x: i
      },
      backend: e
    });
    const l = nt().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new k6t(i.shape, o) : new A6t(i.shape, o);
    return e.runWebGLProgram(l, [
      i
    ], i.dtype);
  }
  const E6t = {
    kernelName: X_,
    backendName: "webgl",
    kernelFunc: D6t
  };
  class M6t {
    constructor(t, e) {
      this.variableNames = [
        "Image"
      ], this.outputShape = [], this.customUniforms = [
        {
          name: "params",
          type: "vec4"
        }
      ];
      const r = t[1], i = t[2];
      this.outputShape = t;
      let a = "";
      typeof e == "number" ? a = `float outputValue = ${e.toFixed(2)};` : a = `
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  }
  const R6t = {
    kernelName: $M,
    backendName: "webgl",
    kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
      const { image: r } = n, { radians: i, fillValue: a, center: s } = t, o = e, l = new M6t(r.shape, a), [u, c] = SR(s, r.shape[1], r.shape[2]), h = [
        [
          u,
          c,
          Math.sin(i),
          Math.cos(i)
        ]
      ];
      return o.runWebGLProgram(l, [
        r
      ], r.dtype, h);
    }
  };
  const N6t = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`, L6t = Be({
    opSnippet: N6t
  }), P6t = {
    kernelName: Nm,
    backendName: "webgl",
    kernelFunc: L6t
  };
  const $6t = "return inversesqrt(x);", O6t = Be({
    opSnippet: $6t,
    cpuKernelImpl: Kzt
  }), F6t = {
    kernelName: Lm,
    backendName: "webgl",
    kernelFunc: O6t
  };
  class TN {
    constructor(t, e, r, i, a, s, o = true, l = false) {
      this.variableNames = [
        "updates",
        "indices",
        "defaultValue"
      ], this.outputShape = s;
      const u = sn(a.length), c = sn(s.length);
      let h = "";
      r === 1 ? h = "i" : r === 2 && (h = "i, j");
      const f = `getIndices(${h})`;
      let d = "";
      i === 1 ? d = "i" : i === 2 && (d = "i, coords[1]");
      const p = `getUpdates(${d})`;
      let g = "";
      l && (g = "coords[0], coords[1]");
      const v = `getDefaultValue(${g})`, m = e > 1 ? "strides[j]" : "strides";
      this.userCode = `
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${m};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `;
    }
  }
  class B6t {
    constructor(t, e, r, i, a, s, o = true, l = false) {
      this.variableNames = [
        "updates",
        "indices",
        "defaultValue"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = s;
      const u = sn(a.length), c = sn(s.length);
      let h = "";
      r === 1 ? h = "i" : r === 2 && (h = "i, j");
      const f = `getIndices(${h})`;
      let d = "";
      i === 1 ? d = "i" : i === 2 && (d = "i, coords[1]");
      const p = `getUpdates(${d})`;
      let g = "";
      l && (g = "coords[0], coords[1]");
      const v = `getDefaultValue(${g})`, m = e > 1 ? "strides[j]" : "strides", y = e > 1 ? "strides[j + 1]" : "strides";
      this.userCode = `
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${m};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `;
    }
  }
  function z6t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { indices: i, updates: a } = t, { shape: s } = r, { sliceRank: o, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Sh(a, i, s), f = [
      h / u,
      u
    ];
    if (h === 0) return e.makeTensorInfo(s, i.dtype);
    const d = Tt({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: [
          l,
          o
        ]
      }
    }), p = Tt({
      inputs: {
        x: a
      },
      backend: e,
      attrs: {
        shape: [
          l,
          u
        ]
      }
    }), g = e.makeTensorInfo([], "float32", new Float32Array([
      0
    ]));
    let v;
    nt().getBool("WEBGL_PACK") ? v = new B6t(l, o, d.shape.length, p.shape.length, c, f) : v = new TN(l, o, d.shape.length, p.shape.length, c, f);
    const m = e.runWebGLProgram(v, [
      p,
      d,
      g
    ], p.dtype), y = Tt({
      inputs: {
        x: m
      },
      backend: e,
      attrs: {
        shape: s
      }
    });
    return e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(p), e.disposeIntermediateTensorInfo(m), e.disposeIntermediateTensorInfo(g), y;
  }
  const V6t = {
    kernelName: oq,
    backendName: "webgl",
    kernelFunc: z6t
  };
  class G6t {
    constructor(t, e, r, i) {
      this.variableNames = [
        "sortedSequence",
        "values"
      ], this.customUniforms = [
        {
          name: "numInputs",
          type: "int"
        }
      ], this.outputShape = [
        t,
        r
      ];
      const a = "while (left < right) {", s = `for (int i = 0; i < ${Math.ceil(Math.log2(e + 1))}; ++i) { if (left >= right) break;`, o = nt().getNumber("WEBGL_VERSION") === 2 ? a : s, l = i === "left" ? "<" : "<=";
      this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
    }
  }
  function W6t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { sortedSequence: i, values: a } = t, { side: s } = r, o = new G6t(i.shape[0], i.shape[1], a.shape[1], s), l = [
      [
        i.shape[1]
      ]
    ];
    return e.runWebGLProgram(o, [
      i,
      a
    ], "int32", l);
  }
  const U6t = {
    kernelName: uq,
    backendName: "webgl",
    kernelFunc: W6t
  };
  class H6t {
    constructor(t, e, r) {
      this.variableNames = [
        "c",
        "a",
        "b"
      ], this.outputShape = e;
      let i, a;
      if (r > 4) throw Error(`Where for rank ${r} is not yet supported`);
      if (r === 1) a = "resRC", i = "resRC";
      else {
        const o = [
          "resRC.x",
          "resRC.y",
          "resRC.z",
          "resRC.w"
        ], l = [], u = [];
        for (let c = 0; c < e.length; c++) u.push(`${o[c]}`), c < t && l.push(`${o[c]}`);
        i = l.join(), a = u.join();
      }
      const s = sn(r);
      this.userCode = `
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `;
    }
  }
  function X6t(n) {
    const { inputs: t, backend: e } = n, { condition: r, t: i, e: a } = t, s = new H6t(r.shape.length, i.shape, i.shape.length);
    return e.runWebGLProgram(s, [
      r,
      i,
      a
    ], $i(i.dtype, a.dtype));
  }
  const Y6t = {
    kernelName: Y_,
    backendName: "webgl",
    kernelFunc: X6t
  };
  const q6t = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${pw};
  float scale = ${gw};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`, j6t = Be({
    opSnippet: q6t
  }), K6t = {
    kernelName: Pm,
    backendName: "webgl",
    kernelFunc: j6t
  };
  const Z6t = Yd + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`, J6t = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, Q6t = Be({
    opSnippet: Z6t,
    packedOpSnippet: J6t,
    cpuKernelImpl: Jzt
  }), t8t = {
    kernelName: Bm,
    backendName: "webgl",
    kernelFunc: Q6t
  };
  const e8t = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`, n8t = Be({
    opSnippet: e8t
  }), r8t = {
    kernelName: Fm,
    backendName: "webgl",
    kernelFunc: n8t
  };
  const i8t = Yd + `
  return sin(x);
`, a8t = `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${kh}
  return result;
`, s8t = Be({
    opSnippet: i8t,
    packedOpSnippet: a8t
  }), o8t = {
    kernelName: $m,
    backendName: "webgl",
    kernelFunc: s8t
  };
  const l8t = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`, u8t = Be({
    opSnippet: l8t
  }), c8t = {
    kernelName: Om,
    backendName: "webgl",
    kernelFunc: u8t
  };
  const h8t = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`, f8t = Be({
    opSnippet: h8t
  }), d8t = {
    kernelName: zm,
    backendName: "webgl",
    kernelFunc: f8t
  };
  const p8t = (n) => {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { blockShape: a, paddings: s } = r;
    B(i.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    const o = a.reduce((m, y) => m * y), l = [
      [
        0,
        0
      ]
    ];
    l.push(...s);
    for (let m = 1 + a.length; m < i.shape.length; ++m) l.push([
      0,
      0
    ]);
    const u = [], c = SJ({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        paddings: l,
        constantValue: 0
      }
    }), h = Qm(c.shape, a, o, false), f = ty(h.length, a.length, false), d = ey(c.shape, a, o, false), p = Tt({
      inputs: {
        x: c
      },
      backend: e,
      attrs: {
        shape: h
      }
    }), g = Jr({
      inputs: {
        x: p
      },
      backend: e,
      attrs: {
        perm: f
      }
    }), v = Tt({
      inputs: {
        x: g
      },
      backend: e,
      attrs: {
        shape: d
      }
    });
    return u.push(c), u.push(p), u.push(g), u.forEach((m) => e.disposeIntermediateTensorInfo(m)), v;
  }, g8t = {
    kernelName: K_,
    backendName: "webgl",
    kernelFunc: p8t
  };
  function v8t(n) {
    const { inputs: t, backend: e } = n, { indices: r, values: i, denseShape: a, defaultValue: s } = t;
    if (a.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);
    if (r.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Values must be a vector, saw:
         ${i.shape}`);
    if (s.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${s.shape}`);
    const o = e.readSync(r.dataId), l = e.readSync(i.dataId), u = e.readSync(a.dataId), c = e.readSync(s.dataId)[0], [h, f, d, p, g] = tVt(o, r.shape, r.dtype, l, i.dtype, u, c);
    return [
      e.makeTensorInfo(f, r.dtype, h),
      e.makeTensorInfo([
        f[0]
      ], i.dtype, d),
      e.makeTensorInfo([
        p.length
      ], "bool", new Uint8Array(p.map((v) => Number(v)))),
      e.makeTensorInfo([
        g.length
      ], r.dtype, new Int32Array(g))
    ];
  }
  const m8t = {
    kernelName: cq,
    backendName: "webgl",
    kernelFunc: v8t
  };
  function y8t(n) {
    const { inputs: t, backend: e } = n, { inputIndices: r, inputShape: i, newShape: a } = t;
    if (r.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${a.shape}`);
    const s = Array.from(e.readSync(i.dataId)), o = e.readSync(r.dataId), l = Array.from(e.readSync(a.dataId)), [u, c, h] = eVt(o, r.shape, r.dtype, s, l);
    return [
      e.makeTensorInfo(c, r.dtype, u),
      e.makeTensorInfo([
        h.length
      ], a.dtype, new Int32Array(h))
    ];
  }
  const x8t = {
    kernelName: hq,
    backendName: "webgl",
    kernelFunc: y8t
  };
  function b8t(n) {
    const { inputs: t, backend: e } = n, { data: r, indices: i, segmentIds: a } = t;
    if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (i.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);
    const s = e.readSync(r.dataId), o = e.readSync(i.dataId), l = e.readSync(a.dataId), [u, c] = qZ(s, r.shape, r.dtype, o, l, true);
    return e.makeTensorInfo(c, r.dtype, u);
  }
  const _8t = {
    kernelName: fq,
    backendName: "webgl",
    kernelFunc: b8t
  };
  function w8t(n) {
    const { inputs: t, backend: e } = n, { data: r, indices: i, segmentIds: a } = t;
    if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (i.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);
    const s = e.readSync(r.dataId), o = e.readSync(i.dataId), l = e.readSync(a.dataId), [u, c] = qZ(s, r.shape, r.dtype, o, l);
    return e.makeTensorInfo(c, r.dtype, u);
  }
  const S8t = {
    kernelName: dq,
    backendName: "webgl",
    kernelFunc: w8t
  };
  function C8t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { sparseIndices: i, sparseValues: a, defaultValue: s } = t, { outputShape: o } = r, { sliceRank: l, numUpdates: u, sliceSize: c, strides: h, outputSize: f } = Sh(a, i, o), d = false;
    if (a.dtype === "string") {
      const m = e.bufferSync(i), y = e.bufferSync(a), x = tu(e.readSync(s.dataId)[0]), b = Zzt(m, y, o, f, c, u, l, h, x, d);
      return e.makeTensorInfo(o, b.dtype, b.values);
    }
    const p = new TN(u, l, i.shape.length, a.shape.length, h, [
      f,
      1
    ], d), g = e.runWebGLProgram(p, [
      a,
      i,
      s
    ], a.dtype), v = Tt({
      inputs: {
        x: g
      },
      backend: e,
      attrs: {
        shape: o
      }
    });
    return e.disposeIntermediateTensorInfo(g), v;
  }
  const T8t = {
    kernelName: pq,
    backendName: "webgl",
    kernelFunc: C8t
  };
  function I8t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { numOrSizeSplits: a, axis: s } = r, o = Se(s, i.shape)[0], l = FR(i, a, o), u = i.shape.length, c = new Array(u).fill(0), h = i.shape.slice();
    return l.map((f) => {
      const d = [
        ...h
      ];
      d[o] = f;
      const p = qd({
        inputs: {
          x: i
        },
        backend: e,
        attrs: {
          begin: c,
          size: d
        }
      });
      return c[o] += f, p;
    });
  }
  const A8t = {
    kernelName: Z_,
    backendName: "webgl",
    kernelFunc: I8t
  };
  const fG = "return sqrt(x);", k8t = Be({
    opSnippet: fG,
    packedOpSnippet: fG,
    cpuKernelImpl: nVt
  }), D8t = {
    kernelName: Vm,
    backendName: "webgl",
    kernelFunc: k8t
  };
  const E8t = "return x * x;", M8t = Be({
    opSnippet: E8t
  }), R8t = {
    kernelName: EM,
    backendName: "webgl",
    kernelFunc: M8t
  };
  const dG = "return (a - b) * (a - b);", N8t = Sr({
    opSnippet: dG,
    packedOpSnippet: dG
  }), L8t = {
    kernelName: Gm,
    backendName: "webgl",
    kernelFunc: N8t
  };
  function P8t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t;
    if (i.dtype !== "string") throw new Error("Input must be of datatype string");
    const a = e.readSync(i.dataId), s = Zo(a), o = rVt(s, "string", r);
    return e.makeTensorInfo(i.shape, "string", o);
  }
  const $8t = {
    kernelName: MM,
    backendName: "webgl",
    kernelFunc: P8t
  };
  function O8t({ inputs: n, attrs: t, backend: e }) {
    const { x: r } = n, i = La + `
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `, a = new Gs(r.shape, i);
    return e.runWebGLProgram(a, [
      r
    ], r.dtype);
  }
  const F8t = {
    kernelName: Ym,
    backendName: "webgl",
    kernelFunc: O8t
  };
  class B8t {
    constructor(t, e, r) {
      this.variableNames = [
        "x"
      ], this.outputShape = r;
      const i = r.length, a = sn(r.length), s = sn(r.length);
      let o = "";
      if (i === 1) o = "coords * strides + begin";
      else {
        let l = 0;
        o = r.map((u, c) => (l++, r.length === 1 ? `coords * strides[${c}] + begin[${c}]` : `coords[${l - 1}] * strides[${c}] + begin[${c}]`)).join(",");
      }
      this.userCode = `
      ${a} begin = ${a}(${t});
      ${a} strides = ${a}(${e});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `;
    }
  }
  function z8t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { begin: a, end: s, strides: o, beginMask: l, endMask: u, ellipsisMask: c, newAxisMask: h, shrinkAxisMask: f } = r, { finalShapeSparse: d, finalShape: p, isIdentity: g, sliceDim0: v, isSimpleSlice: m, begin: y, end: x, strides: b } = bR(i.shape, a, s, o, l, u, c, h, f);
    let _;
    if (g) _ = Tt({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: p
      }
    });
    else if (v || m) {
      B(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
      const S = mR(y, x, b), I = qd({
        inputs: {
          x: i
        },
        backend: e,
        attrs: {
          begin: y,
          size: S
        }
      });
      _ = Tt({
        inputs: {
          x: I
        },
        backend: e,
        attrs: {
          shape: p
        }
      }), e.disposeIntermediateTensorInfo(I);
    } else if (e.shouldExecuteOnCPU([
      i
    ])) {
      const I = e.readSync(i.dataId), T = we(i.shape, i.dtype, I), A = iVt(d, T, b, y);
      _ = e.makeTensorInfo(p, i.dtype, A.values);
    } else {
      const I = new B8t(y, b, d);
      _ = e.runWebGLProgram(I, [
        i
      ], i.dtype);
    }
    const w = Tt({
      inputs: {
        x: _
      },
      backend: e,
      attrs: {
        shape: p
      }
    });
    return e.disposeIntermediateTensorInfo(_), w;
  }
  const V8t = {
    kernelName: RM,
    backendName: "webgl",
    kernelFunc: z8t
  };
  function G8t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { separator: i, nGramWidths: a, leftPad: s, rightPad: o, padWidth: l, preserveShortSequences: u } = r, { data: c, dataSplits: h } = t, f = e.readSync(c.dataId), d = e.readSync(h.dataId), [p, g] = aVt(f, d, i, a, s, o, l, u);
    return [
      e.makeTensorInfo([
        p.length
      ], "string", p),
      e.makeTensorInfo(h.shape, "int32", g)
    ];
  }
  const W8t = {
    kernelName: gq,
    backendName: "webgl",
    kernelFunc: G8t
  };
  function U8t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { skipEmpty: i } = r, { input: a, delimiter: s } = t;
    if (a.dtype !== "string") throw new Error("Input must be of datatype string");
    if (a.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${a.shape}`);
    if (s.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);
    const o = e.readSync(a.dataId), l = e.readSync(s.dataId)[0], [u, c, h] = sVt(o, l, i), f = c.length;
    return [
      e.makeTensorInfo([
        f,
        2
      ], "int32", u),
      e.makeTensorInfo([
        f
      ], "string", c),
      e.makeTensorInfo([
        2
      ], "int32", new Int32Array(h))
    ];
  }
  const H8t = {
    kernelName: vq,
    backendName: "webgl",
    kernelFunc: U8t
  };
  function X8t(n) {
    const { inputs: t, backend: e, attrs: r } = n, { numBuckets: i } = r, { input: a } = t;
    if (a.dtype !== "string") throw new Error("Input must be of datatype string");
    if (i <= 0) throw new Error("Number of buckets must be at least 1");
    const s = e.readSync(a.dataId), o = oVt(s, i);
    return e.makeTensorInfo(a.shape, "int32", o);
  }
  const Y8t = {
    kernelName: mq,
    backendName: "webgl",
    kernelFunc: X8t
  };
  const q8t = "return tan(x);", j8t = Be({
    opSnippet: q8t
  }), K8t = {
    kernelName: Um,
    backendName: "webgl",
    kernelFunc: j8t
  };
  const Z8t = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`, J8t = Be({
    opSnippet: Z8t
  }), Q8t = {
    kernelName: Hm,
    backendName: "webgl",
    kernelFunc: J8t
  };
  function tXt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { tensor: i, indices: a, updates: s } = t, { sliceRank: o, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Sh(s, a, i.shape), f = [
      h / u,
      u
    ];
    if (h === 0) return e.makeTensorInfo(i.shape, a.dtype);
    const d = Tt({
      inputs: {
        x: a
      },
      backend: e,
      attrs: {
        shape: [
          l,
          o
        ]
      }
    }), p = Tt({
      inputs: {
        x: s
      },
      backend: e,
      attrs: {
        shape: [
          l,
          u
        ]
      }
    }), g = Tt({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: f
      }
    }), v = new TN(l, o, d.shape.length, p.shape.length, c, f, false, true), m = e.runWebGLProgram(v, [
      p,
      d,
      g
    ], g.dtype), y = Tt({
      inputs: {
        x: m
      },
      backend: e,
      attrs: {
        shape: i.shape
      }
    });
    return e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(p), e.disposeIntermediateTensorInfo(g), e.disposeIntermediateTensorInfo(m), y;
  }
  const eXt = {
    kernelName: lq,
    backendName: "webgl",
    kernelFunc: tXt
  };
  class nXt {
    constructor(t, e) {
      this.variableNames = [
        "A"
      ];
      const r = new Array(t.length);
      for (let s = 0; s < r.length; s++) r[s] = t[s] * e[s];
      this.outputShape = r, this.rank = r.length;
      const i = sn(this.rank), a = rXt(t);
      this.userCode = `
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `;
    }
  }
  function rXt(n) {
    const t = n.length;
    if (t > 5) throw Error(`Tile for rank ${t} is not yet supported`);
    if (t === 1) return `imod(resRC, ${n[0]})`;
    const e = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w",
      "resRC.u"
    ], r = [];
    for (let i = 0; i < n.length; i++) r.push(`imod(${e[i]}, ${n[i]})`);
    return r.join();
  }
  function TJ(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { reps: a } = r;
    if (i.dtype === "string" || i.shape.length > 5) {
      const l = e.readSync(i.dataId), u = i.dtype === "string" ? l.map((f) => tu(f)) : l, c = we(i.shape, i.dtype, u), h = uVt(c, a);
      return e.makeTensorInfo(h.shape, h.dtype, h.values);
    }
    const s = new nXt(i.shape, a);
    return e.runWebGLProgram(s, [
      i
    ], i.dtype);
  }
  const iXt = {
    kernelName: Xm,
    backendName: "webgl",
    kernelFunc: TJ
  };
  class aXt {
    constructor(t) {
      this.variableNames = [
        "x",
        "indices"
      ], this.customUniforms = [
        {
          name: "n",
          type: "int"
        },
        {
          name: "firstPass",
          type: "int"
        },
        {
          name: "negativeInf",
          type: "float"
        },
        {
          name: "dir",
          type: "int"
        },
        {
          name: "inc",
          type: "int"
        }
      ], this.outputShape = t, this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
  }
  class sXt {
    constructor(t) {
      this.variableNames = [
        "x",
        "indices"
      ], this.customUniforms = [
        {
          name: "n",
          type: "int"
        },
        {
          name: "firstPass",
          type: "int"
        },
        {
          name: "k",
          type: "int"
        }
      ], this.outputShape = t, this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
  }
  function Yu(n, t) {
    t !== null && n.disposeIntermediateTensorInfo(t);
  }
  function pG(n) {
    let t = 1;
    for (; t < n; ) t *= 2;
    return t;
  }
  function oXt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i } = t, { k: a, sorted: s } = r, o = nt().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), l = nt().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), u = i.shape, c = u[u.length - 1];
    if (e.shouldExecuteOnCPU([
      i
    ]) || c < o || a > l) {
      const A = e.readSync(i.dataId), [C, D] = cVt(A, u, i.dtype, a, s);
      return [
        e.makeTensorInfo(C.shape, C.dtype, C.values),
        e.makeTensorInfo(D.shape, D.dtype, D.values)
      ];
    }
    if (a === 0) return u[u.length - 1] = 0, [
      e.makeTensorInfo(u, i.dtype, []),
      e.makeTensorInfo(u, "int32", [])
    ];
    if (c === 1) return [
      i,
      gy({
        attrs: {
          shape: u,
          dtype: "int32",
          value: 0
        },
        backend: e
      })
    ];
    const h = e.texData.get(i.dataId), f = h !== null && h.isPacked, d = f ? e.unpackTensor(i) : i, g = lt(u) / c, v = Tt({
      inputs: {
        x: d
      },
      attrs: {
        shape: [
          g,
          c
        ]
      },
      backend: e
    });
    f && Yu(e, d);
    const m = pG(a), y = pG(c);
    let x = null;
    const b = () => x === null ? [
      v,
      v
    ] : [
      v,
      x
    ], _ = (A, C, D) => {
      const E = b(), M = new aXt(D), k = [
        [
          c
        ],
        [
          x === null ? 1 : 0
        ],
        [
          Number.NEGATIVE_INFINITY
        ],
        [
          A
        ],
        [
          C
        ]
      ], N = x;
      x = e.runWebGLProgram(M, E, "int32", k), Yu(e, N);
    };
    for (let A = 1; A < m; A *= 2) {
      const C = A * 2;
      for (let D = A; D >= 1; D /= 2) _(C, D, [
        g,
        y
      ]);
    }
    for (let A = y; A > m; A /= 2) {
      const C = b(), D = new sXt([
        g,
        A / 2
      ]), M = [
        [
          c
        ],
        [
          x === null ? 1 : 0
        ],
        [
          m
        ]
      ], L = x;
      x = e.runWebGLProgram(D, C, "int32", M), Yu(e, L);
      const k = m / 2, N = k * 2;
      for (let R = k; R >= 1; R /= 2) _(N, R, x.shape);
    }
    let w = x;
    x = qd({
      inputs: {
        x
      },
      backend: e,
      attrs: {
        begin: 0,
        size: [
          g,
          a
        ]
      }
    }), Yu(e, w);
    let S = mJ({
      inputs: {
        x: v,
        indices: x
      },
      backend: e,
      attrs: {
        axis: 1,
        batchDims: 1
      }
    });
    Yu(e, v);
    const I = u.slice(0, -1);
    I.push(a), w = x, x = Tt({
      inputs: {
        x
      },
      attrs: {
        shape: I
      },
      backend: e
    }), Yu(e, w);
    const T = S;
    return S = Tt({
      inputs: {
        x: S
      },
      attrs: {
        shape: I
      },
      backend: e
    }), Yu(e, T), [
      S,
      x
    ];
  }
  const lXt = {
    kernelName: NM,
    backendName: "webgl",
    kernelFunc: oXt
  };
  class uXt {
    constructor(t, e, r, i, a, s) {
      this.variableNames = [
        "Image",
        "Transforms"
      ], this.outputShape = s;
      const o = r === "nearest" ? 1 : 2;
      let l;
      switch (i) {
        case "constant":
          l = 1;
          break;
        case "reflect":
          l = 2;
          break;
        case "wrap":
          l = 3;
          break;
        case "nearest":
          l = 4;
          break;
        default:
          l = 1;
          break;
      }
      this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
  }
  function cXt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { image: i, transforms: a } = t, { interpolation: s, fillMode: o, fillValue: l, outputShape: u } = r, [c, h, f, d] = i.shape, [p, g] = u ?? [
      h,
      f
    ], v = [
      c,
      p,
      g,
      d
    ], m = new uXt(h, f, s, o, l, v);
    return e.runWebGLProgram(m, [
      i,
      a
    ], "float32");
  }
  const hXt = {
    kernelName: LM,
    backendName: "webgl",
    kernelFunc: cXt
  };
  function fXt(n) {
    const { inputs: t, attrs: e, backend: r } = n, { axis: i } = e, { x: a } = t;
    fy(a, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    const s = r.readSync(a.dataId), { outputValues: o, outputShape: l, indices: u } = hVt(s, i, a.shape, a.dtype);
    return [
      r.makeTensorInfo(l, a.dtype, o),
      r.makeTensorInfo([
        u.length
      ], "int32", u)
    ];
  }
  const dXt = {
    kernelName: PM,
    backendName: "webgl",
    kernelFunc: fXt
  };
  function pXt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { value: i } = t;
    let { axis: a } = r;
    a < 0 && (a += i.shape.length);
    const s = i, o = s.shape.length, l = i.shape[a], u = new Array(o - 1);
    let c = 0;
    for (let g = 0; g < o; g++) g !== a && (u[c++] = s.shape[g]);
    const h = [], f = new Array(o).fill(0), d = s.shape.slice();
    d[a] = 1;
    const p = new Array(l);
    for (let g = 0; g < p.length; g++) {
      f[a] = g;
      const v = qd({
        inputs: {
          x: s
        },
        backend: e,
        attrs: {
          begin: f,
          size: d
        }
      }), m = Tt({
        inputs: {
          x: v
        },
        backend: e,
        attrs: {
          shape: u
        }
      });
      p[g] = m, h.push(v);
    }
    return h.forEach((g) => e.disposeIntermediateTensorInfo(g)), p;
  }
  const gXt = {
    kernelName: Q_,
    backendName: "webgl",
    kernelFunc: pXt
  };
  class vXt {
    constructor(t, e) {
      this.variableNames = [
        "x",
        "segmentIds"
      ];
      const r = t.windowSize, i = t.batchSize, a = t.inSize, s = t.numSegments, o = s * Math.ceil(a / r);
      this.outputShape = [
        i,
        o
      ];
      const l = "0.0", u = "sumValue", c = Math.floor(r / 4) * 4, h = r % 4, f = `
        sumValue += dot(values, segFilter);
    `;
      let d = "";
      a % r > 0 && (d = `
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);
      let p = "";
      a % r > 0 && (p = `
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${h === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${h === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${h === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${u});
      }
    `;
    }
  }
  function mXt(n) {
    const { inputs: t, backend: e, attrs: r } = n, { x: i, segmentIds: a } = t, { numSegments: s } = r, o = i.shape.length, l = [];
    let u = 0;
    const c = wn([
      u
    ], o);
    let h = i;
    c != null && (h = Jr({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        perm: c
      }
    }), l.push(h), u = Rn(1, o)[0]);
    const f = s7(h.shape, u, s), d = lt([
      h.shape[u]
    ]), p = Tt({
      inputs: {
        x: h
      },
      backend: e,
      attrs: {
        shape: [
          -1,
          d
        ]
      }
    });
    l.push(p);
    const g = OM(i.dtype), v = (b, _, w, S, I) => {
      const T = b.shape[0], A = b.shape[1], C = a7(A, I), D = {
        windowSize: C,
        inSize: A,
        batchSize: T,
        numSegments: I
      }, E = new vXt(D, _), M = e.compileAndRun(E, [
        b,
        w
      ], S);
      if (l.push(M), M.shape[1] === I) return M;
      const L = CJ({
        backend: e,
        attrs: {
          start: 0,
          stop: I,
          step: 1,
          dtype: "float32"
        }
      }), k = TJ({
        inputs: {
          x: L
        },
        backend: e,
        attrs: {
          reps: [
            A / C
          ]
        }
      });
      return l.push(L), l.push(k), v(M, _, k, S, I);
    }, m = v(p, "unsortedSegmentSum", a, g, s), y = Tt({
      inputs: {
        x: m
      },
      backend: e,
      attrs: {
        shape: f
      }
    });
    let x = y;
    if (c != null) {
      l.push(y);
      const b = hu(c);
      x = Jr({
        inputs: {
          x
        },
        backend: e,
        attrs: {
          perm: b
        }
      });
    }
    return l.forEach((b) => e.disposeIntermediateTensorInfo(b)), x;
  }
  const yXt = {
    kernelName: tw,
    backendName: "webgl",
    kernelFunc: mXt
  };
  const xXt = [
    nGt,
    iGt,
    oGt,
    cGt,
    fGt,
    gGt,
    mGt,
    xGt,
    SGt,
    TGt,
    kGt,
    MGt,
    LGt,
    FGt,
    VGt,
    WGt,
    HGt,
    jGt,
    ZGt,
    QGt,
    r4t,
    c4t,
    f4t,
    v4t,
    y4t,
    C4t,
    I4t,
    E4t,
    BVt,
    N4t,
    F4t,
    G4t,
    q4t,
    Z4t,
    Q4t,
    eWt,
    rWt,
    oWt,
    cWt,
    dWt,
    gWt,
    mWt,
    xWt,
    wWt,
    CWt,
    kWt,
    EWt,
    NWt,
    $Wt,
    FWt,
    GWt,
    XWt,
    KWt,
    QWt,
    nUt,
    rUt,
    aUt,
    oUt,
    uUt,
    hUt,
    dUt,
    mUt,
    bUt,
    SUt,
    TUt,
    kUt,
    MUt,
    PUt,
    BUt,
    FVt,
    VUt,
    $4t,
    UUt,
    YUt,
    KUt,
    VVt,
    t5t,
    i5t,
    s5t,
    c5t,
    d5t,
    m5t,
    b5t,
    C5t,
    k5t,
    M5t,
    N5t,
    O5t,
    B5t,
    V5t,
    H5t,
    Y5t,
    j5t,
    Z5t,
    Q5t,
    rHt,
    oHt,
    hHt,
    xHt,
    UVt,
    SHt,
    IHt,
    DHt,
    RHt,
    b4t,
    PHt,
    OHt,
    BHt,
    GHt,
    XHt,
    WVt,
    qHt,
    KHt,
    JHt,
    t6t,
    e6t,
    _4t,
    gHt,
    i6t,
    l6t,
    f6t,
    XVt,
    v6t,
    x6t,
    S6t,
    I6t,
    E6t,
    R6t,
    P6t,
    F6t,
    V6t,
    U6t,
    Y6t,
    K6t,
    t8t,
    r8t,
    o8t,
    c8t,
    l4t,
    mHt,
    d8t,
    g8t,
    m8t,
    x8t,
    _8t,
    S8t,
    T8t,
    A8t,
    D8t,
    R8t,
    L8t,
    $8t,
    F8t,
    V8t,
    W8t,
    H8t,
    Y8t,
    vHt,
    QVt,
    K8t,
    Q8t,
    eXt,
    iXt,
    lXt,
    hXt,
    tGt,
    dXt,
    gXt,
    yXt,
    $Ht
  ];
  for (const n of xXt) xq(n);
  function bXt(n) {
    return new Worker("/tfjs_model_tester/assets/detect.worker-CxeD56_M.js", {
      name: n == null ? void 0 : n.name
    });
  }
  var ng = ((n) => (n.detect = "detect", n.stop = "stop", n.loadModel = "loadModel", n.disposeModel = "disposeModel", n.testRun = "testRun", n))(ng || {});
  class IJ {
    constructor(t) {
      __publicField(this, "_canvas");
      __publicField(this, "onSelect");
      this._canvas = t;
    }
  }
  class gG {
    constructor() {
      __publicField(this, "palette");
      __publicField(this, "n");
      __publicField(this, "get", (t) => this.palette[Math.floor(t) % this.n]);
      this.palette = [
        "#FF3838",
        "#FF9D97",
        "#FF701F",
        "#FFB21D",
        "#CFD231",
        "#48F90A",
        "#92CC17",
        "#3DDB86",
        "#1A9334",
        "#00D4BB",
        "#2C99A8",
        "#00C2FF",
        "#344593",
        "#6473FF",
        "#0018EC",
        "#8438FF",
        "#520085",
        "#CB38FF",
        "#FF95C8",
        "#FF37C7"
      ], this.n = this.palette.length;
    }
  }
  __publicField(gG, "hexToRgba", (t, e) => {
    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
    return r ? `rgba(${[
      parseInt(r[1], 16),
      parseInt(r[2], 16),
      parseInt(r[3], 16)
    ].join(", ")}, ${e})` : null;
  });
  class _Xt extends IJ {
    init() {
      throw new Error("Method not implemented.");
    }
    render(t, e, r, i, a) {
      throw new Error("Method not implemented.");
    }
    clear() {
      throw new Error("Method not implemented.");
    }
    dispose() {
      throw new Error("Method not implemented.");
    }
    capture(t) {
      throw new Error("Method not implemented.");
    }
  }
  rn = ((n) => (n.Application = "application", n.WebGLPipes = "webgl-pipes", n.WebGLPipesAdaptor = "webgl-pipes-adaptor", n.WebGLSystem = "webgl-system", n.WebGPUPipes = "webgpu-pipes", n.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", n.WebGPUSystem = "webgpu-system", n.CanvasSystem = "canvas-system", n.CanvasPipesAdaptor = "canvas-pipes-adaptor", n.CanvasPipes = "canvas-pipes", n.Asset = "asset", n.LoadParser = "load-parser", n.ResolveParser = "resolve-parser", n.CacheParser = "cache-parser", n.DetectionParser = "detection-parser", n.MaskEffect = "mask-effect", n.BlendMode = "blend-mode", n.TextureSource = "texture-source", n.Environment = "environment", n.ShapeBuilder = "shape-builder", n.Batcher = "batcher", n))(rn || {});
  let j2, P0, wXt, SXt;
  j2 = (n) => {
    if (typeof n == "function" || typeof n == "object" && n.extension) {
      if (!n.extension) throw new Error("Extension class must have an extension object");
      n = {
        ...typeof n.extension != "object" ? {
          type: n.extension
        } : n.extension,
        ref: n
      };
    }
    if (typeof n == "object") n = {
      ...n
    };
    else throw new Error("Invalid extension type");
    return typeof n.type == "string" && (n.type = [
      n.type
    ]), n;
  };
  P0 = (n, t) => j2(n).priority ?? t;
  Pa = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...n) {
      return n.map(j2).forEach((t) => {
        t.type.forEach((e) => {
          var _a2, _b2;
          return (_b2 = (_a2 = this._removeHandlers)[e]) == null ? void 0 : _b2.call(_a2, t);
        });
      }), this;
    },
    add(...n) {
      return n.map(j2).forEach((t) => {
        t.type.forEach((e) => {
          var _a2, _b2;
          const r = this._addHandlers, i = this._queue;
          r[e] ? (_a2 = r[e]) == null ? void 0 : _a2.call(r, t) : (i[e] = i[e] || [], (_b2 = i[e]) == null ? void 0 : _b2.push(t));
        });
      }), this;
    },
    handle(n, t, e) {
      var _a2;
      const r = this._addHandlers, i = this._removeHandlers;
      if (r[n] || i[n]) throw new Error(`Extension type ${n} already has a handler`);
      r[n] = t, i[n] = e;
      const a = this._queue;
      return a[n] && ((_a2 = a[n]) == null ? void 0 : _a2.forEach((s) => t(s)), delete a[n]), this;
    },
    handleByMap(n, t) {
      return this.handle(n, (e) => {
        e.name && (t[e.name] = e.ref);
      }, (e) => {
        e.name && delete t[e.name];
      });
    },
    handleByNamedList(n, t, e = -1) {
      return this.handle(n, (r) => {
        t.findIndex((a) => a.name === r.name) >= 0 || (t.push({
          name: r.name,
          value: r.ref
        }), t.sort((a, s) => P0(s.value, e) - P0(a.value, e)));
      }, (r) => {
        const i = t.findIndex((a) => a.name === r.name);
        i !== -1 && t.splice(i, 1);
      });
    },
    handleByList(n, t, e = -1) {
      return this.handle(n, (r) => {
        t.includes(r.ref) || (t.push(r.ref), t.sort((i, a) => P0(a, e) - P0(i, e)));
      }, (r) => {
        const i = t.indexOf(r.ref);
        i !== -1 && t.splice(i, 1);
      });
    },
    mixin(n, ...t) {
      for (const e of t) Object.defineProperties(n.prototype, Object.getOwnPropertyDescriptors(e));
    }
  };
  wXt = {
    extension: {
      type: rn.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await Bf(() => import("./browserAll-DcNQBVkE.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([0,1,2,3,4,5]));
    }
  };
  SXt = {
    extension: {
      type: rn.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await Bf(() => import("./webworkerAll-BbyK6mNU.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([1,2,3,4,5]));
    }
  };
  class Ii {
    constructor(t, e, r) {
      this._x = e || 0, this._y = r || 0, this._observer = t;
    }
    clone(t) {
      return new Ii(t ?? this._observer, this._x, this._y);
    }
    set(t = 0, e = t) {
      return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
    }
    copyFrom(t) {
      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
    }
    copyTo(t) {
      return t.set(this._x, this._y), t;
    }
    equals(t) {
      return t.x === this._x && t.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x !== t && (this._x = t, this._observer._onUpdate(this));
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y !== t && (this._y = t, this._observer._onUpdate(this));
    }
  }
  var RT = {
    exports: {}
  }, vG;
  function CXt() {
    return vG || (vG = 1, function(n) {
      var t = Object.prototype.hasOwnProperty, e = "~";
      function r() {
      }
      Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = false));
      function i(l, u, c) {
        this.fn = l, this.context = u, this.once = c || false;
      }
      function a(l, u, c, h, f) {
        if (typeof c != "function") throw new TypeError("The listener must be a function");
        var d = new i(c, h || l, f), p = e ? e + u : u;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [
          l._events[p],
          d
        ] : l._events[p].push(d) : (l._events[p] = d, l._eventsCount++), l;
      }
      function s(l, u) {
        --l._eventsCount === 0 ? l._events = new r() : delete l._events[u];
      }
      function o() {
        this._events = new r(), this._eventsCount = 0;
      }
      o.prototype.eventNames = function() {
        var u = [], c, h;
        if (this._eventsCount === 0) return u;
        for (h in c = this._events) t.call(c, h) && u.push(e ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u;
      }, o.prototype.listeners = function(u) {
        var c = e ? e + u : u, h = this._events[c];
        if (!h) return [];
        if (h.fn) return [
          h.fn
        ];
        for (var f = 0, d = h.length, p = new Array(d); f < d; f++) p[f] = h[f].fn;
        return p;
      }, o.prototype.listenerCount = function(u) {
        var c = e ? e + u : u, h = this._events[c];
        return h ? h.fn ? 1 : h.length : 0;
      }, o.prototype.emit = function(u, c, h, f, d, p) {
        var g = e ? e + u : u;
        if (!this._events[g]) return false;
        var v = this._events[g], m = arguments.length, y, x;
        if (v.fn) {
          switch (v.once && this.removeListener(u, v.fn, void 0, true), m) {
            case 1:
              return v.fn.call(v.context), true;
            case 2:
              return v.fn.call(v.context, c), true;
            case 3:
              return v.fn.call(v.context, c, h), true;
            case 4:
              return v.fn.call(v.context, c, h, f), true;
            case 5:
              return v.fn.call(v.context, c, h, f, d), true;
            case 6:
              return v.fn.call(v.context, c, h, f, d, p), true;
          }
          for (x = 1, y = new Array(m - 1); x < m; x++) y[x - 1] = arguments[x];
          v.fn.apply(v.context, y);
        } else {
          var b = v.length, _;
          for (x = 0; x < b; x++) switch (v[x].once && this.removeListener(u, v[x].fn, void 0, true), m) {
            case 1:
              v[x].fn.call(v[x].context);
              break;
            case 2:
              v[x].fn.call(v[x].context, c);
              break;
            case 3:
              v[x].fn.call(v[x].context, c, h);
              break;
            case 4:
              v[x].fn.call(v[x].context, c, h, f);
              break;
            default:
              if (!y) for (_ = 1, y = new Array(m - 1); _ < m; _++) y[_ - 1] = arguments[_];
              v[x].fn.apply(v[x].context, y);
          }
        }
        return true;
      }, o.prototype.on = function(u, c, h) {
        return a(this, u, c, h, false);
      }, o.prototype.once = function(u, c, h) {
        return a(this, u, c, h, true);
      }, o.prototype.removeListener = function(u, c, h, f) {
        var d = e ? e + u : u;
        if (!this._events[d]) return this;
        if (!c) return s(this, d), this;
        var p = this._events[d];
        if (p.fn) p.fn === c && (!f || p.once) && (!h || p.context === h) && s(this, d);
        else {
          for (var g = 0, v = [], m = p.length; g < m; g++) (p[g].fn !== c || f && !p[g].once || h && p[g].context !== h) && v.push(p[g]);
          v.length ? this._events[d] = v.length === 1 ? v[0] : v : s(this, d);
        }
        return this;
      }, o.prototype.removeAllListeners = function(u) {
        var c;
        return u ? (c = e ? e + u : u, this._events[c] && s(this, c)) : (this._events = new r(), this._eventsCount = 0), this;
      }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = e, o.EventEmitter = o, n.exports = o;
    }(RT)), RT.exports;
  }
  var TXt = CXt();
  let IXt, AXt, kXt;
  po = nw(TXt);
  IXt = Math.PI * 2;
  AXt = 180 / Math.PI;
  kXt = Math.PI / 180;
  Xr = class {
    constructor(t = 0, e = 0) {
      this.x = 0, this.y = 0, this.x = t, this.y = e;
    }
    clone() {
      return new Xr(this.x, this.y);
    }
    copyFrom(t) {
      return this.set(t.x, t.y), this;
    }
    copyTo(t) {
      return t.set(this.x, this.y), t;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    set(t = 0, e = t) {
      return this.x = t, this.y = e, this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
      return NT.x = 0, NT.y = 0, NT;
    }
  };
  const NT = new Xr();
  Ve = class {
    constructor(t = 1, e = 0, r = 0, i = 1, a = 0, s = 0) {
      this.array = null, this.a = t, this.b = e, this.c = r, this.d = i, this.tx = a, this.ty = s;
    }
    fromArray(t) {
      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
    }
    set(t, e, r, i, a, s) {
      return this.a = t, this.b = e, this.c = r, this.d = i, this.tx = a, this.ty = s, this;
    }
    toArray(t, e) {
      this.array || (this.array = new Float32Array(9));
      const r = e || this.array;
      return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
    }
    apply(t, e) {
      e = e || new Xr();
      const r = t.x, i = t.y;
      return e.x = this.a * r + this.c * i + this.tx, e.y = this.b * r + this.d * i + this.ty, e;
    }
    applyInverse(t, e) {
      e = e || new Xr();
      const r = this.a, i = this.b, a = this.c, s = this.d, o = this.tx, l = this.ty, u = 1 / (r * s + a * -i), c = t.x, h = t.y;
      return e.x = s * u * c + -a * u * h + (l * a - o * s) * u, e.y = r * u * h + -i * u * c + (-l * r + o * i) * u, e;
    }
    translate(t, e) {
      return this.tx += t, this.ty += e, this;
    }
    scale(t, e) {
      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
    }
    rotate(t) {
      const e = Math.cos(t), r = Math.sin(t), i = this.a, a = this.c, s = this.tx;
      return this.a = i * e - this.b * r, this.b = i * r + this.b * e, this.c = a * e - this.d * r, this.d = a * r + this.d * e, this.tx = s * e - this.ty * r, this.ty = s * r + this.ty * e, this;
    }
    append(t) {
      const e = this.a, r = this.b, i = this.c, a = this.d;
      return this.a = t.a * e + t.b * i, this.b = t.a * r + t.b * a, this.c = t.c * e + t.d * i, this.d = t.c * r + t.d * a, this.tx = t.tx * e + t.ty * i + this.tx, this.ty = t.tx * r + t.ty * a + this.ty, this;
    }
    appendFrom(t, e) {
      const r = t.a, i = t.b, a = t.c, s = t.d, o = t.tx, l = t.ty, u = e.a, c = e.b, h = e.c, f = e.d;
      return this.a = r * u + i * h, this.b = r * c + i * f, this.c = a * u + s * h, this.d = a * c + s * f, this.tx = o * u + l * h + e.tx, this.ty = o * c + l * f + e.ty, this;
    }
    setTransform(t, e, r, i, a, s, o, l, u) {
      return this.a = Math.cos(o + u) * a, this.b = Math.sin(o + u) * a, this.c = -Math.sin(o - l) * s, this.d = Math.cos(o - l) * s, this.tx = t - (r * this.a + i * this.c), this.ty = e - (r * this.b + i * this.d), this;
    }
    prepend(t) {
      const e = this.tx;
      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
        const r = this.a, i = this.c;
        this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d;
      }
      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
    }
    decompose(t) {
      const e = this.a, r = this.b, i = this.c, a = this.d, s = t.pivot, o = -Math.atan2(-i, a), l = Math.atan2(r, e), u = Math.abs(o + l);
      return u < 1e-5 || Math.abs(IXt - u) < 1e-5 ? (t.rotation = l, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = l), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(i * i + a * a), t.position.x = this.tx + (s.x * e + s.y * i), t.position.y = this.ty + (s.x * r + s.y * a), t;
    }
    invert() {
      const t = this.a, e = this.b, r = this.c, i = this.d, a = this.tx, s = t * i - e * r;
      return this.a = i / s, this.b = -e / s, this.c = -r / s, this.d = t / s, this.tx = (r * this.ty - i * a) / s, this.ty = -(t * this.ty - e * a) / s, this;
    }
    isIdentity() {
      return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    identity() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }
    clone() {
      const t = new Ve();
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }
    copyTo(t) {
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }
    copyFrom(t) {
      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
    }
    equals(t) {
      return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return EXt.identity();
    }
    static get shared() {
      return DXt.identity();
    }
  };
  const DXt = new Ve(), EXt = new Ve(), ac = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1
  ], sc = [
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], oc = [
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], lc = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1
  ], K2 = [], AJ = [], $0 = Math.sign;
  function MXt() {
    for (let n = 0; n < 16; n++) {
      const t = [];
      K2.push(t);
      for (let e = 0; e < 16; e++) {
        const r = $0(ac[n] * ac[e] + oc[n] * sc[e]), i = $0(sc[n] * ac[e] + lc[n] * sc[e]), a = $0(ac[n] * oc[e] + oc[n] * lc[e]), s = $0(sc[n] * oc[e] + lc[n] * lc[e]);
        for (let o = 0; o < 16; o++) if (ac[o] === r && sc[o] === i && oc[o] === a && lc[o] === s) {
          t.push(o);
          break;
        }
      }
    }
    for (let n = 0; n < 16; n++) {
      const t = new Ve();
      t.set(ac[n], sc[n], oc[n], lc[n], 0, 0), AJ.push(t);
    }
  }
  MXt();
  const Sn = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (n) => ac[n],
    uY: (n) => sc[n],
    vX: (n) => oc[n],
    vY: (n) => lc[n],
    inv: (n) => n & 8 ? n & 15 : -n & 7,
    add: (n, t) => K2[n][t],
    sub: (n, t) => K2[n][Sn.inv(t)],
    rotate180: (n) => n ^ 4,
    isVertical: (n) => (n & 3) === 2,
    byDirection: (n, t) => Math.abs(n) * 2 <= Math.abs(t) ? t >= 0 ? Sn.S : Sn.N : Math.abs(t) * 2 <= Math.abs(n) ? n > 0 ? Sn.E : Sn.W : t > 0 ? n > 0 ? Sn.SE : Sn.SW : n > 0 ? Sn.NE : Sn.NW,
    matrixAppendRotationInv: (n, t, e = 0, r = 0) => {
      const i = AJ[Sn.inv(t)];
      i.tx = e, i.ty = r, n.append(i);
    }
  }, O0 = [
    new Xr(),
    new Xr(),
    new Xr(),
    new Xr()
  ];
  yr = class {
    constructor(t = 0, e = 0, r = 0, i = 0) {
      this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(i);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new yr(0, 0, 0, 0);
    }
    clone() {
      return new yr(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(t) {
      return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    contains(t, e) {
      return this.width <= 0 || this.height <= 0 ? false : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
    }
    strokeContains(t, e, r, i = 0.5) {
      const { width: a, height: s } = this;
      if (a <= 0 || s <= 0) return false;
      const o = this.x, l = this.y, u = r * (1 - i), c = r - u, h = o - u, f = o + a + u, d = l - u, p = l + s + u, g = o + c, v = o + a - c, m = l + c, y = l + s - c;
      return t >= h && t <= f && e >= d && e <= p && !(t > g && t < v && e > m && e < y);
    }
    intersects(t, e) {
      if (!e) {
        const I = this.x < t.x ? t.x : this.x;
        if ((this.right > t.right ? t.right : this.right) <= I) return false;
        const A = this.y < t.y ? t.y : this.y;
        return (this.bottom > t.bottom ? t.bottom : this.bottom) > A;
      }
      const r = this.left, i = this.right, a = this.top, s = this.bottom;
      if (i <= r || s <= a) return false;
      const o = O0[0].set(t.left, t.top), l = O0[1].set(t.left, t.bottom), u = O0[2].set(t.right, t.top), c = O0[3].set(t.right, t.bottom);
      if (u.x <= o.x || l.y <= o.y) return false;
      const h = Math.sign(e.a * e.d - e.b * e.c);
      if (h === 0 || (e.apply(o, o), e.apply(l, l), e.apply(u, u), e.apply(c, c), Math.max(o.x, l.x, u.x, c.x) <= r || Math.min(o.x, l.x, u.x, c.x) >= i || Math.max(o.y, l.y, u.y, c.y) <= a || Math.min(o.y, l.y, u.y, c.y) >= s)) return false;
      const f = h * (l.y - o.y), d = h * (o.x - l.x), p = f * r + d * a, g = f * i + d * a, v = f * r + d * s, m = f * i + d * s;
      if (Math.max(p, g, v, m) <= f * o.x + d * o.y || Math.min(p, g, v, m) >= f * c.x + d * c.y) return false;
      const y = h * (o.y - u.y), x = h * (u.x - o.x), b = y * r + x * a, _ = y * i + x * a, w = y * r + x * s, S = y * i + x * s;
      return !(Math.max(b, _, w, S) <= y * o.x + x * o.y || Math.min(b, _, w, S) >= y * c.x + x * c.y);
    }
    pad(t = 0, e = t) {
      return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
    }
    fit(t) {
      const e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), i = Math.max(this.y, t.y), a = Math.min(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = Math.max(r - e, 0), this.y = i, this.height = Math.max(a - i, 0), this;
    }
    ceil(t = 1, e = 1e-3) {
      const r = Math.ceil((this.x + this.width - e) * t) / t, i = Math.ceil((this.y + this.height - e) * t) / t;
      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = i - this.y, this;
    }
    enlarge(t) {
      const e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), i = Math.min(this.y, t.y), a = Math.max(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = r - e, this.y = i, this.height = a - i, this;
    }
    getBounds(t) {
      return t || (t = new yr()), t.copyFrom(this), t;
    }
    containsRect(t) {
      if (this.width <= 0 || this.height <= 0) return false;
      const e = t.x, r = t.y, i = t.x + t.width, a = t.y + t.height;
      return e >= this.x && e < this.x + this.width && r >= this.y && r < this.y + this.height && i >= this.x && i < this.x + this.width && a >= this.y && a < this.y + this.height;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };
  const LT = {
    default: -1
  };
  Yn = function(n = "default") {
    return LT[n] === void 0 && (LT[n] = -1), ++LT[n];
  };
  let mG, RXt;
  mG = {};
  An = "8.0.0";
  RXt = "8.3.4";
  fn = function(n, t, e = 3) {
    if (mG[t]) return;
    let r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${n}`) : (r = r.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${n}`), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${n}`), console.warn(r))), mG[t] = true;
  };
  const kJ = () => {
  };
  yG = function(n) {
    return n += n === 0 ? 1 : 0, --n, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n + 1;
  };
  function xG(n) {
    return !(n & n - 1) && !!n;
  }
  function DJ(n) {
    const t = {};
    for (const e in n) n[e] !== void 0 && (t[e] = n[e]);
    return t;
  }
  const bG = /* @__PURE__ */ Object.create(null);
  function NXt(n) {
    const t = bG[n];
    return t === void 0 && (bG[n] = Yn("resource")), t;
  }
  const EJ = class MJ extends po {
    constructor(t = {}) {
      super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = false, t = {
        ...MJ.defaultOptions,
        ...t
      }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
    }
    set addressMode(t) {
      this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(t) {
      fn(An, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(t) {
      this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(t) {
      this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this), this._sharedResourceId = null;
    }
    _generateResourceId() {
      const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      return this._sharedResourceId = NXt(t), this._resourceId;
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
    }
  };
  EJ.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  LXt = EJ;
  const RJ = class NJ extends po {
    constructor(t = {}) {
      super(), this.options = t, this.uid = Yn("textureSource"), this._resourceType = "textureSource", this._resourceId = Yn("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = false, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = false, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = {
        ...NJ.defaultOptions,
        ...t
      }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new LXt(DJ(t)), this.destroyed = false, this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(t) {
      var _a2, _b2;
      this.style !== t && ((_a2 = this._style) == null ? void 0 : _a2.off("change", this._onStyleChange, this), this._style = t, (_b2 = this._style) == null ? void 0 : _b2.on("change", this._onStyleChange, this), this._onStyleChange());
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(t) {
      this._style.addressMode = t;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(t) {
      this._style.addressMode = t;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(t) {
      this._style.magFilter = t;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(t) {
      this._style.minFilter = t;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(t) {
      this._style.mipmapFilter = t;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(t) {
      this._style.lodMinClamp = t;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(t) {
      this._style.lodMaxClamp = t;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const t = this._resolution;
        if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return;
      }
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
    }
    unload() {
      this._resourceId = Yn("resource"), this.emit("change", this), this.emit("unload", this);
    }
    get resourceWidth() {
      const { resource: t } = this;
      return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
    }
    get resourceHeight() {
      const { resource: t } = this;
      return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(t) {
      this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
    }
    resize(t, e, r) {
      r || (r = this._resolution), t || (t = this.width), e || (e = this.height);
      const i = Math.round(t * r), a = Math.round(e * r);
      return this.width = i / r, this.height = a / r, this._resolution = r, this.pixelWidth === i && this.pixelHeight === a ? false : (this._refreshPOT(), this.pixelWidth = i, this.pixelHeight = a, this.emit("resize", this), this._resourceId = Yn("resource"), this.emit("change", this), true);
    }
    updateMipmaps() {
      this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
    }
    set wrapMode(t) {
      this._style.wrapMode = t;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(t) {
      this._style.scaleMode = t;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = xG(this.pixelWidth) && xG(this.pixelHeight);
    }
    static test(t) {
      throw new Error("Unimplemented");
    }
  };
  RJ.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
    autoGarbageCollect: false
  };
  gs = RJ;
  class IN extends gs {
    constructor(t) {
      const e = t.resource || new Float32Array(t.width * t.height * 4);
      let r = t.format;
      r || (e instanceof Float32Array ? r = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? r = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? r = "rgba16uint" : (e instanceof Int8Array, r = "bgra8unorm")), super({
        ...t,
        resource: e,
        format: r
      }), this.uploadMethodId = "buffer";
    }
    static test(t) {
      return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
    }
  }
  IN.extension = rn.TextureSource;
  const _G = new Ve();
  PXt = class {
    constructor(t, e) {
      this.mapCoord = new Ve(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : 0.5 : this.clampMargin = e, this.isSimple = false, this.texture = t;
    }
    get texture() {
      return this._texture;
    }
    set texture(t) {
      var _a2;
      this.texture !== t && ((_a2 = this._texture) == null ? void 0 : _a2.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
    }
    multiplyUvs(t, e) {
      e === void 0 && (e = t);
      const r = this.mapCoord;
      for (let i = 0; i < t.length; i += 2) {
        const a = t[i], s = t[i + 1];
        e[i] = a * r.a + s * r.c + r.tx, e[i + 1] = a * r.b + s * r.d + r.ty;
      }
      return e;
    }
    update() {
      const t = this._texture;
      this._updateID++;
      const e = t.uvs;
      this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
      const r = t.orig, i = t.trim;
      i && (_G.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(_G));
      const a = t.source, s = this.uClampFrame, o = this.clampMargin / a._resolution, l = this.clampOffset / a._resolution;
      return s[0] = (t.frame.x + o + l) / a.width, s[1] = (t.frame.y + o + l) / a.height, s[2] = (t.frame.x + t.frame.width - o + l) / a.width, s[3] = (t.frame.y + t.frame.height - o + l) / a.height, this.uClampOffset[0] = this.clampOffset / a.pixelWidth, this.uClampOffset[1] = this.clampOffset / a.pixelHeight, this.isSimple = t.frame.width === a.width && t.frame.height === a.height && t.rotate === 0, true;
    }
  };
  on = class extends po {
    constructor({ source: t, label: e, frame: r, orig: i, trim: a, defaultAnchor: s, defaultBorders: o, rotate: l, dynamic: u } = {}) {
      if (super(), this.uid = Yn("texture"), this.uvs = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        x3: 0,
        y3: 0
      }, this.frame = new yr(), this.noFrame = false, this.dynamic = false, this.isTexture = true, this.label = e, this.source = (t == null ? void 0 : t.source) ?? new gs(), this.noFrame = !r, r) this.frame.copyFrom(r);
      else {
        const { width: c, height: h } = this._source;
        this.frame.width = c, this.frame.height = h;
      }
      this.orig = i || this.frame, this.trim = a, this.rotate = l ?? 0, this.defaultAnchor = s, this.defaultBorders = o, this.destroyed = false, this.dynamic = u || false, this.updateUvs();
    }
    set source(t) {
      this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      return this._textureMatrix || (this._textureMatrix = new PXt(this)), this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const { uvs: t, frame: e } = this, { width: r, height: i } = this._source, a = e.x / r, s = e.y / i, o = e.width / r, l = e.height / i;
      let u = this.rotate;
      if (u) {
        const c = o / 2, h = l / 2, f = a + c, d = s + h;
        u = Sn.add(u, Sn.NW), t.x0 = f + c * Sn.uX(u), t.y0 = d + h * Sn.uY(u), u = Sn.add(u, 2), t.x1 = f + c * Sn.uX(u), t.y1 = d + h * Sn.uY(u), u = Sn.add(u, 2), t.x2 = f + c * Sn.uX(u), t.y2 = d + h * Sn.uY(u), u = Sn.add(u, 2), t.x3 = f + c * Sn.uX(u), t.y3 = d + h * Sn.uY(u);
      } else t.x0 = a, t.y0 = s, t.x1 = a + o, t.y1 = s, t.x2 = a + o, t.y2 = s + l, t.x3 = a, t.y3 = s + l;
    }
    destroy(t = false) {
      this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = true, this.emit("destroy", this), this.removeAllListeners();
    }
    update() {
      this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
    }
    get baseTexture() {
      return fn(An, "Texture.baseTexture is now Texture.source"), this._source;
    }
  };
  on.EMPTY = new on({
    label: "EMPTY",
    source: new gs({
      label: "EMPTY"
    })
  });
  on.EMPTY.destroy = kJ;
  on.WHITE = new on({
    source: new IN({
      resource: new Uint8Array([
        255,
        255,
        255,
        255
      ]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  on.WHITE.destroy = kJ;
  $Xt = function(n, t, e) {
    const { width: r, height: i } = e.orig, a = e.trim;
    if (a) {
      const s = a.width, o = a.height;
      n.minX = a.x - t._x * r, n.maxX = n.minX + s, n.minY = a.y - t._y * i, n.maxY = n.minY + o;
    } else n.minX = -t._x * r, n.maxX = n.minX + r, n.minY = -t._y * i, n.maxY = n.minY + i;
  };
  const wG = new Ve();
  hs = class {
    constructor(t = 1 / 0, e = 1 / 0, r = -1 / 0, i = -1 / 0) {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = wG, this.minX = t, this.minY = e, this.maxX = r, this.maxY = i;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      this._rectangle || (this._rectangle = new yr());
      const t = this._rectangle;
      return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
    }
    clear() {
      return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = wG, this;
    }
    set(t, e, r, i) {
      this.minX = t, this.minY = e, this.maxX = r, this.maxY = i;
    }
    addFrame(t, e, r, i, a) {
      a || (a = this.matrix);
      const s = a.a, o = a.b, l = a.c, u = a.d, c = a.tx, h = a.ty;
      let f = this.minX, d = this.minY, p = this.maxX, g = this.maxY, v = s * t + l * e + c, m = o * t + u * e + h;
      v < f && (f = v), m < d && (d = m), v > p && (p = v), m > g && (g = m), v = s * r + l * e + c, m = o * r + u * e + h, v < f && (f = v), m < d && (d = m), v > p && (p = v), m > g && (g = m), v = s * t + l * i + c, m = o * t + u * i + h, v < f && (f = v), m < d && (d = m), v > p && (p = v), m > g && (g = m), v = s * r + l * i + c, m = o * r + u * i + h, v < f && (f = v), m < d && (d = m), v > p && (p = v), m > g && (g = m), this.minX = f, this.minY = d, this.maxX = p, this.maxY = g;
    }
    addRect(t, e) {
      this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
    }
    addBounds(t, e) {
      this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
    }
    addBoundsMask(t) {
      this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
    }
    applyMatrix(t) {
      const e = this.minX, r = this.minY, i = this.maxX, a = this.maxY, { a: s, b: o, c: l, d: u, tx: c, ty: h } = t;
      let f = s * e + l * r + c, d = o * e + u * r + h;
      this.minX = f, this.minY = d, this.maxX = f, this.maxY = d, f = s * i + l * r + c, d = o * i + u * r + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, f = s * e + l * a + c, d = o * e + u * a + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, f = s * i + l * a + c, d = o * i + u * a + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY;
    }
    fit(t) {
      return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
    }
    fitBounds(t, e, r, i) {
      return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < r && (this.minY = r), this.maxY > i && (this.maxY = i), this;
    }
    pad(t, e = t) {
      return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
    }
    ceil() {
      return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
    }
    clone() {
      return new hs(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(t, e = t) {
      return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
    }
    get x() {
      return this.minX;
    }
    set x(t) {
      const e = this.maxX - this.minX;
      this.minX = t, this.maxX = t + e;
    }
    get y() {
      return this.minY;
    }
    set y(t) {
      const e = this.maxY - this.minY;
      this.minY = t, this.maxY = t + e;
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(t) {
      this.maxX = this.minX + t;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(t) {
      this.maxY = this.minY + t;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== 1 / 0;
    }
    addVertexData(t, e, r, i) {
      let a = this.minX, s = this.minY, o = this.maxX, l = this.maxY;
      i || (i = this.matrix);
      const u = i.a, c = i.b, h = i.c, f = i.d, d = i.tx, p = i.ty;
      for (let g = e; g < r; g += 2) {
        const v = t[g], m = t[g + 1], y = u * v + h * m + d, x = c * v + f * m + p;
        a = y < a ? y : a, s = x < s ? x : s, o = y > o ? y : o, l = x > l ? x : l;
      }
      this.minX = a, this.minY = s, this.maxX = o, this.maxY = l;
    }
    containsPoint(t, e) {
      return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    copyFrom(t) {
      return this.minX = t.minX, this.minY = t.minY, this.maxX = t.maxX, this.maxY = t.maxY, this;
    }
  };
  var OXt = {
    grad: 0.9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  }, yo = function(n) {
    return typeof n == "string" ? n.length > 0 : typeof n == "number";
  }, gr = function(n, t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * n) / e + 0;
  }, Ca = function(n, t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = 1), n > e ? e : n > t ? n : t;
  }, LJ = function(n) {
    return (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360;
  }, SG = function(n) {
    return {
      r: Ca(n.r, 0, 255),
      g: Ca(n.g, 0, 255),
      b: Ca(n.b, 0, 255),
      a: Ca(n.a)
    };
  }, PT = function(n) {
    return {
      r: gr(n.r),
      g: gr(n.g),
      b: gr(n.b),
      a: gr(n.a, 3)
    };
  }, FXt = /^#([0-9a-f]{3,8})$/i, F0 = function(n) {
    var t = n.toString(16);
    return t.length < 2 ? "0" + t : t;
  }, PJ = function(n) {
    var t = n.r, e = n.g, r = n.b, i = n.a, a = Math.max(t, e, r), s = a - Math.min(t, e, r), o = s ? a === t ? (e - r) / s : a === e ? 2 + (r - t) / s : 4 + (t - e) / s : 0;
    return {
      h: 60 * (o < 0 ? o + 6 : o),
      s: a ? s / a * 100 : 0,
      v: a / 255 * 100,
      a: i
    };
  }, $J = function(n) {
    var t = n.h, e = n.s, r = n.v, i = n.a;
    t = t / 360 * 6, e /= 100, r /= 100;
    var a = Math.floor(t), s = r * (1 - e), o = r * (1 - (t - a) * e), l = r * (1 - (1 - t + a) * e), u = a % 6;
    return {
      r: 255 * [
        r,
        o,
        s,
        s,
        l,
        r
      ][u],
      g: 255 * [
        l,
        r,
        r,
        o,
        s,
        s
      ][u],
      b: 255 * [
        s,
        s,
        l,
        r,
        r,
        o
      ][u],
      a: i
    };
  }, CG = function(n) {
    return {
      h: LJ(n.h),
      s: Ca(n.s, 0, 100),
      l: Ca(n.l, 0, 100),
      a: Ca(n.a)
    };
  }, TG = function(n) {
    return {
      h: gr(n.h),
      s: gr(n.s),
      l: gr(n.l),
      a: gr(n.a, 3)
    };
  }, IG = function(n) {
    return $J((e = (t = n).s, {
      h: t.h,
      s: (e *= ((r = t.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * e / (r + e) * 100 : 0,
      v: r + e,
      a: t.a
    }));
    var t, e, r;
  }, Cg = function(n) {
    return {
      h: (t = PJ(n)).h,
      s: (i = (200 - (e = t.s)) * (r = t.v) / 100) > 0 && i < 200 ? e * r / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
      l: i / 2,
      a: t.a
    };
    var t, e, r, i;
  }, BXt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, zXt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, VXt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, GXt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Z2 = {
    string: [
      [
        function(n) {
          var t = FXt.exec(n);
          return t ? (n = t[1]).length <= 4 ? {
            r: parseInt(n[0] + n[0], 16),
            g: parseInt(n[1] + n[1], 16),
            b: parseInt(n[2] + n[2], 16),
            a: n.length === 4 ? gr(parseInt(n[3] + n[3], 16) / 255, 2) : 1
          } : n.length === 6 || n.length === 8 ? {
            r: parseInt(n.substr(0, 2), 16),
            g: parseInt(n.substr(2, 2), 16),
            b: parseInt(n.substr(4, 2), 16),
            a: n.length === 8 ? gr(parseInt(n.substr(6, 2), 16) / 255, 2) : 1
          } : null : null;
        },
        "hex"
      ],
      [
        function(n) {
          var t = VXt.exec(n) || GXt.exec(n);
          return t ? t[2] !== t[4] || t[4] !== t[6] ? null : SG({
            r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
            g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
            b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
            a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
          }) : null;
        },
        "rgb"
      ],
      [
        function(n) {
          var t = BXt.exec(n) || zXt.exec(n);
          if (!t) return null;
          var e, r, i = CG({
            h: (e = t[1], r = t[2], r === void 0 && (r = "deg"), Number(e) * (OXt[r] || 1)),
            s: Number(t[3]),
            l: Number(t[4]),
            a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
          });
          return IG(i);
        },
        "hsl"
      ]
    ],
    object: [
      [
        function(n) {
          var t = n.r, e = n.g, r = n.b, i = n.a, a = i === void 0 ? 1 : i;
          return yo(t) && yo(e) && yo(r) ? SG({
            r: Number(t),
            g: Number(e),
            b: Number(r),
            a: Number(a)
          }) : null;
        },
        "rgb"
      ],
      [
        function(n) {
          var t = n.h, e = n.s, r = n.l, i = n.a, a = i === void 0 ? 1 : i;
          if (!yo(t) || !yo(e) || !yo(r)) return null;
          var s = CG({
            h: Number(t),
            s: Number(e),
            l: Number(r),
            a: Number(a)
          });
          return IG(s);
        },
        "hsl"
      ],
      [
        function(n) {
          var t = n.h, e = n.s, r = n.v, i = n.a, a = i === void 0 ? 1 : i;
          if (!yo(t) || !yo(e) || !yo(r)) return null;
          var s = function(o) {
            return {
              h: LJ(o.h),
              s: Ca(o.s, 0, 100),
              v: Ca(o.v, 0, 100),
              a: Ca(o.a)
            };
          }({
            h: Number(t),
            s: Number(e),
            v: Number(r),
            a: Number(a)
          });
          return $J(s);
        },
        "hsv"
      ]
    ]
  }, AG = function(n, t) {
    for (var e = 0; e < t.length; e++) {
      var r = t[e][0](n);
      if (r) return [
        r,
        t[e][1]
      ];
    }
    return [
      null,
      void 0
    ];
  }, WXt = function(n) {
    return typeof n == "string" ? AG(n.trim(), Z2.string) : typeof n == "object" && n !== null ? AG(n, Z2.object) : [
      null,
      void 0
    ];
  }, $T = function(n, t) {
    var e = Cg(n);
    return {
      h: e.h,
      s: Ca(e.s + 100 * t, 0, 100),
      l: e.l,
      a: e.a
    };
  }, OT = function(n) {
    return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3 / 255;
  }, kG = function(n, t) {
    var e = Cg(n);
    return {
      h: e.h,
      s: e.s,
      l: Ca(e.l + 100 * t, 0, 100),
      a: e.a
    };
  }, J2 = function() {
    function n(t) {
      this.parsed = WXt(t)[0], this.rgba = this.parsed || {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      };
    }
    return n.prototype.isValid = function() {
      return this.parsed !== null;
    }, n.prototype.brightness = function() {
      return gr(OT(this.rgba), 2);
    }, n.prototype.isDark = function() {
      return OT(this.rgba) < 0.5;
    }, n.prototype.isLight = function() {
      return OT(this.rgba) >= 0.5;
    }, n.prototype.toHex = function() {
      return t = PT(this.rgba), e = t.r, r = t.g, i = t.b, s = (a = t.a) < 1 ? F0(gr(255 * a)) : "", "#" + F0(e) + F0(r) + F0(i) + s;
      var t, e, r, i, a, s;
    }, n.prototype.toRgb = function() {
      return PT(this.rgba);
    }, n.prototype.toRgbString = function() {
      return t = PT(this.rgba), e = t.r, r = t.g, i = t.b, (a = t.a) < 1 ? "rgba(" + e + ", " + r + ", " + i + ", " + a + ")" : "rgb(" + e + ", " + r + ", " + i + ")";
      var t, e, r, i, a;
    }, n.prototype.toHsl = function() {
      return TG(Cg(this.rgba));
    }, n.prototype.toHslString = function() {
      return t = TG(Cg(this.rgba)), e = t.h, r = t.s, i = t.l, (a = t.a) < 1 ? "hsla(" + e + ", " + r + "%, " + i + "%, " + a + ")" : "hsl(" + e + ", " + r + "%, " + i + "%)";
      var t, e, r, i, a;
    }, n.prototype.toHsv = function() {
      return t = PJ(this.rgba), {
        h: gr(t.h),
        s: gr(t.s),
        v: gr(t.v),
        a: gr(t.a, 3)
      };
      var t;
    }, n.prototype.invert = function() {
      return ks({
        r: 255 - (t = this.rgba).r,
        g: 255 - t.g,
        b: 255 - t.b,
        a: t.a
      });
      var t;
    }, n.prototype.saturate = function(t) {
      return t === void 0 && (t = 0.1), ks($T(this.rgba, t));
    }, n.prototype.desaturate = function(t) {
      return t === void 0 && (t = 0.1), ks($T(this.rgba, -t));
    }, n.prototype.grayscale = function() {
      return ks($T(this.rgba, -1));
    }, n.prototype.lighten = function(t) {
      return t === void 0 && (t = 0.1), ks(kG(this.rgba, t));
    }, n.prototype.darken = function(t) {
      return t === void 0 && (t = 0.1), ks(kG(this.rgba, -t));
    }, n.prototype.rotate = function(t) {
      return t === void 0 && (t = 15), this.hue(this.hue() + t);
    }, n.prototype.alpha = function(t) {
      return typeof t == "number" ? ks({
        r: (e = this.rgba).r,
        g: e.g,
        b: e.b,
        a: t
      }) : gr(this.rgba.a, 3);
      var e;
    }, n.prototype.hue = function(t) {
      var e = Cg(this.rgba);
      return typeof t == "number" ? ks({
        h: t,
        s: e.s,
        l: e.l,
        a: e.a
      }) : gr(e.h);
    }, n.prototype.isEqual = function(t) {
      return this.toHex() === ks(t).toHex();
    }, n;
  }(), ks = function(n) {
    return n instanceof J2 ? n : new J2(n);
  }, DG = [], UXt = function(n) {
    n.forEach(function(t) {
      DG.indexOf(t) < 0 && (t(J2, Z2), DG.push(t));
    });
  };
  function HXt(n, t) {
    var e = {
      white: "#ffffff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000"
    }, r = {};
    for (var i in e) r[e[i]] = i;
    var a = {};
    n.prototype.toName = function(s) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var o, l, u = r[this.toHex()];
      if (u) return u;
      if (s == null ? void 0 : s.closest) {
        var c = this.toRgb(), h = 1 / 0, f = "black";
        if (!a.length) for (var d in e) a[d] = new n(e[d]).toRgb();
        for (var p in e) {
          var g = (o = c, l = a[p], Math.pow(o.r - l.r, 2) + Math.pow(o.g - l.g, 2) + Math.pow(o.b - l.b, 2));
          g < h && (h = g, f = p);
        }
        return f;
      }
    }, t.string.push([
      function(s) {
        var o = s.toLowerCase(), l = o === "transparent" ? "#0000" : e[o];
        return l ? new n(l).toRgb() : null;
      },
      "name"
    ]);
  }
  UXt([
    HXt
  ]);
  const ud = class rg {
    constructor(t = 16777215) {
      this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(t) {
      return this.value = t, this;
    }
    set value(t) {
      if (t instanceof rg) this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
      else {
        if (t === null) throw new Error("Cannot set Color#value to null");
        (this._value === null || !this._isSourceEqual(this._value, t)) && (this._value = this._cloneSource(t), this._normalize(this._value));
      }
    }
    get value() {
      return this._value;
    }
    _cloneSource(t) {
      return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? {
        ...t
      } : t;
    }
    _isSourceEqual(t, e) {
      const r = typeof t;
      if (r !== typeof e) return false;
      if (r === "number" || r === "string" || t instanceof Number) return t === e;
      if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) return t.length !== e.length ? false : t.every((a, s) => a === e[s]);
      if (t !== null && e !== null) {
        const a = Object.keys(t), s = Object.keys(e);
        return a.length !== s.length ? false : a.every((o) => t[o] === e[o]);
      }
      return t === e;
    }
    toRgba() {
      const [t, e, r, i] = this._components;
      return {
        r: t,
        g: e,
        b: r,
        a: i
      };
    }
    toRgb() {
      const [t, e, r] = this._components;
      return {
        r: t,
        g: e,
        b: r
      };
    }
    toRgbaString() {
      const [t, e, r] = this.toUint8RgbArray();
      return `rgba(${t},${e},${r},${this.alpha})`;
    }
    toUint8RgbArray(t) {
      const [e, r, i] = this._components;
      return this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb), t[0] = Math.round(e * 255), t[1] = Math.round(r * 255), t[2] = Math.round(i * 255), t;
    }
    toArray(t) {
      this._arrayRgba || (this._arrayRgba = []), t || (t = this._arrayRgba);
      const [e, r, i, a] = this._components;
      return t[0] = e, t[1] = r, t[2] = i, t[3] = a, t;
    }
    toRgbArray(t) {
      this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb);
      const [e, r, i] = this._components;
      return t[0] = e, t[1] = r, t[2] = i, t;
    }
    toNumber() {
      return this._int;
    }
    toBgrNumber() {
      const [t, e, r] = this.toUint8RgbArray();
      return (r << 16) + (e << 8) + t;
    }
    toLittleEndianNumber() {
      const t = this._int;
      return (t >> 16) + (t & 65280) + ((t & 255) << 16);
    }
    multiply(t) {
      const [e, r, i, a] = rg._temp.setValue(t)._components;
      return this._components[0] *= e, this._components[1] *= r, this._components[2] *= i, this._components[3] *= a, this._refreshInt(), this._value = null, this;
    }
    premultiply(t, e = true) {
      return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
    }
    toPremultiplied(t, e = true) {
      if (t === 1) return (255 << 24) + this._int;
      if (t === 0) return e ? 0 : this._int;
      let r = this._int >> 16 & 255, i = this._int >> 8 & 255, a = this._int & 255;
      return e && (r = r * t + 0.5 | 0, i = i * t + 0.5 | 0, a = a * t + 0.5 | 0), (t * 255 << 24) + (r << 16) + (i << 8) + a;
    }
    toHex() {
      const t = this._int.toString(16);
      return `#${"000000".substring(0, 6 - t.length) + t}`;
    }
    toHexa() {
      const e = Math.round(this._components[3] * 255).toString(16);
      return this.toHex() + "00".substring(0, 2 - e.length) + e;
    }
    setAlpha(t) {
      return this._components[3] = this._clamp(t), this;
    }
    _normalize(t) {
      let e, r, i, a;
      if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
        const s = t;
        e = (s >> 16 & 255) / 255, r = (s >> 8 & 255) / 255, i = (s & 255) / 255, a = 1;
      } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4) t = this._clamp(t), [e, r, i, a = 1] = t;
      else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4) t = this._clamp(t, 0, 255), [e, r, i, a = 255] = t, e /= 255, r /= 255, i /= 255, a /= 255;
      else if (typeof t == "string" || typeof t == "object") {
        if (typeof t == "string") {
          const o = rg.HEX_PATTERN.exec(t);
          o && (t = `#${o[2]}`);
        }
        const s = ks(t);
        s.isValid() && ({ r: e, g: r, b: i, a } = s.rgba, e /= 255, r /= 255, i /= 255);
      }
      if (e !== void 0) this._components[0] = e, this._components[1] = r, this._components[2] = i, this._components[3] = a, this._refreshInt();
      else throw new Error(`Unable to convert color ${t}`);
    }
    _refreshInt() {
      this._clamp(this._components);
      const [t, e, r] = this._components;
      this._int = (t * 255 << 16) + (e * 255 << 8) + (r * 255 | 0);
    }
    _clamp(t, e = 0, r = 1) {
      return typeof t == "number" ? Math.min(Math.max(t, e), r) : (t.forEach((i, a) => {
        t[a] = Math.min(Math.max(i, e), r);
      }), t);
    }
    static isColorLike(t) {
      return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof rg || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
    }
  };
  ud.shared = new ud();
  ud._temp = new ud();
  ud.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  jr = ud;
  const XXt = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
  };
  class AN {
    constructor(t, e) {
      this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
    }
    prepopulate(t) {
      for (let e = 0; e < t; e++) this._pool[this._index++] = new this._classType();
      this._count += t;
    }
    get(t) {
      var _a2;
      let e;
      return this._index > 0 ? e = this._pool[--this._index] : e = new this._classType(), (_a2 = e.init) == null ? void 0 : _a2.call(e, t), e;
    }
    return(t) {
      var _a2;
      (_a2 = t.reset) == null ? void 0 : _a2.call(t), this._pool[this._index++] = t;
    }
    get totalSize() {
      return this._count;
    }
    get totalFree() {
      return this._index;
    }
    get totalUsed() {
      return this._count - this._index;
    }
    clear() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class YXt {
    constructor() {
      this._poolsByClass = /* @__PURE__ */ new Map();
    }
    prepopulate(t, e) {
      this.getPool(t).prepopulate(e);
    }
    get(t, e) {
      return this.getPool(t).get(e);
    }
    return(t) {
      this.getPool(t.constructor).return(t);
    }
    getPool(t) {
      return this._poolsByClass.has(t) || this._poolsByClass.set(t, new AN(t)), this._poolsByClass.get(t);
    }
    stats() {
      const t = {};
      return this._poolsByClass.forEach((e) => {
        const r = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
        t[r] = {
          free: e.totalFree,
          used: e.totalUsed,
          size: e.totalSize
        };
      }), t;
    }
  }
  let qXt;
  Oo = new YXt();
  qXt = {
    get isCachedAsTexture() {
      var _a2;
      return !!((_a2 = this.renderGroup) == null ? void 0 : _a2.isCachedAsTexture);
    },
    cacheAsTexture(n) {
      typeof n == "boolean" && n === false ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(n === true ? {} : n));
    },
    updateCacheTexture() {
      var _a2;
      (_a2 = this.renderGroup) == null ? void 0 : _a2.updateCacheTexture();
    },
    get cacheAsBitmap() {
      return this.isCachedAsTexture;
    },
    set cacheAsBitmap(n) {
      fn("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(n);
    }
  };
  jXt = function(n, t, e) {
    const r = n.length;
    let i;
    if (t >= r || e === 0) return;
    e = t + e > r ? r - t : e;
    const a = r - e;
    for (i = t; i < a; ++i) n[i] = n[i + e];
    n.length = a;
  };
  const KXt = {
    allowChildren: true,
    removeChildren(n = 0, t) {
      const e = t ?? this.children.length, r = e - n, i = [];
      if (r > 0 && r <= e) {
        for (let s = e - 1; s >= n; s--) {
          const o = this.children[s];
          o && (i.push(o), o.parent = null);
        }
        jXt(this.children, n, e);
        const a = this.renderGroup || this.parentRenderGroup;
        a && a.removeChildren(i);
        for (let s = 0; s < i.length; ++s) this.emit("childRemoved", i[s], this, s), i[s].emit("removed", this);
        return i.length > 0 && this._didViewChangeTick++, i;
      } else if (r === 0 && this.children.length === 0) return i;
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt(n) {
      const t = this.getChildAt(n);
      return this.removeChild(t);
    },
    getChildAt(n) {
      if (n < 0 || n >= this.children.length) throw new Error(`getChildAt: Index (${n}) does not exist.`);
      return this.children[n];
    },
    setChildIndex(n, t) {
      if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
      this.getChildIndex(n), this.addChildAt(n, t);
    },
    getChildIndex(n) {
      const t = this.children.indexOf(n);
      if (t === -1) throw new Error("The supplied Container must be a child of the caller");
      return t;
    },
    addChildAt(n, t) {
      this.allowChildren || fn(An, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      const { children: e } = this;
      if (t < 0 || t > e.length) throw new Error(`${n}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
      if (n.parent) {
        const i = n.parent.children.indexOf(n);
        if (n.parent === this && i === t) return n;
        i !== -1 && n.parent.children.splice(i, 1);
      }
      t === e.length ? e.push(n) : e.splice(t, 0, n), n.parent = this, n.didChange = true, n._updateFlags = 15;
      const r = this.renderGroup || this.parentRenderGroup;
      return r && r.addChild(n), this.sortableChildren && (this.sortDirty = true), this.emit("childAdded", n, this, t), n.emit("added", this), n;
    },
    swapChildren(n, t) {
      if (n === t) return;
      const e = this.getChildIndex(n), r = this.getChildIndex(t);
      this.children[e] = t, this.children[r] = n;
      const i = this.renderGroup || this.parentRenderGroup;
      i && (i.structureDidChange = true), this._didContainerChangeTick++;
    },
    removeFromParent() {
      var _a2;
      (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
    },
    reparentChild(...n) {
      return n.length === 1 ? this.reparentChildAt(n[0], this.children.length) : (n.forEach((t) => this.reparentChildAt(t, this.children.length)), n[0]);
    },
    reparentChildAt(n, t) {
      if (n.parent === this) return this.setChildIndex(n, t), n;
      const e = n.worldTransform.clone();
      n.removeFromParent(), this.addChildAt(n, t);
      const r = this.worldTransform.clone();
      return r.invert(), e.prepend(r), n.setFromMatrix(e), n;
    }
  }, ZXt = {
    collectRenderables(n, t, e) {
      this.parentRenderLayer && this.parentRenderLayer !== e || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(n, t, e) : this.renderGroup ? t.renderPipes.renderGroup.addRenderGroup(this.renderGroup, n) : this.collectRenderablesWithEffects(n, t, e));
    },
    collectRenderablesSimple(n, t, e) {
      const r = this.children, i = r.length;
      for (let a = 0; a < i; a++) r[a].collectRenderables(n, t, e);
    },
    collectRenderablesWithEffects(n, t, e) {
      const { renderPipes: r } = t;
      for (let i = 0; i < this.effects.length; i++) {
        const a = this.effects[i];
        r[a.pipe].push(a, this, n);
      }
      this.collectRenderablesSimple(n, t, e);
      for (let i = this.effects.length - 1; i >= 0; i--) {
        const a = this.effects[i];
        r[a.pipe].pop(a, this, n);
      }
    }
  };
  EG = class {
    constructor() {
      this.pipe = "filter", this.priority = 1;
    }
    destroy() {
      for (let t = 0; t < this.filters.length; t++) this.filters[t].destroy();
      this.filters = null, this.filterArea = null;
    }
  };
  class JXt {
    constructor() {
      this._effectClasses = [], this._tests = [], this._initialized = false;
    }
    init() {
      this._initialized || (this._initialized = true, this._effectClasses.forEach((t) => {
        this.add({
          test: t.test,
          maskClass: t
        });
      }));
    }
    add(t) {
      this._tests.push(t);
    }
    getMaskEffect(t) {
      this._initialized || this.init();
      for (let e = 0; e < this._tests.length; e++) {
        const r = this._tests[e];
        if (r.test(t)) return Oo.get(r.maskClass, t);
      }
      return t;
    }
    returnMaskEffect(t) {
      Oo.return(t);
    }
  }
  const Q2 = new JXt();
  Pa.handleByList(rn.MaskEffect, Q2._effectClasses);
  const QXt = {
    _maskEffect: null,
    _maskOptions: {
      inverse: false
    },
    _filterEffect: null,
    effects: [],
    _markStructureAsChanged() {
      const n = this.renderGroup || this.parentRenderGroup;
      n && (n.structureDidChange = true);
    },
    addEffect(n) {
      this.effects.indexOf(n) === -1 && (this.effects.push(n), this.effects.sort((e, r) => e.priority - r.priority), this._markStructureAsChanged(), this._updateIsSimple());
    },
    removeEffect(n) {
      const t = this.effects.indexOf(n);
      t !== -1 && (this.effects.splice(t, 1), this._markStructureAsChanged(), this._updateIsSimple());
    },
    set mask(n) {
      const t = this._maskEffect;
      (t == null ? void 0 : t.mask) !== n && (t && (this.removeEffect(t), Q2.returnMaskEffect(t), this._maskEffect = null), n != null && (this._maskEffect = Q2.getMaskEffect(n), this.addEffect(this._maskEffect)));
    },
    setMask(n) {
      this._maskOptions = {
        ...this._maskOptions,
        ...n
      }, n.mask && (this.mask = n.mask), this._markStructureAsChanged();
    },
    get mask() {
      var _a2;
      return (_a2 = this._maskEffect) == null ? void 0 : _a2.mask;
    },
    set filters(n) {
      var _a2;
      !Array.isArray(n) && n && (n = [
        n
      ]);
      const t = this._filterEffect || (this._filterEffect = new EG());
      n = n;
      const e = (n == null ? void 0 : n.length) > 0, r = ((_a2 = t.filters) == null ? void 0 : _a2.length) > 0, i = e !== r;
      n = Array.isArray(n) ? n.slice(0) : n, t.filters = Object.freeze(n), i && (e ? this.addEffect(t) : (this.removeEffect(t), t.filters = n ?? null));
    },
    get filters() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filters;
    },
    set filterArea(n) {
      this._filterEffect || (this._filterEffect = new EG()), this._filterEffect.filterArea = n;
    },
    get filterArea() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filterArea;
    }
  }, tYt = {
    label: null,
    get name() {
      return fn(An, "Container.name property has been removed, use Container.label instead"), this.label;
    },
    set name(n) {
      fn(An, "Container.name property has been removed, use Container.label instead"), this.label = n;
    },
    getChildByName(n, t = false) {
      return this.getChildByLabel(n, t);
    },
    getChildByLabel(n, t = false) {
      const e = this.children;
      for (let r = 0; r < e.length; r++) {
        const i = e[r];
        if (i.label === n || n instanceof RegExp && n.test(i.label)) return i;
      }
      if (t) for (let r = 0; r < e.length; r++) {
        const a = e[r].getChildByLabel(n, true);
        if (a) return a;
      }
      return null;
    },
    getChildrenByLabel(n, t = false, e = []) {
      const r = this.children;
      for (let i = 0; i < r.length; i++) {
        const a = r[i];
        (a.label === n || n instanceof RegExp && n.test(a.label)) && e.push(a);
      }
      if (t) for (let i = 0; i < r.length; i++) r[i].getChildrenByLabel(n, true, e);
      return e;
    }
  }, hi = new AN(Ve), Fo = new AN(hs), eYt = new Ve(), nYt = {
    getFastGlobalBounds(n, t) {
      t || (t = new hs()), t.clear(), this._getGlobalBoundsRecursive(!!n, t, this.parentRenderLayer), t.isValid || t.set(0, 0, 0, 0);
      const e = this.renderGroup || this.parentRenderGroup;
      return t.applyMatrix(e.worldTransform), t;
    },
    _getGlobalBoundsRecursive(n, t, e) {
      let r = t;
      if (n && this.parentRenderLayer && this.parentRenderLayer !== e || this.localDisplayStatus !== 7 || !this.measurable) return;
      const i = !!this.effects.length;
      if ((this.renderGroup || i) && (r = Fo.get().clear()), this.boundsArea) t.addRect(this.boundsArea, this.worldTransform);
      else {
        if (this.renderPipeId) {
          const s = this.bounds;
          r.addFrame(s.minX, s.minY, s.maxX, s.maxY, this.groupTransform);
        }
        const a = this.children;
        for (let s = 0; s < a.length; s++) a[s]._getGlobalBoundsRecursive(n, r, e);
      }
      if (i) {
        let a = false;
        const s = this.renderGroup || this.parentRenderGroup;
        for (let o = 0; o < this.effects.length; o++) this.effects[o].addBounds && (a || (a = true, r.applyMatrix(s.worldTransform)), this.effects[o].addBounds(r, true));
        a && (r.applyMatrix(s.worldTransform.copyTo(eYt).invert()), t.addBounds(r, this.relativeGroupTransform)), t.addBounds(r), Fo.return(r);
      } else this.renderGroup && (t.addBounds(r, this.relativeGroupTransform), Fo.return(r));
    }
  };
  OJ = function(n, t, e) {
    e.clear();
    let r, i;
    return n.parent ? t ? r = n.parent.worldTransform : (i = hi.get().identity(), r = kN(n, i)) : r = Ve.IDENTITY, FJ(n, e, r, t), i && hi.return(i), e.isValid || e.set(0, 0, 0, 0), e;
  };
  function FJ(n, t, e, r) {
    var _a2, _b2;
    if (!n.visible || !n.measurable) return;
    let i;
    r ? i = n.worldTransform : (n.updateLocalTransform(), i = hi.get(), i.appendFrom(n.localTransform, e));
    const a = t, s = !!n.effects.length;
    if (s && (t = Fo.get().clear()), n.boundsArea) t.addRect(n.boundsArea, i);
    else {
      n.bounds && (t.matrix = i, t.addBounds(n.bounds));
      for (let o = 0; o < n.children.length; o++) FJ(n.children[o], t, i, r);
    }
    if (s) {
      for (let o = 0; o < n.effects.length; o++) (_b2 = (_a2 = n.effects[o]).addBounds) == null ? void 0 : _b2.call(_a2, t);
      a.addBounds(t, Ve.IDENTITY), Fo.return(t);
    }
    r || hi.return(i);
  }
  function kN(n, t) {
    const e = n.parent;
    return e && (kN(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
  }
  function BJ(n, t) {
    if (n === 16777215 || !t) return t;
    if (t === 16777215 || !n) return n;
    const e = n >> 16 & 255, r = n >> 8 & 255, i = n & 255, a = t >> 16 & 255, s = t >> 8 & 255, o = t & 255, l = e * a / 255 | 0, u = r * s / 255 | 0, c = i * o / 255 | 0;
    return (l << 16) + (u << 8) + c;
  }
  const MG = 16777215;
  RG = function(n, t) {
    return n === MG ? t : t === MG ? n : BJ(n, t);
  };
  function Rx(n) {
    return ((n & 255) << 16) + (n & 65280) + (n >> 16 & 255);
  }
  const rYt = {
    getGlobalAlpha(n) {
      if (n) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
      let t = this.alpha, e = this.parent;
      for (; e; ) t *= e.alpha, e = e.parent;
      return t;
    },
    getGlobalTransform(n, t) {
      if (t) return n.copyFrom(this.worldTransform);
      this.updateLocalTransform();
      const e = kN(this, hi.get().identity());
      return n.appendFrom(this.localTransform, e), hi.return(e), n;
    },
    getGlobalTint(n) {
      if (n) return this.renderGroup ? Rx(this.renderGroup.worldColor) : this.parentRenderGroup ? Rx(RG(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
      let t = this.localColor, e = this.parent;
      for (; e; ) t = RG(t, e.localColor), e = e.parent;
      return Rx(t);
    }
  };
  let FT = 0;
  const NG = 500;
  Ki = function(...n) {
    FT !== NG && (FT++, FT === NG ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...n));
  };
  zJ = function(n, t, e) {
    return t.clear(), e || (e = Ve.IDENTITY), VJ(n, t, e, n, true), t.isValid || t.set(0, 0, 0, 0), t;
  };
  function VJ(n, t, e, r, i) {
    var _a2, _b2;
    let a;
    if (i) a = hi.get(), a = e.copyTo(a);
    else {
      if (!n.visible || !n.measurable) return;
      n.updateLocalTransform();
      const l = n.localTransform;
      a = hi.get(), a.appendFrom(l, e);
    }
    const s = t, o = !!n.effects.length;
    if (o && (t = Fo.get().clear()), n.boundsArea) t.addRect(n.boundsArea, a);
    else {
      n.renderPipeId && (t.matrix = a, t.addBounds(n.bounds));
      const l = n.children;
      for (let u = 0; u < l.length; u++) VJ(l[u], t, a, r, false);
    }
    if (o) {
      for (let l = 0; l < n.effects.length; l++) (_b2 = (_a2 = n.effects[l]).addLocalBounds) == null ? void 0 : _b2.call(_a2, t, r);
      s.addBounds(t, Ve.IDENTITY), Fo.return(t);
    }
    hi.return(a);
  }
  function GJ(n, t) {
    const e = n.children;
    for (let r = 0; r < e.length; r++) {
      const i = e[r], a = i.uid, s = (i._didViewChangeTick & 65535) << 16 | i._didContainerChangeTick & 65535, o = t.index;
      (t.data[o] !== a || t.data[o + 1] !== s) && (t.data[t.index] = a, t.data[t.index + 1] = s, t.didChange = true), t.index = o + 2, i.children.length && GJ(i, t);
    }
    return t.didChange;
  }
  const iYt = new Ve(), aYt = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(n, t) {
      const e = Math.sign(this.scale.x) || 1;
      t !== 0 ? this.scale.x = n / t * e : this.scale.x = e;
    },
    _setHeight(n, t) {
      const e = Math.sign(this.scale.y) || 1;
      t !== 0 ? this.scale.y = n / t * e : this.scale.y = e;
    },
    getLocalBounds() {
      this._localBoundsCacheData || (this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new hs()
      });
      const n = this._localBoundsCacheData;
      return n.index = 1, n.didChange = false, n.data[0] !== this._didViewChangeTick && (n.didChange = true, n.data[0] = this._didViewChangeTick), GJ(this, n), n.didChange && zJ(this, n.localBounds, iYt), n.localBounds;
    },
    getBounds(n, t) {
      return OJ(this, n, t || new hs());
    }
  }, sYt = {
    _onRender: null,
    set onRender(n) {
      const t = this.renderGroup || this.parentRenderGroup;
      if (!n) {
        this._onRender && (t == null ? void 0 : t.removeOnRender(this)), this._onRender = null;
        return;
      }
      this._onRender || (t == null ? void 0 : t.addOnRender(this)), this._onRender = n;
    },
    get onRender() {
      return this._onRender;
    }
  }, oYt = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex() {
      return this._zIndex;
    },
    set zIndex(n) {
      this._zIndex !== n && (this._zIndex = n, this.depthOfChildModified());
    },
    depthOfChildModified() {
      this.parent && (this.parent.sortableChildren = true, this.parent.sortDirty = true), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true);
    },
    sortChildren() {
      this.sortDirty && (this.sortDirty = false, this.children.sort(lYt));
    }
  };
  function lYt(n, t) {
    return n._zIndex - t._zIndex;
  }
  const uYt = {
    getGlobalPosition(n = new Xr(), t = false) {
      return this.parent ? this.parent.toGlobal(this._position, n, t) : (n.x = this._position.x, n.y = this._position.y), n;
    },
    toGlobal(n, t, e = false) {
      const r = this.getGlobalTransform(hi.get(), e);
      return t = r.apply(n, t), hi.return(r), t;
    },
    toLocal(n, t, e, r) {
      t && (n = t.toGlobal(n, e, r));
      const i = this.getGlobalTransform(hi.get(), r);
      return e = i.applyInverse(n, e), hi.return(i), e;
    }
  };
  class WJ {
    constructor() {
      this.uid = Yn("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
    }
    reset() {
      this.instructionSize = 0;
    }
    add(t) {
      this.instructions[this.instructionSize++] = t;
    }
    log() {
      this.instructions.length = this.instructionSize, console.table(this.instructions, [
        "type",
        "action"
      ]);
    }
  }
  let cYt = 0;
  class hYt {
    constructor(t) {
      this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = false;
    }
    createTexture(t, e, r) {
      const i = new gs({
        ...this.textureOptions,
        width: t,
        height: e,
        resolution: 1,
        antialias: r,
        autoGarbageCollect: false
      });
      return new on({
        source: i,
        label: `texturePool_${cYt++}`
      });
    }
    getOptimalTexture(t, e, r = 1, i) {
      let a = Math.ceil(t * r - 1e-6), s = Math.ceil(e * r - 1e-6);
      a = yG(a), s = yG(s);
      const o = (a << 17) + (s << 1) + (i ? 1 : 0);
      this._texturePool[o] || (this._texturePool[o] = []);
      let l = this._texturePool[o].pop();
      return l || (l = this.createTexture(a, s, i)), l.source._resolution = r, l.source.width = a / r, l.source.height = s / r, l.source.pixelWidth = a, l.source.pixelHeight = s, l.frame.x = 0, l.frame.y = 0, l.frame.width = t, l.frame.height = e, l.updateUvs(), this._poolKeyHash[l.uid] = o, l;
    }
    getSameSizeTexture(t, e = false) {
      const r = t.source;
      return this.getOptimalTexture(t.width, t.height, r._resolution, e);
    }
    returnTexture(t) {
      const e = this._poolKeyHash[t.uid];
      this._texturePool[e].push(t);
    }
    clear(t) {
      if (t = t !== false, t) for (const e in this._texturePool) {
        const r = this._texturePool[e];
        if (r) for (let i = 0; i < r.length; i++) r[i].destroy(true);
      }
      this._texturePool = {};
    }
  }
  fYt = new hYt();
  class dYt {
    constructor() {
      this.renderPipeId = "renderGroup", this.root = null, this.canBundle = false, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new Ve(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
        list: [],
        index: 0
      }, this.structureDidChange = true, this.instructionSet = new WJ(), this._onRenderContainers = [], this.textureNeedsUpdate = true, this.isCachedAsTexture = false, this._matrixDirty = 7;
    }
    init(t) {
      this.root = t, t._onRender && this.addOnRender(t), t.didChange = true;
      const e = t.children;
      for (let r = 0; r < e.length; r++) {
        const i = e[r];
        i._updateFlags = 15, this.addChild(i);
      }
    }
    enableCacheAsTexture(t = {}) {
      this.textureOptions = t, this.isCachedAsTexture = true, this.textureNeedsUpdate = true;
    }
    disableCacheAsTexture() {
      this.isCachedAsTexture = false, this.texture && (fYt.returnTexture(this.texture), this.texture = null);
    }
    updateCacheTexture() {
      this.textureNeedsUpdate = true;
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const t in this.childrenToUpdate) {
        const e = this.childrenToUpdate[t];
        e.list.fill(null), e.index = 0;
      }
      this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = true, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(t) {
      t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
    }
    _removeRenderGroupChild(t) {
      const e = this.renderGroupChildren.indexOf(t);
      e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
    }
    addChild(t) {
      if (this.structureDidChange = true, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = true, this.onChildUpdate(t), t.renderGroup) {
        this.addRenderGroupChild(t.renderGroup);
        return;
      }
      t._onRender && this.addOnRender(t);
      const e = t.children;
      for (let r = 0; r < e.length; r++) this.addChild(e[r]);
    }
    removeChild(t) {
      if (this.structureDidChange = true, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
        this._removeRenderGroupChild(t.renderGroup);
        return;
      }
      const e = t.children;
      for (let r = 0; r < e.length; r++) this.removeChild(e[r]);
    }
    removeChildren(t) {
      for (let e = 0; e < t.length; e++) this.removeChild(t[e]);
    }
    onChildUpdate(t) {
      let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
      e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      }), e.list[e.index++] = t;
    }
    updateRenderable(t) {
      t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = false);
    }
    onChildViewUpdate(t) {
      this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
    }
    get isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(t) {
      this._onRenderContainers.push(t);
    }
    removeOnRender(t) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
    }
    runOnRender(t) {
      for (let e = 0; e < this._onRenderContainers.length; e++) this._onRenderContainers[e]._onRender(t);
    }
    destroy() {
      this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
    }
    getChildren(t = []) {
      const e = this.root.children;
      for (let r = 0; r < e.length; r++) this._getChildren(e[r], t);
      return t;
    }
    _getChildren(t, e = []) {
      if (e.push(t), t.renderGroup) return e;
      const r = t.children;
      for (let i = 0; i < r.length; i++) this._getChildren(r[i], e);
      return e;
    }
    invalidateMatrices() {
      this._matrixDirty = 7;
    }
    get inverseWorldTransform() {
      return this._matrixDirty & 1 ? (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new Ve()), this._inverseWorldTransform.copyFrom(this.worldTransform).invert()) : this._inverseWorldTransform;
    }
    get textureOffsetInverseTransform() {
      return this._matrixDirty & 2 ? (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Ve()), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y)) : this._textureOffsetInverseTransform;
    }
    get inverseParentTextureTransform() {
      if (!(this._matrixDirty & 4)) return this._inverseParentTextureTransform;
      this._matrixDirty &= -5;
      const t = this._parentCacheAsTextureRenderGroup;
      return t ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Ve()), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(t.inverseWorldTransform).translate(-t._textureBounds.x, -t._textureBounds.y)) : this.worldTransform;
    }
    get cacheToLocalTransform() {
      return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
    }
  }
  function pYt(n, t, e = {}) {
    for (const r in t) !e[r] && t[r] !== void 0 && (n[r] = t[r]);
  }
  let BT, zT, VT;
  BT = new Ii(null);
  zT = new Ii(null);
  VT = new Ii(null, 1, 1);
  LG = 1;
  gYt = 2;
  GT = 4;
  Eh = class extends po {
    constructor(t = {}) {
      var _a2, _b2;
      super(), this.uid = Yn("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = false, this.didViewUpdate = false, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = true, this.measurable = true, this.isSimple = true, this.updateTick = -1, this.localTransform = new Ve(), this.relativeGroupTransform = new Ve(), this.groupTransform = this.relativeGroupTransform, this.destroyed = false, this._position = new Ii(this, 0, 0), this._scale = VT, this._pivot = zT, this._skew = BT, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], pYt(this, t, {
        children: true,
        parent: true,
        effects: true
      }), (_a2 = t.children) == null ? void 0 : _a2.forEach((e) => this.addChild(e)), (_b2 = t.parent) == null ? void 0 : _b2.addChild(this);
    }
    static mixin(t) {
      fn("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), Pa.mixin(Eh, t);
    }
    set _didChangeId(t) {
      this._didViewChangeTick = t >> 12 & 4095, this._didContainerChangeTick = t & 4095;
    }
    get _didChangeId() {
      return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
    }
    addChild(...t) {
      if (this.allowChildren || fn(An, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
        for (let i = 0; i < t.length; i++) this.addChild(t[i]);
        return t[0];
      }
      const e = t[0], r = this.renderGroup || this.parentRenderGroup;
      return e.parent === this ? (this.children.splice(this.children.indexOf(e), 1), this.children.push(e), r && (r.structureDidChange = true), e) : (e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = true), e.parent = this, e.didChange = true, e._updateFlags = 15, r && r.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didViewChangeTick++, e._zIndex !== 0 && e.depthOfChildModified(), e);
    }
    removeChild(...t) {
      if (t.length > 1) {
        for (let i = 0; i < t.length; i++) this.removeChild(t[i]);
        return t[0];
      }
      const e = t[0], r = this.children.indexOf(e);
      return r > -1 && (this._didViewChangeTick++, this.children.splice(r, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parentRenderLayer && e.parentRenderLayer.detach(e), e.parent = null, this.emit("childRemoved", e, this, r), e.emit("removed", this)), e;
    }
    _onUpdate(t) {
      t && t === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = true, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
    }
    set isRenderGroup(t) {
      !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup) return;
      const t = this.parentRenderGroup;
      t == null ? void 0 : t.removeChild(this), this.renderGroup = Oo.get(dYt, this), this.groupTransform = Ve.IDENTITY, t == null ? void 0 : t.addChild(this), this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup) return;
      const t = this.parentRenderGroup;
      t == null ? void 0 : t.removeChild(this), Oo.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t == null ? void 0 : t.addChild(this), this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      return this._worldTransform || (this._worldTransform = new Ve()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
    }
    get x() {
      return this._position.x;
    }
    set x(t) {
      this._position.x = t;
    }
    get y() {
      return this._position.y;
    }
    set y(t) {
      this._position.y = t;
    }
    get position() {
      return this._position;
    }
    set position(t) {
      this._position.copyFrom(t);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(t) {
      this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
    }
    get angle() {
      return this.rotation * AXt;
    }
    set angle(t) {
      this.rotation = t * kXt;
    }
    get pivot() {
      return this._pivot === zT && (this._pivot = new Ii(this, 0, 0)), this._pivot;
    }
    set pivot(t) {
      this._pivot === zT && (this._pivot = new Ii(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
    }
    get skew() {
      return this._skew === BT && (this._skew = new Ii(this, 0, 0)), this._skew;
    }
    set skew(t) {
      this._skew === BT && (this._skew = new Ii(this, 0, 0)), this._skew.copyFrom(t);
    }
    get scale() {
      return this._scale === VT && (this._scale = new Ii(this, 1, 1)), this._scale;
    }
    set scale(t) {
      this._scale === VT && (this._scale = new Ii(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(t) {
      const e = this.getLocalBounds().width;
      this._setWidth(t, e);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(t) {
      const e = this.getLocalBounds().height;
      this._setHeight(t, e);
    }
    getSize(t) {
      t || (t = {});
      const e = this.getLocalBounds();
      return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
    }
    setSize(t, e) {
      const r = this.getLocalBounds();
      typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, r.width), e !== void 0 && this._setHeight(e, r.height);
    }
    _updateSkew() {
      const t = this._rotation, e = this._skew;
      this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
    }
    updateTransform(t) {
      return this.position.set(typeof t.x == "number" ? t.x : this.position.x, typeof t.y == "number" ? t.y : this.position.y), this.scale.set(typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x, typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(typeof t.skewX == "number" ? t.skewX : this.skew.x, typeof t.skewY == "number" ? t.skewY : this.skew.y), this.pivot.set(typeof t.pivotX == "number" ? t.pivotX : this.pivot.x, typeof t.pivotY == "number" ? t.pivotY : this.pivot.y), this;
    }
    setFromMatrix(t) {
      t.decompose(this);
    }
    updateLocalTransform() {
      const t = this._didContainerChangeTick;
      if (this._didLocalTransformChangeId === t) return;
      this._didLocalTransformChangeId = t;
      const e = this.localTransform, r = this._scale, i = this._pivot, a = this._position, s = r._x, o = r._y, l = i._x, u = i._y;
      e.a = this._cx * s, e.b = this._sx * s, e.c = this._cy * o, e.d = this._sy * o, e.tx = a._x - (l * e.a + u * e.c), e.ty = a._y - (l * e.b + u * e.d);
    }
    set alpha(t) {
      t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= LG, this._onUpdate());
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(t) {
      const r = jr.shared.setValue(t ?? 16777215).toBgrNumber();
      r !== this.localColor && (this.localColor = r, this._updateFlags |= LG, this._onUpdate());
    }
    get tint() {
      return Rx(this.localColor);
    }
    set blendMode(t) {
      this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= gYt, this.localBlendMode = t, this._onUpdate());
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(t) {
      const e = t ? 2 : 0;
      (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= GT, this.localDisplayStatus ^= 2, this._onUpdate());
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(t) {
      const e = t ? 0 : 4;
      (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= GT, this.localDisplayStatus ^= 4, this._onUpdate());
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(t) {
      const e = t ? 1 : 0;
      (this.localDisplayStatus & 1) !== e && (this._updateFlags |= GT, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._onUpdate());
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(t = false) {
      var _a2;
      if (this.destroyed) return;
      this.destroyed = true;
      let e;
      if (this.children.length && (e = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof t == "boolean" ? t : t == null ? void 0 : t.children) && e) for (let i = 0; i < e.length; ++i) e[i].destroy(t);
      (_a2 = this.renderGroup) == null ? void 0 : _a2.destroy(), this.renderGroup = null;
    }
  };
  Pa.mixin(Eh, KXt, nYt, uYt, sYt, aYt, QXt, tYt, oYt, XXt, qXt, rYt, ZXt);
  class DN extends Eh {
    constructor(t) {
      super(t), this.canBundle = true, this.allowChildren = false, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new hs(0, 1, 0, 0), this._boundsDirty = true;
    }
    get bounds() {
      return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = false, this._bounds) : this._bounds;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(t) {
      this._roundPixels = t ? 1 : 0;
    }
    containsPoint(t) {
      const e = this.bounds, { x: r, y: i } = t;
      return r >= e.minX && r <= e.maxX && i >= e.minY && i <= e.maxY;
    }
    onViewUpdate() {
      if (this._didViewChangeTick++, this._boundsDirty = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const t = this.renderGroup || this.parentRenderGroup;
      t && t.onChildViewUpdate(this);
    }
    destroy(t) {
      super.destroy(t), this._bounds = null;
    }
    collectRenderablesSimple(t, e, r) {
      const { renderPipes: i, renderableGC: a } = e;
      i.blendMode.setBlendMode(this, this.groupBlendMode, t), i[this.renderPipeId].addRenderable(this, t), a.addRenderable(this), this.didViewUpdate = false;
      const o = this.children, l = o.length;
      for (let u = 0; u < l; u++) o[u].collectRenderables(t, e, r);
    }
  }
  cd = class extends DN {
    constructor(t = on.EMPTY) {
      t instanceof on && (t = {
        texture: t
      });
      const { texture: e = on.EMPTY, anchor: r, roundPixels: i, width: a, height: s, ...o } = t;
      super({
        label: "Sprite",
        ...o
      }), this.renderPipeId = "sprite", this.batched = true, this._visualBounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._anchor = new Ii({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), r ? this.anchor = r : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = false, this.roundPixels = i ?? false, a !== void 0 && (this.width = a), s !== void 0 && (this.height = s);
    }
    static from(t, e = false) {
      return t instanceof on ? new cd(t) : new cd(on.from(t, e));
    }
    set texture(t) {
      t || (t = on.EMPTY);
      const e = this._texture;
      e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get visualBounds() {
      return $Xt(this._visualBounds, this._anchor, this._texture), this._visualBounds;
    }
    get sourceBounds() {
      return fn("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
    }
    updateBounds() {
      const t = this._anchor, e = this._texture, r = this._bounds, { width: i, height: a } = e.orig;
      r.minX = -t._x * i, r.maxX = r.minX + i, r.minY = -t._y * a, r.maxY = r.minY + a;
    }
    destroy(t = false) {
      if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._texture.destroy(r);
      }
      this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(t) {
      this._setWidth(t, this._texture.orig.width), this._width = t;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(t) {
      this._setHeight(t, this._texture.orig.height), this._height = t;
    }
    getSize(t) {
      return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
    }
    setSize(t, e) {
      typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this._texture.orig.width), e !== void 0 && this._setHeight(e, this._texture.orig.height);
    }
  };
  const vYt = new hs();
  function UJ(n, t, e) {
    const r = vYt;
    n.measurable = true, OJ(n, e, r), t.addBoundsMask(r), n.measurable = false;
  }
  function HJ(n, t, e) {
    const r = Fo.get();
    n.measurable = true;
    const i = hi.get().identity(), a = XJ(n, e, i);
    zJ(n, r, a), n.measurable = false, t.addBoundsMask(r), hi.return(i), Fo.return(r);
  }
  function XJ(n, t, e) {
    return n ? (n !== t && (XJ(n.parent, t, e), n.updateLocalTransform(), e.append(n.localTransform)), e) : (Ki("Mask bounds, renderable is not inside the root container"), e);
  }
  class YJ {
    constructor(t) {
      this.priority = 0, this.inverse = false, this.pipe = "alphaMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t, this.renderMaskToTexture = !(t instanceof cd), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask = null;
    }
    addBounds(t, e) {
      this.inverse || UJ(this.mask, t, e);
    }
    addLocalBounds(t, e) {
      HJ(this.mask, t, e);
    }
    containsPoint(t, e) {
      const r = this.mask;
      return e(r, t);
    }
    destroy() {
      this.reset();
    }
    static test(t) {
      return t instanceof cd;
    }
  }
  YJ.extension = rn.MaskEffect;
  class qJ {
    constructor(t) {
      this.priority = 0, this.pipe = "colorMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t;
    }
    destroy() {
    }
    static test(t) {
      return typeof t == "number";
    }
  }
  qJ.extension = rn.MaskEffect;
  class jJ {
    constructor(t) {
      this.priority = 0, this.pipe = "stencilMask", (t == null ? void 0 : t.mask) && this.init(t.mask);
    }
    init(t) {
      this.mask = t, this.mask.includeInBuild = false, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask.includeInBuild = true, this.mask = null;
    }
    addBounds(t, e) {
      UJ(this.mask, t, e);
    }
    addLocalBounds(t, e) {
      HJ(this.mask, t, e);
    }
    containsPoint(t, e) {
      const r = this.mask;
      return e(r, t);
    }
    destroy() {
      this.reset();
    }
    static test(t) {
      return t instanceof Eh;
    }
  }
  jJ.extension = rn.MaskEffect;
  const mYt = {
    createCanvas: (n, t) => {
      const e = document.createElement("canvas");
      return e.width = n, e.height = t, e;
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (n, t) => fetch(n, t),
    parseXML: (n) => new DOMParser().parseFromString(n, "text/xml")
  };
  let PG = mYt;
  as = {
    get() {
      return PG;
    },
    set(n) {
      PG = n;
    }
  };
  KJ = class extends gs {
    constructor(t) {
      t.resource || (t.resource = as.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity, this.resizeCanvas(), this.transparent = !!t.transparent;
    }
    resizeCanvas() {
      this.autoDensity && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
    }
    resize(t = this.width, e = this.height, r = this._resolution) {
      const i = super.resize(t, e, r);
      return i && this.resizeCanvas(), i;
    }
    static test(t) {
      return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
    }
    get context2D() {
      return this._context2D || (this._context2D = this.resource.getContext("2d"));
    }
  };
  KJ.extension = rn.TextureSource;
  l1 = class extends gs {
    constructor(t) {
      if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) {
        const e = as.get().createCanvas(t.resource.width, t.resource.height);
        e.getContext("2d").drawImage(t.resource, 0, 0, t.resource.width, t.resource.height), t.resource = e, Ki("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
      }
      super(t), this.uploadMethodId = "image", this.autoGarbageCollect = true;
    }
    static test(t) {
      return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame;
    }
  };
  l1.extension = rn.TextureSource;
  tk = ((n) => (n[n.INTERACTION = 50] = "INTERACTION", n[n.HIGH = 25] = "HIGH", n[n.NORMAL = 0] = "NORMAL", n[n.LOW = -25] = "LOW", n[n.UTILITY = -50] = "UTILITY", n))(tk || {});
  class WT {
    constructor(t, e = null, r = 0, i = false) {
      this.next = null, this.previous = null, this._destroyed = false, this._fn = t, this._context = e, this.priority = r, this._once = i;
    }
    match(t, e = null) {
      return this._fn === t && this._context === e;
    }
    emit(t) {
      this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
      const e = this.next;
      return this._once && this.destroy(true), this._destroyed && (this.next = null), e;
    }
    connect(t) {
      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
    }
    destroy(t = false) {
      this._destroyed = true, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      const e = this.next;
      return this.next = t ? null : e, this.previous = null, e;
    }
  }
  const ZJ = class Gi {
    constructor() {
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new WT(null, null, 1 / 0), this.deltaMS = 1 / Gi.targetFPMS, this.elapsedMS = 1 / Gi.targetFPMS, this._tick = (t) => {
        this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
      };
    }
    _requestIfNeeded() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }
    _cancelIfNeeded() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(t, e, r = tk.NORMAL) {
      return this._addListener(new WT(t, e, r));
    }
    addOnce(t, e, r = tk.NORMAL) {
      return this._addListener(new WT(t, e, r, true));
    }
    _addListener(t) {
      let e = this._head.next, r = this._head;
      if (!e) t.connect(r);
      else {
        for (; e; ) {
          if (t.priority > e.priority) {
            t.connect(r);
            break;
          }
          r = e, e = e.next;
        }
        t.previous || t.connect(r);
      }
      return this._startIfPossible(), this;
    }
    remove(t, e) {
      let r = this._head.next;
      for (; r; ) r.match(t, e) ? r = r.destroy() : r = r.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) return 0;
      let t = 0, e = this._head;
      for (; e = e.next; ) t++;
      return t;
    }
    start() {
      this.started || (this.started = true, this._requestIfNeeded());
    }
    stop() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let t = this._head.next;
        for (; t; ) t = t.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }
    update(t = performance.now()) {
      let e;
      if (t > this.lastTime) {
        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
          const a = t - this._lastFrame | 0;
          if (a < this._minElapsedMS) return;
          this._lastFrame = t - a % this._minElapsedMS;
        }
        this.deltaMS = e, this.deltaTime = this.deltaMS * Gi.targetFPMS;
        const r = this._head;
        let i = r.next;
        for (; i; ) i = i.emit(this);
        r.next || this._cancelIfNeeded();
      } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(t) {
      const e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, Gi.targetFPMS);
      this._maxElapsedMS = 1 / r;
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(t) {
      if (t === 0) this._minElapsedMS = 0;
      else {
        const e = Math.max(this.minFPS, t);
        this._minElapsedMS = 1 / (e / 1e3);
      }
    }
    static get shared() {
      if (!Gi._shared) {
        const t = Gi._shared = new Gi();
        t.autoStart = true, t._protected = true;
      }
      return Gi._shared;
    }
    static get system() {
      if (!Gi._system) {
        const t = Gi._system = new Gi();
        t.autoStart = true, t._protected = true;
      }
      return Gi._system;
    }
  };
  ZJ.targetFPMS = 0.06;
  let UT;
  B0 = ZJ;
  async function yYt() {
    return UT ?? (UT = (async () => {
      var _a2;
      const t = document.createElement("canvas").getContext("webgl");
      if (!t) return "premultiply-alpha-on-upload";
      const e = await new Promise((s) => {
        const o = document.createElement("video");
        o.onloadeddata = () => s(o), o.onerror = () => s(null), o.autoplay = false, o.crossOrigin = "anonymous", o.preload = "auto", o.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", o.load();
      });
      if (!e) return "premultiply-alpha-on-upload";
      const r = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, r);
      const i = t.createFramebuffer();
      t.bindFramebuffer(t.FRAMEBUFFER, i), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
      const a = new Uint8Array(4);
      return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, a), t.deleteFramebuffer(i), t.deleteTexture(r), (_a2 = t.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), a[0] <= a[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })()), UT;
  }
  const Nw = class JJ extends gs {
    constructor(t) {
      super(t), this.isReady = false, this.uploadMethodId = "video", t = {
        ...JJ.defaultOptions,
        ...t
      }, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== false, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== false && this.load();
    }
    updateFrame() {
      if (!this.destroyed) {
        if (this._updateFPS) {
          const t = B0.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
        }
        (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) return this._load;
      const t = this.resource, e = this.options;
      return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = true), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, true)), this.alphaMode = await yYt(), this._load = new Promise((r, i) => {
        this.isValid ? r(this) : (this._resolve = r, this._reject = i, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
          this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
        })), t.load());
      }), this._load;
    }
    _onError(t) {
      this.resource.removeEventListener("error", this._onError, true), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
    }
    _isSourcePlaying() {
      const t = this.resource;
      return !t.paused && !t.ended;
    }
    _isSourceReady() {
      return this.resource.readyState > 2;
    }
    _onPlayStart() {
      this.isValid || this._mediaReady(), this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
    }
    _onCanPlay() {
      this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
    }
    _onCanPlayThrough() {
      this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
    }
    _mediaReady() {
      const t = this.resource;
      this.isValid && (this.isReady = true, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
    }
    destroy() {
      this._configureAutoUpdate();
      const t = this.resource;
      t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, true), t.pause(), t.src = "", t.load()), super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(t) {
      t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(t) {
      t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (B0.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (B0.shared.add(this.updateFrame, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (B0.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
    }
    static test(t) {
      return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement;
    }
  };
  Nw.extension = rn.TextureSource;
  Nw.defaultOptions = {
    ...gs.defaultOptions,
    autoLoad: true,
    autoPlay: true,
    updateFPS: 0,
    crossorigin: true,
    loop: false,
    muted: true,
    playsinline: true,
    preload: false
  };
  Nw.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  let xYt = Nw;
  const yf = (n, t, e = false) => (Array.isArray(n) || (n = [
    n
  ]), t ? n.map((r) => typeof r == "string" || e ? t(r) : r) : n);
  class bYt {
    constructor() {
      this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear(), this._cache.clear();
    }
    has(t) {
      return this._cache.has(t);
    }
    get(t) {
      const e = this._cache.get(t);
      return e || Ki(`[Assets] Asset id ${t} was not found in the Cache`), e;
    }
    set(t, e) {
      const r = yf(t);
      let i;
      for (let l = 0; l < this.parsers.length; l++) {
        const u = this.parsers[l];
        if (u.test(e)) {
          i = u.getCacheableAssets(r, e);
          break;
        }
      }
      const a = new Map(Object.entries(i || {}));
      i || r.forEach((l) => {
        a.set(l, e);
      });
      const s = [
        ...a.keys()
      ], o = {
        cacheKeys: s,
        keys: r
      };
      r.forEach((l) => {
        this._cacheMap.set(l, o);
      }), s.forEach((l) => {
        const u = i ? i[l] : e;
        this._cache.has(l) && this._cache.get(l) !== u && Ki("[Cache] already has key:", l), this._cache.set(l, a.get(l));
      });
    }
    remove(t) {
      if (!this._cacheMap.has(t)) {
        Ki(`[Assets] Asset id ${t} was not found in the Cache`);
        return;
      }
      const e = this._cacheMap.get(t);
      e.cacheKeys.forEach((i) => {
        this._cache.delete(i);
      }), e.keys.forEach((i) => {
        this._cacheMap.delete(i);
      });
    }
    get parsers() {
      return this._parsers;
    }
  }
  let ek;
  xf = new bYt();
  ek = [];
  Pa.handleByList(rn.TextureSource, ek);
  function QJ(n = {}) {
    const t = n && n.resource, e = t ? n.resource : n, r = t ? n : {
      resource: n
    };
    for (let i = 0; i < ek.length; i++) {
      const a = ek[i];
      if (a.test(e)) return new a(r);
    }
    throw new Error(`Could not find a source type for resource: ${r.resource}`);
  }
  function _Yt(n = {}, t = false) {
    const e = n && n.resource, r = e ? n.resource : n, i = e ? n : {
      resource: n
    };
    if (!t && xf.has(r)) return xf.get(r);
    const a = new on({
      source: QJ(i)
    });
    return a.on("destroy", () => {
      xf.has(r) && xf.remove(r);
    }), t || xf.set(r, a), a;
  }
  function wYt(n, t = false) {
    return typeof n == "string" ? xf.get(n) : n instanceof gs ? new on({
      source: n
    }) : _Yt(n, t);
  }
  on.from = wYt;
  gs.from = QJ;
  Pa.add(YJ, qJ, jJ, xYt, l1, KJ, IN);
  var tQ = ((n) => (n[n.Low = 0] = "Low", n[n.Normal = 1] = "Normal", n[n.High = 2] = "High", n))(tQ || {});
  function za(n) {
    if (typeof n != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(n)}`);
  }
  function Mp(n) {
    return n.split("?")[0].split("#")[0];
  }
  function SYt(n) {
    return n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function CYt(n, t, e) {
    return n.replace(new RegExp(SYt(t), "g"), e);
  }
  function TYt(n, t) {
    let e = "", r = 0, i = -1, a = 0, s = -1;
    for (let o = 0; o <= n.length; ++o) {
      if (o < n.length) s = n.charCodeAt(o);
      else {
        if (s === 47) break;
        s = 47;
      }
      if (s === 47) {
        if (!(i === o - 1 || a === 1)) if (i !== o - 1 && a === 2) {
          if (e.length < 2 || r !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
            if (e.length > 2) {
              const l = e.lastIndexOf("/");
              if (l !== e.length - 1) {
                l === -1 ? (e = "", r = 0) : (e = e.slice(0, l), r = e.length - 1 - e.lastIndexOf("/")), i = o, a = 0;
                continue;
              }
            } else if (e.length === 2 || e.length === 1) {
              e = "", r = 0, i = o, a = 0;
              continue;
            }
          }
        } else e.length > 0 ? e += `/${n.slice(i + 1, o)}` : e = n.slice(i + 1, o), r = o - i - 1;
        i = o, a = 0;
      } else s === 46 && a !== -1 ? ++a : a = -1;
    }
    return e;
  }
  const wv = {
    toPosix(n) {
      return CYt(n, "\\", "/");
    },
    isUrl(n) {
      return /^https?:/.test(this.toPosix(n));
    },
    isDataUrl(n) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(n);
    },
    isBlobUrl(n) {
      return n.startsWith("blob:");
    },
    hasProtocol(n) {
      return /^[^/:]+:/.test(this.toPosix(n));
    },
    getProtocol(n) {
      za(n), n = this.toPosix(n);
      const t = /^file:\/\/\//.exec(n);
      if (t) return t[0];
      const e = /^[^/:]+:\/{0,2}/.exec(n);
      return e ? e[0] : "";
    },
    toAbsolute(n, t, e) {
      if (za(n), this.isDataUrl(n) || this.isBlobUrl(n)) return n;
      const r = Mp(this.toPosix(t ?? as.get().getBaseUrl())), i = Mp(this.toPosix(e ?? this.rootname(r)));
      return n = this.toPosix(n), n.startsWith("/") ? wv.join(i, n.slice(1)) : this.isAbsolute(n) ? n : this.join(r, n);
    },
    normalize(n) {
      if (za(n), n.length === 0) return ".";
      if (this.isDataUrl(n) || this.isBlobUrl(n)) return n;
      n = this.toPosix(n);
      let t = "";
      const e = n.startsWith("/");
      this.hasProtocol(n) && (t = this.rootname(n), n = n.slice(t.length));
      const r = n.endsWith("/");
      return n = TYt(n), n.length > 0 && r && (n += "/"), e ? `/${n}` : t + n;
    },
    isAbsolute(n) {
      return za(n), n = this.toPosix(n), this.hasProtocol(n) ? true : n.startsWith("/");
    },
    join(...n) {
      if (n.length === 0) return ".";
      let t;
      for (let e = 0; e < n.length; ++e) {
        const r = n[e];
        if (za(r), r.length > 0) if (t === void 0) t = r;
        else {
          const i = n[e - 1] ?? "";
          this.joinExtensions.includes(this.extname(i).toLowerCase()) ? t += `/../${r}` : t += `/${r}`;
        }
      }
      return t === void 0 ? "." : this.normalize(t);
    },
    dirname(n) {
      if (za(n), n.length === 0) return ".";
      n = this.toPosix(n);
      let t = n.charCodeAt(0);
      const e = t === 47;
      let r = -1, i = true;
      const a = this.getProtocol(n), s = n;
      n = n.slice(a.length);
      for (let o = n.length - 1; o >= 1; --o) if (t = n.charCodeAt(o), t === 47) {
        if (!i) {
          r = o;
          break;
        }
      } else i = false;
      return r === -1 ? e ? "/" : this.isUrl(s) ? a + n : a : e && r === 1 ? "//" : a + n.slice(0, r);
    },
    rootname(n) {
      za(n), n = this.toPosix(n);
      let t = "";
      if (n.startsWith("/") ? t = "/" : t = this.getProtocol(n), this.isUrl(n)) {
        const e = n.indexOf("/", t.length);
        e !== -1 ? t = n.slice(0, e) : t = n, t.endsWith("/") || (t += "/");
      }
      return t;
    },
    basename(n, t) {
      za(n), t && za(t), n = Mp(this.toPosix(n));
      let e = 0, r = -1, i = true, a;
      if (t !== void 0 && t.length > 0 && t.length <= n.length) {
        if (t.length === n.length && t === n) return "";
        let s = t.length - 1, o = -1;
        for (a = n.length - 1; a >= 0; --a) {
          const l = n.charCodeAt(a);
          if (l === 47) {
            if (!i) {
              e = a + 1;
              break;
            }
          } else o === -1 && (i = false, o = a + 1), s >= 0 && (l === t.charCodeAt(s) ? --s === -1 && (r = a) : (s = -1, r = o));
        }
        return e === r ? r = o : r === -1 && (r = n.length), n.slice(e, r);
      }
      for (a = n.length - 1; a >= 0; --a) if (n.charCodeAt(a) === 47) {
        if (!i) {
          e = a + 1;
          break;
        }
      } else r === -1 && (i = false, r = a + 1);
      return r === -1 ? "" : n.slice(e, r);
    },
    extname(n) {
      za(n), n = Mp(this.toPosix(n));
      let t = -1, e = 0, r = -1, i = true, a = 0;
      for (let s = n.length - 1; s >= 0; --s) {
        const o = n.charCodeAt(s);
        if (o === 47) {
          if (!i) {
            e = s + 1;
            break;
          }
          continue;
        }
        r === -1 && (i = false, r = s + 1), o === 46 ? t === -1 ? t = s : a !== 1 && (a = 1) : t !== -1 && (a = -1);
      }
      return t === -1 || r === -1 || a === 0 || a === 1 && t === r - 1 && t === e + 1 ? "" : n.slice(t, r);
    },
    parse(n) {
      za(n);
      const t = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (n.length === 0) return t;
      n = Mp(this.toPosix(n));
      let e = n.charCodeAt(0);
      const r = this.isAbsolute(n);
      let i;
      t.root = this.rootname(n), r || this.hasProtocol(n) ? i = 1 : i = 0;
      let a = -1, s = 0, o = -1, l = true, u = n.length - 1, c = 0;
      for (; u >= i; --u) {
        if (e = n.charCodeAt(u), e === 47) {
          if (!l) {
            s = u + 1;
            break;
          }
          continue;
        }
        o === -1 && (l = false, o = u + 1), e === 46 ? a === -1 ? a = u : c !== 1 && (c = 1) : a !== -1 && (c = -1);
      }
      return a === -1 || o === -1 || c === 0 || c === 1 && a === o - 1 && a === s + 1 ? o !== -1 && (s === 0 && r ? t.base = t.name = n.slice(1, o) : t.base = t.name = n.slice(s, o)) : (s === 0 && r ? (t.name = n.slice(1, a), t.base = n.slice(1, o)) : (t.name = n.slice(s, a), t.base = n.slice(s, o)), t.ext = n.slice(a, o)), t.dir = this.dirname(n), t;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [
      ".html"
    ]
  };
  function eQ(n, t, e, r, i) {
    const a = t[e];
    for (let s = 0; s < a.length; s++) {
      const o = a[s];
      e < t.length - 1 ? eQ(n.replace(r[e], o), t, e + 1, r, i) : i.push(n.replace(r[e], o));
    }
  }
  function IYt(n) {
    const t = /\{(.*?)\}/g, e = n.match(t), r = [];
    if (e) {
      const i = [];
      e.forEach((a) => {
        const s = a.substring(1, a.length - 1).split(",");
        i.push(s);
      }), eQ(n, i, 0, e, r);
    } else r.push(n);
    return r;
  }
  const $G = (n) => !Array.isArray(n);
  class nQ {
    constructor() {
      this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
        extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "")
      }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
    }
    setBundleIdentifier(t) {
      if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
    prefer(...t) {
      t.forEach((e) => {
        this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
      }), this._resolverHash = {};
    }
    set basePath(t) {
      this._basePath = t;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(t) {
      this._rootPath = t;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
    }
    setDefaultSearchParams(t) {
      if (typeof t == "string") this._defaultSearchParams = t;
      else {
        const e = t;
        this._defaultSearchParams = Object.keys(e).map((r) => `${encodeURIComponent(r)}=${encodeURIComponent(e[r])}`).join("&");
      }
    }
    getAlias(t) {
      const { alias: e, src: r } = t;
      return yf(e || r, (a) => typeof a == "string" ? a : Array.isArray(a) ? a.map((s) => (s == null ? void 0 : s.src) ?? s) : (a == null ? void 0 : a.src) ? a.src : a, true);
    }
    addManifest(t) {
      this._manifest && Ki("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e) => {
        this.addBundle(e.name, e.assets);
      });
    }
    addBundle(t, e) {
      const r = [];
      let i = e;
      Array.isArray(e) || (i = Object.entries(e).map(([a, s]) => typeof s == "string" || Array.isArray(s) ? {
        alias: a,
        src: s
      } : {
        alias: a,
        ...s
      })), i.forEach((a) => {
        const s = a.src, o = a.alias;
        let l;
        if (typeof o == "string") {
          const u = this._createBundleAssetId(t, o);
          r.push(u), l = [
            o,
            u
          ];
        } else {
          const u = o.map((c) => this._createBundleAssetId(t, c));
          r.push(...u), l = [
            ...o,
            ...u
          ];
        }
        this.add({
          ...a,
          alias: l,
          src: s
        });
      }), this._bundles[t] = r;
    }
    add(t) {
      const e = [];
      Array.isArray(t) ? e.push(...t) : e.push(t);
      let r;
      r = (a) => {
        this.hasKey(a) && Ki(`[Resolver] already has key: ${a} overwriting`);
      }, yf(e).forEach((a) => {
        const { src: s } = a;
        let { data: o, format: l, loadParser: u } = a;
        const c = yf(s).map((d) => typeof d == "string" ? IYt(d) : Array.isArray(d) ? d : [
          d
        ]), h = this.getAlias(a);
        Array.isArray(h) ? h.forEach(r) : r(h);
        const f = [];
        c.forEach((d) => {
          d.forEach((p) => {
            let g = {};
            if (typeof p != "object") {
              g.src = p;
              for (let v = 0; v < this._parsers.length; v++) {
                const m = this._parsers[v];
                if (m.test(p)) {
                  g = m.parse(p);
                  break;
                }
              }
            } else o = p.data ?? o, l = p.format ?? l, u = p.loadParser ?? u, g = {
              ...g,
              ...p
            };
            if (!h) throw new Error(`[Resolver] alias is undefined for this asset: ${g.src}`);
            g = this._buildResolvedAsset(g, {
              aliases: h,
              data: o,
              format: l,
              loadParser: u
            }), f.push(g);
          });
        }), h.forEach((d) => {
          this._assetMap[d] = f;
        });
      });
    }
    resolveBundle(t) {
      const e = $G(t);
      t = yf(t);
      const r = {};
      return t.forEach((i) => {
        const a = this._bundles[i];
        if (a) {
          const s = this.resolve(a), o = {};
          for (const l in s) {
            const u = s[l];
            o[this._extractAssetIdFromBundle(i, l)] = u;
          }
          r[i] = o;
        }
      }), e ? r[t[0]] : r;
    }
    resolveUrl(t) {
      const e = this.resolve(t);
      if (typeof t != "string") {
        const r = {};
        for (const i in e) r[i] = e[i].src;
        return r;
      }
      return e.src;
    }
    resolve(t) {
      const e = $G(t);
      t = yf(t);
      const r = {};
      return t.forEach((i) => {
        if (!this._resolverHash[i]) if (this._assetMap[i]) {
          let a = this._assetMap[i];
          const s = this._getPreferredOrder(a);
          s == null ? void 0 : s.priority.forEach((o) => {
            s.params[o].forEach((l) => {
              const u = a.filter((c) => c[o] ? c[o] === l : false);
              u.length && (a = u);
            });
          }), this._resolverHash[i] = a[0];
        } else this._resolverHash[i] = this._buildResolvedAsset({
          alias: [
            i
          ],
          src: i
        }, {});
        r[i] = this._resolverHash[i];
      }), e ? r[t[0]] : r;
    }
    hasKey(t) {
      return !!this._assetMap[t];
    }
    hasBundle(t) {
      return !!this._bundles[t];
    }
    _getPreferredOrder(t) {
      for (let e = 0; e < t.length; e++) {
        const r = t[e], i = this._preferredOrder.find((a) => a.params.format.includes(r.format));
        if (i) return i;
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(t) {
      if (!this._defaultSearchParams) return t;
      const e = /\?/.test(t) ? "&" : "?";
      return `${t}${e}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(t, e) {
      const { aliases: r, data: i, loadParser: a, format: s } = e;
      return (this._basePath || this._rootPath) && (t.src = wv.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = r ?? t.alias ?? [
        t.src
      ], t.src = this._appendDefaultSearchParams(t.src), t.data = {
        ...i || {},
        ...t.data
      }, t.loadParser = a ?? t.loadParser, t.format = s ?? t.format ?? AYt(t.src), t;
    }
  }
  nQ.RETINA_PREFIX = /@([0-9\.]+)x/;
  function AYt(n) {
    return n.split(".").pop().split("?").shift().split("#").shift();
  }
  const OG = (n, t) => {
    const e = t.split("?")[1];
    return e && (n += `?${e}`), n;
  }, rQ = class ig {
    constructor(t, e) {
      this.linkedSheets = [], this._texture = t instanceof on ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e;
      const r = parseFloat(e.meta.scale);
      r ? (this.resolution = r, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    parse() {
      return new Promise((t) => {
        this._callback = t, this._batchIndex = 0, this._frameKeys.length <= ig.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
      });
    }
    _processFrames(t) {
      let e = t;
      const r = ig.BATCH_SIZE;
      for (; e - t < r && e < this._frameKeys.length; ) {
        const i = this._frameKeys[e], a = this._frames[i], s = a.frame;
        if (s) {
          let o = null, l = null;
          const u = a.trimmed !== false && a.sourceSize ? a.sourceSize : a.frame, c = new yr(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution);
          a.rotated ? o = new yr(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : o = new yr(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), a.trimmed !== false && a.spriteSourceSize && (l = new yr(Math.floor(a.spriteSourceSize.x) / this.resolution, Math.floor(a.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[i] = new on({
            source: this.textureSource,
            frame: o,
            orig: c,
            trim: l,
            rotate: a.rotated ? 2 : 0,
            defaultAnchor: a.anchor,
            defaultBorders: a.borders,
            label: i.toString()
          });
        }
        e++;
      }
    }
    _processAnimations() {
      const t = this.data.animations || {};
      for (const e in t) {
        this.animations[e] = [];
        for (let r = 0; r < t[e].length; r++) {
          const i = t[e][r];
          this.animations[e].push(this.textures[i]);
        }
      }
    }
    _parseComplete() {
      const t = this._callback;
      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * ig.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
        this._batchIndex * ig.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(t = false) {
      var _a2;
      for (const e in this.textures) this.textures[e].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((_a2 = this._texture) == null ? void 0 : _a2.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
    }
  };
  rQ.BATCH_SIZE = 1e3;
  let FG = rQ;
  const kYt = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
  ];
  function iQ(n, t, e) {
    const r = {};
    if (n.forEach((i) => {
      r[i] = t;
    }), Object.keys(t.textures).forEach((i) => {
      r[i] = t.textures[i];
    }), !e) {
      const i = wv.dirname(n[0]);
      t.linkedSheets.forEach((a, s) => {
        const o = iQ([
          `${i}/${t.data.meta.related_multi_packs[s]}`
        ], a, true);
        Object.assign(r, o);
      });
    }
    return r;
  }
  const DYt = {
    extension: rn.Asset,
    cache: {
      test: (n) => n instanceof FG,
      getCacheableAssets: (n, t) => iQ(n, t, false)
    },
    resolver: {
      extension: {
        type: rn.ResolveParser,
        name: "resolveSpritesheet"
      },
      test: (n) => {
        const e = n.split("?")[0].split("."), r = e.pop(), i = e.pop();
        return r === "json" && kYt.includes(i);
      },
      parse: (n) => {
        var _a2;
        const t = n.split(".");
        return {
          resolution: parseFloat(((_a2 = nQ.RETINA_PREFIX.exec(n)) == null ? void 0 : _a2[1]) ?? "1"),
          format: t[t.length - 2],
          src: n
        };
      }
    },
    loader: {
      name: "spritesheetLoader",
      extension: {
        type: rn.LoadParser,
        priority: tQ.Normal,
        name: "spritesheetLoader"
      },
      async testParse(n, t) {
        return wv.extname(t.src).toLowerCase() === ".json" && !!n.frames;
      },
      async parse(n, t, e) {
        var _a2, _b2;
        const { texture: r, imageFilename: i, textureOptions: a } = (t == null ? void 0 : t.data) ?? {};
        let s = wv.dirname(t.src);
        s && s.lastIndexOf("/") !== s.length - 1 && (s += "/");
        let o;
        if (r instanceof on) o = r;
        else {
          const c = OG(s + (i ?? n.meta.image), t.src);
          o = (await e.load([
            {
              src: c,
              data: a
            }
          ]))[c];
        }
        const l = new FG(o.source, n);
        await l.parse();
        const u = (_a2 = n == null ? void 0 : n.meta) == null ? void 0 : _a2.related_multi_packs;
        if (Array.isArray(u)) {
          const c = [];
          for (const f of u) {
            if (typeof f != "string") continue;
            let d = s + f;
            ((_b2 = t.data) == null ? void 0 : _b2.ignoreMultiPack) || (d = OG(d, t.src), c.push(e.load({
              src: d,
              data: {
                textureOptions: a,
                ignoreMultiPack: true
              }
            })));
          }
          const h = await Promise.all(c);
          l.linkedSheets = h, h.forEach((f) => {
            f.linkedSheets = [
              l
            ].concat(l.linkedSheets.filter((d) => d !== f));
          });
        }
        return l;
      },
      async unload(n, t, e) {
        await e.unload(n.textureSource._sourceOrigin), n.destroy(false);
      }
    }
  };
  Pa.add(DYt);
  const HT = /* @__PURE__ */ Object.create(null), BG = /* @__PURE__ */ Object.create(null);
  EN = function(n, t) {
    let e = BG[n];
    return e === void 0 && (HT[t] === void 0 && (HT[t] = 1), BG[n] = e = HT[t]++), e;
  };
  let z0;
  function aQ() {
    return (!z0 || (z0 == null ? void 0 : z0.isContextLost())) && (z0 = as.get().createCanvas().getContext("webgl", {})), z0;
  }
  let V0;
  function EYt() {
    if (!V0) {
      V0 = "mediump";
      const n = aQ();
      n && n.getShaderPrecisionFormat && (V0 = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision ? "highp" : "mediump");
    }
    return V0;
  }
  function MYt(n, t, e) {
    return t ? n : e ? (n = n.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${n}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${n}
        `;
  }
  function RYt(n, t, e) {
    const r = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
    if (n.substring(0, 9) !== "precision") {
      let i = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
      return i === "highp" && r !== "highp" && (i = "mediump"), `precision ${i} float;
${n}`;
    } else if (r !== "highp" && n.substring(0, 15) === "precision highp") return n.replace("precision highp", "precision mediump");
    return n;
  }
  function NYt(n, t) {
    return t ? `#version 300 es
${n}` : n;
  }
  const LYt = {}, PYt = {};
  function $Yt(n, { name: t = "pixi-program" }, e = true) {
    t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
    const r = e ? LYt : PYt;
    return r[t] ? (r[t]++, t += `-${r[t]}`) : r[t] = 1, n.indexOf("#define SHADER_NAME") !== -1 ? n : `${`#define SHADER_NAME ${t}`}
${n}`;
  }
  function OYt(n, t) {
    return t ? n.replace("#version 300 es", "") : n;
  }
  const XT = {
    stripVersion: OYt,
    ensurePrecision: RYt,
    addProgramDefines: MYt,
    setProgramName: $Yt,
    insertVersion: NYt
  }, YT = /* @__PURE__ */ Object.create(null), sQ = class nk {
    constructor(t) {
      t = {
        ...nk.defaultOptions,
        ...t
      };
      const e = t.fragment.indexOf("#version 300 es") !== -1, r = {
        stripVersion: e,
        ensurePrecision: {
          requestedFragmentPrecision: t.preferredFragmentPrecision,
          requestedVertexPrecision: t.preferredVertexPrecision,
          maxSupportedVertexPrecision: "highp",
          maxSupportedFragmentPrecision: EYt()
        },
        setProgramName: {
          name: t.name
        },
        addProgramDefines: e,
        insertVersion: e
      };
      let i = t.fragment, a = t.vertex;
      Object.keys(XT).forEach((s) => {
        const o = r[s];
        i = XT[s](i, o, true), a = XT[s](a, o, false);
      }), this.fragment = i, this.vertex = a, this.transformFeedbackVaryings = t.transformFeedbackVaryings, this._key = EN(`${this.vertex}:${this.fragment}`, "gl-program");
    }
    destroy() {
      this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
    }
    static from(t) {
      const e = `${t.vertex}:${t.fragment}`;
      return YT[e] || (YT[e] = new nk(t)), YT[e];
    }
  };
  sQ.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
  };
  oQ = sQ;
  const zG = {
    uint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    uint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    sint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    sint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    unorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    unorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    snorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    snorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    uint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    uint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    sint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    sint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    unorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    unorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    snorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    snorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    float16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    float16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    float32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    float32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    float32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    float32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    uint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    uint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    uint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    uint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    sint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    sint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    sint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    sint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    }
  };
  FYt = function(n) {
    return zG[n] ?? zG.float32;
  };
  const BYt = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };
  function zYt({ source: n, entryPoint: t }) {
    const e = {}, r = n.indexOf(`fn ${t}`);
    if (r !== -1) {
      const i = n.indexOf("->", r);
      if (i !== -1) {
        const a = n.substring(r, i), s = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let o;
        for (; (o = s.exec(a)) !== null; ) {
          const l = BYt[o[3]] ?? "float32";
          e[o[2]] = {
            location: parseInt(o[1], 10),
            format: l,
            stride: FYt(l).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return e;
  }
  function qT(n) {
    var _a2, _b2;
    const t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, e = /@group\((\d+)\)/, r = /@binding\((\d+)\)/, i = /var(<[^>]+>)? (\w+)/, a = /:\s*(\w+)/, s = /struct\s+(\w+)\s*{([^}]+)}/g, o = /(\w+)\s*:\s*([\w\<\>]+)/g, l = /struct\s+(\w+)/, u = (_a2 = n.match(t)) == null ? void 0 : _a2.map((h) => ({
      group: parseInt(h.match(e)[1], 10),
      binding: parseInt(h.match(r)[1], 10),
      name: h.match(i)[2],
      isUniform: h.match(i)[1] === "<uniform>",
      type: h.match(a)[1]
    }));
    if (!u) return {
      groups: [],
      structs: []
    };
    const c = ((_b2 = n.match(s)) == null ? void 0 : _b2.map((h) => {
      const f = h.match(l)[1], d = h.match(o).reduce((p, g) => {
        const [v, m] = g.split(":");
        return p[v.trim()] = m.trim(), p;
      }, {});
      return d ? {
        name: f,
        members: d
      } : null;
    }).filter(({ name: h }) => u.some((f) => f.type === h))) ?? [];
    return {
      groups: u,
      structs: c
    };
  }
  var ag = ((n) => (n[n.VERTEX = 1] = "VERTEX", n[n.FRAGMENT = 2] = "FRAGMENT", n[n.COMPUTE = 4] = "COMPUTE", n))(ag || {});
  function VYt({ groups: n }) {
    const t = [];
    for (let e = 0; e < n.length; e++) {
      const r = n[e];
      t[r.group] || (t[r.group] = []), r.isUniform ? t[r.group].push({
        binding: r.binding,
        visibility: ag.VERTEX | ag.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      }) : r.type === "sampler" ? t[r.group].push({
        binding: r.binding,
        visibility: ag.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      }) : r.type === "texture_2d" && t[r.group].push({
        binding: r.binding,
        visibility: ag.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
    return t;
  }
  function GYt({ groups: n }) {
    const t = [];
    for (let e = 0; e < n.length; e++) {
      const r = n[e];
      t[r.group] || (t[r.group] = {}), t[r.group][r.name] = r.binding;
    }
    return t;
  }
  function WYt(n, t) {
    const e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = [
      ...n.structs,
      ...t.structs
    ].filter((s) => e.has(s.name) ? false : (e.add(s.name), true)), a = [
      ...n.groups,
      ...t.groups
    ].filter((s) => {
      const o = `${s.name}-${s.binding}`;
      return r.has(o) ? false : (r.add(o), true);
    });
    return {
      structs: i,
      groups: a
    };
  }
  const jT = /* @__PURE__ */ Object.create(null);
  Lw = class {
    constructor(t) {
      var _a2, _b2;
      this._layoutKey = 0, this._attributeLocationsKey = 0;
      const { fragment: e, vertex: r, layout: i, gpuLayout: a, name: s } = t;
      if (this.name = s, this.fragment = e, this.vertex = r, e.source === r.source) {
        const o = qT(e.source);
        this.structsAndGroups = o;
      } else {
        const o = qT(r.source), l = qT(e.source);
        this.structsAndGroups = WYt(o, l);
      }
      this.layout = i ?? GYt(this.structsAndGroups), this.gpuLayout = a ?? VYt(this.structsAndGroups), this.autoAssignGlobalUniforms = ((_a2 = this.layout[0]) == null ? void 0 : _a2.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((_b2 = this.layout[1]) == null ? void 0 : _b2.localUniforms) !== void 0, this._generateProgramKey();
    }
    _generateProgramKey() {
      const { vertex: t, fragment: e } = this, r = t.source + e.source + t.entryPoint + e.entryPoint;
      this._layoutKey = EN(r, "program");
    }
    get attributeData() {
      return this._attributeData ?? (this._attributeData = zYt(this.vertex)), this._attributeData;
    }
    destroy() {
      this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
    }
    static from(t) {
      const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
      return jT[e] || (jT[e] = new Lw(t)), jT[e];
    }
  };
  const lQ = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>",
    "vec2<i32>",
    "vec3<i32>",
    "vec4<i32>"
  ], UYt = lQ.reduce((n, t) => (n[t] = true, n), {});
  function HYt(n, t) {
    switch (n) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * t);
      case "vec3<f32>":
        return new Float32Array(3 * t);
      case "vec4<f32>":
        return new Float32Array(4 * t);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  const uQ = class cQ {
    constructor(t, e) {
      this._touched = 0, this.uid = Yn("uniform"), this._resourceType = "uniformGroup", this._resourceId = Yn("resource"), this.isUniformGroup = true, this._dirtyId = 0, this.destroyed = false, e = {
        ...cQ.defaultOptions,
        ...e
      }, this.uniformStructures = t;
      const r = {};
      for (const i in t) {
        const a = t[i];
        if (a.name = i, a.size = a.size ?? 1, !UYt[a.type]) throw new Error(`Uniform type ${a.type} is not supported. Supported uniform types are: ${lQ.join(", ")}`);
        a.value ?? (a.value = HYt(a.type, a.size)), r[i] = a.value;
      }
      this.uniforms = r, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = EN(Object.keys(r).map((i) => `${i}-${t[i].type}`).join("-"), "uniform-group");
    }
    update() {
      this._dirtyId++;
    }
  };
  uQ.defaultOptions = {
    ubo: false,
    isStatic: false
  };
  hQ = uQ;
  Nx = class {
    constructor(t) {
      this.resources = /* @__PURE__ */ Object.create(null), this._dirty = true;
      let e = 0;
      for (const r in t) {
        const i = t[r];
        this.setResource(i, e++);
      }
      this._updateKey();
    }
    _updateKey() {
      if (!this._dirty) return;
      this._dirty = false;
      const t = [];
      let e = 0;
      for (const r in this.resources) t[e++] = this.resources[r]._resourceId;
      this._key = t.join("|");
    }
    setResource(t, e) {
      var _a2, _b2;
      const r = this.resources[e];
      t !== r && (r && ((_a2 = t.off) == null ? void 0 : _a2.call(t, "change", this.onResourceChange, this)), (_b2 = t.on) == null ? void 0 : _b2.call(t, "change", this.onResourceChange, this), this.resources[e] = t, this._dirty = true);
    }
    getResource(t) {
      return this.resources[t];
    }
    _touch(t) {
      const e = this.resources;
      for (const r in e) e[r]._touched = t;
    }
    destroy() {
      var _a2, _b2;
      const t = this.resources;
      for (const e in t) (_b2 = (_a2 = t[e]).off) == null ? void 0 : _b2.call(_a2, "change", this.onResourceChange, this);
      this.resources = null;
    }
    onResourceChange(t) {
      if (this._dirty = true, t.destroyed) {
        const e = this.resources;
        for (const r in e) e[r] === t && (e[r] = null);
      } else this._updateKey();
    }
  };
  rk = ((n) => (n[n.WEBGL = 1] = "WEBGL", n[n.WEBGPU = 2] = "WEBGPU", n[n.BOTH = 3] = "BOTH", n))(rk || {});
  MN = class extends po {
    constructor(t) {
      super(), this.uid = Yn("shader"), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
      let { gpuProgram: e, glProgram: r, groups: i, resources: a, compatibleRenderers: s, groupMap: o } = t;
      this.gpuProgram = e, this.glProgram = r, s === void 0 && (s = 0, e && (s |= rk.WEBGPU), r && (s |= rk.WEBGL)), this.compatibleRenderers = s;
      const l = {};
      if (!a && !i && (a = {}), a && i) throw new Error("[Shader] Cannot have both resources and groups");
      if (!e && i && !o) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      if (!e && i && o) for (const u in o) for (const c in o[u]) {
        const h = o[u][c];
        l[h] = {
          group: u,
          binding: c,
          name: h
        };
      }
      else if (e && i && !o) {
        const u = e.structsAndGroups.groups;
        o = {}, u.forEach((c) => {
          o[c.group] = o[c.group] || {}, o[c.group][c.binding] = c.name, l[c.name] = c;
        });
      } else if (a) {
        i = {}, o = {}, e && e.structsAndGroups.groups.forEach((h) => {
          o[h.group] = o[h.group] || {}, o[h.group][h.binding] = h.name, l[h.name] = h;
        });
        let u = 0;
        for (const c in a) l[c] || (i[99] || (i[99] = new Nx(), this._ownedBindGroups.push(i[99])), l[c] = {
          group: 99,
          binding: u,
          name: c
        }, o[99] = o[99] || {}, o[99][u] = c, u++);
        for (const c in a) {
          const h = c;
          let f = a[c];
          !f.source && !f._resourceType && (f = new hQ(f));
          const d = l[h];
          d && (i[d.group] || (i[d.group] = new Nx(), this._ownedBindGroups.push(i[d.group])), i[d.group].setResource(f, d.binding));
        }
      }
      this.groups = i, this._uniformBindMap = o, this.resources = this._buildResourceAccessor(i, l);
    }
    addResource(t, e, r) {
      var i, a;
      (i = this._uniformBindMap)[e] || (i[e] = {}), (a = this._uniformBindMap[e])[r] || (a[r] = t), this.groups[e] || (this.groups[e] = new Nx(), this._ownedBindGroups.push(this.groups[e]));
    }
    _buildResourceAccessor(t, e) {
      const r = {};
      for (const i in e) {
        const a = e[i];
        Object.defineProperty(r, a.name, {
          get() {
            return t[a.group].getResource(a.binding);
          },
          set(s) {
            t[a.group].setResource(s, a.binding);
          }
        });
      }
      return r;
    }
    destroy(t = false) {
      var _a2, _b2;
      this.emit("destroy", this), t && ((_a2 = this.gpuProgram) == null ? void 0 : _a2.destroy(), (_b2 = this.glProgram) == null ? void 0 : _b2.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((e) => {
        e.destroy();
      }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
    }
    static from(t) {
      const { gpu: e, gl: r, ...i } = t;
      let a, s;
      return e && (a = Lw.from(e)), r && (s = oQ.from(r)), new MN({
        gpuProgram: a,
        glProgram: s,
        ...i
      });
    }
  };
  const ik = [];
  Pa.handleByNamedList(rn.Environment, ik);
  async function XYt(n) {
    if (!n) for (let t = 0; t < ik.length; t++) {
      const e = ik[t];
      if (e.value.test()) {
        await e.value.load();
        return;
      }
    }
  }
  let Rp;
  YYt = function() {
    if (typeof Rp == "boolean") return Rp;
    try {
      Rp = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
        a: "b"
      }, "a", "b") === true;
    } catch {
      Rp = false;
    }
    return Rp;
  };
  var G0 = {
    exports: {}
  }, VG;
  function qYt() {
    if (VG) return G0.exports;
    VG = 1, G0.exports = n, G0.exports.default = n;
    function n(k, N, R) {
      R = R || 2;
      var $ = N && N.length, O = $ ? N[0] * R : k.length, F = t(k, 0, O, R, true), z = [];
      if (!F || F.next === F.prev) return z;
      var V, U, X, at, pt, it, et;
      if ($ && (F = l(k, N, F, R)), k.length > 80 * R) {
        V = X = k[0], U = at = k[1];
        for (var ft = R; ft < O; ft += R) pt = k[ft], it = k[ft + 1], pt < V && (V = pt), it < U && (U = it), pt > X && (X = pt), it > at && (at = it);
        et = Math.max(X - V, at - U), et = et !== 0 ? 32767 / et : 0;
      }
      return r(F, z, R, V, U, et, 0), z;
    }
    function t(k, N, R, $, O) {
      var F, z;
      if (O === L(k, N, R, $) > 0) for (F = N; F < R; F += $) z = D(F, k[F], k[F + 1], z);
      else for (F = R - $; F >= N; F -= $) z = D(F, k[F], k[F + 1], z);
      return z && b(z, z.next) && (E(z), z = z.next), z;
    }
    function e(k, N) {
      if (!k) return k;
      N || (N = k);
      var R = k, $;
      do
        if ($ = false, !R.steiner && (b(R, R.next) || x(R.prev, R, R.next) === 0)) {
          if (E(R), R = N = R.prev, R === R.next) break;
          $ = true;
        } else R = R.next;
      while ($ || R !== N);
      return N;
    }
    function r(k, N, R, $, O, F, z) {
      if (k) {
        !z && F && d(k, $, O, F);
        for (var V = k, U, X; k.prev !== k.next; ) {
          if (U = k.prev, X = k.next, F ? a(k, $, O, F) : i(k)) {
            N.push(U.i / R | 0), N.push(k.i / R | 0), N.push(X.i / R | 0), E(k), k = X.next, V = X.next;
            continue;
          }
          if (k = X, k === V) {
            z ? z === 1 ? (k = s(e(k), N, R), r(k, N, R, $, O, F, 2)) : z === 2 && o(k, N, R, $, O, F) : r(e(k), N, R, $, O, F, 1);
            break;
          }
        }
      }
    }
    function i(k) {
      var N = k.prev, R = k, $ = k.next;
      if (x(N, R, $) >= 0) return false;
      for (var O = N.x, F = R.x, z = $.x, V = N.y, U = R.y, X = $.y, at = O < F ? O < z ? O : z : F < z ? F : z, pt = V < U ? V < X ? V : X : U < X ? U : X, it = O > F ? O > z ? O : z : F > z ? F : z, et = V > U ? V > X ? V : X : U > X ? U : X, ft = $.next; ft !== N; ) {
        if (ft.x >= at && ft.x <= it && ft.y >= pt && ft.y <= et && m(O, V, F, U, z, X, ft.x, ft.y) && x(ft.prev, ft, ft.next) >= 0) return false;
        ft = ft.next;
      }
      return true;
    }
    function a(k, N, R, $) {
      var O = k.prev, F = k, z = k.next;
      if (x(O, F, z) >= 0) return false;
      for (var V = O.x, U = F.x, X = z.x, at = O.y, pt = F.y, it = z.y, et = V < U ? V < X ? V : X : U < X ? U : X, ft = at < pt ? at < it ? at : it : pt < it ? pt : it, ut = V > U ? V > X ? V : X : U > X ? U : X, gt = at > pt ? at > it ? at : it : pt > it ? pt : it, kt = g(et, ft, N, R, $), At = g(ut, gt, N, R, $), mt = k.prevZ, _t = k.nextZ; mt && mt.z >= kt && _t && _t.z <= At; ) {
        if (mt.x >= et && mt.x <= ut && mt.y >= ft && mt.y <= gt && mt !== O && mt !== z && m(V, at, U, pt, X, it, mt.x, mt.y) && x(mt.prev, mt, mt.next) >= 0 || (mt = mt.prevZ, _t.x >= et && _t.x <= ut && _t.y >= ft && _t.y <= gt && _t !== O && _t !== z && m(V, at, U, pt, X, it, _t.x, _t.y) && x(_t.prev, _t, _t.next) >= 0)) return false;
        _t = _t.nextZ;
      }
      for (; mt && mt.z >= kt; ) {
        if (mt.x >= et && mt.x <= ut && mt.y >= ft && mt.y <= gt && mt !== O && mt !== z && m(V, at, U, pt, X, it, mt.x, mt.y) && x(mt.prev, mt, mt.next) >= 0) return false;
        mt = mt.prevZ;
      }
      for (; _t && _t.z <= At; ) {
        if (_t.x >= et && _t.x <= ut && _t.y >= ft && _t.y <= gt && _t !== O && _t !== z && m(V, at, U, pt, X, it, _t.x, _t.y) && x(_t.prev, _t, _t.next) >= 0) return false;
        _t = _t.nextZ;
      }
      return true;
    }
    function s(k, N, R) {
      var $ = k;
      do {
        var O = $.prev, F = $.next.next;
        !b(O, F) && _(O, $, $.next, F) && T(O, F) && T(F, O) && (N.push(O.i / R | 0), N.push($.i / R | 0), N.push(F.i / R | 0), E($), E($.next), $ = k = F), $ = $.next;
      } while ($ !== k);
      return e($);
    }
    function o(k, N, R, $, O, F) {
      var z = k;
      do {
        for (var V = z.next.next; V !== z.prev; ) {
          if (z.i !== V.i && y(z, V)) {
            var U = C(z, V);
            z = e(z, z.next), U = e(U, U.next), r(z, N, R, $, O, F, 0), r(U, N, R, $, O, F, 0);
            return;
          }
          V = V.next;
        }
        z = z.next;
      } while (z !== k);
    }
    function l(k, N, R, $) {
      var O = [], F, z, V, U, X;
      for (F = 0, z = N.length; F < z; F++) V = N[F] * $, U = F < z - 1 ? N[F + 1] * $ : k.length, X = t(k, V, U, $, false), X === X.next && (X.steiner = true), O.push(v(X));
      for (O.sort(u), F = 0; F < O.length; F++) R = c(O[F], R);
      return R;
    }
    function u(k, N) {
      return k.x - N.x;
    }
    function c(k, N) {
      var R = h(k, N);
      if (!R) return N;
      var $ = C(R, k);
      return e($, $.next), e(R, R.next);
    }
    function h(k, N) {
      var R = N, $ = k.x, O = k.y, F = -1 / 0, z;
      do {
        if (O <= R.y && O >= R.next.y && R.next.y !== R.y) {
          var V = R.x + (O - R.y) * (R.next.x - R.x) / (R.next.y - R.y);
          if (V <= $ && V > F && (F = V, z = R.x < R.next.x ? R : R.next, V === $)) return z;
        }
        R = R.next;
      } while (R !== N);
      if (!z) return null;
      var U = z, X = z.x, at = z.y, pt = 1 / 0, it;
      R = z;
      do
        $ >= R.x && R.x >= X && $ !== R.x && m(O < at ? $ : F, O, X, at, O < at ? F : $, O, R.x, R.y) && (it = Math.abs(O - R.y) / ($ - R.x), T(R, k) && (it < pt || it === pt && (R.x > z.x || R.x === z.x && f(z, R))) && (z = R, pt = it)), R = R.next;
      while (R !== U);
      return z;
    }
    function f(k, N) {
      return x(k.prev, k, N.prev) < 0 && x(N.next, k, k.next) < 0;
    }
    function d(k, N, R, $) {
      var O = k;
      do
        O.z === 0 && (O.z = g(O.x, O.y, N, R, $)), O.prevZ = O.prev, O.nextZ = O.next, O = O.next;
      while (O !== k);
      O.prevZ.nextZ = null, O.prevZ = null, p(O);
    }
    function p(k) {
      var N, R, $, O, F, z, V, U, X = 1;
      do {
        for (R = k, k = null, F = null, z = 0; R; ) {
          for (z++, $ = R, V = 0, N = 0; N < X && (V++, $ = $.nextZ, !!$); N++) ;
          for (U = X; V > 0 || U > 0 && $; ) V !== 0 && (U === 0 || !$ || R.z <= $.z) ? (O = R, R = R.nextZ, V--) : (O = $, $ = $.nextZ, U--), F ? F.nextZ = O : k = O, O.prevZ = F, F = O;
          R = $;
        }
        F.nextZ = null, X *= 2;
      } while (z > 1);
      return k;
    }
    function g(k, N, R, $, O) {
      return k = (k - R) * O | 0, N = (N - $) * O | 0, k = (k | k << 8) & 16711935, k = (k | k << 4) & 252645135, k = (k | k << 2) & 858993459, k = (k | k << 1) & 1431655765, N = (N | N << 8) & 16711935, N = (N | N << 4) & 252645135, N = (N | N << 2) & 858993459, N = (N | N << 1) & 1431655765, k | N << 1;
    }
    function v(k) {
      var N = k, R = k;
      do
        (N.x < R.x || N.x === R.x && N.y < R.y) && (R = N), N = N.next;
      while (N !== k);
      return R;
    }
    function m(k, N, R, $, O, F, z, V) {
      return (O - z) * (N - V) >= (k - z) * (F - V) && (k - z) * ($ - V) >= (R - z) * (N - V) && (R - z) * (F - V) >= (O - z) * ($ - V);
    }
    function y(k, N) {
      return k.next.i !== N.i && k.prev.i !== N.i && !I(k, N) && (T(k, N) && T(N, k) && A(k, N) && (x(k.prev, k, N.prev) || x(k, N.prev, N)) || b(k, N) && x(k.prev, k, k.next) > 0 && x(N.prev, N, N.next) > 0);
    }
    function x(k, N, R) {
      return (N.y - k.y) * (R.x - N.x) - (N.x - k.x) * (R.y - N.y);
    }
    function b(k, N) {
      return k.x === N.x && k.y === N.y;
    }
    function _(k, N, R, $) {
      var O = S(x(k, N, R)), F = S(x(k, N, $)), z = S(x(R, $, k)), V = S(x(R, $, N));
      return !!(O !== F && z !== V || O === 0 && w(k, R, N) || F === 0 && w(k, $, N) || z === 0 && w(R, k, $) || V === 0 && w(R, N, $));
    }
    function w(k, N, R) {
      return N.x <= Math.max(k.x, R.x) && N.x >= Math.min(k.x, R.x) && N.y <= Math.max(k.y, R.y) && N.y >= Math.min(k.y, R.y);
    }
    function S(k) {
      return k > 0 ? 1 : k < 0 ? -1 : 0;
    }
    function I(k, N) {
      var R = k;
      do {
        if (R.i !== k.i && R.next.i !== k.i && R.i !== N.i && R.next.i !== N.i && _(R, R.next, k, N)) return true;
        R = R.next;
      } while (R !== k);
      return false;
    }
    function T(k, N) {
      return x(k.prev, k, k.next) < 0 ? x(k, N, k.next) >= 0 && x(k, k.prev, N) >= 0 : x(k, N, k.prev) < 0 || x(k, k.next, N) < 0;
    }
    function A(k, N) {
      var R = k, $ = false, O = (k.x + N.x) / 2, F = (k.y + N.y) / 2;
      do
        R.y > F != R.next.y > F && R.next.y !== R.y && O < (R.next.x - R.x) * (F - R.y) / (R.next.y - R.y) + R.x && ($ = !$), R = R.next;
      while (R !== k);
      return $;
    }
    function C(k, N) {
      var R = new M(k.i, k.x, k.y), $ = new M(N.i, N.x, N.y), O = k.next, F = N.prev;
      return k.next = N, N.prev = k, R.next = O, O.prev = R, $.next = R, R.prev = $, F.next = $, $.prev = F, $;
    }
    function D(k, N, R, $) {
      var O = new M(k, N, R);
      return $ ? (O.next = $.next, O.prev = $, $.next.prev = O, $.next = O) : (O.prev = O, O.next = O), O;
    }
    function E(k) {
      k.next.prev = k.prev, k.prev.next = k.next, k.prevZ && (k.prevZ.nextZ = k.nextZ), k.nextZ && (k.nextZ.prevZ = k.prevZ);
    }
    function M(k, N, R) {
      this.i = k, this.x = N, this.y = R, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    n.deviation = function(k, N, R, $) {
      var O = N && N.length, F = O ? N[0] * R : k.length, z = Math.abs(L(k, 0, F, R));
      if (O) for (var V = 0, U = N.length; V < U; V++) {
        var X = N[V] * R, at = V < U - 1 ? N[V + 1] * R : k.length;
        z -= Math.abs(L(k, X, at, R));
      }
      var pt = 0;
      for (V = 0; V < $.length; V += 3) {
        var it = $[V] * R, et = $[V + 1] * R, ft = $[V + 2] * R;
        pt += Math.abs((k[it] - k[ft]) * (k[et + 1] - k[it + 1]) - (k[it] - k[et]) * (k[ft + 1] - k[it + 1]));
      }
      return z === 0 && pt === 0 ? 0 : Math.abs((pt - z) / z);
    };
    function L(k, N, R, $) {
      for (var O = 0, F = N, z = R - $; F < R; F += $) O += (k[z] - k[F]) * (k[F + 1] + k[z + 1]), z = F;
      return O;
    }
    return n.flatten = function(k) {
      for (var N = k[0][0].length, R = {
        vertices: [],
        holes: [],
        dimensions: N
      }, $ = 0, O = 0; O < k.length; O++) {
        for (var F = 0; F < k[O].length; F++) for (var z = 0; z < N; z++) R.vertices.push(k[O][F][z]);
        O > 0 && ($ += k[O - 1].length, R.holes.push($));
      }
      return R;
    }, G0.exports;
  }
  var jYt = qYt();
  const KYt = nw(jYt);
  fQ = ((n) => (n[n.NONE = 0] = "NONE", n[n.COLOR = 16384] = "COLOR", n[n.STENCIL = 1024] = "STENCIL", n[n.DEPTH = 256] = "DEPTH", n[n.COLOR_DEPTH = 16640] = "COLOR_DEPTH", n[n.COLOR_STENCIL = 17408] = "COLOR_STENCIL", n[n.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", n[n.ALL = 17664] = "ALL", n))(fQ || {});
  ZYt = class {
    constructor(t) {
      this.items = [], this._name = t;
    }
    emit(t, e, r, i, a, s, o, l) {
      const { name: u, items: c } = this;
      for (let h = 0, f = c.length; h < f; h++) c[h][u](t, e, r, i, a, s, o, l);
      return this;
    }
    add(t) {
      return t[this._name] && (this.remove(t), this.items.push(t)), this;
    }
    remove(t) {
      const e = this.items.indexOf(t);
      return e !== -1 && this.items.splice(e, 1), this;
    }
    contains(t) {
      return this.items.indexOf(t) !== -1;
    }
    removeAll() {
      return this.items.length = 0, this;
    }
    destroy() {
      this.removeAll(), this.items = null, this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  };
  const JYt = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "resetState",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender"
  ], dQ = class pQ extends po {
    constructor(t) {
      super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
      const e = [
        ...JYt,
        ...this.config.runners ?? []
      ];
      this._addRunners(...e), this._unsafeEvalCheck();
    }
    async init(t = {}) {
      const e = t.skipExtensionImports === true ? true : t.manageImports === false;
      await XYt(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (const r in this._systemsHash) t = {
        ...this._systemsHash[r].constructor.defaultOptions,
        ...t
      };
      t = {
        ...pQ.defaultOptions,
        ...t
      }, this._roundPixels = t.roundPixels ? 1 : 0;
      for (let r = 0; r < this.runners.init.items.length; r++) await this.runners.init.items[r].init(t);
      this._initOptions = t;
    }
    render(t, e) {
      let r = t;
      if (r instanceof Eh && (r = {
        container: r
      }, e && (fn(An, "passing a second argument is deprecated, please use render options instead"), r.target = e.renderTexture)), r.target || (r.target = this.view.renderTarget), r.target === this.view.renderTarget && (this._lastObjectRendered = r.container, r.clearColor ?? (r.clearColor = this.background.colorRgba), r.clear ?? (r.clear = this.background.clearBeforeRender)), r.clearColor) {
        const i = Array.isArray(r.clearColor) && r.clearColor.length === 4;
        r.clearColor = i ? r.clearColor : jr.shared.setValue(r.clearColor).toArray();
      }
      r.transform || (r.container.updateLocalTransform(), r.transform = r.container.localTransform), r.container.enableRenderGroup(), this.runners.prerender.emit(r), this.runners.renderStart.emit(r), this.runners.render.emit(r), this.runners.renderEnd.emit(r), this.runners.postrender.emit(r);
    }
    resize(t, e, r) {
      const i = this.view.resolution;
      this.view.resize(t, e, r), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), r !== void 0 && r !== i && this.runners.resolutionChange.emit(r);
    }
    clear(t = {}) {
      const e = this;
      t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = fQ.ALL);
      const { clear: r, clearColor: i, target: a } = t;
      jr.shared.setValue(i ?? this.background.colorRgba), e.renderTarget.clear(a, r, jr.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(t) {
      this.view.resolution = t, this.runners.resolutionChange.emit(t);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      return this.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...t) {
      t.forEach((e) => {
        this.runners[e] = new ZYt(e);
      });
    }
    _addSystems(t) {
      let e;
      for (e in t) {
        const r = t[e];
        this._addSystem(r.value, r.name);
      }
    }
    _addSystem(t, e) {
      const r = new t(this);
      if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`);
      this[e] = r, this._systemsHash[e] = r;
      for (const i in this.runners) this.runners[i].add(r);
      return this;
    }
    _addPipes(t, e) {
      const r = e.reduce((i, a) => (i[a.name] = a.value, i), {});
      t.forEach((i) => {
        const a = i.value, s = i.name, o = r[s];
        this.renderPipes[s] = new a(this, o ? new o() : null);
      });
    }
    destroy(t = false) {
      this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e) => {
        e.destroy();
      }), this._systemsHash = null, this.renderPipes = null;
    }
    generateTexture(t) {
      return this.textureGenerator.generateTexture(t);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!YYt()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
    resetState() {
      this.runners.resetState.emit();
    }
  };
  dQ.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: false,
    roundPixels: false
  };
  let W0;
  gQ = dQ;
  function QYt(n) {
    return W0 !== void 0 || (W0 = (() => {
      var _a2;
      const t = {
        stencil: true,
        failIfMajorPerformanceCaveat: n ?? gQ.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!as.get().getWebGLRenderingContext()) return false;
        let r = as.get().createCanvas().getContext("webgl", t);
        const i = !!((_a2 = r == null ? void 0 : r.getContextAttributes()) == null ? void 0 : _a2.stencil);
        if (r) {
          const a = r.getExtension("WEBGL_lose_context");
          a && a.loseContext();
        }
        return r = null, i;
      } catch {
        return false;
      }
    })()), W0;
  }
  let U0;
  async function tqt(n = {}) {
    return U0 !== void 0 || (U0 = await (async () => {
      const t = as.get().getNavigator().gpu;
      if (!t) return false;
      try {
        return await (await t.requestAdapter(n)).requestDevice(), true;
      } catch {
        return false;
      }
    })()), U0;
  }
  const GG = [
    "webgl",
    "webgpu",
    "canvas"
  ];
  async function eqt(n) {
    let t = [];
    n.preference ? (t.push(n.preference), GG.forEach((a) => {
      a !== n.preference && t.push(a);
    })) : t = GG.slice();
    let e, r = {};
    for (let a = 0; a < t.length; a++) {
      const s = t[a];
      if (s === "webgpu" && await tqt()) {
        const { WebGPURenderer: o } = await Bf(async () => {
          const { WebGPURenderer: l } = await import("./WebGPURenderer-BQ_LKRBC.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            WebGPURenderer: l
          };
        }, __vite__mapDeps([6,2,7,3,4,5]));
        e = o, r = {
          ...n,
          ...n.webgpu
        };
        break;
      } else if (s === "webgl" && QYt(n.failIfMajorPerformanceCaveat ?? gQ.defaultOptions.failIfMajorPerformanceCaveat)) {
        const { WebGLRenderer: o } = await Bf(async () => {
          const { WebGLRenderer: l } = await import("./WebGLRenderer-BZ74uuMe.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            WebGLRenderer: l
          };
        }, __vite__mapDeps([8,2,7,4,5]));
        e = o, r = {
          ...n,
          ...n.webgl
        };
        break;
      } else if (s === "canvas") throw r = {
        ...n
      }, new Error("CanvasRenderer is not yet implemented");
    }
    if (delete r.webgpu, delete r.webgl, !e) throw new Error("No available renderer for the current environment");
    const i = new e();
    return await i.init(r), i;
  }
  vQ = "8.8.0";
  class mQ {
    static init() {
      var _a2;
      (_a2 = globalThis.__PIXI_APP_INIT__) == null ? void 0 : _a2.call(globalThis, this, vQ);
    }
    static destroy() {
    }
  }
  mQ.extension = rn.Application;
  nqt = class {
    constructor(t) {
      this._renderer = t;
    }
    init() {
      var _a2;
      (_a2 = globalThis.__PIXI_RENDERER_INIT__) == null ? void 0 : _a2.call(globalThis, this._renderer, vQ);
    }
    destroy() {
      this._renderer = null;
    }
  };
  nqt.extension = {
    type: [
      rn.WebGLSystem,
      rn.WebGPUSystem
    ],
    name: "initHook",
    priority: -10
  };
  const yQ = class ak {
    constructor(...t) {
      this.stage = new Eh(), t[0] !== void 0 && fn(An, "Application constructor options are deprecated, please use Application.init() instead.");
    }
    async init(t) {
      t = {
        ...t
      }, this.renderer = await eqt(t), ak._plugins.forEach((e) => {
        e.init.call(this, t);
      });
    }
    render() {
      this.renderer.render({
        container: this.stage
      });
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      return fn(An, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(t = false, e = false) {
      const r = ak._plugins.slice(0);
      r.reverse(), r.forEach((i) => {
        i.destroy.call(this);
      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
    }
  };
  yQ._plugins = [];
  let xQ = yQ;
  Pa.handleByList(rn.Application, xQ._plugins);
  Pa.add(mQ);
  const WG = [
    {
      offset: 0,
      color: "white"
    },
    {
      offset: 1,
      color: "black"
    }
  ], RN = class sk {
    constructor(...t) {
      this.uid = Yn("fillGradient"), this.type = "linear", this.colorStops = [];
      let e = rqt(t);
      e = {
        ...e.type === "radial" ? sk.defaultRadialOptions : sk.defaultLinearOptions,
        ...DJ(e)
      }, this._textureSize = e.textureSize, e.type === "radial" ? (this.center = e.center, this.outerCenter = e.outerCenter ?? this.center, this.innerRadius = e.innerRadius, this.outerRadius = e.outerRadius, this.scale = e.scale, this.rotation = e.rotation) : (this.start = e.start, this.end = e.end), this.textureSpace = e.textureSpace, this.type = e.type, e.colorStops.forEach((i) => {
        this.addColorStop(i.offset, i.color);
      });
    }
    addColorStop(t, e) {
      return this.colorStops.push({
        offset: t,
        color: jr.shared.setValue(e).toHexa()
      }), this;
    }
    buildLinearGradient() {
      if (this.texture) return;
      const t = this.colorStops.length ? this.colorStops : WG, e = this._textureSize, { canvas: r, context: i } = HG(e, 1), a = i.createLinearGradient(0, 0, this._textureSize, 0);
      UG(a, t), i.fillStyle = a, i.fillRect(0, 0, e, 1), this.texture = new on({
        source: new l1({
          resource: r
        })
      });
      const { x: s, y: o } = this.start, { x: l, y: u } = this.end, c = new Ve(), h = l - s, f = u - o, d = Math.sqrt(h * h + f * f), p = Math.atan2(f, h);
      c.scale(d / e, 1), c.rotate(p), c.translate(s, o), this.textureSpace === "local" && c.scale(e, e), this.transform = c;
    }
    buildGradient() {
      this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
    }
    buildRadialGradient() {
      if (this.texture) return;
      const t = this.colorStops.length ? this.colorStops : WG, e = this._textureSize, { canvas: r, context: i } = HG(e, e), { x: a, y: s } = this.center, { x: o, y: l } = this.outerCenter, u = this.innerRadius, c = this.outerRadius, h = o - c, f = l - c, d = e / (c * 2), p = (a - h) * d, g = (s - f) * d, v = i.createRadialGradient(p, g, u * d, (o - h) * d, (l - f) * d, c * d);
      UG(v, t), i.fillStyle = t[t.length - 1].color, i.fillRect(0, 0, e, e), i.fillStyle = v, i.translate(p, g), i.rotate(this.rotation), i.scale(1, this.scale), i.translate(-p, -g), i.fillRect(0, 0, e, e), this.texture = new on({
        source: new l1({
          resource: r,
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        })
      });
      const m = new Ve();
      m.scale(1 / d, 1 / d), m.translate(h, f), this.textureSpace === "local" && m.scale(e, e), this.transform = m;
    }
    get styleKey() {
      return this.uid;
    }
    destroy() {
      var _a2;
      (_a2 = this.texture) == null ? void 0 : _a2.destroy(true), this.texture = null;
    }
  };
  RN.defaultLinearOptions = {
    start: {
      x: 0,
      y: 0
    },
    end: {
      x: 0,
      y: 1
    },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256
  };
  RN.defaultRadialOptions = {
    center: {
      x: 0.5,
      y: 0.5
    },
    innerRadius: 0,
    outerRadius: 0.5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256
  };
  ch = RN;
  function UG(n, t) {
    for (let e = 0; e < t.length; e++) {
      const r = t[e];
      n.addColorStop(r.offset, r.color);
    }
  }
  function HG(n, t) {
    const e = as.get().createCanvas(n, t), r = e.getContext("2d");
    return {
      canvas: e,
      context: r
    };
  }
  function rqt(n) {
    let t = n[0] ?? {};
    return (typeof t == "number" || n[1]) && (fn("8.5.2", "use options object instead"), t = {
      type: "linear",
      start: {
        x: n[0],
        y: n[1]
      },
      end: {
        x: n[2],
        y: n[3]
      },
      textureSpace: n[4],
      textureSize: n[5] ?? ch.defaultLinearOptions.textureSize
    }), t;
  }
  const XG = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  NN = class {
    constructor(t, e) {
      this.uid = Yn("fillPattern"), this.transform = new Ve(), this._styleKey = null, this.texture = t, this.transform.scale(1 / t.frame.width, 1 / t.frame.height), e && (t.source.style.addressModeU = XG[e].addressModeU, t.source.style.addressModeV = XG[e].addressModeV);
    }
    setTransform(t) {
      const e = this.texture;
      this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(1 / e.frame.width, 1 / e.frame.height), this._styleKey = null;
    }
    get styleKey() {
      return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
    }
  };
  var KT, YG;
  function iqt() {
    if (YG) return KT;
    YG = 1, KT = e;
    var n = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    }, t = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function e(a) {
      var s = [];
      return a.replace(t, function(o, l, u) {
        var c = l.toLowerCase();
        for (u = i(u), c == "m" && u.length > 2 && (s.push([
          l
        ].concat(u.splice(0, 2))), c = "l", l = l == "m" ? "l" : "L"); ; ) {
          if (u.length == n[c]) return u.unshift(l), s.push(u);
          if (u.length < n[c]) throw new Error("malformed path data");
          s.push([
            l
          ].concat(u.splice(0, n[c])));
        }
      }), s;
    }
    var r = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function i(a) {
      var s = a.match(r);
      return s ? s.map(Number) : [];
    }
    return KT;
  }
  var aqt = iqt();
  const sqt = nw(aqt);
  function oqt(n, t) {
    const e = sqt(n), r = [];
    let i = null, a = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      const l = e[o], u = l[0], c = l;
      switch (u) {
        case "M":
          a = c[1], s = c[2], t.moveTo(a, s);
          break;
        case "m":
          a += c[1], s += c[2], t.moveTo(a, s);
          break;
        case "H":
          a = c[1], t.lineTo(a, s);
          break;
        case "h":
          a += c[1], t.lineTo(a, s);
          break;
        case "V":
          s = c[1], t.lineTo(a, s);
          break;
        case "v":
          s += c[1], t.lineTo(a, s);
          break;
        case "L":
          a = c[1], s = c[2], t.lineTo(a, s);
          break;
        case "l":
          a += c[1], s += c[2], t.lineTo(a, s);
          break;
        case "C":
          a = c[5], s = c[6], t.bezierCurveTo(c[1], c[2], c[3], c[4], a, s);
          break;
        case "c":
          t.bezierCurveTo(a + c[1], s + c[2], a + c[3], s + c[4], a + c[5], s + c[6]), a += c[5], s += c[6];
          break;
        case "S":
          a = c[3], s = c[4], t.bezierCurveToShort(c[1], c[2], a, s);
          break;
        case "s":
          t.bezierCurveToShort(a + c[1], s + c[2], a + c[3], s + c[4]), a += c[3], s += c[4];
          break;
        case "Q":
          a = c[3], s = c[4], t.quadraticCurveTo(c[1], c[2], a, s);
          break;
        case "q":
          t.quadraticCurveTo(a + c[1], s + c[2], a + c[3], s + c[4]), a += c[3], s += c[4];
          break;
        case "T":
          a = c[1], s = c[2], t.quadraticCurveToShort(a, s);
          break;
        case "t":
          a += c[1], s += c[2], t.quadraticCurveToShort(a, s);
          break;
        case "A":
          a = c[6], s = c[7], t.arcToSvg(c[1], c[2], c[3], c[4], c[5], a, s);
          break;
        case "a":
          a += c[6], s += c[7], t.arcToSvg(c[1], c[2], c[3], c[4], c[5], a, s);
          break;
        case "Z":
        case "z":
          t.closePath(), r.length > 0 && (i = r.pop(), i ? (a = i.startX, s = i.startY) : (a = 0, s = 0)), i = null;
          break;
        default:
          Ki(`Unknown SVG path command: ${u}`);
      }
      u !== "Z" && u !== "z" && i === null && (i = {
        startX: a,
        startY: s
      }, r.push(i));
    }
    return t;
  }
  class LN {
    constructor(t = 0, e = 0, r = 0) {
      this.type = "circle", this.x = t, this.y = e, this.radius = r;
    }
    clone() {
      return new LN(this.x, this.y, this.radius);
    }
    contains(t, e) {
      if (this.radius <= 0) return false;
      const r = this.radius * this.radius;
      let i = this.x - t, a = this.y - e;
      return i *= i, a *= a, i + a <= r;
    }
    strokeContains(t, e, r, i = 0.5) {
      if (this.radius === 0) return false;
      const a = this.x - t, s = this.y - e, o = this.radius, l = (1 - i) * r, u = Math.sqrt(a * a + s * s);
      return u <= o + l && u > o - (r - l);
    }
    getBounds(t) {
      return t || (t = new yr()), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  }
  class PN {
    constructor(t = 0, e = 0, r = 0, i = 0) {
      this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = r, this.halfHeight = i;
    }
    clone() {
      return new PN(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(t, e) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;
      let r = (t - this.x) / this.halfWidth, i = (e - this.y) / this.halfHeight;
      return r *= r, i *= i, r + i <= 1;
    }
    strokeContains(t, e, r, i = 0.5) {
      const { halfWidth: a, halfHeight: s } = this;
      if (a <= 0 || s <= 0) return false;
      const o = r * (1 - i), l = r - o, u = a - l, c = s - l, h = a + o, f = s + o, d = t - this.x, p = e - this.y, g = d * d / (u * u) + p * p / (c * c), v = d * d / (h * h) + p * p / (f * f);
      return g > 1 && v <= 1;
    }
    getBounds(t) {
      return t || (t = new yr()), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  }
  function lqt(n, t, e, r, i, a) {
    const s = n - e, o = t - r, l = i - e, u = a - r, c = s * l + o * u, h = l * l + u * u;
    let f = -1;
    h !== 0 && (f = c / h);
    let d, p;
    f < 0 ? (d = e, p = r) : f > 1 ? (d = i, p = a) : (d = e + f * l, p = r + f * u);
    const g = n - d, v = t - p;
    return g * g + v * v;
  }
  let uqt, cqt;
  class Tg {
    constructor(...t) {
      this.type = "polygon";
      let e = Array.isArray(t[0]) ? t[0] : t;
      if (typeof e[0] != "number") {
        const r = [];
        for (let i = 0, a = e.length; i < a; i++) r.push(e[i].x, e[i].y);
        e = r;
      }
      this.points = e, this.closePath = true;
    }
    isClockwise() {
      let t = 0;
      const e = this.points, r = e.length;
      for (let i = 0; i < r; i += 2) {
        const a = e[i], s = e[i + 1], o = e[(i + 2) % r], l = e[(i + 3) % r];
        t += (o - a) * (l + s);
      }
      return t < 0;
    }
    containsPolygon(t) {
      const e = this.getBounds(uqt), r = t.getBounds(cqt);
      if (!e.containsRect(r)) return false;
      const i = t.points;
      for (let a = 0; a < i.length; a += 2) {
        const s = i[a], o = i[a + 1];
        if (!this.contains(s, o)) return false;
      }
      return true;
    }
    clone() {
      const t = this.points.slice(), e = new Tg(t);
      return e.closePath = this.closePath, e;
    }
    contains(t, e) {
      let r = false;
      const i = this.points.length / 2;
      for (let a = 0, s = i - 1; a < i; s = a++) {
        const o = this.points[a * 2], l = this.points[a * 2 + 1], u = this.points[s * 2], c = this.points[s * 2 + 1];
        l > e != c > e && t < (u - o) * ((e - l) / (c - l)) + o && (r = !r);
      }
      return r;
    }
    strokeContains(t, e, r, i = 0.5) {
      const a = r * r, s = a * (1 - i), o = a - s, { points: l } = this, u = l.length - (this.closePath ? 0 : 2);
      for (let c = 0; c < u; c += 2) {
        const h = l[c], f = l[c + 1], d = l[(c + 2) % l.length], p = l[(c + 3) % l.length], g = lqt(t, e, h, f, d, p), v = Math.sign((d - h) * (e - f) - (p - f) * (t - h));
        if (g <= (v < 0 ? o : s)) return true;
      }
      return false;
    }
    getBounds(t) {
      t || (t = new yr());
      const e = this.points;
      let r = 1 / 0, i = -1 / 0, a = 1 / 0, s = -1 / 0;
      for (let o = 0, l = e.length; o < l; o += 2) {
        const u = e[o], c = e[o + 1];
        r = u < r ? u : r, i = u > i ? u : i, a = c < a ? c : a, s = c > s ? c : s;
      }
      return t.x = r, t.width = i - r, t.y = a, t.height = s - a, t;
    }
    copyFrom(t) {
      return this.points = t.points.slice(), this.closePath = t.closePath, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      return this.points[this.points.length - 2];
    }
    get y() {
      return this.points[this.points.length - 1];
    }
  }
  const H0 = (n, t, e, r, i, a, s) => {
    const o = n - e, l = t - r, u = Math.sqrt(o * o + l * l);
    return u >= i - a && u <= i + s;
  };
  class $N {
    constructor(t = 0, e = 0, r = 0, i = 0, a = 20) {
      this.type = "roundedRectangle", this.x = t, this.y = e, this.width = r, this.height = i, this.radius = a;
    }
    getBounds(t) {
      return t || (t = new yr()), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
    }
    clone() {
      return new $N(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }
    copyTo(t) {
      return t.copyFrom(this), t;
    }
    contains(t, e) {
      if (this.width <= 0 || this.height <= 0) return false;
      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
        const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r) return true;
        let i = t - (this.x + r), a = e - (this.y + r);
        const s = r * r;
        if (i * i + a * a <= s || (i = t - (this.x + this.width - r), i * i + a * a <= s) || (a = e - (this.y + this.height - r), i * i + a * a <= s) || (i = t - (this.x + r), i * i + a * a <= s)) return true;
      }
      return false;
    }
    strokeContains(t, e, r, i = 0.5) {
      const { x: a, y: s, width: o, height: l, radius: u } = this, c = r * (1 - i), h = r - c, f = a + u, d = s + u, p = o - u * 2, g = l - u * 2, v = a + o, m = s + l;
      return (t >= a - c && t <= a + h || t >= v - h && t <= v + c) && e >= d && e <= d + g || (e >= s - c && e <= s + h || e >= m - h && e <= m + c) && t >= f && t <= f + p ? true : t < f && e < d && H0(t, e, f, d, u, h, c) || t > v - u && e < d && H0(t, e, v - u, d, u, h, c) || t > v - u && e > m - u && H0(t, e, v - u, m - u, u, h, c) || t < f && e > m - u && H0(t, e, f, m - u, u, h, c);
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }
  const hqt = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join(`
`);
  function fqt(n) {
    let t = "";
    for (let e = 0; e < n; ++e) e > 0 && (t += `
else `), e < n - 1 && (t += `if(test == ${e}.0){}`);
    return t;
  }
  function dqt(n, t) {
    if (n === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const e = t.createShader(t.FRAGMENT_SHADER);
    try {
      for (; ; ) {
        const r = hqt.replace(/%forloop%/gi, fqt(n));
        if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS)) n = n / 2 | 0;
        else break;
      }
    } finally {
      t.deleteShader(e);
    }
    return n;
  }
  let af = null;
  bQ = function() {
    var _a2;
    if (af) return af;
    const n = aQ();
    return af = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), af = dqt(af, n), (_a2 = n.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), af;
  };
  const _Q = {};
  pqt = function(n, t) {
    let e = 2166136261;
    for (let r = 0; r < t; r++) e ^= n[r].uid, e = Math.imul(e, 16777619), e >>>= 0;
    return _Q[e] || gqt(n, t, e);
  };
  let ZT = 0;
  function gqt(n, t, e) {
    const r = {};
    let i = 0;
    ZT || (ZT = bQ());
    for (let s = 0; s < ZT; s++) {
      const o = s < t ? n[s] : on.EMPTY.source;
      r[i++] = o.source, r[i++] = o.style;
    }
    const a = new Nx(r);
    return _Q[e] = a, a;
  }
  qG = class {
    constructor(t) {
      typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
    }
    get int8View() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    }
    get uint8View() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    }
    get int16View() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    }
    get int32View() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    }
    get float64View() {
      return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
    }
    get bigUint64View() {
      return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
    }
    view(t) {
      return this[`${t}View`];
    }
    destroy() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }
    static sizeOf(t) {
      switch (t) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${t} isn't a valid view type`);
      }
    }
  };
  jG = function(n, t) {
    const e = n.byteLength / 8 | 0, r = new Float64Array(n, 0, e);
    new Float64Array(t, 0, e).set(r);
    const a = n.byteLength - e * 8;
    if (a > 0) {
      const s = new Uint8Array(n, e * 8, a);
      new Uint8Array(t, e * 8, a).set(s);
    }
  };
  const vqt = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  mqt = ((n) => (n[n.DISABLED = 0] = "DISABLED", n[n.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", n[n.MASK_ACTIVE = 2] = "MASK_ACTIVE", n[n.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", n[n.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", n[n.NONE = 5] = "NONE", n))(mqt || {});
  KG = function(n, t) {
    return t.alphaMode === "no-premultiply-alpha" && vqt[n] || n;
  };
  class yqt {
    constructor() {
      this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
    }
    clear() {
      for (let t = 0; t < this.count; t++) {
        const e = this.textures[t];
        this.textures[t] = null, this.ids[e.uid] = null;
      }
      this.count = 0;
    }
  }
  class xqt {
    constructor() {
      this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new yqt(), this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = true;
    }
    destroy() {
      this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
    }
  }
  const wQ = [];
  let ok = 0;
  function ZG() {
    return ok > 0 ? wQ[--ok] : new xqt();
  }
  function JG(n) {
    wQ[ok++] = n;
  }
  let Np = 0;
  const SQ = class Lx {
    constructor(t = {}) {
      this.uid = Yn("batcher"), this.dirty = true, this.batchIndex = 0, this.batches = [], this._elements = [], Lx.defaultOptions.maxTextures = Lx.defaultOptions.maxTextures ?? bQ(), t = {
        ...Lx.defaultOptions,
        ...t
      };
      const { maxTextures: e, attributesInitialSize: r, indicesInitialSize: i } = t;
      this.attributeBuffer = new qG(r * 4), this.indexBuffer = new Uint16Array(i), this.maxTextures = e;
    }
    begin() {
      this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
      for (let t = 0; t < this.batchIndex; t++) JG(this.batches[t]);
      this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = true;
    }
    add(t) {
      this._elements[this.elementSize++] = t, t._indexStart = this.indexSize, t._attributeStart = this.attributeSize, t._batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize;
    }
    checkAndUpdateTexture(t, e) {
      const r = t._batch.textures.ids[e._source.uid];
      return !r && r !== 0 ? false : (t._textureId = r, t.texture = e, true);
    }
    updateElement(t) {
      this.dirty = true;
      const e = this.attributeBuffer;
      t.packAsQuad ? this.packQuadAttributes(t, e.float32View, e.uint32View, t._attributeStart, t._textureId) : this.packAttributes(t, e.float32View, e.uint32View, t._attributeStart, t._textureId);
    }
    break(t) {
      const e = this._elements;
      if (!e[this.elementStart]) return;
      let r = ZG(), i = r.textures;
      i.clear();
      const a = e[this.elementStart];
      let s = KG(a.blendMode, a.texture._source), o = a.topology;
      this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
      const l = this.attributeBuffer.float32View, u = this.attributeBuffer.uint32View, c = this.indexBuffer;
      let h = this._batchIndexSize, f = this._batchIndexStart, d = "startBatch";
      const p = this.maxTextures;
      for (let g = this.elementStart; g < this.elementSize; ++g) {
        const v = e[g];
        e[g] = null;
        const y = v.texture._source, x = KG(v.blendMode, y), b = s !== x || o !== v.topology;
        if (y._batchTick === Np && !b) {
          v._textureId = y._textureBindLocation, h += v.indexSize, v.packAsQuad ? (this.packQuadAttributes(v, l, u, v._attributeStart, v._textureId), this.packQuadIndex(c, v._indexStart, v._attributeStart / this.vertexSize)) : (this.packAttributes(v, l, u, v._attributeStart, v._textureId), this.packIndex(v, c, v._indexStart, v._attributeStart / this.vertexSize)), v._batch = r;
          continue;
        }
        y._batchTick = Np, (i.count >= p || b) && (this._finishBatch(r, f, h - f, i, s, o, t, d), d = "renderBatch", f = h, s = x, o = v.topology, r = ZG(), i = r.textures, i.clear(), ++Np), v._textureId = y._textureBindLocation = i.count, i.ids[y.uid] = i.count, i.textures[i.count++] = y, v._batch = r, h += v.indexSize, v.packAsQuad ? (this.packQuadAttributes(v, l, u, v._attributeStart, v._textureId), this.packQuadIndex(c, v._indexStart, v._attributeStart / this.vertexSize)) : (this.packAttributes(v, l, u, v._attributeStart, v._textureId), this.packIndex(v, c, v._indexStart, v._attributeStart / this.vertexSize));
      }
      i.count > 0 && (this._finishBatch(r, f, h - f, i, s, o, t, d), f = h, ++Np), this.elementStart = this.elementSize, this._batchIndexStart = f, this._batchIndexSize = h;
    }
    _finishBatch(t, e, r, i, a, s, o, l) {
      t.gpuBindGroup = null, t.bindGroup = null, t.action = l, t.batcher = this, t.textures = i, t.blendMode = a, t.topology = s, t.start = e, t.size = r, ++Np, this.batches[this.batchIndex++] = t, o.add(t);
    }
    finish(t) {
      this.break(t);
    }
    ensureAttributeBuffer(t) {
      t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
    }
    ensureIndexBuffer(t) {
      t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
    }
    _resizeAttributeBuffer(t) {
      const e = Math.max(t, this.attributeBuffer.size * 2), r = new qG(e);
      jG(this.attributeBuffer.rawBinaryData, r.rawBinaryData), this.attributeBuffer = r;
    }
    _resizeIndexBuffer(t) {
      const e = this.indexBuffer;
      let r = Math.max(t, e.length * 1.5);
      r += r % 2;
      const i = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
      if (i.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT) for (let a = 0; a < e.length; a++) i[a] = e[a];
      else jG(e.buffer, i.buffer);
      this.indexBuffer = i;
    }
    packQuadIndex(t, e, r) {
      t[e] = r + 0, t[e + 1] = r + 1, t[e + 2] = r + 2, t[e + 3] = r + 0, t[e + 4] = r + 2, t[e + 5] = r + 3;
    }
    packIndex(t, e, r, i) {
      const a = t.indices, s = t.indexSize, o = t.indexOffset, l = t.attributeOffset;
      for (let u = 0; u < s; u++) e[r++] = i + a[u + o] - l;
    }
    destroy() {
      for (let t = 0; t < this.batches.length; t++) JG(this.batches[t]);
      this.batches = null;
      for (let t = 0; t < this._elements.length; t++) this._elements[t]._batch = null;
      this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
    }
  };
  SQ.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6
  };
  let bqt = SQ;
  Di = ((n) => (n[n.MAP_READ = 1] = "MAP_READ", n[n.MAP_WRITE = 2] = "MAP_WRITE", n[n.COPY_SRC = 4] = "COPY_SRC", n[n.COPY_DST = 8] = "COPY_DST", n[n.INDEX = 16] = "INDEX", n[n.VERTEX = 32] = "VERTEX", n[n.UNIFORM = 64] = "UNIFORM", n[n.STORAGE = 128] = "STORAGE", n[n.INDIRECT = 256] = "INDIRECT", n[n.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", n[n.STATIC = 1024] = "STATIC", n))(Di || {});
  Sv = class extends po {
    constructor(t) {
      let { data: e, size: r } = t;
      const { usage: i, label: a, shrinkToFit: s } = t;
      super(), this.uid = Yn("buffer"), this._resourceType = "buffer", this._resourceId = Yn("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = true, this.destroyed = false, e instanceof Array && (e = new Float32Array(e)), this._data = e, r ?? (r = e == null ? void 0 : e.byteLength);
      const o = !!e;
      this.descriptor = {
        size: r,
        usage: i,
        mappedAtCreation: o,
        label: a
      }, this.shrinkToFit = s ?? true;
    }
    get data() {
      return this._data;
    }
    set data(t) {
      this.setDataWithSize(t, t.length, true);
    }
    get dataInt32() {
      return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
    }
    get static() {
      return !!(this.descriptor.usage & Di.STATIC);
    }
    set static(t) {
      t ? this.descriptor.usage |= Di.STATIC : this.descriptor.usage &= ~Di.STATIC;
    }
    setDataWithSize(t, e, r) {
      if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
        r && this.emit("update", this);
        return;
      }
      const i = this._data;
      if (this._data = t, this._dataInt32 = null, !i || i.length !== t.length) {
        !this.shrinkToFit && i && t.byteLength < i.byteLength ? r && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = Yn("resource"), this.emit("change", this));
        return;
      }
      r && this.emit("update", this);
    }
    update(t) {
      this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
    }
  };
  function CQ(n, t) {
    if (!(n instanceof Sv)) {
      let e = t ? Di.INDEX : Di.VERTEX;
      n instanceof Array && (t ? (n = new Uint32Array(n), e = Di.INDEX | Di.COPY_DST) : (n = new Float32Array(n), e = Di.VERTEX | Di.COPY_DST)), n = new Sv({
        data: n,
        label: t ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage: e
      });
    }
    return n;
  }
  function _qt(n, t, e) {
    const r = n.getAttribute(t);
    if (!r) return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
    const i = r.buffer.data;
    let a = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0;
    const u = i.BYTES_PER_ELEMENT, c = (r.offset || 0) / u, h = (r.stride || 2 * 4) / u;
    for (let f = c; f < i.length; f += h) {
      const d = i[f], p = i[f + 1];
      d > o && (o = d), p > l && (l = p), d < a && (a = d), p < s && (s = p);
    }
    return e.minX = a, e.minY = s, e.maxX = o, e.maxY = l, e;
  }
  function wqt(n) {
    return (n instanceof Sv || Array.isArray(n) || n.BYTES_PER_ELEMENT) && (n = {
      buffer: n
    }), n.buffer = CQ(n.buffer, false), n;
  }
  Sqt = class extends po {
    constructor(t = {}) {
      super(), this.uid = Yn("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new hs(), this._boundsDirty = true;
      const { attributes: e, indexBuffer: r, topology: i } = t;
      if (this.buffers = [], this.attributes = {}, e) for (const a in e) this.addAttribute(a, e[a]);
      this.instanceCount = t.instanceCount ?? 1, r && this.addIndex(r), this.topology = i || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true, this.emit("update", this);
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(t) {
      return this.getAttribute(t).buffer;
    }
    getSize() {
      for (const t in this.attributes) {
        const e = this.attributes[t];
        return e.buffer.data.length / (e.stride / 4 || e.size);
      }
      return 0;
    }
    addAttribute(t, e) {
      const r = wqt(e);
      this.buffers.indexOf(r.buffer) === -1 && (this.buffers.push(r.buffer), r.buffer.on("update", this.onBufferUpdate, this), r.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = r;
    }
    addIndex(t) {
      this.indexBuffer = CQ(t, true), this.buffers.push(this.indexBuffer);
    }
    get bounds() {
      return this._boundsDirty ? (this._boundsDirty = false, _qt(this, "aPosition", this._bounds)) : this._bounds;
    }
    destroy(t = false) {
      this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e) => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
    }
  };
  const Cqt = new Float32Array(1), Tqt = new Uint32Array(1);
  class Iqt extends Sqt {
    constructor() {
      const e = new Sv({
        data: Cqt,
        label: "attribute-batch-buffer",
        usage: Di.VERTEX | Di.COPY_DST,
        shrinkToFit: false
      }), r = new Sv({
        data: Tqt,
        label: "index-batch-buffer",
        usage: Di.INDEX | Di.COPY_DST,
        shrinkToFit: false
      }), i = 6 * 4;
      super({
        attributes: {
          aPosition: {
            buffer: e,
            format: "float32x2",
            stride: i,
            offset: 0
          },
          aUV: {
            buffer: e,
            format: "float32x2",
            stride: i,
            offset: 2 * 4
          },
          aColor: {
            buffer: e,
            format: "unorm8x4",
            stride: i,
            offset: 4 * 4
          },
          aTextureIdAndRound: {
            buffer: e,
            format: "uint16x2",
            stride: i,
            offset: 5 * 4
          }
        },
        indexBuffer: r
      });
    }
  }
  function QG(n, t, e) {
    if (n) for (const r in n) {
      const i = r.toLocaleLowerCase(), a = t[i];
      if (a) {
        let s = n[r];
        r === "header" && (s = s.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && a.push(`//----${e}----//`), a.push(s);
      } else Ki(`${r} placement hook does not exist in shader`);
    }
  }
  const Aqt = /\{\{(.*?)\}\}/g;
  function t4(n) {
    var _a2;
    const t = {};
    return (((_a2 = n.match(Aqt)) == null ? void 0 : _a2.map((r) => r.replace(/[{()}]/g, ""))) ?? []).forEach((r) => {
      t[r] = [];
    }), t;
  }
  function e4(n, t) {
    let e;
    const r = /@in\s+([^;]+);/g;
    for (; (e = r.exec(n)) !== null; ) t.push(e[1]);
  }
  function n4(n, t, e = false) {
    const r = [];
    e4(t, r), n.forEach((o) => {
      o.header && e4(o.header, r);
    });
    const i = r;
    e && i.sort();
    const a = i.map((o, l) => `       @location(${l}) ${o},`).join(`
`);
    let s = t.replace(/@in\s+[^;]+;\s*/g, "");
    return s = s.replace("{{in}}", `
${a}
`), s;
  }
  function r4(n, t) {
    let e;
    const r = /@out\s+([^;]+);/g;
    for (; (e = r.exec(n)) !== null; ) t.push(e[1]);
  }
  function kqt(n) {
    const e = /\b(\w+)\s*:/g.exec(n);
    return e ? e[1] : "";
  }
  function Dqt(n) {
    const t = /@.*?\s+/g;
    return n.replace(t, "");
  }
  function Eqt(n, t) {
    const e = [];
    r4(t, e), n.forEach((l) => {
      l.header && r4(l.header, e);
    });
    let r = 0;
    const i = e.sort().map((l) => l.indexOf("builtin") > -1 ? l : `@location(${r++}) ${l}`).join(`,
`), a = e.sort().map((l) => `       var ${Dqt(l)};`).join(`
`), s = `return VSOutput(
            ${e.sort().map((l) => ` ${kqt(l)}`).join(`,
`)});`;
    let o = t.replace(/@out\s+[^;]+;\s*/g, "");
    return o = o.replace("{{struct}}", `
${i}
`), o = o.replace("{{start}}", `
${a}
`), o = o.replace("{{return}}", `
${s}
`), o;
  }
  function i4(n, t) {
    let e = n;
    for (const r in t) {
      const i = t[r];
      i.join(`
`).length ? e = e.replace(`{{${r}}}`, `//-----${r} START-----//
${i.join(`
`)}
//----${r} FINISH----//`) : e = e.replace(`{{${r}}}`, "");
    }
    return e;
  }
  const Pl = /* @__PURE__ */ Object.create(null), JT = /* @__PURE__ */ new Map();
  let Mqt = 0;
  function Rqt({ template: n, bits: t }) {
    const e = TQ(n, t);
    if (Pl[e]) return Pl[e];
    const { vertex: r, fragment: i } = Lqt(n, t);
    return Pl[e] = IQ(r, i, t), Pl[e];
  }
  function Nqt({ template: n, bits: t }) {
    const e = TQ(n, t);
    return Pl[e] || (Pl[e] = IQ(n.vertex, n.fragment, t)), Pl[e];
  }
  function Lqt(n, t) {
    const e = t.map((s) => s.vertex).filter((s) => !!s), r = t.map((s) => s.fragment).filter((s) => !!s);
    let i = n4(e, n.vertex, true);
    i = Eqt(e, i);
    const a = n4(r, n.fragment, true);
    return {
      vertex: i,
      fragment: a
    };
  }
  function TQ(n, t) {
    return t.map((e) => (JT.has(e) || JT.set(e, Mqt++), JT.get(e))).sort((e, r) => e - r).join("-") + n.vertex + n.fragment;
  }
  function IQ(n, t, e) {
    const r = t4(n), i = t4(t);
    return e.forEach((a) => {
      QG(a.vertex, r, a.name), QG(a.fragment, i, a.name);
    }), {
      vertex: i4(n, r),
      fragment: i4(t, i)
    };
  }
  const Pqt = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, $qt = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, Oqt = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, Fqt = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`, Bqt = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    }
  }, zqt = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    }
  };
  Vqt = function({ bits: n, name: t }) {
    const e = Rqt({
      template: {
        fragment: $qt,
        vertex: Pqt
      },
      bits: [
        Bqt,
        ...n
      ]
    });
    return Lw.from({
      name: t,
      vertex: {
        source: e.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: e.fragment,
        entryPoint: "main"
      }
    });
  };
  Gqt = function({ bits: n, name: t }) {
    return new oQ({
      name: t,
      ...Nqt({
        template: {
          vertex: Oqt,
          fragment: Fqt
        },
        bits: [
          zqt,
          ...n
        ]
      })
    });
  };
  let QT;
  Wqt = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  Uqt = {
    name: "color-bit",
    vertex: {
      header: `
            in vec4 aColor;
        `,
      main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  QT = {};
  function Hqt(n) {
    const t = [];
    if (n === 1) t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
      let e = 0;
      for (let r = 0; r < n; r++) t.push(`@group(1) @binding(${e++}) var textureSource${r + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${r + 1}: sampler;`);
    }
    return t.join(`
`);
  }
  function Xqt(n) {
    const t = [];
    if (n === 1) t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
      t.push("switch vTextureId {");
      for (let e = 0; e < n; e++) e === n - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
      t.push("}");
    }
    return t.join(`
`);
  }
  Yqt = function(n) {
    return QT[n] || (QT[n] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${Hqt(n)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${Xqt(n)}
            `
      }
    }), QT[n];
  };
  const tI = {};
  function qqt(n) {
    const t = [];
    for (let e = 0; e < n; e++) e > 0 && t.push("else"), e < n - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
    return t.join(`
`);
  }
  jqt = function(n) {
    return tI[n] || (tI[n] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${n}];

            `,
        main: `

                ${qqt(n)}
            `
      }
    }), tI[n];
  };
  let a4;
  Kqt = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  Zqt = {
    name: "round-pixels-bit",
    vertex: {
      header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  a4 = {};
  Jqt = function(n) {
    let t = a4[n];
    if (t) return t;
    const e = new Int32Array(n);
    for (let r = 0; r < n; r++) e[r] = r;
    return t = a4[n] = new hQ({
      uTextures: {
        value: e,
        type: "i32",
        size: n
      }
    }, {
      isStatic: true
    }), t;
  };
  class Qqt extends MN {
    constructor(t) {
      const e = Gqt({
        name: "batch",
        bits: [
          Uqt,
          jqt(t),
          Zqt
        ]
      }), r = Vqt({
        name: "batch",
        bits: [
          Wqt,
          Yqt(t),
          Kqt
        ]
      });
      super({
        glProgram: e,
        gpuProgram: r,
        resources: {
          batchSamplers: Jqt(t)
        }
      });
    }
  }
  let s4 = null;
  const AQ = class kQ extends bqt {
    constructor() {
      super(...arguments), this.geometry = new Iqt(), this.shader = s4 || (s4 = new Qqt(this.maxTextures)), this.name = kQ.extension.name, this.vertexSize = 6;
    }
    packAttributes(t, e, r, i, a) {
      const s = a << 16 | t.roundPixels & 65535, o = t.transform, l = o.a, u = o.b, c = o.c, h = o.d, f = o.tx, d = o.ty, { positions: p, uvs: g } = t, v = t.color, m = t.attributeOffset, y = m + t.attributeSize;
      for (let x = m; x < y; x++) {
        const b = x * 2, _ = p[b], w = p[b + 1];
        e[i++] = l * _ + c * w + f, e[i++] = h * w + u * _ + d, e[i++] = g[b], e[i++] = g[b + 1], r[i++] = v, r[i++] = s;
      }
    }
    packQuadAttributes(t, e, r, i, a) {
      const s = t.texture, o = t.transform, l = o.a, u = o.b, c = o.c, h = o.d, f = o.tx, d = o.ty, p = t.bounds, g = p.maxX, v = p.minX, m = p.maxY, y = p.minY, x = s.uvs, b = t.color, _ = a << 16 | t.roundPixels & 65535;
      e[i + 0] = l * v + c * y + f, e[i + 1] = h * y + u * v + d, e[i + 2] = x.x0, e[i + 3] = x.y0, r[i + 4] = b, r[i + 5] = _, e[i + 6] = l * g + c * y + f, e[i + 7] = h * y + u * g + d, e[i + 8] = x.x1, e[i + 9] = x.y1, r[i + 10] = b, r[i + 11] = _, e[i + 12] = l * g + c * m + f, e[i + 13] = h * m + u * g + d, e[i + 14] = x.x2, e[i + 15] = x.y2, r[i + 16] = b, r[i + 17] = _, e[i + 18] = l * v + c * m + f, e[i + 19] = h * m + u * v + d, e[i + 20] = x.x3, e[i + 21] = x.y3, r[i + 22] = b, r[i + 23] = _;
    }
  };
  AQ.extension = {
    type: [
      rn.Batcher
    ],
    name: "default"
  };
  tjt = AQ;
  function ejt(n, t, e, r, i, a, s, o = null) {
    let l = 0;
    e *= t, i *= a;
    const u = o.a, c = o.b, h = o.c, f = o.d, d = o.tx, p = o.ty;
    for (; l < s; ) {
      const g = n[e], v = n[e + 1];
      r[i] = u * g + h * v + d, r[i + 1] = c * g + f * v + p, i += a, e += t, l++;
    }
  }
  function njt(n, t, e, r) {
    let i = 0;
    for (t *= e; i < r; ) n[t] = 0, n[t + 1] = 0, t += e, i++;
  }
  function DQ(n, t, e, r, i) {
    const a = t.a, s = t.b, o = t.c, l = t.d, u = t.tx, c = t.ty;
    e || (e = 0), r || (r = 2), i || (i = n.length / r - e);
    let h = e * r;
    for (let f = 0; f < i; f++) {
      const d = n[h], p = n[h + 1];
      n[h] = a * d + o * p + u, n[h + 1] = s * d + l * p + c, h += r;
    }
  }
  const rjt = new Ve();
  EQ = class {
    constructor() {
      this.packAsQuad = false, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = true, this.roundPixels = 0, this._batcher = null, this._batch = null;
    }
    get uvs() {
      return this.geometryData.uvs;
    }
    get positions() {
      return this.geometryData.vertices;
    }
    get indices() {
      return this.geometryData.indices;
    }
    get blendMode() {
      return this.applyTransform ? this.renderable.groupBlendMode : "normal";
    }
    get color() {
      const t = this.baseColor, e = t >> 16 | t & 65280 | (t & 255) << 16, r = this.renderable;
      return r ? BJ(e, r.groupColor) + (this.alpha * r.groupAlpha * 255 << 24) : e + (this.alpha * 255 << 24);
    }
    get transform() {
      var _a2;
      return ((_a2 = this.renderable) == null ? void 0 : _a2.groupTransform) || rjt;
    }
    copyTo(t) {
      t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData, t.topology = this.topology;
    }
    reset() {
      this.applyTransform = true, this.renderable = null, this.topology = "triangle-list";
    }
  };
  const Cv = {
    extension: {
      type: rn.ShapeBuilder,
      name: "circle"
    },
    build(n, t) {
      let e, r, i, a, s, o;
      if (n.type === "circle") {
        const b = n;
        e = b.x, r = b.y, s = o = b.radius, i = a = 0;
      } else if (n.type === "ellipse") {
        const b = n;
        e = b.x, r = b.y, s = b.halfWidth, o = b.halfHeight, i = a = 0;
      } else {
        const b = n, _ = b.width / 2, w = b.height / 2;
        e = b.x + _, r = b.y + w, s = o = Math.max(0, Math.min(b.radius, Math.min(_, w))), i = _ - s, a = w - o;
      }
      if (!(s >= 0 && o >= 0 && i >= 0 && a >= 0)) return t;
      const l = Math.ceil(2.3 * Math.sqrt(s + o)), u = l * 8 + (i ? 4 : 0) + (a ? 4 : 0);
      if (u === 0) return t;
      if (l === 0) return t[0] = t[6] = e + i, t[1] = t[3] = r + a, t[2] = t[4] = e - i, t[5] = t[7] = r - a, t;
      let c = 0, h = l * 4 + (i ? 2 : 0) + 2, f = h, d = u, p = i + s, g = a, v = e + p, m = e - p, y = r + g;
      if (t[c++] = v, t[c++] = y, t[--h] = y, t[--h] = m, a) {
        const b = r - g;
        t[f++] = m, t[f++] = b, t[--d] = b, t[--d] = v;
      }
      for (let b = 1; b < l; b++) {
        const _ = Math.PI / 2 * (b / l), w = i + Math.cos(_) * s, S = a + Math.sin(_) * o, I = e + w, T = e - w, A = r + S, C = r - S;
        t[c++] = I, t[c++] = A, t[--h] = A, t[--h] = T, t[f++] = T, t[f++] = C, t[--d] = C, t[--d] = I;
      }
      p = i, g = a + o, v = e + p, m = e - p, y = r + g;
      const x = r - g;
      return t[c++] = v, t[c++] = y, t[--d] = x, t[--d] = v, i && (t[c++] = m, t[c++] = y, t[--d] = x, t[--d] = m), t;
    },
    triangulate(n, t, e, r, i, a) {
      if (n.length === 0) return;
      let s = 0, o = 0;
      for (let c = 0; c < n.length; c += 2) s += n[c], o += n[c + 1];
      s /= n.length / 2, o /= n.length / 2;
      let l = r;
      t[l * e] = s, t[l * e + 1] = o;
      const u = l++;
      for (let c = 0; c < n.length; c += 2) t[l * e] = n[c], t[l * e + 1] = n[c + 1], c > 0 && (i[a++] = l, i[a++] = u, i[a++] = l - 1), l++;
      i[a++] = u + 1, i[a++] = u, i[a++] = l - 1;
    }
  }, ijt = {
    ...Cv,
    extension: {
      ...Cv.extension,
      name: "ellipse"
    }
  }, ajt = {
    ...Cv,
    extension: {
      ...Cv.extension,
      name: "roundedRectangle"
    }
  }, MQ = 1e-4, o4 = 1e-4;
  function sjt(n) {
    const t = n.length;
    if (t < 6) return 1;
    let e = 0;
    for (let r = 0, i = n[t - 2], a = n[t - 1]; r < t; r += 2) {
      const s = n[r], o = n[r + 1];
      e += (s - i) * (o + a), i = s, a = o;
    }
    return e < 0 ? -1 : 1;
  }
  function l4(n, t, e, r, i, a, s, o) {
    const l = n - e * i, u = t - r * i, c = n + e * a, h = t + r * a;
    let f, d;
    s ? (f = r, d = -e) : (f = -r, d = e);
    const p = l + f, g = u + d, v = c + f, m = h + d;
    return o.push(p, g), o.push(v, m), 2;
  }
  function qu(n, t, e, r, i, a, s, o) {
    const l = e - n, u = r - t;
    let c = Math.atan2(l, u), h = Math.atan2(i - n, a - t);
    o && c < h ? c += Math.PI * 2 : !o && c > h && (h += Math.PI * 2);
    let f = c;
    const d = h - c, p = Math.abs(d), g = Math.sqrt(l * l + u * u), v = (15 * p * Math.sqrt(g) / Math.PI >> 0) + 1, m = d / v;
    if (f += m, o) {
      s.push(n, t), s.push(e, r);
      for (let y = 1, x = f; y < v; y++, x += m) s.push(n, t), s.push(n + Math.sin(x) * g, t + Math.cos(x) * g);
      s.push(n, t), s.push(i, a);
    } else {
      s.push(e, r), s.push(n, t);
      for (let y = 1, x = f; y < v; y++, x += m) s.push(n + Math.sin(x) * g, t + Math.cos(x) * g), s.push(n, t);
      s.push(i, a), s.push(n, t);
    }
    return v * 2;
  }
  function ojt(n, t, e, r, i, a) {
    const s = MQ;
    if (n.length === 0) return;
    const o = t;
    let l = o.alignment;
    if (t.alignment !== 0.5) {
      let $ = sjt(n);
      l = (l - 0.5) * $ + 0.5;
    }
    const u = new Xr(n[0], n[1]), c = new Xr(n[n.length - 2], n[n.length - 1]), h = r, f = Math.abs(u.x - c.x) < s && Math.abs(u.y - c.y) < s;
    if (h) {
      n = n.slice(), f && (n.pop(), n.pop(), c.set(n[n.length - 2], n[n.length - 1]));
      const $ = (u.x + c.x) * 0.5, O = (c.y + u.y) * 0.5;
      n.unshift($, O), n.push($, O);
    }
    const d = i, p = n.length / 2;
    let g = n.length;
    const v = d.length / 2, m = o.width / 2, y = m * m, x = o.miterLimit * o.miterLimit;
    let b = n[0], _ = n[1], w = n[2], S = n[3], I = 0, T = 0, A = -(_ - S), C = b - w, D = 0, E = 0, M = Math.sqrt(A * A + C * C);
    A /= M, C /= M, A *= m, C *= m;
    const L = l, k = (1 - L) * 2, N = L * 2;
    h || (o.cap === "round" ? g += qu(b - A * (k - N) * 0.5, _ - C * (k - N) * 0.5, b - A * k, _ - C * k, b + A * N, _ + C * N, d, true) + 2 : o.cap === "square" && (g += l4(b, _, A, C, k, N, true, d))), d.push(b - A * k, _ - C * k), d.push(b + A * N, _ + C * N);
    for (let $ = 1; $ < p - 1; ++$) {
      b = n[($ - 1) * 2], _ = n[($ - 1) * 2 + 1], w = n[$ * 2], S = n[$ * 2 + 1], I = n[($ + 1) * 2], T = n[($ + 1) * 2 + 1], A = -(_ - S), C = b - w, M = Math.sqrt(A * A + C * C), A /= M, C /= M, A *= m, C *= m, D = -(S - T), E = w - I, M = Math.sqrt(D * D + E * E), D /= M, E /= M, D *= m, E *= m;
      const O = w - b, F = _ - S, z = w - I, V = T - S, U = O * z + F * V, X = F * z - V * O, at = X < 0;
      if (Math.abs(X) < 1e-3 * Math.abs(U)) {
        d.push(w - A * k, S - C * k), d.push(w + A * N, S + C * N), U >= 0 && (o.join === "round" ? g += qu(w, S, w - A * k, S - C * k, w - D * k, S - E * k, d, false) + 4 : g += 2, d.push(w - D * N, S - E * N), d.push(w + D * k, S + E * k));
        continue;
      }
      const pt = (-A + b) * (-C + S) - (-A + w) * (-C + _), it = (-D + I) * (-E + S) - (-D + w) * (-E + T), et = (O * it - z * pt) / X, ft = (V * pt - F * it) / X, ut = (et - w) * (et - w) + (ft - S) * (ft - S), gt = w + (et - w) * k, kt = S + (ft - S) * k, At = w - (et - w) * N, mt = S - (ft - S) * N, _t = Math.min(O * O + F * F, z * z + V * V), ee = at ? k : N, G = _t + ee * ee * y;
      ut <= G ? o.join === "bevel" || ut / y > x ? (at ? (d.push(gt, kt), d.push(w + A * N, S + C * N), d.push(gt, kt), d.push(w + D * N, S + E * N)) : (d.push(w - A * k, S - C * k), d.push(At, mt), d.push(w - D * k, S - E * k), d.push(At, mt)), g += 2) : o.join === "round" ? at ? (d.push(gt, kt), d.push(w + A * N, S + C * N), g += qu(w, S, w + A * N, S + C * N, w + D * N, S + E * N, d, true) + 4, d.push(gt, kt), d.push(w + D * N, S + E * N)) : (d.push(w - A * k, S - C * k), d.push(At, mt), g += qu(w, S, w - A * k, S - C * k, w - D * k, S - E * k, d, false) + 4, d.push(w - D * k, S - E * k), d.push(At, mt)) : (d.push(gt, kt), d.push(At, mt)) : (d.push(w - A * k, S - C * k), d.push(w + A * N, S + C * N), o.join === "round" ? at ? g += qu(w, S, w + A * N, S + C * N, w + D * N, S + E * N, d, true) + 2 : g += qu(w, S, w - A * k, S - C * k, w - D * k, S - E * k, d, false) + 2 : o.join === "miter" && ut / y <= x && (at ? (d.push(At, mt), d.push(At, mt)) : (d.push(gt, kt), d.push(gt, kt)), g += 2), d.push(w - D * k, S - E * k), d.push(w + D * N, S + E * N), g += 2);
    }
    b = n[(p - 2) * 2], _ = n[(p - 2) * 2 + 1], w = n[(p - 1) * 2], S = n[(p - 1) * 2 + 1], A = -(_ - S), C = b - w, M = Math.sqrt(A * A + C * C), A /= M, C /= M, A *= m, C *= m, d.push(w - A * k, S - C * k), d.push(w + A * N, S + C * N), h || (o.cap === "round" ? g += qu(w - A * (k - N) * 0.5, S - C * (k - N) * 0.5, w - A * k, S - C * k, w + A * N, S + C * N, d, false) + 2 : o.cap === "square" && (g += l4(w, S, A, C, k, N, false, d)));
    const R = o4 * o4;
    for (let $ = v; $ < g + v - 2; ++$) b = d[$ * 2], _ = d[$ * 2 + 1], w = d[($ + 1) * 2], S = d[($ + 1) * 2 + 1], I = d[($ + 2) * 2], T = d[($ + 2) * 2 + 1], !(Math.abs(b * (S - T) + w * (T - _) + I * (_ - S)) < R) && a.push($, $ + 1, $ + 2);
  }
  function ljt(n, t, e, r) {
    const i = MQ;
    if (n.length === 0) return;
    const a = n[0], s = n[1], o = n[n.length - 2], l = n[n.length - 1], u = t || Math.abs(a - o) < i && Math.abs(s - l) < i, c = e, h = n.length / 2, f = c.length / 2;
    for (let d = 0; d < h; d++) c.push(n[d * 2]), c.push(n[d * 2 + 1]);
    for (let d = 0; d < h - 1; d++) r.push(f + d, f + d + 1);
    u && r.push(f + h - 1, f);
  }
  function RQ(n, t, e, r, i, a, s) {
    const o = KYt(n, t, 2);
    if (!o) return;
    for (let u = 0; u < o.length; u += 3) a[s++] = o[u] + i, a[s++] = o[u + 1] + i, a[s++] = o[u + 2] + i;
    let l = i * r;
    for (let u = 0; u < n.length; u += 2) e[l] = n[u], e[l + 1] = n[u + 1], l += r;
  }
  const ujt = [], cjt = {
    extension: {
      type: rn.ShapeBuilder,
      name: "polygon"
    },
    build(n, t) {
      for (let e = 0; e < n.points.length; e++) t[e] = n.points[e];
      return t;
    },
    triangulate(n, t, e, r, i, a) {
      RQ(n, ujt, t, e, r, i, a);
    }
  }, hjt = {
    extension: {
      type: rn.ShapeBuilder,
      name: "rectangle"
    },
    build(n, t) {
      const e = n, r = e.x, i = e.y, a = e.width, s = e.height;
      return a >= 0 && s >= 0 && (t[0] = r, t[1] = i, t[2] = r + a, t[3] = i, t[4] = r + a, t[5] = i + s, t[6] = r, t[7] = i + s), t;
    },
    triangulate(n, t, e, r, i, a) {
      let s = 0;
      r *= e, t[r + s] = n[0], t[r + s + 1] = n[1], s += e, t[r + s] = n[2], t[r + s + 1] = n[3], s += e, t[r + s] = n[6], t[r + s + 1] = n[7], s += e, t[r + s] = n[4], t[r + s + 1] = n[5], s += e;
      const o = r / e;
      i[a++] = o, i[a++] = o + 1, i[a++] = o + 2, i[a++] = o + 1, i[a++] = o + 3, i[a++] = o + 2;
    }
  }, fjt = {
    extension: {
      type: rn.ShapeBuilder,
      name: "triangle"
    },
    build(n, t) {
      return t[0] = n.x, t[1] = n.y, t[2] = n.x2, t[3] = n.y2, t[4] = n.x3, t[5] = n.y3, t;
    },
    triangulate(n, t, e, r, i, a) {
      let s = 0;
      r *= e, t[r + s] = n[0], t[r + s + 1] = n[1], s += e, t[r + s] = n[2], t[r + s + 1] = n[3], s += e, t[r + s] = n[4], t[r + s + 1] = n[5];
      const o = r / e;
      i[a++] = o, i[a++] = o + 1, i[a++] = o + 2;
    }
  }, djt = new Ve(), pjt = new yr();
  function gjt(n, t, e, r) {
    const i = t.matrix ? n.copyFrom(t.matrix).invert() : n.identity();
    if (t.textureSpace === "local") {
      const a = e.getBounds(pjt);
      i.translate(-a.x, -a.y), i.scale(1 / a.width, 1 / a.height);
    } else {
      i.translate(t.texture.frame.x, t.texture.frame.y), i.scale(1 / t.texture.source.width, 1 / t.texture.source.height);
      const a = t.texture.source.style;
      a.addressMode === "clamp-to-edge" && (a.addressMode = "repeat", a.update());
    }
    return r && i.append(djt.copyFrom(r).invert()), i;
  }
  const Pw = {};
  Pa.handleByMap(rn.ShapeBuilder, Pw);
  Pa.add(hjt, cjt, fjt, Cv, ijt, ajt);
  const vjt = new yr(), mjt = new Ve();
  function yjt(n, t) {
    const { geometryData: e, batches: r } = t;
    r.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
    for (let i = 0; i < n.instructions.length; i++) {
      const a = n.instructions[i];
      if (a.action === "texture") xjt(a.data, r, e);
      else if (a.action === "fill" || a.action === "stroke") {
        const s = a.action === "stroke", o = a.data.path.shapePath, l = a.data.style, u = a.data.hole;
        s && u && u4(u.shapePath, l, true, r, e), u && (o.shapePrimitives[o.shapePrimitives.length - 1].holes = u.shapePath.shapePrimitives), u4(o, l, s, r, e);
      }
    }
  }
  function xjt(n, t, e) {
    const { vertices: r, uvs: i, indices: a } = e, s = a.length, o = r.length / 2, l = [], u = Pw.rectangle, c = vjt, h = n.image;
    c.x = n.dx, c.y = n.dy, c.width = n.dw, c.height = n.dh;
    const f = n.transform;
    u.build(c, l), f && DQ(l, f), u.triangulate(l, r, 2, o, a, s);
    const d = h.uvs;
    i.push(d.x0, d.y0, d.x1, d.y1, d.x3, d.y3, d.x2, d.y2);
    const p = Oo.get(EQ);
    p.indexOffset = s, p.indexSize = a.length - s, p.attributeOffset = o, p.attributeSize = r.length / 2 - o, p.baseColor = n.style, p.alpha = n.alpha, p.texture = h, p.geometryData = e, t.push(p);
  }
  function u4(n, t, e, r, i) {
    const { vertices: a, uvs: s, indices: o } = i;
    n.shapePrimitives.forEach(({ shape: l, transform: u, holes: c }) => {
      const h = o.length, f = a.length / 2, d = [], p = Pw[l.type];
      let g = "triangle-list";
      if (p.build(l, d), u && DQ(d, u), e) {
        const x = l.closePath ?? true, b = t;
        b.pixelLine ? (ljt(d, x, a, o), g = "line-list") : ojt(d, b, false, x, a, o);
      } else if (c) {
        const x = [], b = d.slice();
        bjt(c).forEach((w) => {
          x.push(b.length / 2), b.push(...w);
        }), RQ(b, x, a, 2, f, o, h);
      } else p.triangulate(d, a, 2, f, o, h);
      const v = s.length / 2, m = t.texture;
      if (m !== on.WHITE) {
        const x = gjt(mjt, t, l, u);
        ejt(a, 2, f, s, v, 2, a.length / 2 - f, x);
      } else njt(s, v, 2, a.length / 2 - f);
      const y = Oo.get(EQ);
      y.indexOffset = h, y.indexSize = o.length - h, y.attributeOffset = f, y.attributeSize = a.length / 2 - f, y.baseColor = t.color, y.alpha = t.alpha, y.texture = m, y.geometryData = i, y.topology = g, r.push(y);
    });
  }
  function bjt(n) {
    const t = [];
    for (let e = 0; e < n.length; e++) {
      const r = n[e].shape, i = [];
      Pw[r.type].build(r, i), t.push(i);
    }
    return t;
  }
  class _jt {
    constructor() {
      this.batches = [], this.geometryData = {
        vertices: [],
        uvs: [],
        indices: []
      };
    }
  }
  class wjt {
    constructor() {
      this.batcher = new tjt(), this.instructions = new WJ();
    }
    init() {
      this.instructions.reset();
    }
    get geometry() {
      return fn(RXt, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
    }
  }
  const ON = class lk {
    constructor(t) {
      this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
    }
    init(t) {
      lk.defaultOptions.bezierSmoothness = (t == null ? void 0 : t.bezierSmoothness) ?? lk.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(t) {
      return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
    }
    updateGpuContext(t) {
      let e = this._gpuContextHash[t.uid] || this._initContext(t);
      if (t.dirty) {
        e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), yjt(t, e);
        const r = t.batchMode;
        t.customShader || r === "no-batch" ? e.isBatchable = false : r === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = false;
      }
      return e;
    }
    getGpuContext(t) {
      return this._gpuContextHash[t.uid] || this._initContext(t);
    }
    _initContextRenderData(t) {
      const e = Oo.get(wjt), { batches: r, geometryData: i } = this._gpuContextHash[t.uid], a = i.vertices.length, s = i.indices.length;
      for (let c = 0; c < r.length; c++) r[c].applyTransform = false;
      const o = e.batcher;
      o.ensureAttributeBuffer(a), o.ensureIndexBuffer(s), o.begin();
      for (let c = 0; c < r.length; c++) {
        const h = r[c];
        o.add(h);
      }
      o.finish(e.instructions);
      const l = o.geometry;
      l.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, true), l.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, true);
      const u = o.batches;
      for (let c = 0; c < u.length; c++) {
        const h = u[c];
        h.bindGroup = pqt(h.textures.textures, h.textures.count);
      }
      return this._graphicsDataContextHash[t.uid] = e, e;
    }
    _initContext(t) {
      const e = new _jt();
      return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
    }
    onGraphicsContextDestroy(t) {
      this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
    }
    _cleanGraphicsContextData(t) {
      const e = this._gpuContextHash[t.uid];
      e.isBatchable || this._graphicsDataContextHash[t.uid] && (Oo.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((r) => {
        Oo.return(r);
      });
    }
    destroy() {
      for (const t in this._gpuContextHash) this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
    }
  };
  ON.extension = {
    type: [
      rn.WebGLSystem,
      rn.WebGPUSystem,
      rn.CanvasSystem
    ],
    name: "graphicsContext"
  };
  ON.defaultOptions = {
    bezierSmoothness: 0.5
  };
  NQ = ON;
  const Sjt = 8, X0 = 11920929e-14, Cjt = 1;
  function LQ(n, t, e, r, i, a, s, o, l, u) {
    const h = Math.min(0.99, Math.max(0, u ?? NQ.defaultOptions.bezierSmoothness));
    let f = (Cjt - h) / 1;
    return f *= f, Tjt(t, e, r, i, a, s, o, l, n, f), n;
  }
  function Tjt(n, t, e, r, i, a, s, o, l, u) {
    uk(n, t, e, r, i, a, s, o, l, u, 0), l.push(s, o);
  }
  function uk(n, t, e, r, i, a, s, o, l, u, c) {
    if (c > Sjt) return;
    const h = (n + e) / 2, f = (t + r) / 2, d = (e + i) / 2, p = (r + a) / 2, g = (i + s) / 2, v = (a + o) / 2, m = (h + d) / 2, y = (f + p) / 2, x = (d + g) / 2, b = (p + v) / 2, _ = (m + x) / 2, w = (y + b) / 2;
    if (c > 0) {
      let S = s - n, I = o - t;
      const T = Math.abs((e - s) * I - (r - o) * S), A = Math.abs((i - s) * I - (a - o) * S);
      if (T > X0 && A > X0) {
        if ((T + A) * (T + A) <= u * (S * S + I * I)) {
          l.push(_, w);
          return;
        }
      } else if (T > X0) {
        if (T * T <= u * (S * S + I * I)) {
          l.push(_, w);
          return;
        }
      } else if (A > X0) {
        if (A * A <= u * (S * S + I * I)) {
          l.push(_, w);
          return;
        }
      } else if (S = _ - (n + s) / 2, I = w - (t + o) / 2, S * S + I * I <= u) {
        l.push(_, w);
        return;
      }
    }
    uk(n, t, h, f, m, y, _, w, l, u, c + 1), uk(_, w, x, b, g, v, s, o, l, u, c + 1);
  }
  const Ijt = 8, Ajt = 11920929e-14, kjt = 1;
  function Djt(n, t, e, r, i, a, s, o) {
    const u = Math.min(0.99, Math.max(0, o ?? NQ.defaultOptions.bezierSmoothness));
    let c = (kjt - u) / 1;
    return c *= c, Ejt(t, e, r, i, a, s, n, c), n;
  }
  function Ejt(n, t, e, r, i, a, s, o) {
    ck(s, n, t, e, r, i, a, o, 0), s.push(i, a);
  }
  function ck(n, t, e, r, i, a, s, o, l) {
    if (l > Ijt) return;
    const u = (t + r) / 2, c = (e + i) / 2, h = (r + a) / 2, f = (i + s) / 2, d = (u + h) / 2, p = (c + f) / 2;
    let g = a - t, v = s - e;
    const m = Math.abs((r - a) * v - (i - s) * g);
    if (m > Ajt) {
      if (m * m <= o * (g * g + v * v)) {
        n.push(d, p);
        return;
      }
    } else if (g = d - (t + a) / 2, v = p - (e + s) / 2, g * g + v * v <= o) {
      n.push(d, p);
      return;
    }
    ck(n, t, e, u, c, d, p, o, l + 1), ck(n, d, p, h, f, a, s, o, l + 1);
  }
  function PQ(n, t, e, r, i, a, s, o) {
    let l = Math.abs(i - a);
    (!s && i > a || s && a > i) && (l = 2 * Math.PI - l), o || (o = Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (l / Math.PI)))), o = Math.max(o, 3);
    let u = l / o, c = i;
    u *= s ? -1 : 1;
    for (let h = 0; h < o + 1; h++) {
      const f = Math.cos(c), d = Math.sin(c), p = t + f * r, g = e + d * r;
      n.push(p, g), c += u;
    }
  }
  function Mjt(n, t, e, r, i, a) {
    const s = n[n.length - 2], l = n[n.length - 1] - e, u = s - t, c = i - e, h = r - t, f = Math.abs(l * h - u * c);
    if (f < 1e-8 || a === 0) {
      (n[n.length - 2] !== t || n[n.length - 1] !== e) && n.push(t, e);
      return;
    }
    const d = l * l + u * u, p = c * c + h * h, g = l * c + u * h, v = a * Math.sqrt(d) / f, m = a * Math.sqrt(p) / f, y = v * g / d, x = m * g / p, b = v * h + m * u, _ = v * c + m * l, w = u * (m + y), S = l * (m + y), I = h * (v + x), T = c * (v + x), A = Math.atan2(S - _, w - b), C = Math.atan2(T - _, I - b);
    PQ(n, b + t, _ + e, a, A, C, u * c > h * l);
  }
  const Ig = Math.PI * 2, eI = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  }, nI = ({ x: n, y: t }, e, r, i, a, s, o, l) => {
    n *= e, t *= r;
    const u = i * n - a * t, c = a * n + i * t;
    return l.x = u + s, l.y = c + o, l;
  };
  function Rjt(n, t) {
    const e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), r = t === 1.5707963267948966 ? 0.551915024494 : e, i = Math.cos(n), a = Math.sin(n), s = Math.cos(n + t), o = Math.sin(n + t);
    return [
      {
        x: i - a * r,
        y: a + i * r
      },
      {
        x: s + o * r,
        y: o - s * r
      },
      {
        x: s,
        y: o
      }
    ];
  }
  const c4 = (n, t, e, r) => {
    const i = n * r - t * e < 0 ? -1 : 1;
    let a = n * e + t * r;
    return a > 1 && (a = 1), a < -1 && (a = -1), i * Math.acos(a);
  }, Njt = (n, t, e, r, i, a, s, o, l, u, c, h, f) => {
    const d = Math.pow(i, 2), p = Math.pow(a, 2), g = Math.pow(c, 2), v = Math.pow(h, 2);
    let m = d * p - d * v - p * g;
    m < 0 && (m = 0), m /= d * v + p * g, m = Math.sqrt(m) * (s === o ? -1 : 1);
    const y = m * i / a * h, x = m * -a / i * c, b = u * y - l * x + (n + e) / 2, _ = l * y + u * x + (t + r) / 2, w = (c - y) / i, S = (h - x) / a, I = (-c - y) / i, T = (-h - x) / a, A = c4(1, 0, w, S);
    let C = c4(w, S, I, T);
    o === 0 && C > 0 && (C -= Ig), o === 1 && C < 0 && (C += Ig), f.centerX = b, f.centerY = _, f.ang1 = A, f.ang2 = C;
  };
  function Ljt(n, t, e, r, i, a, s, o = 0, l = 0, u = 0) {
    if (a === 0 || s === 0) return;
    const c = Math.sin(o * Ig / 360), h = Math.cos(o * Ig / 360), f = h * (t - r) / 2 + c * (e - i) / 2, d = -c * (t - r) / 2 + h * (e - i) / 2;
    if (f === 0 && d === 0) return;
    a = Math.abs(a), s = Math.abs(s);
    const p = Math.pow(f, 2) / Math.pow(a, 2) + Math.pow(d, 2) / Math.pow(s, 2);
    p > 1 && (a *= Math.sqrt(p), s *= Math.sqrt(p)), Njt(t, e, r, i, a, s, l, u, c, h, f, d, eI);
    let { ang1: g, ang2: v } = eI;
    const { centerX: m, centerY: y } = eI;
    let x = Math.abs(v) / (Ig / 4);
    Math.abs(1 - x) < 1e-7 && (x = 1);
    const b = Math.max(Math.ceil(x), 1);
    v /= b;
    let _ = n[n.length - 2], w = n[n.length - 1];
    const S = {
      x: 0,
      y: 0
    };
    for (let I = 0; I < b; I++) {
      const T = Rjt(g, v), { x: A, y: C } = nI(T[0], a, s, h, c, m, y, S), { x: D, y: E } = nI(T[1], a, s, h, c, m, y, S), { x: M, y: L } = nI(T[2], a, s, h, c, m, y, S);
      LQ(n, _, w, A, C, D, E, M, L), _ = M, w = L, g += v;
    }
  }
  function Pjt(n, t, e) {
    const r = (s, o) => {
      const l = o.x - s.x, u = o.y - s.y, c = Math.sqrt(l * l + u * u), h = l / c, f = u / c;
      return {
        len: c,
        nx: h,
        ny: f
      };
    }, i = (s, o) => {
      s === 0 ? n.moveTo(o.x, o.y) : n.lineTo(o.x, o.y);
    };
    let a = t[t.length - 1];
    for (let s = 0; s < t.length; s++) {
      const o = t[s % t.length], l = o.radius ?? e;
      if (l <= 0) {
        i(s, o), a = o;
        continue;
      }
      const u = t[(s + 1) % t.length], c = r(o, a), h = r(o, u);
      if (c.len < 1e-4 || h.len < 1e-4) {
        i(s, o), a = o;
        continue;
      }
      let f = Math.asin(c.nx * h.ny - c.ny * h.nx), d = 1, p = false;
      c.nx * h.nx - c.ny * -h.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, d = -1, p = true) : f > 0 && (d = -1, p = true);
      const g = f / 2;
      let v, m = Math.abs(Math.cos(g) * l / Math.sin(g));
      m > Math.min(c.len / 2, h.len / 2) ? (m = Math.min(c.len / 2, h.len / 2), v = Math.abs(m * Math.sin(g) / Math.cos(g))) : v = l;
      const y = o.x + h.nx * m + -h.ny * v * d, x = o.y + h.ny * m + h.nx * v * d, b = Math.atan2(c.ny, c.nx) + Math.PI / 2 * d, _ = Math.atan2(h.ny, h.nx) - Math.PI / 2 * d;
      s === 0 && n.moveTo(y + Math.cos(b) * v, x + Math.sin(b) * v), n.arc(y, x, v, b, _, p), a = o;
    }
  }
  function $jt(n, t, e, r) {
    const i = (o, l) => Math.sqrt((o.x - l.x) ** 2 + (o.y - l.y) ** 2), a = (o, l, u) => ({
      x: o.x + (l.x - o.x) * u,
      y: o.y + (l.y - o.y) * u
    }), s = t.length;
    for (let o = 0; o < s; o++) {
      const l = t[(o + 1) % s], u = l.radius ?? e;
      if (u <= 0) {
        o === 0 ? n.moveTo(l.x, l.y) : n.lineTo(l.x, l.y);
        continue;
      }
      const c = t[o], h = t[(o + 2) % s], f = i(c, l);
      let d;
      if (f < 1e-4) d = l;
      else {
        const v = Math.min(f / 2, u);
        d = a(l, c, v / f);
      }
      const p = i(h, l);
      let g;
      if (p < 1e-4) g = l;
      else {
        const v = Math.min(p / 2, u);
        g = a(l, h, v / p);
      }
      o === 0 ? n.moveTo(d.x, d.y) : n.lineTo(d.x, d.y), n.quadraticCurveTo(l.x, l.y, g.x, g.y, r);
    }
  }
  const Ojt = new yr();
  class Fjt {
    constructor(t) {
      this.shapePrimitives = [], this._currentPoly = null, this._bounds = new hs(), this._graphicsPath2D = t, this.signed = t.checkForHoles;
    }
    moveTo(t, e) {
      return this.startPoly(t, e), this;
    }
    lineTo(t, e) {
      this._ensurePoly();
      const r = this._currentPoly.points, i = r[r.length - 2], a = r[r.length - 1];
      return (i !== t || a !== e) && r.push(t, e), this;
    }
    arc(t, e, r, i, a, s) {
      this._ensurePoly(false);
      const o = this._currentPoly.points;
      return PQ(o, t, e, r, i, a, s), this;
    }
    arcTo(t, e, r, i, a) {
      this._ensurePoly();
      const s = this._currentPoly.points;
      return Mjt(s, t, e, r, i, a), this;
    }
    arcToSvg(t, e, r, i, a, s, o) {
      const l = this._currentPoly.points;
      return Ljt(l, this._currentPoly.lastX, this._currentPoly.lastY, s, o, t, e, r, i, a), this;
    }
    bezierCurveTo(t, e, r, i, a, s, o) {
      this._ensurePoly();
      const l = this._currentPoly;
      return LQ(this._currentPoly.points, l.lastX, l.lastY, t, e, r, i, a, s, o), this;
    }
    quadraticCurveTo(t, e, r, i, a) {
      this._ensurePoly();
      const s = this._currentPoly;
      return Djt(this._currentPoly.points, s.lastX, s.lastY, t, e, r, i, a), this;
    }
    closePath() {
      return this.endPoly(true), this;
    }
    addPath(t, e) {
      this.endPoly(), e && !e.isIdentity() && (t = t.clone(true), t.transform(e));
      const r = this.shapePrimitives, i = r.length;
      for (let a = 0; a < t.instructions.length; a++) {
        const s = t.instructions[a];
        this[s.action](...s.data);
      }
      if (t.checkForHoles && r.length - i > 1) {
        let a = null;
        for (let s = i; s < r.length; s++) {
          const o = r[s];
          if (o.shape.type === "polygon") {
            const l = o.shape, u = a == null ? void 0 : a.shape;
            u && u.containsPolygon(l) ? (a.holes || (a.holes = []), a.holes.push(o), r.copyWithin(s, s + 1), r.length--, s--) : a = o;
          }
        }
      }
      return this;
    }
    finish(t = false) {
      this.endPoly(t);
    }
    rect(t, e, r, i, a) {
      return this.drawShape(new yr(t, e, r, i), a), this;
    }
    circle(t, e, r, i) {
      return this.drawShape(new LN(t, e, r), i), this;
    }
    poly(t, e, r) {
      const i = new Tg(t);
      return i.closePath = e, this.drawShape(i, r), this;
    }
    regularPoly(t, e, r, i, a = 0, s) {
      i = Math.max(i | 0, 3);
      const o = -1 * Math.PI / 2 + a, l = Math.PI * 2 / i, u = [];
      for (let c = 0; c < i; c++) {
        const h = o - c * l;
        u.push(t + r * Math.cos(h), e + r * Math.sin(h));
      }
      return this.poly(u, true, s), this;
    }
    roundPoly(t, e, r, i, a, s = 0, o) {
      if (i = Math.max(i | 0, 3), a <= 0) return this.regularPoly(t, e, r, i, s);
      const l = r * Math.sin(Math.PI / i) - 1e-3;
      a = Math.min(a, l);
      const u = -1 * Math.PI / 2 + s, c = Math.PI * 2 / i, h = (i - 2) * Math.PI / i / 2;
      for (let f = 0; f < i; f++) {
        const d = f * c + u, p = t + r * Math.cos(d), g = e + r * Math.sin(d), v = d + Math.PI + h, m = d - Math.PI - h, y = p + a * Math.cos(v), x = g + a * Math.sin(v), b = p + a * Math.cos(m), _ = g + a * Math.sin(m);
        f === 0 ? this.moveTo(y, x) : this.lineTo(y, x), this.quadraticCurveTo(p, g, b, _, o);
      }
      return this.closePath();
    }
    roundShape(t, e, r = false, i) {
      return t.length < 3 ? this : (r ? $jt(this, t, e, i) : Pjt(this, t, e), this.closePath());
    }
    filletRect(t, e, r, i, a) {
      if (a === 0) return this.rect(t, e, r, i);
      const s = Math.min(r, i) / 2, o = Math.min(s, Math.max(-s, a)), l = t + r, u = e + i, c = o < 0 ? -o : 0, h = Math.abs(o);
      return this.moveTo(t, e + h).arcTo(t + c, e + c, t + h, e, h).lineTo(l - h, e).arcTo(l - c, e + c, l, e + h, h).lineTo(l, u - h).arcTo(l - c, u - c, t + r - h, u, h).lineTo(t + h, u).arcTo(t + c, u - c, t, u - h, h).closePath();
    }
    chamferRect(t, e, r, i, a, s) {
      if (a <= 0) return this.rect(t, e, r, i);
      const o = Math.min(a, Math.min(r, i) / 2), l = t + r, u = e + i, c = [
        t + o,
        e,
        l - o,
        e,
        l,
        e + o,
        l,
        u - o,
        l - o,
        u,
        t + o,
        u,
        t,
        u - o,
        t,
        e + o
      ];
      for (let h = c.length - 1; h >= 2; h -= 2) c[h] === c[h - 2] && c[h - 1] === c[h - 3] && c.splice(h - 1, 2);
      return this.poly(c, true, s);
    }
    ellipse(t, e, r, i, a) {
      return this.drawShape(new PN(t, e, r, i), a), this;
    }
    roundRect(t, e, r, i, a, s) {
      return this.drawShape(new $N(t, e, r, i, a), s), this;
    }
    drawShape(t, e) {
      return this.endPoly(), this.shapePrimitives.push({
        shape: t,
        transform: e
      }), this;
    }
    startPoly(t, e) {
      let r = this._currentPoly;
      return r && this.endPoly(), r = new Tg(), r.points.push(t, e), this._currentPoly = r, this;
    }
    endPoly(t = false) {
      const e = this._currentPoly;
      return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({
        shape: e
      })), this._currentPoly = null, this;
    }
    _ensurePoly(t = true) {
      if (!this._currentPoly && (this._currentPoly = new Tg(), t)) {
        const e = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (e) {
          let r = e.shape.x, i = e.shape.y;
          if (e.transform && !e.transform.isIdentity()) {
            const a = e.transform, s = r;
            r = a.a * r + a.c * i + a.tx, i = a.b * s + a.d * i + a.ty;
          }
          this._currentPoly.points.push(r, i);
        } else this._currentPoly.points.push(0, 0);
      }
    }
    buildPath() {
      const t = this._graphicsPath2D;
      this.shapePrimitives.length = 0, this._currentPoly = null;
      for (let e = 0; e < t.instructions.length; e++) {
        const r = t.instructions[e];
        this[r.action](...r.data);
      }
      this.finish();
    }
    get bounds() {
      const t = this._bounds;
      t.clear();
      const e = this.shapePrimitives;
      for (let r = 0; r < e.length; r++) {
        const i = e[r], a = i.shape.getBounds(Ojt);
        i.transform ? t.addRect(a, i.transform) : t.addRect(a);
      }
      return t;
    }
  }
  class hd {
    constructor(t, e = false) {
      this.instructions = [], this.uid = Yn("graphicsPath"), this._dirty = true, this.checkForHoles = e, typeof t == "string" ? oqt(t, this) : this.instructions = (t == null ? void 0 : t.slice()) ?? [];
    }
    get shapePath() {
      return this._shapePath || (this._shapePath = new Fjt(this)), this._dirty && (this._dirty = false, this._shapePath.buildPath()), this._shapePath;
    }
    addPath(t, e) {
      return t = t.clone(), this.instructions.push({
        action: "addPath",
        data: [
          t,
          e
        ]
      }), this._dirty = true, this;
    }
    arc(...t) {
      return this.instructions.push({
        action: "arc",
        data: t
      }), this._dirty = true, this;
    }
    arcTo(...t) {
      return this.instructions.push({
        action: "arcTo",
        data: t
      }), this._dirty = true, this;
    }
    arcToSvg(...t) {
      return this.instructions.push({
        action: "arcToSvg",
        data: t
      }), this._dirty = true, this;
    }
    bezierCurveTo(...t) {
      return this.instructions.push({
        action: "bezierCurveTo",
        data: t
      }), this._dirty = true, this;
    }
    bezierCurveToShort(t, e, r, i, a) {
      const s = this.instructions[this.instructions.length - 1], o = this.getLastPoint(Xr.shared);
      let l = 0, u = 0;
      if (!s || s.action !== "bezierCurveTo") l = o.x, u = o.y;
      else {
        l = s.data[2], u = s.data[3];
        const c = o.x, h = o.y;
        l = c + (c - l), u = h + (h - u);
      }
      return this.instructions.push({
        action: "bezierCurveTo",
        data: [
          l,
          u,
          t,
          e,
          r,
          i,
          a
        ]
      }), this._dirty = true, this;
    }
    closePath() {
      return this.instructions.push({
        action: "closePath",
        data: []
      }), this._dirty = true, this;
    }
    ellipse(...t) {
      return this.instructions.push({
        action: "ellipse",
        data: t
      }), this._dirty = true, this;
    }
    lineTo(...t) {
      return this.instructions.push({
        action: "lineTo",
        data: t
      }), this._dirty = true, this;
    }
    moveTo(...t) {
      return this.instructions.push({
        action: "moveTo",
        data: t
      }), this;
    }
    quadraticCurveTo(...t) {
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: t
      }), this._dirty = true, this;
    }
    quadraticCurveToShort(t, e, r) {
      const i = this.instructions[this.instructions.length - 1], a = this.getLastPoint(Xr.shared);
      let s = 0, o = 0;
      if (!i || i.action !== "quadraticCurveTo") s = a.x, o = a.y;
      else {
        s = i.data[0], o = i.data[1];
        const l = a.x, u = a.y;
        s = l + (l - s), o = u + (u - o);
      }
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: [
          s,
          o,
          t,
          e,
          r
        ]
      }), this._dirty = true, this;
    }
    rect(t, e, r, i, a) {
      return this.instructions.push({
        action: "rect",
        data: [
          t,
          e,
          r,
          i,
          a
        ]
      }), this._dirty = true, this;
    }
    circle(t, e, r, i) {
      return this.instructions.push({
        action: "circle",
        data: [
          t,
          e,
          r,
          i
        ]
      }), this._dirty = true, this;
    }
    roundRect(...t) {
      return this.instructions.push({
        action: "roundRect",
        data: t
      }), this._dirty = true, this;
    }
    poly(...t) {
      return this.instructions.push({
        action: "poly",
        data: t
      }), this._dirty = true, this;
    }
    regularPoly(...t) {
      return this.instructions.push({
        action: "regularPoly",
        data: t
      }), this._dirty = true, this;
    }
    roundPoly(...t) {
      return this.instructions.push({
        action: "roundPoly",
        data: t
      }), this._dirty = true, this;
    }
    roundShape(...t) {
      return this.instructions.push({
        action: "roundShape",
        data: t
      }), this._dirty = true, this;
    }
    filletRect(...t) {
      return this.instructions.push({
        action: "filletRect",
        data: t
      }), this._dirty = true, this;
    }
    chamferRect(...t) {
      return this.instructions.push({
        action: "chamferRect",
        data: t
      }), this._dirty = true, this;
    }
    star(t, e, r, i, a, s, o) {
      a || (a = i / 2);
      const l = -1 * Math.PI / 2 + s, u = r * 2, c = Math.PI * 2 / u, h = [];
      for (let f = 0; f < u; f++) {
        const d = f % 2 ? a : i, p = f * c + l;
        h.push(t + d * Math.cos(p), e + d * Math.sin(p));
      }
      return this.poly(h, true, o), this;
    }
    clone(t = false) {
      const e = new hd();
      if (e.checkForHoles = this.checkForHoles, !t) e.instructions = this.instructions.slice();
      else for (let r = 0; r < this.instructions.length; r++) {
        const i = this.instructions[r];
        e.instructions.push({
          action: i.action,
          data: i.data.slice()
        });
      }
      return e;
    }
    clear() {
      return this.instructions.length = 0, this._dirty = true, this;
    }
    transform(t) {
      if (t.isIdentity()) return this;
      const e = t.a, r = t.b, i = t.c, a = t.d, s = t.tx, o = t.ty;
      let l = 0, u = 0, c = 0, h = 0, f = 0, d = 0, p = 0, g = 0;
      for (let v = 0; v < this.instructions.length; v++) {
        const m = this.instructions[v], y = m.data;
        switch (m.action) {
          case "moveTo":
          case "lineTo":
            l = y[0], u = y[1], y[0] = e * l + i * u + s, y[1] = r * l + a * u + o;
            break;
          case "bezierCurveTo":
            c = y[0], h = y[1], f = y[2], d = y[3], l = y[4], u = y[5], y[0] = e * c + i * h + s, y[1] = r * c + a * h + o, y[2] = e * f + i * d + s, y[3] = r * f + a * d + o, y[4] = e * l + i * u + s, y[5] = r * l + a * u + o;
            break;
          case "quadraticCurveTo":
            c = y[0], h = y[1], l = y[2], u = y[3], y[0] = e * c + i * h + s, y[1] = r * c + a * h + o, y[2] = e * l + i * u + s, y[3] = r * l + a * u + o;
            break;
          case "arcToSvg":
            l = y[5], u = y[6], p = y[0], g = y[1], y[0] = e * p + i * g, y[1] = r * p + a * g, y[5] = e * l + i * u + s, y[6] = r * l + a * u + o;
            break;
          case "circle":
            y[4] = Lp(y[3], t);
            break;
          case "rect":
            y[4] = Lp(y[4], t);
            break;
          case "ellipse":
            y[8] = Lp(y[8], t);
            break;
          case "roundRect":
            y[5] = Lp(y[5], t);
            break;
          case "addPath":
            y[0].transform(t);
            break;
          case "poly":
            y[2] = Lp(y[2], t);
            break;
          default:
            Ki("unknown transform action", m.action);
            break;
        }
      }
      return this._dirty = true, this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(t) {
      let e = this.instructions.length - 1, r = this.instructions[e];
      if (!r) return t.x = 0, t.y = 0, t;
      for (; r.action === "closePath"; ) {
        if (e--, e < 0) return t.x = 0, t.y = 0, t;
        r = this.instructions[e];
      }
      switch (r.action) {
        case "moveTo":
        case "lineTo":
          t.x = r.data[0], t.y = r.data[1];
          break;
        case "quadraticCurveTo":
          t.x = r.data[2], t.y = r.data[3];
          break;
        case "bezierCurveTo":
          t.x = r.data[4], t.y = r.data[5];
          break;
        case "arc":
        case "arcToSvg":
          t.x = r.data[5], t.y = r.data[6];
          break;
        case "addPath":
          r.data[0].getLastPoint(t);
          break;
      }
      return t;
    }
  }
  function Lp(n, t) {
    return n ? n.prepend(t) : t.clone();
  }
  function Tn(n, t, e) {
    const r = n.getAttribute(t);
    return r ? Number(r) : e;
  }
  function Bjt(n, t) {
    const e = n.querySelectorAll("defs");
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      for (let a = 0; a < i.children.length; a++) {
        const s = i.children[a];
        switch (s.nodeName.toLowerCase()) {
          case "lineargradient":
            t.defs[s.id] = zjt(s);
            break;
          case "radialgradient":
            t.defs[s.id] = Vjt();
            break;
        }
      }
    }
  }
  function zjt(n) {
    const t = Tn(n, "x1", 0), e = Tn(n, "y1", 0), r = Tn(n, "x2", 1), i = Tn(n, "y2", 0), a = n.getAttribute("gradientUnits") || "objectBoundingBox", s = new ch(t, e, r, i, a === "objectBoundingBox" ? "local" : "global");
    for (let o = 0; o < n.children.length; o++) {
      const l = n.children[o], u = Tn(l, "offset", 0), c = jr.shared.setValue(l.getAttribute("stop-color")).toNumber();
      s.addColorStop(u, c);
    }
    return s;
  }
  function Vjt(n) {
    return Ki("[SVG Parser] Radial gradients are not yet supported"), new ch(0, 0, 1, 0);
  }
  function h4(n) {
    const t = n.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return t ? t[1] : "";
  }
  const f4 = {
    fill: {
      type: "paint",
      default: 0
    },
    "fill-opacity": {
      type: "number",
      default: 1
    },
    stroke: {
      type: "paint",
      default: 0
    },
    "stroke-width": {
      type: "number",
      default: 1
    },
    "stroke-opacity": {
      type: "number",
      default: 1
    },
    "stroke-linecap": {
      type: "string",
      default: "butt"
    },
    "stroke-linejoin": {
      type: "string",
      default: "miter"
    },
    "stroke-miterlimit": {
      type: "number",
      default: 10
    },
    "stroke-dasharray": {
      type: "string",
      default: "none"
    },
    "stroke-dashoffset": {
      type: "number",
      default: 0
    },
    opacity: {
      type: "number",
      default: 1
    }
  };
  function $Q(n, t) {
    const e = n.getAttribute("style"), r = {}, i = {}, a = {
      strokeStyle: r,
      fillStyle: i,
      useFill: false,
      useStroke: false
    };
    for (const s in f4) {
      const o = n.getAttribute(s);
      o && d4(t, a, s, o.trim());
    }
    if (e) {
      const s = e.split(";");
      for (let o = 0; o < s.length; o++) {
        const l = s[o].trim(), [u, c] = l.split(":");
        f4[u] && d4(t, a, u, c.trim());
      }
    }
    return {
      strokeStyle: a.useStroke ? r : null,
      fillStyle: a.useFill ? i : null,
      useFill: a.useFill,
      useStroke: a.useStroke
    };
  }
  function d4(n, t, e, r) {
    switch (e) {
      case "stroke":
        if (r !== "none") {
          if (r.startsWith("url(")) {
            const i = h4(r);
            t.strokeStyle.fill = n.defs[i];
          } else t.strokeStyle.color = jr.shared.setValue(r).toNumber();
          t.useStroke = true;
        }
        break;
      case "stroke-width":
        t.strokeStyle.width = Number(r);
        break;
      case "fill":
        if (r !== "none") {
          if (r.startsWith("url(")) {
            const i = h4(r);
            t.fillStyle.fill = n.defs[i];
          } else t.fillStyle.color = jr.shared.setValue(r).toNumber();
          t.useFill = true;
        }
        break;
      case "fill-opacity":
        t.fillStyle.alpha = Number(r);
        break;
      case "stroke-opacity":
        t.strokeStyle.alpha = Number(r);
        break;
      case "opacity":
        t.fillStyle.alpha = Number(r), t.strokeStyle.alpha = Number(r);
        break;
    }
  }
  function Gjt(n, t) {
    if (typeof n == "string") {
      const s = document.createElement("div");
      s.innerHTML = n.trim(), n = s.querySelector("svg");
    }
    const e = {
      context: t,
      defs: {},
      path: new hd()
    };
    Bjt(n, e);
    const r = n.children, { fillStyle: i, strokeStyle: a } = $Q(n, e);
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      o.nodeName.toLowerCase() !== "defs" && OQ(o, e, i, a);
    }
    return t;
  }
  function OQ(n, t, e, r) {
    const i = n.children, { fillStyle: a, strokeStyle: s } = $Q(n, t);
    a && e ? e = {
      ...e,
      ...a
    } : a && (e = a), s && r ? r = {
      ...r,
      ...s
    } : s && (r = s);
    const o = !e && !r;
    o && (e = {
      color: 0
    });
    let l, u, c, h, f, d, p, g, v, m, y, x, b, _, w, S, I;
    switch (n.nodeName.toLowerCase()) {
      case "path":
        _ = n.getAttribute("d"), n.getAttribute("fill-rule") === "evenodd" && Ki("SVG Evenodd fill rule not supported, your svg may render incorrectly"), w = new hd(_, true), t.context.path(w), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "circle":
        p = Tn(n, "cx", 0), g = Tn(n, "cy", 0), v = Tn(n, "r", 0), t.context.ellipse(p, g, v, v), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "rect":
        l = Tn(n, "x", 0), u = Tn(n, "y", 0), S = Tn(n, "width", 0), I = Tn(n, "height", 0), m = Tn(n, "rx", 0), y = Tn(n, "ry", 0), m || y ? t.context.roundRect(l, u, S, I, m || y) : t.context.rect(l, u, S, I), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "ellipse":
        p = Tn(n, "cx", 0), g = Tn(n, "cy", 0), m = Tn(n, "rx", 0), y = Tn(n, "ry", 0), t.context.beginPath(), t.context.ellipse(p, g, m, y), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "line":
        c = Tn(n, "x1", 0), h = Tn(n, "y1", 0), f = Tn(n, "x2", 0), d = Tn(n, "y2", 0), t.context.beginPath(), t.context.moveTo(c, h), t.context.lineTo(f, d), r && t.context.stroke(r);
        break;
      case "polygon":
        b = n.getAttribute("points"), x = b.match(/\d+/g).map((T) => parseInt(T, 10)), t.context.poly(x, true), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "polyline":
        b = n.getAttribute("points"), x = b.match(/\d+/g).map((T) => parseInt(T, 10)), t.context.poly(x, false), r && t.context.stroke(r);
        break;
      case "g":
      case "svg":
        break;
      default: {
        Ki(`[SVG parser] <${n.nodeName}> elements unsupported`);
        break;
      }
    }
    o && (e = null);
    for (let T = 0; T < i.length; T++) OQ(i[T], t, e, r);
  }
  function Wjt(n) {
    return jr.isColorLike(n);
  }
  function p4(n) {
    return n instanceof NN;
  }
  function g4(n) {
    return n instanceof ch;
  }
  function Ujt(n) {
    return n instanceof on;
  }
  function Hjt(n, t, e) {
    const r = jr.shared.setValue(t ?? 0);
    return n.color = r.toNumber(), n.alpha = r.alpha === 1 ? e.alpha : r.alpha, n.texture = on.WHITE, {
      ...e,
      ...n
    };
  }
  function Xjt(n, t, e) {
    return n.texture = t, {
      ...e,
      ...n
    };
  }
  function v4(n, t, e) {
    return n.fill = t, n.color = 16777215, n.texture = t.texture, n.matrix = t.transform, {
      ...e,
      ...n
    };
  }
  function m4(n, t, e) {
    return t.buildGradient(), n.fill = t, n.color = 16777215, n.texture = t.texture, n.matrix = t.transform, n.textureSpace = t.textureSpace, {
      ...e,
      ...n
    };
  }
  function Yjt(n, t) {
    const e = {
      ...t,
      ...n
    }, r = jr.shared.setValue(e.color);
    return e.alpha *= r.alpha, e.color = r.toNumber(), e;
  }
  function Ic(n, t) {
    if (n == null) return null;
    const e = {}, r = n;
    return Wjt(n) ? Hjt(e, n, t) : Ujt(n) ? Xjt(e, n, t) : p4(n) ? v4(e, n, t) : g4(n) ? m4(e, n, t) : r.fill && p4(r.fill) ? v4(r, r.fill, t) : r.fill && g4(r.fill) ? m4(r, r.fill, t) : Yjt(r, t);
  }
  function u1(n, t) {
    const { width: e, alignment: r, miterLimit: i, cap: a, join: s, pixelLine: o, ...l } = t, u = Ic(n, l);
    return u ? {
      width: e,
      alignment: r,
      miterLimit: i,
      cap: a,
      join: s,
      pixelLine: o,
      ...u
    } : null;
  }
  const qjt = new Xr(), y4 = new Ve(), FN = class Ds extends po {
    constructor() {
      super(...arguments), this.uid = Yn("graphicsContext"), this.dirty = true, this.batchMode = "auto", this.instructions = [], this._activePath = new hd(), this._transform = new Ve(), this._fillStyle = {
        ...Ds.defaultFillStyle
      }, this._strokeStyle = {
        ...Ds.defaultStrokeStyle
      }, this._stateStack = [], this._tick = 0, this._bounds = new hs(), this._boundsDirty = true;
    }
    clone() {
      const t = new Ds();
      return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = {
        ...this._fillStyle
      }, t._strokeStyle = {
        ...this._strokeStyle
      }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = true, t;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(t) {
      this._fillStyle = Ic(t, Ds.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(t) {
      this._strokeStyle = u1(t, Ds.defaultStrokeStyle);
    }
    setFillStyle(t) {
      return this._fillStyle = Ic(t, Ds.defaultFillStyle), this;
    }
    setStrokeStyle(t) {
      return this._strokeStyle = Ic(t, Ds.defaultStrokeStyle), this;
    }
    texture(t, e, r, i, a, s) {
      return this.instructions.push({
        action: "texture",
        data: {
          image: t,
          dx: r || 0,
          dy: i || 0,
          dw: a || t.frame.width,
          dh: s || t.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: e ? jr.shared.setValue(e).toNumber() : 16777215
        }
      }), this.onUpdate(), this;
    }
    beginPath() {
      return this._activePath = new hd(), this;
    }
    fill(t, e) {
      let r;
      const i = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && i && i.action === "stroke" ? r = i.data.path : r = this._activePath.clone(), r ? (t != null && (e !== void 0 && typeof t == "number" && (fn(An, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = {
        color: t,
        alpha: e
      }), this._fillStyle = Ic(t, Ds.defaultFillStyle)), this.instructions.push({
        action: "fill",
        data: {
          style: this.fillStyle,
          path: r
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    _initNextPathLocation() {
      const { x: t, y: e } = this._activePath.getLastPoint(Xr.shared);
      this._activePath.clear(), this._activePath.moveTo(t, e);
    }
    stroke(t) {
      let e;
      const r = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && r && r.action === "fill" ? e = r.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = u1(t, Ds.defaultStrokeStyle)), this.instructions.push({
        action: "stroke",
        data: {
          style: this.strokeStyle,
          path: e
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    cut() {
      for (let t = 0; t < 2; t++) {
        const e = this.instructions[this.instructions.length - 1 - t], r = this._activePath.clone();
        if (e && (e.action === "stroke" || e.action === "fill")) if (e.data.hole) e.data.hole.addPath(r);
        else {
          e.data.hole = r;
          break;
        }
      }
      return this._initNextPathLocation(), this;
    }
    arc(t, e, r, i, a, s) {
      this._tick++;
      const o = this._transform;
      return this._activePath.arc(o.a * t + o.c * e + o.tx, o.b * t + o.d * e + o.ty, r, i, a, s), this;
    }
    arcTo(t, e, r, i, a) {
      this._tick++;
      const s = this._transform;
      return this._activePath.arcTo(s.a * t + s.c * e + s.tx, s.b * t + s.d * e + s.ty, s.a * r + s.c * i + s.tx, s.b * r + s.d * i + s.ty, a), this;
    }
    arcToSvg(t, e, r, i, a, s, o) {
      this._tick++;
      const l = this._transform;
      return this._activePath.arcToSvg(t, e, r, i, a, l.a * s + l.c * o + l.tx, l.b * s + l.d * o + l.ty), this;
    }
    bezierCurveTo(t, e, r, i, a, s, o) {
      this._tick++;
      const l = this._transform;
      return this._activePath.bezierCurveTo(l.a * t + l.c * e + l.tx, l.b * t + l.d * e + l.ty, l.a * r + l.c * i + l.tx, l.b * r + l.d * i + l.ty, l.a * a + l.c * s + l.tx, l.b * a + l.d * s + l.ty, o), this;
    }
    closePath() {
      var _a2;
      return this._tick++, (_a2 = this._activePath) == null ? void 0 : _a2.closePath(), this;
    }
    ellipse(t, e, r, i) {
      return this._tick++, this._activePath.ellipse(t, e, r, i, this._transform.clone()), this;
    }
    circle(t, e, r) {
      return this._tick++, this._activePath.circle(t, e, r, this._transform.clone()), this;
    }
    path(t) {
      return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
    }
    lineTo(t, e) {
      this._tick++;
      const r = this._transform;
      return this._activePath.lineTo(r.a * t + r.c * e + r.tx, r.b * t + r.d * e + r.ty), this;
    }
    moveTo(t, e) {
      this._tick++;
      const r = this._transform, i = this._activePath.instructions, a = r.a * t + r.c * e + r.tx, s = r.b * t + r.d * e + r.ty;
      return i.length === 1 && i[0].action === "moveTo" ? (i[0].data[0] = a, i[0].data[1] = s, this) : (this._activePath.moveTo(a, s), this);
    }
    quadraticCurveTo(t, e, r, i, a) {
      this._tick++;
      const s = this._transform;
      return this._activePath.quadraticCurveTo(s.a * t + s.c * e + s.tx, s.b * t + s.d * e + s.ty, s.a * r + s.c * i + s.tx, s.b * r + s.d * i + s.ty, a), this;
    }
    rect(t, e, r, i) {
      return this._tick++, this._activePath.rect(t, e, r, i, this._transform.clone()), this;
    }
    roundRect(t, e, r, i, a) {
      return this._tick++, this._activePath.roundRect(t, e, r, i, a, this._transform.clone()), this;
    }
    poly(t, e) {
      return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
    }
    regularPoly(t, e, r, i, a = 0, s) {
      return this._tick++, this._activePath.regularPoly(t, e, r, i, a, s), this;
    }
    roundPoly(t, e, r, i, a, s) {
      return this._tick++, this._activePath.roundPoly(t, e, r, i, a, s), this;
    }
    roundShape(t, e, r, i) {
      return this._tick++, this._activePath.roundShape(t, e, r, i), this;
    }
    filletRect(t, e, r, i, a) {
      return this._tick++, this._activePath.filletRect(t, e, r, i, a), this;
    }
    chamferRect(t, e, r, i, a, s) {
      return this._tick++, this._activePath.chamferRect(t, e, r, i, a, s), this;
    }
    star(t, e, r, i, a = 0, s = 0) {
      return this._tick++, this._activePath.star(t, e, r, i, a, s, this._transform.clone()), this;
    }
    svg(t) {
      return this._tick++, Gjt(t, this), this;
    }
    restore() {
      const t = this._stateStack.pop();
      return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
    }
    save() {
      return this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: {
          ...this._fillStyle
        },
        strokeStyle: {
          ...this._strokeStyle
        }
      }), this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      return this._transform.identity(), this;
    }
    rotate(t) {
      return this._transform.rotate(t), this;
    }
    scale(t, e = t) {
      return this._transform.scale(t, e), this;
    }
    setTransform(t, e, r, i, a, s) {
      return t instanceof Ve ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, r, i, a, s), this);
    }
    transform(t, e, r, i, a, s) {
      return t instanceof Ve ? (this._transform.append(t), this) : (y4.set(t, e, r, i, a, s), this._transform.append(y4), this);
    }
    translate(t, e = t) {
      return this._transform.translate(t, e), this;
    }
    clear() {
      return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
    }
    onUpdate() {
      this.dirty || (this.emit("update", this, 16), this.dirty = true, this._boundsDirty = true);
    }
    get bounds() {
      if (!this._boundsDirty) return this._bounds;
      const t = this._bounds;
      t.clear();
      for (let e = 0; e < this.instructions.length; e++) {
        const r = this.instructions[e], i = r.action;
        if (i === "fill") {
          const a = r.data;
          t.addBounds(a.path.bounds);
        } else if (i === "texture") {
          const a = r.data;
          t.addFrame(a.dx, a.dy, a.dx + a.dw, a.dy + a.dh, a.transform);
        }
        if (i === "stroke") {
          const a = r.data, s = a.style.alignment, o = a.style.width * (1 - s), l = a.path.bounds;
          t.addFrame(l.minX - o, l.minY - o, l.maxX + o, l.maxY + o);
        }
      }
      return t;
    }
    containsPoint(t) {
      var _a2;
      if (!this.bounds.containsPoint(t.x, t.y)) return false;
      const e = this.instructions;
      let r = false;
      for (let i = 0; i < e.length; i++) {
        const a = e[i], s = a.data, o = s.path;
        if (!a.action || !o) continue;
        const l = s.style, u = o.shapePath.shapePrimitives;
        for (let c = 0; c < u.length; c++) {
          const h = u[c].shape;
          if (!l || !h) continue;
          const f = u[c].transform, d = f ? f.applyInverse(t, qjt) : t;
          if (a.action === "fill") r = h.contains(d.x, d.y);
          else {
            const g = l;
            r = h.strokeContains(d.x, d.y, g.width, g.alignment);
          }
          const p = s.hole;
          if (p) {
            const g = (_a2 = p.shapePath) == null ? void 0 : _a2.shapePrimitives;
            if (g) for (let v = 0; v < g.length; v++) g[v].shape.contains(d.x, d.y) && (r = false);
          }
          if (r) return true;
        }
      }
      return r;
    }
    destroy(t = false) {
      if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        this._fillStyle.texture && this._fillStyle.texture.destroy(r), this._strokeStyle.texture && this._strokeStyle.texture.destroy(r);
      }
      this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
    }
  };
  FN.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: on.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local"
  };
  FN.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: on.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: false
  };
  let qa = FN;
  const x4 = [
    "align",
    "breakWords",
    "cssOverrides",
    "fontVariant",
    "fontWeight",
    "leading",
    "letterSpacing",
    "lineHeight",
    "padding",
    "textBaseline",
    "trim",
    "whiteSpace",
    "wordWrap",
    "wordWrapWidth",
    "fontFamily",
    "fontStyle",
    "fontSize"
  ];
  jjt = function(n) {
    const t = [];
    let e = 0;
    for (let r = 0; r < x4.length; r++) {
      const i = `_${x4[r]}`;
      t[e++] = n[i];
    }
    return e = FQ(n._fill, t, e), e = Kjt(n._stroke, t, e), e = Zjt(n.dropShadow, t, e), t.join("-");
  };
  function FQ(n, t, e) {
    var _a2;
    return n && (t[e++] = n.color, t[e++] = n.alpha, t[e++] = (_a2 = n.fill) == null ? void 0 : _a2.styleKey), e;
  }
  function Kjt(n, t, e) {
    return n && (e = FQ(n, t, e), t[e++] = n.width, t[e++] = n.alignment, t[e++] = n.cap, t[e++] = n.join, t[e++] = n.miterLimit), e;
  }
  function Zjt(n, t, e) {
    return n && (t[e++] = n.alpha, t[e++] = n.angle, t[e++] = n.blur, t[e++] = n.distance, t[e++] = jr.shared.setValue(n.color).toNumber()), e;
  }
  const BN = class bf extends po {
    constructor(t = {}) {
      super(), Jjt(t);
      const e = {
        ...bf.defaultTextStyle,
        ...t
      };
      for (const r in e) {
        const i = r;
        this[i] = e[r];
      }
      this.update();
    }
    get align() {
      return this._align;
    }
    set align(t) {
      this._align = t, this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(t) {
      this._breakWords = t, this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(t) {
      t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({
        ...bf.defaultDropShadow,
        ...t
      }) : this._dropShadow = t ? this._createProxy({
        ...bf.defaultDropShadow
      }) : null, this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(t) {
      this._fontFamily = t, this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(t) {
      typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(t) {
      this._fontStyle = t.toLowerCase(), this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(t) {
      this._fontVariant = t, this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(t) {
      this._fontWeight = t, this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(t) {
      this._leading = t, this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(t) {
      this._letterSpacing = t, this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(t) {
      this._lineHeight = t, this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(t) {
      this._padding = t, this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(t) {
      this._trim = t, this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(t) {
      this._textBaseline = t, this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(t) {
      this._whiteSpace = t, this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(t) {
      this._wordWrap = t, this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(t) {
      this._wordWrapWidth = t, this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(t) {
      t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({
        ...qa.defaultFillStyle,
        ...t
      }, () => {
        this._fill = Ic({
          ...this._originalFill
        }, qa.defaultFillStyle);
      })), this._fill = Ic(t === 0 ? "black" : t, qa.defaultFillStyle), this.update());
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(t) {
      t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({
        ...qa.defaultStrokeStyle,
        ...t
      }, () => {
        this._stroke = u1({
          ...this._originalStroke
        }, qa.defaultStrokeStyle);
      })), this._stroke = u1(t, qa.defaultStrokeStyle), this.update());
    }
    _generateKey() {
      return this._styleKey = jjt(this), this._styleKey;
    }
    update() {
      this._styleKey = null, this.emit("update", this);
    }
    reset() {
      const t = bf.defaultTextStyle;
      for (const e in t) this[e] = t[e];
    }
    get styleKey() {
      return this._styleKey || this._generateKey();
    }
    clone() {
      return new bf({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? {
          ...this._dropShadow
        } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth
      });
    }
    destroy(t = false) {
      var _a2, _b2, _c2, _d2;
      if (this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
        const r = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
        ((_a2 = this._fill) == null ? void 0 : _a2.texture) && this._fill.texture.destroy(r), ((_b2 = this._originalFill) == null ? void 0 : _b2.texture) && this._originalFill.texture.destroy(r), ((_c2 = this._stroke) == null ? void 0 : _c2.texture) && this._stroke.texture.destroy(r), ((_d2 = this._originalStroke) == null ? void 0 : _d2.texture) && this._originalStroke.texture.destroy(r);
      }
      this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
    }
    _createProxy(t, e) {
      return new Proxy(t, {
        set: (r, i, a) => (r[i] = a, e == null ? void 0 : e(i, a), this.update(), true)
      });
    }
    _isFillStyle(t) {
      return (t ?? null) !== null && !(jr.isColorLike(t) || t instanceof ch || t instanceof NN);
    }
  };
  BN.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
  };
  BN.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  hk = BN;
  function Jjt(n) {
    const t = n;
    if (typeof t.dropShadow == "boolean" && t.dropShadow) {
      const e = hk.defaultDropShadow;
      n.dropShadow = {
        alpha: t.dropShadowAlpha ?? e.alpha,
        angle: t.dropShadowAngle ?? e.angle,
        blur: t.dropShadowBlur ?? e.blur,
        color: t.dropShadowColor ?? e.color,
        distance: t.dropShadowDistance ?? e.distance
      };
    }
    if (t.strokeThickness !== void 0) {
      fn(An, "strokeThickness is now a part of stroke");
      const e = t.stroke;
      let r = {};
      if (jr.isColorLike(e)) r.color = e;
      else if (e instanceof ch || e instanceof NN) r.fill = e;
      else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill")) r = e;
      else throw new Error("Invalid stroke value.");
      n.stroke = {
        ...r,
        width: t.strokeThickness
      };
    }
    if (Array.isArray(t.fillGradientStops)) {
      fn(An, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let e;
      n.fontSize == null ? n.fontSize = hk.defaultTextStyle.fontSize : typeof n.fontSize == "string" ? e = parseInt(n.fontSize, 10) : e = n.fontSize;
      const r = new ch({
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: (e || 0) * 1.7
        }
      }), i = t.fillGradientStops.map((a) => jr.shared.setValue(a).toNumber());
      i.forEach((a, s) => {
        const o = s / (i.length - 1);
        r.addColorStop(o, a);
      }), n.fill = {
        fill: r
      };
    }
  }
  const Qjt = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  t7t = function(n) {
    const t = typeof n.fontSize == "number" ? `${n.fontSize}px` : n.fontSize;
    let e = n.fontFamily;
    Array.isArray(n.fontFamily) || (e = n.fontFamily.split(","));
    for (let r = e.length - 1; r >= 0; r--) {
      let i = e[r].trim();
      !/([\"\'])[^\'\"]+\1/.test(i) && !Qjt.includes(i) && (i = `"${i}"`), e[r] = i;
    }
    return `${n.fontStyle} ${n.fontVariant} ${n.fontWeight} ${t} ${e.join(",")}`;
  };
  const rI = {
    willReadFrequently: true
  }, vs = class Xt {
    static get experimentalLetterSpacingSupported() {
      let t = Xt._experimentalLetterSpacingSupported;
      if (t !== void 0) {
        const e = as.get().getCanvasRenderingContext2D().prototype;
        t = Xt._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
      }
      return t;
    }
    constructor(t, e, r, i, a, s, o, l, u) {
      this.text = t, this.style = e, this.width = r, this.height = i, this.lines = a, this.lineWidths = s, this.lineHeight = o, this.maxLineWidth = l, this.fontProperties = u;
    }
    static measureText(t = " ", e, r = Xt._canvas, i = e.wordWrap) {
      var _a2;
      const a = `${t}:${e.styleKey}`;
      if (Xt._measurementCache[a]) return Xt._measurementCache[a];
      const s = t7t(e), o = Xt.measureFont(s);
      o.fontSize === 0 && (o.fontSize = e.fontSize, o.ascent = e.fontSize);
      const l = Xt.__context;
      l.font = s;
      const c = (i ? Xt._wordWrap(t, e, r) : t).split(/(?:\r\n|\r|\n)/), h = new Array(c.length);
      let f = 0;
      for (let y = 0; y < c.length; y++) {
        const x = Xt._measureText(c[y], e.letterSpacing, l);
        h[y] = x, f = Math.max(f, x);
      }
      const d = ((_a2 = e._stroke) == null ? void 0 : _a2.width) || 0;
      let p = f + d;
      e.dropShadow && (p += e.dropShadow.distance);
      const g = e.lineHeight || o.fontSize;
      let v = Math.max(g, o.fontSize + d) + (c.length - 1) * (g + e.leading);
      return e.dropShadow && (v += e.dropShadow.distance), new Xt(t, e, p, v, c, h, g + e.leading, f, o);
    }
    static _measureText(t, e, r) {
      let i = false;
      Xt.experimentalLetterSpacingSupported && (Xt.experimentalLetterSpacing ? (r.letterSpacing = `${e}px`, r.textLetterSpacing = `${e}px`, i = true) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
      const a = r.measureText(t);
      let s = a.width;
      const o = -a.actualBoundingBoxLeft;
      let u = a.actualBoundingBoxRight - o;
      if (s > 0) if (i) s -= e, u -= e;
      else {
        const c = (Xt.graphemeSegmenter(t).length - 1) * e;
        s += c, u += c;
      }
      return Math.max(s, u);
    }
    static _wordWrap(t, e, r = Xt._canvas) {
      const i = r.getContext("2d", rI);
      let a = 0, s = "", o = "";
      const l = /* @__PURE__ */ Object.create(null), { letterSpacing: u, whiteSpace: c } = e, h = Xt._collapseSpaces(c), f = Xt._collapseNewlines(c);
      let d = !h;
      const p = e.wordWrapWidth + u, g = Xt._tokenize(t);
      for (let v = 0; v < g.length; v++) {
        let m = g[v];
        if (Xt._isNewline(m)) {
          if (!f) {
            o += Xt._addLine(s), d = !h, s = "", a = 0;
            continue;
          }
          m = " ";
        }
        if (h) {
          const x = Xt.isBreakingSpace(m), b = Xt.isBreakingSpace(s[s.length - 1]);
          if (x && b) continue;
        }
        const y = Xt._getFromCache(m, u, l, i);
        if (y > p) if (s !== "" && (o += Xt._addLine(s), s = "", a = 0), Xt.canBreakWords(m, e.breakWords)) {
          const x = Xt.wordWrapSplit(m);
          for (let b = 0; b < x.length; b++) {
            let _ = x[b], w = _, S = 1;
            for (; x[b + S]; ) {
              const T = x[b + S];
              if (!Xt.canBreakChars(w, T, m, b, e.breakWords)) _ += T;
              else break;
              w = T, S++;
            }
            b += S - 1;
            const I = Xt._getFromCache(_, u, l, i);
            I + a > p && (o += Xt._addLine(s), d = false, s = "", a = 0), s += _, a += I;
          }
        } else {
          s.length > 0 && (o += Xt._addLine(s), s = "", a = 0);
          const x = v === g.length - 1;
          o += Xt._addLine(m, !x), d = false, s = "", a = 0;
        }
        else y + a > p && (d = false, o += Xt._addLine(s), s = "", a = 0), (s.length > 0 || !Xt.isBreakingSpace(m) || d) && (s += m, a += y);
      }
      return o += Xt._addLine(s, false), o;
    }
    static _addLine(t, e = true) {
      return t = Xt._trimRight(t), t = e ? `${t}
` : t, t;
    }
    static _getFromCache(t, e, r, i) {
      let a = r[t];
      return typeof a != "number" && (a = Xt._measureText(t, e, i) + e, r[t] = a), a;
    }
    static _collapseSpaces(t) {
      return t === "normal" || t === "pre-line";
    }
    static _collapseNewlines(t) {
      return t === "normal";
    }
    static _trimRight(t) {
      if (typeof t != "string") return "";
      for (let e = t.length - 1; e >= 0; e--) {
        const r = t[e];
        if (!Xt.isBreakingSpace(r)) break;
        t = t.slice(0, -1);
      }
      return t;
    }
    static _isNewline(t) {
      return typeof t != "string" ? false : Xt._newlines.includes(t.charCodeAt(0));
    }
    static isBreakingSpace(t, e) {
      return typeof t != "string" ? false : Xt._breakingSpaces.includes(t.charCodeAt(0));
    }
    static _tokenize(t) {
      const e = [];
      let r = "";
      if (typeof t != "string") return e;
      for (let i = 0; i < t.length; i++) {
        const a = t[i], s = t[i + 1];
        if (Xt.isBreakingSpace(a, s) || Xt._isNewline(a)) {
          r !== "" && (e.push(r), r = ""), e.push(a);
          continue;
        }
        r += a;
      }
      return r !== "" && e.push(r), e;
    }
    static canBreakWords(t, e) {
      return e;
    }
    static canBreakChars(t, e, r, i, a) {
      return true;
    }
    static wordWrapSplit(t) {
      return Xt.graphemeSegmenter(t);
    }
    static measureFont(t) {
      if (Xt._fonts[t]) return Xt._fonts[t];
      const e = Xt._context;
      e.font = t;
      const r = e.measureText(Xt.METRICS_STRING + Xt.BASELINE_SYMBOL), i = {
        ascent: r.actualBoundingBoxAscent,
        descent: r.actualBoundingBoxDescent,
        fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
      };
      return Xt._fonts[t] = i, i;
    }
    static clearMetrics(t = "") {
      t ? delete Xt._fonts[t] : Xt._fonts = {};
    }
    static get _canvas() {
      var _a2;
      if (!Xt.__canvas) {
        let t;
        try {
          const e = new OffscreenCanvas(0, 0);
          if ((_a2 = e.getContext("2d", rI)) == null ? void 0 : _a2.measureText) return Xt.__canvas = e, e;
          t = as.get().createCanvas();
        } catch {
          t = as.get().createCanvas();
        }
        t.width = t.height = 10, Xt.__canvas = t;
      }
      return Xt.__canvas;
    }
    static get _context() {
      return Xt.__context || (Xt.__context = Xt._canvas.getContext("2d", rI)), Xt.__context;
    }
  };
  vs.METRICS_STRING = "|\xC9q\xC5";
  vs.BASELINE_SYMBOL = "M";
  vs.BASELINE_MULTIPLIER = 1.4;
  vs.HEIGHT_MULTIPLIER = 2;
  vs.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
      const n = new Intl.Segmenter();
      return (t) => [
        ...n.segment(t)
      ].map((e) => e.segment);
    }
    return (n) => [
      ...n
    ];
  })();
  vs.experimentalLetterSpacing = false;
  vs._fonts = {};
  vs._newlines = [
    10,
    13
  ];
  vs._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  vs._measurementCache = {};
  e7t = vs;
  c1 = class extends DN {
    constructor(t) {
      t instanceof qa && (t = {
        context: t
      });
      const { context: e, roundPixels: r, ...i } = t || {};
      super({
        label: "Graphics",
        ...i
      }), this.renderPipeId = "graphics", e ? this._context = e : this._context = this._ownedContext = new qa(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = false, this.roundPixels = r ?? false;
    }
    set context(t) {
      t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    updateBounds() {
    }
    containsPoint(t) {
      return this._context.containsPoint(t);
    }
    destroy(t) {
      this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === true || (t == null ? void 0 : t.context) === true) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t);
    }
    _callContextMethod(t, e) {
      return this.context[t](...e), this;
    }
    setFillStyle(...t) {
      return this._callContextMethod("setFillStyle", t);
    }
    setStrokeStyle(...t) {
      return this._callContextMethod("setStrokeStyle", t);
    }
    fill(...t) {
      return this._callContextMethod("fill", t);
    }
    stroke(...t) {
      return this._callContextMethod("stroke", t);
    }
    texture(...t) {
      return this._callContextMethod("texture", t);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...t) {
      return this._callContextMethod("arc", t);
    }
    arcTo(...t) {
      return this._callContextMethod("arcTo", t);
    }
    arcToSvg(...t) {
      return this._callContextMethod("arcToSvg", t);
    }
    bezierCurveTo(...t) {
      return this._callContextMethod("bezierCurveTo", t);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...t) {
      return this._callContextMethod("ellipse", t);
    }
    circle(...t) {
      return this._callContextMethod("circle", t);
    }
    path(...t) {
      return this._callContextMethod("path", t);
    }
    lineTo(...t) {
      return this._callContextMethod("lineTo", t);
    }
    moveTo(...t) {
      return this._callContextMethod("moveTo", t);
    }
    quadraticCurveTo(...t) {
      return this._callContextMethod("quadraticCurveTo", t);
    }
    rect(...t) {
      return this._callContextMethod("rect", t);
    }
    roundRect(...t) {
      return this._callContextMethod("roundRect", t);
    }
    poly(...t) {
      return this._callContextMethod("poly", t);
    }
    regularPoly(...t) {
      return this._callContextMethod("regularPoly", t);
    }
    roundPoly(...t) {
      return this._callContextMethod("roundPoly", t);
    }
    roundShape(...t) {
      return this._callContextMethod("roundShape", t);
    }
    filletRect(...t) {
      return this._callContextMethod("filletRect", t);
    }
    chamferRect(...t) {
      return this._callContextMethod("chamferRect", t);
    }
    star(...t) {
      return this._callContextMethod("star", t);
    }
    svg(...t) {
      return this._callContextMethod("svg", t);
    }
    restore(...t) {
      return this._callContextMethod("restore", t);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...t) {
      return this._callContextMethod("rotate", t);
    }
    scaleTransform(...t) {
      return this._callContextMethod("scale", t);
    }
    setTransform(...t) {
      return this._callContextMethod("setTransform", t);
    }
    transform(...t) {
      return this._callContextMethod("transform", t);
    }
    translateTransform(...t) {
      return this._callContextMethod("translate", t);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(t) {
      this._context.fillStyle = t;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(t) {
      this._context.strokeStyle = t;
    }
    clone(t = false) {
      return t ? new c1(this._context.clone()) : (this._ownedContext = null, new c1(this._context));
    }
    lineStyle(t, e, r) {
      fn(An, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const i = {};
      return t && (i.width = t), e && (i.color = e), r && (i.alpha = r), this.context.strokeStyle = i, this;
    }
    beginFill(t, e) {
      fn(An, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const r = {};
      return t !== void 0 && (r.color = t), e !== void 0 && (r.alpha = e), this.context.fillStyle = r, this;
    }
    endFill() {
      fn(An, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
      const t = this.context.strokeStyle;
      return (t.width !== qa.defaultStrokeStyle.width || t.color !== qa.defaultStrokeStyle.color || t.alpha !== qa.defaultStrokeStyle.alpha) && this.context.stroke(), this;
    }
    drawCircle(...t) {
      return fn(An, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t);
    }
    drawEllipse(...t) {
      return fn(An, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t);
    }
    drawPolygon(...t) {
      return fn(An, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t);
    }
    drawRect(...t) {
      return fn(An, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t);
    }
    drawRoundedRect(...t) {
      return fn(An, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t);
    }
    drawStar(...t) {
      return fn(An, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t);
    }
  };
  class n7t extends DN {
    constructor(t, e) {
      const { text: r, resolution: i, style: a, anchor: s, width: o, height: l, roundPixels: u, ...c } = t;
      super({
        ...c
      }), this.batched = true, this._resolution = null, this._autoResolution = true, this._didTextUpdate = true, this._styleClass = e, this.text = r ?? "", this.style = a, this.resolution = i ?? null, this.allowChildren = false, this._anchor = new Ii({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), s && (this.anchor = s), this.roundPixels = u ?? false, o !== void 0 && (this.width = o), l !== void 0 && (this.height = l);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    set text(t) {
      t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(t) {
      this._autoResolution = t === null, this._resolution = t, this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(t) {
      var _a2;
      t || (t = {}), (_a2 = this._style) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(t) {
      this._setWidth(t, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(t) {
      this._setHeight(t, this.bounds.height);
    }
    getSize(t) {
      return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t;
    }
    setSize(t, e) {
      typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this.bounds.width), e !== void 0 && this._setHeight(e, this.bounds.height);
    }
    containsPoint(t) {
      const e = this.bounds.width, r = this.bounds.height, i = -e * this.anchor.x;
      let a = 0;
      return t.x >= i && t.x <= i + e && (a = -r * this.anchor.y, t.y >= a && t.y <= a + r);
    }
    onViewUpdate() {
      this.didViewUpdate || (this._didTextUpdate = true), super.onViewUpdate();
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    destroy(t = false) {
      super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t == null ? void 0 : t.style) && this._style.destroy(t), this._style = null, this._text = null;
    }
  }
  function r7t(n, t) {
    let e = n[0] ?? {};
    return (typeof e == "string" || n[1]) && (fn(An, `use new ${t}({ text: "hi!", style }) instead`), e = {
      text: e,
      style: n[1]
    }), e;
  }
  class i7t extends n7t {
    constructor(...t) {
      const e = r7t(t, "Text");
      super(e, hk), this.renderPipeId = "text";
    }
    updateBounds() {
      const t = this._bounds, e = this._anchor, r = e7t.measureText(this._text, this._style), { width: i, height: a } = r;
      t.minX = -e._x * i, t.maxX = t.minX + i, t.minY = -e._y * a, t.maxY = t.minY + a;
    }
  }
  zN = class extends on {
    static create(t) {
      return new zN({
        source: new gs(t)
      });
    }
    resize(t, e, r) {
      return this.source.resize(t, e, r), this;
    }
  };
  Pa.add(wXt, SXt);
  class a7t extends IJ {
    constructor(t) {
      super(t);
      __publicField(this, "app");
      __publicField(this, "graphicsList", []);
      this.app = new xQ();
    }
    async init() {
      await this.app.init({
        canvas: this._canvas,
        width: this._canvas.width,
        height: this._canvas.height,
        backgroundAlpha: 0
      });
    }
    render(t, e, r, i, a, s = 0.6) {
      this.clear();
      const o = this.app.renderer.width, l = this.app.renderer.height, u = new gG(), c = Math.max(Math.round(Math.max(o, l) / 40), 14);
      for (let h = 0; h < r.length; ++h) {
        if (r[h] < s) continue;
        const f = e[i[h]], d = u.get(i[h]), p = (r[h] * 100).toFixed(1);
        let [g, v, m, y] = t.slice(h * 4, (h + 1) * 4);
        [v, y] = [
          v * a[0],
          y * a[0]
        ], [g, m] = [
          g * a[1],
          m * a[1]
        ];
        const x = y - v, b = m - g, _ = new c1();
        _.rect(v, g, x, b).stroke({
          color: d,
          width: 2
        }).fill({
          color: gG.hexToRgba(d, 0.2)
        });
        const w = new i7t({
          text: `${f} - ${p}%`,
          style: {
            fontFamily: "Arial",
            fontSize: c,
            fill: "#ffffff"
          }
        }), S = w.width, I = w.height, T = g - (I + 2);
        _.fill({
          color: parseInt(d.slice(1), 16)
        }).rect(v - 1, T < 0 ? 0 : T, S + 2, I + 2).fill(), w.x = v - 1, w.y = T < 0 ? 0 : T, _.addChild(w), _.eventMode = "static", _.cursor = "pointer", _.on("mousedown", (A) => {
          var _a2;
          (_a2 = this.onSelect) == null ? void 0 : _a2.call(this, A, {
            boxes: t,
            labels: e,
            scores: r,
            classes: i,
            ratios: a,
            canvas: this.app.canvas
          });
        }), this.app.stage.addChild(_), this.graphicsList.push(_);
      }
    }
    capture(t) {
      const e = t.getContext("2d");
      return new Promise((r) => {
        const i = zN.create({
          width: this.app.canvas.width,
          height: this.app.canvas.height
        });
        this.app.ticker.addOnce(() => {
          this.app.renderer.render(this.app.stage, {
            renderTexture: i
          });
          const a = new cd(i);
          e.drawImage(this.app.renderer.extract.canvas(a), 0, 0, t.width, t.height), r();
        });
      });
    }
    clear() {
      this.app.stage.removeChildren(), this.graphicsList.length = 0;
    }
    dispose() {
      this.clear(), this.app.destroy(true, {
        children: true,
        texture: true
      });
    }
  }
  function b4(n, t) {
    switch (n) {
      case "fabric":
        return new _Xt(t);
      case "pixi":
        return new a7t(t);
      default:
        throw new Error(`Unsupported renderer type: ${n}`);
    }
  }
  const ju = new bXt();
  class s7t {
    constructor(t, e) {
      __publicField(this, "labels");
      __publicField(this, "modelJson");
      __publicField(this, "loaded", false);
      __publicField(this, "inputShape");
      __publicField(this, "frameRate");
      __publicField(this, "renderer");
      __publicField(this, "detectState", false);
      this.labels = t.labels, this.modelJson = t.modelJson, (e == null ? void 0 : e.outputCanvas) && (this.renderer = b4("pixi", e.outputCanvas));
    }
    get numClass() {
      return this.labels.length;
    }
    async setRenderer(t, e, r) {
      const i = b4("pixi", e);
      await i.init(), this.renderer = i, this.renderer.onSelect = async (a, s) => {
        const [o, l, u] = this.inputShape, { canvas: c, ...h } = s, f = await this.capture(t, c);
        r({
          image: f,
          ...h,
          modelSize: [
            l,
            u
          ]
        });
      };
    }
    async capture(t, e) {
      var _a2;
      const r = document.createElement("canvas"), i = r.getContext("2d");
      return r.width = e.width, r.height = e.height, i.drawImage(t, 0, 0, r.width, r.height), await ((_a2 = this.renderer) == null ? void 0 : _a2.capture(r)), r.toDataURL();
    }
    async loadModel(t) {
      return new Promise((e, r) => {
        ju.postMessage({
          cmd: ng.loadModel,
          data: {
            model: this.modelJson,
            labels: this.labels
          }
        }), ju.onmessage = (i) => {
          var _a2;
          i.data.cmd === "loadModel" && ((_a2 = t == null ? void 0 : t.onProgress) == null ? void 0 : _a2.call(t, i.data.percent), i.data.percent === 100 && i.data.inputShape && (this.inputShape = i.data.inputShape, this.loaded = true, e(true)));
        };
      });
    }
    async detect(t, e) {
      return new Promise((r, i) => {
        ju.postMessage({
          cmd: ng.detect,
          data: {
            source: t,
            options: e
          }
        }), ju.onmessage = (a) => {
          r(a.data);
        };
      });
    }
    testRun() {
      return new Promise((t, e) => {
        this.inputShape && (ju.postMessage({
          cmd: ng.testRun
        }), ju.onmessage = (r) => {
          r.data ? t(r.data) : e(new Error("Test run failed"));
        });
      });
    }
    detectVideo(t, e = {
      once: false,
      scoreThreshold: 0.6
    }) {
      const r = async () => {
        var _a2, _b2, _c2, _d2, _e2, _f2;
        if (!this.detectState || this.loaded == null) {
          (_a2 = this.renderer) == null ? void 0 : _a2.clear();
          return;
        }
        if (t instanceof HTMLVideoElement && t.videoWidth === 0 && t.srcObject === null) {
          (_b2 = this.renderer) == null ? void 0 : _b2.clear();
          return;
        }
        if (t instanceof HTMLCanvasElement && t.width === 0) {
          (_c2 = this.renderer) == null ? void 0 : _c2.clear();
          return;
        }
        const [i, a] = this.getSourceSize(t), s = this.inputShape[2], o = Math.min(a, s) / a, l = parseInt((a * o).toString(), 10), u = parseInt((i * o).toString(), 10), c = await createImageBitmap(t, {
          resizeWidth: l,
          resizeHeight: u
        }), h = await this.detect(c, {
          scoreThreshold: e.scoreThreshold
        }), [f, d] = h.ratios;
        if (h.ratios = [
          f / o,
          d / o
        ], (_d2 = this.renderer) == null ? void 0 : _d2.render(h.boxes, h.labels, h.scores, h.classes, h.ratios, e.scoreThreshold), h.boxes.length && ((_e2 = e.onOutput) == null ? void 0 : _e2.call(e, h)), e.once && h.boxes.length) {
          (_f2 = this.renderer) == null ? void 0 : _f2.clear();
          return;
        }
        this.frameRate !== void 0 && this.frameRate !== 0 ? setTimeout(r, 1e3 / this.frameRate) : requestAnimationFrame(r);
      };
      this.detectState = true, r();
    }
    stop() {
      this.detectState = false;
    }
    dispose() {
      var _a2;
      ju.postMessage({
        cmd: ng.disposeModel
      }), (_a2 = this.renderer) == null ? void 0 : _a2.dispose();
    }
    getSourceSize(t) {
      return t instanceof HTMLVideoElement ? [
        t.videoHeight,
        t.videoWidth
      ] : [
        t.height,
        t.width
      ];
    }
  }
  const _Ac = class _Ac {
    constructor() {
      __publicField(this, "ready", false);
      __publicField(this, "model");
      __publicField(this, "modelName", "");
      __publicField(this, "loadingModel", false);
      __publicField(this, "loadingModelProgress", 0);
    }
    static getInstance() {
      return _Ac._instance || (_Ac._instance = new _Ac()), _Ac._instance;
    }
    async init() {
      if (this.ready) return true;
      try {
        return await oCt("webgl"), await lCt(), this.ready = true, true;
      } catch {
        return false;
      }
    }
    async loadGraphModel(t, e) {
      await this.init(), this.model && (this.model.dispose(), this.model = null);
      const r = `${t}/model.json`, i = `${t}/metadata.yaml`, a = await (await fetch(i)).text(), s = dSt.load(a), o = Object.values(s.names);
      if (!o) {
        console.error("No Labels Fetched");
        return;
      }
      return this.model = new s7t({
        modelJson: r,
        labels: o
      }), await this.model.loadModel({
        onProgress: (l) => {
          this.loadingModel = true, this.loadingModelProgress = Math.round(l), e(this.loadingModelProgress);
        }
      }), this.loadingModel = false, this.loadingModelProgress = 100, e(this.loadingModelProgress), this.modelName = t, this.model;
    }
    testRun() {
      var _a2;
      return (_a2 = this.model) == null ? void 0 : _a2.testRun();
    }
  };
  __publicField(_Ac, "_instance");
  let Ac = _Ac;
  const _4 = Ac.getInstance(), o7t = gW("video-detect", {
    state: () => ({
      loadedModel: "",
      loadState: {
        loading: false,
        progress: 0
      }
    }),
    actions: {
      async loadModel(n) {
        await _4.loadGraphModel(n, (t) => {
          t === 100 ? this.loadState.progress = t : (this.loadState.loading = true, this.loadState.progress = t);
        }), await _4.testRun(), this.loadState.loading = false, this.loadedModel = n;
      }
    }
  }), l7t = (n, t, e) => {
    const r = n[t];
    return r ? typeof r == "function" ? r() : Promise.resolve(r) : new Promise((i, a) => {
      (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(a.bind(null, new Error("Unknown variable dynamic import: " + t + (t.split("/").length !== e ? ". Note that variables only represent file names one level deep." : ""))));
    });
  };
  const h1 = typeof window < "u", yu = (n, t = false) => t ? Symbol.for(n) : Symbol(n), u7t = (n, t, e) => c7t({
    l: n,
    k: t,
    s: e
  }), c7t = (n) => JSON.stringify(n).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), Wn = (n) => typeof n == "number" && isFinite(n), h7t = (n) => VN(n) === "[object Date]", fd = (n) => VN(n) === "[object RegExp]", $w = (n) => Ee(n) && Object.keys(n).length === 0, lr = Object.assign, f7t = Object.create, un = (n = null) => f7t(n);
  let w4;
  const kc = () => w4 || (w4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : un());
  function S4(n) {
    return n.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const d7t = Object.prototype.hasOwnProperty;
  function Ja(n, t) {
    return d7t.call(n, t);
  }
  const qn = Array.isArray, mn = (n) => typeof n == "function", Ot = (n) => typeof n == "string", We = (n) => typeof n == "boolean", Ye = (n) => n !== null && typeof n == "object", p7t = (n) => Ye(n) && mn(n.then) && mn(n.catch), BQ = Object.prototype.toString, VN = (n) => BQ.call(n), Ee = (n) => VN(n) === "[object Object]", g7t = (n) => n == null ? "" : qn(n) || Ee(n) && n.toString === BQ ? JSON.stringify(n, null, 2) : String(n);
  function GN(n, t = "") {
    return n.reduce((e, r, i) => i === 0 ? e + r : e + t + r, "");
  }
  function v7t(n, t) {
    typeof console < "u" && (console.warn("[intlify] " + n), t && console.warn(t.stack));
  }
  const Y0 = (n) => !Ye(n) || qn(n);
  function Px(n, t) {
    if (Y0(n) || Y0(t)) throw new Error("Invalid value");
    const e = [
      {
        src: n,
        des: t
      }
    ];
    for (; e.length; ) {
      const { src: r, des: i } = e.pop();
      Object.keys(r).forEach((a) => {
        a !== "__proto__" && (Ye(r[a]) && !Ye(i[a]) && (i[a] = Array.isArray(r[a]) ? [] : un()), Y0(i[a]) || Y0(r[a]) ? i[a] = r[a] : e.push({
          src: r[a],
          des: i[a]
        }));
      });
    }
  }
  function m7t(n, t, e) {
    return {
      line: n,
      column: t,
      offset: e
    };
  }
  function fk(n, t, e) {
    return {
      start: n,
      end: t
    };
  }
  const tn = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14
  }, y7t = 17;
  function Ow(n, t, e = {}) {
    const { domain: r, messages: i, args: a } = e, s = n, o = new SyntaxError(String(s));
    return o.code = n, t && (o.location = t), o.domain = r, o;
  }
  function x7t(n) {
    throw n;
  }
  const xo = " ", b7t = "\r", ni = `
`, _7t = "\u2028", w7t = "\u2029";
  function S7t(n) {
    const t = n;
    let e = 0, r = 1, i = 1, a = 0;
    const s = (S) => t[S] === b7t && t[S + 1] === ni, o = (S) => t[S] === ni, l = (S) => t[S] === w7t, u = (S) => t[S] === _7t, c = (S) => s(S) || o(S) || l(S) || u(S), h = () => e, f = () => r, d = () => i, p = () => a, g = (S) => s(S) || l(S) || u(S) ? ni : t[S], v = () => g(e), m = () => g(e + a);
    function y() {
      return a = 0, c(e) && (r++, i = 0), s(e) && e++, e++, i++, t[e];
    }
    function x() {
      return s(e + a) && a++, a++, t[e + a];
    }
    function b() {
      e = 0, r = 1, i = 1, a = 0;
    }
    function _(S = 0) {
      a = S;
    }
    function w() {
      const S = e + a;
      for (; S !== e; ) y();
      a = 0;
    }
    return {
      index: h,
      line: f,
      column: d,
      peekOffset: p,
      charAt: g,
      currentChar: v,
      currentPeek: m,
      next: y,
      peek: x,
      reset: b,
      resetPeek: _,
      skipToPeek: w
    };
  }
  const gl = void 0, C7t = ".", C4 = "'", T7t = "tokenizer";
  function I7t(n, t = {}) {
    const e = t.location !== false, r = S7t(n), i = () => r.index(), a = () => m7t(r.line(), r.column(), r.index()), s = a(), o = i(), l = {
      currentType: 13,
      offset: o,
      startLoc: s,
      endLoc: s,
      lastType: 13,
      lastOffset: o,
      lastStartLoc: s,
      lastEndLoc: s,
      braceNest: 0,
      inLinked: false,
      text: ""
    }, u = () => l, { onError: c } = t;
    function h(G, H, dt, ...Mt) {
      const Ae = u();
      if (H.column += dt, H.offset += dt, c) {
        const ie = e ? fk(Ae.startLoc, H) : null, st = Ow(G, ie, {
          domain: T7t,
          args: Mt
        });
        c(st);
      }
    }
    function f(G, H, dt) {
      G.endLoc = a(), G.currentType = H;
      const Mt = {
        type: H
      };
      return e && (Mt.loc = fk(G.startLoc, G.endLoc)), dt != null && (Mt.value = dt), Mt;
    }
    const d = (G) => f(G, 13);
    function p(G, H) {
      return G.currentChar() === H ? (G.next(), H) : (h(tn.EXPECTED_TOKEN, a(), 0, H), "");
    }
    function g(G) {
      let H = "";
      for (; G.currentPeek() === xo || G.currentPeek() === ni; ) H += G.currentPeek(), G.peek();
      return H;
    }
    function v(G) {
      const H = g(G);
      return G.skipToPeek(), H;
    }
    function m(G) {
      if (G === gl) return false;
      const H = G.charCodeAt(0);
      return H >= 97 && H <= 122 || H >= 65 && H <= 90 || H === 95;
    }
    function y(G) {
      if (G === gl) return false;
      const H = G.charCodeAt(0);
      return H >= 48 && H <= 57;
    }
    function x(G, H) {
      const { currentType: dt } = H;
      if (dt !== 2) return false;
      g(G);
      const Mt = m(G.currentPeek());
      return G.resetPeek(), Mt;
    }
    function b(G, H) {
      const { currentType: dt } = H;
      if (dt !== 2) return false;
      g(G);
      const Mt = G.currentPeek() === "-" ? G.peek() : G.currentPeek(), Ae = y(Mt);
      return G.resetPeek(), Ae;
    }
    function _(G, H) {
      const { currentType: dt } = H;
      if (dt !== 2) return false;
      g(G);
      const Mt = G.currentPeek() === C4;
      return G.resetPeek(), Mt;
    }
    function w(G, H) {
      const { currentType: dt } = H;
      if (dt !== 7) return false;
      g(G);
      const Mt = G.currentPeek() === ".";
      return G.resetPeek(), Mt;
    }
    function S(G, H) {
      const { currentType: dt } = H;
      if (dt !== 8) return false;
      g(G);
      const Mt = m(G.currentPeek());
      return G.resetPeek(), Mt;
    }
    function I(G, H) {
      const { currentType: dt } = H;
      if (!(dt === 7 || dt === 11)) return false;
      g(G);
      const Mt = G.currentPeek() === ":";
      return G.resetPeek(), Mt;
    }
    function T(G, H) {
      const { currentType: dt } = H;
      if (dt !== 9) return false;
      const Mt = () => {
        const ie = G.currentPeek();
        return ie === "{" ? m(G.peek()) : ie === "@" || ie === "|" || ie === ":" || ie === "." || ie === xo || !ie ? false : ie === ni ? (G.peek(), Mt()) : C(G, false);
      }, Ae = Mt();
      return G.resetPeek(), Ae;
    }
    function A(G) {
      g(G);
      const H = G.currentPeek() === "|";
      return G.resetPeek(), H;
    }
    function C(G, H = true) {
      const dt = (Ae = false, ie = "") => {
        const st = G.currentPeek();
        return st === "{" || st === "@" || !st ? Ae : st === "|" ? !(ie === xo || ie === ni) : st === xo ? (G.peek(), dt(true, xo)) : st === ni ? (G.peek(), dt(true, ni)) : true;
      }, Mt = dt();
      return H && G.resetPeek(), Mt;
    }
    function D(G, H) {
      const dt = G.currentChar();
      return dt === gl ? gl : H(dt) ? (G.next(), dt) : null;
    }
    function E(G) {
      const H = G.charCodeAt(0);
      return H >= 97 && H <= 122 || H >= 65 && H <= 90 || H >= 48 && H <= 57 || H === 95 || H === 36;
    }
    function M(G) {
      return D(G, E);
    }
    function L(G) {
      const H = G.charCodeAt(0);
      return H >= 97 && H <= 122 || H >= 65 && H <= 90 || H >= 48 && H <= 57 || H === 95 || H === 36 || H === 45;
    }
    function k(G) {
      return D(G, L);
    }
    function N(G) {
      const H = G.charCodeAt(0);
      return H >= 48 && H <= 57;
    }
    function R(G) {
      return D(G, N);
    }
    function $(G) {
      const H = G.charCodeAt(0);
      return H >= 48 && H <= 57 || H >= 65 && H <= 70 || H >= 97 && H <= 102;
    }
    function O(G) {
      return D(G, $);
    }
    function F(G) {
      let H = "", dt = "";
      for (; H = R(G); ) dt += H;
      return dt;
    }
    function z(G) {
      let H = "";
      for (; ; ) {
        const dt = G.currentChar();
        if (dt === "{" || dt === "}" || dt === "@" || dt === "|" || !dt) break;
        if (dt === xo || dt === ni) if (C(G)) H += dt, G.next();
        else {
          if (A(G)) break;
          H += dt, G.next();
        }
        else H += dt, G.next();
      }
      return H;
    }
    function V(G) {
      v(G);
      let H = "", dt = "";
      for (; H = k(G); ) dt += H;
      return G.currentChar() === gl && h(tn.UNTERMINATED_CLOSING_BRACE, a(), 0), dt;
    }
    function U(G) {
      v(G);
      let H = "";
      return G.currentChar() === "-" ? (G.next(), H += `-${F(G)}`) : H += F(G), G.currentChar() === gl && h(tn.UNTERMINATED_CLOSING_BRACE, a(), 0), H;
    }
    function X(G) {
      return G !== C4 && G !== ni;
    }
    function at(G) {
      v(G), p(G, "'");
      let H = "", dt = "";
      for (; H = D(G, X); ) H === "\\" ? dt += pt(G) : dt += H;
      const Mt = G.currentChar();
      return Mt === ni || Mt === gl ? (h(tn.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, a(), 0), Mt === ni && (G.next(), p(G, "'")), dt) : (p(G, "'"), dt);
    }
    function pt(G) {
      const H = G.currentChar();
      switch (H) {
        case "\\":
        case "'":
          return G.next(), `\\${H}`;
        case "u":
          return it(G, H, 4);
        case "U":
          return it(G, H, 6);
        default:
          return h(tn.UNKNOWN_ESCAPE_SEQUENCE, a(), 0, H), "";
      }
    }
    function it(G, H, dt) {
      p(G, H);
      let Mt = "";
      for (let Ae = 0; Ae < dt; Ae++) {
        const ie = O(G);
        if (!ie) {
          h(tn.INVALID_UNICODE_ESCAPE_SEQUENCE, a(), 0, `\\${H}${Mt}${G.currentChar()}`);
          break;
        }
        Mt += ie;
      }
      return `\\${H}${Mt}`;
    }
    function et(G) {
      return G !== "{" && G !== "}" && G !== xo && G !== ni;
    }
    function ft(G) {
      v(G);
      let H = "", dt = "";
      for (; H = D(G, et); ) dt += H;
      return dt;
    }
    function ut(G) {
      let H = "", dt = "";
      for (; H = M(G); ) dt += H;
      return dt;
    }
    function gt(G) {
      const H = (dt) => {
        const Mt = G.currentChar();
        return Mt === "{" || Mt === "@" || Mt === "|" || Mt === "(" || Mt === ")" || !Mt || Mt === xo ? dt : (dt += Mt, G.next(), H(dt));
      };
      return H("");
    }
    function kt(G) {
      v(G);
      const H = p(G, "|");
      return v(G), H;
    }
    function At(G, H) {
      let dt = null;
      switch (G.currentChar()) {
        case "{":
          return H.braceNest >= 1 && h(tn.NOT_ALLOW_NEST_PLACEHOLDER, a(), 0), G.next(), dt = f(H, 2, "{"), v(G), H.braceNest++, dt;
        case "}":
          return H.braceNest > 0 && H.currentType === 2 && h(tn.EMPTY_PLACEHOLDER, a(), 0), G.next(), dt = f(H, 3, "}"), H.braceNest--, H.braceNest > 0 && v(G), H.inLinked && H.braceNest === 0 && (H.inLinked = false), dt;
        case "@":
          return H.braceNest > 0 && h(tn.UNTERMINATED_CLOSING_BRACE, a(), 0), dt = mt(G, H) || d(H), H.braceNest = 0, dt;
        default: {
          let Ae = true, ie = true, st = true;
          if (A(G)) return H.braceNest > 0 && h(tn.UNTERMINATED_CLOSING_BRACE, a(), 0), dt = f(H, 1, kt(G)), H.braceNest = 0, H.inLinked = false, dt;
          if (H.braceNest > 0 && (H.currentType === 4 || H.currentType === 5 || H.currentType === 6)) return h(tn.UNTERMINATED_CLOSING_BRACE, a(), 0), H.braceNest = 0, _t(G, H);
          if (Ae = x(G, H)) return dt = f(H, 4, V(G)), v(G), dt;
          if (ie = b(G, H)) return dt = f(H, 5, U(G)), v(G), dt;
          if (st = _(G, H)) return dt = f(H, 6, at(G)), v(G), dt;
          if (!Ae && !ie && !st) return dt = f(H, 12, ft(G)), h(tn.INVALID_TOKEN_IN_PLACEHOLDER, a(), 0, dt.value), v(G), dt;
          break;
        }
      }
      return dt;
    }
    function mt(G, H) {
      const { currentType: dt } = H;
      let Mt = null;
      const Ae = G.currentChar();
      switch ((dt === 7 || dt === 8 || dt === 11 || dt === 9) && (Ae === ni || Ae === xo) && h(tn.INVALID_LINKED_FORMAT, a(), 0), Ae) {
        case "@":
          return G.next(), Mt = f(H, 7, "@"), H.inLinked = true, Mt;
        case ".":
          return v(G), G.next(), f(H, 8, ".");
        case ":":
          return v(G), G.next(), f(H, 9, ":");
        default:
          return A(G) ? (Mt = f(H, 1, kt(G)), H.braceNest = 0, H.inLinked = false, Mt) : w(G, H) || I(G, H) ? (v(G), mt(G, H)) : S(G, H) ? (v(G), f(H, 11, ut(G))) : T(G, H) ? (v(G), Ae === "{" ? At(G, H) || Mt : f(H, 10, gt(G))) : (dt === 7 && h(tn.INVALID_LINKED_FORMAT, a(), 0), H.braceNest = 0, H.inLinked = false, _t(G, H));
      }
    }
    function _t(G, H) {
      let dt = {
        type: 13
      };
      if (H.braceNest > 0) return At(G, H) || d(H);
      if (H.inLinked) return mt(G, H) || d(H);
      switch (G.currentChar()) {
        case "{":
          return At(G, H) || d(H);
        case "}":
          return h(tn.UNBALANCED_CLOSING_BRACE, a(), 0), G.next(), f(H, 3, "}");
        case "@":
          return mt(G, H) || d(H);
        default: {
          if (A(G)) return dt = f(H, 1, kt(G)), H.braceNest = 0, H.inLinked = false, dt;
          if (C(G)) return f(H, 0, z(G));
          break;
        }
      }
      return dt;
    }
    function ee() {
      const { currentType: G, offset: H, startLoc: dt, endLoc: Mt } = l;
      return l.lastType = G, l.lastOffset = H, l.lastStartLoc = dt, l.lastEndLoc = Mt, l.offset = i(), l.startLoc = a(), r.currentChar() === gl ? f(l, 13) : _t(r, l);
    }
    return {
      nextToken: ee,
      currentOffset: i,
      currentPosition: a,
      context: u
    };
  }
  const A7t = "parser", k7t = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function D7t(n, t, e) {
    switch (n) {
      case "\\\\":
        return "\\";
      case "\\'":
        return "'";
      default: {
        const r = parseInt(t || e, 16);
        return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "\uFFFD";
      }
    }
  }
  function E7t(n = {}) {
    const t = n.location !== false, { onError: e } = n;
    function r(m, y, x, b, ..._) {
      const w = m.currentPosition();
      if (w.offset += b, w.column += b, e) {
        const S = t ? fk(x, w) : null, I = Ow(y, S, {
          domain: A7t,
          args: _
        });
        e(I);
      }
    }
    function i(m, y, x) {
      const b = {
        type: m
      };
      return t && (b.start = y, b.end = y, b.loc = {
        start: x,
        end: x
      }), b;
    }
    function a(m, y, x, b) {
      t && (m.end = y, m.loc && (m.loc.end = x));
    }
    function s(m, y) {
      const x = m.context(), b = i(3, x.offset, x.startLoc);
      return b.value = y, a(b, m.currentOffset(), m.currentPosition()), b;
    }
    function o(m, y) {
      const x = m.context(), { lastOffset: b, lastStartLoc: _ } = x, w = i(5, b, _);
      return w.index = parseInt(y, 10), m.nextToken(), a(w, m.currentOffset(), m.currentPosition()), w;
    }
    function l(m, y) {
      const x = m.context(), { lastOffset: b, lastStartLoc: _ } = x, w = i(4, b, _);
      return w.key = y, m.nextToken(), a(w, m.currentOffset(), m.currentPosition()), w;
    }
    function u(m, y) {
      const x = m.context(), { lastOffset: b, lastStartLoc: _ } = x, w = i(9, b, _);
      return w.value = y.replace(k7t, D7t), m.nextToken(), a(w, m.currentOffset(), m.currentPosition()), w;
    }
    function c(m) {
      const y = m.nextToken(), x = m.context(), { lastOffset: b, lastStartLoc: _ } = x, w = i(8, b, _);
      return y.type !== 11 ? (r(m, tn.UNEXPECTED_EMPTY_LINKED_MODIFIER, x.lastStartLoc, 0), w.value = "", a(w, b, _), {
        nextConsumeToken: y,
        node: w
      }) : (y.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, Cs(y)), w.value = y.value || "", a(w, m.currentOffset(), m.currentPosition()), {
        node: w
      });
    }
    function h(m, y) {
      const x = m.context(), b = i(7, x.offset, x.startLoc);
      return b.value = y, a(b, m.currentOffset(), m.currentPosition()), b;
    }
    function f(m) {
      const y = m.context(), x = i(6, y.offset, y.startLoc);
      let b = m.nextToken();
      if (b.type === 8) {
        const _ = c(m);
        x.modifier = _.node, b = _.nextConsumeToken || m.nextToken();
      }
      switch (b.type !== 9 && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(b)), b = m.nextToken(), b.type === 2 && (b = m.nextToken()), b.type) {
        case 10:
          b.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(b)), x.key = h(m, b.value || "");
          break;
        case 4:
          b.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(b)), x.key = l(m, b.value || "");
          break;
        case 5:
          b.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(b)), x.key = o(m, b.value || "");
          break;
        case 6:
          b.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(b)), x.key = u(m, b.value || "");
          break;
        default: {
          r(m, tn.UNEXPECTED_EMPTY_LINKED_KEY, y.lastStartLoc, 0);
          const _ = m.context(), w = i(7, _.offset, _.startLoc);
          return w.value = "", a(w, _.offset, _.startLoc), x.key = w, a(x, _.offset, _.startLoc), {
            nextConsumeToken: b,
            node: x
          };
        }
      }
      return a(x, m.currentOffset(), m.currentPosition()), {
        node: x
      };
    }
    function d(m) {
      const y = m.context(), x = y.currentType === 1 ? m.currentOffset() : y.offset, b = y.currentType === 1 ? y.endLoc : y.startLoc, _ = i(2, x, b);
      _.items = [];
      let w = null;
      do {
        const T = w || m.nextToken();
        switch (w = null, T.type) {
          case 0:
            T.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(T)), _.items.push(s(m, T.value || ""));
            break;
          case 5:
            T.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(T)), _.items.push(o(m, T.value || ""));
            break;
          case 4:
            T.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(T)), _.items.push(l(m, T.value || ""));
            break;
          case 6:
            T.value == null && r(m, tn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Cs(T)), _.items.push(u(m, T.value || ""));
            break;
          case 7: {
            const A = f(m);
            _.items.push(A.node), w = A.nextConsumeToken || null;
            break;
          }
        }
      } while (y.currentType !== 13 && y.currentType !== 1);
      const S = y.currentType === 1 ? y.lastOffset : m.currentOffset(), I = y.currentType === 1 ? y.lastEndLoc : m.currentPosition();
      return a(_, S, I), _;
    }
    function p(m, y, x, b) {
      const _ = m.context();
      let w = b.items.length === 0;
      const S = i(1, y, x);
      S.cases = [], S.cases.push(b);
      do {
        const I = d(m);
        w || (w = I.items.length === 0), S.cases.push(I);
      } while (_.currentType !== 13);
      return w && r(m, tn.MUST_HAVE_MESSAGES_IN_PLURAL, x, 0), a(S, m.currentOffset(), m.currentPosition()), S;
    }
    function g(m) {
      const y = m.context(), { offset: x, startLoc: b } = y, _ = d(m);
      return y.currentType === 13 ? _ : p(m, x, b, _);
    }
    function v(m) {
      const y = I7t(m, lr({}, n)), x = y.context(), b = i(0, x.offset, x.startLoc);
      return t && b.loc && (b.loc.source = m), b.body = g(y), n.onCacheKey && (b.cacheKey = n.onCacheKey(m)), x.currentType !== 13 && r(y, tn.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, m[x.offset] || ""), a(b, y.currentOffset(), y.currentPosition()), b;
    }
    return {
      parse: v
    };
  }
  function Cs(n) {
    if (n.type === 13) return "EOF";
    const t = (n.value || "").replace(/\r?\n/gu, "\\n");
    return t.length > 10 ? t.slice(0, 9) + "\u2026" : t;
  }
  function M7t(n, t = {}) {
    const e = {
      ast: n,
      helpers: /* @__PURE__ */ new Set()
    };
    return {
      context: () => e,
      helper: (a) => (e.helpers.add(a), a)
    };
  }
  function T4(n, t) {
    for (let e = 0; e < n.length; e++) WN(n[e], t);
  }
  function WN(n, t) {
    switch (n.type) {
      case 1:
        T4(n.cases, t), t.helper("plural");
        break;
      case 2:
        T4(n.items, t);
        break;
      case 6: {
        WN(n.key, t), t.helper("linked"), t.helper("type");
        break;
      }
      case 5:
        t.helper("interpolate"), t.helper("list");
        break;
      case 4:
        t.helper("interpolate"), t.helper("named");
        break;
    }
  }
  function R7t(n, t = {}) {
    const e = M7t(n);
    e.helper("normalize"), n.body && WN(n.body, e);
    const r = e.context();
    n.helpers = Array.from(r.helpers);
  }
  function N7t(n) {
    const t = n.body;
    return t.type === 2 ? I4(t) : t.cases.forEach((e) => I4(e)), n;
  }
  function I4(n) {
    if (n.items.length === 1) {
      const t = n.items[0];
      (t.type === 3 || t.type === 9) && (n.static = t.value, delete t.value);
    } else {
      const t = [];
      for (let e = 0; e < n.items.length; e++) {
        const r = n.items[e];
        if (!(r.type === 3 || r.type === 9) || r.value == null) break;
        t.push(r.value);
      }
      if (t.length === n.items.length) {
        n.static = GN(t);
        for (let e = 0; e < n.items.length; e++) {
          const r = n.items[e];
          (r.type === 3 || r.type === 9) && delete r.value;
        }
      }
    }
  }
  function _f(n) {
    switch (n.t = n.type, n.type) {
      case 0: {
        const t = n;
        _f(t.body), t.b = t.body, delete t.body;
        break;
      }
      case 1: {
        const t = n, e = t.cases;
        for (let r = 0; r < e.length; r++) _f(e[r]);
        t.c = e, delete t.cases;
        break;
      }
      case 2: {
        const t = n, e = t.items;
        for (let r = 0; r < e.length; r++) _f(e[r]);
        t.i = e, delete t.items, t.static && (t.s = t.static, delete t.static);
        break;
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const t = n;
        t.value && (t.v = t.value, delete t.value);
        break;
      }
      case 6: {
        const t = n;
        _f(t.key), t.k = t.key, delete t.key, t.modifier && (_f(t.modifier), t.m = t.modifier, delete t.modifier);
        break;
      }
      case 5: {
        const t = n;
        t.i = t.index, delete t.index;
        break;
      }
      case 4: {
        const t = n;
        t.k = t.key, delete t.key;
        break;
      }
    }
    delete n.type;
  }
  function L7t(n, t) {
    const { filename: e, breakLineCode: r, needIndent: i } = t, a = t.location !== false, s = {
      filename: e,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: r,
      needIndent: i,
      indentLevel: 0
    };
    a && n.loc && (s.source = n.loc.source);
    const o = () => s;
    function l(g, v) {
      s.code += g;
    }
    function u(g, v = true) {
      const m = v ? r : "";
      l(i ? m + "  ".repeat(g) : m);
    }
    function c(g = true) {
      const v = ++s.indentLevel;
      g && u(v);
    }
    function h(g = true) {
      const v = --s.indentLevel;
      g && u(v);
    }
    function f() {
      u(s.indentLevel);
    }
    return {
      context: o,
      push: l,
      indent: c,
      deindent: h,
      newline: f,
      helper: (g) => `_${g}`,
      needIndent: () => s.needIndent
    };
  }
  function P7t(n, t) {
    const { helper: e } = n;
    n.push(`${e("linked")}(`), dd(n, t.key), t.modifier ? (n.push(", "), dd(n, t.modifier), n.push(", _type")) : n.push(", undefined, _type"), n.push(")");
  }
  function $7t(n, t) {
    const { helper: e, needIndent: r } = n;
    n.push(`${e("normalize")}([`), n.indent(r());
    const i = t.items.length;
    for (let a = 0; a < i && (dd(n, t.items[a]), a !== i - 1); a++) n.push(", ");
    n.deindent(r()), n.push("])");
  }
  function O7t(n, t) {
    const { helper: e, needIndent: r } = n;
    if (t.cases.length > 1) {
      n.push(`${e("plural")}([`), n.indent(r());
      const i = t.cases.length;
      for (let a = 0; a < i && (dd(n, t.cases[a]), a !== i - 1); a++) n.push(", ");
      n.deindent(r()), n.push("])");
    }
  }
  function F7t(n, t) {
    t.body ? dd(n, t.body) : n.push("null");
  }
  function dd(n, t) {
    const { helper: e } = n;
    switch (t.type) {
      case 0:
        F7t(n, t);
        break;
      case 1:
        O7t(n, t);
        break;
      case 2:
        $7t(n, t);
        break;
      case 6:
        P7t(n, t);
        break;
      case 8:
        n.push(JSON.stringify(t.value), t);
        break;
      case 7:
        n.push(JSON.stringify(t.value), t);
        break;
      case 5:
        n.push(`${e("interpolate")}(${e("list")}(${t.index}))`, t);
        break;
      case 4:
        n.push(`${e("interpolate")}(${e("named")}(${JSON.stringify(t.key)}))`, t);
        break;
      case 9:
        n.push(JSON.stringify(t.value), t);
        break;
      case 3:
        n.push(JSON.stringify(t.value), t);
        break;
    }
  }
  const B7t = (n, t = {}) => {
    const e = Ot(t.mode) ? t.mode : "normal", r = Ot(t.filename) ? t.filename : "message.intl";
    t.sourceMap;
    const i = t.breakLineCode != null ? t.breakLineCode : e === "arrow" ? ";" : `
`, a = t.needIndent ? t.needIndent : e !== "arrow", s = n.helpers || [], o = L7t(n, {
      filename: r,
      breakLineCode: i,
      needIndent: a
    });
    o.push(e === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), o.indent(a), s.length > 0 && (o.push(`const { ${GN(s.map((c) => `${c}: _${c}`), ", ")} } = ctx`), o.newline()), o.push("return "), dd(o, n), o.deindent(a), o.push("}"), delete n.helpers;
    const { code: l, map: u } = o.context();
    return {
      ast: n,
      code: l,
      map: u ? u.toJSON() : void 0
    };
  };
  function z7t(n, t = {}) {
    const e = lr({}, t), r = !!e.jit, i = !!e.minify, a = e.optimize == null ? true : e.optimize, o = E7t(e).parse(n);
    return r ? (a && N7t(o), i && _f(o), {
      ast: o,
      code: ""
    }) : (R7t(o, e), B7t(o, e));
  }
  function V7t() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (kc().__INTLIFY_PROD_DEVTOOLS__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (kc().__INTLIFY_DROP_MESSAGE_COMPILER__ = false);
  }
  function iI(n) {
    return (e) => G7t(e, n);
  }
  function G7t(n, t) {
    const e = U7t(t);
    if (e == null) throw Tv(0);
    if (UN(e) === 1) {
      const a = X7t(e);
      return n.plural(a.reduce((s, o) => [
        ...s,
        A4(n, o)
      ], []));
    } else return A4(n, e);
  }
  const W7t = [
    "b",
    "body"
  ];
  function U7t(n) {
    return xu(n, W7t);
  }
  const H7t = [
    "c",
    "cases"
  ];
  function X7t(n) {
    return xu(n, H7t, []);
  }
  function A4(n, t) {
    const e = q7t(t);
    if (e != null) return n.type === "text" ? e : n.normalize([
      e
    ]);
    {
      const r = K7t(t).reduce((i, a) => [
        ...i,
        dk(n, a)
      ], []);
      return n.normalize(r);
    }
  }
  const Y7t = [
    "s",
    "static"
  ];
  function q7t(n) {
    return xu(n, Y7t);
  }
  const j7t = [
    "i",
    "items"
  ];
  function K7t(n) {
    return xu(n, j7t, []);
  }
  function dk(n, t) {
    const e = UN(t);
    switch (e) {
      case 3:
        return q0(t, e);
      case 9:
        return q0(t, e);
      case 4: {
        const r = t;
        if (Ja(r, "k") && r.k) return n.interpolate(n.named(r.k));
        if (Ja(r, "key") && r.key) return n.interpolate(n.named(r.key));
        throw Tv(e);
      }
      case 5: {
        const r = t;
        if (Ja(r, "i") && Wn(r.i)) return n.interpolate(n.list(r.i));
        if (Ja(r, "index") && Wn(r.index)) return n.interpolate(n.list(r.index));
        throw Tv(e);
      }
      case 6: {
        const r = t, i = t9t(r), a = n9t(r);
        return n.linked(dk(n, a), i ? dk(n, i) : void 0, n.type);
      }
      case 7:
        return q0(t, e);
      case 8:
        return q0(t, e);
      default:
        throw new Error(`unhandled node on format message part: ${e}`);
    }
  }
  const Z7t = [
    "t",
    "type"
  ];
  function UN(n) {
    return xu(n, Z7t);
  }
  const J7t = [
    "v",
    "value"
  ];
  function q0(n, t) {
    const e = xu(n, J7t);
    if (e) return e;
    throw Tv(t);
  }
  const Q7t = [
    "m",
    "modifier"
  ];
  function t9t(n) {
    return xu(n, Q7t);
  }
  const e9t = [
    "k",
    "key"
  ];
  function n9t(n) {
    const t = xu(n, e9t);
    if (t) return t;
    throw Tv(6);
  }
  function xu(n, t, e) {
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      if (Ja(n, i) && n[i] != null) return n[i];
    }
    return e;
  }
  function Tv(n) {
    return new Error(`unhandled node type: ${n}`);
  }
  const r9t = (n) => n;
  let j0 = un();
  function pd(n) {
    return Ye(n) && UN(n) === 0 && (Ja(n, "b") || Ja(n, "body"));
  }
  function i9t(n, t = {}) {
    let e = false;
    const r = t.onError || x7t;
    return t.onError = (i) => {
      e = true, r(i);
    }, {
      ...z7t(n, t),
      detectError: e
    };
  }
  function a9t(n, t) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && Ot(n)) {
      We(t.warnHtmlMessage) && t.warnHtmlMessage;
      const r = (t.onCacheKey || r9t)(n), i = j0[r];
      if (i) return i;
      const { ast: a, detectError: s } = i9t(n, {
        ...t,
        location: false,
        jit: true
      }), o = iI(a);
      return s ? o : j0[r] = o;
    } else {
      const e = n.cacheKey;
      if (e) {
        const r = j0[e];
        return r || (j0[e] = iI(n));
      } else return iI(n);
    }
  }
  let Iv = null;
  function s9t(n) {
    Iv = n;
  }
  function o9t(n, t, e) {
    Iv && Iv.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: n,
      version: t,
      meta: e
    });
  }
  const l9t = u9t("function:translate");
  function u9t(n) {
    return (t) => Iv && Iv.emit(n, t);
  }
  const ko = {
    INVALID_ARGUMENT: y7t,
    INVALID_DATE_ARGUMENT: 18,
    INVALID_ISO_DATE_ARGUMENT: 19,
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
    NOT_SUPPORT_LOCALE_TYPE: 23
  }, c9t = 24;
  function Do(n) {
    return Ow(n, null, void 0);
  }
  function HN(n, t) {
    return t.locale != null ? k4(t.locale) : k4(n.locale);
  }
  let aI;
  function k4(n) {
    if (Ot(n)) return n;
    if (mn(n)) {
      if (n.resolvedOnce && aI != null) return aI;
      if (n.constructor.name === "Function") {
        const t = n();
        if (p7t(t)) throw Do(ko.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        return aI = t;
      } else throw Do(ko.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
    } else throw Do(ko.NOT_SUPPORT_LOCALE_TYPE);
  }
  function h9t(n, t, e) {
    return [
      .../* @__PURE__ */ new Set([
        e,
        ...qn(t) ? t : Ye(t) ? Object.keys(t) : Ot(t) ? [
          t
        ] : [
          e
        ]
      ])
    ];
  }
  function zQ(n, t, e) {
    const r = Ot(e) ? e : Av, i = n;
    i.__localeChainCache || (i.__localeChainCache = /* @__PURE__ */ new Map());
    let a = i.__localeChainCache.get(r);
    if (!a) {
      a = [];
      let s = [
        e
      ];
      for (; qn(s); ) s = D4(a, s, t);
      const o = qn(t) || !Ee(t) ? t : t.default ? t.default : null;
      s = Ot(o) ? [
        o
      ] : o, qn(s) && D4(a, s, false), i.__localeChainCache.set(r, a);
    }
    return a;
  }
  function D4(n, t, e) {
    let r = true;
    for (let i = 0; i < t.length && We(r); i++) {
      const a = t[i];
      Ot(a) && (r = f9t(n, t[i], e));
    }
    return r;
  }
  function f9t(n, t, e) {
    let r;
    const i = t.split("-");
    do {
      const a = i.join("-");
      r = d9t(n, a, e), i.splice(-1, 1);
    } while (i.length && r === true);
    return r;
  }
  function d9t(n, t, e) {
    let r = false;
    if (!n.includes(t) && (r = true, t)) {
      r = t[t.length - 1] !== "!";
      const i = t.replace(/!/g, "");
      n.push(i), (qn(e) || Ee(e)) && e[i] && (r = e[i]);
    }
    return r;
  }
  const bu = [];
  bu[0] = {
    w: [
      0
    ],
    i: [
      3,
      0
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  bu[1] = {
    w: [
      1
    ],
    ".": [
      2
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  bu[2] = {
    w: [
      2
    ],
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ]
  };
  bu[3] = {
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ],
    w: [
      1,
      1
    ],
    ".": [
      2,
      1
    ],
    "[": [
      4,
      1
    ],
    o: [
      7,
      1
    ]
  };
  bu[4] = {
    "'": [
      5,
      0
    ],
    '"': [
      6,
      0
    ],
    "[": [
      4,
      2
    ],
    "]": [
      1,
      3
    ],
    o: 8,
    l: [
      4,
      0
    ]
  };
  bu[5] = {
    "'": [
      4,
      0
    ],
    o: 8,
    l: [
      5,
      0
    ]
  };
  bu[6] = {
    '"': [
      4,
      0
    ],
    o: 8,
    l: [
      6,
      0
    ]
  };
  const p9t = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function g9t(n) {
    return p9t.test(n);
  }
  function v9t(n) {
    const t = n.charCodeAt(0), e = n.charCodeAt(n.length - 1);
    return t === e && (t === 34 || t === 39) ? n.slice(1, -1) : n;
  }
  function m9t(n) {
    if (n == null) return "o";
    switch (n.charCodeAt(0)) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return n;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function y9t(n) {
    const t = n.trim();
    return n.charAt(0) === "0" && isNaN(parseInt(n)) ? false : g9t(t) ? v9t(t) : "*" + t;
  }
  function x9t(n) {
    const t = [];
    let e = -1, r = 0, i = 0, a, s, o, l, u, c, h;
    const f = [];
    f[0] = () => {
      s === void 0 ? s = o : s += o;
    }, f[1] = () => {
      s !== void 0 && (t.push(s), s = void 0);
    }, f[2] = () => {
      f[0](), i++;
    }, f[3] = () => {
      if (i > 0) i--, r = 4, f[0]();
      else {
        if (i = 0, s === void 0 || (s = y9t(s), s === false)) return false;
        f[1]();
      }
    };
    function d() {
      const p = n[e + 1];
      if (r === 5 && p === "'" || r === 6 && p === '"') return e++, o = "\\" + p, f[0](), true;
    }
    for (; r !== null; ) if (e++, a = n[e], !(a === "\\" && d())) {
      if (l = m9t(a), h = bu[r], u = h[l] || h.l || 8, u === 8 || (r = u[0], u[1] !== void 0 && (c = f[u[1]], c && (o = a, c() === false)))) return;
      if (r === 7) return t;
    }
  }
  const E4 = /* @__PURE__ */ new Map();
  function b9t(n, t) {
    return Ye(n) ? n[t] : null;
  }
  function _9t(n, t) {
    if (!Ye(n)) return null;
    let e = E4.get(t);
    if (e || (e = x9t(t), e && E4.set(t, e)), !e) return null;
    const r = e.length;
    let i = n, a = 0;
    for (; a < r; ) {
      const s = i[e[a]];
      if (s === void 0 || mn(i)) return null;
      i = s, a++;
    }
    return i;
  }
  const w9t = "11.1.1", Fw = -1, Av = "en-US", M4 = "", R4 = (n) => `${n.charAt(0).toLocaleUpperCase()}${n.substr(1)}`;
  function S9t() {
    return {
      upper: (n, t) => t === "text" && Ot(n) ? n.toUpperCase() : t === "vnode" && Ye(n) && "__v_isVNode" in n ? n.children.toUpperCase() : n,
      lower: (n, t) => t === "text" && Ot(n) ? n.toLowerCase() : t === "vnode" && Ye(n) && "__v_isVNode" in n ? n.children.toLowerCase() : n,
      capitalize: (n, t) => t === "text" && Ot(n) ? R4(n) : t === "vnode" && Ye(n) && "__v_isVNode" in n ? R4(n.children) : n
    };
  }
  let VQ;
  function C9t(n) {
    VQ = n;
  }
  let GQ;
  function T9t(n) {
    GQ = n;
  }
  let WQ;
  function I9t(n) {
    WQ = n;
  }
  let UQ = null;
  const A9t = (n) => {
    UQ = n;
  }, k9t = () => UQ;
  let HQ = null;
  const N4 = (n) => {
    HQ = n;
  }, D9t = () => HQ;
  let L4 = 0;
  function E9t(n = {}) {
    const t = mn(n.onWarn) ? n.onWarn : v7t, e = Ot(n.version) ? n.version : w9t, r = Ot(n.locale) || mn(n.locale) ? n.locale : Av, i = mn(r) ? Av : r, a = qn(n.fallbackLocale) || Ee(n.fallbackLocale) || Ot(n.fallbackLocale) || n.fallbackLocale === false ? n.fallbackLocale : i, s = Ee(n.messages) ? n.messages : sI(i), o = Ee(n.datetimeFormats) ? n.datetimeFormats : sI(i), l = Ee(n.numberFormats) ? n.numberFormats : sI(i), u = lr(un(), n.modifiers, S9t()), c = n.pluralRules || un(), h = mn(n.missing) ? n.missing : null, f = We(n.missingWarn) || fd(n.missingWarn) ? n.missingWarn : true, d = We(n.fallbackWarn) || fd(n.fallbackWarn) ? n.fallbackWarn : true, p = !!n.fallbackFormat, g = !!n.unresolving, v = mn(n.postTranslation) ? n.postTranslation : null, m = Ee(n.processor) ? n.processor : null, y = We(n.warnHtmlMessage) ? n.warnHtmlMessage : true, x = !!n.escapeParameter, b = mn(n.messageCompiler) ? n.messageCompiler : VQ, _ = mn(n.messageResolver) ? n.messageResolver : GQ || b9t, w = mn(n.localeFallbacker) ? n.localeFallbacker : WQ || h9t, S = Ye(n.fallbackContext) ? n.fallbackContext : void 0, I = n, T = Ye(I.__datetimeFormatters) ? I.__datetimeFormatters : /* @__PURE__ */ new Map(), A = Ye(I.__numberFormatters) ? I.__numberFormatters : /* @__PURE__ */ new Map(), C = Ye(I.__meta) ? I.__meta : {};
    L4++;
    const D = {
      version: e,
      cid: L4,
      locale: r,
      fallbackLocale: a,
      messages: s,
      modifiers: u,
      pluralRules: c,
      missing: h,
      missingWarn: f,
      fallbackWarn: d,
      fallbackFormat: p,
      unresolving: g,
      postTranslation: v,
      processor: m,
      warnHtmlMessage: y,
      escapeParameter: x,
      messageCompiler: b,
      messageResolver: _,
      localeFallbacker: w,
      fallbackContext: S,
      onWarn: t,
      __meta: C
    };
    return D.datetimeFormats = o, D.numberFormats = l, D.__datetimeFormatters = T, D.__numberFormatters = A, __INTLIFY_PROD_DEVTOOLS__ && o9t(D, e, C), D;
  }
  const sI = (n) => ({
    [n]: un()
  });
  function XN(n, t, e, r, i) {
    const { missing: a, onWarn: s } = n;
    if (a !== null) {
      const o = a(n, e, t, i);
      return Ot(o) ? o : t;
    } else return t;
  }
  function Pp(n, t, e) {
    const r = n;
    r.__localeChainCache = /* @__PURE__ */ new Map(), n.localeFallbacker(n, e, t);
  }
  function M9t(n, t) {
    return n === t ? false : n.split("-")[0] === t.split("-")[0];
  }
  function R9t(n, t) {
    const e = t.indexOf(n);
    if (e === -1) return false;
    for (let r = e + 1; r < t.length; r++) if (M9t(n, t[r])) return true;
    return false;
  }
  function P4(n, ...t) {
    const { datetimeFormats: e, unresolving: r, fallbackLocale: i, onWarn: a, localeFallbacker: s } = n, { __datetimeFormatters: o } = n, [l, u, c, h] = pk(...t), f = We(c.missingWarn) ? c.missingWarn : n.missingWarn;
    We(c.fallbackWarn) ? c.fallbackWarn : n.fallbackWarn;
    const d = !!c.part, p = HN(n, c), g = s(n, i, p);
    if (!Ot(l) || l === "") return new Intl.DateTimeFormat(p, h).format(u);
    let v = {}, m, y = null;
    const x = "datetime format";
    for (let w = 0; w < g.length && (m = g[w], v = e[m] || {}, y = v[l], !Ee(y)); w++) XN(n, l, m, f, x);
    if (!Ee(y) || !Ot(m)) return r ? Fw : l;
    let b = `${m}__${l}`;
    $w(h) || (b = `${b}__${JSON.stringify(h)}`);
    let _ = o.get(b);
    return _ || (_ = new Intl.DateTimeFormat(m, lr({}, y, h)), o.set(b, _)), d ? _.formatToParts(u) : _.format(u);
  }
  const XQ = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function pk(...n) {
    const [t, e, r, i] = n, a = un();
    let s = un(), o;
    if (Ot(t)) {
      const l = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!l) throw Do(ko.INVALID_ISO_DATE_ARGUMENT);
      const u = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
      o = new Date(u);
      try {
        o.toISOString();
      } catch {
        throw Do(ko.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (h7t(t)) {
      if (isNaN(t.getTime())) throw Do(ko.INVALID_DATE_ARGUMENT);
      o = t;
    } else if (Wn(t)) o = t;
    else throw Do(ko.INVALID_ARGUMENT);
    return Ot(e) ? a.key = e : Ee(e) && Object.keys(e).forEach((l) => {
      XQ.includes(l) ? s[l] = e[l] : a[l] = e[l];
    }), Ot(r) ? a.locale = r : Ee(r) && (s = r), Ee(i) && (s = i), [
      a.key || "",
      o,
      a,
      s
    ];
  }
  function $4(n, t, e) {
    const r = n;
    for (const i in e) {
      const a = `${t}__${i}`;
      r.__datetimeFormatters.has(a) && r.__datetimeFormatters.delete(a);
    }
  }
  function O4(n, ...t) {
    const { numberFormats: e, unresolving: r, fallbackLocale: i, onWarn: a, localeFallbacker: s } = n, { __numberFormatters: o } = n, [l, u, c, h] = gk(...t), f = We(c.missingWarn) ? c.missingWarn : n.missingWarn;
    We(c.fallbackWarn) ? c.fallbackWarn : n.fallbackWarn;
    const d = !!c.part, p = HN(n, c), g = s(n, i, p);
    if (!Ot(l) || l === "") return new Intl.NumberFormat(p, h).format(u);
    let v = {}, m, y = null;
    const x = "number format";
    for (let w = 0; w < g.length && (m = g[w], v = e[m] || {}, y = v[l], !Ee(y)); w++) XN(n, l, m, f, x);
    if (!Ee(y) || !Ot(m)) return r ? Fw : l;
    let b = `${m}__${l}`;
    $w(h) || (b = `${b}__${JSON.stringify(h)}`);
    let _ = o.get(b);
    return _ || (_ = new Intl.NumberFormat(m, lr({}, y, h)), o.set(b, _)), d ? _.formatToParts(u) : _.format(u);
  }
  const YQ = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function gk(...n) {
    const [t, e, r, i] = n, a = un();
    let s = un();
    if (!Wn(t)) throw Do(ko.INVALID_ARGUMENT);
    const o = t;
    return Ot(e) ? a.key = e : Ee(e) && Object.keys(e).forEach((l) => {
      YQ.includes(l) ? s[l] = e[l] : a[l] = e[l];
    }), Ot(r) ? a.locale = r : Ee(r) && (s = r), Ee(i) && (s = i), [
      a.key || "",
      o,
      a,
      s
    ];
  }
  function F4(n, t, e) {
    const r = n;
    for (const i in e) {
      const a = `${t}__${i}`;
      r.__numberFormatters.has(a) && r.__numberFormatters.delete(a);
    }
  }
  const N9t = (n) => n, L9t = (n) => "", P9t = "text", $9t = (n) => n.length === 0 ? "" : GN(n), O9t = g7t;
  function B4(n, t) {
    return n = Math.abs(n), t === 2 ? n ? n > 1 ? 1 : 0 : 1 : n ? Math.min(n, 2) : 0;
  }
  function F9t(n) {
    const t = Wn(n.pluralIndex) ? n.pluralIndex : -1;
    return n.named && (Wn(n.named.count) || Wn(n.named.n)) ? Wn(n.named.count) ? n.named.count : Wn(n.named.n) ? n.named.n : t : t;
  }
  function B9t(n, t) {
    t.count || (t.count = n), t.n || (t.n = n);
  }
  function z9t(n = {}) {
    const t = n.locale, e = F9t(n), r = Ye(n.pluralRules) && Ot(t) && mn(n.pluralRules[t]) ? n.pluralRules[t] : B4, i = Ye(n.pluralRules) && Ot(t) && mn(n.pluralRules[t]) ? B4 : void 0, a = (m) => m[r(e, m.length, i)], s = n.list || [], o = (m) => s[m], l = n.named || un();
    Wn(n.pluralIndex) && B9t(e, l);
    const u = (m) => l[m];
    function c(m, y) {
      const x = mn(n.messages) ? n.messages(m, !!y) : Ye(n.messages) ? n.messages[m] : false;
      return x || (n.parent ? n.parent.message(m) : L9t);
    }
    const h = (m) => n.modifiers ? n.modifiers[m] : N9t, f = Ee(n.processor) && mn(n.processor.normalize) ? n.processor.normalize : $9t, d = Ee(n.processor) && mn(n.processor.interpolate) ? n.processor.interpolate : O9t, p = Ee(n.processor) && Ot(n.processor.type) ? n.processor.type : P9t, v = {
      list: o,
      named: u,
      plural: a,
      linked: (m, ...y) => {
        const [x, b] = y;
        let _ = "text", w = "";
        y.length === 1 ? Ye(x) ? (w = x.modifier || w, _ = x.type || _) : Ot(x) && (w = x || w) : y.length === 2 && (Ot(x) && (w = x || w), Ot(b) && (_ = b || _));
        const S = c(m, true)(v), I = _ === "vnode" && qn(S) && w ? S[0] : S;
        return w ? h(w)(I, _) : I;
      },
      message: c,
      type: p,
      interpolate: d,
      normalize: f,
      values: lr(un(), s, l)
    };
    return v;
  }
  const z4 = () => "", ma = (n) => mn(n);
  function V4(n, ...t) {
    const { fallbackFormat: e, postTranslation: r, unresolving: i, messageCompiler: a, fallbackLocale: s, messages: o } = n, [l, u] = vk(...t), c = We(u.missingWarn) ? u.missingWarn : n.missingWarn, h = We(u.fallbackWarn) ? u.fallbackWarn : n.fallbackWarn, f = We(u.escapeParameter) ? u.escapeParameter : n.escapeParameter, d = !!u.resolvedMessage, p = Ot(u.default) || We(u.default) ? We(u.default) ? a ? l : () => l : u.default : e ? a ? l : () => l : null, g = e || p != null && (Ot(p) || mn(p)), v = HN(n, u);
    f && V9t(u);
    let [m, y, x] = d ? [
      l,
      v,
      o[v] || un()
    ] : qQ(n, l, v, s, h, c), b = m, _ = l;
    if (!d && !(Ot(b) || pd(b) || ma(b)) && g && (b = p, _ = b), !d && (!(Ot(b) || pd(b) || ma(b)) || !Ot(y))) return i ? Fw : l;
    let w = false;
    const S = () => {
      w = true;
    }, I = ma(b) ? b : jQ(n, l, y, b, _, S);
    if (w) return b;
    const T = U9t(n, y, x, u), A = z9t(T), C = G9t(n, I, A), D = r ? r(C, l) : C;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const E = {
        timestamp: Date.now(),
        key: Ot(l) ? l : ma(b) ? b.key : "",
        locale: y || (ma(b) ? b.locale : ""),
        format: Ot(b) ? b : ma(b) ? b.source : "",
        message: D
      };
      E.meta = lr({}, n.__meta, k9t() || {}), l9t(E);
    }
    return D;
  }
  function V9t(n) {
    qn(n.list) ? n.list = n.list.map((t) => Ot(t) ? S4(t) : t) : Ye(n.named) && Object.keys(n.named).forEach((t) => {
      Ot(n.named[t]) && (n.named[t] = S4(n.named[t]));
    });
  }
  function qQ(n, t, e, r, i, a) {
    const { messages: s, onWarn: o, messageResolver: l, localeFallbacker: u } = n, c = u(n, r, e);
    let h = un(), f, d = null;
    const p = "translate";
    for (let g = 0; g < c.length && (f = c[g], h = s[f] || un(), (d = l(h, t)) === null && (d = h[t]), !(Ot(d) || pd(d) || ma(d))); g++) if (!R9t(f, c)) {
      const v = XN(n, t, f, a, p);
      v !== t && (d = v);
    }
    return [
      d,
      f,
      h
    ];
  }
  function jQ(n, t, e, r, i, a) {
    const { messageCompiler: s, warnHtmlMessage: o } = n;
    if (ma(r)) {
      const u = r;
      return u.locale = u.locale || e, u.key = u.key || t, u;
    }
    if (s == null) {
      const u = () => r;
      return u.locale = e, u.key = t, u;
    }
    const l = s(r, W9t(n, e, i, r, o, a));
    return l.locale = e, l.key = t, l.source = r, l;
  }
  function G9t(n, t, e) {
    return t(e);
  }
  function vk(...n) {
    const [t, e, r] = n, i = un();
    if (!Ot(t) && !Wn(t) && !ma(t) && !pd(t)) throw Do(ko.INVALID_ARGUMENT);
    const a = Wn(t) ? String(t) : (ma(t), t);
    return Wn(e) ? i.plural = e : Ot(e) ? i.default = e : Ee(e) && !$w(e) ? i.named = e : qn(e) && (i.list = e), Wn(r) ? i.plural = r : Ot(r) ? i.default = r : Ee(r) && lr(i, r), [
      a,
      i
    ];
  }
  function W9t(n, t, e, r, i, a) {
    return {
      locale: t,
      key: e,
      warnHtmlMessage: i,
      onError: (s) => {
        throw a && a(s), s;
      },
      onCacheKey: (s) => u7t(t, e, s)
    };
  }
  function U9t(n, t, e, r) {
    const { modifiers: i, pluralRules: a, messageResolver: s, fallbackLocale: o, fallbackWarn: l, missingWarn: u, fallbackContext: c } = n, f = {
      locale: t,
      modifiers: i,
      pluralRules: a,
      messages: (d, p) => {
        let g = s(e, d);
        if (g == null && (c || p)) {
          const [, , v] = qQ(c || n, d, t, o, l, u);
          g = s(v, d);
        }
        if (Ot(g) || pd(g)) {
          let v = false;
          const y = jQ(n, d, t, g, d, () => {
            v = true;
          });
          return v ? z4 : y;
        } else return ma(g) ? g : z4;
      }
    };
    return n.processor && (f.processor = n.processor), r.list && (f.list = r.list), r.named && (f.named = r.named), Wn(r.plural) && (f.pluralIndex = r.plural), f;
  }
  V7t();
  const H9t = "11.1.1";
  function X9t() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (kc().__VUE_I18N_FULL_INSTALL__ = true), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (kc().__VUE_I18N_LEGACY_API__ = true), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (kc().__INTLIFY_DROP_MESSAGE_COMPILER__ = false), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (kc().__INTLIFY_PROD_DEVTOOLS__ = false);
  }
  const Bi = {
    UNEXPECTED_RETURN_TYPE: c9t,
    INVALID_ARGUMENT: 25,
    MUST_BE_CALL_SETUP_TOP: 26,
    NOT_INSTALLED: 27,
    REQUIRED_VALUE: 28,
    INVALID_VALUE: 29,
    NOT_INSTALLED_WITH_PROVIDE: 31,
    UNEXPECTED_ERROR: 32
  };
  function Qi(n, ...t) {
    return Ow(n, null, void 0);
  }
  const mk = yu("__translateVNode"), yk = yu("__datetimeParts"), xk = yu("__numberParts"), KQ = yu("__setPluralRules"), ZQ = yu("__injectWithOption"), bk = yu("__dispose");
  function kv(n) {
    if (!Ye(n)) return n;
    for (const t in n) if (Ja(n, t)) if (!t.includes(".")) Ye(n[t]) && kv(n[t]);
    else {
      const e = t.split("."), r = e.length - 1;
      let i = n, a = false;
      for (let s = 0; s < r; s++) {
        if (e[s] in i || (i[e[s]] = un()), !Ye(i[e[s]])) {
          a = true;
          break;
        }
        i = i[e[s]];
      }
      a || (i[e[r]] = n[t], delete n[t]), Ye(i[e[r]]) && kv(i[e[r]]);
    }
    return n;
  }
  function YN(n, t) {
    const { messages: e, __i18n: r, messageResolver: i, flatJson: a } = t, s = Ee(e) ? e : qn(r) ? un() : {
      [n]: un()
    };
    if (qn(r) && r.forEach((o) => {
      if ("locale" in o && "resource" in o) {
        const { locale: l, resource: u } = o;
        l ? (s[l] = s[l] || un(), Px(u, s[l])) : Px(u, s);
      } else Ot(o) && Px(JSON.parse(o), s);
    }), i == null && a) for (const o in s) Ja(s, o) && kv(s[o]);
    return s;
  }
  function JQ(n) {
    return n.type;
  }
  function QQ(n, t, e) {
    let r = Ye(t.messages) ? t.messages : un();
    "__i18nGlobal" in e && (r = YN(n.locale.value, {
      messages: r,
      __i18n: e.__i18nGlobal
    }));
    const i = Object.keys(r);
    i.length && i.forEach((a) => {
      n.mergeLocaleMessage(a, r[a]);
    });
    {
      if (Ye(t.datetimeFormats)) {
        const a = Object.keys(t.datetimeFormats);
        a.length && a.forEach((s) => {
          n.mergeDateTimeFormat(s, t.datetimeFormats[s]);
        });
      }
      if (Ye(t.numberFormats)) {
        const a = Object.keys(t.numberFormats);
        a.length && a.forEach((s) => {
          n.mergeNumberFormat(s, t.numberFormats[s]);
        });
      }
    }
  }
  function G4(n) {
    return oe(Ett, null, n, 0);
  }
  const W4 = "__INTLIFY_META__", U4 = () => [], Y9t = () => false;
  let H4 = 0;
  function X4(n) {
    return (t, e, r, i) => n(e, r, Zi() || void 0, i);
  }
  const q9t = () => {
    const n = Zi();
    let t = null;
    return n && (t = JQ(n)[W4]) ? {
      [W4]: t
    } : null;
  };
  function qN(n = {}) {
    const { __root: t, __injectWithOption: e } = n, r = t === void 0, i = n.flatJson, a = h1 ? ue : Dtt;
    let s = We(n.inheritLocale) ? n.inheritLocale : true;
    const o = a(t && s ? t.locale.value : Ot(n.locale) ? n.locale : Av), l = a(t && s ? t.fallbackLocale.value : Ot(n.fallbackLocale) || qn(n.fallbackLocale) || Ee(n.fallbackLocale) || n.fallbackLocale === false ? n.fallbackLocale : o.value), u = a(YN(o.value, n)), c = a(Ee(n.datetimeFormats) ? n.datetimeFormats : {
      [o.value]: {}
    }), h = a(Ee(n.numberFormats) ? n.numberFormats : {
      [o.value]: {}
    });
    let f = t ? t.missingWarn : We(n.missingWarn) || fd(n.missingWarn) ? n.missingWarn : true, d = t ? t.fallbackWarn : We(n.fallbackWarn) || fd(n.fallbackWarn) ? n.fallbackWarn : true, p = t ? t.fallbackRoot : We(n.fallbackRoot) ? n.fallbackRoot : true, g = !!n.fallbackFormat, v = mn(n.missing) ? n.missing : null, m = mn(n.missing) ? X4(n.missing) : null, y = mn(n.postTranslation) ? n.postTranslation : null, x = t ? t.warnHtmlMessage : We(n.warnHtmlMessage) ? n.warnHtmlMessage : true, b = !!n.escapeParameter;
    const _ = t ? t.modifiers : Ee(n.modifiers) ? n.modifiers : {};
    let w = n.pluralRules || t && t.pluralRules, S;
    S = (() => {
      r && N4(null);
      const st = {
        version: H9t,
        locale: o.value,
        fallbackLocale: l.value,
        messages: u.value,
        modifiers: _,
        pluralRules: w,
        missing: m === null ? void 0 : m,
        missingWarn: f,
        fallbackWarn: d,
        fallbackFormat: g,
        unresolving: true,
        postTranslation: y === null ? void 0 : y,
        warnHtmlMessage: x,
        escapeParameter: b,
        messageResolver: n.messageResolver,
        messageCompiler: n.messageCompiler,
        __meta: {
          framework: "vue"
        }
      };
      st.datetimeFormats = c.value, st.numberFormats = h.value, st.__datetimeFormatters = Ee(S) ? S.__datetimeFormatters : void 0, st.__numberFormatters = Ee(S) ? S.__numberFormatters : void 0;
      const xt = E9t(st);
      return r && N4(xt), xt;
    })(), Pp(S, o.value, l.value);
    function T() {
      return [
        o.value,
        l.value,
        u.value,
        c.value,
        h.value
      ];
    }
    const A = ke({
      get: () => o.value,
      set: (st) => {
        S.locale = st, o.value = st;
      }
    }), C = ke({
      get: () => l.value,
      set: (st) => {
        S.fallbackLocale = st, l.value = st, Pp(S, o.value, st);
      }
    }), D = ke(() => u.value), E = ke(() => c.value), M = ke(() => h.value);
    function L() {
      return mn(y) ? y : null;
    }
    function k(st) {
      y = st, S.postTranslation = st;
    }
    function N() {
      return v;
    }
    function R(st) {
      st !== null && (m = X4(st)), v = st, S.missing = m;
    }
    const $ = (st, xt, Me, je, $r, ms) => {
      T();
      let ys;
      try {
        __INTLIFY_PROD_DEVTOOLS__, r || (S.fallbackContext = t ? D9t() : void 0), ys = st(S);
      } finally {
        __INTLIFY_PROD_DEVTOOLS__, r || (S.fallbackContext = void 0);
      }
      if (Me !== "translate exists" && Wn(ys) && ys === Fw || Me === "translate exists" && !ys) {
        const [Zd, cL] = xt();
        return t && p ? je(t) : $r(Zd);
      } else {
        if (ms(ys)) return ys;
        throw Qi(Bi.UNEXPECTED_RETURN_TYPE);
      }
    };
    function O(...st) {
      return $((xt) => Reflect.apply(V4, null, [
        xt,
        ...st
      ]), () => vk(...st), "translate", (xt) => Reflect.apply(xt.t, xt, [
        ...st
      ]), (xt) => xt, (xt) => Ot(xt));
    }
    function F(...st) {
      const [xt, Me, je] = st;
      if (je && !Ye(je)) throw Qi(Bi.INVALID_ARGUMENT);
      return O(xt, Me, lr({
        resolvedMessage: true
      }, je || {}));
    }
    function z(...st) {
      return $((xt) => Reflect.apply(P4, null, [
        xt,
        ...st
      ]), () => pk(...st), "datetime format", (xt) => Reflect.apply(xt.d, xt, [
        ...st
      ]), () => M4, (xt) => Ot(xt));
    }
    function V(...st) {
      return $((xt) => Reflect.apply(O4, null, [
        xt,
        ...st
      ]), () => gk(...st), "number format", (xt) => Reflect.apply(xt.n, xt, [
        ...st
      ]), () => M4, (xt) => Ot(xt));
    }
    function U(st) {
      return st.map((xt) => Ot(xt) || Wn(xt) || We(xt) ? G4(String(xt)) : xt);
    }
    const at = {
      normalize: U,
      interpolate: (st) => st,
      type: "vnode"
    };
    function pt(...st) {
      return $((xt) => {
        let Me;
        const je = xt;
        try {
          je.processor = at, Me = Reflect.apply(V4, null, [
            je,
            ...st
          ]);
        } finally {
          je.processor = null;
        }
        return Me;
      }, () => vk(...st), "translate", (xt) => xt[mk](...st), (xt) => [
        G4(xt)
      ], (xt) => qn(xt));
    }
    function it(...st) {
      return $((xt) => Reflect.apply(O4, null, [
        xt,
        ...st
      ]), () => gk(...st), "number format", (xt) => xt[xk](...st), U4, (xt) => Ot(xt) || qn(xt));
    }
    function et(...st) {
      return $((xt) => Reflect.apply(P4, null, [
        xt,
        ...st
      ]), () => pk(...st), "datetime format", (xt) => xt[yk](...st), U4, (xt) => Ot(xt) || qn(xt));
    }
    function ft(st) {
      w = st, S.pluralRules = w;
    }
    function ut(st, xt) {
      return $(() => {
        if (!st) return false;
        const Me = Ot(xt) ? xt : o.value, je = At(Me), $r = S.messageResolver(je, st);
        return pd($r) || ma($r) || Ot($r);
      }, () => [
        st
      ], "translate exists", (Me) => Reflect.apply(Me.te, Me, [
        st,
        xt
      ]), Y9t, (Me) => We(Me));
    }
    function gt(st) {
      let xt = null;
      const Me = zQ(S, l.value, o.value);
      for (let je = 0; je < Me.length; je++) {
        const $r = u.value[Me[je]] || {}, ms = S.messageResolver($r, st);
        if (ms != null) {
          xt = ms;
          break;
        }
      }
      return xt;
    }
    function kt(st) {
      const xt = gt(st);
      return xt ?? (t ? t.tm(st) || {} : {});
    }
    function At(st) {
      return u.value[st] || {};
    }
    function mt(st, xt) {
      if (i) {
        const Me = {
          [st]: xt
        };
        for (const je in Me) Ja(Me, je) && kv(Me[je]);
        xt = Me[st];
      }
      u.value[st] = xt, S.messages = u.value;
    }
    function _t(st, xt) {
      u.value[st] = u.value[st] || {};
      const Me = {
        [st]: xt
      };
      if (i) for (const je in Me) Ja(Me, je) && kv(Me[je]);
      xt = Me[st], Px(xt, u.value[st]), S.messages = u.value;
    }
    function ee(st) {
      return c.value[st] || {};
    }
    function G(st, xt) {
      c.value[st] = xt, S.datetimeFormats = c.value, $4(S, st, xt);
    }
    function H(st, xt) {
      c.value[st] = lr(c.value[st] || {}, xt), S.datetimeFormats = c.value, $4(S, st, xt);
    }
    function dt(st) {
      return h.value[st] || {};
    }
    function Mt(st, xt) {
      h.value[st] = xt, S.numberFormats = h.value, F4(S, st, xt);
    }
    function Ae(st, xt) {
      h.value[st] = lr(h.value[st] || {}, xt), S.numberFormats = h.value, F4(S, st, xt);
    }
    H4++, t && h1 && (Yr(t.locale, (st) => {
      s && (o.value = st, S.locale = st, Pp(S, o.value, l.value));
    }), Yr(t.fallbackLocale, (st) => {
      s && (l.value = st, S.fallbackLocale = st, Pp(S, o.value, l.value));
    }));
    const ie = {
      id: H4,
      locale: A,
      fallbackLocale: C,
      get inheritLocale() {
        return s;
      },
      set inheritLocale(st) {
        s = st, st && t && (o.value = t.locale.value, l.value = t.fallbackLocale.value, Pp(S, o.value, l.value));
      },
      get availableLocales() {
        return Object.keys(u.value).sort();
      },
      messages: D,
      get modifiers() {
        return _;
      },
      get pluralRules() {
        return w || {};
      },
      get isGlobal() {
        return r;
      },
      get missingWarn() {
        return f;
      },
      set missingWarn(st) {
        f = st, S.missingWarn = f;
      },
      get fallbackWarn() {
        return d;
      },
      set fallbackWarn(st) {
        d = st, S.fallbackWarn = d;
      },
      get fallbackRoot() {
        return p;
      },
      set fallbackRoot(st) {
        p = st;
      },
      get fallbackFormat() {
        return g;
      },
      set fallbackFormat(st) {
        g = st, S.fallbackFormat = g;
      },
      get warnHtmlMessage() {
        return x;
      },
      set warnHtmlMessage(st) {
        x = st, S.warnHtmlMessage = st;
      },
      get escapeParameter() {
        return b;
      },
      set escapeParameter(st) {
        b = st, S.escapeParameter = st;
      },
      t: O,
      getLocaleMessage: At,
      setLocaleMessage: mt,
      mergeLocaleMessage: _t,
      getPostTranslationHandler: L,
      setPostTranslationHandler: k,
      getMissingHandler: N,
      setMissingHandler: R,
      [KQ]: ft
    };
    return ie.datetimeFormats = E, ie.numberFormats = M, ie.rt = F, ie.te = ut, ie.tm = kt, ie.d = z, ie.n = V, ie.getDateTimeFormat = ee, ie.setDateTimeFormat = G, ie.mergeDateTimeFormat = H, ie.getNumberFormat = dt, ie.setNumberFormat = Mt, ie.mergeNumberFormat = Ae, ie[ZQ] = e, ie[mk] = pt, ie[yk] = et, ie[xk] = it, ie;
  }
  function j9t(n) {
    const t = Ot(n.locale) ? n.locale : Av, e = Ot(n.fallbackLocale) || qn(n.fallbackLocale) || Ee(n.fallbackLocale) || n.fallbackLocale === false ? n.fallbackLocale : t, r = mn(n.missing) ? n.missing : void 0, i = We(n.silentTranslationWarn) || fd(n.silentTranslationWarn) ? !n.silentTranslationWarn : true, a = We(n.silentFallbackWarn) || fd(n.silentFallbackWarn) ? !n.silentFallbackWarn : true, s = We(n.fallbackRoot) ? n.fallbackRoot : true, o = !!n.formatFallbackMessages, l = Ee(n.modifiers) ? n.modifiers : {}, u = n.pluralizationRules, c = mn(n.postTranslation) ? n.postTranslation : void 0, h = Ot(n.warnHtmlInMessage) ? n.warnHtmlInMessage !== "off" : true, f = !!n.escapeParameterHtml, d = We(n.sync) ? n.sync : true;
    let p = n.messages;
    if (Ee(n.sharedMessages)) {
      const _ = n.sharedMessages;
      p = Object.keys(_).reduce((S, I) => {
        const T = S[I] || (S[I] = {});
        return lr(T, _[I]), S;
      }, p || {});
    }
    const { __i18n: g, __root: v, __injectWithOption: m } = n, y = n.datetimeFormats, x = n.numberFormats, b = n.flatJson;
    return {
      locale: t,
      fallbackLocale: e,
      messages: p,
      flatJson: b,
      datetimeFormats: y,
      numberFormats: x,
      missing: r,
      missingWarn: i,
      fallbackWarn: a,
      fallbackRoot: s,
      fallbackFormat: o,
      modifiers: l,
      pluralRules: u,
      postTranslation: c,
      warnHtmlMessage: h,
      escapeParameter: f,
      messageResolver: n.messageResolver,
      inheritLocale: d,
      __i18n: g,
      __root: v,
      __injectWithOption: m
    };
  }
  function _k(n = {}) {
    const t = qN(j9t(n)), { __extender: e } = n, r = {
      id: t.id,
      get locale() {
        return t.locale.value;
      },
      set locale(i) {
        t.locale.value = i;
      },
      get fallbackLocale() {
        return t.fallbackLocale.value;
      },
      set fallbackLocale(i) {
        t.fallbackLocale.value = i;
      },
      get messages() {
        return t.messages.value;
      },
      get datetimeFormats() {
        return t.datetimeFormats.value;
      },
      get numberFormats() {
        return t.numberFormats.value;
      },
      get availableLocales() {
        return t.availableLocales;
      },
      get missing() {
        return t.getMissingHandler();
      },
      set missing(i) {
        t.setMissingHandler(i);
      },
      get silentTranslationWarn() {
        return We(t.missingWarn) ? !t.missingWarn : t.missingWarn;
      },
      set silentTranslationWarn(i) {
        t.missingWarn = We(i) ? !i : i;
      },
      get silentFallbackWarn() {
        return We(t.fallbackWarn) ? !t.fallbackWarn : t.fallbackWarn;
      },
      set silentFallbackWarn(i) {
        t.fallbackWarn = We(i) ? !i : i;
      },
      get modifiers() {
        return t.modifiers;
      },
      get formatFallbackMessages() {
        return t.fallbackFormat;
      },
      set formatFallbackMessages(i) {
        t.fallbackFormat = i;
      },
      get postTranslation() {
        return t.getPostTranslationHandler();
      },
      set postTranslation(i) {
        t.setPostTranslationHandler(i);
      },
      get sync() {
        return t.inheritLocale;
      },
      set sync(i) {
        t.inheritLocale = i;
      },
      get warnHtmlInMessage() {
        return t.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(i) {
        t.warnHtmlMessage = i !== "off";
      },
      get escapeParameterHtml() {
        return t.escapeParameter;
      },
      set escapeParameterHtml(i) {
        t.escapeParameter = i;
      },
      get pluralizationRules() {
        return t.pluralRules || {};
      },
      __composer: t,
      t(...i) {
        return Reflect.apply(t.t, t, [
          ...i
        ]);
      },
      rt(...i) {
        return Reflect.apply(t.rt, t, [
          ...i
        ]);
      },
      te(i, a) {
        return t.te(i, a);
      },
      tm(i) {
        return t.tm(i);
      },
      getLocaleMessage(i) {
        return t.getLocaleMessage(i);
      },
      setLocaleMessage(i, a) {
        t.setLocaleMessage(i, a);
      },
      mergeLocaleMessage(i, a) {
        t.mergeLocaleMessage(i, a);
      },
      d(...i) {
        return Reflect.apply(t.d, t, [
          ...i
        ]);
      },
      getDateTimeFormat(i) {
        return t.getDateTimeFormat(i);
      },
      setDateTimeFormat(i, a) {
        t.setDateTimeFormat(i, a);
      },
      mergeDateTimeFormat(i, a) {
        t.mergeDateTimeFormat(i, a);
      },
      n(...i) {
        return Reflect.apply(t.n, t, [
          ...i
        ]);
      },
      getNumberFormat(i) {
        return t.getNumberFormat(i);
      },
      setNumberFormat(i, a) {
        t.setNumberFormat(i, a);
      },
      mergeNumberFormat(i, a) {
        t.mergeNumberFormat(i, a);
      }
    };
    return r.__extender = e, r;
  }
  function K9t(n, t, e) {
    return {
      beforeCreate() {
        const r = Zi();
        if (!r) throw Qi(Bi.UNEXPECTED_ERROR);
        const i = this.$options;
        if (i.i18n) {
          const a = i.i18n;
          if (i.__i18n && (a.__i18n = i.__i18n), a.__root = t, this === this.$root) this.$i18n = Y4(n, a);
          else {
            a.__injectWithOption = true, a.__extender = e.__vueI18nExtend, this.$i18n = _k(a);
            const s = this.$i18n;
            s.__extender && (s.__disposer = s.__extender(this.$i18n));
          }
        } else if (i.__i18n) if (this === this.$root) this.$i18n = Y4(n, i);
        else {
          this.$i18n = _k({
            __i18n: i.__i18n,
            __injectWithOption: true,
            __extender: e.__vueI18nExtend,
            __root: t
          });
          const a = this.$i18n;
          a.__extender && (a.__disposer = a.__extender(this.$i18n));
        }
        else this.$i18n = n;
        i.__i18nGlobal && QQ(t, i, i), this.$t = (...a) => this.$i18n.t(...a), this.$rt = (...a) => this.$i18n.rt(...a), this.$te = (a, s) => this.$i18n.te(a, s), this.$d = (...a) => this.$i18n.d(...a), this.$n = (...a) => this.$i18n.n(...a), this.$tm = (a) => this.$i18n.tm(a), e.__setInstance(r, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const r = Zi();
        if (!r) throw Qi(Bi.UNEXPECTED_ERROR);
        const i = this.$i18n;
        delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), e.__deleteInstance(r), delete this.$i18n;
      }
    };
  }
  function Y4(n, t) {
    n.locale = t.locale || n.locale, n.fallbackLocale = t.fallbackLocale || n.fallbackLocale, n.missing = t.missing || n.missing, n.silentTranslationWarn = t.silentTranslationWarn || n.silentFallbackWarn, n.silentFallbackWarn = t.silentFallbackWarn || n.silentFallbackWarn, n.formatFallbackMessages = t.formatFallbackMessages || n.formatFallbackMessages, n.postTranslation = t.postTranslation || n.postTranslation, n.warnHtmlInMessage = t.warnHtmlInMessage || n.warnHtmlInMessage, n.escapeParameterHtml = t.escapeParameterHtml || n.escapeParameterHtml, n.sync = t.sync || n.sync, n.__composer[KQ](t.pluralizationRules || n.pluralizationRules);
    const e = YN(n.locale, {
      messages: t.messages,
      __i18n: t.__i18n
    });
    return Object.keys(e).forEach((r) => n.mergeLocaleMessage(r, e[r])), t.datetimeFormats && Object.keys(t.datetimeFormats).forEach((r) => n.mergeDateTimeFormat(r, t.datetimeFormats[r])), t.numberFormats && Object.keys(t.numberFormats).forEach((r) => n.mergeNumberFormat(r, t.numberFormats[r])), n;
  }
  const jN = {
    tag: {
      type: [
        String,
        Object
      ]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (n) => n === "parent" || n === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  function Z9t({ slots: n }, t) {
    return t.length === 1 && t[0] === "default" ? (n.default ? n.default() : []).reduce((r, i) => [
      ...r,
      ...i.type === kg ? i.children : [
        i
      ]
    ], []) : t.reduce((e, r) => {
      const i = n[r];
      return i && (e[r] = i()), e;
    }, un());
  }
  function ttt() {
    return kg;
  }
  const J9t = he({
    name: "i18n-t",
    props: lr({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [
          Number,
          String
        ],
        validator: (n) => Wn(n) || !isNaN(n)
      }
    }, jN),
    setup(n, t) {
      const { slots: e, attrs: r } = t, i = n.i18n || KN({
        useScope: n.scope,
        __useComponent: true
      });
      return () => {
        const a = Object.keys(e).filter((h) => h !== "_"), s = un();
        n.locale && (s.locale = n.locale), n.plural !== void 0 && (s.plural = Ot(n.plural) ? +n.plural : n.plural);
        const o = Z9t(t, a), l = i[mk](n.keypath, o, s), u = lr(un(), r), c = Ot(n.tag) || Ye(n.tag) ? n.tag : ttt();
        return Qa(c, u, l);
      };
    }
  }), q4 = J9t;
  function Q9t(n) {
    return qn(n) && !Ot(n[0]);
  }
  function ett(n, t, e, r) {
    const { slots: i, attrs: a } = t;
    return () => {
      const s = {
        part: true
      };
      let o = un();
      n.locale && (s.locale = n.locale), Ot(n.format) ? s.key = n.format : Ye(n.format) && (Ot(n.format.key) && (s.key = n.format.key), o = Object.keys(n.format).reduce((f, d) => e.includes(d) ? lr(un(), f, {
        [d]: n.format[d]
      }) : f, un()));
      const l = r(n.value, s, o);
      let u = [
        s.key
      ];
      qn(l) ? u = l.map((f, d) => {
        const p = i[f.type], g = p ? p({
          [f.type]: f.value,
          index: d,
          parts: l
        }) : [
          f.value
        ];
        return Q9t(g) && (g[0].key = `${f.type}-${d}`), g;
      }) : Ot(l) && (u = [
        l
      ]);
      const c = lr(un(), a), h = Ot(n.tag) || Ye(n.tag) ? n.tag : ttt();
      return Qa(h, c, u);
    };
  }
  const tKt = he({
    name: "i18n-n",
    props: lr({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, jN),
    setup(n, t) {
      const e = n.i18n || KN({
        useScope: n.scope,
        __useComponent: true
      });
      return ett(n, t, YQ, (...r) => e[xk](...r));
    }
  }), j4 = tKt;
  function eKt(n, t) {
    const e = n;
    if (n.mode === "composition") return e.__getInstance(t) || n.global;
    {
      const r = e.__getInstance(t);
      return r != null ? r.__composer : n.global.__composer;
    }
  }
  function nKt(n) {
    const t = (s) => {
      const { instance: o, value: l } = s;
      if (!o || !o.$) throw Qi(Bi.UNEXPECTED_ERROR);
      const u = eKt(n, o.$), c = K4(l);
      return [
        Reflect.apply(u.t, u, [
          ...Z4(c)
        ]),
        u
      ];
    };
    return {
      created: (s, o) => {
        const [l, u] = t(o);
        h1 && n.global === u && (s.__i18nWatcher = Yr(u.locale, () => {
          o.instance && o.instance.$forceUpdate();
        })), s.__composer = u, s.textContent = l;
      },
      unmounted: (s) => {
        h1 && s.__i18nWatcher && (s.__i18nWatcher(), s.__i18nWatcher = void 0, delete s.__i18nWatcher), s.__composer && (s.__composer = void 0, delete s.__composer);
      },
      beforeUpdate: (s, { value: o }) => {
        if (s.__composer) {
          const l = s.__composer, u = K4(o);
          s.textContent = Reflect.apply(l.t, l, [
            ...Z4(u)
          ]);
        }
      },
      getSSRProps: (s) => {
        const [o] = t(s);
        return {
          textContent: o
        };
      }
    };
  }
  function K4(n) {
    if (Ot(n)) return {
      path: n
    };
    if (Ee(n)) {
      if (!("path" in n)) throw Qi(Bi.REQUIRED_VALUE, "path");
      return n;
    } else throw Qi(Bi.INVALID_VALUE);
  }
  function Z4(n) {
    const { path: t, locale: e, args: r, choice: i, plural: a } = n, s = {}, o = r || {};
    return Ot(e) && (s.locale = e), Wn(i) && (s.plural = i), Wn(a) && (s.plural = a), [
      t,
      o,
      s
    ];
  }
  function rKt(n, t, ...e) {
    const r = Ee(e[0]) ? e[0] : {};
    (We(r.globalInstall) ? r.globalInstall : true) && ([
      q4.name,
      "I18nT"
    ].forEach((a) => n.component(a, q4)), [
      j4.name,
      "I18nN"
    ].forEach((a) => n.component(a, j4)), [
      Q4.name,
      "I18nD"
    ].forEach((a) => n.component(a, Q4))), n.directive("t", nKt(t));
  }
  const iKt = yu("global-vue-i18n");
  function aKt(n = {}) {
    const t = __VUE_I18N_LEGACY_API__ && We(n.legacy) ? n.legacy : __VUE_I18N_LEGACY_API__, e = We(n.globalInjection) ? n.globalInjection : true, r = /* @__PURE__ */ new Map(), [i, a] = sKt(n, t), s = yu("");
    function o(h) {
      return r.get(h) || null;
    }
    function l(h, f) {
      r.set(h, f);
    }
    function u(h) {
      r.delete(h);
    }
    const c = {
      get mode() {
        return __VUE_I18N_LEGACY_API__ && t ? "legacy" : "composition";
      },
      async install(h, ...f) {
        if (h.__VUE_I18N_SYMBOL__ = s, h.provide(h.__VUE_I18N_SYMBOL__, c), Ee(f[0])) {
          const g = f[0];
          c.__composerExtend = g.__composerExtend, c.__vueI18nExtend = g.__vueI18nExtend;
        }
        let d = null;
        !t && e && (d = pKt(h, c.global)), __VUE_I18N_FULL_INSTALL__ && rKt(h, c, ...f), __VUE_I18N_LEGACY_API__ && t && h.mixin(K9t(a, a.__composer, c));
        const p = h.unmount;
        h.unmount = () => {
          d && d(), c.dispose(), p();
        };
      },
      get global() {
        return a;
      },
      dispose() {
        i.stop();
      },
      __instances: r,
      __getInstance: o,
      __setInstance: l,
      __deleteInstance: u
    };
    return c;
  }
  function KN(n = {}) {
    const t = Zi();
    if (t == null) throw Qi(Bi.MUST_BE_CALL_SETUP_TOP);
    if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__) throw Qi(Bi.NOT_INSTALLED);
    const e = oKt(t), r = uKt(e), i = JQ(t), a = lKt(n, i);
    if (a === "global") return QQ(r, n, i), r;
    if (a === "parent") {
      let l = cKt(e, t, n.__useComponent);
      return l == null && (l = r), l;
    }
    const s = e;
    let o = s.__getInstance(t);
    if (o == null) {
      const l = lr({}, n);
      "__i18n" in i && (l.__i18n = i.__i18n), r && (l.__root = r), o = qN(l), s.__composerExtend && (o[bk] = s.__composerExtend(o)), fKt(s, t, o), s.__setInstance(t, o);
    }
    return o;
  }
  function sKt(n, t) {
    const e = Ik(), r = __VUE_I18N_LEGACY_API__ && t ? e.run(() => _k(n)) : e.run(() => qN(n));
    if (r == null) throw Qi(Bi.UNEXPECTED_ERROR);
    return [
      e,
      r
    ];
  }
  function oKt(n) {
    const t = mW(n.isCE ? iKt : n.appContext.app.__VUE_I18N_SYMBOL__);
    if (!t) throw Qi(n.isCE ? Bi.NOT_INSTALLED_WITH_PROVIDE : Bi.UNEXPECTED_ERROR);
    return t;
  }
  function lKt(n, t) {
    return $w(n) ? "__i18n" in t ? "local" : "global" : n.useScope ? n.useScope : "local";
  }
  function uKt(n) {
    return n.mode === "composition" ? n.global : n.global.__composer;
  }
  function cKt(n, t, e = false) {
    let r = null;
    const i = t.root;
    let a = hKt(t, e);
    for (; a != null; ) {
      const s = n;
      if (n.mode === "composition") r = s.__getInstance(a);
      else if (__VUE_I18N_LEGACY_API__) {
        const o = s.__getInstance(a);
        o != null && (r = o.__composer, e && r && !r[ZQ] && (r = null));
      }
      if (r != null || i === a) break;
      a = a.parent;
    }
    return r;
  }
  function hKt(n, t = false) {
    return n == null ? null : t && n.vnode.ctx || n.parent;
  }
  function fKt(n, t, e) {
    gd(() => {
    }, t), d1(() => {
      const r = e;
      n.__deleteInstance(t);
      const i = r[bk];
      i && (i(), delete r[bk]);
    }, t);
  }
  const dKt = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ], J4 = [
    "t",
    "rt",
    "d",
    "n",
    "tm",
    "te"
  ];
  function pKt(n, t) {
    const e = /* @__PURE__ */ Object.create(null);
    return dKt.forEach((i) => {
      const a = Object.getOwnPropertyDescriptor(t, i);
      if (!a) throw Qi(Bi.UNEXPECTED_ERROR);
      const s = vW(a.value) ? {
        get() {
          return a.value.value;
        },
        set(o) {
          a.value.value = o;
        }
      } : {
        get() {
          return a.get && a.get();
        }
      };
      Object.defineProperty(e, i, s);
    }), n.config.globalProperties.$i18n = e, J4.forEach((i) => {
      const a = Object.getOwnPropertyDescriptor(t, i);
      if (!a || !a.value) throw Qi(Bi.UNEXPECTED_ERROR);
      Object.defineProperty(n.config.globalProperties, `$${i}`, a);
    }), () => {
      delete n.config.globalProperties.$i18n, J4.forEach((i) => {
        delete n.config.globalProperties[`$${i}`];
      });
    };
  }
  const gKt = he({
    name: "i18n-d",
    props: lr({
      value: {
        type: [
          Number,
          Date
        ],
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, jN),
    setup(n, t) {
      const e = n.i18n || KN({
        useScope: n.scope,
        __useComponent: true
      });
      return ett(n, t, XQ, (...r) => e[yk](...r));
    }
  }), Q4 = gKt;
  X9t();
  C9t(a9t);
  T9t(_9t);
  I9t(zQ);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const n = kc();
    n.__INTLIFY__ = true, s9t(n.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const vKt = gW("app", {
    state: () => ({
      lang: ""
    }),
    actions: {
      setNowLang(n) {
        this.lang = n;
      }
    }
  }), tW = await xKt({
    locale: mKt()
  });
  function mKt() {
    const n = window.location.href, t = navigator.language, e = _Kt(n).lang ?? t;
    return vKt().setNowLang(e), e;
  }
  function yKt(n) {
    return n.includes("zh");
  }
  async function xKt(n = {
    locale: "zh-CN"
  }) {
    const t = aKt({
      legacy: false,
      globalInjection: true,
      fallbackLocale: "zh-CN",
      ...n
    });
    return bKt(t, n.locale), await eW(t, "zh-CN"), yKt(n.locale) || await eW(t, n.locale), t;
  }
  function bKt(n, t = "zh-CN") {
    var _a2;
    n.mode === "legacy" ? n.global.locale = t : typeof n.global.locale != "string" && (n.global.locale.value = t), (_a2 = document.querySelector("html")) == null ? void 0 : _a2.setAttribute("lang", t);
  }
  async function eW(n, t) {
    const e = await l7t(Object.assign({
      "./locales/en.json": () => Bf(() => import("./en-8UogEnwF.js"), []),
      "./locales/zh-CN.json": () => Bf(() => import("./zh-CN-BYtN7nWk.js"), [])
    }), `./locales/${t}.json`, 3);
    return n.global.setLocaleMessage(t, e.default), Jo();
  }
  function _Kt(n) {
    const t = {};
    if (!n || n === "" || typeof n != "string") return t;
    const e = n.split("?")[1];
    return e && e.split("&").forEach((i) => {
      const [a, s] = i.split("=");
      s === void 0 ? t[a] = null : s === "true" ? t[a] = true : s === "false" ? t[a] = false : t[a] = decodeURIComponent(s);
    }), t;
  }
  const wKt = () => {
    const n = ke(() => J(tW.global.locale)), t = ke(() => n.value.includes("zh"));
    return {
      t: tW.global.t,
      locale: n,
      isZh: t
    };
  };
  function ntt(n) {
    var t, e, r = "";
    if (typeof n == "string" || typeof n == "number") r += n;
    else if (typeof n == "object") if (Array.isArray(n)) {
      var i = n.length;
      for (t = 0; t < i; t++) n[t] && (e = ntt(n[t])) && (r && (r += " "), r += e);
    } else for (e in n) n[e] && (r && (r += " "), r += e);
    return r;
  }
  function rtt() {
    for (var n, t, e = 0, r = "", i = arguments.length; e < i; e++) (n = arguments[e]) && (t = ntt(n)) && (r && (r += " "), r += t);
    return r;
  }
  const nW = (n) => typeof n == "boolean" ? `${n}` : n === 0 ? "0" : n, rW = rtt, SKt = (n, t) => (e) => {
    var r;
    if ((t == null ? void 0 : t.variants) == null) return rW(n, e == null ? void 0 : e.class, e == null ? void 0 : e.className);
    const { variants: i, defaultVariants: a } = t, s = Object.keys(i).map((u) => {
      const c = e == null ? void 0 : e[u], h = a == null ? void 0 : a[u];
      if (c === null) return null;
      const f = nW(c) || nW(h);
      return i[u][f];
    }), o = e && Object.entries(e).reduce((u, c) => {
      let [h, f] = c;
      return f === void 0 || (u[h] = f), u;
    }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, c) => {
      let { class: h, className: f, ...d } = c;
      return Object.entries(d).every((p) => {
        let [g, v] = p;
        return Array.isArray(v) ? v.includes({
          ...a,
          ...o
        }[g]) : {
          ...a,
          ...o
        }[g] === v;
      }) ? [
        ...u,
        h,
        f
      ] : u;
    }, []);
    return rW(n, s, l, e == null ? void 0 : e.class, e == null ? void 0 : e.className);
  }, ZN = "-", CKt = (n) => {
    const t = IKt(n), { conflictingClassGroups: e, conflictingClassGroupModifiers: r } = n;
    return {
      getClassGroupId: (s) => {
        const o = s.split(ZN);
        return o[0] === "" && o.length !== 1 && o.shift(), itt(o, t) || TKt(s);
      },
      getConflictingClassGroupIds: (s, o) => {
        const l = e[s] || [];
        return o && r[s] ? [
          ...l,
          ...r[s]
        ] : l;
      }
    };
  }, itt = (n, t) => {
    var _a2;
    if (n.length === 0) return t.classGroupId;
    const e = n[0], r = t.nextPart.get(e), i = r ? itt(n.slice(1), r) : void 0;
    if (i) return i;
    if (t.validators.length === 0) return;
    const a = n.join(ZN);
    return (_a2 = t.validators.find(({ validator: s }) => s(a))) == null ? void 0 : _a2.classGroupId;
  }, iW = /^\[(.+)\]$/, TKt = (n) => {
    if (iW.test(n)) {
      const t = iW.exec(n)[1], e = t == null ? void 0 : t.substring(0, t.indexOf(":"));
      if (e) return "arbitrary.." + e;
    }
  }, IKt = (n) => {
    const { theme: t, classGroups: e } = n, r = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    for (const i in e) wk(e[i], r, i, t);
    return r;
  }, wk = (n, t, e, r) => {
    n.forEach((i) => {
      if (typeof i == "string") {
        const a = i === "" ? t : aW(t, i);
        a.classGroupId = e;
        return;
      }
      if (typeof i == "function") {
        if (AKt(i)) {
          wk(i(r), t, e, r);
          return;
        }
        t.validators.push({
          validator: i,
          classGroupId: e
        });
        return;
      }
      Object.entries(i).forEach(([a, s]) => {
        wk(s, aW(t, a), e, r);
      });
    });
  }, aW = (n, t) => {
    let e = n;
    return t.split(ZN).forEach((r) => {
      e.nextPart.has(r) || e.nextPart.set(r, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      }), e = e.nextPart.get(r);
    }), e;
  }, AKt = (n) => n.isThemeGetter, kKt = (n) => {
    if (n < 1) return {
      get: () => {
      },
      set: () => {
      }
    };
    let t = 0, e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
    const i = (a, s) => {
      e.set(a, s), t++, t > n && (t = 0, r = e, e = /* @__PURE__ */ new Map());
    };
    return {
      get(a) {
        let s = e.get(a);
        if (s !== void 0) return s;
        if ((s = r.get(a)) !== void 0) return i(a, s), s;
      },
      set(a, s) {
        e.has(a) ? e.set(a, s) : i(a, s);
      }
    };
  }, Sk = "!", Ck = ":", DKt = Ck.length, EKt = (n) => {
    const { prefix: t, experimentalParseClassName: e } = n;
    let r = (i) => {
      const a = [];
      let s = 0, o = 0, l = 0, u;
      for (let p = 0; p < i.length; p++) {
        let g = i[p];
        if (s === 0 && o === 0) {
          if (g === Ck) {
            a.push(i.slice(l, p)), l = p + DKt;
            continue;
          }
          if (g === "/") {
            u = p;
            continue;
          }
        }
        g === "[" ? s++ : g === "]" ? s-- : g === "(" ? o++ : g === ")" && o--;
      }
      const c = a.length === 0 ? i : i.substring(l), h = MKt(c), f = h !== c, d = u && u > l ? u - l : void 0;
      return {
        modifiers: a,
        hasImportantModifier: f,
        baseClassName: h,
        maybePostfixModifierPosition: d
      };
    };
    if (t) {
      const i = t + Ck, a = r;
      r = (s) => s.startsWith(i) ? a(s.substring(i.length)) : {
        isExternal: true,
        modifiers: [],
        hasImportantModifier: false,
        baseClassName: s,
        maybePostfixModifierPosition: void 0
      };
    }
    if (e) {
      const i = r;
      r = (a) => e({
        className: a,
        parseClassName: i
      });
    }
    return r;
  }, MKt = (n) => n.endsWith(Sk) ? n.substring(0, n.length - 1) : n.startsWith(Sk) ? n.substring(1) : n, RKt = (n) => {
    const t = Object.fromEntries(n.orderSensitiveModifiers.map((r) => [
      r,
      true
    ]));
    return (r) => {
      if (r.length <= 1) return r;
      const i = [];
      let a = [];
      return r.forEach((s) => {
        s[0] === "[" || t[s] ? (i.push(...a.sort(), s), a = []) : a.push(s);
      }), i.push(...a.sort()), i;
    };
  }, NKt = (n) => ({
    cache: kKt(n.cacheSize),
    parseClassName: EKt(n),
    sortModifiers: RKt(n),
    ...CKt(n)
  }), LKt = /\s+/, PKt = (n, t) => {
    const { parseClassName: e, getClassGroupId: r, getConflictingClassGroupIds: i, sortModifiers: a } = t, s = [], o = n.trim().split(LKt);
    let l = "";
    for (let u = o.length - 1; u >= 0; u -= 1) {
      const c = o[u], { isExternal: h, modifiers: f, hasImportantModifier: d, baseClassName: p, maybePostfixModifierPosition: g } = e(c);
      if (h) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      let v = !!g, m = r(v ? p.substring(0, g) : p);
      if (!m) {
        if (!v) {
          l = c + (l.length > 0 ? " " + l : l);
          continue;
        }
        if (m = r(p), !m) {
          l = c + (l.length > 0 ? " " + l : l);
          continue;
        }
        v = false;
      }
      const y = a(f).join(":"), x = d ? y + Sk : y, b = x + m;
      if (s.includes(b)) continue;
      s.push(b);
      const _ = i(m, v);
      for (let w = 0; w < _.length; ++w) {
        const S = _[w];
        s.push(x + S);
      }
      l = c + (l.length > 0 ? " " + l : l);
    }
    return l;
  };
  function $Kt() {
    let n = 0, t, e, r = "";
    for (; n < arguments.length; ) (t = arguments[n++]) && (e = att(t)) && (r && (r += " "), r += e);
    return r;
  }
  const att = (n) => {
    if (typeof n == "string") return n;
    let t, e = "";
    for (let r = 0; r < n.length; r++) n[r] && (t = att(n[r])) && (e && (e += " "), e += t);
    return e;
  };
  function OKt(n, ...t) {
    let e, r, i, a = s;
    function s(l) {
      const u = t.reduce((c, h) => h(c), n());
      return e = NKt(u), r = e.cache.get, i = e.cache.set, a = o, o(l);
    }
    function o(l) {
      const u = r(l);
      if (u) return u;
      const c = PKt(l, e);
      return i(l, c), c;
    }
    return function() {
      return a($Kt.apply(null, arguments));
    };
  }
  const dr = (n) => {
    const t = (e) => e[n] || [];
    return t.isThemeGetter = true, t;
  }, stt = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, ott = /^\((?:(\w[\w-]*):)?(.+)\)$/i, FKt = /^\d+\/\d+$/, BKt = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, zKt = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, VKt = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, GKt = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, WKt = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, sf = (n) => FKt.test(n), Re = (n) => !!n && !Number.isNaN(Number(n)), Ku = (n) => !!n && Number.isInteger(Number(n)), sW = (n) => n.endsWith("%") && Re(n.slice(0, -1)), vl = (n) => BKt.test(n), UKt = () => true, HKt = (n) => zKt.test(n) && !VKt.test(n), JN = () => false, XKt = (n) => GKt.test(n), YKt = (n) => WKt.test(n), qKt = (n) => !Lt(n) && !Pt(n), jKt = (n) => jd(n, ctt, JN), Lt = (n) => stt.test(n), Zu = (n) => jd(n, htt, HKt), oI = (n) => jd(n, sZt, Re), KKt = (n) => jd(n, ltt, JN), ZKt = (n) => jd(n, utt, YKt), JKt = (n) => jd(n, JN, XKt), Pt = (n) => ott.test(n), K0 = (n) => Kd(n, htt), QKt = (n) => Kd(n, oZt), tZt = (n) => Kd(n, ltt), eZt = (n) => Kd(n, ctt), nZt = (n) => Kd(n, utt), rZt = (n) => Kd(n, lZt, true), jd = (n, t, e) => {
    const r = stt.exec(n);
    return r ? r[1] ? t(r[1]) : e(r[2]) : false;
  }, Kd = (n, t, e = false) => {
    const r = ott.exec(n);
    return r ? r[1] ? t(r[1]) : e : false;
  }, ltt = (n) => n === "position", iZt = /* @__PURE__ */ new Set([
    "image",
    "url"
  ]), utt = (n) => iZt.has(n), aZt = /* @__PURE__ */ new Set([
    "length",
    "size",
    "percentage"
  ]), ctt = (n) => aZt.has(n), htt = (n) => n === "length", sZt = (n) => n === "number", oZt = (n) => n === "family-name", lZt = (n) => n === "shadow", uZt = () => {
    const n = dr("color"), t = dr("font"), e = dr("text"), r = dr("font-weight"), i = dr("tracking"), a = dr("leading"), s = dr("breakpoint"), o = dr("container"), l = dr("spacing"), u = dr("radius"), c = dr("shadow"), h = dr("inset-shadow"), f = dr("drop-shadow"), d = dr("blur"), p = dr("perspective"), g = dr("aspect"), v = dr("ease"), m = dr("animate"), y = () => [
      "auto",
      "avoid",
      "all",
      "avoid-page",
      "page",
      "left",
      "right",
      "column"
    ], x = () => [
      "bottom",
      "center",
      "left",
      "left-bottom",
      "left-top",
      "right",
      "right-bottom",
      "right-top",
      "top"
    ], b = () => [
      "auto",
      "hidden",
      "clip",
      "visible",
      "scroll"
    ], _ = () => [
      "auto",
      "contain",
      "none"
    ], w = () => [
      sf,
      "px",
      "full",
      "auto",
      Pt,
      Lt,
      l
    ], S = () => [
      Ku,
      "none",
      "subgrid",
      Pt,
      Lt
    ], I = () => [
      "auto",
      {
        span: [
          "full",
          Ku,
          Pt,
          Lt
        ]
      },
      Pt,
      Lt
    ], T = () => [
      Ku,
      "auto",
      Pt,
      Lt
    ], A = () => [
      "auto",
      "min",
      "max",
      "fr",
      Pt,
      Lt
    ], C = () => [
      Pt,
      Lt,
      l
    ], D = () => [
      "start",
      "end",
      "center",
      "between",
      "around",
      "evenly",
      "stretch",
      "baseline"
    ], E = () => [
      "start",
      "end",
      "center",
      "stretch"
    ], M = () => [
      Pt,
      Lt,
      l
    ], L = () => [
      "px",
      ...M()
    ], k = () => [
      "px",
      "auto",
      ...M()
    ], N = () => [
      sf,
      "auto",
      "px",
      "full",
      "dvw",
      "dvh",
      "lvw",
      "lvh",
      "svw",
      "svh",
      "min",
      "max",
      "fit",
      Pt,
      Lt,
      l
    ], R = () => [
      n,
      Pt,
      Lt
    ], $ = () => [
      sW,
      Zu
    ], O = () => [
      "",
      "none",
      "full",
      u,
      Pt,
      Lt
    ], F = () => [
      "",
      Re,
      K0,
      Zu
    ], z = () => [
      "solid",
      "dashed",
      "dotted",
      "double"
    ], V = () => [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ], U = () => [
      "",
      "none",
      d,
      Pt,
      Lt
    ], X = () => [
      "center",
      "top",
      "top-right",
      "right",
      "bottom-right",
      "bottom",
      "bottom-left",
      "left",
      "top-left",
      Pt,
      Lt
    ], at = () => [
      "none",
      Re,
      Pt,
      Lt
    ], pt = () => [
      "none",
      Re,
      Pt,
      Lt
    ], it = () => [
      Re,
      Pt,
      Lt
    ], et = () => [
      sf,
      "full",
      "px",
      Pt,
      Lt,
      l
    ];
    return {
      cacheSize: 500,
      theme: {
        animate: [
          "spin",
          "ping",
          "pulse",
          "bounce"
        ],
        aspect: [
          "video"
        ],
        blur: [
          vl
        ],
        breakpoint: [
          vl
        ],
        color: [
          UKt
        ],
        container: [
          vl
        ],
        "drop-shadow": [
          vl
        ],
        ease: [
          "in",
          "out",
          "in-out"
        ],
        font: [
          qKt
        ],
        "font-weight": [
          "thin",
          "extralight",
          "light",
          "normal",
          "medium",
          "semibold",
          "bold",
          "extrabold",
          "black"
        ],
        "inset-shadow": [
          vl
        ],
        leading: [
          "none",
          "tight",
          "snug",
          "normal",
          "relaxed",
          "loose"
        ],
        perspective: [
          "dramatic",
          "near",
          "normal",
          "midrange",
          "distant",
          "none"
        ],
        radius: [
          vl
        ],
        shadow: [
          vl
        ],
        spacing: [
          Re
        ],
        text: [
          vl
        ],
        tracking: [
          "tighter",
          "tight",
          "normal",
          "wide",
          "wider",
          "widest"
        ]
      },
      classGroups: {
        aspect: [
          {
            aspect: [
              "auto",
              "square",
              sf,
              Lt,
              Pt,
              g
            ]
          }
        ],
        container: [
          "container"
        ],
        columns: [
          {
            columns: [
              Re,
              Lt,
              Pt,
              o
            ]
          }
        ],
        "break-after": [
          {
            "break-after": y()
          }
        ],
        "break-before": [
          {
            "break-before": y()
          }
        ],
        "break-inside": [
          {
            "break-inside": [
              "auto",
              "avoid",
              "avoid-page",
              "avoid-column"
            ]
          }
        ],
        "box-decoration": [
          {
            "box-decoration": [
              "slice",
              "clone"
            ]
          }
        ],
        box: [
          {
            box: [
              "border",
              "content"
            ]
          }
        ],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden"
        ],
        sr: [
          "sr-only",
          "not-sr-only"
        ],
        float: [
          {
            float: [
              "right",
              "left",
              "none",
              "start",
              "end"
            ]
          }
        ],
        clear: [
          {
            clear: [
              "left",
              "right",
              "both",
              "none",
              "start",
              "end"
            ]
          }
        ],
        isolation: [
          "isolate",
          "isolation-auto"
        ],
        "object-fit": [
          {
            object: [
              "contain",
              "cover",
              "fill",
              "none",
              "scale-down"
            ]
          }
        ],
        "object-position": [
          {
            object: [
              ...x(),
              Lt,
              Pt
            ]
          }
        ],
        overflow: [
          {
            overflow: b()
          }
        ],
        "overflow-x": [
          {
            "overflow-x": b()
          }
        ],
        "overflow-y": [
          {
            "overflow-y": b()
          }
        ],
        overscroll: [
          {
            overscroll: _()
          }
        ],
        "overscroll-x": [
          {
            "overscroll-x": _()
          }
        ],
        "overscroll-y": [
          {
            "overscroll-y": _()
          }
        ],
        position: [
          "static",
          "fixed",
          "absolute",
          "relative",
          "sticky"
        ],
        inset: [
          {
            inset: w()
          }
        ],
        "inset-x": [
          {
            "inset-x": w()
          }
        ],
        "inset-y": [
          {
            "inset-y": w()
          }
        ],
        start: [
          {
            start: w()
          }
        ],
        end: [
          {
            end: w()
          }
        ],
        top: [
          {
            top: w()
          }
        ],
        right: [
          {
            right: w()
          }
        ],
        bottom: [
          {
            bottom: w()
          }
        ],
        left: [
          {
            left: w()
          }
        ],
        visibility: [
          "visible",
          "invisible",
          "collapse"
        ],
        z: [
          {
            z: [
              Ku,
              "auto",
              Pt,
              Lt
            ]
          }
        ],
        basis: [
          {
            basis: [
              sf,
              "full",
              "auto",
              Pt,
              Lt,
              o,
              l
            ]
          }
        ],
        "flex-direction": [
          {
            flex: [
              "row",
              "row-reverse",
              "col",
              "col-reverse"
            ]
          }
        ],
        "flex-wrap": [
          {
            flex: [
              "nowrap",
              "wrap",
              "wrap-reverse"
            ]
          }
        ],
        flex: [
          {
            flex: [
              Re,
              sf,
              "auto",
              "initial",
              "none",
              Lt
            ]
          }
        ],
        grow: [
          {
            grow: [
              "",
              Re,
              Pt,
              Lt
            ]
          }
        ],
        shrink: [
          {
            shrink: [
              "",
              Re,
              Pt,
              Lt
            ]
          }
        ],
        order: [
          {
            order: [
              Ku,
              "first",
              "last",
              "none",
              Pt,
              Lt
            ]
          }
        ],
        "grid-cols": [
          {
            "grid-cols": S()
          }
        ],
        "col-start-end": [
          {
            col: I()
          }
        ],
        "col-start": [
          {
            "col-start": T()
          }
        ],
        "col-end": [
          {
            "col-end": T()
          }
        ],
        "grid-rows": [
          {
            "grid-rows": S()
          }
        ],
        "row-start-end": [
          {
            row: I()
          }
        ],
        "row-start": [
          {
            "row-start": T()
          }
        ],
        "row-end": [
          {
            "row-end": T()
          }
        ],
        "grid-flow": [
          {
            "grid-flow": [
              "row",
              "col",
              "dense",
              "row-dense",
              "col-dense"
            ]
          }
        ],
        "auto-cols": [
          {
            "auto-cols": A()
          }
        ],
        "auto-rows": [
          {
            "auto-rows": A()
          }
        ],
        gap: [
          {
            gap: C()
          }
        ],
        "gap-x": [
          {
            "gap-x": C()
          }
        ],
        "gap-y": [
          {
            "gap-y": C()
          }
        ],
        "justify-content": [
          {
            justify: [
              ...D(),
              "normal"
            ]
          }
        ],
        "justify-items": [
          {
            "justify-items": [
              ...E(),
              "normal"
            ]
          }
        ],
        "justify-self": [
          {
            "justify-self": [
              "auto",
              ...E()
            ]
          }
        ],
        "align-content": [
          {
            content: [
              "normal",
              ...D()
            ]
          }
        ],
        "align-items": [
          {
            items: [
              ...E(),
              "baseline"
            ]
          }
        ],
        "align-self": [
          {
            self: [
              "auto",
              ...E(),
              "baseline"
            ]
          }
        ],
        "place-content": [
          {
            "place-content": D()
          }
        ],
        "place-items": [
          {
            "place-items": [
              ...E(),
              "baseline"
            ]
          }
        ],
        "place-self": [
          {
            "place-self": [
              "auto",
              ...E()
            ]
          }
        ],
        p: [
          {
            p: L()
          }
        ],
        px: [
          {
            px: L()
          }
        ],
        py: [
          {
            py: L()
          }
        ],
        ps: [
          {
            ps: L()
          }
        ],
        pe: [
          {
            pe: L()
          }
        ],
        pt: [
          {
            pt: L()
          }
        ],
        pr: [
          {
            pr: L()
          }
        ],
        pb: [
          {
            pb: L()
          }
        ],
        pl: [
          {
            pl: L()
          }
        ],
        m: [
          {
            m: k()
          }
        ],
        mx: [
          {
            mx: k()
          }
        ],
        my: [
          {
            my: k()
          }
        ],
        ms: [
          {
            ms: k()
          }
        ],
        me: [
          {
            me: k()
          }
        ],
        mt: [
          {
            mt: k()
          }
        ],
        mr: [
          {
            mr: k()
          }
        ],
        mb: [
          {
            mb: k()
          }
        ],
        ml: [
          {
            ml: k()
          }
        ],
        "space-x": [
          {
            "space-x": M()
          }
        ],
        "space-x-reverse": [
          "space-x-reverse"
        ],
        "space-y": [
          {
            "space-y": M()
          }
        ],
        "space-y-reverse": [
          "space-y-reverse"
        ],
        size: [
          {
            size: N()
          }
        ],
        w: [
          {
            w: [
              o,
              "screen",
              ...N()
            ]
          }
        ],
        "min-w": [
          {
            "min-w": [
              o,
              "screen",
              "none",
              ...N()
            ]
          }
        ],
        "max-w": [
          {
            "max-w": [
              o,
              "screen",
              "none",
              "prose",
              {
                screen: [
                  s
                ]
              },
              ...N()
            ]
          }
        ],
        h: [
          {
            h: [
              "screen",
              ...N()
            ]
          }
        ],
        "min-h": [
          {
            "min-h": [
              "screen",
              "none",
              ...N()
            ]
          }
        ],
        "max-h": [
          {
            "max-h": [
              "screen",
              ...N()
            ]
          }
        ],
        "font-size": [
          {
            text: [
              "base",
              e,
              K0,
              Zu
            ]
          }
        ],
        "font-smoothing": [
          "antialiased",
          "subpixel-antialiased"
        ],
        "font-style": [
          "italic",
          "not-italic"
        ],
        "font-weight": [
          {
            font: [
              r,
              Pt,
              oI
            ]
          }
        ],
        "font-stretch": [
          {
            "font-stretch": [
              "ultra-condensed",
              "extra-condensed",
              "condensed",
              "semi-condensed",
              "normal",
              "semi-expanded",
              "expanded",
              "extra-expanded",
              "ultra-expanded",
              sW,
              Lt
            ]
          }
        ],
        "font-family": [
          {
            font: [
              QKt,
              Lt,
              t
            ]
          }
        ],
        "fvn-normal": [
          "normal-nums"
        ],
        "fvn-ordinal": [
          "ordinal"
        ],
        "fvn-slashed-zero": [
          "slashed-zero"
        ],
        "fvn-figure": [
          "lining-nums",
          "oldstyle-nums"
        ],
        "fvn-spacing": [
          "proportional-nums",
          "tabular-nums"
        ],
        "fvn-fraction": [
          "diagonal-fractions",
          "stacked-fractions"
        ],
        tracking: [
          {
            tracking: [
              i,
              Pt,
              Lt
            ]
          }
        ],
        "line-clamp": [
          {
            "line-clamp": [
              Re,
              "none",
              Pt,
              oI
            ]
          }
        ],
        leading: [
          {
            leading: [
              Pt,
              Lt,
              a,
              l
            ]
          }
        ],
        "list-image": [
          {
            "list-image": [
              "none",
              Pt,
              Lt
            ]
          }
        ],
        "list-style-position": [
          {
            list: [
              "inside",
              "outside"
            ]
          }
        ],
        "list-style-type": [
          {
            list: [
              "disc",
              "decimal",
              "none",
              Pt,
              Lt
            ]
          }
        ],
        "text-alignment": [
          {
            text: [
              "left",
              "center",
              "right",
              "justify",
              "start",
              "end"
            ]
          }
        ],
        "placeholder-color": [
          {
            placeholder: R()
          }
        ],
        "text-color": [
          {
            text: R()
          }
        ],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline"
        ],
        "text-decoration-style": [
          {
            decoration: [
              ...z(),
              "wavy"
            ]
          }
        ],
        "text-decoration-thickness": [
          {
            decoration: [
              Re,
              "from-font",
              "auto",
              Pt,
              Zu
            ]
          }
        ],
        "text-decoration-color": [
          {
            decoration: R()
          }
        ],
        "underline-offset": [
          {
            "underline-offset": [
              Re,
              "auto",
              Pt,
              Lt
            ]
          }
        ],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case"
        ],
        "text-overflow": [
          "truncate",
          "text-ellipsis",
          "text-clip"
        ],
        "text-wrap": [
          {
            text: [
              "wrap",
              "nowrap",
              "balance",
              "pretty"
            ]
          }
        ],
        indent: [
          {
            indent: [
              "px",
              ...M()
            ]
          }
        ],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              Pt,
              Lt
            ]
          }
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces"
            ]
          }
        ],
        break: [
          {
            break: [
              "normal",
              "words",
              "all",
              "keep"
            ]
          }
        ],
        hyphens: [
          {
            hyphens: [
              "none",
              "manual",
              "auto"
            ]
          }
        ],
        content: [
          {
            content: [
              "none",
              Pt,
              Lt
            ]
          }
        ],
        "bg-attachment": [
          {
            bg: [
              "fixed",
              "local",
              "scroll"
            ]
          }
        ],
        "bg-clip": [
          {
            "bg-clip": [
              "border",
              "padding",
              "content",
              "text"
            ]
          }
        ],
        "bg-origin": [
          {
            "bg-origin": [
              "border",
              "padding",
              "content"
            ]
          }
        ],
        "bg-position": [
          {
            bg: [
              ...x(),
              tZt,
              KKt
            ]
          }
        ],
        "bg-repeat": [
          {
            bg: [
              "no-repeat",
              {
                repeat: [
                  "",
                  "x",
                  "y",
                  "space",
                  "round"
                ]
              }
            ]
          }
        ],
        "bg-size": [
          {
            bg: [
              "auto",
              "cover",
              "contain",
              eZt,
              jKt
            ]
          }
        ],
        "bg-image": [
          {
            bg: [
              "none",
              {
                linear: [
                  {
                    to: [
                      "t",
                      "tr",
                      "r",
                      "br",
                      "b",
                      "bl",
                      "l",
                      "tl"
                    ]
                  },
                  Ku,
                  Pt,
                  Lt
                ],
                radial: [
                  "",
                  Pt,
                  Lt
                ],
                conic: [
                  Ku,
                  Pt,
                  Lt
                ]
              },
              nZt,
              ZKt
            ]
          }
        ],
        "bg-color": [
          {
            bg: R()
          }
        ],
        "gradient-from-pos": [
          {
            from: $()
          }
        ],
        "gradient-via-pos": [
          {
            via: $()
          }
        ],
        "gradient-to-pos": [
          {
            to: $()
          }
        ],
        "gradient-from": [
          {
            from: R()
          }
        ],
        "gradient-via": [
          {
            via: R()
          }
        ],
        "gradient-to": [
          {
            to: R()
          }
        ],
        rounded: [
          {
            rounded: O()
          }
        ],
        "rounded-s": [
          {
            "rounded-s": O()
          }
        ],
        "rounded-e": [
          {
            "rounded-e": O()
          }
        ],
        "rounded-t": [
          {
            "rounded-t": O()
          }
        ],
        "rounded-r": [
          {
            "rounded-r": O()
          }
        ],
        "rounded-b": [
          {
            "rounded-b": O()
          }
        ],
        "rounded-l": [
          {
            "rounded-l": O()
          }
        ],
        "rounded-ss": [
          {
            "rounded-ss": O()
          }
        ],
        "rounded-se": [
          {
            "rounded-se": O()
          }
        ],
        "rounded-ee": [
          {
            "rounded-ee": O()
          }
        ],
        "rounded-es": [
          {
            "rounded-es": O()
          }
        ],
        "rounded-tl": [
          {
            "rounded-tl": O()
          }
        ],
        "rounded-tr": [
          {
            "rounded-tr": O()
          }
        ],
        "rounded-br": [
          {
            "rounded-br": O()
          }
        ],
        "rounded-bl": [
          {
            "rounded-bl": O()
          }
        ],
        "border-w": [
          {
            border: F()
          }
        ],
        "border-w-x": [
          {
            "border-x": F()
          }
        ],
        "border-w-y": [
          {
            "border-y": F()
          }
        ],
        "border-w-s": [
          {
            "border-s": F()
          }
        ],
        "border-w-e": [
          {
            "border-e": F()
          }
        ],
        "border-w-t": [
          {
            "border-t": F()
          }
        ],
        "border-w-r": [
          {
            "border-r": F()
          }
        ],
        "border-w-b": [
          {
            "border-b": F()
          }
        ],
        "border-w-l": [
          {
            "border-l": F()
          }
        ],
        "divide-x": [
          {
            "divide-x": F()
          }
        ],
        "divide-x-reverse": [
          "divide-x-reverse"
        ],
        "divide-y": [
          {
            "divide-y": F()
          }
        ],
        "divide-y-reverse": [
          "divide-y-reverse"
        ],
        "border-style": [
          {
            border: [
              ...z(),
              "hidden",
              "none"
            ]
          }
        ],
        "divide-style": [
          {
            divide: [
              ...z(),
              "hidden",
              "none"
            ]
          }
        ],
        "border-color": [
          {
            border: R()
          }
        ],
        "border-color-x": [
          {
            "border-x": R()
          }
        ],
        "border-color-y": [
          {
            "border-y": R()
          }
        ],
        "border-color-s": [
          {
            "border-s": R()
          }
        ],
        "border-color-e": [
          {
            "border-e": R()
          }
        ],
        "border-color-t": [
          {
            "border-t": R()
          }
        ],
        "border-color-r": [
          {
            "border-r": R()
          }
        ],
        "border-color-b": [
          {
            "border-b": R()
          }
        ],
        "border-color-l": [
          {
            "border-l": R()
          }
        ],
        "divide-color": [
          {
            divide: R()
          }
        ],
        "outline-style": [
          {
            outline: [
              ...z(),
              "none",
              "hidden"
            ]
          }
        ],
        "outline-offset": [
          {
            "outline-offset": [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "outline-w": [
          {
            outline: [
              "",
              Re,
              K0,
              Zu
            ]
          }
        ],
        "outline-color": [
          {
            outline: [
              n
            ]
          }
        ],
        shadow: [
          {
            shadow: [
              "",
              "none",
              c,
              rZt,
              JKt
            ]
          }
        ],
        "shadow-color": [
          {
            shadow: R()
          }
        ],
        "inset-shadow": [
          {
            "inset-shadow": [
              "none",
              Pt,
              Lt,
              h
            ]
          }
        ],
        "inset-shadow-color": [
          {
            "inset-shadow": R()
          }
        ],
        "ring-w": [
          {
            ring: F()
          }
        ],
        "ring-w-inset": [
          "ring-inset"
        ],
        "ring-color": [
          {
            ring: R()
          }
        ],
        "ring-offset-w": [
          {
            "ring-offset": [
              Re,
              Zu
            ]
          }
        ],
        "ring-offset-color": [
          {
            "ring-offset": R()
          }
        ],
        "inset-ring-w": [
          {
            "inset-ring": F()
          }
        ],
        "inset-ring-color": [
          {
            "inset-ring": R()
          }
        ],
        opacity: [
          {
            opacity: [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "mix-blend": [
          {
            "mix-blend": [
              ...V(),
              "plus-darker",
              "plus-lighter"
            ]
          }
        ],
        "bg-blend": [
          {
            "bg-blend": V()
          }
        ],
        filter: [
          {
            filter: [
              "",
              "none",
              Pt,
              Lt
            ]
          }
        ],
        blur: [
          {
            blur: U()
          }
        ],
        brightness: [
          {
            brightness: [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        contrast: [
          {
            contrast: [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "drop-shadow": [
          {
            "drop-shadow": [
              "",
              "none",
              f,
              Pt,
              Lt
            ]
          }
        ],
        grayscale: [
          {
            grayscale: [
              "",
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "hue-rotate": [
          {
            "hue-rotate": [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        invert: [
          {
            invert: [
              "",
              Re,
              Pt,
              Lt
            ]
          }
        ],
        saturate: [
          {
            saturate: [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        sepia: [
          {
            sepia: [
              "",
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-filter": [
          {
            "backdrop-filter": [
              "",
              "none",
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-blur": [
          {
            "backdrop-blur": U()
          }
        ],
        "backdrop-brightness": [
          {
            "backdrop-brightness": [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-contrast": [
          {
            "backdrop-contrast": [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-grayscale": [
          {
            "backdrop-grayscale": [
              "",
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-hue-rotate": [
          {
            "backdrop-hue-rotate": [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-invert": [
          {
            "backdrop-invert": [
              "",
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-opacity": [
          {
            "backdrop-opacity": [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-saturate": [
          {
            "backdrop-saturate": [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "backdrop-sepia": [
          {
            "backdrop-sepia": [
              "",
              Re,
              Pt,
              Lt
            ]
          }
        ],
        "border-collapse": [
          {
            border: [
              "collapse",
              "separate"
            ]
          }
        ],
        "border-spacing": [
          {
            "border-spacing": M()
          }
        ],
        "border-spacing-x": [
          {
            "border-spacing-x": M()
          }
        ],
        "border-spacing-y": [
          {
            "border-spacing-y": M()
          }
        ],
        "table-layout": [
          {
            table: [
              "auto",
              "fixed"
            ]
          }
        ],
        caption: [
          {
            caption: [
              "top",
              "bottom"
            ]
          }
        ],
        transition: [
          {
            transition: [
              "",
              "all",
              "colors",
              "opacity",
              "shadow",
              "transform",
              "none",
              Pt,
              Lt
            ]
          }
        ],
        "transition-behavior": [
          {
            transition: [
              "normal",
              "discrete"
            ]
          }
        ],
        duration: [
          {
            duration: [
              Re,
              "initial",
              Pt,
              Lt
            ]
          }
        ],
        ease: [
          {
            ease: [
              "linear",
              "initial",
              v,
              Pt,
              Lt
            ]
          }
        ],
        delay: [
          {
            delay: [
              Re,
              Pt,
              Lt
            ]
          }
        ],
        animate: [
          {
            animate: [
              "none",
              m,
              Pt,
              Lt
            ]
          }
        ],
        backface: [
          {
            backface: [
              "hidden",
              "visible"
            ]
          }
        ],
        perspective: [
          {
            perspective: [
              p,
              Pt,
              Lt
            ]
          }
        ],
        "perspective-origin": [
          {
            "perspective-origin": X()
          }
        ],
        rotate: [
          {
            rotate: at()
          }
        ],
        "rotate-x": [
          {
            "rotate-x": at()
          }
        ],
        "rotate-y": [
          {
            "rotate-y": at()
          }
        ],
        "rotate-z": [
          {
            "rotate-z": at()
          }
        ],
        scale: [
          {
            scale: pt()
          }
        ],
        "scale-x": [
          {
            "scale-x": pt()
          }
        ],
        "scale-y": [
          {
            "scale-y": pt()
          }
        ],
        "scale-z": [
          {
            "scale-z": pt()
          }
        ],
        "scale-3d": [
          "scale-3d"
        ],
        skew: [
          {
            skew: it()
          }
        ],
        "skew-x": [
          {
            "skew-x": it()
          }
        ],
        "skew-y": [
          {
            "skew-y": it()
          }
        ],
        transform: [
          {
            transform: [
              Pt,
              Lt,
              "",
              "none",
              "gpu",
              "cpu"
            ]
          }
        ],
        "transform-origin": [
          {
            origin: X()
          }
        ],
        "transform-style": [
          {
            transform: [
              "3d",
              "flat"
            ]
          }
        ],
        translate: [
          {
            translate: et()
          }
        ],
        "translate-x": [
          {
            "translate-x": et()
          }
        ],
        "translate-y": [
          {
            "translate-y": et()
          }
        ],
        "translate-z": [
          {
            "translate-z": et()
          }
        ],
        "translate-none": [
          "translate-none"
        ],
        accent: [
          {
            accent: R()
          }
        ],
        appearance: [
          {
            appearance: [
              "none",
              "auto"
            ]
          }
        ],
        "caret-color": [
          {
            caret: R()
          }
        ],
        "color-scheme": [
          {
            scheme: [
              "normal",
              "dark",
              "light",
              "light-dark",
              "only-dark",
              "only-light"
            ]
          }
        ],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              Pt,
              Lt
            ]
          }
        ],
        "field-sizing": [
          {
            "field-sizing": [
              "fixed",
              "content"
            ]
          }
        ],
        "pointer-events": [
          {
            "pointer-events": [
              "auto",
              "none"
            ]
          }
        ],
        resize: [
          {
            resize: [
              "none",
              "",
              "y",
              "x"
            ]
          }
        ],
        "scroll-behavior": [
          {
            scroll: [
              "auto",
              "smooth"
            ]
          }
        ],
        "scroll-m": [
          {
            "scroll-m": M()
          }
        ],
        "scroll-mx": [
          {
            "scroll-mx": M()
          }
        ],
        "scroll-my": [
          {
            "scroll-my": M()
          }
        ],
        "scroll-ms": [
          {
            "scroll-ms": M()
          }
        ],
        "scroll-me": [
          {
            "scroll-me": M()
          }
        ],
        "scroll-mt": [
          {
            "scroll-mt": M()
          }
        ],
        "scroll-mr": [
          {
            "scroll-mr": M()
          }
        ],
        "scroll-mb": [
          {
            "scroll-mb": M()
          }
        ],
        "scroll-ml": [
          {
            "scroll-ml": M()
          }
        ],
        "scroll-p": [
          {
            "scroll-p": M()
          }
        ],
        "scroll-px": [
          {
            "scroll-px": M()
          }
        ],
        "scroll-py": [
          {
            "scroll-py": M()
          }
        ],
        "scroll-ps": [
          {
            "scroll-ps": M()
          }
        ],
        "scroll-pe": [
          {
            "scroll-pe": M()
          }
        ],
        "scroll-pt": [
          {
            "scroll-pt": M()
          }
        ],
        "scroll-pr": [
          {
            "scroll-pr": M()
          }
        ],
        "scroll-pb": [
          {
            "scroll-pb": M()
          }
        ],
        "scroll-pl": [
          {
            "scroll-pl": M()
          }
        ],
        "snap-align": [
          {
            snap: [
              "start",
              "end",
              "center",
              "align-none"
            ]
          }
        ],
        "snap-stop": [
          {
            snap: [
              "normal",
              "always"
            ]
          }
        ],
        "snap-type": [
          {
            snap: [
              "none",
              "x",
              "y",
              "both"
            ]
          }
        ],
        "snap-strictness": [
          {
            snap: [
              "mandatory",
              "proximity"
            ]
          }
        ],
        touch: [
          {
            touch: [
              "auto",
              "none",
              "manipulation"
            ]
          }
        ],
        "touch-x": [
          {
            "touch-pan": [
              "x",
              "left",
              "right"
            ]
          }
        ],
        "touch-y": [
          {
            "touch-pan": [
              "y",
              "up",
              "down"
            ]
          }
        ],
        "touch-pz": [
          "touch-pinch-zoom"
        ],
        select: [
          {
            select: [
              "none",
              "text",
              "all",
              "auto"
            ]
          }
        ],
        "will-change": [
          {
            "will-change": [
              "auto",
              "scroll",
              "contents",
              "transform",
              Pt,
              Lt
            ]
          }
        ],
        fill: [
          {
            fill: [
              "none",
              ...R()
            ]
          }
        ],
        "stroke-w": [
          {
            stroke: [
              Re,
              K0,
              Zu,
              oI
            ]
          }
        ],
        stroke: [
          {
            stroke: [
              "none",
              ...R()
            ]
          }
        ],
        "forced-color-adjust": [
          {
            "forced-color-adjust": [
              "auto",
              "none"
            ]
          }
        ]
      },
      conflictingClassGroups: {
        overflow: [
          "overflow-x",
          "overflow-y"
        ],
        overscroll: [
          "overscroll-x",
          "overscroll-y"
        ],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left"
        ],
        "inset-x": [
          "right",
          "left"
        ],
        "inset-y": [
          "top",
          "bottom"
        ],
        flex: [
          "basis",
          "grow",
          "shrink"
        ],
        gap: [
          "gap-x",
          "gap-y"
        ],
        p: [
          "px",
          "py",
          "ps",
          "pe",
          "pt",
          "pr",
          "pb",
          "pl"
        ],
        px: [
          "pr",
          "pl"
        ],
        py: [
          "pt",
          "pb"
        ],
        m: [
          "mx",
          "my",
          "ms",
          "me",
          "mt",
          "mr",
          "mb",
          "ml"
        ],
        mx: [
          "mr",
          "ml"
        ],
        my: [
          "mt",
          "mb"
        ],
        size: [
          "w",
          "h"
        ],
        "font-size": [
          "leading"
        ],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction"
        ],
        "fvn-ordinal": [
          "fvn-normal"
        ],
        "fvn-slashed-zero": [
          "fvn-normal"
        ],
        "fvn-figure": [
          "fvn-normal"
        ],
        "fvn-spacing": [
          "fvn-normal"
        ],
        "fvn-fraction": [
          "fvn-normal"
        ],
        "line-clamp": [
          "display",
          "overflow"
        ],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-s": [
          "rounded-ss",
          "rounded-es"
        ],
        "rounded-e": [
          "rounded-se",
          "rounded-ee"
        ],
        "rounded-t": [
          "rounded-tl",
          "rounded-tr"
        ],
        "rounded-r": [
          "rounded-tr",
          "rounded-br"
        ],
        "rounded-b": [
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-l": [
          "rounded-tl",
          "rounded-bl"
        ],
        "border-spacing": [
          "border-spacing-x",
          "border-spacing-y"
        ],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l"
        ],
        "border-w-x": [
          "border-w-r",
          "border-w-l"
        ],
        "border-w-y": [
          "border-w-t",
          "border-w-b"
        ],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l"
        ],
        "border-color-x": [
          "border-color-r",
          "border-color-l"
        ],
        "border-color-y": [
          "border-color-t",
          "border-color-b"
        ],
        translate: [
          "translate-x",
          "translate-y",
          "translate-none"
        ],
        "translate-none": [
          "translate",
          "translate-x",
          "translate-y",
          "translate-z"
        ],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml"
        ],
        "scroll-mx": [
          "scroll-mr",
          "scroll-ml"
        ],
        "scroll-my": [
          "scroll-mt",
          "scroll-mb"
        ],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl"
        ],
        "scroll-px": [
          "scroll-pr",
          "scroll-pl"
        ],
        "scroll-py": [
          "scroll-pt",
          "scroll-pb"
        ],
        touch: [
          "touch-x",
          "touch-y",
          "touch-pz"
        ],
        "touch-x": [
          "touch"
        ],
        "touch-y": [
          "touch"
        ],
        "touch-pz": [
          "touch"
        ]
      },
      conflictingClassGroupModifiers: {
        "font-size": [
          "leading"
        ]
      },
      orderSensitiveModifiers: [
        "before",
        "after",
        "placeholder",
        "file",
        "marker",
        "selection",
        "first-line",
        "first-letter",
        "backdrop",
        "*",
        "**"
      ]
    };
  }, cZt = OKt(uZt);
  function Pr(...n) {
    return cZt(rtt(n));
  }
  function vy(n, t) {
    const e = typeof n == "string" && !t ? `${n}Context` : t, r = Symbol(e);
    return [
      (i) => {
        const a = mW(r, i);
        if (a || a === null) return a;
        throw new Error(`Injection \`${r.toString()}\` not found. Component must be used within ${Array.isArray(n) ? `one of the following components: ${n.join(", ")}` : `\`${n}\``}`);
      },
      (i) => (Vtt(r, i), i)
    ];
  }
  function ftt(n, t, e) {
    const r = e.originalEvent.target, i = new CustomEvent(n, {
      bubbles: false,
      cancelable: true,
      detail: e
    });
    t && r.addEventListener(n, t, {
      once: true
    }), r.dispatchEvent(i);
  }
  function dtt(n) {
    return Ftt() ? (Btt(n), true) : false;
  }
  function hZt(n) {
    let t = false, e;
    const r = Ik(true);
    return (...i) => (t || (e = r.run(() => n(...i)), t = true), e);
  }
  function fZt(n) {
    let t = 0, e, r;
    const i = () => {
      t -= 1, r && t <= 0 && (r.stop(), e = void 0, r = void 0);
    };
    return (...a) => (t += 1, e || (r = Ik(true), e = r.run(() => n(...a))), dtt(i), e);
  }
  function QN(n) {
    return typeof n == "function" ? n() : J(n);
  }
  const Mh = typeof window < "u" && typeof document < "u";
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const dZt = (n) => typeof n < "u", pZt = Object.prototype.toString, gZt = (n) => pZt.call(n) === "[object Object]", vZt = () => {
  }, oW = mZt();
  function mZt() {
    var n, t;
    return Mh && ((n = window == null ? void 0 : window.navigator) == null ? void 0 : n.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
  }
  function yZt(n) {
    return Zi();
  }
  function xZt(n, t) {
    yZt() && Ott(n, t);
  }
  function my(n) {
    var t;
    const e = QN(n);
    return (t = e == null ? void 0 : e.$el) != null ? t : e;
  }
  const tL = Mh ? window : void 0;
  function ptt(...n) {
    let t, e, r, i;
    if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([e, r, i] = n, t = tL) : [t, e, r, i] = n, !t) return vZt;
    Array.isArray(e) || (e = [
      e
    ]), Array.isArray(r) || (r = [
      r
    ]);
    const a = [], s = () => {
      a.forEach((c) => c()), a.length = 0;
    }, o = (c, h, f, d) => (c.addEventListener(h, f, d), () => c.removeEventListener(h, f, d)), l = Yr(() => [
      my(t),
      QN(i)
    ], ([c, h]) => {
      if (s(), !c) return;
      const f = gZt(h) ? {
        ...h
      } : h;
      a.push(...e.flatMap((d) => r.map((p) => o(c, d, p, f))));
    }, {
      immediate: true,
      flush: "post"
    }), u = () => {
      l(), s();
    };
    return dtt(u), u;
  }
  function bZt(n) {
    return typeof n == "function" ? n : typeof n == "string" ? (t) => t.key === n : Array.isArray(n) ? (t) => n.includes(t.key) : () => true;
  }
  function _Zt(...n) {
    let t, e, r = {};
    n.length === 3 ? (t = n[0], e = n[1], r = n[2]) : n.length === 2 ? typeof n[1] == "object" ? (t = true, e = n[0], r = n[1]) : (t = n[0], e = n[1]) : (t = true, e = n[0]);
    const { target: i = tL, eventName: a = "keydown", passive: s = false, dedupe: o = false } = r, l = bZt(t);
    return ptt(i, a, (u) => {
      u.repeat && QN(o) || l(u) && e(u);
    }, s);
  }
  function wZt() {
    const n = ue(false), t = Zi();
    return t && gd(() => {
      n.value = true;
    }, t), n;
  }
  function SZt(n) {
    return JSON.parse(JSON.stringify(n));
  }
  function eL(n, t, e, r = {}) {
    var i, a, s;
    const { clone: o = false, passive: l = false, eventName: u, deep: c = false, defaultValue: h, shouldEmit: f } = r, d = Zi(), p = e || (d == null ? void 0 : d.emit) || ((i = d == null ? void 0 : d.$emit) == null ? void 0 : i.bind(d)) || ((s = (a = d == null ? void 0 : d.proxy) == null ? void 0 : a.$emit) == null ? void 0 : s.bind(d == null ? void 0 : d.proxy));
    let g = u;
    t || (t = "modelValue"), g = g || `update:${t.toString()}`;
    const v = (x) => o ? typeof o == "function" ? o(x) : SZt(x) : x, m = () => dZt(n[t]) ? v(n[t]) : h, y = (x) => {
      f ? f(x) && p(g, x) : p(g, x);
    };
    if (l) {
      const x = m(), b = ue(x);
      let _ = false;
      return Yr(() => n[t], (w) => {
        _ || (_ = true, b.value = v(w), Jo(() => _ = false));
      }), Yr(b, (w) => {
        !_ && (w !== n[t] || c) && y(w);
      }, {
        deep: c
      }), b;
    } else return ke({
      get() {
        return m();
      },
      set(x) {
        y(x);
      }
    });
  }
  function nL(n) {
    return n ? n.flatMap((t) => t.type === kg ? nL(t.children) : [
      t
    ]) : [];
  }
  function Js() {
    let n = document.activeElement;
    if (n == null) return null;
    for (; n != null && n.shadowRoot != null && n.shadowRoot.activeElement != null; ) n = n.shadowRoot.activeElement;
    return n;
  }
  function lI(n) {
    if (n === null || typeof n != "object") return false;
    const t = Object.getPrototypeOf(n);
    return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in n ? false : Symbol.toStringTag in n ? Object.prototype.toString.call(n) === "[object Module]" : true;
  }
  function Tk(n, t, e = ".", r) {
    if (!lI(t)) return Tk(n, {}, e);
    const i = Object.assign({}, t);
    for (const a in n) {
      if (a === "__proto__" || a === "constructor") continue;
      const s = n[a];
      s != null && (Array.isArray(s) && Array.isArray(i[a]) ? i[a] = [
        ...s,
        ...i[a]
      ] : lI(s) && lI(i[a]) ? i[a] = Tk(s, i[a], (e ? `${e}.` : "") + a.toString()) : i[a] = s);
    }
    return i;
  }
  function CZt(n) {
    return (...t) => t.reduce((e, r) => Tk(e, r, ""), {});
  }
  const TZt = CZt(), [rL, pte] = vy("ConfigProvider");
  let IZt = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", AZt = (n = 21) => {
    let t = "", e = n;
    for (; e--; ) t += IZt[Math.random() * 64 | 0];
    return t;
  };
  const kZt = fZt(() => {
    const n = ue(/* @__PURE__ */ new Map()), t = ue(), e = ke(() => {
      for (const s of n.value.values()) if (s) return true;
      return false;
    }), r = rL({
      scrollBody: ue(true)
    });
    let i = null;
    const a = () => {
      document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", oW && (i == null ? void 0 : i()), t.value = void 0;
    };
    return Yr(e, (s, o) => {
      var l;
      if (!Mh) return;
      if (!s) {
        o && a();
        return;
      }
      t.value === void 0 && (t.value = document.body.style.overflow);
      const u = window.innerWidth - document.documentElement.clientWidth, c = {
        padding: u,
        margin: 0
      }, h = (l = r.scrollBody) != null && l.value ? typeof r.scrollBody.value == "object" ? TZt({
        padding: r.scrollBody.value.padding === true ? u : r.scrollBody.value.padding,
        margin: r.scrollBody.value.margin === true ? u : r.scrollBody.value.margin
      }, c) : c : {
        padding: 0,
        margin: 0
      };
      u > 0 && (document.body.style.paddingRight = typeof h.padding == "number" ? `${h.padding}px` : String(h.padding), document.body.style.marginRight = typeof h.margin == "number" ? `${h.margin}px` : String(h.margin), document.body.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), oW && (i = ptt(document, "touchmove", (f) => EZt(f), {
        passive: false
      })), Jo(() => {
        document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
      });
    }, {
      immediate: true,
      flush: "sync"
    }), n;
  });
  function DZt(n) {
    const t = AZt(6), e = kZt();
    e.value.set(t, n);
    const r = ke({
      get: () => e.value.get(t) ?? false,
      set: (i) => e.value.set(t, i)
    });
    return xZt(() => {
      e.value.delete(t);
    }), r;
  }
  function gtt(n) {
    const t = window.getComputedStyle(n);
    if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && n.clientWidth < n.scrollWidth || t.overflowY === "auto" && n.clientHeight < n.scrollHeight) return true;
    {
      const e = n.parentNode;
      return !e || e.tagName === "BODY" ? false : gtt(e);
    }
  }
  function EZt(n) {
    const t = n || window.event, e = t.target;
    return e instanceof Element && gtt(e) ? false : t.touches.length > 1 ? true : (t.preventDefault && t.cancelable && t.preventDefault(), false);
  }
  function vtt(n) {
    const t = rL({
      dir: ue("ltr")
    });
    return ke(() => {
      var e;
      return (n == null ? void 0 : n.value) || ((e = t.dir) == null ? void 0 : e.value) || "ltr";
    });
  }
  function Bw(n) {
    const t = Zi(), e = t == null ? void 0 : t.type.emits, r = {};
    return e != null && e.length || console.warn(`No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`), e == null ? void 0 : e.forEach((i) => {
      r[Rtt(yW(i))] = (...a) => n(i, ...a);
    }), r;
  }
  function iL(n) {
    const t = Zi(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((i, a) => {
      const s = (t == null ? void 0 : t.type.props[a]).default;
      return s !== void 0 && (i[a] = s), i;
    }, {}), r = Mtt(n);
    return ke(() => {
      const i = {}, a = (t == null ? void 0 : t.vnode.props) ?? {};
      return Object.keys(a).forEach((s) => {
        i[yW(s)] = a[s];
      }), Object.keys({
        ...e,
        ...i
      }).reduce((s, o) => (r.value[o] !== void 0 && (s[o] = r.value[o]), s), {});
    });
  }
  function aL(n, t) {
    const e = iL(n), r = t ? Bw(t) : {};
    return ke(() => ({
      ...e.value,
      ...r
    }));
  }
  function zi() {
    const n = Zi(), t = ue(), e = ke(() => {
      var s, o;
      return [
        "#text",
        "#comment"
      ].includes((s = t.value) == null ? void 0 : s.$el.nodeName) ? (o = t.value) == null ? void 0 : o.$el.nextElementSibling : my(t);
    }), r = Object.assign({}, n.exposed), i = {};
    for (const s in n.props) Object.defineProperty(i, s, {
      enumerable: true,
      configurable: true,
      get: () => n.props[s]
    });
    if (Object.keys(r).length > 0) for (const s in r) Object.defineProperty(i, s, {
      enumerable: true,
      configurable: true,
      get: () => r[s]
    });
    Object.defineProperty(i, "$el", {
      enumerable: true,
      configurable: true,
      get: () => n.vnode.el
    }), n.exposed = i;
    function a(s) {
      t.value = s, !(s instanceof Element || !s) && (Object.defineProperty(i, "$el", {
        enumerable: true,
        configurable: true,
        get: () => s.$el
      }), n.exposed = i);
    }
    return {
      forwardRef: a,
      currentRef: t,
      currentElement: e
    };
  }
  var MZt = function(n) {
    if (typeof document > "u") return null;
    var t = Array.isArray(n) ? n[0] : n;
    return t.ownerDocument.body;
  }, of = /* @__PURE__ */ new WeakMap(), Z0 = /* @__PURE__ */ new WeakMap(), J0 = {}, uI = 0, mtt = function(n) {
    return n && (n.host || mtt(n.parentNode));
  }, RZt = function(n, t) {
    return t.map(function(e) {
      if (n.contains(e)) return e;
      var r = mtt(e);
      return r && n.contains(r) ? r : (console.error("aria-hidden", e, "in not contained inside", n, ". Doing nothing"), null);
    }).filter(function(e) {
      return !!e;
    });
  }, NZt = function(n, t, e, r) {
    var i = RZt(t, Array.isArray(n) ? n : [
      n
    ]);
    J0[e] || (J0[e] = /* @__PURE__ */ new WeakMap());
    var a = J0[e], s = [], o = /* @__PURE__ */ new Set(), l = new Set(i), u = function(h) {
      !h || o.has(h) || (o.add(h), u(h.parentNode));
    };
    i.forEach(u);
    var c = function(h) {
      !h || l.has(h) || Array.prototype.forEach.call(h.children, function(f) {
        if (o.has(f)) c(f);
        else try {
          var d = f.getAttribute(r), p = d !== null && d !== "false", g = (of.get(f) || 0) + 1, v = (a.get(f) || 0) + 1;
          of.set(f, g), a.set(f, v), s.push(f), g === 1 && p && Z0.set(f, true), v === 1 && f.setAttribute(e, "true"), p || f.setAttribute(r, "true");
        } catch (m) {
          console.error("aria-hidden: cannot operate on ", f, m);
        }
      });
    };
    return c(t), o.clear(), uI++, function() {
      s.forEach(function(h) {
        var f = of.get(h) - 1, d = a.get(h) - 1;
        of.set(h, f), a.set(h, d), f || (Z0.has(h) || h.removeAttribute(r), Z0.delete(h)), d || h.removeAttribute(e);
      }), uI--, uI || (of = /* @__PURE__ */ new WeakMap(), of = /* @__PURE__ */ new WeakMap(), Z0 = /* @__PURE__ */ new WeakMap(), J0 = {});
    };
  }, LZt = function(n, t, e) {
    e === void 0 && (e = "data-aria-hidden");
    var r = Array.from(Array.isArray(n) ? n : [
      n
    ]), i = MZt(n);
    return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), NZt(r, i, e, "aria-hidden")) : function() {
      return null;
    };
  };
  function PZt(n) {
    let t;
    Yr(() => my(n), (e) => {
      e ? t = LZt(e) : t && t();
    }), d1(() => {
      t && t();
    });
  }
  let $Zt = 0;
  function f1(n, t = "radix") {
    const e = rL({
      useId: void 0
    });
    return hL ? `${t}-${hL()}` : e.useId ? `${t}-${e.useId()}` : `${t}-${++$Zt}`;
  }
  function OZt(n, t) {
    const e = ue(n);
    function r(i) {
      return t[e.value][i] ?? e.value;
    }
    return {
      state: e,
      dispatch: (i) => {
        e.value = r(i);
      }
    };
  }
  const sL = he({
    name: "PrimitiveSlot",
    inheritAttrs: false,
    setup(n, { attrs: t, slots: e }) {
      return () => {
        var r, i;
        if (!e.default) return null;
        const a = nL(e.default()), s = a.findIndex((c) => c.type !== Ntt);
        if (s === -1) return a;
        const o = a[s];
        (r = o.props) == null || delete r.ref;
        const l = o.props ? Li(t, o.props) : t;
        t.class && (i = o.props) != null && i.class && delete o.props.class;
        const u = Ltt(o, l);
        for (const c in l) c.startsWith("on") && (u.props || (u.props = {}), u.props[c] = l[c]);
        return a.length === 1 ? u : (a[s] = u, a);
      };
    }
  }), $a = he({
    name: "Primitive",
    inheritAttrs: false,
    props: {
      asChild: {
        type: Boolean,
        default: false
      },
      as: {
        type: [
          String,
          Object
        ],
        default: "div"
      }
    },
    setup(n, { attrs: t, slots: e }) {
      const r = n.asChild ? "template" : n.as;
      return typeof r == "string" && [
        "area",
        "img",
        "input"
      ].includes(r) ? () => Qa(r, t) : r !== "template" ? () => Qa(n.as, t, {
        default: e.default
      }) : () => Qa(sL, t, {
        default: e.default
      });
    }
  });
  function ytt() {
    const n = ue(), t = ke(() => {
      var e, r;
      return [
        "#text",
        "#comment"
      ].includes((e = n.value) == null ? void 0 : e.$el.nodeName) ? (r = n.value) == null ? void 0 : r.$el.nextElementSibling : my(n);
    });
    return {
      primitiveElement: n,
      currentElement: t
    };
  }
  function FZt(n, t) {
    var e;
    const r = ue({}), i = ue("none"), a = ue(n), s = n.value ? "mounted" : "unmounted";
    let o;
    const l = ((e = t.value) == null ? void 0 : e.ownerDocument.defaultView) ?? tL, { state: u, dispatch: c } = OZt(s, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    }), h = (v) => {
      var m;
      if (Mh) {
        const y = new CustomEvent(v, {
          bubbles: false,
          cancelable: false
        });
        (m = t.value) == null || m.dispatchEvent(y);
      }
    };
    Yr(n, async (v, m) => {
      var y;
      const x = m !== v;
      if (await Jo(), x) {
        const b = i.value, _ = Q0(t.value);
        v ? (c("MOUNT"), h("enter"), _ === "none" && h("after-enter")) : _ === "none" || ((y = r.value) == null ? void 0 : y.display) === "none" ? (c("UNMOUNT"), h("leave"), h("after-leave")) : m && b !== _ ? (c("ANIMATION_OUT"), h("leave")) : (c("UNMOUNT"), h("after-leave"));
      }
    }, {
      immediate: true
    });
    const f = (v) => {
      const m = Q0(t.value), y = m.includes(v.animationName), x = u.value === "mounted" ? "enter" : "leave";
      if (v.target === t.value && y && (h(`after-${x}`), c("ANIMATION_END"), !a.value)) {
        const b = t.value.style.animationFillMode;
        t.value.style.animationFillMode = "forwards", o = l == null ? void 0 : l.setTimeout(() => {
          var _;
          ((_ = t.value) == null ? void 0 : _.style.animationFillMode) === "forwards" && (t.value.style.animationFillMode = b);
        });
      }
      v.target === t.value && m === "none" && c("ANIMATION_END");
    }, d = (v) => {
      v.target === t.value && (i.value = Q0(t.value));
    }, p = Yr(t, (v, m) => {
      v ? (r.value = getComputedStyle(v), v.addEventListener("animationstart", d), v.addEventListener("animationcancel", f), v.addEventListener("animationend", f)) : (c("ANIMATION_END"), o !== void 0 && (l == null ? void 0 : l.clearTimeout(o)), m == null ? void 0 : m.removeEventListener("animationstart", d), m == null ? void 0 : m.removeEventListener("animationcancel", f), m == null ? void 0 : m.removeEventListener("animationend", f));
    }, {
      immediate: true
    }), g = Yr(u, () => {
      const v = Q0(t.value);
      i.value = u.value === "mounted" ? v : "none";
    });
    return d1(() => {
      p(), g();
    }), {
      isPresent: ke(() => [
        "mounted",
        "unmountSuspended"
      ].includes(u.value))
    };
  }
  function Q0(n) {
    return n && getComputedStyle(n).animationName || "none";
  }
  const oL = he({
    name: "Presence",
    props: {
      present: {
        type: Boolean,
        required: true
      },
      forceMount: {
        type: Boolean
      }
    },
    slots: {},
    setup(n, { slots: t, expose: e }) {
      var r;
      const { present: i, forceMount: a } = Dv(n), s = ue(), { isPresent: o } = FZt(i, s);
      e({
        present: o
      });
      let l = t.default({
        present: o
      });
      l = nL(l || []);
      const u = Zi();
      if (l && (l == null ? void 0 : l.length) > 1) {
        const c = (r = u == null ? void 0 : u.parent) != null && r.type.name ? `<${u.parent.type.name} />` : "component";
        throw new Error([
          `Detected an invalid children for \`${c}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((h) => `  - ${h}`).join(`
`)
        ].join(`
`));
      }
      return () => a.value || i.value || o.value ? Qa(t.default({
        present: o
      })[0], {
        ref: (c) => {
          const h = my(c);
          return typeof (h == null ? void 0 : h.hasAttribute) > "u" || (h != null && h.hasAttribute("data-radix-popper-content-wrapper") ? s.value = h.firstElementChild : s.value = h), h;
        }
      }) : null;
    }
  }), [_u, BZt] = vy("DialogRoot"), zZt = he({
    inheritAttrs: false,
    __name: "DialogRoot",
    props: {
      open: {
        type: Boolean,
        default: void 0
      },
      defaultOpen: {
        type: Boolean,
        default: false
      },
      modal: {
        type: Boolean,
        default: true
      }
    },
    emits: [
      "update:open"
    ],
    setup(n, { emit: t }) {
      const e = n, r = eL(e, "open", t, {
        defaultValue: e.defaultOpen,
        passive: e.open === void 0
      }), i = ue(), a = ue(), { modal: s } = Dv(e);
      return BZt({
        open: r,
        modal: s,
        openModal: () => {
          r.value = true;
        },
        onOpenChange: (o) => {
          r.value = o;
        },
        onOpenToggle: () => {
          r.value = !r.value;
        },
        contentId: "",
        titleId: "",
        descriptionId: "",
        triggerElement: i,
        contentElement: a
      }), (o, l) => De(o.$slots, "default", {
        open: J(r)
      });
    }
  }), VZt = he({
    __name: "Teleport",
    props: {
      to: {
        default: "body"
      },
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(n) {
      const t = wZt();
      return (e, r) => J(t) || e.forceMount ? (fe(), Je($tt, {
        key: 0,
        to: e.to,
        disabled: e.disabled
      }, [
        De(e.$slots, "default")
      ], 8, [
        "to",
        "disabled"
      ])) : Dg("", true);
    }
  }), GZt = he({
    __name: "DialogPortal",
    props: {
      to: {},
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Je(J(VZt), Ak(kk(t)), {
        default: Rt(() => [
          De(e.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), WZt = "dismissableLayer.pointerDownOutside", UZt = "dismissableLayer.focusOutside";
  function xtt(n, t) {
    const e = t.closest("[data-dismissable-layer]"), r = n.dataset.dismissableLayer === "" ? n : n.querySelector("[data-dismissable-layer]"), i = Array.from(n.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
    return !!(e && r === e || i.indexOf(r) < i.indexOf(e));
  }
  function HZt(n, t) {
    var e;
    const r = ((e = t == null ? void 0 : t.value) == null ? void 0 : e.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = ue(false), a = ue(() => {
    });
    return Gc((s) => {
      if (!Mh) return;
      const o = async (u) => {
        const c = u.target;
        if (t != null && t.value) {
          if (xtt(t.value, c)) {
            i.value = false;
            return;
          }
          if (u.target && !i.value) {
            let h = function() {
              ftt(WZt, n, f);
            };
            const f = {
              originalEvent: u
            };
            u.pointerType === "touch" ? (r.removeEventListener("click", a.value), a.value = h, r.addEventListener("click", a.value, {
              once: true
            })) : h();
          } else r.removeEventListener("click", a.value);
          i.value = false;
        }
      }, l = window.setTimeout(() => {
        r.addEventListener("pointerdown", o);
      }, 0);
      s(() => {
        window.clearTimeout(l), r.removeEventListener("pointerdown", o), r.removeEventListener("click", a.value);
      });
    }), {
      onPointerDownCapture: () => i.value = true
    };
  }
  function XZt(n, t) {
    var e;
    const r = ((e = t == null ? void 0 : t.value) == null ? void 0 : e.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = ue(false);
    return Gc((a) => {
      if (!Mh) return;
      const s = async (o) => {
        t != null && t.value && (await Jo(), !(!t.value || xtt(t.value, o.target)) && o.target && !i.value && ftt(UZt, n, {
          originalEvent: o
        }));
      };
      r.addEventListener("focusin", s), a(() => r.removeEventListener("focusin", s));
    }), {
      onFocusCapture: () => i.value = true,
      onBlurCapture: () => i.value = false
    };
  }
  const bo = xW({
    layersRoot: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  }), YZt = he({
    __name: "DismissableLayer",
    props: {
      disableOutsidePointerEvents: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "dismiss"
    ],
    setup(n, { emit: t }) {
      const e = n, r = t, { forwardRef: i, currentElement: a } = zi(), s = ke(() => {
        var p;
        return ((p = a.value) == null ? void 0 : p.ownerDocument) ?? globalThis.document;
      }), o = ke(() => bo.layersRoot), l = ke(() => a.value ? Array.from(o.value).indexOf(a.value) : -1), u = ke(() => bo.layersWithOutsidePointerEventsDisabled.size > 0), c = ke(() => {
        const p = Array.from(o.value), [g] = [
          ...bo.layersWithOutsidePointerEventsDisabled
        ].slice(-1), v = p.indexOf(g);
        return l.value >= v;
      }), h = HZt(async (p) => {
        const g = [
          ...bo.branches
        ].some((v) => v == null ? void 0 : v.contains(p.target));
        !c.value || g || (r("pointerDownOutside", p), r("interactOutside", p), await Jo(), p.defaultPrevented || r("dismiss"));
      }, a), f = XZt((p) => {
        [
          ...bo.branches
        ].some((g) => g == null ? void 0 : g.contains(p.target)) || (r("focusOutside", p), r("interactOutside", p), p.defaultPrevented || r("dismiss"));
      }, a);
      _Zt("Escape", (p) => {
        l.value === o.value.size - 1 && (r("escapeKeyDown", p), p.defaultPrevented || r("dismiss"));
      });
      let d;
      return Gc((p) => {
        a.value && (e.disableOutsidePointerEvents && (bo.layersWithOutsidePointerEventsDisabled.size === 0 && (d = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), bo.layersWithOutsidePointerEventsDisabled.add(a.value)), o.value.add(a.value), p(() => {
          e.disableOutsidePointerEvents && bo.layersWithOutsidePointerEventsDisabled.size === 1 && (s.value.body.style.pointerEvents = d);
        }));
      }), Gc((p) => {
        p(() => {
          a.value && (o.value.delete(a.value), bo.layersWithOutsidePointerEventsDisabled.delete(a.value));
        });
      }), (p, g) => (fe(), Je(J($a), {
        ref: J(i),
        "as-child": p.asChild,
        as: p.as,
        "data-dismissable-layer": "",
        style: bW({
          pointerEvents: u.value ? c.value ? "auto" : "none" : void 0
        }),
        onFocusCapture: J(f).onFocusCapture,
        onBlurCapture: J(f).onBlurCapture,
        onPointerdownCapture: J(h).onPointerDownCapture
      }, {
        default: Rt(() => [
          De(p.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "style",
        "onFocusCapture",
        "onBlurCapture",
        "onPointerdownCapture"
      ]));
    }
  }), cI = "focusScope.autoFocusOnMount", hI = "focusScope.autoFocusOnUnmount", lW = {
    bubbles: false,
    cancelable: true
  };
  function qZt(n, { select: t = false } = {}) {
    const e = Js();
    for (const r of n) if (xl(r, {
      select: t
    }), Js() !== e) return true;
  }
  function jZt(n) {
    const t = btt(n), e = uW(t, n), r = uW(t.reverse(), n);
    return [
      e,
      r
    ];
  }
  function btt(n) {
    const t = [], e = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; e.nextNode(); ) t.push(e.currentNode);
    return t;
  }
  function uW(n, t) {
    for (const e of n) if (!KZt(e, {
      upTo: t
    })) return e;
  }
  function KZt(n, { upTo: t }) {
    if (getComputedStyle(n).visibility === "hidden") return true;
    for (; n; ) {
      if (t !== void 0 && n === t) return false;
      if (getComputedStyle(n).display === "none") return true;
      n = n.parentElement;
    }
    return false;
  }
  function ZZt(n) {
    return n instanceof HTMLInputElement && "select" in n;
  }
  function xl(n, { select: t = false } = {}) {
    if (n && n.focus) {
      const e = Js();
      n.focus({
        preventScroll: true
      }), n !== e && ZZt(n) && t && n.select();
    }
  }
  const JZt = hZt(() => ue([]));
  function QZt() {
    const n = JZt();
    return {
      add(t) {
        const e = n.value[0];
        t !== e && (e == null ? void 0 : e.pause()), n.value = cW(n.value, t), n.value.unshift(t);
      },
      remove(t) {
        var e;
        n.value = cW(n.value, t), (e = n.value[0]) == null || e.resume();
      }
    };
  }
  function cW(n, t) {
    const e = [
      ...n
    ], r = e.indexOf(t);
    return r !== -1 && e.splice(r, 1), e;
  }
  function tJt(n) {
    return n.filter((t) => t.tagName !== "A");
  }
  const eJt = he({
    __name: "FocusScope",
    props: {
      loop: {
        type: Boolean,
        default: false
      },
      trapped: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "mountAutoFocus",
      "unmountAutoFocus"
    ],
    setup(n, { emit: t }) {
      const e = n, r = t, { currentRef: i, currentElement: a } = zi(), s = ue(null), o = QZt(), l = xW({
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      });
      Gc((c) => {
        if (!Mh) return;
        const h = a.value;
        if (!e.trapped) return;
        function f(v) {
          if (l.paused || !h) return;
          const m = v.target;
          h.contains(m) ? s.value = m : xl(s.value, {
            select: true
          });
        }
        function d(v) {
          if (l.paused || !h) return;
          const m = v.relatedTarget;
          m !== null && (h.contains(m) || xl(s.value, {
            select: true
          }));
        }
        function p(v) {
          h.contains(s.value) || xl(h);
        }
        document.addEventListener("focusin", f), document.addEventListener("focusout", d);
        const g = new MutationObserver(p);
        h && g.observe(h, {
          childList: true,
          subtree: true
        }), c(() => {
          document.removeEventListener("focusin", f), document.removeEventListener("focusout", d), g.disconnect();
        });
      }), Gc(async (c) => {
        const h = a.value;
        if (await Jo(), !h) return;
        o.add(l);
        const f = Js();
        if (!h.contains(f)) {
          const d = new CustomEvent(cI, lW);
          h.addEventListener(cI, (p) => r("mountAutoFocus", p)), h.dispatchEvent(d), d.defaultPrevented || (qZt(tJt(btt(h)), {
            select: true
          }), Js() === f && xl(h));
        }
        c(() => {
          h.removeEventListener(cI, (g) => r("mountAutoFocus", g));
          const d = new CustomEvent(hI, lW), p = (g) => {
            r("unmountAutoFocus", g);
          };
          h.addEventListener(hI, p), h.dispatchEvent(d), setTimeout(() => {
            d.defaultPrevented || xl(f ?? document.body, {
              select: true
            }), h.removeEventListener(hI, p), o.remove(l);
          }, 0);
        });
      });
      function u(c) {
        if (!e.loop && !e.trapped || l.paused) return;
        const h = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, f = Js();
        if (h && f) {
          const d = c.currentTarget, [p, g] = jZt(d);
          p && g ? !c.shiftKey && f === g ? (c.preventDefault(), e.loop && xl(p, {
            select: true
          })) : c.shiftKey && f === p && (c.preventDefault(), e.loop && xl(g, {
            select: true
          })) : f === d && c.preventDefault();
        }
      }
      return (c, h) => (fe(), Je(J($a), {
        ref_key: "currentRef",
        ref: i,
        tabindex: "-1",
        "as-child": c.asChild,
        as: c.as,
        onKeydown: u
      }, {
        default: Rt(() => [
          De(c.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as-child",
        "as"
      ]));
    }
  });
  function nJt(n) {
    return n ? "open" : "closed";
  }
  const _tt = he({
    __name: "DialogContentImpl",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: t }) {
      const e = n, r = t, i = _u(), { forwardRef: a, currentElement: s } = zi();
      return i.titleId || (i.titleId = f1(void 0, "radix-vue-dialog-title")), i.descriptionId || (i.descriptionId = f1(void 0, "radix-vue-dialog-description")), gd(() => {
        i.contentElement = s, Js() !== document.body && (i.triggerElement.value = Js());
      }), (o, l) => (fe(), Je(J(eJt), {
        "as-child": "",
        loop: "",
        trapped: e.trapFocus,
        onMountAutoFocus: l[5] || (l[5] = (u) => r("openAutoFocus", u)),
        onUnmountAutoFocus: l[6] || (l[6] = (u) => r("closeAutoFocus", u))
      }, {
        default: Rt(() => [
          oe(J(YZt), Li({
            id: J(i).contentId,
            ref: J(a),
            as: o.as,
            "as-child": o.asChild,
            "disable-outside-pointer-events": o.disableOutsidePointerEvents,
            role: "dialog",
            "aria-describedby": J(i).descriptionId,
            "aria-labelledby": J(i).titleId,
            "data-state": J(nJt)(J(i).open.value)
          }, o.$attrs, {
            onDismiss: l[0] || (l[0] = (u) => J(i).onOpenChange(false)),
            onEscapeKeyDown: l[1] || (l[1] = (u) => r("escapeKeyDown", u)),
            onFocusOutside: l[2] || (l[2] = (u) => r("focusOutside", u)),
            onInteractOutside: l[3] || (l[3] = (u) => r("interactOutside", u)),
            onPointerDownOutside: l[4] || (l[4] = (u) => r("pointerDownOutside", u))
          }), {
            default: Rt(() => [
              De(o.$slots, "default")
            ]),
            _: 3
          }, 16, [
            "id",
            "as",
            "as-child",
            "disable-outside-pointer-events",
            "aria-describedby",
            "aria-labelledby",
            "data-state"
          ])
        ]),
        _: 3
      }, 8, [
        "trapped"
      ]));
    }
  }), rJt = he({
    __name: "DialogContentModal",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: t }) {
      const e = n, r = t, i = _u(), a = Bw(r), { forwardRef: s, currentElement: o } = zi();
      return PZt(o), (l, u) => (fe(), Je(_tt, Li({
        ...e,
        ...J(a)
      }, {
        ref: J(s),
        "trap-focus": J(i).open.value,
        "disable-outside-pointer-events": true,
        onCloseAutoFocus: u[0] || (u[0] = (c) => {
          var h;
          c.defaultPrevented || (c.preventDefault(), (h = J(i).triggerElement.value) == null || h.focus());
        }),
        onPointerDownOutside: u[1] || (u[1] = (c) => {
          const h = c.detail.originalEvent, f = h.button === 0 && h.ctrlKey === true;
          (h.button === 2 || f) && c.preventDefault();
        }),
        onFocusOutside: u[2] || (u[2] = (c) => {
          c.preventDefault();
        })
      }), {
        default: Rt(() => [
          De(l.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "trap-focus"
      ]));
    }
  }), iJt = he({
    __name: "DialogContentNonModal",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: t }) {
      const e = n, r = Bw(t);
      zi();
      const i = _u(), a = ue(false), s = ue(false);
      return (o, l) => (fe(), Je(_tt, Li({
        ...e,
        ...J(r)
      }, {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: l[0] || (l[0] = (u) => {
          var c;
          u.defaultPrevented || (a.value || (c = J(i).triggerElement.value) == null || c.focus(), u.preventDefault()), a.value = false, s.value = false;
        }),
        onInteractOutside: l[1] || (l[1] = (u) => {
          var c;
          u.defaultPrevented || (a.value = true, u.detail.originalEvent.type === "pointerdown" && (s.value = true));
          const h = u.target;
          (c = J(i).triggerElement.value) != null && c.contains(h) && u.preventDefault(), u.detail.originalEvent.type === "focusin" && s.value && u.preventDefault();
        })
      }), {
        default: Rt(() => [
          De(o.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), aJt = he({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: t }) {
      const e = n, r = t, i = _u(), a = Bw(r), { forwardRef: s } = zi();
      return (o, l) => (fe(), Je(J(oL), {
        present: o.forceMount || J(i).open.value
      }, {
        default: Rt(() => [
          J(i).modal.value ? (fe(), Je(rJt, Li({
            key: 0,
            ref: J(s)
          }, {
            ...e,
            ...J(a),
            ...o.$attrs
          }), {
            default: Rt(() => [
              De(o.$slots, "default")
            ]),
            _: 3
          }, 16)) : (fe(), Je(iJt, Li({
            key: 1,
            ref: J(s)
          }, {
            ...e,
            ...J(a),
            ...o.$attrs
          }), {
            default: Rt(() => [
              De(o.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, [
        "present"
      ]));
    }
  }), sJt = he({
    __name: "DialogOverlayImpl",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(n) {
      const t = _u();
      return DZt(true), zi(), (e, r) => (fe(), Je(J($a), {
        as: e.as,
        "as-child": e.asChild,
        "data-state": J(t).open.value ? "open" : "closed",
        style: {
          "pointer-events": "auto"
        }
      }, {
        default: Rt(() => [
          De(e.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ]));
    }
  }), oJt = he({
    __name: "DialogOverlay",
    props: {
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(n) {
      const t = _u(), { forwardRef: e } = zi();
      return (r, i) => {
        var a;
        return (a = J(t)) != null && a.modal.value ? (fe(), Je(J(oL), {
          key: 0,
          present: r.forceMount || J(t).open.value
        }, {
          default: Rt(() => [
            oe(sJt, Li(r.$attrs, {
              ref: J(e),
              as: r.as,
              "as-child": r.asChild
            }), {
              default: Rt(() => [
                De(r.$slots, "default")
              ]),
              _: 3
            }, 16, [
              "as",
              "as-child"
            ])
          ]),
          _: 3
        }, 8, [
          "present"
        ])) : Dg("", true);
      };
    }
  }), lJt = he({
    __name: "DialogClose",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(n) {
      const t = n;
      zi();
      const e = _u();
      return (r, i) => (fe(), Je(J($a), Li(t, {
        type: r.as === "button" ? "button" : void 0,
        onClick: i[0] || (i[0] = (a) => J(e).onOpenChange(false))
      }), {
        default: Rt(() => [
          De(r.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "type"
      ]));
    }
  }), uJt = he({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "h2"
      }
    },
    setup(n) {
      const t = n, e = _u();
      return zi(), (r, i) => (fe(), Je(J($a), Li(t, {
        id: J(e).titleId
      }), {
        default: Rt(() => [
          De(r.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "id"
      ]));
    }
  }), cJt = "data-radix-vue-collection-item", [lL, hJt] = vy("CollectionProvider");
  function fJt(n = cJt) {
    const t = ue(/* @__PURE__ */ new Map()), e = ue(), r = hJt({
      collectionRef: e,
      itemMap: t,
      attrName: n
    }), { getItems: i } = wtt(r), a = ke(() => Array.from(r.itemMap.value.values())), s = ke(() => r.itemMap.value.size);
    return {
      getItems: i,
      reactiveItems: a,
      itemMapSize: s
    };
  }
  const dJt = he({
    name: "CollectionSlot",
    setup(n, { slots: t }) {
      const e = lL(), { primitiveElement: r, currentElement: i } = ytt();
      return Yr(i, () => {
        e.collectionRef.value = i.value;
      }), () => Qa(sL, {
        ref: r
      }, t);
    }
  }), pJt = he({
    name: "CollectionItem",
    inheritAttrs: false,
    props: {
      value: {
        validator: () => true
      }
    },
    setup(n, { slots: t, attrs: e }) {
      const r = lL(), { primitiveElement: i, currentElement: a } = ytt();
      return Gc((s) => {
        if (a.value) {
          const o = ztt(a.value);
          r.itemMap.value.set(o, {
            ref: a.value,
            value: n.value
          }), s(() => r.itemMap.value.delete(o));
        }
      }), () => Qa(sL, {
        ...e,
        [r.attrName]: "",
        ref: i
      }, t);
    }
  });
  function wtt(n) {
    const t = n ?? lL();
    return {
      getItems: () => {
        const e = t.collectionRef.value;
        if (!e) return [];
        const r = Array.from(e.querySelectorAll(`[${t.attrName}]`));
        return Array.from(t.itemMap.value.values()).sort((i, a) => r.indexOf(i.ref) - r.indexOf(a.ref));
      }
    };
  }
  const gJt = "rovingFocusGroup.onEntryFocus", vJt = {
    bubbles: false,
    cancelable: true
  }, mJt = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function yJt(n, t) {
    return t !== "rtl" ? n : n === "ArrowLeft" ? "ArrowRight" : n === "ArrowRight" ? "ArrowLeft" : n;
  }
  function xJt(n, t, e) {
    const r = yJt(n.key, e);
    if (!(t === "vertical" && [
      "ArrowLeft",
      "ArrowRight"
    ].includes(r)) && !(t === "horizontal" && [
      "ArrowUp",
      "ArrowDown"
    ].includes(r))) return mJt[r];
  }
  function Stt(n, t = false) {
    const e = Js();
    for (const r of n) if (r === e || (r.focus({
      preventScroll: t
    }), Js() !== e)) return;
  }
  function bJt(n, t) {
    return n.map((e, r) => n[(t + r) % n.length]);
  }
  const [_Jt, wJt] = vy("RovingFocusGroup"), SJt = he({
    __name: "RovingFocusGroup",
    props: {
      orientation: {
        default: void 0
      },
      dir: {},
      loop: {
        type: Boolean,
        default: false
      },
      currentTabStopId: {},
      defaultCurrentTabStopId: {},
      preventScrollOnEntryFocus: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "entryFocus",
      "update:currentTabStopId"
    ],
    setup(n, { expose: t, emit: e }) {
      const r = n, i = e, { loop: a, orientation: s, dir: o } = Dv(r), l = vtt(o), u = eL(r, "currentTabStopId", i, {
        defaultValue: r.defaultCurrentTabStopId,
        passive: r.currentTabStopId === void 0
      }), c = ue(false), h = ue(false), f = ue(0), { getItems: d } = fJt();
      function p(v) {
        const m = !h.value;
        if (v.currentTarget && v.target === v.currentTarget && m && !c.value) {
          const y = new CustomEvent(gJt, vJt);
          if (v.currentTarget.dispatchEvent(y), i("entryFocus", y), !y.defaultPrevented) {
            const x = d().map((S) => S.ref).filter((S) => S.dataset.disabled !== ""), b = x.find((S) => S.getAttribute("data-active") === "true"), _ = x.find((S) => S.id === u.value), w = [
              b,
              _,
              ...x
            ].filter(Boolean);
            Stt(w, r.preventScrollOnEntryFocus);
          }
        }
        h.value = false;
      }
      function g() {
        setTimeout(() => {
          h.value = false;
        }, 1);
      }
      return t({
        getItems: d
      }), wJt({
        loop: a,
        dir: l,
        orientation: s,
        currentTabStopId: u,
        onItemFocus: (v) => {
          u.value = v;
        },
        onItemShiftTab: () => {
          c.value = true;
        },
        onFocusableItemAdd: () => {
          f.value++;
        },
        onFocusableItemRemove: () => {
          f.value--;
        }
      }), (v, m) => (fe(), Je(J(dJt), null, {
        default: Rt(() => [
          oe(J($a), {
            tabindex: c.value || f.value === 0 ? -1 : 0,
            "data-orientation": J(s),
            as: v.as,
            "as-child": v.asChild,
            dir: J(l),
            style: {
              outline: "none"
            },
            onMousedown: m[0] || (m[0] = (y) => h.value = true),
            onMouseup: g,
            onFocus: p,
            onBlur: m[1] || (m[1] = (y) => c.value = false)
          }, {
            default: Rt(() => [
              De(v.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "as",
            "as-child",
            "dir"
          ])
        ]),
        _: 3
      }));
    }
  }), CJt = he({
    __name: "RovingFocusItem",
    props: {
      tabStopId: {},
      focusable: {
        type: Boolean,
        default: true
      },
      active: {
        type: Boolean,
        default: true
      },
      allowShiftKey: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(n) {
      const t = n, e = _Jt(), r = ke(() => t.tabStopId || f1()), i = ke(() => e.currentTabStopId.value === r.value), { getItems: a } = wtt();
      gd(() => {
        t.focusable && e.onFocusableItemAdd();
      }), d1(() => {
        t.focusable && e.onFocusableItemRemove();
      });
      function s(o) {
        if (o.key === "Tab" && o.shiftKey) {
          e.onItemShiftTab();
          return;
        }
        if (o.target !== o.currentTarget) return;
        const l = xJt(o, e.orientation.value, e.dir.value);
        if (l !== void 0) {
          if (o.metaKey || o.ctrlKey || o.altKey || !t.allowShiftKey && o.shiftKey) return;
          o.preventDefault();
          let u = [
            ...a().map((c) => c.ref).filter((c) => c.dataset.disabled !== "")
          ];
          if (l === "last") u.reverse();
          else if (l === "prev" || l === "next") {
            l === "prev" && u.reverse();
            const c = u.indexOf(o.currentTarget);
            u = e.loop.value ? bJt(u, c + 1) : u.slice(c + 1);
          }
          Jo(() => Stt(u));
        }
      }
      return (o, l) => (fe(), Je(J(pJt), null, {
        default: Rt(() => [
          oe(J($a), {
            tabindex: i.value ? 0 : -1,
            "data-orientation": J(e).orientation.value,
            "data-active": o.active,
            "data-disabled": o.focusable ? void 0 : "",
            as: o.as,
            "as-child": o.asChild,
            onMousedown: l[0] || (l[0] = (u) => {
              o.focusable ? J(e).onItemFocus(r.value) : u.preventDefault();
            }),
            onFocus: l[1] || (l[1] = (u) => J(e).onItemFocus(r.value)),
            onKeydown: s
          }, {
            default: Rt(() => [
              De(o.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "data-active",
            "data-disabled",
            "as",
            "as-child"
          ])
        ]),
        _: 3
      }));
    }
  });
  function TJt() {
    if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
  TJt();
  const [uL, IJt] = vy("TabsRoot"), AJt = he({
    __name: "TabsRoot",
    props: {
      defaultValue: {},
      orientation: {
        default: "horizontal"
      },
      dir: {},
      activationMode: {
        default: "automatic"
      },
      modelValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(n, { emit: t }) {
      const e = n, r = t, { orientation: i, dir: a } = Dv(e), s = vtt(a);
      zi();
      const o = eL(e, "modelValue", r, {
        defaultValue: e.defaultValue,
        passive: e.modelValue === void 0
      }), l = ue();
      return IJt({
        modelValue: o,
        changeModelValue: (u) => {
          o.value = u;
        },
        orientation: i,
        dir: s,
        activationMode: e.activationMode,
        baseId: f1(void 0, "radix-vue-tabs"),
        tabsList: l
      }), (u, c) => (fe(), Je(J($a), {
        dir: J(s),
        "data-orientation": J(i),
        "as-child": u.asChild,
        as: u.as
      }, {
        default: Rt(() => [
          De(u.$slots, "default", {
            modelValue: J(o)
          })
        ]),
        _: 3
      }, 8, [
        "dir",
        "data-orientation",
        "as-child",
        "as"
      ]));
    }
  }), kJt = he({
    __name: "TabsList",
    props: {
      loop: {
        type: Boolean,
        default: true
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(n) {
      const t = n, { loop: e } = Dv(t), { forwardRef: r, currentElement: i } = zi(), a = uL();
      return a.tabsList = i, (s, o) => (fe(), Je(J(SJt), {
        "as-child": "",
        orientation: J(a).orientation.value,
        dir: J(a).dir.value,
        loop: J(e)
      }, {
        default: Rt(() => [
          oe(J($a), {
            ref: J(r),
            role: "tablist",
            "as-child": s.asChild,
            as: s.as,
            "aria-orientation": J(a).orientation.value
          }, {
            default: Rt(() => [
              De(s.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "as-child",
            "as",
            "aria-orientation"
          ])
        ]),
        _: 3
      }, 8, [
        "orientation",
        "dir",
        "loop"
      ]));
    }
  });
  function Ctt(n, t) {
    return `${n}-trigger-${t}`;
  }
  function Ttt(n, t) {
    return `${n}-content-${t}`;
  }
  const DJt = he({
    __name: "TabsContent",
    props: {
      value: {},
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(n) {
      const t = n, { forwardRef: e } = zi(), r = uL(), i = ke(() => Ctt(r.baseId, t.value)), a = ke(() => Ttt(r.baseId, t.value)), s = ke(() => t.value === r.modelValue.value), o = ue(s.value);
      return gd(() => {
        requestAnimationFrame(() => {
          o.value = false;
        });
      }), (l, u) => (fe(), Je(J(oL), {
        present: s.value,
        "force-mount": ""
      }, {
        default: Rt(({ present: c }) => [
          oe(J($a), {
            id: a.value,
            ref: J(e),
            "as-child": l.asChild,
            as: l.as,
            role: "tabpanel",
            "data-state": s.value ? "active" : "inactive",
            "data-orientation": J(r).orientation.value,
            "aria-labelledby": i.value,
            hidden: !c.value,
            tabindex: "0",
            style: bW({
              animationDuration: o.value ? "0s" : void 0
            })
          }, {
            default: Rt(() => [
              l.forceMount || s.value ? De(l.$slots, "default", {
                key: 0
              }) : Dg("", true)
            ]),
            _: 2
          }, 1032, [
            "id",
            "as-child",
            "as",
            "data-state",
            "data-orientation",
            "aria-labelledby",
            "hidden",
            "style"
          ])
        ]),
        _: 3
      }, 8, [
        "present"
      ]));
    }
  }), EJt = he({
    __name: "TabsTrigger",
    props: {
      value: {},
      disabled: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(n) {
      const t = n, { forwardRef: e } = zi(), r = uL(), i = ke(() => Ctt(r.baseId, t.value)), a = ke(() => Ttt(r.baseId, t.value)), s = ke(() => t.value === r.modelValue.value);
      return (o, l) => (fe(), Je(J(CJt), {
        "as-child": "",
        focusable: !o.disabled,
        active: s.value
      }, {
        default: Rt(() => [
          oe(J($a), {
            id: i.value,
            ref: J(e),
            role: "tab",
            type: o.as === "button" ? "button" : void 0,
            as: o.as,
            "as-child": o.asChild,
            "aria-selected": s.value ? "true" : "false",
            "aria-controls": a.value,
            "data-state": s.value ? "active" : "inactive",
            disabled: o.disabled,
            "data-disabled": o.disabled ? "" : void 0,
            "data-orientation": J(r).orientation.value,
            onMousedown: l[0] || (l[0] = $p((u) => {
              !o.disabled && u.ctrlKey === false ? J(r).changeModelValue(o.value) : u.preventDefault();
            }, [
              "left"
            ])),
            onKeydown: l[1] || (l[1] = Ptt((u) => J(r).changeModelValue(o.value), [
              "enter",
              "space"
            ])),
            onFocus: l[2] || (l[2] = () => {
              const u = J(r).activationMode !== "manual";
              !s.value && !o.disabled && u && J(r).changeModelValue(o.value);
            })
          }, {
            default: Rt(() => [
              De(o.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "id",
            "type",
            "as",
            "as-child",
            "aria-selected",
            "aria-controls",
            "data-state",
            "disabled",
            "data-disabled",
            "data-orientation"
          ])
        ]),
        _: 3
      }, 8, [
        "focusable",
        "active"
      ]));
    }
  }), fI = he({
    __name: "Button",
    props: {
      variant: {},
      size: {},
      class: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Je(J($a), {
        as: e.as,
        "as-child": e.asChild,
        class: ta(J(Pr)(J(MJt)({
          variant: e.variant,
          size: e.size
        }), t.class))
      }, {
        default: Rt(() => [
          De(e.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "class"
      ]));
    }
  }), MJt = SKt("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }), RJt = he({
    __name: "Card",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("div", {
        class: ta(J(Pr)("rounded-lg border bg-card text-card-foreground shadow-sm", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), dI = he({
    __name: "CardContent",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("div", {
        class: ta(J(Pr)("p-6 pt-0", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), NJt = he({
    __name: "CardHeader",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("div", {
        class: ta(J(Pr)("flex flex-col gap-y-1.5 p-6", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), LJt = he({
    __name: "Dialog",
    props: {
      open: {
        type: Boolean
      },
      defaultOpen: {
        type: Boolean
      },
      modal: {
        type: Boolean
      }
    },
    emits: [
      "update:open"
    ],
    setup(n, { emit: t }) {
      const i = aL(n, t);
      return (a, s) => (fe(), Je(J(zZt), Ak(kk(J(i))), {
        default: Rt(() => [
          De(a.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), PJt = he({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: t }) {
      const e = n, r = t, i = ke(() => {
        const { class: s, ...o } = e;
        return o;
      }), a = aL(i, r);
      return (s, o) => (fe(), Je(J(GZt), null, {
        default: Rt(() => [
          oe(J(oJt), {
            class: "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
          }),
          oe(J(aJt), Li(J(a), {
            class: J(Pr)("fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", e.class)
          }), {
            default: Rt(() => [
              De(s.$slots, "default"),
              oe(J(lJt), {
                class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground"
              }, {
                default: Rt(() => [
                  oe(J(Y1t), {
                    class: "w-4 h-4"
                  }),
                  o[0] || (o[0] = Wt("span", {
                    class: "sr-only"
                  }, "Close", -1))
                ]),
                _: 1
              })
            ]),
            _: 3
          }, 16, [
            "class"
          ])
        ]),
        _: 3
      }));
    }
  }), $Jt = he({
    __name: "DialogHeader",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("div", {
        class: ta(J(Pr)("flex flex-col gap-y-1.5 text-center sm:text-left", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), OJt = he({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(n) {
      const t = n, e = ke(() => {
        const { class: i, ...a } = t;
        return a;
      }), r = iL(e);
      return (i, a) => (fe(), Je(J(uJt), Li(J(r), {
        class: J(Pr)("text-lg font-semibold leading-none tracking-tight", t.class)
      }), {
        default: Rt(() => [
          De(i.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  });
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const FJt = (n) => typeof n < "u";
  function BJt(n) {
    return JSON.parse(JSON.stringify(n));
  }
  function zJt(n, t, e, r = {}) {
    var i, a, s;
    const { clone: o = false, passive: l = false, eventName: u, deep: c = false, defaultValue: h, shouldEmit: f } = r, d = Zi(), p = e || (d == null ? void 0 : d.emit) || ((i = d == null ? void 0 : d.$emit) == null ? void 0 : i.bind(d)) || ((s = (a = d == null ? void 0 : d.proxy) == null ? void 0 : a.$emit) == null ? void 0 : s.bind(d == null ? void 0 : d.proxy));
    let g = u;
    g = g || `update:${t.toString()}`;
    const v = (x) => o ? typeof o == "function" ? o(x) : BJt(x) : x, m = () => FJt(n[t]) ? v(n[t]) : h, y = (x) => {
      f ? f(x) && p(g, x) : p(g, x);
    };
    if (l) {
      const x = m(), b = ue(x);
      let _ = false;
      return Yr(() => n[t], (w) => {
        _ || (_ = true, b.value = v(w), Jo(() => _ = false));
      }), Yr(b, (w) => {
        !_ && (w !== n[t] || c) && y(w);
      }, {
        deep: c
      }), b;
    } else return ke({
      get() {
        return m();
      },
      set(x) {
        y(x);
      }
    });
  }
  const VJt = he({
    __name: "Textarea",
    props: {
      class: {},
      defaultValue: {},
      modelValue: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(n, { emit: t }) {
      const e = n, i = zJt(e, "modelValue", t, {
        passive: true,
        defaultValue: e.defaultValue
      });
      return (a, s) => vI((fe(), Ur("textarea", {
        "onUpdate:modelValue": s[0] || (s[0] = (o) => vW(i) ? i.value = o : null),
        class: ta(J(Pr)("flex min-h-20 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", e.class))
      }, null, 2)), [
        [
          mI,
          J(i)
        ]
      ]);
    }
  }), GJt = he({
    __name: "Tabs",
    props: {
      defaultValue: {},
      orientation: {},
      dir: {},
      activationMode: {},
      modelValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(n, { emit: t }) {
      const i = aL(n, t);
      return (a, s) => (fe(), Je(J(AJt), Ak(kk(J(i))), {
        default: Rt(() => [
          De(a.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), hW = he({
    __name: "TabsContent",
    props: {
      value: {},
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(n) {
      const t = n, e = ke(() => {
        const { class: r, ...i } = t;
        return i;
      });
      return (r, i) => (fe(), Je(J(DJt), Li({
        class: J(Pr)("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", t.class)
      }, e.value), {
        default: Rt(() => [
          De(r.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), WJt = he({
    __name: "TabsList",
    props: {
      loop: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(n) {
      const t = n, e = ke(() => {
        const { class: r, ...i } = t;
        return i;
      });
      return (r, i) => (fe(), Je(J(kJt), Li(e.value, {
        class: J(Pr)("inline-flex items-center justify-center rounded-md bg-muted p-1 text-muted-foreground", t.class)
      }), {
        default: Rt(() => [
          De(r.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), UJt = {
    class: "truncate"
  }, fW = he({
    __name: "TabsTrigger",
    props: {
      value: {},
      disabled: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(n) {
      const t = n, e = ke(() => {
        const { class: i, ...a } = t;
        return a;
      }), r = iL(e);
      return (i, a) => (fe(), Je(J(EJt), Li(J(r), {
        class: J(Pr)("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm", t.class)
      }), {
        default: Rt(() => [
          Wt("span", UJt, [
            De(i.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), HJt = {
    class: "relative w-full overflow-auto"
  }, XJt = he({
    __name: "Table",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("div", HJt, [
        Wt("table", {
          class: ta(J(Pr)("w-full caption-bottom text-sm", t.class))
        }, [
          De(e.$slots, "default")
        ], 2)
      ]));
    }
  }), YJt = he({
    __name: "TableBody",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("tbody", {
        class: ta(J(Pr)("[&_tr:last-child]:border-0", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), lf = he({
    __name: "TableCell",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("td", {
        class: ta(J(Pr)("p-4 align-middle [&:has([role=checkbox])]:pr-0", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), dW = he({
    __name: "TableRow",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("tr", {
        class: ta(J(Pr)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), uf = he({
    __name: "TableHead",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("th", {
        class: ta(J(Pr)("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), qJt = he({
    __name: "TableHeader",
    props: {
      class: {}
    },
    setup(n) {
      const t = n;
      return (e, r) => (fe(), Ur("thead", {
        class: ta(J(Pr)("[&_tr]:border-b", t.class))
      }, [
        De(e.$slots, "default")
      ], 2));
    }
  }), jJt = 1, KJt = 1e6, Eo = {
    ADD_TOAST: "ADD_TOAST",
    UPDATE_TOAST: "UPDATE_TOAST",
    DISMISS_TOAST: "DISMISS_TOAST",
    REMOVE_TOAST: "REMOVE_TOAST"
  };
  let pI = 0;
  function ZJt() {
    return pI = (pI + 1) % Number.MAX_VALUE, pI.toString();
  }
  const gI = /* @__PURE__ */ new Map();
  function pW(n) {
    if (gI.has(n)) return;
    const t = setTimeout(() => {
      gI.delete(n), Ag({
        type: Eo.REMOVE_TOAST,
        toastId: n
      });
    }, KJt);
    gI.set(n, t);
  }
  const Ga = ue({
    toasts: []
  });
  function Ag(n) {
    switch (n.type) {
      case Eo.ADD_TOAST:
        Ga.value.toasts = [
          n.toast,
          ...Ga.value.toasts
        ].slice(0, jJt);
        break;
      case Eo.UPDATE_TOAST:
        Ga.value.toasts = Ga.value.toasts.map((t) => t.id === n.toast.id ? {
          ...t,
          ...n.toast
        } : t);
        break;
      case Eo.DISMISS_TOAST: {
        const { toastId: t } = n;
        t ? pW(t) : Ga.value.toasts.forEach((e) => {
          pW(e.id);
        }), Ga.value.toasts = Ga.value.toasts.map((e) => e.id === t || t === void 0 ? {
          ...e,
          open: false
        } : e);
        break;
      }
      case Eo.REMOVE_TOAST:
        n.toastId === void 0 ? Ga.value.toasts = [] : Ga.value.toasts = Ga.value.toasts.filter((t) => t.id !== n.toastId);
        break;
    }
  }
  function JJt() {
    return {
      toasts: ke(() => Ga.value.toasts),
      toast: QJt,
      dismiss: (n) => Ag({
        type: Eo.DISMISS_TOAST,
        toastId: n
      })
    };
  }
  function QJt(n) {
    const t = ZJt(), e = (i) => Ag({
      type: Eo.UPDATE_TOAST,
      toast: {
        ...i,
        id: t
      }
    }), r = () => Ag({
      type: Eo.DISMISS_TOAST,
      toastId: t
    });
    return Ag({
      type: Eo.ADD_TOAST,
      toast: {
        ...n,
        id: t,
        open: true,
        onOpenChange: (i) => {
          i || r();
        }
      }
    }), {
      id: t,
      dismiss: r,
      update: e
    };
  }
  let tQt, eQt, nQt, rQt, iQt, aQt, sQt, oQt, lQt, uQt, cQt, hQt, fQt, dQt, pQt, gQt, vQt, mQt, yQt, xQt, bQt, _Qt, wQt, SQt, CQt, TQt, IQt, AQt, kQt, DQt, EQt, MQt, RQt, NQt, LQt, PQt, $Qt, OQt, FQt, BQt, zQt, VQt, GQt, WQt, UQt, HQt, XQt, YQt, qQt, jQt, KQt, ZQt, JQt, QQt, tte, ete, nte, rte, ite, ate, ste;
  tQt = {
    class: "flex flex-col justify-start space-y-4 p-4 max-w-4xl mx-auto w-full"
  };
  eQt = {
    class: "text-lg font-bold"
  };
  nQt = {
    class: "text-sm text-gray-600 text-center"
  };
  rQt = {
    class: "text-primary font-medium hover:underline"
  };
  iQt = {
    key: 0,
    class: "w-full max-w-2xl mx-auto"
  };
  aQt = {
    class: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"
  };
  sQt = [
    "onClick"
  ];
  oQt = [
    "src",
    "alt"
  ];
  lQt = {
    class: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-center justify-center"
  };
  uQt = {
    class: "text-white text-sm truncate max-w-[90%] px-2"
  };
  cQt = {
    class: "flex flex-col gap-4 items-center justify-center"
  };
  hQt = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  fQt = {
    class: "text-sm text-gray-600"
  };
  dQt = [
    "disabled"
  ];
  pQt = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  gQt = {
    class: "text-sm text-gray-600"
  };
  vQt = [
    "disabled"
  ];
  mQt = {
    class: "flex gap-6"
  };
  yQt = {
    class: "bg-white rounded-xl shadow-sm"
  };
  xQt = {
    class: "mt-6 p-6 bg-gray-50/50 rounded-xl border border-gray-100"
  };
  bQt = {
    class: "border rounded-xl overflow-hidden overflow-x-auto"
  };
  _Qt = {
    class: "flex flex-col gap-8 pt-4"
  };
  wQt = {
    class: "relative w-full overflow-hidden rounded-xl shadow-lg bg-gray-50/50"
  };
  SQt = [
    "src"
  ];
  CQt = {
    class: "grid grid-cols-2 gap-6 p-6 border rounded-xl bg-gray-50/30"
  };
  TQt = {
    class: "space-y-2"
  };
  IQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  AQt = {
    class: "font-medium"
  };
  kQt = {
    class: "space-y-2"
  };
  DQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  EQt = {
    class: "font-medium"
  };
  MQt = {
    class: "space-y-2"
  };
  RQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  NQt = {
    class: "font-medium"
  };
  LQt = {
    class: "space-y-2"
  };
  PQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  $Qt = {
    class: "font-medium"
  };
  OQt = {
    class: "space-y-2"
  };
  FQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  BQt = {
    class: "font-medium"
  };
  zQt = {
    class: "space-y-2"
  };
  VQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  GQt = {
    class: "font-medium"
  };
  WQt = {
    class: "space-y-2"
  };
  UQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  HQt = {
    class: "font-medium"
  };
  XQt = {
    class: "space-y-2"
  };
  YQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  qQt = {
    class: "font-medium"
  };
  jQt = {
    class: "space-y-2"
  };
  KQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  ZQt = {
    class: "font-medium"
  };
  JQt = {
    class: "space-y-2"
  };
  QQt = {
    class: "text-sm font-semibold text-gray-500"
  };
  tte = {
    class: "font-medium"
  };
  ete = {
    class: "space-y-2"
  };
  nte = {
    class: "text-sm font-semibold text-gray-500"
  };
  rte = {
    class: "font-medium"
  };
  ite = 10;
  ate = he({
    __name: "ModelPerformanceTest",
    setup(n) {
      const { t } = wKt(), { toast: e } = JJt(), r = ue([]), i = ue(""), a = ue([]), s = ue(false), o = ue("chart"), l = ue(false), u = ue(null), c = ue(), h = ue(), f = ue(), d = ue(1), p = ue(ite), g = o7t(), v = ue([]), m = ue(false), y = (D) => {
        const M = D.target.value.split(`
`).filter((L) => L.trim()).map((L) => {
          if (L.includes(".json")) {
            const k = L.split("/");
            return k.slice(0, k.length - 1).join("/");
          }
          return L;
        });
        r.value = M.map((L) => {
          const k = L.split("/");
          return {
            name: k[k.length - 1].split(".")[0],
            url: L
          };
        });
      }, x = (D) => {
        const E = D.target.files;
        E && Array.from(E).forEach((M) => {
          const L = new FileReader();
          L.addEventListener("load", async () => {
            const k = new Image();
            k.src = L.result, await new Promise((R) => {
              k.onload = R;
            });
            const N = await createImageBitmap(k);
            a.value.push({
              file: M,
              preview: L.result,
              bitmap: N
            });
          }, false), L.readAsDataURL(M);
        });
      }, b = async () => {
        if (!r.value.length || !a.value.length) {
          e({
            variant: "destructive",
            title: t("modelTest.messages.selectModelAndImage")
          });
          return;
        }
        s.value = true, v.value = [];
        try {
          for (const D of r.value) {
            const { name: E, url: M } = D;
            await g.loadModel(M);
            for (const L of a.value) {
              const k = performance.now(), N = [];
              for (let V = 0; V < d.value; V++) {
                const U = await w(E, M, L.bitmap, L.file.name);
                N.push(U);
              }
              const R = Math.round(N.reduce((V, U) => V + U.inferenceTime, 0) / d.value), $ = [];
              for (let V = 0; V < p.value; V++) {
                const U = await w(E, M, L.bitmap, L.file.name);
                $.push(U);
              }
              const F = performance.now() - k, z = {
                modelName: E,
                modelUrl: M,
                imageName: L.file.name,
                warmupTime: R,
                inferenceTime: Math.round($.reduce((V, U) => V + U.inferenceTime, 0) / p.value),
                fps: Math.round($.reduce((V, U) => V + U.fps, 0) / p.value),
                detections: $[0].detections,
                batchSize: p.value,
                minInferenceTime: Math.min(...$.map((V) => V.inferenceTime)),
                maxInferenceTime: Math.max(...$.map((V) => V.inferenceTime)),
                totalTime: F,
                warmupResults: N,
                warmupCount: d.value
              };
              v.value.push(z);
            }
          }
          m.value = true, I();
        } catch (D) {
          e({
            variant: "destructive",
            title: t("modelTest.messages.testError"),
            description: D.message
          });
        } finally {
          s.value = false;
        }
      }, _ = () => {
        const D = v.value.map((N) => `${N.modelName},${N.imageName},${N.inferenceTime},${N.minInferenceTime},${N.maxInferenceTime},${N.fps},${p.value}`).join(`
`), E = [
          t("modelTest.tableColumns.model"),
          t("modelTest.tableColumns.image"),
          t("modelTest.tableColumns.inferenceTime"),
          t("modelTest.tableColumns.minInferenceTime"),
          t("modelTest.tableColumns.maxInferenceTime"),
          t("modelTest.tableColumns.fps"),
          t("modelTest.dialog.testCount")
        ].join(","), M = new Blob([
          `${E}
${D}`
        ], {
          type: "text/csv"
        }), L = URL.createObjectURL(M), k = document.createElement("a");
        k.href = L, k.download = `model_performance_${(/* @__PURE__ */ new Date()).toISOString()}.csv`, k.click();
      }, w = async (D, E, M, L) => {
        var _a2;
        const k = performance.now(), R = await ((_a2 = Ac.getInstance().model) == null ? void 0 : _a2.detect(M, {})), O = performance.now() - k;
        return {
          modelName: D,
          modelUrl: E,
          imageName: L,
          inferenceTime: O,
          fps: Math.round(1e3 / O),
          detections: ((R == null ? void 0 : R.boxes.length) ?? 0) / 4
        };
      }, S = (D) => {
        u.value = D, l.value = true;
      }, I = () => {
        if (!c.value) return;
        const D = $ot(c.value), E = {
          tooltip: {
            trigger: "axis",
            backgroundColor: "rgba(255, 255, 255, 0.9)",
            borderColor: "#e5e7eb",
            textStyle: {
              color: "black"
            }
          },
          legend: {
            data: [
              t("modelTest.tableColumns.inferenceTime"),
              t("modelTest.tableColumns.fps")
            ],
            textStyle: {
              color: "black"
            }
          },
          xAxis: {
            type: "category",
            data: v.value.map((M) => M.modelName),
            axisLine: {
              lineStyle: {
                color: "#e5e7eb"
              }
            },
            axisLabel: {
              color: "#000"
            },
            nameTextStyle: {
              color: "#000"
            }
          },
          yAxis: [
            {
              type: "value",
              name: t("modelTest.tableColumns.inferenceTime"),
              axisLine: {
                lineStyle: {
                  color: "#e5e7eb"
                }
              },
              axisLabel: {
                color: "#000"
              },
              splitLine: {
                lineStyle: {
                  color: "#f3f4f6"
                }
              },
              nameTextStyle: {
                color: "#000"
              }
            },
            {
              type: "value",
              name: t("modelTest.tableColumns.fps"),
              axisLine: {
                lineStyle: {
                  color: "#e5e7eb"
                }
              },
              axisLabel: {
                color: "#000"
              },
              splitLine: {
                lineStyle: {
                  color: "#f3f4f6"
                }
              },
              nameTextStyle: {
                color: "#000"
              }
            }
          ],
          series: [
            {
              name: t("modelTest.tableColumns.inferenceTime"),
              type: "bar",
              data: v.value.map((M) => M.inferenceTime),
              itemStyle: {
                color: "#3b82f6"
              },
              emphasis: {
                itemStyle: {
                  color: "#2563eb"
                }
              }
            },
            {
              name: t("modelTest.tableColumns.fps"),
              type: "line",
              yAxisIndex: 1,
              data: v.value.map((M) => M.fps),
              lineStyle: {
                color: "#10b981"
              },
              itemStyle: {
                color: "#10b981"
              },
              emphasis: {
                itemStyle: {
                  color: "#059669"
                }
              }
            }
          ]
        };
        return D.setOption(E), window.addEventListener("resize", () => {
          D.resize();
        }), D;
      };
      Yr([
        v
      ], I), Yr(o, (D) => {
        D === "chart" && setTimeout(() => {
          I();
        }, 500);
      }), gd(() => I());
      const T = (D) => {
        var _a2;
        const E = new Image();
        E.src = D, (_a2 = window.open("")) == null ? void 0 : _a2.document.write(E.outerHTML);
      }, A = ue(false), C = (D) => {
        var _a2;
        A.value = false;
        const E = (_a2 = D.dataTransfer) == null ? void 0 : _a2.files;
        E && Array.from(E).filter((M) => M.type.startsWith("image/")).forEach((M) => {
          const L = new FileReader();
          L.addEventListener("load", async () => {
            const k = new Image();
            k.src = L.result, await new Promise((R) => {
              k.onload = R;
            });
            const N = await createImageBitmap(k);
            a.value.push({
              file: M,
              preview: L.result,
              bitmap: N
            });
          }, false), L.readAsDataURL(M);
        });
      };
      return (D, E) => (fe(), Ur("div", tQt, [
        oe(J(RJt), {
          class: "shadow-lg hover:shadow-2xl transition-all duration-300 rounded-xl overflow-hidden bg-white/50 backdrop-blur-sm border border-gray-100"
        }, {
          default: Rt(() => [
            oe(J(NJt), null, {
              default: Rt(() => [
                Wt("h1", eQt, de(J(t)("modelTest.title")), 1)
              ]),
              _: 1
            }),
            oe(J(dI), null, {
              default: Rt(() => [
                oe(J(VJt), {
                  modelValue: i.value,
                  "onUpdate:modelValue": E[0] || (E[0] = (M) => i.value = M),
                  rows: "3",
                  class: "w-full max-w-2xl mx-auto transition-all duration-300 hover:shadow-md focus:ring-2 focus:ring-primary/20 rounded-lg",
                  placeholder: J(t)("modelTest.enterModelUrls"),
                  onInput: y
                }, null, 8, [
                  "modelValue",
                  "placeholder"
                ])
              ]),
              _: 1
            }),
            oe(J(dI), {
              class: "space-y-6"
            }, {
              default: Rt(() => [
                Wt("div", {
                  class: ta([
                    "border-2 border-dashed border-gray-200 rounded-xl p-6 hover:border-primary/60 transition-all duration-300 hover:shadow-md bg-gray-50/50 group max-w-2xl mx-auto",
                    {
                      "border-primary/60 shadow-md": A.value
                    }
                  ]),
                  onDragover: E[4] || (E[4] = $p(() => {
                  }, [
                    "prevent"
                  ])),
                  onDrop: $p(C, [
                    "prevent"
                  ])
                }, [
                  Wt("input", {
                    type: "file",
                    accept: "image/*",
                    multiple: "",
                    class: "hidden",
                    ref_key: "fileInput",
                    ref: f,
                    onChange: x
                  }, null, 544),
                  Wt("div", {
                    class: "flex flex-col items-center justify-center h-full cursor-pointer space-y-4",
                    onClick: E[1] || (E[1] = () => f.value.click()),
                    onDragenter: E[2] || (E[2] = $p((M) => A.value = true, [
                      "prevent"
                    ])),
                    onDragleave: E[3] || (E[3] = $p((M) => A.value = false, [
                      "prevent"
                    ]))
                  }, [
                    oe(J(X1t), {
                      class: "w-8 h-8 text-primary/70 group-hover:scale-110 transition-transform duration-300"
                    }),
                    Wt("div", nQt, [
                      fr(de(J(t)("modelTest.uploadText")) + " ", 1),
                      Wt("span", rQt, de(J(t)("modelTest.uploadClickText")), 1)
                    ])
                  ], 32)
                ], 34),
                a.value.length > 0 ? (fe(), Ur("div", iQt, [
                  Wt("div", aQt, [
                    (fe(true), Ur(kg, null, fL(a.value, (M, L) => (fe(), Ur("div", {
                      key: L,
                      class: "relative group cursor-pointer rounded-lg overflow-hidden shadow-sm hover:shadow-lg transition-all duration-300",
                      onClick: (k) => T(M.preview)
                    }, [
                      Wt("img", {
                        src: M.preview,
                        class: "w-full h-32 object-cover",
                        alt: M.file.name
                      }, null, 8, oQt),
                      Wt("div", lQt, [
                        Wt("span", uQt, de(M.file.name), 1)
                      ])
                    ], 8, sQt))), 128))
                  ])
                ])) : Dg("", true)
              ]),
              _: 1
            }),
            oe(J(dI), null, {
              default: Rt(() => [
                Wt("div", cQt, [
                  Wt("div", hQt, [
                    Wt("label", fQt, de(J(t)("modelTest.warmupCount")) + ":", 1),
                    vI(Wt("input", {
                      type: "number",
                      "onUpdate:modelValue": E[5] || (E[5] = (M) => d.value = M),
                      min: "1",
                      max: "100",
                      disabled: s.value,
                      class: "w-24 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, null, 8, dQt), [
                      [
                        mI,
                        d.value
                      ]
                    ])
                  ]),
                  Wt("div", pQt, [
                    Wt("label", gQt, de(J(t)("modelTest.inferenceCount")) + ":", 1),
                    vI(Wt("input", {
                      type: "number",
                      "onUpdate:modelValue": E[6] || (E[6] = (M) => p.value = M),
                      min: "1",
                      max: "100",
                      disabled: s.value,
                      class: "w-24 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, null, 8, vQt), [
                      [
                        mI,
                        p.value
                      ]
                    ])
                  ]),
                  Wt("div", mQt, [
                    oe(J(fI), {
                      disabled: s.value || !r.value.length || !a.value.length,
                      class: "min-w-[140px] transition-all duration-300 hover:scale-105 shadow-md hover:shadow-lg disabled:opacity-50",
                      onClick: b
                    }, {
                      default: Rt(() => [
                        s.value ? (fe(), Je(J(H1t), {
                          key: 0,
                          class: "mr-2 h-4 w-4 animate-spin"
                        })) : Dg("", true),
                        fr(" " + de(J(t)("modelTest.startTest")), 1)
                      ]),
                      _: 1
                    }, 8, [
                      "disabled"
                    ]),
                    oe(J(fI), {
                      variant: "outline",
                      disabled: !m.value,
                      class: "min-w-[140px] transition-all duration-300 hover:scale-105 shadow-sm hover:shadow-md disabled:opacity-50",
                      onClick: _
                    }, {
                      default: Rt(() => [
                        fr(de(J(t)("modelTest.exportResults")), 1)
                      ]),
                      _: 1
                    }, 8, [
                      "disabled"
                    ])
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Wt("div", yQt, [
          oe(J(GJt), {
            modelValue: o.value,
            "onUpdate:modelValue": E[7] || (E[7] = (M) => o.value = M),
            class: "w-full"
          }, {
            default: Rt(() => [
              oe(J(WJt), {
                class: "grid w-full grid-cols-2 p-1 bg-gray-100/50 rounded-lg"
              }, {
                default: Rt(() => [
                  oe(J(fW), {
                    value: "chart",
                    class: "data-[state=active]:bg-white data-[state=active]:shadow-sm rounded-md transition-all duration-300"
                  }, {
                    default: Rt(() => [
                      fr(de(J(t)("modelTest.performanceChart")), 1)
                    ]),
                    _: 1
                  }),
                  oe(J(fW), {
                    value: "table",
                    class: "data-[state=active]:bg-white data-[state=active]:shadow-sm rounded-md transition-all duration-300"
                  }, {
                    default: Rt(() => [
                      fr(de(J(t)("modelTest.detailData")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              oe(J(hW), {
                value: "chart"
              }, {
                default: Rt(() => [
                  Wt("div", xQt, [
                    Wt("div", {
                      ref_key: "performanceChart",
                      ref: c,
                      class: "h-[500px] w-full"
                    }, null, 512)
                  ])
                ]),
                _: 1
              }),
              oe(J(hW), {
                value: "table"
              }, {
                default: Rt(() => [
                  Wt("div", bQt, [
                    oe(J(XJt), {
                      class: "min-w-full table-auto"
                    }, {
                      default: Rt(() => [
                        oe(J(qJt), null, {
                          default: Rt(() => [
                            oe(J(dW), {
                              class: "bg-gray-50/70 hover:bg-gray-50/90"
                            }, {
                              default: Rt(() => [
                                oe(J(uf), {
                                  class: "font-semibold"
                                }, {
                                  default: Rt(() => [
                                    fr(de(J(t)("modelTest.tableColumns.model")), 1)
                                  ]),
                                  _: 1
                                }),
                                oe(J(uf), {
                                  class: "font-semibold"
                                }, {
                                  default: Rt(() => [
                                    fr(de(J(t)("modelTest.tableColumns.image")), 1)
                                  ]),
                                  _: 1
                                }),
                                oe(J(uf), {
                                  class: "font-semibold"
                                }, {
                                  default: Rt(() => [
                                    fr(de(J(t)("modelTest.tableColumns.warmupTime")), 1)
                                  ]),
                                  _: 1
                                }),
                                oe(J(uf), {
                                  class: "font-semibold"
                                }, {
                                  default: Rt(() => [
                                    fr(de(J(t)("modelTest.tableColumns.inferenceTime")), 1)
                                  ]),
                                  _: 1
                                }),
                                oe(J(uf), {
                                  class: "font-semibold"
                                }, {
                                  default: Rt(() => [
                                    fr(de(J(t)("modelTest.tableColumns.fps")), 1)
                                  ]),
                                  _: 1
                                }),
                                oe(J(uf), {
                                  class: "font-semibold"
                                }, {
                                  default: Rt(() => [
                                    fr(de(J(t)("modelTest.tableColumns.actions")), 1)
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        oe(J(YJt), null, {
                          default: Rt(() => [
                            (fe(true), Ur(kg, null, fL(v.value, (M) => (fe(), Je(J(dW), {
                              key: M.modelName + M.imageName,
                              class: "hover:bg-gray-50/50 transition-colors duration-200"
                            }, {
                              default: Rt(() => [
                                oe(J(lf), {
                                  class: "font-medium"
                                }, {
                                  default: Rt(() => [
                                    fr(de(M.modelName), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                oe(J(lf), null, {
                                  default: Rt(() => [
                                    fr(de(M.imageName), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                oe(J(lf), null, {
                                  default: Rt(() => [
                                    fr(de(M.warmupTime), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                oe(J(lf), null, {
                                  default: Rt(() => [
                                    fr(de(M.inferenceTime), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                oe(J(lf), null, {
                                  default: Rt(() => [
                                    fr(de(M.fps), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                oe(J(lf), null, {
                                  default: Rt(() => [
                                    oe(J(fI), {
                                      variant: "ghost",
                                      class: "transition-all duration-300 hover:scale-110 hover:text-primary",
                                      onClick: (L) => S(M)
                                    }, {
                                      default: Rt(() => [
                                        fr(de(J(t)("modelTest.tableColumns.viewDetail")), 1)
                                      ]),
                                      _: 2
                                    }, 1032, [
                                      "onClick"
                                    ])
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1024))), 128))
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, [
            "modelValue"
          ])
        ]),
        oe(J(LJt), {
          open: l.value,
          "onUpdate:open": E[8] || (E[8] = (M) => l.value = M)
        }, {
          default: Rt(() => [
            oe(J(PJt), {
              class: "sm:max-w-[800px] rounded-xl overflow-hidden bg-white/95 shadow-xl border border-gray-100/20"
            }, {
              default: Rt(() => {
                var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2;
                return [
                  oe(J($Jt), {
                    class: "border-b pb-4"
                  }, {
                    default: Rt(() => [
                      oe(J(OJt), {
                        class: "text-xl font-bold"
                      }, {
                        default: Rt(() => [
                          fr(de(J(t)("modelTest.dialog.title")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  Wt("div", _Qt, [
                    Wt("div", wQt, [
                      Wt("img", {
                        src: (_a2 = u.value) == null ? void 0 : _a2.image,
                        class: "max-w-full h-auto"
                      }, null, 8, SQt),
                      Wt("canvas", {
                        ref_key: "detailCanvas",
                        ref: h,
                        class: "max-w-full h-auto absolute top-0 left-0"
                      }, null, 512)
                    ]),
                    Wt("div", CQt, [
                      Wt("div", TQt, [
                        Wt("div", IQt, de(J(t)("modelTest.dialog.modelName")), 1),
                        Wt("div", AQt, de((_b2 = u.value) == null ? void 0 : _b2.modelName), 1)
                      ]),
                      Wt("div", kQt, [
                        Wt("div", DQt, de(J(t)("modelTest.dialog.detectionCount")), 1),
                        Wt("div", EQt, de((_c2 = u.value) == null ? void 0 : _c2.detections), 1)
                      ]),
                      Wt("div", MQt, [
                        Wt("div", RQt, de(J(t)("modelTest.warmupCount")), 1),
                        Wt("div", NQt, de((_d2 = u.value) == null ? void 0 : _d2.warmupCount), 1)
                      ]),
                      Wt("div", LQt, [
                        Wt("div", PQt, de(J(t)("modelTest.dialog.testCount")), 1),
                        Wt("div", $Qt, de((_e2 = u.value) == null ? void 0 : _e2.batchSize), 1)
                      ]),
                      Wt("div", OQt, [
                        Wt("div", FQt, de(J(t)("modelTest.dialog.totalCount")), 1),
                        Wt("div", BQt, de((((_f2 = u.value) == null ? void 0 : _f2.batchSize) ?? 0) + (((_g2 = u.value) == null ? void 0 : _g2.warmupCount) ?? 0)), 1)
                      ]),
                      Wt("div", zQt, [
                        Wt("div", VQt, de(J(t)("modelTest.dialog.warmupTime")), 1),
                        Wt("div", GQt, de((_i2 = (_h2 = u.value) == null ? void 0 : _h2.warmupTime) == null ? void 0 : _i2.toFixed(0)) + "ms", 1)
                      ]),
                      Wt("div", WQt, [
                        Wt("div", UQt, de(J(t)("modelTest.dialog.avgInferenceTime")), 1),
                        Wt("div", HQt, de((_k2 = (_j2 = u.value) == null ? void 0 : _j2.inferenceTime) == null ? void 0 : _k2.toFixed(0)) + "ms", 1)
                      ]),
                      Wt("div", XQt, [
                        Wt("div", YQt, de(J(t)("modelTest.dialog.avgFps")), 1),
                        Wt("div", qQt, de((_l2 = u.value) == null ? void 0 : _l2.fps), 1)
                      ]),
                      Wt("div", jQt, [
                        Wt("div", KQt, de(J(t)("modelTest.dialog.minInferenceTime")), 1),
                        Wt("div", ZQt, de((_n2 = (_m2 = u.value) == null ? void 0 : _m2.minInferenceTime) == null ? void 0 : _n2.toFixed(0)) + "ms", 1)
                      ]),
                      Wt("div", JQt, [
                        Wt("div", QQt, de(J(t)("modelTest.dialog.maxInferenceTime")), 1),
                        Wt("div", tte, de((_p2 = (_o2 = u.value) == null ? void 0 : _o2.maxInferenceTime) == null ? void 0 : _p2.toFixed(0)) + "ms", 1)
                      ]),
                      Wt("div", ete, [
                        Wt("div", nte, de(J(t)("modelTest.dialog.totalTime")), 1),
                        Wt("div", rte, de(((((_q2 = u.value) == null ? void 0 : _q2.totalTime) ?? 0) / 1e3).toFixed(1)) + "s", 1)
                      ])
                    ])
                  ])
                ];
              }),
              _: 1
            })
          ]),
          _: 1
        }, 8, [
          "open"
        ])
      ]));
    }
  });
  ste = Gtt(ate, [
    [
      "__scopeId",
      "data-v-39f09407"
    ]
  ]);
  gte = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: ste
  }, Symbol.toStringTag, {
    value: "Module"
  }));
});
export {
  zN as $,
  gQ as A,
  Di as B,
  Eh as C,
  as as D,
  rn as E,
  hs as F,
  Lw as G,
  fYt as H,
  EG as I,
  cd as J,
  FYt as K,
  YYt as L,
  Ve as M,
  Yn as N,
  yr as O,
  Xr as P,
  ZYt as Q,
  rk as R,
  mqt as S,
  B0 as T,
  tk as U,
  RG as V,
  GT as W,
  LG as X,
  gYt as Y,
  jr as Z,
  zJ as _,
  __tla,
  po as a,
  vQ as a0,
  fn as a1,
  An as a2,
  nqt as a3,
  Sqt as a4,
  Gqt as a5,
  Uqt as a6,
  jqt as a7,
  Zqt as a8,
  Jqt as a9,
  NN as aa,
  ch as ab,
  t7t as ac,
  e7t as ad,
  l1 as ae,
  hk as af,
  xf as ag,
  jjt as ah,
  EQ as ai,
  KG as aj,
  qG as ak,
  LXt as al,
  c1 as am,
  $Xt as an,
  NQ as ao,
  gte as ap,
  Sv as b,
  Nx as c,
  EN as d,
  Pa as e,
  jG as f,
  pqt as g,
  fQ as h,
  KJ as i,
  gs as j,
  hQ as k,
  Vqt as l,
  Wqt as m,
  yG as n,
  Yqt as o,
  Kqt as p,
  bQ as q,
  jXt as r,
  MN as s,
  on as t,
  oQ as u,
  PXt as v,
  Ki as w,
  tjt as x,
  Oo as y,
  OJ as z
};
