const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/browserAll-BmRNpMLm.js","assets/webworkerAll-Df24uNNZ.js","assets/colorToUniform-C2GHuDhf.js","assets/CanvasPool-BnRu4Vcd.js","assets/index-C_KNhBjg.js","assets/index-o16NAz4V.css","assets/base-D4gcL655.js","assets/WebGPURenderer-BMk906eM.js","assets/SharedSystems-CsCF3qDc.js","assets/WebGLRenderer-BKxAD3Yx.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { cL as ni, cM as V$, cz as rr, cN as PL, cO as Au, J as ph, E as Mt, cD as $$, cE as G$, cF as Wg, cP as Ug, cQ as Yw, s as Ze, cR as Rb, cS as au, cT as Xw, cU as W$, cV as U$, cW as H$, cX as kL, cK as Y$, cY as X$, cZ as q$, c_ as K$, c$ as Z$, d0 as j$, d1 as Q$, d2 as J$, d3 as eG, ay as tG, az as rG, d4 as nG, R as iG, D as aG, a as Ua, _ as oG, d5 as qw, I as sG, d6 as lG, d7 as vh, d8 as Kw, d9 as uG, A as cG, b as hG, c as fG, d as dG, e as pG, T as vG, j as Eb, p as Ys, g as lf, f as uf, i as Nb, k as gG, da as mG, h as yG, l as xG, m as _G, n as bG, o as SG, q as wG, r as CG, u as TG, v as AG, a$ as IG, b7 as MG, w as DG, x as cf, y as PG, z as $v, B as kG, C as LG, F as RG, S as EG, G as NG, db as OG, M as FG, N as LL, O as RL, P as EL, Q as BG, U as zG, V as VG, X as $G, bj as GG, dc as WG, Y as UG, dd as HG, de as YG, Z as XG, $ as qG, df as KG, a2 as gh, dg as ZG, a0 as jG, a1 as QG, a5 as JG, a6 as hf, a7 as go, dh as e5, a8 as t5, a9 as r5, aa as Ob, ab as n5, ac as i5, ad as a5, ae as o5, af as s5, ah as NL, ag as l5, ai as u5, aj as c5, ak as h5, al as f5, di as d5, dj as p5, am as v5, an as g5, ao as Fb, ap as m5, aq as y5, dk as x5, be as _5, cn as b5, dl as S5, dm as w5, dn as C5, dp as T5, dq as A5, dr as I5, ar as M5, as as D5, at as P5, au as k5, av as L5, aw as R5, ax as E5, ds as N5, aA as O5, aB as F5, aC as B5, dt as z5, aD as V5, aE as $5, aF as G5, b6 as OL, aG as W5, aH as U5, aI as H5, aJ as Y5, aK as X5, aL as q5, du as K5, aM as Z5, aN as j5, aO as Q5, aP as J5, aQ as eW, aR as tW, aS as rW, aT as nW, aU as iW, aV as aW, aW as oW, aX as sW, aZ as lW, a_ as uW, b0 as cW, b1 as hW, b2 as fW, b3 as dW, b4 as pW, b5 as vW, b8 as gW, b9 as mW, ba as yW, bd as xW, bb as _W, bc as bW, bf as SW, bg as wW, dv as CW, bi as TW, dw as AW, bk as IW, cx as MW, bl as DW, bm as PW, bn as kW, bo as LW, bp as RW, bq as EW, br as NW, bs as OW, bu as FW, bv as BW, bw as zW, bx as VW, by as $W, bz as GW, bA as WW, bB as UW, bC as HW, bD as YW, bE as XW, bF as qW, bG as KW, bH as ZW, bI as Bb, bJ as jW, bK as QW, bL as JW, bM as e4, bN as t4, bO as r4, bP as n4, bQ as i4, bR as a4, c4 as o4, c5 as s4, cr as l4, c6 as u4, dx as c4, c7 as h4, c8 as f4, c9 as d4, ca as p4, cb as v4, cc as g4, cd as m4, ce as y4, cf as x4, cg as _4, cm as b4, co as S4, cp as w4, cq as C4, cs as T4, ct as A4, cw as I4, dy as M4, dz as D4, cy as P4, dA as ou, cC as zb, dB as Hg, dC as Zw, dD as jw, dE as FL, dF as Vb, dG as We, dH as k4, dI as at, dJ as Pr, dK as BL, dL as Ye, dM as yn, dN as mh, dO as zL, dP as Iu, dQ as Gv, dR as Ge, dS as L4, dT as wa, dU as W, dV as ff, dW as _t, dX as ve, dY as ot, dZ as R4, d_ as VL, d$ as E4, e0 as Qw, e1 as N4, e2 as on, e3 as O4, e4 as $L, e5 as qe, e6 as F4, e7 as Mc, e8 as GL, e9 as yh, ea as $b, eb as Gb, ec as B4, ed as Fs, ee as z4, ef as V4, eg as $4, eh as G4, ei as W4, ej as _n, ek as Mr, el as pe, em as sp, en as nx, eo as $e, ep as hr, eq as Jw, er as U4, es as H4, __tla as __tla_0 } from "./index-C_KNhBjg.js";
import { __tla as __tla_1 } from "./base-D4gcL655.js";
let Sw, MV, rn, al, oi, Ct, ui, Fg, Fxe, HP, bu, u_e, y_e, pt, Qt, gr, Dr, S_e, cb, G_e, Yd, sb, XP, D0, KP, Vxe, kr, Jz, Yi, DV, Pt, $t, I_e, q_e, dbe, vbe, _be, Sbe, wbe, vw, Hs, T1e, A1e, Ov, yb, Ul, _1e, WV, hk, uk, axe, Bv, sxe, YV, WAe, tf, Lp, fw, Wn, ck, z_e, TV, uV, fi, CV, fbe, pbe, RP, ybe, bbe, RV, _xe, dw, At, _V, oxe, mn, Tbe, fa, Zz;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_1;
    } catch {
    }
  })()
]).then(async () => {
  var ix = function(r, e) {
    return ix = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(t, n) {
      t.__proto__ = n;
    } || function(t, n) {
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }, ix(r, e);
  };
  function G(r, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    ix(r, e);
    function t() {
      this.constructor = r;
    }
    r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
  }
  var Y4 = /* @__PURE__ */ function() {
    function r() {
      this.firefox = false, this.ie = false, this.edge = false, this.newEdge = false, this.weChat = false;
    }
    return r;
  }(), X4 = /* @__PURE__ */ function() {
    function r() {
      this.browser = new Y4(), this.node = false, this.wxa = false, this.worker = false, this.svgSupported = false, this.touchEventsSupported = false, this.pointerEventsSupported = false, this.domSupported = false, this.transformSupported = false, this.transform3dSupported = false, this.hasGlobalWindow = typeof window < "u";
    }
    return r;
  }(), He = new X4();
  typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (He.wxa = true, He.touchEventsSupported = true) : typeof document > "u" && typeof self < "u" ? He.worker = true : !He.hasGlobalWindow || "Deno" in window ? (He.node = true, He.svgSupported = true) : q4(navigator.userAgent, He);
  function q4(r, e) {
    var t = e.browser, n = r.match(/Firefox\/([\d.]+)/), i = r.match(/MSIE\s([\d.]+)/) || r.match(/Trident\/.+?rv:(([\d.]+))/), a = r.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(r);
    n && (t.firefox = true, t.version = n[1]), i && (t.ie = true, t.version = i[1]), a && (t.edge = true, t.version = a[1], t.newEdge = +a[1].split(".")[0] > 18), o && (t.weChat = true), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !t.ie && !t.edge, e.pointerEventsSupported = "onpointerdown" in window && (t.edge || t.ie && +t.version >= 11), e.domSupported = typeof document < "u";
    var s = document.documentElement.style;
    e.transform3dSupported = (t.ie && "transition" in s || t.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), e.transformSupported = e.transform3dSupported || t.ie && +t.version >= 9;
  }
  var Wb = 12, WL = "sans-serif", oo = Wb + "px " + WL, K4 = 20, Z4 = 100, j4 = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
  function Q4(r) {
    var e = {};
    if (typeof JSON > "u") return e;
    for (var t = 0; t < r.length; t++) {
      var n = String.fromCharCode(t + 32), i = (r.charCodeAt(t) - K4) / Z4;
      e[n] = i;
    }
    return e;
  }
  var J4 = Q4(j4), so = {
    createCanvas: function() {
      return typeof document < "u" && document.createElement("canvas");
    },
    measureText: /* @__PURE__ */ function() {
      var r, e;
      return function(t, n) {
        if (!r) {
          var i = so.createCanvas();
          r = i && i.getContext("2d");
        }
        if (r) return e !== n && (e = r.font = n || oo), r.measureText(t);
        t = t || "", n = n || oo;
        var a = /((?:\d+)?\.?\d*)px/.exec(n), o = a && +a[1] || Wb, s = 0;
        if (n.indexOf("mono") >= 0) s = o * t.length;
        else for (var l = 0; l < t.length; l++) {
          var u = J4[t[l]];
          s += u == null ? o : u * o;
        }
        return {
          width: s
        };
      };
    }(),
    loadImage: function(r, e, t) {
      var n = new Image();
      return n.onload = e, n.onerror = t, n.src = r, n;
    }
  }, UL = Fi([
    "Function",
    "RegExp",
    "Date",
    "Error",
    "CanvasGradient",
    "CanvasPattern",
    "Image",
    "Canvas"
  ], function(r, e) {
    return r["[object " + e + "]"] = true, r;
  }, {}), HL = Fi([
    "Int8",
    "Uint8",
    "Uint8Clamped",
    "Int16",
    "Uint16",
    "Int32",
    "Uint32",
    "Float32",
    "Float64"
  ], function(r, e) {
    return r["[object " + e + "Array]"] = true, r;
  }, {}), Mu = Object.prototype.toString, Wv = Array.prototype, eU = Wv.forEach, tU = Wv.filter, Ub = Wv.slice, rU = Wv.map, eC = (function() {
  }).constructor, zf = eC ? eC.prototype : null, Hb = "__proto__", nU = 2311;
  function YL() {
    return nU++;
  }
  function Yb() {
    for (var r = [], e = 0; e < arguments.length; e++) r[e] = arguments[e];
    typeof console < "u" && console.error.apply(console, r);
  }
  function be(r) {
    if (r == null || typeof r != "object") return r;
    var e = r, t = Mu.call(r);
    if (t === "[object Array]") {
      if (!Xc(r)) {
        e = [];
        for (var n = 0, i = r.length; n < i; n++) e[n] = be(r[n]);
      }
    } else if (HL[t]) {
      if (!Xc(r)) {
        var a = r.constructor;
        if (a.from) e = a.from(r);
        else {
          e = new a(r.length);
          for (var n = 0, i = r.length; n < i; n++) e[n] = r[n];
        }
      }
    } else if (!UL[t] && !Xc(r) && !su(r)) {
      e = {};
      for (var o in r) r.hasOwnProperty(o) && o !== Hb && (e[o] = be(r[o]));
    }
    return e;
  }
  function Ee(r, e, t) {
    if (!_e(e) || !_e(r)) return t ? be(e) : r;
    for (var n in e) if (e.hasOwnProperty(n) && n !== Hb) {
      var i = r[n], a = e[n];
      _e(a) && _e(i) && !X(a) && !X(i) && !su(a) && !su(i) && !tC(a) && !tC(i) && !Xc(a) && !Xc(i) ? Ee(i, a, t) : (t || !(n in r)) && (r[n] = be(e[n]));
    }
    return r;
  }
  function Xb(r, e) {
    for (var t = r[0], n = 1, i = r.length; n < i; n++) t = Ee(t, r[n], e);
    return t;
  }
  function H(r, e) {
    if (Object.assign) Object.assign(r, e);
    else for (var t in e) e.hasOwnProperty(t) && t !== Hb && (r[t] = e[t]);
    return r;
  }
  function ye(r, e, t) {
    for (var n = je(e), i = 0, a = n.length; i < a; i++) {
      var o = n[i];
      (t ? e[o] != null : r[o] == null) && (r[o] = e[o]);
    }
    return r;
  }
  function Be(r, e) {
    if (r) {
      if (r.indexOf) return r.indexOf(e);
      for (var t = 0, n = r.length; t < n; t++) if (r[t] === e) return t;
    }
    return -1;
  }
  function iU(r, e) {
    var t = r.prototype;
    function n() {
    }
    n.prototype = e.prototype, r.prototype = new n();
    for (var i in t) t.hasOwnProperty(i) && (r.prototype[i] = t[i]);
    r.prototype.constructor = r, r.superClass = e;
  }
  function qt(r, e, t) {
    if (r = "prototype" in r ? r.prototype : r, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames) for (var n = Object.getOwnPropertyNames(e), i = 0; i < n.length; i++) {
      var a = n[i];
      a !== "constructor" && (t ? e[a] != null : r[a] == null) && (r[a] = e[a]);
    }
    else ye(r, e, t);
  }
  function Lr(r) {
    return !r || typeof r == "string" ? false : typeof r.length == "number";
  }
  function D(r, e, t) {
    if (r && e) if (r.forEach && r.forEach === eU) r.forEach(e, t);
    else if (r.length === +r.length) for (var n = 0, i = r.length; n < i; n++) e.call(t, r[n], n, r);
    else for (var a in r) r.hasOwnProperty(a) && e.call(t, r[a], a, r);
  }
  function K(r, e, t) {
    if (!r) return [];
    if (!e) return qb(r);
    if (r.map && r.map === rU) return r.map(e, t);
    for (var n = [], i = 0, a = r.length; i < a; i++) n.push(e.call(t, r[i], i, r));
    return n;
  }
  function Fi(r, e, t, n) {
    if (r && e) {
      for (var i = 0, a = r.length; i < a; i++) t = e.call(n, t, r[i], i, r);
      return t;
    }
  }
  function ct(r, e, t) {
    if (!r) return [];
    if (!e) return qb(r);
    if (r.filter && r.filter === tU) return r.filter(e, t);
    for (var n = [], i = 0, a = r.length; i < a; i++) e.call(t, r[i], i, r) && n.push(r[i]);
    return n;
  }
  function aU(r, e, t) {
    if (r && e) {
      for (var n = 0, i = r.length; n < i; n++) if (e.call(t, r[n], n, r)) return r[n];
    }
  }
  function je(r) {
    if (!r) return [];
    if (Object.keys) return Object.keys(r);
    var e = [];
    for (var t in r) r.hasOwnProperty(t) && e.push(t);
    return e;
  }
  function oU(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++) t[n - 2] = arguments[n];
    return function() {
      return r.apply(e, t.concat(Ub.call(arguments)));
    };
  }
  var ne = zf && ge(zf.bind) ? zf.call.bind(zf.bind) : oU;
  function Le(r) {
    for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
    return function() {
      return r.apply(this, e.concat(Ub.call(arguments)));
    };
  }
  function X(r) {
    return Array.isArray ? Array.isArray(r) : Mu.call(r) === "[object Array]";
  }
  function ge(r) {
    return typeof r == "function";
  }
  function ee(r) {
    return typeof r == "string";
  }
  function ax(r) {
    return Mu.call(r) === "[object String]";
  }
  function nt(r) {
    return typeof r == "number";
  }
  function _e(r) {
    var e = typeof r;
    return e === "function" || !!r && e === "object";
  }
  function tC(r) {
    return !!UL[Mu.call(r)];
  }
  function sn(r) {
    return !!HL[Mu.call(r)];
  }
  function su(r) {
    return typeof r == "object" && typeof r.nodeType == "number" && typeof r.ownerDocument == "object";
  }
  function Uv(r) {
    return r.colorStops != null;
  }
  function sU(r) {
    return r.image != null;
  }
  function lU(r) {
    return Mu.call(r) === "[object RegExp]";
  }
  function xh(r) {
    return r !== r;
  }
  function vr() {
    for (var r = [], e = 0; e < arguments.length; e++) r[e] = arguments[e];
    for (var t = 0, n = r.length; t < n; t++) if (r[t] != null) return r[t];
  }
  function Pe(r, e) {
    return r ?? e;
  }
  function Li(r, e, t) {
    return r ?? e ?? t;
  }
  function qb(r) {
    for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
    return Ub.apply(r, e);
  }
  function Kb(r) {
    if (typeof r == "number") return [
      r,
      r,
      r,
      r
    ];
    var e = r.length;
    return e === 2 ? [
      r[0],
      r[1],
      r[0],
      r[1]
    ] : e === 3 ? [
      r[0],
      r[1],
      r[2],
      r[1]
    ] : r;
  }
  function Yr(r, e) {
    if (!r) throw new Error(e);
  }
  function ei(r) {
    return r == null ? null : typeof r.trim == "function" ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
  var XL = "__ec_primitive__";
  function Np(r) {
    r[XL] = true;
  }
  function Xc(r) {
    return r[XL];
  }
  var uU = function() {
    function r() {
      this.data = {};
    }
    return r.prototype.delete = function(e) {
      var t = this.has(e);
      return t && delete this.data[e], t;
    }, r.prototype.has = function(e) {
      return this.data.hasOwnProperty(e);
    }, r.prototype.get = function(e) {
      return this.data[e];
    }, r.prototype.set = function(e, t) {
      return this.data[e] = t, this;
    }, r.prototype.keys = function() {
      return je(this.data);
    }, r.prototype.forEach = function(e) {
      var t = this.data;
      for (var n in t) t.hasOwnProperty(n) && e(t[n], n);
    }, r;
  }(), qL = typeof Map == "function";
  function cU() {
    return qL ? /* @__PURE__ */ new Map() : new uU();
  }
  var hU = function() {
    function r(e) {
      var t = X(e);
      this.data = cU();
      var n = this;
      e instanceof r ? e.each(i) : e && D(e, i);
      function i(a, o) {
        t ? n.set(a, o) : n.set(o, a);
      }
    }
    return r.prototype.hasKey = function(e) {
      return this.data.has(e);
    }, r.prototype.get = function(e) {
      return this.data.get(e);
    }, r.prototype.set = function(e, t) {
      return this.data.set(e, t), t;
    }, r.prototype.each = function(e, t) {
      this.data.forEach(function(n, i) {
        e.call(t, n, i);
      });
    }, r.prototype.keys = function() {
      var e = this.data.keys();
      return qL ? Array.from(e) : e;
    }, r.prototype.removeKey = function(e) {
      this.data.delete(e);
    }, r;
  }();
  function ce(r) {
    return new hU(r);
  }
  function _h(r, e) {
    for (var t = new r.constructor(r.length + e.length), n = 0; n < r.length; n++) t[n] = r[n];
    for (var i = r.length, n = 0; n < e.length; n++) t[n + i] = e[n];
    return t;
  }
  function Hv(r, e) {
    var t;
    if (Object.create) t = Object.create(r);
    else {
      var n = function() {
      };
      n.prototype = r, t = new n();
    }
    return e && H(t, e), t;
  }
  function KL(r) {
    var e = r.style;
    e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none";
  }
  function oe(r, e) {
    return r.hasOwnProperty(e);
  }
  function Wt() {
  }
  var lp = 180 / Math.PI;
  function Xs(r, e) {
    return r == null && (r = 0), e == null && (e = 0), [
      r,
      e
    ];
  }
  function Fr(r, e) {
    return r[0] = e[0], r[1] = e[1], r;
  }
  function oa(r) {
    return [
      r[0],
      r[1]
    ];
  }
  function fU(r, e, t) {
    return r[0] = e, r[1] = t, r;
  }
  function rC(r, e, t) {
    return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
  }
  function ox(r, e, t, n) {
    return r[0] = e[0] + t[0] * n, r[1] = e[1] + t[1] * n, r;
  }
  function vs(r, e, t) {
    return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r;
  }
  function sx(r) {
    return Math.sqrt(dU(r));
  }
  function dU(r) {
    return r[0] * r[0] + r[1] * r[1];
  }
  function up(r, e, t) {
    return r[0] = e[0] * t, r[1] = e[1] * t, r;
  }
  function Du(r, e) {
    var t = sx(e);
    return t === 0 ? (r[0] = 0, r[1] = 0) : (r[0] = e[0] / t, r[1] = e[1] / t), r;
  }
  function lx(r, e) {
    return Math.sqrt((r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]));
  }
  var Ha = lx;
  function pU(r, e) {
    return (r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]);
  }
  var As = pU;
  function cp(r, e, t, n) {
    return r[0] = e[0] + n * (t[0] - e[0]), r[1] = e[1] + n * (t[1] - e[1]), r;
  }
  function xr(r, e, t) {
    var n = e[0], i = e[1];
    return r[0] = t[0] * n + t[2] * i + t[4], r[1] = t[1] * n + t[3] * i + t[5], r;
  }
  function Ya(r, e, t) {
    return r[0] = Math.min(e[0], t[0]), r[1] = Math.min(e[1], t[1]), r;
  }
  function Xa(r, e, t) {
    return r[0] = Math.max(e[0], t[0]), r[1] = Math.max(e[1], t[1]), r;
  }
  var ll = /* @__PURE__ */ function() {
    function r(e, t) {
      this.target = e, this.topTarget = t && t.topTarget;
    }
    return r;
  }(), vU = function() {
    function r(e) {
      this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this);
    }
    return r.prototype._dragStart = function(e) {
      for (var t = e.target; t && !t.draggable; ) t = t.parent || t.__hostTarget;
      t && (this._draggingTarget = t, t.dragging = true, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new ll(t, e), "dragstart", e.event));
    }, r.prototype._drag = function(e) {
      var t = this._draggingTarget;
      if (t) {
        var n = e.offsetX, i = e.offsetY, a = n - this._x, o = i - this._y;
        this._x = n, this._y = i, t.drift(a, o, e), this.handler.dispatchToElement(new ll(t, e), "drag", e.event);
        var s = this.handler.findHover(n, i, t).target, l = this._dropTarget;
        this._dropTarget = s, t !== s && (l && s !== l && this.handler.dispatchToElement(new ll(l, e), "dragleave", e.event), s && s !== l && this.handler.dispatchToElement(new ll(s, e), "dragenter", e.event));
      }
    }, r.prototype._dragEnd = function(e) {
      var t = this._draggingTarget;
      t && (t.dragging = false), this.handler.dispatchToElement(new ll(t, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new ll(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null;
    }, r;
  }(), Vn = function() {
    function r(e) {
      e && (this._$eventProcessor = e);
    }
    return r.prototype.on = function(e, t, n, i) {
      this._$handlers || (this._$handlers = {});
      var a = this._$handlers;
      if (typeof t == "function" && (i = n, n = t, t = null), !n || !e) return this;
      var o = this._$eventProcessor;
      t != null && o && o.normalizeQuery && (t = o.normalizeQuery(t)), a[e] || (a[e] = []);
      for (var s = 0; s < a[e].length; s++) if (a[e][s].h === n) return this;
      var l = {
        h: n,
        query: t,
        ctx: i || this,
        callAtLast: n.zrEventfulCallAtLast
      }, u = a[e].length - 1, c = a[e][u];
      return c && c.callAtLast ? a[e].splice(u, 0, l) : a[e].push(l), this;
    }, r.prototype.isSilent = function(e) {
      var t = this._$handlers;
      return !t || !t[e] || !t[e].length;
    }, r.prototype.off = function(e, t) {
      var n = this._$handlers;
      if (!n) return this;
      if (!e) return this._$handlers = {}, this;
      if (t) {
        if (n[e]) {
          for (var i = [], a = 0, o = n[e].length; a < o; a++) n[e][a].h !== t && i.push(n[e][a]);
          n[e] = i;
        }
        n[e] && n[e].length === 0 && delete n[e];
      } else delete n[e];
      return this;
    }, r.prototype.trigger = function(e) {
      for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      if (!this._$handlers) return this;
      var i = this._$handlers[e], a = this._$eventProcessor;
      if (i) for (var o = t.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(a && a.filter && u.query != null && !a.filter(e, u.query))) switch (o) {
          case 0:
            u.h.call(u.ctx);
            break;
          case 1:
            u.h.call(u.ctx, t[0]);
            break;
          case 2:
            u.h.call(u.ctx, t[0], t[1]);
            break;
          default:
            u.h.apply(u.ctx, t);
            break;
        }
      }
      return a && a.afterTrigger && a.afterTrigger(e), this;
    }, r.prototype.triggerWithContext = function(e) {
      for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      if (!this._$handlers) return this;
      var i = this._$handlers[e], a = this._$eventProcessor;
      if (i) for (var o = t.length, s = t[o - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(a && a.filter && c.query != null && !a.filter(e, c.query))) switch (o) {
          case 0:
            c.h.call(s);
            break;
          case 1:
            c.h.call(s, t[0]);
            break;
          case 2:
            c.h.call(s, t[0], t[1]);
            break;
          default:
            c.h.apply(s, t.slice(1, o - 1));
            break;
        }
      }
      return a && a.afterTrigger && a.afterTrigger(e), this;
    }, r;
  }(), gU = Math.log(2);
  function ux(r, e, t, n, i, a) {
    var o = n + "-" + i, s = r.length;
    if (a.hasOwnProperty(o)) return a[o];
    if (e === 1) {
      var l = Math.round(Math.log((1 << s) - 1 & ~i) / gU);
      return r[t][l];
    }
    for (var u = n | 1 << t, c = t + 1; n & 1 << c; ) c++;
    for (var h = 0, f = 0, d = 0; f < s; f++) {
      var p = 1 << f;
      p & i || (h += (d % 2 ? -1 : 1) * r[t][f] * ux(r, e - 1, c, u, i | p, a), d++);
    }
    return a[o] = h, h;
  }
  function nC(r, e) {
    var t = [
      [
        r[0],
        r[1],
        1,
        0,
        0,
        0,
        -e[0] * r[0],
        -e[0] * r[1]
      ],
      [
        0,
        0,
        0,
        r[0],
        r[1],
        1,
        -e[1] * r[0],
        -e[1] * r[1]
      ],
      [
        r[2],
        r[3],
        1,
        0,
        0,
        0,
        -e[2] * r[2],
        -e[2] * r[3]
      ],
      [
        0,
        0,
        0,
        r[2],
        r[3],
        1,
        -e[3] * r[2],
        -e[3] * r[3]
      ],
      [
        r[4],
        r[5],
        1,
        0,
        0,
        0,
        -e[4] * r[4],
        -e[4] * r[5]
      ],
      [
        0,
        0,
        0,
        r[4],
        r[5],
        1,
        -e[5] * r[4],
        -e[5] * r[5]
      ],
      [
        r[6],
        r[7],
        1,
        0,
        0,
        0,
        -e[6] * r[6],
        -e[6] * r[7]
      ],
      [
        0,
        0,
        0,
        r[6],
        r[7],
        1,
        -e[7] * r[6],
        -e[7] * r[7]
      ]
    ], n = {}, i = ux(t, 8, 0, 0, 0, n);
    if (i !== 0) {
      for (var a = [], o = 0; o < 8; o++) for (var s = 0; s < 8; s++) a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * ux(t, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, n) / i * e[o];
      return function(l, u, c) {
        var h = u * a[6] + c * a[7] + 1;
        l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
      };
    }
  }
  var iC = "___zrEVENTSAVED", Yg = [];
  function mU(r, e, t, n, i) {
    return cx(Yg, e, n, i, true) && cx(r, t, Yg[0], Yg[1]);
  }
  function cx(r, e, t, n, i) {
    if (e.getBoundingClientRect && He.domSupported && !ZL(e)) {
      var a = e[iC] || (e[iC] = {}), o = yU(e, a), s = xU(o, a, i);
      if (s) return s(r, t, n), true;
    }
    return false;
  }
  function yU(r, e) {
    var t = e.markers;
    if (t) return t;
    t = e.markers = [];
    for (var n = [
      "left",
      "right"
    ], i = [
      "top",
      "bottom"
    ], a = 0; a < 4; a++) {
      var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
      s.cssText = [
        "position: absolute",
        "visibility: hidden",
        "padding: 0",
        "margin: 0",
        "border-width: 0",
        "user-select: none",
        "width:0",
        "height:0",
        n[l] + ":0",
        i[u] + ":0",
        n[1 - l] + ":auto",
        i[1 - u] + ":auto",
        ""
      ].join("!important;"), r.appendChild(o), t.push(o);
    }
    return t;
  }
  function xU(r, e, t) {
    for (var n = t ? "invTrans" : "trans", i = e[n], a = e.srcCoords, o = [], s = [], l = true, u = 0; u < 4; u++) {
      var c = r[u].getBoundingClientRect(), h = 2 * u, f = c.left, d = c.top;
      o.push(f, d), l = l && a && f === a[h] && d === a[h + 1], s.push(r[u].offsetLeft, r[u].offsetTop);
    }
    return l && i ? i : (e.srcCoords = o, e[n] = t ? nC(s, o) : nC(o, s));
  }
  function ZL(r) {
    return r.nodeName.toUpperCase() === "CANVAS";
  }
  var _U = /([&<>"'])/g, bU = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function Vr(r) {
    return r == null ? "" : (r + "").replace(_U, function(e, t) {
      return bU[t];
    });
  }
  var SU = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Xg = [], wU = He.browser.firefox && +He.browser.version.split(".")[0] < 39;
  function hx(r, e, t, n) {
    return t = t || {}, n ? aC(r, e, t) : wU && e.layerX != null && e.layerX !== e.offsetX ? (t.zrX = e.layerX, t.zrY = e.layerY) : e.offsetX != null ? (t.zrX = e.offsetX, t.zrY = e.offsetY) : aC(r, e, t), t;
  }
  function aC(r, e, t) {
    if (He.domSupported && r.getBoundingClientRect) {
      var n = e.clientX, i = e.clientY;
      if (ZL(r)) {
        var a = r.getBoundingClientRect();
        t.zrX = n - a.left, t.zrY = i - a.top;
        return;
      } else if (cx(Xg, r, n, i)) {
        t.zrX = Xg[0], t.zrY = Xg[1];
        return;
      }
    }
    t.zrX = t.zrY = 0;
  }
  function Zb(r) {
    return r || window.event;
  }
  function In(r, e, t) {
    if (e = Zb(e), e.zrX != null) return e;
    var n = e.type, i = n && n.indexOf("touch") >= 0;
    if (i) {
      var o = n !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
      o && hx(r, o, e, t);
    } else {
      hx(r, e, e, t);
      var a = CU(e);
      e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3;
    }
    var s = e.button;
    return e.which == null && s !== void 0 && SU.test(e.type) && (e.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), e;
  }
  function CU(r) {
    var e = r.wheelDelta;
    if (e) return e;
    var t = r.deltaX, n = r.deltaY;
    if (t == null || n == null) return e;
    var i = Math.abs(n !== 0 ? n : t), a = n > 0 ? -1 : n < 0 ? 1 : t > 0 ? -1 : 1;
    return 3 * i * a;
  }
  function fx(r, e, t, n) {
    r.addEventListener(e, t, n);
  }
  function TU(r, e, t, n) {
    r.removeEventListener(e, t, n);
  }
  var pa = function(r) {
    r.preventDefault(), r.stopPropagation(), r.cancelBubble = true;
  };
  function oC(r) {
    return r.which === 2 || r.which === 3;
  }
  var AU = function() {
    function r() {
      this._track = [];
    }
    return r.prototype.recognize = function(e, t, n) {
      return this._doTrack(e, t, n), this._recognize(e);
    }, r.prototype.clear = function() {
      return this._track.length = 0, this;
    }, r.prototype._doTrack = function(e, t, n) {
      var i = e.touches;
      if (i) {
        for (var a = {
          points: [],
          touches: [],
          target: t,
          event: e
        }, o = 0, s = i.length; o < s; o++) {
          var l = i[o], u = hx(n, l, {});
          a.points.push([
            u.zrX,
            u.zrY
          ]), a.touches.push(l);
        }
        this._track.push(a);
      }
    }, r.prototype._recognize = function(e) {
      for (var t in qg) if (qg.hasOwnProperty(t)) {
        var n = qg[t](this._track, e);
        if (n) return n;
      }
    }, r;
  }();
  function sC(r) {
    var e = r[1][0] - r[0][0], t = r[1][1] - r[0][1];
    return Math.sqrt(e * e + t * t);
  }
  function IU(r) {
    return [
      (r[0][0] + r[1][0]) / 2,
      (r[0][1] + r[1][1]) / 2
    ];
  }
  var qg = {
    pinch: function(r, e) {
      var t = r.length;
      if (t) {
        var n = (r[t - 1] || {}).points, i = (r[t - 2] || {}).points || n;
        if (i && i.length > 1 && n && n.length > 1) {
          var a = sC(n) / sC(i);
          !isFinite(a) && (a = 1), e.pinchScale = a;
          var o = IU(n);
          return e.pinchX = o[0], e.pinchY = o[1], {
            type: "pinch",
            target: r[0].target,
            event: e
          };
        }
      }
    }
  };
  function pn() {
    return [
      1,
      0,
      0,
      1,
      0,
      0
    ];
  }
  function Yv(r) {
    return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
  }
  function jb(r, e) {
    return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r;
  }
  function sa(r, e, t) {
    var n = e[0] * t[0] + e[2] * t[1], i = e[1] * t[0] + e[3] * t[1], a = e[0] * t[2] + e[2] * t[3], o = e[1] * t[2] + e[3] * t[3], s = e[0] * t[4] + e[2] * t[5] + e[4], l = e[1] * t[4] + e[3] * t[5] + e[5];
    return r[0] = n, r[1] = i, r[2] = a, r[3] = o, r[4] = s, r[5] = l, r;
  }
  function Bi(r, e, t) {
    return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4] + t[0], r[5] = e[5] + t[1], r;
  }
  function qs(r, e, t, n) {
    n === void 0 && (n = [
      0,
      0
    ]);
    var i = e[0], a = e[2], o = e[4], s = e[1], l = e[3], u = e[5], c = Math.sin(t), h = Math.cos(t);
    return r[0] = i * h + s * c, r[1] = -i * c + s * h, r[2] = a * h + l * c, r[3] = -a * c + h * l, r[4] = h * (o - n[0]) + c * (u - n[1]) + n[0], r[5] = h * (u - n[1]) - c * (o - n[0]) + n[1], r;
  }
  function Qb(r, e, t) {
    var n = t[0], i = t[1];
    return r[0] = e[0] * n, r[1] = e[1] * i, r[2] = e[2] * n, r[3] = e[3] * i, r[4] = e[4] * n, r[5] = e[5] * i, r;
  }
  function Pu(r, e) {
    var t = e[0], n = e[2], i = e[4], a = e[1], o = e[3], s = e[5], l = t * o - a * n;
    return l ? (l = 1 / l, r[0] = o * l, r[1] = -a * l, r[2] = -n * l, r[3] = t * l, r[4] = (n * s - o * i) * l, r[5] = (a * i - t * s) * l, r) : null;
  }
  function MU(r) {
    var e = pn();
    return jb(e, r), e;
  }
  var Ne = function() {
    function r(e, t) {
      this.x = e || 0, this.y = t || 0;
    }
    return r.prototype.copy = function(e) {
      return this.x = e.x, this.y = e.y, this;
    }, r.prototype.clone = function() {
      return new r(this.x, this.y);
    }, r.prototype.set = function(e, t) {
      return this.x = e, this.y = t, this;
    }, r.prototype.equal = function(e) {
      return e.x === this.x && e.y === this.y;
    }, r.prototype.add = function(e) {
      return this.x += e.x, this.y += e.y, this;
    }, r.prototype.scale = function(e) {
      this.x *= e, this.y *= e;
    }, r.prototype.scaleAndAdd = function(e, t) {
      this.x += e.x * t, this.y += e.y * t;
    }, r.prototype.sub = function(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }, r.prototype.dot = function(e) {
      return this.x * e.x + this.y * e.y;
    }, r.prototype.len = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }, r.prototype.lenSquare = function() {
      return this.x * this.x + this.y * this.y;
    }, r.prototype.normalize = function() {
      var e = this.len();
      return this.x /= e, this.y /= e, this;
    }, r.prototype.distance = function(e) {
      var t = this.x - e.x, n = this.y - e.y;
      return Math.sqrt(t * t + n * n);
    }, r.prototype.distanceSquare = function(e) {
      var t = this.x - e.x, n = this.y - e.y;
      return t * t + n * n;
    }, r.prototype.negate = function() {
      return this.x = -this.x, this.y = -this.y, this;
    }, r.prototype.transform = function(e) {
      if (e) {
        var t = this.x, n = this.y;
        return this.x = e[0] * t + e[2] * n + e[4], this.y = e[1] * t + e[3] * n + e[5], this;
      }
    }, r.prototype.toArray = function(e) {
      return e[0] = this.x, e[1] = this.y, e;
    }, r.prototype.fromArray = function(e) {
      this.x = e[0], this.y = e[1];
    }, r.set = function(e, t, n) {
      e.x = t, e.y = n;
    }, r.copy = function(e, t) {
      e.x = t.x, e.y = t.y;
    }, r.len = function(e) {
      return Math.sqrt(e.x * e.x + e.y * e.y);
    }, r.lenSquare = function(e) {
      return e.x * e.x + e.y * e.y;
    }, r.dot = function(e, t) {
      return e.x * t.x + e.y * t.y;
    }, r.add = function(e, t, n) {
      e.x = t.x + n.x, e.y = t.y + n.y;
    }, r.sub = function(e, t, n) {
      e.x = t.x - n.x, e.y = t.y - n.y;
    }, r.scale = function(e, t, n) {
      e.x = t.x * n, e.y = t.y * n;
    }, r.scaleAndAdd = function(e, t, n, i) {
      e.x = t.x + n.x * i, e.y = t.y + n.y * i;
    }, r.lerp = function(e, t, n, i) {
      var a = 1 - i;
      e.x = a * t.x + i * n.x, e.y = a * t.y + i * n.y;
    }, r;
  }(), Vf = Math.min, $f = Math.max, To = new Ne(), Ao = new Ne(), Io = new Ne(), Mo = new Ne(), qu = new Ne(), Ku = new Ne(), Oe = function() {
    function r(e, t, n, i) {
      n < 0 && (e = e + n, n = -n), i < 0 && (t = t + i, i = -i), this.x = e, this.y = t, this.width = n, this.height = i;
    }
    return r.prototype.union = function(e) {
      var t = Vf(e.x, this.x), n = Vf(e.y, this.y);
      isFinite(this.x) && isFinite(this.width) ? this.width = $f(e.x + e.width, this.x + this.width) - t : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = $f(e.y + e.height, this.y + this.height) - n : this.height = e.height, this.x = t, this.y = n;
    }, r.prototype.applyTransform = function(e) {
      r.applyTransform(this, this, e);
    }, r.prototype.calculateTransform = function(e) {
      var t = this, n = e.width / t.width, i = e.height / t.height, a = pn();
      return Bi(a, a, [
        -t.x,
        -t.y
      ]), Qb(a, a, [
        n,
        i
      ]), Bi(a, a, [
        e.x,
        e.y
      ]), a;
    }, r.prototype.intersect = function(e, t) {
      if (!e) return false;
      e instanceof r || (e = r.create(e));
      var n = this, i = n.x, a = n.x + n.width, o = n.y, s = n.y + n.height, l = e.x, u = e.x + e.width, c = e.y, h = e.y + e.height, f = !(a < l || u < i || s < c || h < o);
      if (t) {
        var d = 1 / 0, p = 0, v = Math.abs(a - l), g = Math.abs(u - i), m = Math.abs(s - c), y = Math.abs(h - o), x = Math.min(v, g), _ = Math.min(m, y);
        a < l || u < i ? x > p && (p = x, v < g ? Ne.set(Ku, -v, 0) : Ne.set(Ku, g, 0)) : x < d && (d = x, v < g ? Ne.set(qu, v, 0) : Ne.set(qu, -g, 0)), s < c || h < o ? _ > p && (p = _, m < y ? Ne.set(Ku, 0, -m) : Ne.set(Ku, 0, y)) : x < d && (d = x, m < y ? Ne.set(qu, 0, m) : Ne.set(qu, 0, -y));
      }
      return t && Ne.copy(t, f ? qu : Ku), f;
    }, r.prototype.contain = function(e, t) {
      var n = this;
      return e >= n.x && e <= n.x + n.width && t >= n.y && t <= n.y + n.height;
    }, r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height);
    }, r.prototype.copy = function(e) {
      r.copy(this, e);
    }, r.prototype.plain = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    }, r.prototype.isFinite = function() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    }, r.prototype.isZero = function() {
      return this.width === 0 || this.height === 0;
    }, r.create = function(e) {
      return new r(e.x, e.y, e.width, e.height);
    }, r.copy = function(e, t) {
      e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height;
    }, r.applyTransform = function(e, t, n) {
      if (!n) {
        e !== t && r.copy(e, t);
        return;
      }
      if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
        var i = n[0], a = n[3], o = n[4], s = n[5];
        e.x = t.x * i + o, e.y = t.y * a + s, e.width = t.width * i, e.height = t.height * a, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
        return;
      }
      To.x = Io.x = t.x, To.y = Mo.y = t.y, Ao.x = Mo.x = t.x + t.width, Ao.y = Io.y = t.y + t.height, To.transform(n), Mo.transform(n), Ao.transform(n), Io.transform(n), e.x = Vf(To.x, Ao.x, Io.x, Mo.x), e.y = Vf(To.y, Ao.y, Io.y, Mo.y);
      var l = $f(To.x, Ao.x, Io.x, Mo.x), u = $f(To.y, Ao.y, Io.y, Mo.y);
      e.width = l - e.x, e.height = u - e.y;
    }, r;
  }(), jL = "silent";
  function DU(r, e, t) {
    return {
      type: r,
      event: t,
      target: e.target,
      topTarget: e.topTarget,
      cancelBubble: false,
      offsetX: t.zrX,
      offsetY: t.zrY,
      gestureEvent: t.gestureEvent,
      pinchX: t.pinchX,
      pinchY: t.pinchY,
      pinchScale: t.pinchScale,
      wheelDelta: t.zrDelta,
      zrByTouch: t.zrByTouch,
      which: t.which,
      stop: PU
    };
  }
  function PU() {
    pa(this.event);
  }
  var kU = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.handler = null, t;
    }
    return e.prototype.dispose = function() {
    }, e.prototype.setCursor = function() {
    }, e;
  }(Vn), Zu = /* @__PURE__ */ function() {
    function r(e, t) {
      this.x = e, this.y = t;
    }
    return r;
  }(), LU = [
    "click",
    "dblclick",
    "mousewheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], Kg = new Oe(0, 0, 0, 0), QL = function(r) {
    G(e, r);
    function e(t, n, i, a, o) {
      var s = r.call(this) || this;
      return s._hovered = new Zu(0, 0), s.storage = t, s.painter = n, s.painterRoot = a, s._pointerSize = o, i = i || new kU(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new vU(s), s;
    }
    return e.prototype.setHandlerProxy = function(t) {
      this.proxy && this.proxy.dispose(), t && (D(LU, function(n) {
        t.on && t.on(n, this[n], this);
      }, this), t.handler = this), this.proxy = t;
    }, e.prototype.mousemove = function(t) {
      var n = t.zrX, i = t.zrY, a = JL(this, n, i), o = this._hovered, s = o.target;
      s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
      var l = this._hovered = a ? new Zu(n, i) : this.findHover(n, i), u = l.target, c = this.proxy;
      c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", t), this.dispatchToElement(l, "mousemove", t), u && u !== s && this.dispatchToElement(l, "mouseover", t);
    }, e.prototype.mouseout = function(t) {
      var n = t.zrEventControl;
      n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), n !== "no_globalout" && this.trigger("globalout", {
        type: "globalout",
        event: t
      });
    }, e.prototype.resize = function() {
      this._hovered = new Zu(0, 0);
    }, e.prototype.dispatch = function(t, n) {
      var i = this[t];
      i && i.call(this, n);
    }, e.prototype.dispose = function() {
      this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
    }, e.prototype.setCursorStyle = function(t) {
      var n = this.proxy;
      n.setCursor && n.setCursor(t);
    }, e.prototype.dispatchToElement = function(t, n, i) {
      t = t || {};
      var a = t.target;
      if (!(a && a.silent)) {
        for (var o = "on" + n, s = DU(n, t, i); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(n, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); ) ;
        s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
          typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(n, s);
        }));
      }
    }, e.prototype.findHover = function(t, n, i) {
      var a = this.storage.getDisplayList(), o = new Zu(t, n);
      if (lC(a, o, t, n, i), this._pointerSize && !o.target) {
        for (var s = [], l = this._pointerSize, u = l / 2, c = new Oe(t - u, n - u, l, l), h = a.length - 1; h >= 0; h--) {
          var f = a[h];
          f !== i && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (Kg.copy(f.getBoundingRect()), f.transform && Kg.applyTransform(f.transform), Kg.intersect(c) && s.push(f));
        }
        if (s.length) for (var d = 4, p = Math.PI / 12, v = Math.PI * 2, g = 0; g < u; g += d) for (var m = 0; m < v; m += p) {
          var y = t + g * Math.cos(m), x = n + g * Math.sin(m);
          if (lC(s, o, y, x, i), o.target) return o;
        }
      }
      return o;
    }, e.prototype.processGesture = function(t, n) {
      this._gestureMgr || (this._gestureMgr = new AU());
      var i = this._gestureMgr;
      n === "start" && i.clear();
      var a = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
      if (n === "end" && i.clear(), a) {
        var o = a.type;
        t.gestureEvent = o;
        var s = new Zu();
        s.target = a.target, this.dispatchToElement(s, o, a.event);
      }
    }, e;
  }(Vn);
  D([
    "click",
    "mousedown",
    "mouseup",
    "mousewheel",
    "dblclick",
    "contextmenu"
  ], function(r) {
    QL.prototype[r] = function(e) {
      var t = e.zrX, n = e.zrY, i = JL(this, t, n), a, o;
      if ((r !== "mouseup" || !i) && (a = this.findHover(t, n), o = a.target), r === "mousedown") this._downEl = o, this._downPoint = [
        e.zrX,
        e.zrY
      ], this._upEl = o;
      else if (r === "mouseup") this._upEl = o;
      else if (r === "click") {
        if (this._downEl !== this._upEl || !this._downPoint || Ha(this._downPoint, [
          e.zrX,
          e.zrY
        ]) > 4) return;
        this._downPoint = null;
      }
      this.dispatchToElement(a, r, e);
    };
  });
  function RU(r, e, t) {
    if (r[r.rectHover ? "rectContain" : "contain"](e, t)) {
      for (var n = r, i = void 0, a = false; n; ) {
        if (n.ignoreClip && (a = true), !a) {
          var o = n.getClipPath();
          if (o && !o.contain(e, t)) return false;
        }
        n.silent && (i = true);
        var s = n.__hostTarget;
        n = s || n.parent;
      }
      return i ? jL : true;
    }
    return false;
  }
  function lC(r, e, t, n, i) {
    for (var a = r.length - 1; a >= 0; a--) {
      var o = r[a], s = void 0;
      if (o !== i && !o.ignore && (s = RU(o, t, n)) && (!e.topTarget && (e.topTarget = o), s !== jL)) {
        e.target = o;
        break;
      }
    }
  }
  function JL(r, e, t) {
    var n = r.painter;
    return e < 0 || e > n.getWidth() || t < 0 || t > n.getHeight();
  }
  var eR = 32, ju = 7;
  function EU(r) {
    for (var e = 0; r >= eR; ) e |= r & 1, r >>= 1;
    return r + e;
  }
  function uC(r, e, t, n) {
    var i = e + 1;
    if (i === t) return 1;
    if (n(r[i++], r[e]) < 0) {
      for (; i < t && n(r[i], r[i - 1]) < 0; ) i++;
      NU(r, e, i);
    } else for (; i < t && n(r[i], r[i - 1]) >= 0; ) i++;
    return i - e;
  }
  function NU(r, e, t) {
    for (t--; e < t; ) {
      var n = r[e];
      r[e++] = r[t], r[t--] = n;
    }
  }
  function cC(r, e, t, n, i) {
    for (n === e && n++; n < t; n++) {
      for (var a = r[n], o = e, s = n, l; o < s; ) l = o + s >>> 1, i(a, r[l]) < 0 ? s = l : o = l + 1;
      var u = n - o;
      switch (u) {
        case 3:
          r[o + 3] = r[o + 2];
        case 2:
          r[o + 2] = r[o + 1];
        case 1:
          r[o + 1] = r[o];
          break;
        default:
          for (; u > 0; ) r[o + u] = r[o + u - 1], u--;
      }
      r[o] = a;
    }
  }
  function Zg(r, e, t, n, i, a) {
    var o = 0, s = 0, l = 1;
    if (a(r, e[t + i]) > 0) {
      for (s = n - i; l < s && a(r, e[t + i + l]) > 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
      l > s && (l = s), o += i, l += i;
    } else {
      for (s = i + 1; l < s && a(r, e[t + i - l]) <= 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
      l > s && (l = s);
      var u = o;
      o = i - l, l = i - u;
    }
    for (o++; o < l; ) {
      var c = o + (l - o >>> 1);
      a(r, e[t + c]) > 0 ? o = c + 1 : l = c;
    }
    return l;
  }
  function jg(r, e, t, n, i, a) {
    var o = 0, s = 0, l = 1;
    if (a(r, e[t + i]) < 0) {
      for (s = i + 1; l < s && a(r, e[t + i - l]) < 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
      l > s && (l = s);
      var u = o;
      o = i - l, l = i - u;
    } else {
      for (s = n - i; l < s && a(r, e[t + i + l]) >= 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
      l > s && (l = s), o += i, l += i;
    }
    for (o++; o < l; ) {
      var c = o + (l - o >>> 1);
      a(r, e[t + c]) < 0 ? l = c : o = c + 1;
    }
    return l;
  }
  function OU(r, e) {
    var t = ju, n, i, a = 0, o = [];
    n = [], i = [];
    function s(d, p) {
      n[a] = d, i[a] = p, a += 1;
    }
    function l() {
      for (; a > 1; ) {
        var d = a - 2;
        if (d >= 1 && i[d - 1] <= i[d] + i[d + 1] || d >= 2 && i[d - 2] <= i[d] + i[d - 1]) i[d - 1] < i[d + 1] && d--;
        else if (i[d] > i[d + 1]) break;
        c(d);
      }
    }
    function u() {
      for (; a > 1; ) {
        var d = a - 2;
        d > 0 && i[d - 1] < i[d + 1] && d--, c(d);
      }
    }
    function c(d) {
      var p = n[d], v = i[d], g = n[d + 1], m = i[d + 1];
      i[d] = v + m, d === a - 3 && (n[d + 1] = n[d + 2], i[d + 1] = i[d + 2]), a--;
      var y = jg(r[g], r, p, v, 0, e);
      p += y, v -= y, v !== 0 && (m = Zg(r[p + v - 1], r, g, m, m - 1, e), m !== 0 && (v <= m ? h(p, v, g, m) : f(p, v, g, m)));
    }
    function h(d, p, v, g) {
      var m = 0;
      for (m = 0; m < p; m++) o[m] = r[d + m];
      var y = 0, x = v, _ = d;
      if (r[_++] = r[x++], --g === 0) {
        for (m = 0; m < p; m++) r[_ + m] = o[y + m];
        return;
      }
      if (p === 1) {
        for (m = 0; m < g; m++) r[_ + m] = r[x + m];
        r[_ + g] = o[y];
        return;
      }
      for (var S = t, b, w, C; ; ) {
        b = 0, w = 0, C = false;
        do
          if (e(r[x], o[y]) < 0) {
            if (r[_++] = r[x++], w++, b = 0, --g === 0) {
              C = true;
              break;
            }
          } else if (r[_++] = o[y++], b++, w = 0, --p === 1) {
            C = true;
            break;
          }
        while ((b | w) < S);
        if (C) break;
        do {
          if (b = jg(r[x], o, y, p, 0, e), b !== 0) {
            for (m = 0; m < b; m++) r[_ + m] = o[y + m];
            if (_ += b, y += b, p -= b, p <= 1) {
              C = true;
              break;
            }
          }
          if (r[_++] = r[x++], --g === 0) {
            C = true;
            break;
          }
          if (w = Zg(o[y], r, x, g, 0, e), w !== 0) {
            for (m = 0; m < w; m++) r[_ + m] = r[x + m];
            if (_ += w, x += w, g -= w, g === 0) {
              C = true;
              break;
            }
          }
          if (r[_++] = o[y++], --p === 1) {
            C = true;
            break;
          }
          S--;
        } while (b >= ju || w >= ju);
        if (C) break;
        S < 0 && (S = 0), S += 2;
      }
      if (t = S, t < 1 && (t = 1), p === 1) {
        for (m = 0; m < g; m++) r[_ + m] = r[x + m];
        r[_ + g] = o[y];
      } else {
        if (p === 0) throw new Error();
        for (m = 0; m < p; m++) r[_ + m] = o[y + m];
      }
    }
    function f(d, p, v, g) {
      var m = 0;
      for (m = 0; m < g; m++) o[m] = r[v + m];
      var y = d + p - 1, x = g - 1, _ = v + g - 1, S = 0, b = 0;
      if (r[_--] = r[y--], --p === 0) {
        for (S = _ - (g - 1), m = 0; m < g; m++) r[S + m] = o[m];
        return;
      }
      if (g === 1) {
        for (_ -= p, y -= p, b = _ + 1, S = y + 1, m = p - 1; m >= 0; m--) r[b + m] = r[S + m];
        r[_] = o[x];
        return;
      }
      for (var w = t; ; ) {
        var C = 0, T = 0, A = false;
        do
          if (e(o[x], r[y]) < 0) {
            if (r[_--] = r[y--], C++, T = 0, --p === 0) {
              A = true;
              break;
            }
          } else if (r[_--] = o[x--], T++, C = 0, --g === 1) {
            A = true;
            break;
          }
        while ((C | T) < w);
        if (A) break;
        do {
          if (C = p - jg(o[x], r, d, p, p - 1, e), C !== 0) {
            for (_ -= C, y -= C, p -= C, b = _ + 1, S = y + 1, m = C - 1; m >= 0; m--) r[b + m] = r[S + m];
            if (p === 0) {
              A = true;
              break;
            }
          }
          if (r[_--] = o[x--], --g === 1) {
            A = true;
            break;
          }
          if (T = g - Zg(r[y], o, 0, g, g - 1, e), T !== 0) {
            for (_ -= T, x -= T, g -= T, b = _ + 1, S = x + 1, m = 0; m < T; m++) r[b + m] = o[S + m];
            if (g <= 1) {
              A = true;
              break;
            }
          }
          if (r[_--] = r[y--], --p === 0) {
            A = true;
            break;
          }
          w--;
        } while (C >= ju || T >= ju);
        if (A) break;
        w < 0 && (w = 0), w += 2;
      }
      if (t = w, t < 1 && (t = 1), g === 1) {
        for (_ -= p, y -= p, b = _ + 1, S = y + 1, m = p - 1; m >= 0; m--) r[b + m] = r[S + m];
        r[_] = o[x];
      } else {
        if (g === 0) throw new Error();
        for (S = _ - (g - 1), m = 0; m < g; m++) r[S + m] = o[m];
      }
    }
    return {
      mergeRuns: l,
      forceMergeRuns: u,
      pushRun: s
    };
  }
  function hp(r, e, t, n) {
    t || (t = 0), n || (n = r.length);
    var i = n - t;
    if (!(i < 2)) {
      var a = 0;
      if (i < eR) {
        a = uC(r, t, n, e), cC(r, t, n, t + a, e);
        return;
      }
      var o = OU(r, e), s = EU(i);
      do {
        if (a = uC(r, t, n, e), a < s) {
          var l = i;
          l > s && (l = s), cC(r, t, t + l, t + a, e), a = l;
        }
        o.pushRun(t, a), o.mergeRuns(), i -= a, t += a;
      } while (i !== 0);
      o.forceMergeRuns();
    }
  }
  var Ri = 1, fp = 2, Dc = 4, hC = false;
  function Qg() {
    hC || (hC = true, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
  }
  function fC(r, e) {
    return r.zlevel === e.zlevel ? r.z === e.z ? r.z2 - e.z2 : r.z - e.z : r.zlevel - e.zlevel;
  }
  var FU = function() {
    function r() {
      this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = fC;
    }
    return r.prototype.traverse = function(e, t) {
      for (var n = 0; n < this._roots.length; n++) this._roots[n].traverse(e, t);
    }, r.prototype.getDisplayList = function(e, t) {
      t = t || false;
      var n = this._displayList;
      return (e || !n.length) && this.updateDisplayList(t), n;
    }, r.prototype.updateDisplayList = function(e) {
      this._displayListLen = 0;
      for (var t = this._roots, n = this._displayList, i = 0, a = t.length; i < a; i++) this._updateAndAddDisplayable(t[i], null, e);
      n.length = this._displayListLen, hp(n, fC);
    }, r.prototype._updateAndAddDisplayable = function(e, t, n) {
      if (!(e.ignore && !n)) {
        e.beforeUpdate(), e.update(), e.afterUpdate();
        var i = e.getClipPath();
        if (e.ignoreClip) t = null;
        else if (i) {
          t ? t = t.slice() : t = [];
          for (var a = i, o = e; a; ) a.parent = o, a.updateTransform(), t.push(a), o = a, a = a.getClipPath();
        }
        if (e.childrenRef) {
          for (var s = e.childrenRef(), l = 0; l < s.length; l++) {
            var u = s[l];
            e.__dirty && (u.__dirty |= Ri), this._updateAndAddDisplayable(u, t, n);
          }
          e.__dirty = 0;
        } else {
          var c = e;
          t && t.length ? c.__clipPaths = t : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (Qg(), c.z = 0), isNaN(c.z2) && (Qg(), c.z2 = 0), isNaN(c.zlevel) && (Qg(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
        }
        var h = e.getDecalElement && e.getDecalElement();
        h && this._updateAndAddDisplayable(h, t, n);
        var f = e.getTextGuideLine();
        f && this._updateAndAddDisplayable(f, t, n);
        var d = e.getTextContent();
        d && this._updateAndAddDisplayable(d, t, n);
      }
    }, r.prototype.addRoot = function(e) {
      e.__zr && e.__zr.storage === this || this._roots.push(e);
    }, r.prototype.delRoot = function(e) {
      if (e instanceof Array) {
        for (var t = 0, n = e.length; t < n; t++) this.delRoot(e[t]);
        return;
      }
      var i = Be(this._roots, e);
      i >= 0 && this._roots.splice(i, 1);
    }, r.prototype.delAllRoots = function() {
      this._roots = [], this._displayList = [], this._displayListLen = 0;
    }, r.prototype.getRoots = function() {
      return this._roots;
    }, r.prototype.dispose = function() {
      this._displayList = null, this._roots = null;
    }, r;
  }(), Op;
  Op = He.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(r) {
    return setTimeout(r, 16);
  };
  var qc = {
    linear: function(r) {
      return r;
    },
    quadraticIn: function(r) {
      return r * r;
    },
    quadraticOut: function(r) {
      return r * (2 - r);
    },
    quadraticInOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
    },
    cubicIn: function(r) {
      return r * r * r;
    },
    cubicOut: function(r) {
      return --r * r * r + 1;
    },
    cubicInOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
    },
    quarticIn: function(r) {
      return r * r * r * r;
    },
    quarticOut: function(r) {
      return 1 - --r * r * r * r;
    },
    quarticInOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
    },
    quinticIn: function(r) {
      return r * r * r * r * r;
    },
    quinticOut: function(r) {
      return --r * r * r * r * r + 1;
    },
    quinticInOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
    },
    sinusoidalIn: function(r) {
      return 1 - Math.cos(r * Math.PI / 2);
    },
    sinusoidalOut: function(r) {
      return Math.sin(r * Math.PI / 2);
    },
    sinusoidalInOut: function(r) {
      return 0.5 * (1 - Math.cos(Math.PI * r));
    },
    exponentialIn: function(r) {
      return r === 0 ? 0 : Math.pow(1024, r - 1);
    },
    exponentialOut: function(r) {
      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
    },
    exponentialInOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
    },
    circularIn: function(r) {
      return 1 - Math.sqrt(1 - r * r);
    },
    circularOut: function(r) {
      return Math.sqrt(1 - --r * r);
    },
    circularInOut: function(r) {
      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
    },
    elasticIn: function(r) {
      var e, t = 0.1, n = 0.4;
      return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = n / 4) : e = n * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / n)));
    },
    elasticOut: function(r) {
      var e, t = 0.1, n = 0.4;
      return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = n / 4) : e = n * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * r) * Math.sin((r - e) * (2 * Math.PI) / n) + 1);
    },
    elasticInOut: function(r) {
      var e, t = 0.1, n = 0.4;
      return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = n / 4) : e = n * Math.asin(1 / t) / (2 * Math.PI), (r *= 2) < 1 ? -0.5 * (t * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / n)) : t * Math.pow(2, -10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / n) * 0.5 + 1);
    },
    backIn: function(r) {
      var e = 1.70158;
      return r * r * ((e + 1) * r - e);
    },
    backOut: function(r) {
      var e = 1.70158;
      return --r * r * ((e + 1) * r + e) + 1;
    },
    backInOut: function(r) {
      var e = 2.5949095;
      return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
    },
    bounceIn: function(r) {
      return 1 - qc.bounceOut(1 - r);
    },
    bounceOut: function(r) {
      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
    },
    bounceInOut: function(r) {
      return r < 0.5 ? qc.bounceIn(r * 2) * 0.5 : qc.bounceOut(r * 2 - 1) * 0.5 + 0.5;
    }
  }, Gf = Math.pow, to = Math.sqrt, tR = 1e-8, rR = 1e-4, dC = to(3), Wf = 1 / 3, Ai = Xs(), kn = Xs(), Jl = Xs();
  function qa(r) {
    return r > -1e-8 && r < tR;
  }
  function nR(r) {
    return r > tR || r < -1e-8;
  }
  function tr(r, e, t, n, i) {
    var a = 1 - i;
    return a * a * (a * r + 3 * i * e) + i * i * (i * n + 3 * a * t);
  }
  function pC(r, e, t, n, i) {
    var a = 1 - i;
    return 3 * (((e - r) * a + 2 * (t - e) * i) * a + (n - t) * i * i);
  }
  function Fp(r, e, t, n, i, a) {
    var o = n + 3 * (e - t) - r, s = 3 * (t - e * 2 + r), l = 3 * (e - r), u = r - i, c = s * s - 3 * o * l, h = s * l - 9 * o * u, f = l * l - 3 * s * u, d = 0;
    if (qa(c) && qa(h)) if (qa(s)) a[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (a[d++] = p);
    }
    else {
      var v = h * h - 4 * c * f;
      if (qa(v)) {
        var g = h / c, p = -s / o + g, m = -g / 2;
        p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m);
      } else if (v > 0) {
        var y = to(v), x = c * s + 1.5 * o * (-h + y), _ = c * s + 1.5 * o * (-h - y);
        x < 0 ? x = -Gf(-x, Wf) : x = Gf(x, Wf), _ < 0 ? _ = -Gf(-_, Wf) : _ = Gf(_, Wf);
        var p = (-s - (x + _)) / (3 * o);
        p >= 0 && p <= 1 && (a[d++] = p);
      } else {
        var S = (2 * c * s - 3 * o * h) / (2 * to(c * c * c)), b = Math.acos(S) / 3, w = to(c), C = Math.cos(b), p = (-s - 2 * w * C) / (3 * o), m = (-s + w * (C + dC * Math.sin(b))) / (3 * o), T = (-s + w * (C - dC * Math.sin(b))) / (3 * o);
        p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m), T >= 0 && T <= 1 && (a[d++] = T);
      }
    }
    return d;
  }
  function iR(r, e, t, n, i) {
    var a = 6 * t - 12 * e + 6 * r, o = 9 * e + 3 * n - 3 * r - 9 * t, s = 3 * e - 3 * r, l = 0;
    if (qa(o)) {
      if (nR(a)) {
        var u = -s / a;
        u >= 0 && u <= 1 && (i[l++] = u);
      }
    } else {
      var c = a * a - 4 * o * s;
      if (qa(c)) i[0] = -a / (2 * o);
      else if (c > 0) {
        var h = to(c), u = (-a + h) / (2 * o), f = (-a - h) / (2 * o);
        u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
      }
    }
    return l;
  }
  function lo(r, e, t, n, i, a) {
    var o = (e - r) * i + r, s = (t - e) * i + e, l = (n - t) * i + t, u = (s - o) * i + o, c = (l - s) * i + s, h = (c - u) * i + u;
    a[0] = r, a[1] = o, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = n;
  }
  function aR(r, e, t, n, i, a, o, s, l, u, c) {
    var h, f = 5e-3, d = 1 / 0, p, v, g, m;
    Ai[0] = l, Ai[1] = u;
    for (var y = 0; y < 1; y += 0.05) kn[0] = tr(r, t, i, o, y), kn[1] = tr(e, n, a, s, y), g = As(Ai, kn), g < d && (h = y, d = g);
    d = 1 / 0;
    for (var x = 0; x < 32 && !(f < rR); x++) p = h - f, v = h + f, kn[0] = tr(r, t, i, o, p), kn[1] = tr(e, n, a, s, p), g = As(kn, Ai), p >= 0 && g < d ? (h = p, d = g) : (Jl[0] = tr(r, t, i, o, v), Jl[1] = tr(e, n, a, s, v), m = As(Jl, Ai), v <= 1 && m < d ? (h = v, d = m) : f *= 0.5);
    return c && (c[0] = tr(r, t, i, o, h), c[1] = tr(e, n, a, s, h)), to(d);
  }
  function BU(r, e, t, n, i, a, o, s, l) {
    for (var u = r, c = e, h = 0, f = 1 / l, d = 1; d <= l; d++) {
      var p = d * f, v = tr(r, t, i, o, p), g = tr(e, n, a, s, p), m = v - u, y = g - c;
      h += Math.sqrt(m * m + y * y), u = v, c = g;
    }
    return h;
  }
  function dr(r, e, t, n) {
    var i = 1 - n;
    return i * (i * r + 2 * n * e) + n * n * t;
  }
  function dx(r, e, t, n) {
    return 2 * ((1 - n) * (e - r) + n * (t - e));
  }
  function zU(r, e, t, n, i) {
    var a = r - 2 * e + t, o = 2 * (e - r), s = r - n, l = 0;
    if (qa(a)) {
      if (nR(o)) {
        var u = -s / o;
        u >= 0 && u <= 1 && (i[l++] = u);
      }
    } else {
      var c = o * o - 4 * a * s;
      if (qa(c)) {
        var u = -o / (2 * a);
        u >= 0 && u <= 1 && (i[l++] = u);
      } else if (c > 0) {
        var h = to(c), u = (-o + h) / (2 * a), f = (-o - h) / (2 * a);
        u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
      }
    }
    return l;
  }
  function oR(r, e, t) {
    var n = r + t - 2 * e;
    return n === 0 ? 0.5 : (r - e) / n;
  }
  function bh(r, e, t, n, i) {
    var a = (e - r) * n + r, o = (t - e) * n + e, s = (o - a) * n + a;
    i[0] = r, i[1] = a, i[2] = s, i[3] = s, i[4] = o, i[5] = t;
  }
  function sR(r, e, t, n, i, a, o, s, l) {
    var u, c = 5e-3, h = 1 / 0;
    Ai[0] = o, Ai[1] = s;
    for (var f = 0; f < 1; f += 0.05) {
      kn[0] = dr(r, t, i, f), kn[1] = dr(e, n, a, f);
      var d = As(Ai, kn);
      d < h && (u = f, h = d);
    }
    h = 1 / 0;
    for (var p = 0; p < 32 && !(c < rR); p++) {
      var v = u - c, g = u + c;
      kn[0] = dr(r, t, i, v), kn[1] = dr(e, n, a, v);
      var d = As(kn, Ai);
      if (v >= 0 && d < h) u = v, h = d;
      else {
        Jl[0] = dr(r, t, i, g), Jl[1] = dr(e, n, a, g);
        var m = As(Jl, Ai);
        g <= 1 && m < h ? (u = g, h = m) : c *= 0.5;
      }
    }
    return l && (l[0] = dr(r, t, i, u), l[1] = dr(e, n, a, u)), to(h);
  }
  function VU(r, e, t, n, i, a, o) {
    for (var s = r, l = e, u = 0, c = 1 / o, h = 1; h <= o; h++) {
      var f = h * c, d = dr(r, t, i, f), p = dr(e, n, a, f), v = d - s, g = p - l;
      u += Math.sqrt(v * v + g * g), s = d, l = p;
    }
    return u;
  }
  var $U = /cubic-bezier\(([0-9,\.e ]+)\)/;
  function Jb(r) {
    var e = r && $U.exec(r);
    if (e) {
      var t = e[1].split(","), n = +ei(t[0]), i = +ei(t[1]), a = +ei(t[2]), o = +ei(t[3]);
      if (isNaN(n + i + a + o)) return;
      var s = [];
      return function(l) {
        return l <= 0 ? 0 : l >= 1 ? 1 : Fp(0, n, a, 1, l, s) && tr(0, i, o, 1, s[0]);
      };
    }
  }
  var GU = function() {
    function r(e) {
      this._inited = false, this._startTime = 0, this._pausedTime = 0, this._paused = false, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || false, this.onframe = e.onframe || Wt, this.ondestroy = e.ondestroy || Wt, this.onrestart = e.onrestart || Wt, e.easing && this.setEasing(e.easing);
    }
    return r.prototype.step = function(e, t) {
      if (this._inited || (this._startTime = e + this._delay, this._inited = true), this._paused) {
        this._pausedTime += t;
        return;
      }
      var n = this._life, i = e - this._startTime - this._pausedTime, a = i / n;
      a < 0 && (a = 0), a = Math.min(a, 1);
      var o = this.easingFunc, s = o ? o(a) : a;
      if (this.onframe(s), a === 1) if (this.loop) {
        var l = i % n;
        this._startTime = e - l, this._pausedTime = 0, this.onrestart();
      } else return true;
      return false;
    }, r.prototype.pause = function() {
      this._paused = true;
    }, r.prototype.resume = function() {
      this._paused = false;
    }, r.prototype.setEasing = function(e) {
      this.easing = e, this.easingFunc = ge(e) ? e : qc[e] || Jb(e);
    }, r;
  }(), lR = /* @__PURE__ */ function() {
    function r(e) {
      this.value = e;
    }
    return r;
  }(), WU = function() {
    function r() {
      this._len = 0;
    }
    return r.prototype.insert = function(e) {
      var t = new lR(e);
      return this.insertEntry(t), t;
    }, r.prototype.insertEntry = function(e) {
      this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
    }, r.prototype.remove = function(e) {
      var t = e.prev, n = e.next;
      t ? t.next = n : this.head = n, n ? n.prev = t : this.tail = t, e.next = e.prev = null, this._len--;
    }, r.prototype.len = function() {
      return this._len;
    }, r.prototype.clear = function() {
      this.head = this.tail = null, this._len = 0;
    }, r;
  }(), df = function() {
    function r(e) {
      this._list = new WU(), this._maxSize = 10, this._map = {}, this._maxSize = e;
    }
    return r.prototype.put = function(e, t) {
      var n = this._list, i = this._map, a = null;
      if (i[e] == null) {
        var o = n.len(), s = this._lastRemovedEntry;
        if (o >= this._maxSize && o > 0) {
          var l = n.head;
          n.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l;
        }
        s ? s.value = t : s = new lR(t), s.key = e, n.insertEntry(s), i[e] = s;
      }
      return a;
    }, r.prototype.get = function(e) {
      var t = this._map[e], n = this._list;
      if (t != null) return t !== n.tail && (n.remove(t), n.insertEntry(t)), t.value;
    }, r.prototype.clear = function() {
      this._list.clear(), this._map = {};
    }, r.prototype.len = function() {
      return this._list.len();
    }, r;
  }(), vC = {
    transparent: [
      0,
      0,
      0,
      0
    ],
    aliceblue: [
      240,
      248,
      255,
      1
    ],
    antiquewhite: [
      250,
      235,
      215,
      1
    ],
    aqua: [
      0,
      255,
      255,
      1
    ],
    aquamarine: [
      127,
      255,
      212,
      1
    ],
    azure: [
      240,
      255,
      255,
      1
    ],
    beige: [
      245,
      245,
      220,
      1
    ],
    bisque: [
      255,
      228,
      196,
      1
    ],
    black: [
      0,
      0,
      0,
      1
    ],
    blanchedalmond: [
      255,
      235,
      205,
      1
    ],
    blue: [
      0,
      0,
      255,
      1
    ],
    blueviolet: [
      138,
      43,
      226,
      1
    ],
    brown: [
      165,
      42,
      42,
      1
    ],
    burlywood: [
      222,
      184,
      135,
      1
    ],
    cadetblue: [
      95,
      158,
      160,
      1
    ],
    chartreuse: [
      127,
      255,
      0,
      1
    ],
    chocolate: [
      210,
      105,
      30,
      1
    ],
    coral: [
      255,
      127,
      80,
      1
    ],
    cornflowerblue: [
      100,
      149,
      237,
      1
    ],
    cornsilk: [
      255,
      248,
      220,
      1
    ],
    crimson: [
      220,
      20,
      60,
      1
    ],
    cyan: [
      0,
      255,
      255,
      1
    ],
    darkblue: [
      0,
      0,
      139,
      1
    ],
    darkcyan: [
      0,
      139,
      139,
      1
    ],
    darkgoldenrod: [
      184,
      134,
      11,
      1
    ],
    darkgray: [
      169,
      169,
      169,
      1
    ],
    darkgreen: [
      0,
      100,
      0,
      1
    ],
    darkgrey: [
      169,
      169,
      169,
      1
    ],
    darkkhaki: [
      189,
      183,
      107,
      1
    ],
    darkmagenta: [
      139,
      0,
      139,
      1
    ],
    darkolivegreen: [
      85,
      107,
      47,
      1
    ],
    darkorange: [
      255,
      140,
      0,
      1
    ],
    darkorchid: [
      153,
      50,
      204,
      1
    ],
    darkred: [
      139,
      0,
      0,
      1
    ],
    darksalmon: [
      233,
      150,
      122,
      1
    ],
    darkseagreen: [
      143,
      188,
      143,
      1
    ],
    darkslateblue: [
      72,
      61,
      139,
      1
    ],
    darkslategray: [
      47,
      79,
      79,
      1
    ],
    darkslategrey: [
      47,
      79,
      79,
      1
    ],
    darkturquoise: [
      0,
      206,
      209,
      1
    ],
    darkviolet: [
      148,
      0,
      211,
      1
    ],
    deeppink: [
      255,
      20,
      147,
      1
    ],
    deepskyblue: [
      0,
      191,
      255,
      1
    ],
    dimgray: [
      105,
      105,
      105,
      1
    ],
    dimgrey: [
      105,
      105,
      105,
      1
    ],
    dodgerblue: [
      30,
      144,
      255,
      1
    ],
    firebrick: [
      178,
      34,
      34,
      1
    ],
    floralwhite: [
      255,
      250,
      240,
      1
    ],
    forestgreen: [
      34,
      139,
      34,
      1
    ],
    fuchsia: [
      255,
      0,
      255,
      1
    ],
    gainsboro: [
      220,
      220,
      220,
      1
    ],
    ghostwhite: [
      248,
      248,
      255,
      1
    ],
    gold: [
      255,
      215,
      0,
      1
    ],
    goldenrod: [
      218,
      165,
      32,
      1
    ],
    gray: [
      128,
      128,
      128,
      1
    ],
    green: [
      0,
      128,
      0,
      1
    ],
    greenyellow: [
      173,
      255,
      47,
      1
    ],
    grey: [
      128,
      128,
      128,
      1
    ],
    honeydew: [
      240,
      255,
      240,
      1
    ],
    hotpink: [
      255,
      105,
      180,
      1
    ],
    indianred: [
      205,
      92,
      92,
      1
    ],
    indigo: [
      75,
      0,
      130,
      1
    ],
    ivory: [
      255,
      255,
      240,
      1
    ],
    khaki: [
      240,
      230,
      140,
      1
    ],
    lavender: [
      230,
      230,
      250,
      1
    ],
    lavenderblush: [
      255,
      240,
      245,
      1
    ],
    lawngreen: [
      124,
      252,
      0,
      1
    ],
    lemonchiffon: [
      255,
      250,
      205,
      1
    ],
    lightblue: [
      173,
      216,
      230,
      1
    ],
    lightcoral: [
      240,
      128,
      128,
      1
    ],
    lightcyan: [
      224,
      255,
      255,
      1
    ],
    lightgoldenrodyellow: [
      250,
      250,
      210,
      1
    ],
    lightgray: [
      211,
      211,
      211,
      1
    ],
    lightgreen: [
      144,
      238,
      144,
      1
    ],
    lightgrey: [
      211,
      211,
      211,
      1
    ],
    lightpink: [
      255,
      182,
      193,
      1
    ],
    lightsalmon: [
      255,
      160,
      122,
      1
    ],
    lightseagreen: [
      32,
      178,
      170,
      1
    ],
    lightskyblue: [
      135,
      206,
      250,
      1
    ],
    lightslategray: [
      119,
      136,
      153,
      1
    ],
    lightslategrey: [
      119,
      136,
      153,
      1
    ],
    lightsteelblue: [
      176,
      196,
      222,
      1
    ],
    lightyellow: [
      255,
      255,
      224,
      1
    ],
    lime: [
      0,
      255,
      0,
      1
    ],
    limegreen: [
      50,
      205,
      50,
      1
    ],
    linen: [
      250,
      240,
      230,
      1
    ],
    magenta: [
      255,
      0,
      255,
      1
    ],
    maroon: [
      128,
      0,
      0,
      1
    ],
    mediumaquamarine: [
      102,
      205,
      170,
      1
    ],
    mediumblue: [
      0,
      0,
      205,
      1
    ],
    mediumorchid: [
      186,
      85,
      211,
      1
    ],
    mediumpurple: [
      147,
      112,
      219,
      1
    ],
    mediumseagreen: [
      60,
      179,
      113,
      1
    ],
    mediumslateblue: [
      123,
      104,
      238,
      1
    ],
    mediumspringgreen: [
      0,
      250,
      154,
      1
    ],
    mediumturquoise: [
      72,
      209,
      204,
      1
    ],
    mediumvioletred: [
      199,
      21,
      133,
      1
    ],
    midnightblue: [
      25,
      25,
      112,
      1
    ],
    mintcream: [
      245,
      255,
      250,
      1
    ],
    mistyrose: [
      255,
      228,
      225,
      1
    ],
    moccasin: [
      255,
      228,
      181,
      1
    ],
    navajowhite: [
      255,
      222,
      173,
      1
    ],
    navy: [
      0,
      0,
      128,
      1
    ],
    oldlace: [
      253,
      245,
      230,
      1
    ],
    olive: [
      128,
      128,
      0,
      1
    ],
    olivedrab: [
      107,
      142,
      35,
      1
    ],
    orange: [
      255,
      165,
      0,
      1
    ],
    orangered: [
      255,
      69,
      0,
      1
    ],
    orchid: [
      218,
      112,
      214,
      1
    ],
    palegoldenrod: [
      238,
      232,
      170,
      1
    ],
    palegreen: [
      152,
      251,
      152,
      1
    ],
    paleturquoise: [
      175,
      238,
      238,
      1
    ],
    palevioletred: [
      219,
      112,
      147,
      1
    ],
    papayawhip: [
      255,
      239,
      213,
      1
    ],
    peachpuff: [
      255,
      218,
      185,
      1
    ],
    peru: [
      205,
      133,
      63,
      1
    ],
    pink: [
      255,
      192,
      203,
      1
    ],
    plum: [
      221,
      160,
      221,
      1
    ],
    powderblue: [
      176,
      224,
      230,
      1
    ],
    purple: [
      128,
      0,
      128,
      1
    ],
    red: [
      255,
      0,
      0,
      1
    ],
    rosybrown: [
      188,
      143,
      143,
      1
    ],
    royalblue: [
      65,
      105,
      225,
      1
    ],
    saddlebrown: [
      139,
      69,
      19,
      1
    ],
    salmon: [
      250,
      128,
      114,
      1
    ],
    sandybrown: [
      244,
      164,
      96,
      1
    ],
    seagreen: [
      46,
      139,
      87,
      1
    ],
    seashell: [
      255,
      245,
      238,
      1
    ],
    sienna: [
      160,
      82,
      45,
      1
    ],
    silver: [
      192,
      192,
      192,
      1
    ],
    skyblue: [
      135,
      206,
      235,
      1
    ],
    slateblue: [
      106,
      90,
      205,
      1
    ],
    slategray: [
      112,
      128,
      144,
      1
    ],
    slategrey: [
      112,
      128,
      144,
      1
    ],
    snow: [
      255,
      250,
      250,
      1
    ],
    springgreen: [
      0,
      255,
      127,
      1
    ],
    steelblue: [
      70,
      130,
      180,
      1
    ],
    tan: [
      210,
      180,
      140,
      1
    ],
    teal: [
      0,
      128,
      128,
      1
    ],
    thistle: [
      216,
      191,
      216,
      1
    ],
    tomato: [
      255,
      99,
      71,
      1
    ],
    turquoise: [
      64,
      224,
      208,
      1
    ],
    violet: [
      238,
      130,
      238,
      1
    ],
    wheat: [
      245,
      222,
      179,
      1
    ],
    white: [
      255,
      255,
      255,
      1
    ],
    whitesmoke: [
      245,
      245,
      245,
      1
    ],
    yellow: [
      255,
      255,
      0,
      1
    ],
    yellowgreen: [
      154,
      205,
      50,
      1
    ]
  };
  function ii(r) {
    return r = Math.round(r), r < 0 ? 0 : r > 255 ? 255 : r;
  }
  function UU(r) {
    return r = Math.round(r), r < 0 ? 0 : r > 360 ? 360 : r;
  }
  function Sh(r) {
    return r < 0 ? 0 : r > 1 ? 1 : r;
  }
  function Jg(r) {
    var e = r;
    return e.length && e.charAt(e.length - 1) === "%" ? ii(parseFloat(e) / 100 * 255) : ii(parseInt(e, 10));
  }
  function Is(r) {
    var e = r;
    return e.length && e.charAt(e.length - 1) === "%" ? Sh(parseFloat(e) / 100) : Sh(parseFloat(e));
  }
  function em(r, e, t) {
    return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? r + (e - r) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? r + (e - r) * (2 / 3 - t) * 6 : r;
  }
  function Ka(r, e, t) {
    return r + (e - r) * t;
  }
  function An(r, e, t, n, i) {
    return r[0] = e, r[1] = t, r[2] = n, r[3] = i, r;
  }
  function px(r, e) {
    return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r;
  }
  var uR = new df(20), Uf = null;
  function ul(r, e) {
    Uf && px(Uf, e), Uf = uR.put(r, Uf || e.slice());
  }
  function vn(r, e) {
    if (r) {
      e = e || [];
      var t = uR.get(r);
      if (t) return px(e, t);
      r = r + "";
      var n = r.replace(/ /g, "").toLowerCase();
      if (n in vC) return px(e, vC[n]), ul(r, e), e;
      var i = n.length;
      if (n.charAt(0) === "#") {
        if (i === 4 || i === 5) {
          var a = parseInt(n.slice(1, 4), 16);
          if (!(a >= 0 && a <= 4095)) {
            An(e, 0, 0, 0, 1);
            return;
          }
          return An(e, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(n.slice(4), 16) / 15 : 1), ul(r, e), e;
        } else if (i === 7 || i === 9) {
          var a = parseInt(n.slice(1, 7), 16);
          if (!(a >= 0 && a <= 16777215)) {
            An(e, 0, 0, 0, 1);
            return;
          }
          return An(e, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(n.slice(7), 16) / 255 : 1), ul(r, e), e;
        }
        return;
      }
      var o = n.indexOf("("), s = n.indexOf(")");
      if (o !== -1 && s + 1 === i) {
        var l = n.substr(0, o), u = n.substr(o + 1, s - (o + 1)).split(","), c = 1;
        switch (l) {
          case "rgba":
            if (u.length !== 4) return u.length === 3 ? An(e, +u[0], +u[1], +u[2], 1) : An(e, 0, 0, 0, 1);
            c = Is(u.pop());
          case "rgb":
            if (u.length >= 3) return An(e, Jg(u[0]), Jg(u[1]), Jg(u[2]), u.length === 3 ? c : Is(u[3])), ul(r, e), e;
            An(e, 0, 0, 0, 1);
            return;
          case "hsla":
            if (u.length !== 4) {
              An(e, 0, 0, 0, 1);
              return;
            }
            return u[3] = Is(u[3]), vx(u, e), ul(r, e), e;
          case "hsl":
            if (u.length !== 3) {
              An(e, 0, 0, 0, 1);
              return;
            }
            return vx(u, e), ul(r, e), e;
          default:
            return;
        }
      }
      An(e, 0, 0, 0, 1);
    }
  }
  function vx(r, e) {
    var t = (parseFloat(r[0]) % 360 + 360) % 360 / 360, n = Is(r[1]), i = Is(r[2]), a = i <= 0.5 ? i * (n + 1) : i + n - i * n, o = i * 2 - a;
    return e = e || [], An(e, ii(em(o, a, t + 1 / 3) * 255), ii(em(o, a, t) * 255), ii(em(o, a, t - 1 / 3) * 255), 1), r.length === 4 && (e[3] = r[3]), e;
  }
  function HU(r) {
    if (r) {
      var e = r[0] / 255, t = r[1] / 255, n = r[2] / 255, i = Math.min(e, t, n), a = Math.max(e, t, n), o = a - i, s = (a + i) / 2, l, u;
      if (o === 0) l = 0, u = 0;
      else {
        s < 0.5 ? u = o / (a + i) : u = o / (2 - a - i);
        var c = ((a - e) / 6 + o / 2) / o, h = ((a - t) / 6 + o / 2) / o, f = ((a - n) / 6 + o / 2) / o;
        e === a ? l = f - h : t === a ? l = 1 / 3 + c - f : n === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
      }
      var d = [
        l * 360,
        u,
        s
      ];
      return r[3] != null && d.push(r[3]), d;
    }
  }
  function gx(r, e) {
    var t = vn(r);
    if (t) {
      for (var n = 0; n < 3; n++) e < 0 ? t[n] = t[n] * (1 - e) | 0 : t[n] = (255 - t[n]) * e + t[n] | 0, t[n] > 255 ? t[n] = 255 : t[n] < 0 && (t[n] = 0);
      return la(t, t.length === 4 ? "rgba" : "rgb");
    }
  }
  function tm(r, e, t) {
    if (!(!(e && e.length) || !(r >= 0 && r <= 1))) {
      t = t || [];
      var n = r * (e.length - 1), i = Math.floor(n), a = Math.ceil(n), o = e[i], s = e[a], l = n - i;
      return t[0] = ii(Ka(o[0], s[0], l)), t[1] = ii(Ka(o[1], s[1], l)), t[2] = ii(Ka(o[2], s[2], l)), t[3] = Sh(Ka(o[3], s[3], l)), t;
    }
  }
  function YU(r, e, t) {
    if (!(!(e && e.length) || !(r >= 0 && r <= 1))) {
      var n = r * (e.length - 1), i = Math.floor(n), a = Math.ceil(n), o = vn(e[i]), s = vn(e[a]), l = n - i, u = la([
        ii(Ka(o[0], s[0], l)),
        ii(Ka(o[1], s[1], l)),
        ii(Ka(o[2], s[2], l)),
        Sh(Ka(o[3], s[3], l))
      ], "rgba");
      return t ? {
        color: u,
        leftIndex: i,
        rightIndex: a,
        value: n
      } : u;
    }
  }
  function Kc(r, e, t, n) {
    var i = vn(r);
    if (r) return i = HU(i), e != null && (i[0] = UU(e)), t != null && (i[1] = Is(t)), n != null && (i[2] = Is(n)), la(vx(i), "rgba");
  }
  function Bp(r, e) {
    var t = vn(r);
    if (t && e != null) return t[3] = Sh(e), la(t, "rgba");
  }
  function la(r, e) {
    if (!(!r || !r.length)) {
      var t = r[0] + "," + r[1] + "," + r[2];
      return (e === "rgba" || e === "hsva" || e === "hsla") && (t += "," + r[3]), e + "(" + t + ")";
    }
  }
  function zp(r, e) {
    var t = vn(r);
    return t ? (0.299 * t[0] + 0.587 * t[1] + 0.114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0;
  }
  var gC = new df(100);
  function mx(r) {
    if (ee(r)) {
      var e = gC.get(r);
      return e || (e = gx(r, -0.1), gC.put(r, e)), e;
    } else if (Uv(r)) {
      var t = H({}, r);
      return t.colorStops = K(r.colorStops, function(n) {
        return {
          offset: n.offset,
          color: gx(n.color, -0.1)
        };
      }), t;
    }
    return r;
  }
  var Vp = Math.round;
  function wh(r) {
    var e;
    if (!r || r === "transparent") r = "none";
    else if (typeof r == "string" && r.indexOf("rgba") > -1) {
      var t = vn(r);
      t && (r = "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")", e = t[3]);
    }
    return {
      color: r,
      opacity: e ?? 1
    };
  }
  var XU = 1e-4;
  function Za(r) {
    return r < XU && r > -1e-4;
  }
  function Hf(r) {
    return Vp(r * 1e3) / 1e3;
  }
  function yx(r) {
    return Vp(r * 1e4) / 1e4;
  }
  function qU(r) {
    return "matrix(" + Hf(r[0]) + "," + Hf(r[1]) + "," + Hf(r[2]) + "," + Hf(r[3]) + "," + yx(r[4]) + "," + yx(r[5]) + ")";
  }
  var KU = {
    left: "start",
    right: "end",
    center: "middle",
    middle: "middle"
  };
  function ZU(r, e, t) {
    return t === "top" ? r += e / 2 : t === "bottom" && (r -= e / 2), r;
  }
  function jU(r) {
    return r && (r.shadowBlur || r.shadowOffsetX || r.shadowOffsetY);
  }
  function QU(r) {
    var e = r.style, t = r.getGlobalScale();
    return [
      e.shadowColor,
      (e.shadowBlur || 0).toFixed(2),
      (e.shadowOffsetX || 0).toFixed(2),
      (e.shadowOffsetY || 0).toFixed(2),
      t[0],
      t[1]
    ].join(",");
  }
  function cR(r) {
    return r && !!r.image;
  }
  function JU(r) {
    return r && !!r.svgElement;
  }
  function e1(r) {
    return cR(r) || JU(r);
  }
  function hR(r) {
    return r.type === "linear";
  }
  function fR(r) {
    return r.type === "radial";
  }
  function dR(r) {
    return r && (r.type === "linear" || r.type === "radial");
  }
  function Xv(r) {
    return "url(#" + r + ")";
  }
  function pR(r) {
    var e = r.getGlobalScale(), t = Math.max(e[0], e[1]);
    return Math.max(Math.ceil(Math.log(t) / Math.log(10)), 1);
  }
  function vR(r) {
    var e = r.x || 0, t = r.y || 0, n = (r.rotation || 0) * lp, i = Pe(r.scaleX, 1), a = Pe(r.scaleY, 1), o = r.skewX || 0, s = r.skewY || 0, l = [];
    return (e || t) && l.push("translate(" + e + "px," + t + "px)"), n && l.push("rotate(" + n + ")"), (i !== 1 || a !== 1) && l.push("scale(" + i + "," + a + ")"), (o || s) && l.push("skew(" + Vp(o * lp) + "deg, " + Vp(s * lp) + "deg)"), l.join(" ");
  }
  var eH = function() {
    return He.hasGlobalWindow && ge(window.btoa) ? function(r) {
      return window.btoa(unescape(encodeURIComponent(r)));
    } : typeof Buffer < "u" ? function(r) {
      return Buffer.from(r).toString("base64");
    } : function(r) {
      return null;
    };
  }(), xx = Array.prototype.slice;
  function Ji(r, e, t) {
    return (e - r) * t + r;
  }
  function rm(r, e, t, n) {
    for (var i = e.length, a = 0; a < i; a++) r[a] = Ji(e[a], t[a], n);
    return r;
  }
  function tH(r, e, t, n) {
    for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) {
      r[o] || (r[o] = []);
      for (var s = 0; s < a; s++) r[o][s] = Ji(e[o][s], t[o][s], n);
    }
    return r;
  }
  function Yf(r, e, t, n) {
    for (var i = e.length, a = 0; a < i; a++) r[a] = e[a] + t[a] * n;
    return r;
  }
  function mC(r, e, t, n) {
    for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) {
      r[o] || (r[o] = []);
      for (var s = 0; s < a; s++) r[o][s] = e[o][s] + t[o][s] * n;
    }
    return r;
  }
  function rH(r, e) {
    for (var t = r.length, n = e.length, i = t > n ? e : r, a = Math.min(t, n), o = i[a - 1] || {
      color: [
        0,
        0,
        0,
        0
      ],
      offset: 0
    }, s = a; s < Math.max(t, n); s++) i.push({
      offset: o.offset,
      color: o.color.slice()
    });
  }
  function nH(r, e, t) {
    var n = r, i = e;
    if (!(!n.push || !i.push)) {
      var a = n.length, o = i.length;
      if (a !== o) {
        var s = a > o;
        if (s) n.length = o;
        else for (var l = a; l < o; l++) n.push(t === 1 ? i[l] : xx.call(i[l]));
      }
      for (var u = n[0] && n[0].length, l = 0; l < n.length; l++) if (t === 1) isNaN(n[l]) && (n[l] = i[l]);
      else for (var c = 0; c < u; c++) isNaN(n[l][c]) && (n[l][c] = i[l][c]);
    }
  }
  function Zc(r) {
    if (Lr(r)) {
      var e = r.length;
      if (Lr(r[0])) {
        for (var t = [], n = 0; n < e; n++) t.push(xx.call(r[n]));
        return t;
      }
      return xx.call(r);
    }
    return r;
  }
  function dp(r) {
    return r[0] = Math.floor(r[0]) || 0, r[1] = Math.floor(r[1]) || 0, r[2] = Math.floor(r[2]) || 0, r[3] = r[3] == null ? 1 : r[3], "rgba(" + r.join(",") + ")";
  }
  function iH(r) {
    return Lr(r && r[0]) ? 2 : 1;
  }
  var Xf = 0, pp = 1, gR = 2, Pc = 3, _x = 4, bx = 5, yC = 6;
  function xC(r) {
    return r === _x || r === bx;
  }
  function qf(r) {
    return r === pp || r === gR;
  }
  var Qu = [
    0,
    0,
    0,
    0
  ], aH = function() {
    function r(e) {
      this.keyframes = [], this.discrete = false, this._invalid = false, this._needsSort = false, this._lastFr = 0, this._lastFrP = 0, this.propName = e;
    }
    return r.prototype.isFinished = function() {
      return this._finished;
    }, r.prototype.setFinished = function() {
      this._finished = true, this._additiveTrack && this._additiveTrack.setFinished();
    }, r.prototype.needsAnimate = function() {
      return this.keyframes.length >= 1;
    }, r.prototype.getAdditiveTrack = function() {
      return this._additiveTrack;
    }, r.prototype.addKeyframe = function(e, t, n) {
      this._needsSort = true;
      var i = this.keyframes, a = i.length, o = false, s = yC, l = t;
      if (Lr(t)) {
        var u = iH(t);
        s = u, (u === 1 && !nt(t[0]) || u === 2 && !nt(t[0][0])) && (o = true);
      } else if (nt(t) && !xh(t)) s = Xf;
      else if (ee(t)) if (!isNaN(+t)) s = Xf;
      else {
        var c = vn(t);
        c && (l = c, s = Pc);
      }
      else if (Uv(t)) {
        var h = H({}, l);
        h.colorStops = K(t.colorStops, function(d) {
          return {
            offset: d.offset,
            color: vn(d.color)
          };
        }), hR(t) ? s = _x : fR(t) && (s = bx), l = h;
      }
      a === 0 ? this.valType = s : (s !== this.valType || s === yC) && (o = true), this.discrete = this.discrete || o;
      var f = {
        time: e,
        value: l,
        rawValue: t,
        percent: 0
      };
      return n && (f.easing = n, f.easingFunc = ge(n) ? n : qc[n] || Jb(n)), i.push(f), f;
    }, r.prototype.prepare = function(e, t) {
      var n = this.keyframes;
      this._needsSort && n.sort(function(v, g) {
        return v.time - g.time;
      });
      for (var i = this.valType, a = n.length, o = n[a - 1], s = this.discrete, l = qf(i), u = xC(i), c = 0; c < a; c++) {
        var h = n[c], f = h.value, d = o.value;
        h.percent = h.time / e, s || (l && c !== a - 1 ? nH(f, d, i) : u && rH(f.colorStops, d.colorStops));
      }
      if (!s && i !== bx && t && this.needsAnimate() && t.needsAnimate() && i === t.valType && !t._finished) {
        this._additiveTrack = t;
        for (var p = n[0].value, c = 0; c < a; c++) i === Xf ? n[c].additiveValue = n[c].value - p : i === Pc ? n[c].additiveValue = Yf([], n[c].value, p, -1) : qf(i) && (n[c].additiveValue = i === pp ? Yf([], n[c].value, p, -1) : mC([], n[c].value, p, -1));
      }
    }, r.prototype.step = function(e, t) {
      if (!this._finished) {
        this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
        var n = this._additiveTrack != null, i = n ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === Pc, c, h = this._lastFr, f = Math.min, d, p;
        if (s === 1) d = p = o[0];
        else {
          if (t < 0) c = 0;
          else if (t < this._lastFrP) {
            var v = f(h + 1, s - 1);
            for (c = v; c >= 0 && !(o[c].percent <= t); c--) ;
            c = f(c, s - 2);
          } else {
            for (c = h; c < s && !(o[c].percent > t); c++) ;
            c = f(c - 1, s - 2);
          }
          p = o[c + 1], d = o[c];
        }
        if (d && p) {
          this._lastFr = c, this._lastFrP = t;
          var g = p.percent - d.percent, m = g === 0 ? 1 : f((t - d.percent) / g, 1);
          p.easingFunc && (m = p.easingFunc(m));
          var y = n ? this._additiveValue : u ? Qu : e[l];
          if ((qf(a) || u) && !y && (y = this._additiveValue = []), this.discrete) e[l] = m < 1 ? d.rawValue : p.rawValue;
          else if (qf(a)) a === pp ? rm(y, d[i], p[i], m) : tH(y, d[i], p[i], m);
          else if (xC(a)) {
            var x = d[i], _ = p[i], S = a === _x;
            e[l] = {
              type: S ? "linear" : "radial",
              x: Ji(x.x, _.x, m),
              y: Ji(x.y, _.y, m),
              colorStops: K(x.colorStops, function(w, C) {
                var T = _.colorStops[C];
                return {
                  offset: Ji(w.offset, T.offset, m),
                  color: dp(rm([], w.color, T.color, m))
                };
              }),
              global: _.global
            }, S ? (e[l].x2 = Ji(x.x2, _.x2, m), e[l].y2 = Ji(x.y2, _.y2, m)) : e[l].r = Ji(x.r, _.r, m);
          } else if (u) rm(y, d[i], p[i], m), n || (e[l] = dp(y));
          else {
            var b = Ji(d[i], p[i], m);
            n ? this._additiveValue = b : e[l] = b;
          }
          n && this._addToTarget(e);
        }
      }
    }, r.prototype._addToTarget = function(e) {
      var t = this.valType, n = this.propName, i = this._additiveValue;
      t === Xf ? e[n] = e[n] + i : t === Pc ? (vn(e[n], Qu), Yf(Qu, Qu, i, 1), e[n] = dp(Qu)) : t === pp ? Yf(e[n], e[n], i, 1) : t === gR && mC(e[n], e[n], i, 1);
    }, r;
  }(), t1 = function() {
    function r(e, t, n, i) {
      if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = t, t && i) {
        Yb("Can' use additive animation on looped animation.");
        return;
      }
      this._additiveAnimators = i, this._allowDiscrete = n;
    }
    return r.prototype.getMaxTime = function() {
      return this._maxTime;
    }, r.prototype.getDelay = function() {
      return this._delay;
    }, r.prototype.getLoop = function() {
      return this._loop;
    }, r.prototype.getTarget = function() {
      return this._target;
    }, r.prototype.changeTarget = function(e) {
      this._target = e;
    }, r.prototype.when = function(e, t, n) {
      return this.whenWithKeys(e, t, je(t), n);
    }, r.prototype.whenWithKeys = function(e, t, n, i) {
      for (var a = this._tracks, o = 0; o < n.length; o++) {
        var s = n[o], l = a[s];
        if (!l) {
          l = a[s] = new aH(s);
          var u = void 0, c = this._getAdditiveTrack(s);
          if (c) {
            var h = c.keyframes, f = h[h.length - 1];
            u = f && f.value, c.valType === Pc && u && (u = dp(u));
          } else u = this._target[s];
          if (u == null) continue;
          e > 0 && l.addKeyframe(0, Zc(u), i), this._trackKeys.push(s);
        }
        l.addKeyframe(e, Zc(t[s]), i);
      }
      return this._maxTime = Math.max(this._maxTime, e), this;
    }, r.prototype.pause = function() {
      this._clip.pause(), this._paused = true;
    }, r.prototype.resume = function() {
      this._clip.resume(), this._paused = false;
    }, r.prototype.isPaused = function() {
      return !!this._paused;
    }, r.prototype.duration = function(e) {
      return this._maxTime = e, this._force = true, this;
    }, r.prototype._doneCallback = function() {
      this._setTracksFinished(), this._clip = null;
      var e = this._doneCbs;
      if (e) for (var t = e.length, n = 0; n < t; n++) e[n].call(this);
    }, r.prototype._abortedCallback = function() {
      this._setTracksFinished();
      var e = this.animation, t = this._abortedCbs;
      if (e && e.removeClip(this._clip), this._clip = null, t) for (var n = 0; n < t.length; n++) t[n].call(this);
    }, r.prototype._setTracksFinished = function() {
      for (var e = this._tracks, t = this._trackKeys, n = 0; n < t.length; n++) e[t[n]].setFinished();
    }, r.prototype._getAdditiveTrack = function(e) {
      var t, n = this._additiveAnimators;
      if (n) for (var i = 0; i < n.length; i++) {
        var a = n[i].getTrack(e);
        a && (t = a);
      }
      return t;
    }, r.prototype.start = function(e) {
      if (!(this._started > 0)) {
        this._started = 1;
        for (var t = this, n = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
          var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, c = u.length;
          if (s.prepare(i, l), s.needsAnimate()) if (!this._allowDiscrete && s.discrete) {
            var h = u[c - 1];
            h && (t._target[s.propName] = h.rawValue), s.setFinished();
          } else n.push(s);
        }
        if (n.length || this._force) {
          var f = new GU({
            life: i,
            loop: this._loop,
            delay: this._delay || 0,
            onframe: function(d) {
              t._started = 2;
              var p = t._additiveAnimators;
              if (p) {
                for (var v = false, g = 0; g < p.length; g++) if (p[g]._clip) {
                  v = true;
                  break;
                }
                v || (t._additiveAnimators = null);
              }
              for (var g = 0; g < n.length; g++) n[g].step(t._target, d);
              var m = t._onframeCbs;
              if (m) for (var g = 0; g < m.length; g++) m[g](t._target, d);
            },
            ondestroy: function() {
              t._doneCallback();
            }
          });
          this._clip = f, this.animation && this.animation.addClip(f), e && f.setEasing(e);
        } else this._doneCallback();
        return this;
      }
    }, r.prototype.stop = function(e) {
      if (this._clip) {
        var t = this._clip;
        e && t.onframe(1), this._abortedCallback();
      }
    }, r.prototype.delay = function(e) {
      return this._delay = e, this;
    }, r.prototype.during = function(e) {
      return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this;
    }, r.prototype.done = function(e) {
      return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this;
    }, r.prototype.aborted = function(e) {
      return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this;
    }, r.prototype.getClip = function() {
      return this._clip;
    }, r.prototype.getTrack = function(e) {
      return this._tracks[e];
    }, r.prototype.getTracks = function() {
      var e = this;
      return K(this._trackKeys, function(t) {
        return e._tracks[t];
      });
    }, r.prototype.stopTracks = function(e, t) {
      if (!e.length || !this._clip) return true;
      for (var n = this._tracks, i = this._trackKeys, a = 0; a < e.length; a++) {
        var o = n[e[a]];
        o && !o.isFinished() && (t ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
      }
      for (var s = true, a = 0; a < i.length; a++) if (!n[i[a]].isFinished()) {
        s = false;
        break;
      }
      return s && this._abortedCallback(), s;
    }, r.prototype.saveTo = function(e, t, n) {
      if (e) {
        t = t || this._trackKeys;
        for (var i = 0; i < t.length; i++) {
          var a = t[i], o = this._tracks[a];
          if (!(!o || o.isFinished())) {
            var s = o.keyframes, l = s[n ? 0 : s.length - 1];
            l && (e[a] = Zc(l.rawValue));
          }
        }
      }
    }, r.prototype.__changeFinalValue = function(e, t) {
      t = t || je(e);
      for (var n = 0; n < t.length; n++) {
        var i = t[n], a = this._tracks[i];
        if (a) {
          var o = a.keyframes;
          if (o.length > 1) {
            var s = o.pop();
            a.addKeyframe(s.time, e[i]), a.prepare(this._maxTime, a.getAdditiveTrack());
          }
        }
      }
    }, r;
  }();
  function Xl() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  var oH = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this) || this;
      return n._running = false, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = false, t = t || {}, n.stage = t.stage || {}, n;
    }
    return e.prototype.addClip = function(t) {
      t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this;
    }, e.prototype.addAnimator = function(t) {
      t.animation = this;
      var n = t.getClip();
      n && this.addClip(n);
    }, e.prototype.removeClip = function(t) {
      if (t.animation) {
        var n = t.prev, i = t.next;
        n ? n.next = i : this._head = i, i ? i.prev = n : this._tail = n, t.next = t.prev = t.animation = null;
      }
    }, e.prototype.removeAnimator = function(t) {
      var n = t.getClip();
      n && this.removeClip(n), t.animation = null;
    }, e.prototype.update = function(t) {
      for (var n = Xl() - this._pausedTime, i = n - this._time, a = this._head; a; ) {
        var o = a.next, s = a.step(n, i);
        s && (a.ondestroy(), this.removeClip(a)), a = o;
      }
      this._time = n, t || (this.trigger("frame", i), this.stage.update && this.stage.update());
    }, e.prototype._startLoop = function() {
      var t = this;
      this._running = true;
      function n() {
        t._running && (Op(n), !t._paused && t.update());
      }
      Op(n);
    }, e.prototype.start = function() {
      this._running || (this._time = Xl(), this._pausedTime = 0, this._startLoop());
    }, e.prototype.stop = function() {
      this._running = false;
    }, e.prototype.pause = function() {
      this._paused || (this._pauseStart = Xl(), this._paused = true);
    }, e.prototype.resume = function() {
      this._paused && (this._pausedTime += Xl() - this._pauseStart, this._paused = false);
    }, e.prototype.clear = function() {
      for (var t = this._head; t; ) {
        var n = t.next;
        t.prev = t.next = t.animation = null, t = n;
      }
      this._head = this._tail = null;
    }, e.prototype.isFinished = function() {
      return this._head == null;
    }, e.prototype.animate = function(t, n) {
      n = n || {}, this.start();
      var i = new t1(t, n.loop);
      return this.addAnimator(i), i;
    }, e;
  }(Vn), sH = 300, nm = He.domSupported, im = function() {
    var r = [
      "click",
      "dblclick",
      "mousewheel",
      "wheel",
      "mouseout",
      "mouseup",
      "mousedown",
      "mousemove",
      "contextmenu"
    ], e = [
      "touchstart",
      "touchend",
      "touchmove"
    ], t = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    }, n = K(r, function(i) {
      var a = i.replace("mouse", "pointer");
      return t.hasOwnProperty(a) ? a : i;
    });
    return {
      mouse: r,
      touch: e,
      pointer: n
    };
  }(), _C = {
    mouse: [
      "mousemove",
      "mouseup"
    ],
    pointer: [
      "pointermove",
      "pointerup"
    ]
  }, bC = false;
  function Sx(r) {
    var e = r.pointerType;
    return e === "pen" || e === "touch";
  }
  function lH(r) {
    r.touching = true, r.touchTimer != null && (clearTimeout(r.touchTimer), r.touchTimer = null), r.touchTimer = setTimeout(function() {
      r.touching = false, r.touchTimer = null;
    }, 700);
  }
  function am(r) {
    r && (r.zrByTouch = true);
  }
  function uH(r, e) {
    return In(r.dom, new cH(r, e), true);
  }
  function mR(r, e) {
    for (var t = e, n = false; t && t.nodeType !== 9 && !(n = t.domBelongToZr || t !== e && t === r.painterRoot); ) t = t.parentNode;
    return n;
  }
  var cH = /* @__PURE__ */ function() {
    function r(e, t) {
      this.stopPropagation = Wt, this.stopImmediatePropagation = Wt, this.preventDefault = Wt, this.type = t.type, this.target = this.currentTarget = e.dom, this.pointerType = t.pointerType, this.clientX = t.clientX, this.clientY = t.clientY;
    }
    return r;
  }(), Zn = {
    mousedown: function(r) {
      r = In(this.dom, r), this.__mayPointerCapture = [
        r.zrX,
        r.zrY
      ], this.trigger("mousedown", r);
    },
    mousemove: function(r) {
      r = In(this.dom, r);
      var e = this.__mayPointerCapture;
      e && (r.zrX !== e[0] || r.zrY !== e[1]) && this.__togglePointerCapture(true), this.trigger("mousemove", r);
    },
    mouseup: function(r) {
      r = In(this.dom, r), this.__togglePointerCapture(false), this.trigger("mouseup", r);
    },
    mouseout: function(r) {
      r = In(this.dom, r);
      var e = r.toElement || r.relatedTarget;
      mR(this, e) || (this.__pointerCapturing && (r.zrEventControl = "no_globalout"), this.trigger("mouseout", r));
    },
    wheel: function(r) {
      bC = true, r = In(this.dom, r), this.trigger("mousewheel", r);
    },
    mousewheel: function(r) {
      bC || (r = In(this.dom, r), this.trigger("mousewheel", r));
    },
    touchstart: function(r) {
      r = In(this.dom, r), am(r), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(r, "start"), Zn.mousemove.call(this, r), Zn.mousedown.call(this, r);
    },
    touchmove: function(r) {
      r = In(this.dom, r), am(r), this.handler.processGesture(r, "change"), Zn.mousemove.call(this, r);
    },
    touchend: function(r) {
      r = In(this.dom, r), am(r), this.handler.processGesture(r, "end"), Zn.mouseup.call(this, r), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < sH && Zn.click.call(this, r);
    },
    pointerdown: function(r) {
      Zn.mousedown.call(this, r);
    },
    pointermove: function(r) {
      Sx(r) || Zn.mousemove.call(this, r);
    },
    pointerup: function(r) {
      Zn.mouseup.call(this, r);
    },
    pointerout: function(r) {
      Sx(r) || Zn.mouseout.call(this, r);
    }
  };
  D([
    "click",
    "dblclick",
    "contextmenu"
  ], function(r) {
    Zn[r] = function(e) {
      e = In(this.dom, e), this.trigger(r, e);
    };
  });
  var Cx = {
    pointermove: function(r) {
      Sx(r) || Cx.mousemove.call(this, r);
    },
    pointerup: function(r) {
      Cx.mouseup.call(this, r);
    },
    mousemove: function(r) {
      this.trigger("mousemove", r);
    },
    mouseup: function(r) {
      var e = this.__pointerCapturing;
      this.__togglePointerCapture(false), this.trigger("mouseup", r), e && (r.zrEventControl = "only_globalout", this.trigger("mouseout", r));
    }
  };
  function hH(r, e) {
    var t = e.domHandlers;
    He.pointerEventsSupported ? D(im.pointer, function(n) {
      vp(e, n, function(i) {
        t[n].call(r, i);
      });
    }) : (He.touchEventsSupported && D(im.touch, function(n) {
      vp(e, n, function(i) {
        t[n].call(r, i), lH(e);
      });
    }), D(im.mouse, function(n) {
      vp(e, n, function(i) {
        i = Zb(i), e.touching || t[n].call(r, i);
      });
    }));
  }
  function fH(r, e) {
    He.pointerEventsSupported ? D(_C.pointer, t) : He.touchEventsSupported || D(_C.mouse, t);
    function t(n) {
      function i(a) {
        a = Zb(a), mR(r, a.target) || (a = uH(r, a), e.domHandlers[n].call(r, a));
      }
      vp(e, n, i, {
        capture: true
      });
    }
  }
  function vp(r, e, t, n) {
    r.mounted[e] = t, r.listenerOpts[e] = n, fx(r.domTarget, e, t, n);
  }
  function om(r) {
    var e = r.mounted;
    for (var t in e) e.hasOwnProperty(t) && TU(r.domTarget, t, e[t], r.listenerOpts[t]);
    r.mounted = {};
  }
  var SC = /* @__PURE__ */ function() {
    function r(e, t) {
      this.mounted = {}, this.listenerOpts = {}, this.touching = false, this.domTarget = e, this.domHandlers = t;
    }
    return r;
  }(), dH = function(r) {
    G(e, r);
    function e(t, n) {
      var i = r.call(this) || this;
      return i.__pointerCapturing = false, i.dom = t, i.painterRoot = n, i._localHandlerScope = new SC(t, Zn), nm && (i._globalHandlerScope = new SC(document, Cx)), hH(i, i._localHandlerScope), i;
    }
    return e.prototype.dispose = function() {
      om(this._localHandlerScope), nm && om(this._globalHandlerScope);
    }, e.prototype.setCursor = function(t) {
      this.dom.style && (this.dom.style.cursor = t || "default");
    }, e.prototype.__togglePointerCapture = function(t) {
      if (this.__mayPointerCapture = null, nm && +this.__pointerCapturing ^ +t) {
        this.__pointerCapturing = t;
        var n = this._globalHandlerScope;
        t ? fH(this, n) : om(n);
      }
    }, e;
  }(Vn), yR = 1;
  He.hasGlobalWindow && (yR = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
  var $p = yR, Tx = 0.4, Ax = "#333", Ix = "#ccc", pH = "#eee", wC = Yv, vH = 5e-5;
  function Do(r) {
    return r > vH || r < -5e-5;
  }
  var Po = [], cl = [], sm = pn(), lm = Math.abs, ta = function() {
    function r() {
    }
    return r.prototype.getLocalTransform = function(e) {
      return r.getLocalTransform(this, e);
    }, r.prototype.setPosition = function(e) {
      this.x = e[0], this.y = e[1];
    }, r.prototype.setScale = function(e) {
      this.scaleX = e[0], this.scaleY = e[1];
    }, r.prototype.setSkew = function(e) {
      this.skewX = e[0], this.skewY = e[1];
    }, r.prototype.setOrigin = function(e) {
      this.originX = e[0], this.originY = e[1];
    }, r.prototype.needLocalTransform = function() {
      return Do(this.rotation) || Do(this.x) || Do(this.y) || Do(this.scaleX - 1) || Do(this.scaleY - 1) || Do(this.skewX) || Do(this.skewY);
    }, r.prototype.updateTransform = function() {
      var e = this.parent && this.parent.transform, t = this.needLocalTransform(), n = this.transform;
      if (!(t || e)) {
        n && (wC(n), this.invTransform = null);
        return;
      }
      n = n || pn(), t ? this.getLocalTransform(n) : wC(n), e && (t ? sa(n, e, n) : jb(n, e)), this.transform = n, this._resolveGlobalScaleRatio(n);
    }, r.prototype._resolveGlobalScaleRatio = function(e) {
      var t = this.globalScaleRatio;
      if (t != null && t !== 1) {
        this.getGlobalScale(Po);
        var n = Po[0] < 0 ? -1 : 1, i = Po[1] < 0 ? -1 : 1, a = ((Po[0] - n) * t + n) / Po[0] || 0, o = ((Po[1] - i) * t + i) / Po[1] || 0;
        e[0] *= a, e[1] *= a, e[2] *= o, e[3] *= o;
      }
      this.invTransform = this.invTransform || pn(), Pu(this.invTransform, e);
    }, r.prototype.getComputedTransform = function() {
      for (var e = this, t = []; e; ) t.push(e), e = e.parent;
      for (; e = t.pop(); ) e.updateTransform();
      return this.transform;
    }, r.prototype.setLocalTransform = function(e) {
      if (e) {
        var t = e[0] * e[0] + e[1] * e[1], n = e[2] * e[2] + e[3] * e[3], i = Math.atan2(e[1], e[0]), a = Math.PI / 2 + i - Math.atan2(e[3], e[2]);
        n = Math.sqrt(n) * Math.cos(a), t = Math.sqrt(t), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +e[4], this.y = +e[5], this.scaleX = t, this.scaleY = n, this.originX = 0, this.originY = 0;
      }
    }, r.prototype.decomposeTransform = function() {
      if (this.transform) {
        var e = this.parent, t = this.transform;
        e && e.transform && (e.invTransform = e.invTransform || pn(), sa(cl, e.invTransform, t), t = cl);
        var n = this.originX, i = this.originY;
        (n || i) && (sm[4] = n, sm[5] = i, sa(cl, t, sm), cl[4] -= n, cl[5] -= i, t = cl), this.setLocalTransform(t);
      }
    }, r.prototype.getGlobalScale = function(e) {
      var t = this.transform;
      return e = e || [], t ? (e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1]), e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3]), t[0] < 0 && (e[0] = -e[0]), t[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e);
    }, r.prototype.transformCoordToLocal = function(e, t) {
      var n = [
        e,
        t
      ], i = this.invTransform;
      return i && xr(n, n, i), n;
    }, r.prototype.transformCoordToGlobal = function(e, t) {
      var n = [
        e,
        t
      ], i = this.transform;
      return i && xr(n, n, i), n;
    }, r.prototype.getLineScale = function() {
      var e = this.transform;
      return e && lm(e[0] - 1) > 1e-10 && lm(e[3] - 1) > 1e-10 ? Math.sqrt(lm(e[0] * e[3] - e[2] * e[1])) : 1;
    }, r.prototype.copyTransform = function(e) {
      xR(this, e);
    }, r.getLocalTransform = function(e, t) {
      t = t || [];
      var n = e.originX || 0, i = e.originY || 0, a = e.scaleX, o = e.scaleY, s = e.anchorX, l = e.anchorY, u = e.rotation || 0, c = e.x, h = e.y, f = e.skewX ? Math.tan(e.skewX) : 0, d = e.skewY ? Math.tan(-e.skewY) : 0;
      if (n || i || s || l) {
        var p = n + s, v = i + l;
        t[4] = -p * a - f * v * o, t[5] = -v * o - d * p * a;
      } else t[4] = t[5] = 0;
      return t[0] = a, t[3] = o, t[1] = d * a, t[2] = f * o, u && qs(t, t, u), t[4] += n + c, t[5] += i + h, t;
    }, r.initDefaultProps = function() {
      var e = r.prototype;
      e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0;
    }(), r;
  }(), zi = [
    "x",
    "y",
    "originX",
    "originY",
    "anchorX",
    "anchorY",
    "rotation",
    "scaleX",
    "scaleY",
    "skewX",
    "skewY"
  ];
  function xR(r, e) {
    for (var t = 0; t < zi.length; t++) {
      var n = zi[t];
      r[n] = e[n];
    }
  }
  var CC = {};
  function gn(r, e) {
    e = e || oo;
    var t = CC[e];
    t || (t = CC[e] = new df(500));
    var n = t.get(r);
    return n == null && (n = so.measureText(r, e).width, t.put(r, n)), n;
  }
  function TC(r, e, t, n) {
    var i = gn(r, e), a = qv(e), o = kc(0, i, t), s = Bl(0, a, n), l = new Oe(o, s, i, a);
    return l;
  }
  function pf(r, e, t, n) {
    var i = ((r || "") + "").split(`
`), a = i.length;
    if (a === 1) return TC(i[0], e, t, n);
    for (var o = new Oe(0, 0, 0, 0), s = 0; s < i.length; s++) {
      var l = TC(i[s], e, t, n);
      s === 0 ? o.copy(l) : o.union(l);
    }
    return o;
  }
  function kc(r, e, t) {
    return t === "right" ? r -= e : t === "center" && (r -= e / 2), r;
  }
  function Bl(r, e, t) {
    return t === "middle" ? r -= e / 2 : t === "bottom" && (r -= e), r;
  }
  function qv(r) {
    return gn("\u56FD", r);
  }
  function si(r, e) {
    return typeof r == "string" ? r.lastIndexOf("%") >= 0 ? parseFloat(r) / 100 * e : parseFloat(r) : r;
  }
  function Gp(r, e, t) {
    var n = e.position || "inside", i = e.distance != null ? e.distance : 5, a = t.height, o = t.width, s = a / 2, l = t.x, u = t.y, c = "left", h = "top";
    if (n instanceof Array) l += si(n[0], t.width), u += si(n[1], t.height), c = null, h = null;
    else switch (n) {
      case "left":
        l -= i, u += s, c = "right", h = "middle";
        break;
      case "right":
        l += i + o, u += s, h = "middle";
        break;
      case "top":
        l += o / 2, u -= i, c = "center", h = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + i, c = "center";
        break;
      case "inside":
        l += o / 2, u += s, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += i, u += s, h = "middle";
        break;
      case "insideRight":
        l += o - i, u += s, c = "right", h = "middle";
        break;
      case "insideTop":
        l += o / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - i, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += o - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += a - i, h = "bottom";
        break;
      case "insideBottomRight":
        l += o - i, u += a - i, c = "right", h = "bottom";
        break;
    }
    return r = r || {}, r.x = l, r.y = u, r.align = c, r.verticalAlign = h, r;
  }
  var um = "__zr_normal__", cm = zi.concat([
    "ignore"
  ]), gH = Fi(zi, function(r, e) {
    return r[e] = true, r;
  }, {
    ignore: false
  }), hl = {}, mH = new Oe(0, 0, 0, 0), Kv = function() {
    function r(e) {
      this.id = YL(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e);
    }
    return r.prototype._init = function(e) {
      this.attr(e);
    }, r.prototype.drift = function(e, t, n) {
      switch (this.draggable) {
        case "horizontal":
          t = 0;
          break;
        case "vertical":
          e = 0;
          break;
      }
      var i = this.transform;
      i || (i = this.transform = [
        1,
        0,
        0,
        1,
        0,
        0
      ]), i[4] += e, i[5] += t, this.decomposeTransform(), this.markRedraw();
    }, r.prototype.beforeUpdate = function() {
    }, r.prototype.afterUpdate = function() {
    }, r.prototype.update = function() {
      this.updateTransform(), this.__dirty && this.updateInnerText();
    }, r.prototype.updateInnerText = function(e) {
      var t = this._textContent;
      if (t && (!t.ignore || e)) {
        this.textConfig || (this.textConfig = {});
        var n = this.textConfig, i = n.local, a = t.innerTransformable, o = void 0, s = void 0, l = false;
        a.parent = i ? this : null;
        var u = false;
        if (a.copyTransform(t), n.position != null) {
          var c = mH;
          n.layoutRect ? c.copy(n.layoutRect) : c.copy(this.getBoundingRect()), i || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(hl, n, c) : Gp(hl, n, c), a.x = hl.x, a.y = hl.y, o = hl.align, s = hl.verticalAlign;
          var h = n.origin;
          if (h && n.rotation != null) {
            var f = void 0, d = void 0;
            h === "center" ? (f = c.width * 0.5, d = c.height * 0.5) : (f = si(h[0], c.width), d = si(h[1], c.height)), u = true, a.originX = -a.x + f + (i ? 0 : c.x), a.originY = -a.y + d + (i ? 0 : c.y);
          }
        }
        n.rotation != null && (a.rotation = n.rotation);
        var p = n.offset;
        p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
        var v = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, g = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), m = void 0, y = void 0, x = void 0;
        v && this.canBeInsideText() ? (m = n.insideFill, y = n.insideStroke, (m == null || m === "auto") && (m = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(m), x = true)) : (m = n.outsideFill, y = n.outsideStroke, (m == null || m === "auto") && (m = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(m), x = true)), m = m || "#000", (m !== g.fill || y !== g.stroke || x !== g.autoStroke || o !== g.align || s !== g.verticalAlign) && (l = true, g.fill = m, g.stroke = y, g.autoStroke = x, g.align = o, g.verticalAlign = s, t.setDefaultTextStyle(g)), t.__dirty |= Ri, l && t.dirtyStyle(true);
      }
    }, r.prototype.canBeInsideText = function() {
      return true;
    }, r.prototype.getInsideTextFill = function() {
      return "#fff";
    }, r.prototype.getInsideTextStroke = function(e) {
      return "#000";
    }, r.prototype.getOutsideFill = function() {
      return this.__zr && this.__zr.isDarkMode() ? Ix : Ax;
    }, r.prototype.getOutsideStroke = function(e) {
      var t = this.__zr && this.__zr.getBackgroundColor(), n = typeof t == "string" && vn(t);
      n || (n = [
        255,
        255,
        255,
        1
      ]);
      for (var i = n[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++) n[o] = n[o] * i + (a ? 0 : 255) * (1 - i);
      return n[3] = 1, la(n, "rgba");
    }, r.prototype.traverse = function(e, t) {
    }, r.prototype.attrKV = function(e, t) {
      e === "textConfig" ? this.setTextConfig(t) : e === "textContent" ? this.setTextContent(t) : e === "clipPath" ? this.setClipPath(t) : e === "extra" ? (this.extra = this.extra || {}, H(this.extra, t)) : this[e] = t;
    }, r.prototype.hide = function() {
      this.ignore = true, this.markRedraw();
    }, r.prototype.show = function() {
      this.ignore = false, this.markRedraw();
    }, r.prototype.attr = function(e, t) {
      if (typeof e == "string") this.attrKV(e, t);
      else if (_e(e)) for (var n = e, i = je(n), a = 0; a < i.length; a++) {
        var o = i[a];
        this.attrKV(o, e[o]);
      }
      return this.markRedraw(), this;
    }, r.prototype.saveCurrentToNormalState = function(e) {
      this._innerSaveToNormal(e);
      for (var t = this._normalState, n = 0; n < this.animators.length; n++) {
        var i = this.animators[n], a = i.__fromStateTransition;
        if (!(i.getLoop() || a && a !== um)) {
          var o = i.targetName, s = o ? t[o] : t;
          i.saveTo(s);
        }
      }
    }, r.prototype._innerSaveToNormal = function(e) {
      var t = this._normalState;
      t || (t = this._normalState = {}), e.textConfig && !t.textConfig && (t.textConfig = this.textConfig), this._savePrimaryToNormal(e, t, cm);
    }, r.prototype._savePrimaryToNormal = function(e, t, n) {
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        e[a] != null && !(a in t) && (t[a] = this[a]);
      }
    }, r.prototype.hasState = function() {
      return this.currentStates.length > 0;
    }, r.prototype.getState = function(e) {
      return this.states[e];
    }, r.prototype.ensureState = function(e) {
      var t = this.states;
      return t[e] || (t[e] = {}), t[e];
    }, r.prototype.clearStates = function(e) {
      this.useState(um, false, e);
    }, r.prototype.useState = function(e, t, n, i) {
      var a = e === um, o = this.hasState();
      if (!(!o && a)) {
        var s = this.currentStates, l = this.stateTransition;
        if (!(Be(s, e) >= 0 && (t || s.length === 1))) {
          var u;
          if (this.stateProxy && !a && (u = this.stateProxy(e)), u || (u = this.states && this.states[e]), !u && !a) {
            Yb("State " + e + " not exists.");
            return;
          }
          a || this.saveCurrentToNormalState(u);
          var c = !!(u && u.hoverLayer || i);
          c && this._toggleHoverLayerFlag(true), this._applyStateObj(e, u, this._normalState, t, !n && !this.__inHover && l && l.duration > 0, l);
          var h = this._textContent, f = this._textGuide;
          return h && h.useState(e, t, n, c), f && f.useState(e, t, n, c), a ? (this.currentStates = [], this._normalState = {}) : t ? this.currentStates.push(e) : this.currentStates = [
            e
          ], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= -2), u;
        }
      }
    }, r.prototype.useStates = function(e, t, n) {
      if (!e.length) this.clearStates();
      else {
        var i = [], a = this.currentStates, o = e.length, s = o === a.length;
        if (s) {
          for (var l = 0; l < o; l++) if (e[l] !== a[l]) {
            s = false;
            break;
          }
        }
        if (s) return;
        for (var l = 0; l < o; l++) {
          var u = e[l], c = void 0;
          this.stateProxy && (c = this.stateProxy(u, e)), c || (c = this.states[u]), c && i.push(c);
        }
        var h = i[o - 1], f = !!(h && h.hoverLayer || n);
        f && this._toggleHoverLayerFlag(true);
        var d = this._mergeStates(i), p = this.stateTransition;
        this.saveCurrentToNormalState(d), this._applyStateObj(e.join(","), d, this._normalState, false, !t && !this.__inHover && p && p.duration > 0, p);
        var v = this._textContent, g = this._textGuide;
        v && v.useStates(e, t, f), g && g.useStates(e, t, f), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= -2);
      }
    }, r.prototype.isSilent = function() {
      for (var e = this.silent, t = this.parent; !e && t; ) {
        if (t.silent) {
          e = true;
          break;
        }
        t = t.parent;
      }
      return e;
    }, r.prototype._updateAnimationTargets = function() {
      for (var e = 0; e < this.animators.length; e++) {
        var t = this.animators[e];
        t.targetName && t.changeTarget(this[t.targetName]);
      }
    }, r.prototype.removeState = function(e) {
      var t = Be(this.currentStates, e);
      if (t >= 0) {
        var n = this.currentStates.slice();
        n.splice(t, 1), this.useStates(n);
      }
    }, r.prototype.replaceState = function(e, t, n) {
      var i = this.currentStates.slice(), a = Be(i, e), o = Be(i, t) >= 0;
      a >= 0 ? o ? i.splice(a, 1) : i[a] = t : n && !o && i.push(t), this.useStates(i);
    }, r.prototype.toggleState = function(e, t) {
      t ? this.useState(e, true) : this.removeState(e);
    }, r.prototype._mergeStates = function(e) {
      for (var t = {}, n, i = 0; i < e.length; i++) {
        var a = e[i];
        H(t, a), a.textConfig && (n = n || {}, H(n, a.textConfig));
      }
      return n && (t.textConfig = n), t;
    }, r.prototype._applyStateObj = function(e, t, n, i, a, o) {
      var s = !(t && i);
      t && t.textConfig ? (this.textConfig = H({}, i ? this.textConfig : n.textConfig), H(this.textConfig, t.textConfig)) : s && n.textConfig && (this.textConfig = n.textConfig);
      for (var l = {}, u = false, c = 0; c < cm.length; c++) {
        var h = cm[c], f = a && gH[h];
        t && t[h] != null ? f ? (u = true, l[h] = t[h]) : this[h] = t[h] : s && n[h] != null && (f ? (u = true, l[h] = n[h]) : this[h] = n[h]);
      }
      if (!a) for (var c = 0; c < this.animators.length; c++) {
        var d = this.animators[c], p = d.targetName;
        d.getLoop() || d.__changeFinalValue(p ? (t || n)[p] : t || n);
      }
      u && this._transitionState(e, l, o);
    }, r.prototype._attachComponent = function(e) {
      if (!(e.__zr && !e.__hostTarget) && e !== this) {
        var t = this.__zr;
        t && e.addSelfToZr(t), e.__zr = t, e.__hostTarget = this;
      }
    }, r.prototype._detachComponent = function(e) {
      e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null;
    }, r.prototype.getClipPath = function() {
      return this._clipPath;
    }, r.prototype.setClipPath = function(e) {
      this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw();
    }, r.prototype.removeClipPath = function() {
      var e = this._clipPath;
      e && (this._detachComponent(e), this._clipPath = null, this.markRedraw());
    }, r.prototype.getTextContent = function() {
      return this._textContent;
    }, r.prototype.setTextContent = function(e) {
      var t = this._textContent;
      t !== e && (t && t !== e && this.removeTextContent(), e.innerTransformable = new ta(), this._attachComponent(e), this._textContent = e, this.markRedraw());
    }, r.prototype.setTextConfig = function(e) {
      this.textConfig || (this.textConfig = {}), H(this.textConfig, e), this.markRedraw();
    }, r.prototype.removeTextConfig = function() {
      this.textConfig = null, this.markRedraw();
    }, r.prototype.removeTextContent = function() {
      var e = this._textContent;
      e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
    }, r.prototype.getTextGuideLine = function() {
      return this._textGuide;
    }, r.prototype.setTextGuideLine = function(e) {
      this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw();
    }, r.prototype.removeTextGuideLine = function() {
      var e = this._textGuide;
      e && (this._detachComponent(e), this._textGuide = null, this.markRedraw());
    }, r.prototype.markRedraw = function() {
      this.__dirty |= Ri;
      var e = this.__zr;
      e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
    }, r.prototype.dirty = function() {
      this.markRedraw();
    }, r.prototype._toggleHoverLayerFlag = function(e) {
      this.__inHover = e;
      var t = this._textContent, n = this._textGuide;
      t && (t.__inHover = e), n && (n.__inHover = e);
    }, r.prototype.addSelfToZr = function(e) {
      if (this.__zr !== e) {
        this.__zr = e;
        var t = this.animators;
        if (t) for (var n = 0; n < t.length; n++) e.animation.addAnimator(t[n]);
        this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e);
      }
    }, r.prototype.removeSelfFromZr = function(e) {
      if (this.__zr) {
        this.__zr = null;
        var t = this.animators;
        if (t) for (var n = 0; n < t.length; n++) e.animation.removeAnimator(t[n]);
        this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e);
      }
    }, r.prototype.animate = function(e, t, n) {
      var i = e ? this[e] : this, a = new t1(i, t, n);
      return e && (a.targetName = e), this.addAnimator(a, e), a;
    }, r.prototype.addAnimator = function(e, t) {
      var n = this.__zr, i = this;
      e.during(function() {
        i.updateDuringAnimation(t);
      }).done(function() {
        var a = i.animators, o = Be(a, e);
        o >= 0 && a.splice(o, 1);
      }), this.animators.push(e), n && n.animation.addAnimator(e), n && n.wakeUp();
    }, r.prototype.updateDuringAnimation = function(e) {
      this.markRedraw();
    }, r.prototype.stopAnimation = function(e, t) {
      for (var n = this.animators, i = n.length, a = [], o = 0; o < i; o++) {
        var s = n[o];
        !e || e === s.scope ? s.stop(t) : a.push(s);
      }
      return this.animators = a, this;
    }, r.prototype.animateTo = function(e, t, n) {
      hm(this, e, t, n);
    }, r.prototype.animateFrom = function(e, t, n) {
      hm(this, e, t, n, true);
    }, r.prototype._transitionState = function(e, t, n, i) {
      for (var a = hm(this, t, n, i), o = 0; o < a.length; o++) a[o].__fromStateTransition = e;
    }, r.prototype.getBoundingRect = function() {
      return null;
    }, r.prototype.getPaintRect = function() {
      return null;
    }, r.initDefaultProps = function() {
      var e = r.prototype;
      e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = false, e.__dirty = Ri;
      function t(n, i, a, o) {
        Object.defineProperty(e, n, {
          get: function() {
            if (!this[i]) {
              var l = this[i] = [];
              s(this, l);
            }
            return this[i];
          },
          set: function(l) {
            this[a] = l[0], this[o] = l[1], this[i] = l, s(this, l);
          }
        });
        function s(l, u) {
          Object.defineProperty(u, 0, {
            get: function() {
              return l[a];
            },
            set: function(c) {
              l[a] = c;
            }
          }), Object.defineProperty(u, 1, {
            get: function() {
              return l[o];
            },
            set: function(c) {
              l[o] = c;
            }
          });
        }
      }
      Object.defineProperty && (t("position", "_legacyPos", "x", "y"), t("scale", "_legacyScale", "scaleX", "scaleY"), t("origin", "_legacyOrigin", "originX", "originY"));
    }(), r;
  }();
  qt(Kv, Vn);
  qt(Kv, ta);
  function hm(r, e, t, n, i) {
    t = t || {};
    var a = [];
    _R(r, "", r, e, t, n, a, i);
    var o = a.length, s = false, l = t.done, u = t.aborted, c = function() {
      s = true, o--, o <= 0 && (s ? l && l() : u && u());
    }, h = function() {
      o--, o <= 0 && (s ? l && l() : u && u());
    };
    o || l && l(), a.length > 0 && t.during && a[0].during(function(p, v) {
      t.during(v);
    });
    for (var f = 0; f < a.length; f++) {
      var d = a[f];
      c && d.done(c), h && d.aborted(h), t.force && d.duration(t.duration), d.start(t.easing);
    }
    return a;
  }
  function fm(r, e, t) {
    for (var n = 0; n < t; n++) r[n] = e[n];
  }
  function yH(r) {
    return Lr(r[0]);
  }
  function xH(r, e, t) {
    if (Lr(e[t])) if (Lr(r[t]) || (r[t] = []), sn(e[t])) {
      var n = e[t].length;
      r[t].length !== n && (r[t] = new e[t].constructor(n), fm(r[t], e[t], n));
    } else {
      var i = e[t], a = r[t], o = i.length;
      if (yH(i)) for (var s = i[0].length, l = 0; l < o; l++) a[l] ? fm(a[l], i[l], s) : a[l] = Array.prototype.slice.call(i[l]);
      else fm(a, i, o);
      a.length = i.length;
    }
    else r[t] = e[t];
  }
  function _H(r, e) {
    return r === e || Lr(r) && Lr(e) && bH(r, e);
  }
  function bH(r, e) {
    var t = r.length;
    if (t !== e.length) return false;
    for (var n = 0; n < t; n++) if (r[n] !== e[n]) return false;
    return true;
  }
  function _R(r, e, t, n, i, a, o, s) {
    for (var l = je(n), u = i.duration, c = i.delay, h = i.additive, f = i.setToFinal, d = !_e(a), p = r.animators, v = [], g = 0; g < l.length; g++) {
      var m = l[g], y = n[m];
      if (y != null && t[m] != null && (d || a[m])) if (_e(y) && !Lr(y) && !Uv(y)) {
        if (e) {
          s || (t[m] = y, r.updateDuringAnimation(e));
          continue;
        }
        _R(r, m, t[m], y, i, a && a[m], o, s);
      } else v.push(m);
      else s || (t[m] = y, r.updateDuringAnimation(e), v.push(m));
    }
    var x = v.length;
    if (!h && x) for (var _ = 0; _ < p.length; _++) {
      var S = p[_];
      if (S.targetName === e) {
        var b = S.stopTracks(v);
        if (b) {
          var w = Be(p, S);
          p.splice(w, 1);
        }
      }
    }
    if (i.force || (v = ct(v, function(M) {
      return !_H(n[M], t[M]);
    }), x = v.length), x > 0 || i.force && !o.length) {
      var C = void 0, T = void 0, A = void 0;
      if (s) {
        T = {}, f && (C = {});
        for (var _ = 0; _ < x; _++) {
          var m = v[_];
          T[m] = t[m], f ? C[m] = n[m] : t[m] = n[m];
        }
      } else if (f) {
        A = {};
        for (var _ = 0; _ < x; _++) {
          var m = v[_];
          A[m] = Zc(t[m]), xH(t, n, m);
        }
      }
      var S = new t1(t, false, false, h ? ct(p, function(E) {
        return E.targetName === e;
      }) : null);
      S.targetName = e, i.scope && (S.scope = i.scope), f && C && S.whenWithKeys(0, C, v), A && S.whenWithKeys(0, A, v), S.whenWithKeys(u ?? 500, s ? T : n, v).delay(c || 0), r.addAnimator(S, e), o.push(S);
    }
  }
  var Ce = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this) || this;
      return n.isGroup = true, n._children = [], n.attr(t), n;
    }
    return e.prototype.childrenRef = function() {
      return this._children;
    }, e.prototype.children = function() {
      return this._children.slice();
    }, e.prototype.childAt = function(t) {
      return this._children[t];
    }, e.prototype.childOfName = function(t) {
      for (var n = this._children, i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    }, e.prototype.childCount = function() {
      return this._children.length;
    }, e.prototype.add = function(t) {
      return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this;
    }, e.prototype.addBefore = function(t, n) {
      if (t && t !== this && t.parent !== this && n && n.parent === this) {
        var i = this._children, a = i.indexOf(n);
        a >= 0 && (i.splice(a, 0, t), this._doAdd(t));
      }
      return this;
    }, e.prototype.replace = function(t, n) {
      var i = Be(this._children, t);
      return i >= 0 && this.replaceAt(n, i), this;
    }, e.prototype.replaceAt = function(t, n) {
      var i = this._children, a = i[n];
      if (t && t !== this && t.parent !== this && t !== a) {
        i[n] = t, a.parent = null;
        var o = this.__zr;
        o && a.removeSelfFromZr(o), this._doAdd(t);
      }
      return this;
    }, e.prototype._doAdd = function(t) {
      t.parent && t.parent.remove(t), t.parent = this;
      var n = this.__zr;
      n && n !== t.__zr && t.addSelfToZr(n), n && n.refresh();
    }, e.prototype.remove = function(t) {
      var n = this.__zr, i = this._children, a = Be(i, t);
      return a < 0 ? this : (i.splice(a, 1), t.parent = null, n && t.removeSelfFromZr(n), n && n.refresh(), this);
    }, e.prototype.removeAll = function() {
      for (var t = this._children, n = this.__zr, i = 0; i < t.length; i++) {
        var a = t[i];
        n && a.removeSelfFromZr(n), a.parent = null;
      }
      return t.length = 0, this;
    }, e.prototype.eachChild = function(t, n) {
      for (var i = this._children, a = 0; a < i.length; a++) {
        var o = i[a];
        t.call(n, o, a);
      }
      return this;
    }, e.prototype.traverse = function(t, n) {
      for (var i = 0; i < this._children.length; i++) {
        var a = this._children[i], o = t.call(n, a);
        a.isGroup && !o && a.traverse(t, n);
      }
      return this;
    }, e.prototype.addSelfToZr = function(t) {
      r.prototype.addSelfToZr.call(this, t);
      for (var n = 0; n < this._children.length; n++) {
        var i = this._children[n];
        i.addSelfToZr(t);
      }
    }, e.prototype.removeSelfFromZr = function(t) {
      r.prototype.removeSelfFromZr.call(this, t);
      for (var n = 0; n < this._children.length; n++) {
        var i = this._children[n];
        i.removeSelfFromZr(t);
      }
    }, e.prototype.getBoundingRect = function(t) {
      for (var n = new Oe(0, 0, 0, 0), i = t || this._children, a = [], o = null, s = 0; s < i.length; s++) {
        var l = i[s];
        if (!(l.ignore || l.invisible)) {
          var u = l.getBoundingRect(), c = l.getLocalTransform(a);
          c ? (Oe.applyTransform(n, u, c), o = o || n.clone(), o.union(n)) : (o = o || u.clone(), o.union(u));
        }
      }
      return o || n;
    }, e;
  }(Kv);
  Ce.prototype.type = "group";
  var gp = {}, bR = {};
  function SH(r) {
    delete bR[r];
  }
  function wH(r) {
    if (!r) return false;
    if (typeof r == "string") return zp(r, 1) < Tx;
    if (r.colorStops) {
      for (var e = r.colorStops, t = 0, n = e.length, i = 0; i < n; i++) t += zp(e[i].color, 1);
      return t /= n, t < Tx;
    }
    return false;
  }
  var CH = function() {
    function r(e, t, n) {
      var i = this;
      this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = true, this._needsRefreshHover = true, this._darkMode = false, n = n || {}, this.dom = t, this.id = e;
      var a = new FU(), o = n.renderer || "canvas";
      gp[o] || (o = je(gp)[0]), n.useDirtyRect = n.useDirtyRect == null ? false : n.useDirtyRect;
      var s = new gp[o](t, a, n, e), l = n.ssr || s.ssrOnly;
      this.storage = a, this.painter = s;
      var u = !He.node && !He.worker && !l ? new dH(s.getViewportRoot(), s.root) : null, c = n.useCoarsePointer, h = c == null || c === "auto" ? He.touchEventsSupported : !!c, f = 44, d;
      h && (d = Pe(n.pointerSize, f)), this.handler = new QL(a, s, u, s.root, d), this.animation = new oH({
        stage: {
          update: l ? null : function() {
            return i._flush(true);
          }
        }
      }), l || this.animation.start();
    }
    return r.prototype.add = function(e) {
      this._disposed || !e || (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh());
    }, r.prototype.remove = function(e) {
      this._disposed || !e || (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh());
    }, r.prototype.configLayer = function(e, t) {
      this._disposed || (this.painter.configLayer && this.painter.configLayer(e, t), this.refresh());
    }, r.prototype.setBackgroundColor = function(e) {
      this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = wH(e));
    }, r.prototype.getBackgroundColor = function() {
      return this._backgroundColor;
    }, r.prototype.setDarkMode = function(e) {
      this._darkMode = e;
    }, r.prototype.isDarkMode = function() {
      return this._darkMode;
    }, r.prototype.refreshImmediately = function(e) {
      this._disposed || (e || this.animation.update(true), this._needsRefresh = false, this.painter.refresh(), this._needsRefresh = false);
    }, r.prototype.refresh = function() {
      this._disposed || (this._needsRefresh = true, this.animation.start());
    }, r.prototype.flush = function() {
      this._disposed || this._flush(false);
    }, r.prototype._flush = function(e) {
      var t, n = Xl();
      this._needsRefresh && (t = true, this.refreshImmediately(e)), this._needsRefreshHover && (t = true, this.refreshHoverImmediately());
      var i = Xl();
      t ? (this._stillFrameAccum = 0, this.trigger("rendered", {
        elapsedTime: i - n
      })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
    }, r.prototype.setSleepAfterStill = function(e) {
      this._sleepAfterStill = e;
    }, r.prototype.wakeUp = function() {
      this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
    }, r.prototype.refreshHover = function() {
      this._needsRefreshHover = true;
    }, r.prototype.refreshHoverImmediately = function() {
      this._disposed || (this._needsRefreshHover = false, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
    }, r.prototype.resize = function(e) {
      this._disposed || (e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize());
    }, r.prototype.clearAnimation = function() {
      this._disposed || this.animation.clear();
    }, r.prototype.getWidth = function() {
      if (!this._disposed) return this.painter.getWidth();
    }, r.prototype.getHeight = function() {
      if (!this._disposed) return this.painter.getHeight();
    }, r.prototype.setCursorStyle = function(e) {
      this._disposed || this.handler.setCursorStyle(e);
    }, r.prototype.findHover = function(e, t) {
      if (!this._disposed) return this.handler.findHover(e, t);
    }, r.prototype.on = function(e, t, n) {
      return this._disposed || this.handler.on(e, t, n), this;
    }, r.prototype.off = function(e, t) {
      this._disposed || this.handler.off(e, t);
    }, r.prototype.trigger = function(e, t) {
      this._disposed || this.handler.trigger(e, t);
    }, r.prototype.clear = function() {
      if (!this._disposed) {
        for (var e = this.storage.getRoots(), t = 0; t < e.length; t++) e[t] instanceof Ce && e[t].removeSelfFromZr(this);
        this.storage.delAllRoots(), this.painter.clear();
      }
    }, r.prototype.dispose = function() {
      this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = true, SH(this.id));
    }, r;
  }();
  function AC(r, e) {
    var t = new CH(YL(), r, e);
    return bR[t.id] = t, t;
  }
  function TH(r, e) {
    gp[r] = e;
  }
  var Mx;
  function AH(r) {
    if (typeof Mx == "function") return Mx(r);
  }
  function IH(r) {
    Mx = r;
  }
  var MH = 1e-4, SR = 20;
  function DH(r) {
    return r.replace(/^\s+|\s+$/g, "");
  }
  function ht(r, e, t, n) {
    var i = e[0], a = e[1], o = t[0], s = t[1], l = a - i, u = s - o;
    if (l === 0) return u === 0 ? o : (o + s) / 2;
    if (n) if (l > 0) {
      if (r <= i) return o;
      if (r >= a) return s;
    } else {
      if (r >= i) return o;
      if (r <= a) return s;
    }
    else {
      if (r === i) return o;
      if (r === a) return s;
    }
    return (r - i) / l * u + o;
  }
  function Q(r, e) {
    switch (r) {
      case "center":
      case "middle":
        r = "50%";
        break;
      case "left":
      case "top":
        r = "0%";
        break;
      case "right":
      case "bottom":
        r = "100%";
        break;
    }
    return ee(r) ? DH(r).match(/%$/) ? parseFloat(r) / 100 * e : parseFloat(r) : r == null ? NaN : +r;
  }
  function Bt(r, e, t) {
    return e == null && (e = 10), e = Math.min(Math.max(0, e), SR), r = (+r).toFixed(e), t ? r : +r;
  }
  function On(r) {
    return r.sort(function(e, t) {
      return e - t;
    }), r;
  }
  function Mi(r) {
    if (r = +r, isNaN(r)) return 0;
    if (r > 1e-14) {
      for (var e = 1, t = 0; t < 15; t++, e *= 10) if (Math.round(r * e) / e === r) return t;
    }
    return PH(r);
  }
  function PH(r) {
    var e = r.toString().toLowerCase(), t = e.indexOf("e"), n = t > 0 ? +e.slice(t + 1) : 0, i = t > 0 ? t : e.length, a = e.indexOf("."), o = a < 0 ? 0 : i - 1 - a;
    return Math.max(0, o - n);
  }
  function wR(r, e) {
    var t = Math.log, n = Math.LN10, i = Math.floor(t(r[1] - r[0]) / n), a = Math.round(t(Math.abs(e[1] - e[0])) / n), o = Math.min(Math.max(-i + a, 0), 20);
    return isFinite(o) ? o : 20;
  }
  function kH(r, e) {
    var t = Fi(r, function(d, p) {
      return d + (isNaN(p) ? 0 : p);
    }, 0);
    if (t === 0) return [];
    for (var n = Math.pow(10, e), i = K(r, function(d) {
      return (isNaN(d) ? 0 : d) / t * n * 100;
    }), a = n * 100, o = K(i, function(d) {
      return Math.floor(d);
    }), s = Fi(o, function(d, p) {
      return d + p;
    }, 0), l = K(i, function(d, p) {
      return d - o[p];
    }); s < a; ) {
      for (var u = Number.NEGATIVE_INFINITY, c = null, h = 0, f = l.length; h < f; ++h) l[h] > u && (u = l[h], c = h);
      ++o[c], l[c] = 0, ++s;
    }
    return K(o, function(d) {
      return d / n;
    });
  }
  function LH(r, e) {
    var t = Math.max(Mi(r), Mi(e)), n = r + e;
    return t > SR ? n : Bt(n, t);
  }
  var IC = 9007199254740991;
  function CR(r) {
    var e = Math.PI * 2;
    return (r % e + e) % e;
  }
  function Ch(r) {
    return r > -1e-4 && r < MH;
  }
  var RH = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function Vi(r) {
    if (r instanceof Date) return r;
    if (ee(r)) {
      var e = RH.exec(r);
      if (!e) return /* @__PURE__ */ new Date(NaN);
      if (e[8]) {
        var t = +e[4] || 0;
        return e[8].toUpperCase() !== "Z" && (t -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, t, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0));
      } else return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0);
    } else if (r == null) return /* @__PURE__ */ new Date(NaN);
    return new Date(Math.round(r));
  }
  function EH(r) {
    return Math.pow(10, r1(r));
  }
  function r1(r) {
    if (r === 0) return 0;
    var e = Math.floor(Math.log(r) / Math.LN10);
    return r / Math.pow(10, e) >= 10 && e++, e;
  }
  function TR(r, e) {
    var t = r1(r), n = Math.pow(10, t), i = r / n, a;
    return i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10, r = a * n, t >= -20 ? +r.toFixed(t < 0 ? -t : 0) : r;
  }
  function dm(r, e) {
    var t = (r.length - 1) * e + 1, n = Math.floor(t), i = +r[n - 1], a = t - n;
    return a ? i + a * (r[n] - i) : i;
  }
  function MC(r) {
    r.sort(function(l, u) {
      return s(l, u, 0) ? -1 : 1;
    });
    for (var e = -1 / 0, t = 1, n = 0; n < r.length; ) {
      for (var i = r[n].interval, a = r[n].close, o = 0; o < 2; o++) i[o] <= e && (i[o] = e, a[o] = o ? 1 : 1 - t), e = i[o], t = a[o];
      i[0] === i[1] && a[0] * a[1] !== 1 ? r.splice(n, 1) : n++;
    }
    return r;
    function s(l, u, c) {
      return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
    }
  }
  function va(r) {
    var e = parseFloat(r);
    return e == r && (e !== 0 || !ee(r) || r.indexOf("x") <= 0) ? e : NaN;
  }
  function AR(r) {
    return !isNaN(va(r));
  }
  function IR() {
    return Math.round(Math.random() * 9);
  }
  function MR(r, e) {
    return e === 0 ? r : MR(e, r % e);
  }
  function DC(r, e) {
    return r == null ? e : e == null ? r : r * e / MR(r, e);
  }
  function ut(r) {
    throw new Error(r);
  }
  function PC(r, e, t) {
    return (e - r) * t + r;
  }
  var DR = "series\0", PR = "\0_ec_\0";
  function gt(r) {
    return r instanceof Array ? r : r == null ? [] : [
      r
    ];
  }
  function Bs(r, e, t) {
    if (r) {
      r[e] = r[e] || {}, r.emphasis = r.emphasis || {}, r.emphasis[e] = r.emphasis[e] || {};
      for (var n = 0, i = t.length; n < i; n++) {
        var a = t[n];
        !r.emphasis[e].hasOwnProperty(a) && r[e].hasOwnProperty(a) && (r.emphasis[e][a] = r[e][a]);
      }
    }
  }
  var kC = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "rich",
    "tag",
    "color",
    "textBorderColor",
    "textBorderWidth",
    "width",
    "height",
    "lineHeight",
    "align",
    "verticalAlign",
    "baseline",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "textShadowColor",
    "textShadowBlur",
    "textShadowOffsetX",
    "textShadowOffsetY",
    "backgroundColor",
    "borderColor",
    "borderWidth",
    "borderRadius",
    "padding"
  ];
  function ku(r) {
    return _e(r) && !X(r) && !(r instanceof Date) ? r.value : r;
  }
  function NH(r) {
    return _e(r) && !(r instanceof Array);
  }
  function kR(r, e, t) {
    var n = t === "normalMerge", i = t === "replaceMerge", a = t === "replaceAll";
    r = r || [], e = (e || []).slice();
    var o = ce();
    D(e, function(l, u) {
      if (!_e(l)) {
        e[u] = null;
        return;
      }
    });
    var s = OH(r, o, t);
    return (n || i) && FH(s, r, o, e), n && BH(s, e), n || i ? zH(s, e, i) : a && VH(s, e), $H(s), s;
  }
  function OH(r, e, t) {
    var n = [];
    if (t === "replaceAll") return n;
    for (var i = 0; i < r.length; i++) {
      var a = r[i];
      a && a.id != null && e.set(a.id, i), n.push({
        existing: t === "replaceMerge" || Th(a) ? null : a,
        newOption: null,
        keyInfo: null,
        brandNew: null
      });
    }
    return n;
  }
  function FH(r, e, t, n) {
    D(n, function(i, a) {
      if (!(!i || i.id == null)) {
        var o = jc(i.id), s = t.get(o);
        if (s != null) {
          var l = r[s];
          Yr(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = i, l.existing = e[s], n[a] = null;
        }
      }
    });
  }
  function BH(r, e) {
    D(e, function(t, n) {
      if (!(!t || t.name == null)) for (var i = 0; i < r.length; i++) {
        var a = r[i].existing;
        if (!r[i].newOption && a && (a.id == null || t.id == null) && !Th(t) && !Th(a) && LR("name", a, t)) {
          r[i].newOption = t, e[n] = null;
          return;
        }
      }
    });
  }
  function zH(r, e, t) {
    D(e, function(n) {
      if (n) {
        for (var i, a = 0; (i = r[a]) && (i.newOption || Th(i.existing) || i.existing && n.id != null && !LR("id", n, i.existing)); ) a++;
        i ? (i.newOption = n, i.brandNew = t) : r.push({
          newOption: n,
          brandNew: t,
          existing: null,
          keyInfo: null
        }), a++;
      }
    });
  }
  function VH(r, e) {
    D(e, function(t) {
      r.push({
        newOption: t,
        brandNew: true,
        existing: null,
        keyInfo: null
      });
    });
  }
  function $H(r) {
    var e = ce();
    D(r, function(t) {
      var n = t.existing;
      n && e.set(n.id, t);
    }), D(r, function(t) {
      var n = t.newOption;
      Yr(!n || n.id == null || !e.get(n.id) || e.get(n.id) === t, "id duplicates: " + (n && n.id)), n && n.id != null && e.set(n.id, t), !t.keyInfo && (t.keyInfo = {});
    }), D(r, function(t, n) {
      var i = t.existing, a = t.newOption, o = t.keyInfo;
      if (_e(a)) {
        if (o.name = a.name != null ? jc(a.name) : i ? i.name : DR + n, i) o.id = jc(i.id);
        else if (a.id != null) o.id = jc(a.id);
        else {
          var s = 0;
          do
            o.id = "\0" + o.name + "\0" + s++;
          while (e.get(o.id));
        }
        e.set(o.id, t);
      }
    });
  }
  function LR(r, e, t) {
    var n = jt(e[r], null), i = jt(t[r], null);
    return n != null && i != null && n === i;
  }
  function jc(r) {
    return jt(r, "");
  }
  function jt(r, e) {
    return r == null ? e : ee(r) ? r : nt(r) || ax(r) ? r + "" : e;
  }
  function n1(r) {
    var e = r.name;
    return !!(e && e.indexOf(DR));
  }
  function Th(r) {
    return r && r.id != null && jc(r.id).indexOf(PR) === 0;
  }
  function GH(r) {
    return PR + r;
  }
  function WH(r, e, t) {
    D(r, function(n) {
      var i = n.newOption;
      _e(i) && (n.keyInfo.mainType = e, n.keyInfo.subType = UH(e, i, n.existing, t));
    });
  }
  function UH(r, e, t, n) {
    var i = e.type ? e.type : t ? t.subType : n.determineSubType(r, e);
    return i;
  }
  function HH(r, e) {
    var t = {}, n = {};
    return i(r || [], t), i(e || [], n, t), [
      a(t),
      a(n)
    ];
    function i(o, s, l) {
      for (var u = 0, c = o.length; u < c; u++) {
        var h = jt(o[u].seriesId, null);
        if (h == null) return;
        for (var f = gt(o[u].dataIndex), d = l && l[h], p = 0, v = f.length; p < v; p++) {
          var g = f[p];
          d && d[g] ? d[g] = null : (s[h] || (s[h] = {}))[g] = 1;
        }
      }
    }
    function a(o, s) {
      var l = [];
      for (var u in o) if (o.hasOwnProperty(u) && o[u] != null) if (s) l.push(+u);
      else {
        var c = a(o[u], true);
        c.length && l.push({
          seriesId: u,
          dataIndex: c
        });
      }
      return l;
    }
  }
  function zs(r, e) {
    if (e.dataIndexInside != null) return e.dataIndexInside;
    if (e.dataIndex != null) return X(e.dataIndex) ? K(e.dataIndex, function(t) {
      return r.indexOfRawIndex(t);
    }) : r.indexOfRawIndex(e.dataIndex);
    if (e.name != null) return X(e.name) ? K(e.name, function(t) {
      return r.indexOfName(t);
    }) : r.indexOfName(e.name);
  }
  function tt() {
    var r = "__ec_inner_" + YH++;
    return function(e) {
      return e[r] || (e[r] = {});
    };
  }
  var YH = IR();
  function Qc(r, e, t) {
    var n = i1(e, t), i = n.mainTypeSpecified, a = n.queryOptionMap, o = n.others, s = o, l = t ? t.defaultMainType : null;
    return !i && l && a.set(l, {}), a.each(function(u, c) {
      var h = vf(r, c, u, {
        useDefault: l === c,
        enableAll: t && t.enableAll != null ? t.enableAll : true,
        enableNone: t && t.enableNone != null ? t.enableNone : true
      });
      s[c + "Models"] = h.models, s[c + "Model"] = h.models[0];
    }), s;
  }
  function i1(r, e) {
    var t;
    if (ee(r)) {
      var n = {};
      n[r + "Index"] = 0, t = n;
    } else t = r;
    var i = ce(), a = {}, o = false;
    return D(t, function(s, l) {
      if (l === "dataIndex" || l === "dataIndexInside") {
        a[l] = s;
        return;
      }
      var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
      if (!(!c || !h || e && e.includeMainTypes && Be(e.includeMainTypes, c) < 0)) {
        o = o || !!c;
        var f = i.get(c) || i.set(c, {});
        f[h] = s;
      }
    }), {
      mainTypeSpecified: o,
      queryOptionMap: i,
      others: a
    };
  }
  var Yt = {
    useDefault: true,
    enableAll: false,
    enableNone: false
  }, XH = {
    useDefault: false,
    enableAll: true,
    enableNone: true
  };
  function vf(r, e, t, n) {
    n = n || Yt;
    var i = t.index, a = t.id, o = t.name, s = {
      models: null,
      specified: i != null || a != null || o != null
    };
    if (!s.specified) {
      var l = void 0;
      return s.models = n.useDefault && (l = r.getComponent(e)) ? [
        l
      ] : [], s;
    }
    return i === "none" || i === false ? (Yr(n.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (i === "all" && (Yr(n.enableAll, '`"all"` is not a valid value on index option.'), i = a = o = null), s.models = r.queryComponents({
      mainType: e,
      index: i,
      id: a,
      name: o
    }), s);
  }
  function RR(r, e, t) {
    r.setAttribute ? r.setAttribute(e, t) : r[e] = t;
  }
  function qH(r, e) {
    return r.getAttribute ? r.getAttribute(e) : r[e];
  }
  function KH(r) {
    return r === "auto" ? He.domSupported ? "html" : "richText" : r || "html";
  }
  function Dx(r, e) {
    var t = ce(), n = [];
    return D(r, function(i) {
      var a = e(i);
      (t.get(a) || (n.push(a), t.set(a, []))).push(i);
    }), {
      keys: n,
      buckets: t
    };
  }
  function ER(r, e, t, n, i) {
    var a = e == null || e === "auto";
    if (n == null) return n;
    if (nt(n)) {
      var o = PC(t || 0, n, i);
      return Bt(o, a ? Math.max(Mi(t || 0), Mi(n)) : e);
    } else {
      if (ee(n)) return i < 1 ? t : n;
      for (var s = [], l = t, u = n, c = Math.max(l ? l.length : 0, u.length), h = 0; h < c; ++h) {
        var f = r.getDimensionInfo(h);
        if (f && f.type === "ordinal") s[h] = (i < 1 && l ? l : u)[h];
        else {
          var d = l && l[h] ? l[h] : 0, p = u[h], o = PC(d, p, i);
          s[h] = Bt(o, a ? Math.max(Mi(d), Mi(p)) : e);
        }
      }
      return s;
    }
  }
  var ZH = ".", ko = "___EC__COMPONENT__CONTAINER___", NR = "___EC__EXTENDED_CLASS___";
  function Di(r) {
    var e = {
      main: "",
      sub: ""
    };
    if (r) {
      var t = r.split(ZH);
      e.main = t[0] || "", e.sub = t[1] || "";
    }
    return e;
  }
  function jH(r) {
    Yr(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(r), 'componentType "' + r + '" illegal');
  }
  function QH(r) {
    return !!(r && r[NR]);
  }
  function a1(r, e) {
    r.$constructor = r, r.extend = function(t) {
      var n = this, i;
      return JH(n) ? i = function(a) {
        G(o, a);
        function o() {
          return a.apply(this, arguments) || this;
        }
        return o;
      }(n) : (i = function() {
        (t.$constructor || n).apply(this, arguments);
      }, iU(i, this)), H(i.prototype, t), i[NR] = true, i.extend = this.extend, i.superCall = r6, i.superApply = n6, i.superClass = n, i;
    };
  }
  function JH(r) {
    return ge(r) && /^class\s/.test(Function.prototype.toString.call(r));
  }
  function OR(r, e) {
    r.extend = e.extend;
  }
  var e6 = Math.round(Math.random() * 10);
  function t6(r) {
    var e = [
      "__\0is_clz",
      e6++
    ].join("_");
    r.prototype[e] = true, r.isInstance = function(t) {
      return !!(t && t[e]);
    };
  }
  function r6(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++) t[n - 2] = arguments[n];
    return this.superClass.prototype[e].apply(r, t);
  }
  function n6(r, e, t) {
    return this.superClass.prototype[e].apply(r, t);
  }
  function Zv(r) {
    var e = {};
    r.registerClass = function(n) {
      var i = n.type || n.prototype.type;
      if (i) {
        jH(i), n.prototype.type = i;
        var a = Di(i);
        if (!a.sub) e[a.main] = n;
        else if (a.sub !== ko) {
          var o = t(a);
          o[a.sub] = n;
        }
      }
      return n;
    }, r.getClass = function(n, i, a) {
      var o = e[n];
      if (o && o[ko] && (o = i ? o[i] : null), a && !o) throw new Error(i ? "Component " + n + "." + (i || "") + " is used but not imported." : n + ".type should be specified.");
      return o;
    }, r.getClassesByMainType = function(n) {
      var i = Di(n), a = [], o = e[i.main];
      return o && o[ko] ? D(o, function(s, l) {
        l !== ko && a.push(s);
      }) : a.push(o), a;
    }, r.hasClass = function(n) {
      var i = Di(n);
      return !!e[i.main];
    }, r.getAllClassMainTypes = function() {
      var n = [];
      return D(e, function(i, a) {
        n.push(a);
      }), n;
    }, r.hasSubTypes = function(n) {
      var i = Di(n), a = e[i.main];
      return a && a[ko];
    };
    function t(n) {
      var i = e[n.main];
      return (!i || !i[ko]) && (i = e[n.main] = {}, i[ko] = true), i;
    }
  }
  function Vs(r, e) {
    for (var t = 0; t < r.length; t++) r[t][1] || (r[t][1] = r[t][0]);
    return e = e || false, function(n, i, a) {
      for (var o = {}, s = 0; s < r.length; s++) {
        var l = r[s][1];
        if (!(i && Be(i, l) >= 0 || a && Be(a, l) < 0)) {
          var u = n.getShallow(l, e);
          u != null && (o[r[s][0]] = u);
        }
      }
      return o;
    };
  }
  var i6 = [
    [
      "fill",
      "color"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "opacity"
    ],
    [
      "shadowColor"
    ]
  ], a6 = Vs(i6), o6 = function() {
    function r() {
    }
    return r.prototype.getAreaStyle = function(e, t) {
      return a6(this, e, t);
    }, r;
  }(), Px = new df(50);
  function s6(r) {
    if (typeof r == "string") {
      var e = Px.get(r);
      return e && e.image;
    } else return r;
  }
  function o1(r, e, t, n, i) {
    if (r) if (typeof r == "string") {
      if (e && e.__zrImageSrc === r || !t) return e;
      var a = Px.get(r), o = {
        hostEl: t,
        cb: n,
        cbPayload: i
      };
      return a ? (e = a.image, !jv(e) && a.pending.push(o)) : (e = so.loadImage(r, LC, LC), e.__zrImageSrc = r, Px.put(r, e.__cachedImgObj = {
        image: e,
        pending: [
          o
        ]
      })), e;
    } else return r;
    else return e;
  }
  function LC() {
    var r = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;
    for (var e = 0; e < r.pending.length; e++) {
      var t = r.pending[e], n = t.cb;
      n && n(this, t.cbPayload), t.hostEl.dirty();
    }
    r.pending.length = 0;
  }
  function jv(r) {
    return r && r.width && r.height;
  }
  var pm = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
  function l6(r, e, t, n, i, a) {
    if (!t) {
      r.text = "", r.isTruncated = false;
      return;
    }
    var o = (e + "").split(`
`);
    a = FR(t, n, i, a);
    for (var s = false, l = {}, u = 0, c = o.length; u < c; u++) BR(l, o[u], a), o[u] = l.textLine, s = s || l.isTruncated;
    r.text = o.join(`
`), r.isTruncated = s;
  }
  function FR(r, e, t, n) {
    n = n || {};
    var i = H({}, n);
    i.font = e, t = Pe(t, "..."), i.maxIterations = Pe(n.maxIterations, 2);
    var a = i.minChar = Pe(n.minChar, 0);
    i.cnCharWidth = gn("\u56FD", e);
    var o = i.ascCharWidth = gn("a", e);
    i.placeholder = Pe(n.placeholder, "");
    for (var s = r = Math.max(0, r - 1), l = 0; l < a && s >= o; l++) s -= o;
    var u = gn(t, e);
    return u > s && (t = "", u = 0), s = r - u, i.ellipsis = t, i.ellipsisWidth = u, i.contentWidth = s, i.containerWidth = r, i;
  }
  function BR(r, e, t) {
    var n = t.containerWidth, i = t.font, a = t.contentWidth;
    if (!n) {
      r.textLine = "", r.isTruncated = false;
      return;
    }
    var o = gn(e, i);
    if (o <= n) {
      r.textLine = e, r.isTruncated = false;
      return;
    }
    for (var s = 0; ; s++) {
      if (o <= a || s >= t.maxIterations) {
        e += t.ellipsis;
        break;
      }
      var l = s === 0 ? u6(e, a, t.ascCharWidth, t.cnCharWidth) : o > 0 ? Math.floor(e.length * a / o) : 0;
      e = e.substr(0, l), o = gn(e, i);
    }
    e === "" && (e = t.placeholder), r.textLine = e, r.isTruncated = true;
  }
  function u6(r, e, t, n) {
    for (var i = 0, a = 0, o = r.length; a < o && i < e; a++) {
      var s = r.charCodeAt(a);
      i += 0 <= s && s <= 127 ? t : n;
    }
    return a;
  }
  function c6(r, e) {
    r != null && (r += "");
    var t = e.overflow, n = e.padding, i = e.font, a = t === "truncate", o = qv(i), s = Pe(e.lineHeight, o), l = !!e.backgroundColor, u = e.lineOverflow === "truncate", c = false, h = e.width, f;
    h != null && (t === "break" || t === "breakAll") ? f = r ? zR(r, e.font, h, t === "breakAll", 0).lines : [] : f = r ? r.split(`
`) : [];
    var d = f.length * s, p = Pe(e.height, d);
    if (d > p && u) {
      var v = Math.floor(p / s);
      c = c || f.length > v, f = f.slice(0, v);
    }
    if (r && a && h != null) for (var g = FR(h, i, e.ellipsis, {
      minChar: e.truncateMinChar,
      placeholder: e.placeholder
    }), m = {}, y = 0; y < f.length; y++) BR(m, f[y], g), f[y] = m.textLine, c = c || m.isTruncated;
    for (var x = p, _ = 0, y = 0; y < f.length; y++) _ = Math.max(gn(f[y], i), _);
    h == null && (h = _);
    var S = _;
    return n && (x += n[0] + n[2], S += n[1] + n[3], h += n[1] + n[3]), l && (S = h), {
      lines: f,
      height: p,
      outerWidth: S,
      outerHeight: x,
      lineHeight: s,
      calculatedLineHeight: o,
      contentWidth: _,
      contentHeight: d,
      width: h,
      isTruncated: c
    };
  }
  var h6 = /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }(), RC = /* @__PURE__ */ function() {
    function r(e) {
      this.tokens = [], e && (this.tokens = e);
    }
    return r;
  }(), f6 = /* @__PURE__ */ function() {
    function r() {
      this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = false;
    }
    return r;
  }();
  function d6(r, e) {
    var t = new f6();
    if (r != null && (r += ""), !r) return t;
    for (var n = e.width, i = e.height, a = e.overflow, o = (a === "break" || a === "breakAll") && n != null ? {
      width: n,
      accumWidth: 0,
      breakAll: a === "breakAll"
    } : null, s = pm.lastIndex = 0, l; (l = pm.exec(r)) != null; ) {
      var u = l.index;
      u > s && vm(t, r.substring(s, u), e, o), vm(t, l[2], e, o, l[1]), s = pm.lastIndex;
    }
    s < r.length && vm(t, r.substring(s, r.length), e, o);
    var c = [], h = 0, f = 0, d = e.padding, p = a === "truncate", v = e.lineOverflow === "truncate", g = {};
    function m(F, B, V) {
      F.width = B, F.lineHeight = V, h += V, f = Math.max(f, B);
    }
    e: for (var y = 0; y < t.lines.length; y++) {
      for (var x = t.lines[y], _ = 0, S = 0, b = 0; b < x.tokens.length; b++) {
        var w = x.tokens[b], C = w.styleName && e.rich[w.styleName] || {}, T = w.textPadding = C.padding, A = T ? T[1] + T[3] : 0, M = w.font = C.font || e.font;
        w.contentHeight = qv(M);
        var E = Pe(C.height, w.contentHeight);
        if (w.innerHeight = E, T && (E += T[0] + T[2]), w.height = E, w.lineHeight = Li(C.lineHeight, e.lineHeight, E), w.align = C && C.align || e.align, w.verticalAlign = C && C.verticalAlign || "middle", v && i != null && h + w.lineHeight > i) {
          var k = t.lines.length;
          b > 0 ? (x.tokens = x.tokens.slice(0, b), m(x, S, _), t.lines = t.lines.slice(0, y + 1)) : t.lines = t.lines.slice(0, y), t.isTruncated = t.isTruncated || t.lines.length < k;
          break e;
        }
        var R = C.width, N = R == null || R === "auto";
        if (typeof R == "string" && R.charAt(R.length - 1) === "%") w.percentWidth = R, c.push(w), w.contentWidth = gn(w.text, M);
        else {
          if (N) {
            var I = C.backgroundColor, L = I && I.image;
            L && (L = s6(L), jv(L) && (w.width = Math.max(w.width, L.width * E / L.height)));
          }
          var P = p && n != null ? n - S : null;
          P != null && P < w.width ? !N || P < A ? (w.text = "", w.width = w.contentWidth = 0) : (l6(g, w.text, P - A, M, e.ellipsis, {
            minChar: e.truncateMinChar
          }), w.text = g.text, t.isTruncated = t.isTruncated || g.isTruncated, w.width = w.contentWidth = gn(w.text, M)) : w.contentWidth = gn(w.text, M);
        }
        w.width += A, S += w.width, C && (_ = Math.max(_, w.lineHeight));
      }
      m(x, S, _);
    }
    t.outerWidth = t.width = Pe(n, f), t.outerHeight = t.height = Pe(i, h), t.contentHeight = h, t.contentWidth = f, d && (t.outerWidth += d[1] + d[3], t.outerHeight += d[0] + d[2]);
    for (var y = 0; y < c.length; y++) {
      var w = c[y], O = w.percentWidth;
      w.width = parseInt(O, 10) / 100 * t.width;
    }
    return t;
  }
  function vm(r, e, t, n, i) {
    var a = e === "", o = i && t.rich[i] || {}, s = r.lines, l = o.font || t.font, u = false, c, h;
    if (n) {
      var f = o.padding, d = f ? f[1] + f[3] : 0;
      if (o.width != null && o.width !== "auto") {
        var p = si(o.width, n.width) + d;
        s.length > 0 && p + n.accumWidth > n.width && (c = e.split(`
`), u = true), n.accumWidth = p;
      } else {
        var v = zR(e, l, n.width, n.breakAll, n.accumWidth);
        n.accumWidth = v.accumWidth + d, h = v.linesWidths, c = v.lines;
      }
    } else c = e.split(`
`);
    for (var g = 0; g < c.length; g++) {
      var m = c[g], y = new h6();
      if (y.styleName = i, y.text = m, y.isLineHolder = !m && !a, typeof o.width == "number" ? y.width = o.width : y.width = h ? h[g] : gn(m, l), !g && !u) {
        var x = (s[s.length - 1] || (s[0] = new RC())).tokens, _ = x.length;
        _ === 1 && x[0].isLineHolder ? x[0] = y : (m || !_ || a) && x.push(y);
      } else s.push(new RC([
        y
      ]));
    }
  }
  function p6(r) {
    var e = r.charCodeAt(0);
    return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303;
  }
  var v6 = Fi(",&?/;] ".split(""), function(r, e) {
    return r[e] = true, r;
  }, {});
  function g6(r) {
    return p6(r) ? !!v6[r] : true;
  }
  function zR(r, e, t, n, i) {
    for (var a = [], o = [], s = "", l = "", u = 0, c = 0, h = 0; h < r.length; h++) {
      var f = r.charAt(h);
      if (f === `
`) {
        l && (s += l, c += u), a.push(s), o.push(c), s = "", l = "", u = 0, c = 0;
        continue;
      }
      var d = gn(f, e), p = n ? false : !g6(f);
      if (a.length ? c + d > t : i + c + d > t) {
        c ? (s || l) && (p ? (s || (s = l, l = "", u = 0, c = u), a.push(s), o.push(c - u), l += f, u += d, s = "", c = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(c), s = f, c = d)) : p ? (a.push(l), o.push(u), l = f, u = d) : (a.push(f), o.push(d));
        continue;
      }
      c += d, p ? (l += f, u += d) : (l && (s += l, l = "", u = 0), s += f);
    }
    return !a.length && !s && (s = r, l = "", u = 0), l && (s += l), s && (a.push(s), o.push(c)), a.length === 1 && (c += i), {
      accumWidth: c,
      lines: a,
      linesWidths: o
    };
  }
  var kx = "__zr_style_" + Math.round(Math.random() * 10), Ms = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    opacity: 1,
    blend: "source-over"
  }, Qv = {
    style: {
      shadowBlur: true,
      shadowOffsetX: true,
      shadowOffsetY: true,
      shadowColor: true,
      opacity: true
    }
  };
  Ms[kx] = true;
  var EC = [
    "z",
    "z2",
    "invisible"
  ], m6 = [
    "invisible"
  ], zn = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype._init = function(t) {
      for (var n = je(t), i = 0; i < n.length; i++) {
        var a = n[i];
        a === "style" ? this.useStyle(t[a]) : r.prototype.attrKV.call(this, a, t[a]);
      }
      this.style || this.useStyle({});
    }, e.prototype.beforeBrush = function() {
    }, e.prototype.afterBrush = function() {
    }, e.prototype.innerBeforeBrush = function() {
    }, e.prototype.innerAfterBrush = function() {
    }, e.prototype.shouldBePainted = function(t, n, i, a) {
      var o = this.transform;
      if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && y6(this, t, n) || o && !o[0] && !o[3]) return false;
      if (i && this.__clipPaths) {
        for (var s = 0; s < this.__clipPaths.length; ++s) if (this.__clipPaths[s].isZeroArea()) return false;
      }
      if (a && this.parent) for (var l = this.parent; l; ) {
        if (l.ignore) return false;
        l = l.parent;
      }
      return true;
    }, e.prototype.contain = function(t, n) {
      return this.rectContain(t, n);
    }, e.prototype.traverse = function(t, n) {
      t.call(n, this);
    }, e.prototype.rectContain = function(t, n) {
      var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
      return a.contain(i[0], i[1]);
    }, e.prototype.getPaintRect = function() {
      var t = this._paintRect;
      if (!this._paintRect || this.__dirty) {
        var n = this.transform, i = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
        t = this._paintRect || (this._paintRect = new Oe(0, 0, 0, 0)), n ? Oe.applyTransform(t, i, n) : t.copy(i), (o || s || l) && (t.width += o * 2 + Math.abs(s), t.height += o * 2 + Math.abs(l), t.x = Math.min(t.x, t.x + s - o), t.y = Math.min(t.y, t.y + l - o));
        var u = this.dirtyRectTolerance;
        t.isZero() || (t.x = Math.floor(t.x - u), t.y = Math.floor(t.y - u), t.width = Math.ceil(t.width + 1 + u * 2), t.height = Math.ceil(t.height + 1 + u * 2));
      }
      return t;
    }, e.prototype.setPrevPaintRect = function(t) {
      t ? (this._prevPaintRect = this._prevPaintRect || new Oe(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null;
    }, e.prototype.getPrevPaintRect = function() {
      return this._prevPaintRect;
    }, e.prototype.animateStyle = function(t) {
      return this.animate("style", t);
    }, e.prototype.updateDuringAnimation = function(t) {
      t === "style" ? this.dirtyStyle() : this.markRedraw();
    }, e.prototype.attrKV = function(t, n) {
      t !== "style" ? r.prototype.attrKV.call(this, t, n) : this.style ? this.setStyle(n) : this.useStyle(n);
    }, e.prototype.setStyle = function(t, n) {
      return typeof t == "string" ? this.style[t] = n : H(this.style, t), this.dirtyStyle(), this;
    }, e.prototype.dirtyStyle = function(t) {
      t || this.markRedraw(), this.__dirty |= fp, this._rect && (this._rect = null);
    }, e.prototype.dirty = function() {
      this.dirtyStyle();
    }, e.prototype.styleChanged = function() {
      return !!(this.__dirty & fp);
    }, e.prototype.styleUpdated = function() {
      this.__dirty &= -3;
    }, e.prototype.createStyle = function(t) {
      return Hv(Ms, t);
    }, e.prototype.useStyle = function(t) {
      t[kx] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle();
    }, e.prototype.isStyleObject = function(t) {
      return t[kx];
    }, e.prototype._innerSaveToNormal = function(t) {
      r.prototype._innerSaveToNormal.call(this, t);
      var n = this._normalState;
      t.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(t, n, EC);
    }, e.prototype._applyStateObj = function(t, n, i, a, o, s) {
      r.prototype._applyStateObj.call(this, t, n, i, a, o, s);
      var l = !(n && a), u;
      if (n && n.style ? o ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(u, n.style)) : l && (u = i.style), u) if (o) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l) for (var h = je(c), f = 0; f < h.length; f++) {
          var d = h[f];
          d in u && (u[d] = u[d], this.style[d] = c[d]);
        }
        for (var p = je(u), f = 0; f < p.length; f++) {
          var d = p[f];
          this.style[d] = this.style[d];
        }
        this._transitionState(t, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else this.useStyle(u);
      for (var v = this.__inHover ? m6 : EC, f = 0; f < v.length; f++) {
        var d = v[f];
        n && n[d] != null ? this[d] = n[d] : l && i[d] != null && (this[d] = i[d]);
      }
    }, e.prototype._mergeStates = function(t) {
      for (var n = r.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) {
        var o = t[a];
        o.style && (i = i || {}, this._mergeStyle(i, o.style));
      }
      return i && (n.style = i), n;
    }, e.prototype._mergeStyle = function(t, n) {
      return H(t, n), t;
    }, e.prototype.getAnimationStyleProps = function() {
      return Qv;
    }, e.initDefaultProps = function() {
      var t = e.prototype;
      t.type = "displayable", t.invisible = false, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = false, t.cursor = "pointer", t.rectHover = false, t.incremental = false, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = Ri | fp;
    }(), e;
  }(Kv), gm = new Oe(0, 0, 0, 0), mm = new Oe(0, 0, 0, 0);
  function y6(r, e, t) {
    return gm.copy(r.getBoundingRect()), r.transform && gm.applyTransform(r.transform), mm.width = e, mm.height = t, !gm.intersect(mm);
  }
  var en = Math.min, tn = Math.max, ym = Math.sin, xm = Math.cos, Lo = Math.PI * 2, Kf = Xs(), Zf = Xs(), jf = Xs();
  function Jv(r, e, t) {
    if (r.length !== 0) {
      for (var n = r[0], i = n[0], a = n[0], o = n[1], s = n[1], l = 1; l < r.length; l++) n = r[l], i = en(i, n[0]), a = tn(a, n[0]), o = en(o, n[1]), s = tn(s, n[1]);
      e[0] = i, e[1] = o, t[0] = a, t[1] = s;
    }
  }
  function NC(r, e, t, n, i, a) {
    i[0] = en(r, t), i[1] = en(e, n), a[0] = tn(r, t), a[1] = tn(e, n);
  }
  var OC = [], FC = [];
  function x6(r, e, t, n, i, a, o, s, l, u) {
    var c = iR, h = tr, f = c(r, t, i, o, OC);
    l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
    for (var d = 0; d < f; d++) {
      var p = h(r, t, i, o, OC[d]);
      l[0] = en(p, l[0]), u[0] = tn(p, u[0]);
    }
    f = c(e, n, a, s, FC);
    for (var d = 0; d < f; d++) {
      var v = h(e, n, a, s, FC[d]);
      l[1] = en(v, l[1]), u[1] = tn(v, u[1]);
    }
    l[0] = en(r, l[0]), u[0] = tn(r, u[0]), l[0] = en(o, l[0]), u[0] = tn(o, u[0]), l[1] = en(e, l[1]), u[1] = tn(e, u[1]), l[1] = en(s, l[1]), u[1] = tn(s, u[1]);
  }
  function _6(r, e, t, n, i, a, o, s) {
    var l = oR, u = dr, c = tn(en(l(r, t, i), 1), 0), h = tn(en(l(e, n, a), 1), 0), f = u(r, t, i, c), d = u(e, n, a, h);
    o[0] = en(r, i, f), o[1] = en(e, a, d), s[0] = tn(r, i, f), s[1] = tn(e, a, d);
  }
  function b6(r, e, t, n, i, a, o, s, l) {
    var u = Ya, c = Xa, h = Math.abs(i - a);
    if (h % Lo < 1e-4 && h > 1e-4) {
      s[0] = r - t, s[1] = e - n, l[0] = r + t, l[1] = e + n;
      return;
    }
    if (Kf[0] = xm(i) * t + r, Kf[1] = ym(i) * n + e, Zf[0] = xm(a) * t + r, Zf[1] = ym(a) * n + e, u(s, Kf, Zf), c(l, Kf, Zf), i = i % Lo, i < 0 && (i = i + Lo), a = a % Lo, a < 0 && (a = a + Lo), i > a && !o ? a += Lo : i < a && o && (i += Lo), o) {
      var f = a;
      a = i, i = f;
    }
    for (var d = 0; d < a; d += Math.PI / 2) d > i && (jf[0] = xm(d) * t + r, jf[1] = ym(d) * n + e, u(s, jf, s), c(l, jf, l));
  }
  var xt = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  }, Ro = [], Eo = [], pi = [], Ma = [], vi = [], gi = [], _m = Math.min, bm = Math.max, No = Math.cos, Oo = Math.sin, Xi = Math.abs, Lx = Math.PI, za = Lx * 2, Sm = typeof Float32Array < "u", Ju = [];
  function wm(r) {
    var e = Math.round(r / Lx * 1e8) / 1e8;
    return e % 2 * Lx;
  }
  function s1(r, e) {
    var t = wm(r[0]);
    t < 0 && (t += za);
    var n = t - r[0], i = r[1];
    i += n, !e && i - t >= za ? i = t + za : e && t - i >= za ? i = t - za : !e && t > i ? i = t + (za - wm(t - i)) : e && t < i && (i = t - (za - wm(i - t))), r[0] = t, r[1] = i;
  }
  var $i = function() {
    function r(e) {
      this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = false), this._saveData && (this.data = []);
    }
    return r.prototype.increaseVersion = function() {
      this._version++;
    }, r.prototype.getVersion = function() {
      return this._version;
    }, r.prototype.setScale = function(e, t, n) {
      n = n || 0, n > 0 && (this._ux = Xi(n / $p / e) || 0, this._uy = Xi(n / $p / t) || 0);
    }, r.prototype.setDPR = function(e) {
      this.dpr = e;
    }, r.prototype.setContext = function(e) {
      this._ctx = e;
    }, r.prototype.getContext = function() {
      return this._ctx;
    }, r.prototype.beginPath = function() {
      return this._ctx && this._ctx.beginPath(), this.reset(), this;
    }, r.prototype.reset = function() {
      this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
    }, r.prototype.moveTo = function(e, t) {
      return this._drawPendingPt(), this.addData(xt.M, e, t), this._ctx && this._ctx.moveTo(e, t), this._x0 = e, this._y0 = t, this._xi = e, this._yi = t, this;
    }, r.prototype.lineTo = function(e, t) {
      var n = Xi(e - this._xi), i = Xi(t - this._yi), a = n > this._ux || i > this._uy;
      if (this.addData(xt.L, e, t), this._ctx && a && this._ctx.lineTo(e, t), a) this._xi = e, this._yi = t, this._pendingPtDist = 0;
      else {
        var o = n * n + i * i;
        o > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = t, this._pendingPtDist = o);
      }
      return this;
    }, r.prototype.bezierCurveTo = function(e, t, n, i, a, o) {
      return this._drawPendingPt(), this.addData(xt.C, e, t, n, i, a, o), this._ctx && this._ctx.bezierCurveTo(e, t, n, i, a, o), this._xi = a, this._yi = o, this;
    }, r.prototype.quadraticCurveTo = function(e, t, n, i) {
      return this._drawPendingPt(), this.addData(xt.Q, e, t, n, i), this._ctx && this._ctx.quadraticCurveTo(e, t, n, i), this._xi = n, this._yi = i, this;
    }, r.prototype.arc = function(e, t, n, i, a, o) {
      this._drawPendingPt(), Ju[0] = i, Ju[1] = a, s1(Ju, o), i = Ju[0], a = Ju[1];
      var s = a - i;
      return this.addData(xt.A, e, t, n, n, i, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(e, t, n, i, a, o), this._xi = No(a) * n + e, this._yi = Oo(a) * n + t, this;
    }, r.prototype.arcTo = function(e, t, n, i, a) {
      return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, t, n, i, a), this;
    }, r.prototype.rect = function(e, t, n, i) {
      return this._drawPendingPt(), this._ctx && this._ctx.rect(e, t, n, i), this.addData(xt.R, e, t, n, i), this;
    }, r.prototype.closePath = function() {
      this._drawPendingPt(), this.addData(xt.Z);
      var e = this._ctx, t = this._x0, n = this._y0;
      return e && e.closePath(), this._xi = t, this._yi = n, this;
    }, r.prototype.fill = function(e) {
      e && e.fill(), this.toStatic();
    }, r.prototype.stroke = function(e) {
      e && e.stroke(), this.toStatic();
    }, r.prototype.len = function() {
      return this._len;
    }, r.prototype.setData = function(e) {
      var t = e.length;
      !(this.data && this.data.length === t) && Sm && (this.data = new Float32Array(t));
      for (var n = 0; n < t; n++) this.data[n] = e[n];
      this._len = t;
    }, r.prototype.appendPath = function(e) {
      e instanceof Array || (e = [
        e
      ]);
      for (var t = e.length, n = 0, i = this._len, a = 0; a < t; a++) n += e[a].len();
      Sm && this.data instanceof Float32Array && (this.data = new Float32Array(i + n));
      for (var a = 0; a < t; a++) for (var o = e[a].data, s = 0; s < o.length; s++) this.data[i++] = o[s];
      this._len = i;
    }, r.prototype.addData = function(e, t, n, i, a, o, s, l, u) {
      if (this._saveData) {
        var c = this.data;
        this._len + arguments.length > c.length && (this._expandData(), c = this.data);
        for (var h = 0; h < arguments.length; h++) c[this._len++] = arguments[h];
      }
    }, r.prototype._drawPendingPt = function() {
      this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
    }, r.prototype._expandData = function() {
      if (!(this.data instanceof Array)) {
        for (var e = [], t = 0; t < this._len; t++) e[t] = this.data[t];
        this.data = e;
      }
    }, r.prototype.toStatic = function() {
      if (this._saveData) {
        this._drawPendingPt();
        var e = this.data;
        e instanceof Array && (e.length = this._len, Sm && this._len > 11 && (this.data = new Float32Array(e)));
      }
    }, r.prototype.getBoundingRect = function() {
      pi[0] = pi[1] = vi[0] = vi[1] = Number.MAX_VALUE, Ma[0] = Ma[1] = gi[0] = gi[1] = -Number.MAX_VALUE;
      var e = this.data, t = 0, n = 0, i = 0, a = 0, o;
      for (o = 0; o < this._len; ) {
        var s = e[o++], l = o === 1;
        switch (l && (t = e[o], n = e[o + 1], i = t, a = n), s) {
          case xt.M:
            t = i = e[o++], n = a = e[o++], vi[0] = i, vi[1] = a, gi[0] = i, gi[1] = a;
            break;
          case xt.L:
            NC(t, n, e[o], e[o + 1], vi, gi), t = e[o++], n = e[o++];
            break;
          case xt.C:
            x6(t, n, e[o++], e[o++], e[o++], e[o++], e[o], e[o + 1], vi, gi), t = e[o++], n = e[o++];
            break;
          case xt.Q:
            _6(t, n, e[o++], e[o++], e[o], e[o + 1], vi, gi), t = e[o++], n = e[o++];
            break;
          case xt.A:
            var u = e[o++], c = e[o++], h = e[o++], f = e[o++], d = e[o++], p = e[o++] + d;
            o += 1;
            var v = !e[o++];
            l && (i = No(d) * h + u, a = Oo(d) * f + c), b6(u, c, h, f, d, p, v, vi, gi), t = No(p) * h + u, n = Oo(p) * f + c;
            break;
          case xt.R:
            i = t = e[o++], a = n = e[o++];
            var g = e[o++], m = e[o++];
            NC(i, a, i + g, a + m, vi, gi);
            break;
          case xt.Z:
            t = i, n = a;
            break;
        }
        Ya(pi, pi, vi), Xa(Ma, Ma, gi);
      }
      return o === 0 && (pi[0] = pi[1] = Ma[0] = Ma[1] = 0), new Oe(pi[0], pi[1], Ma[0] - pi[0], Ma[1] - pi[1]);
    }, r.prototype._calculateLength = function() {
      var e = this.data, t = this._len, n = this._ux, i = this._uy, a = 0, o = 0, s = 0, l = 0;
      this._pathSegLen || (this._pathSegLen = []);
      for (var u = this._pathSegLen, c = 0, h = 0, f = 0; f < t; ) {
        var d = e[f++], p = f === 1;
        p && (a = e[f], o = e[f + 1], s = a, l = o);
        var v = -1;
        switch (d) {
          case xt.M:
            a = s = e[f++], o = l = e[f++];
            break;
          case xt.L: {
            var g = e[f++], m = e[f++], y = g - a, x = m - o;
            (Xi(y) > n || Xi(x) > i || f === t - 1) && (v = Math.sqrt(y * y + x * x), a = g, o = m);
            break;
          }
          case xt.C: {
            var _ = e[f++], S = e[f++], g = e[f++], m = e[f++], b = e[f++], w = e[f++];
            v = BU(a, o, _, S, g, m, b, w, 10), a = b, o = w;
            break;
          }
          case xt.Q: {
            var _ = e[f++], S = e[f++], g = e[f++], m = e[f++];
            v = VU(a, o, _, S, g, m, 10), a = g, o = m;
            break;
          }
          case xt.A:
            var C = e[f++], T = e[f++], A = e[f++], M = e[f++], E = e[f++], k = e[f++], R = k + E;
            f += 1, p && (s = No(E) * A + C, l = Oo(E) * M + T), v = bm(A, M) * _m(za, Math.abs(k)), a = No(R) * A + C, o = Oo(R) * M + T;
            break;
          case xt.R: {
            s = a = e[f++], l = o = e[f++];
            var N = e[f++], I = e[f++];
            v = N * 2 + I * 2;
            break;
          }
          case xt.Z: {
            var y = s - a, x = l - o;
            v = Math.sqrt(y * y + x * x), a = s, o = l;
            break;
          }
        }
        v >= 0 && (u[h++] = v, c += v);
      }
      return this._pathLen = c, c;
    }, r.prototype.rebuildPath = function(e, t) {
      var n = this.data, i = this._ux, a = this._uy, o = this._len, s, l, u, c, h, f, d = t < 1, p, v, g = 0, m = 0, y, x = 0, _, S;
      if (!(d && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, v = this._pathLen, y = t * v, !y))) e: for (var b = 0; b < o; ) {
        var w = n[b++], C = b === 1;
        switch (C && (u = n[b], c = n[b + 1], s = u, l = c), w !== xt.L && x > 0 && (e.lineTo(_, S), x = 0), w) {
          case xt.M:
            s = u = n[b++], l = c = n[b++], e.moveTo(u, c);
            break;
          case xt.L: {
            h = n[b++], f = n[b++];
            var T = Xi(h - u), A = Xi(f - c);
            if (T > i || A > a) {
              if (d) {
                var M = p[m++];
                if (g + M > y) {
                  var E = (y - g) / M;
                  e.lineTo(u * (1 - E) + h * E, c * (1 - E) + f * E);
                  break e;
                }
                g += M;
              }
              e.lineTo(h, f), u = h, c = f, x = 0;
            } else {
              var k = T * T + A * A;
              k > x && (_ = h, S = f, x = k);
            }
            break;
          }
          case xt.C: {
            var R = n[b++], N = n[b++], I = n[b++], L = n[b++], P = n[b++], O = n[b++];
            if (d) {
              var M = p[m++];
              if (g + M > y) {
                var E = (y - g) / M;
                lo(u, R, I, P, E, Ro), lo(c, N, L, O, E, Eo), e.bezierCurveTo(Ro[1], Eo[1], Ro[2], Eo[2], Ro[3], Eo[3]);
                break e;
              }
              g += M;
            }
            e.bezierCurveTo(R, N, I, L, P, O), u = P, c = O;
            break;
          }
          case xt.Q: {
            var R = n[b++], N = n[b++], I = n[b++], L = n[b++];
            if (d) {
              var M = p[m++];
              if (g + M > y) {
                var E = (y - g) / M;
                bh(u, R, I, E, Ro), bh(c, N, L, E, Eo), e.quadraticCurveTo(Ro[1], Eo[1], Ro[2], Eo[2]);
                break e;
              }
              g += M;
            }
            e.quadraticCurveTo(R, N, I, L), u = I, c = L;
            break;
          }
          case xt.A:
            var F = n[b++], B = n[b++], V = n[b++], U = n[b++], Y = n[b++], q = n[b++], me = n[b++], Me = !n[b++], re = V > U ? V : U, J = Xi(V - U) > 1e-3, le = Y + q, te = false;
            if (d) {
              var M = p[m++];
              g + M > y && (le = Y + q * (y - g) / M, te = true), g += M;
            }
            if (J && e.ellipse ? e.ellipse(F, B, V, U, me, Y, le, Me) : e.arc(F, B, re, Y, le, Me), te) break e;
            C && (s = No(Y) * V + F, l = Oo(Y) * U + B), u = No(le) * V + F, c = Oo(le) * U + B;
            break;
          case xt.R:
            s = u = n[b], l = c = n[b + 1], h = n[b++], f = n[b++];
            var he = n[b++], Xe = n[b++];
            if (d) {
              var M = p[m++];
              if (g + M > y) {
                var Fe = y - g;
                e.moveTo(h, f), e.lineTo(h + _m(Fe, he), f), Fe -= he, Fe > 0 && e.lineTo(h + he, f + _m(Fe, Xe)), Fe -= Xe, Fe > 0 && e.lineTo(h + bm(he - Fe, 0), f + Xe), Fe -= he, Fe > 0 && e.lineTo(h, f + bm(Xe - Fe, 0));
                break e;
              }
              g += M;
            }
            e.rect(h, f, he, Xe);
            break;
          case xt.Z:
            if (d) {
              var M = p[m++];
              if (g + M > y) {
                var E = (y - g) / M;
                e.lineTo(u * (1 - E) + s * E, c * (1 - E) + l * E);
                break e;
              }
              g += M;
            }
            e.closePath(), u = s, c = l;
        }
      }
    }, r.prototype.clone = function() {
      var e = new r(), t = this.data;
      return e.data = t.slice ? t.slice() : Array.prototype.slice.call(t), e._len = this._len, e;
    }, r.CMD = xt, r.initDefaultProps = function() {
      var e = r.prototype;
      e._saveData = true, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
    }(), r;
  }();
  function Ga(r, e, t, n, i, a, o) {
    if (i === 0) return false;
    var s = i, l = 0, u = r;
    if (o > e + s && o > n + s || o < e - s && o < n - s || a > r + s && a > t + s || a < r - s && a < t - s) return false;
    if (r !== t) l = (e - n) / (r - t), u = (r * n - t * e) / (r - t);
    else return Math.abs(a - r) <= s / 2;
    var c = l * a - o + u, h = c * c / (l * l + 1);
    return h <= s / 2 * s / 2;
  }
  function S6(r, e, t, n, i, a, o, s, l, u, c) {
    if (l === 0) return false;
    var h = l;
    if (c > e + h && c > n + h && c > a + h && c > s + h || c < e - h && c < n - h && c < a - h && c < s - h || u > r + h && u > t + h && u > i + h && u > o + h || u < r - h && u < t - h && u < i - h && u < o - h) return false;
    var f = aR(r, e, t, n, i, a, o, s, u, c, null);
    return f <= h / 2;
  }
  function VR(r, e, t, n, i, a, o, s, l) {
    if (o === 0) return false;
    var u = o;
    if (l > e + u && l > n + u && l > a + u || l < e - u && l < n - u && l < a - u || s > r + u && s > t + u && s > i + u || s < r - u && s < t - u && s < i - u) return false;
    var c = sR(r, e, t, n, i, a, s, l, null);
    return c <= u / 2;
  }
  var BC = Math.PI * 2;
  function dn(r) {
    return r %= BC, r < 0 && (r += BC), r;
  }
  var ec = Math.PI * 2;
  function w6(r, e, t, n, i, a, o, s, l) {
    if (o === 0) return false;
    var u = o;
    s -= r, l -= e;
    var c = Math.sqrt(s * s + l * l);
    if (c - u > t || c + u < t) return false;
    if (Math.abs(n - i) % ec < 1e-4) return true;
    if (a) {
      var h = n;
      n = dn(i), i = dn(h);
    } else n = dn(n), i = dn(i);
    n > i && (i += ec);
    var f = Math.atan2(l, s);
    return f < 0 && (f += ec), f >= n && f <= i || f + ec >= n && f + ec <= i;
  }
  function ea(r, e, t, n, i, a) {
    if (a > e && a > n || a < e && a < n || n === e) return 0;
    var o = (a - e) / (n - e), s = n < e ? 1 : -1;
    (o === 1 || o === 0) && (s = n < e ? 0.5 : -0.5);
    var l = o * (t - r) + r;
    return l === i ? 1 / 0 : l > i ? s : 0;
  }
  var Da = $i.CMD, Fo = Math.PI * 2, C6 = 1e-4;
  function T6(r, e) {
    return Math.abs(r - e) < C6;
  }
  var Br = [
    -1,
    -1,
    -1
  ], Dn = [
    -1,
    -1
  ];
  function A6() {
    var r = Dn[0];
    Dn[0] = Dn[1], Dn[1] = r;
  }
  function I6(r, e, t, n, i, a, o, s, l, u) {
    if (u > e && u > n && u > a && u > s || u < e && u < n && u < a && u < s) return 0;
    var c = Fp(e, n, a, s, u, Br);
    if (c === 0) return 0;
    for (var h = 0, f = -1, d = void 0, p = void 0, v = 0; v < c; v++) {
      var g = Br[v], m = g === 0 || g === 1 ? 0.5 : 1, y = tr(r, t, i, o, g);
      y < l || (f < 0 && (f = iR(e, n, a, s, Dn), Dn[1] < Dn[0] && f > 1 && A6(), d = tr(e, n, a, s, Dn[0]), f > 1 && (p = tr(e, n, a, s, Dn[1]))), f === 2 ? g < Dn[0] ? h += d < e ? m : -m : g < Dn[1] ? h += p < d ? m : -m : h += s < p ? m : -m : g < Dn[0] ? h += d < e ? m : -m : h += s < d ? m : -m);
    }
    return h;
  }
  function M6(r, e, t, n, i, a, o, s) {
    if (s > e && s > n && s > a || s < e && s < n && s < a) return 0;
    var l = zU(e, n, a, s, Br);
    if (l === 0) return 0;
    var u = oR(e, n, a);
    if (u >= 0 && u <= 1) {
      for (var c = 0, h = dr(e, n, a, u), f = 0; f < l; f++) {
        var d = Br[f] === 0 || Br[f] === 1 ? 0.5 : 1, p = dr(r, t, i, Br[f]);
        p < o || (Br[f] < u ? c += h < e ? d : -d : c += a < h ? d : -d);
      }
      return c;
    } else {
      var d = Br[0] === 0 || Br[0] === 1 ? 0.5 : 1, p = dr(r, t, i, Br[0]);
      return p < o ? 0 : a < e ? d : -d;
    }
  }
  function D6(r, e, t, n, i, a, o, s) {
    if (s -= e, s > t || s < -t) return 0;
    var l = Math.sqrt(t * t - s * s);
    Br[0] = -l, Br[1] = l;
    var u = Math.abs(n - i);
    if (u < 1e-4) return 0;
    if (u >= Fo - 1e-4) {
      n = 0, i = Fo;
      var c = a ? 1 : -1;
      return o >= Br[0] + r && o <= Br[1] + r ? c : 0;
    }
    if (n > i) {
      var h = n;
      n = i, i = h;
    }
    n < 0 && (n += Fo, i += Fo);
    for (var f = 0, d = 0; d < 2; d++) {
      var p = Br[d];
      if (p + r > o) {
        var v = Math.atan2(s, p), c = a ? 1 : -1;
        v < 0 && (v = Fo + v), (v >= n && v <= i || v + Fo >= n && v + Fo <= i) && (v > Math.PI / 2 && v < Math.PI * 1.5 && (c = -c), f += c);
      }
    }
    return f;
  }
  function $R(r, e, t, n, i) {
    for (var a = r.data, o = r.len(), s = 0, l = 0, u = 0, c = 0, h = 0, f, d, p = 0; p < o; ) {
      var v = a[p++], g = p === 1;
      switch (v === Da.M && p > 1 && (t || (s += ea(l, u, c, h, n, i))), g && (l = a[p], u = a[p + 1], c = l, h = u), v) {
        case Da.M:
          c = a[p++], h = a[p++], l = c, u = h;
          break;
        case Da.L:
          if (t) {
            if (Ga(l, u, a[p], a[p + 1], e, n, i)) return true;
          } else s += ea(l, u, a[p], a[p + 1], n, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case Da.C:
          if (t) {
            if (S6(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], e, n, i)) return true;
          } else s += I6(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], n, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case Da.Q:
          if (t) {
            if (VR(l, u, a[p++], a[p++], a[p], a[p + 1], e, n, i)) return true;
          } else s += M6(l, u, a[p++], a[p++], a[p], a[p + 1], n, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case Da.A:
          var m = a[p++], y = a[p++], x = a[p++], _ = a[p++], S = a[p++], b = a[p++];
          p += 1;
          var w = !!(1 - a[p++]);
          f = Math.cos(S) * x + m, d = Math.sin(S) * _ + y, g ? (c = f, h = d) : s += ea(l, u, f, d, n, i);
          var C = (n - m) * _ / x + m;
          if (t) {
            if (w6(m, y, _, S, S + b, w, e, C, i)) return true;
          } else s += D6(m, y, _, S, S + b, w, C, i);
          l = Math.cos(S + b) * x + m, u = Math.sin(S + b) * _ + y;
          break;
        case Da.R:
          c = l = a[p++], h = u = a[p++];
          var T = a[p++], A = a[p++];
          if (f = c + T, d = h + A, t) {
            if (Ga(c, h, f, h, e, n, i) || Ga(f, h, f, d, e, n, i) || Ga(f, d, c, d, e, n, i) || Ga(c, d, c, h, e, n, i)) return true;
          } else s += ea(f, h, f, d, n, i), s += ea(c, d, c, h, n, i);
          break;
        case Da.Z:
          if (t) {
            if (Ga(l, u, c, h, e, n, i)) return true;
          } else s += ea(l, u, c, h, n, i);
          l = c, u = h;
          break;
      }
    }
    return !t && !T6(u, h) && (s += ea(l, u, c, h, n, i) || 0), s !== 0;
  }
  function P6(r, e, t) {
    return $R(r, 0, false, e, t);
  }
  function k6(r, e, t, n) {
    return $R(r, e, true, t, n);
  }
  var Wp = ye({
    fill: "#000",
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
  }, Ms), L6 = {
    style: ye({
      fill: true,
      stroke: true,
      strokePercent: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineDashOffset: true,
      lineWidth: true,
      miterLimit: true
    }, Qv.style)
  }, Cm = zi.concat([
    "invisible",
    "culling",
    "z",
    "z2",
    "zlevel",
    "parent"
  ]), Ue = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.update = function() {
      var t = this;
      r.prototype.update.call(this);
      var n = this.style;
      if (n.decal) {
        var i = this._decalEl = this._decalEl || new e();
        i.buildPath === e.prototype.buildPath && (i.buildPath = function(l) {
          t.buildPath(l, t.shape);
        }), i.silent = true;
        var a = i.style;
        for (var o in n) a[o] !== n[o] && (a[o] = n[o]);
        a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
        for (var s = 0; s < Cm.length; ++s) i[Cm[s]] = this[Cm[s]];
        i.__dirty |= Ri;
      } else this._decalEl && (this._decalEl = null);
    }, e.prototype.getDecalElement = function() {
      return this._decalEl;
    }, e.prototype._init = function(t) {
      var n = je(t);
      this.shape = this.getDefaultShape();
      var i = this.getDefaultStyle();
      i && this.useStyle(i);
      for (var a = 0; a < n.length; a++) {
        var o = n[a], s = t[o];
        o === "style" ? this.style ? H(this.style, s) : this.useStyle(s) : o === "shape" ? H(this.shape, s) : r.prototype.attrKV.call(this, o, s);
      }
      this.style || this.useStyle({});
    }, e.prototype.getDefaultStyle = function() {
      return null;
    }, e.prototype.getDefaultShape = function() {
      return {};
    }, e.prototype.canBeInsideText = function() {
      return this.hasFill();
    }, e.prototype.getInsideTextFill = function() {
      var t = this.style.fill;
      if (t !== "none") {
        if (ee(t)) {
          var n = zp(t, 0);
          return n > 0.5 ? Ax : n > 0.2 ? pH : Ix;
        } else if (t) return Ix;
      }
      return Ax;
    }, e.prototype.getInsideTextStroke = function(t) {
      var n = this.style.fill;
      if (ee(n)) {
        var i = this.__zr, a = !!(i && i.isDarkMode()), o = zp(t, 0) < Tx;
        if (a === o) return n;
      }
    }, e.prototype.buildPath = function(t, n, i) {
    }, e.prototype.pathUpdated = function() {
      this.__dirty &= -5;
    }, e.prototype.getUpdatedPathProxy = function(t) {
      return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path;
    }, e.prototype.createPathProxy = function() {
      this.path = new $i(false);
    }, e.prototype.hasStroke = function() {
      var t = this.style, n = t.stroke;
      return !(n == null || n === "none" || !(t.lineWidth > 0));
    }, e.prototype.hasFill = function() {
      var t = this.style, n = t.fill;
      return n != null && n !== "none";
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect, n = this.style, i = !t;
      if (i) {
        var a = false;
        this.path || (a = true, this.createPathProxy());
        var o = this.path;
        (a || this.__dirty & Dc) && (o.beginPath(), this.buildPath(o, this.shape, false), this.pathUpdated()), t = o.getBoundingRect();
      }
      if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) {
        var s = this._rectStroke || (this._rectStroke = t.clone());
        if (this.__dirty || i) {
          s.copy(t);
          var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
          if (!this.hasFill()) {
            var c = this.strokeContainThreshold;
            u = Math.max(u, c ?? 4);
          }
          l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
        }
        return s;
      }
      return t;
    }, e.prototype.contain = function(t, n) {
      var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect(), o = this.style;
      if (t = i[0], n = i[1], a.contain(t, n)) {
        var s = this.path;
        if (this.hasStroke()) {
          var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
          if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), k6(s, l / u, t, n))) return true;
        }
        if (this.hasFill()) return P6(s, t, n);
      }
      return false;
    }, e.prototype.dirtyShape = function() {
      this.__dirty |= Dc, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
    }, e.prototype.dirty = function() {
      this.dirtyStyle(), this.dirtyShape();
    }, e.prototype.animateShape = function(t) {
      return this.animate("shape", t);
    }, e.prototype.updateDuringAnimation = function(t) {
      t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw();
    }, e.prototype.attrKV = function(t, n) {
      t === "shape" ? this.setShape(n) : r.prototype.attrKV.call(this, t, n);
    }, e.prototype.setShape = function(t, n) {
      var i = this.shape;
      return i || (i = this.shape = {}), typeof t == "string" ? i[t] = n : H(i, t), this.dirtyShape(), this;
    }, e.prototype.shapeChanged = function() {
      return !!(this.__dirty & Dc);
    }, e.prototype.createStyle = function(t) {
      return Hv(Wp, t);
    }, e.prototype._innerSaveToNormal = function(t) {
      r.prototype._innerSaveToNormal.call(this, t);
      var n = this._normalState;
      t.shape && !n.shape && (n.shape = H({}, this.shape));
    }, e.prototype._applyStateObj = function(t, n, i, a, o, s) {
      r.prototype._applyStateObj.call(this, t, n, i, a, o, s);
      var l = !(n && a), u;
      if (n && n.shape ? o ? a ? u = n.shape : (u = H({}, i.shape), H(u, n.shape)) : (u = H({}, a ? this.shape : i.shape), H(u, n.shape)) : l && (u = i.shape), u) if (o) {
        this.shape = H({}, this.shape);
        for (var c = {}, h = je(u), f = 0; f < h.length; f++) {
          var d = h[f];
          typeof u[d] == "object" ? this.shape[d] = u[d] : c[d] = u[d];
        }
        this._transitionState(t, {
          shape: c
        }, s);
      } else this.shape = u, this.dirtyShape();
    }, e.prototype._mergeStates = function(t) {
      for (var n = r.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) {
        var o = t[a];
        o.shape && (i = i || {}, this._mergeStyle(i, o.shape));
      }
      return i && (n.shape = i), n;
    }, e.prototype.getAnimationStyleProps = function() {
      return L6;
    }, e.prototype.isZeroArea = function() {
      return false;
    }, e.extend = function(t) {
      var n = function(a) {
        G(o, a);
        function o(s) {
          var l = a.call(this, s) || this;
          return t.init && t.init.call(l, s), l;
        }
        return o.prototype.getDefaultStyle = function() {
          return be(t.style);
        }, o.prototype.getDefaultShape = function() {
          return be(t.shape);
        }, o;
      }(e);
      for (var i in t) typeof t[i] == "function" && (n.prototype[i] = t[i]);
      return n;
    }, e.initDefaultProps = function() {
      var t = e.prototype;
      t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = false, t.autoBatch = false, t.__dirty = Ri | fp | Dc;
    }(), e;
  }(zn), R6 = ye({
    strokeFirst: true,
    font: oo,
    x: 0,
    y: 0,
    textAlign: "left",
    textBaseline: "top",
    miterLimit: 2
  }, Wp), lu = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.hasStroke = function() {
      var t = this.style, n = t.stroke;
      return n != null && n !== "none" && t.lineWidth > 0;
    }, e.prototype.hasFill = function() {
      var t = this.style, n = t.fill;
      return n != null && n !== "none";
    }, e.prototype.createStyle = function(t) {
      return Hv(R6, t);
    }, e.prototype.setBoundingRect = function(t) {
      this._rect = t;
    }, e.prototype.getBoundingRect = function() {
      var t = this.style;
      if (!this._rect) {
        var n = t.text;
        n != null ? n += "" : n = "";
        var i = pf(n, t.font, t.textAlign, t.textBaseline);
        if (i.x += t.x || 0, i.y += t.y || 0, this.hasStroke()) {
          var a = t.lineWidth;
          i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a;
        }
        this._rect = i;
      }
      return this._rect;
    }, e.initDefaultProps = function() {
      var t = e.prototype;
      t.dirtyRectTolerance = 10;
    }(), e;
  }(zn);
  lu.prototype.type = "tspan";
  var E6 = ye({
    x: 0,
    y: 0
  }, Ms), N6 = {
    style: ye({
      x: true,
      y: true,
      width: true,
      height: true,
      sx: true,
      sy: true,
      sWidth: true,
      sHeight: true
    }, Qv.style)
  };
  function O6(r) {
    return !!(r && typeof r != "string" && r.width && r.height);
  }
  var mr = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.createStyle = function(t) {
      return Hv(E6, t);
    }, e.prototype._getSize = function(t) {
      var n = this.style, i = n[t];
      if (i != null) return i;
      var a = O6(n.image) ? n.image : this.__image;
      if (!a) return 0;
      var o = t === "width" ? "height" : "width", s = n[o];
      return s == null ? a[t] : a[t] / a[o] * s;
    }, e.prototype.getWidth = function() {
      return this._getSize("width");
    }, e.prototype.getHeight = function() {
      return this._getSize("height");
    }, e.prototype.getAnimationStyleProps = function() {
      return N6;
    }, e.prototype.getBoundingRect = function() {
      var t = this.style;
      return this._rect || (this._rect = new Oe(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect;
    }, e;
  }(zn);
  mr.prototype.type = "image";
  function F6(r, e) {
    var t = e.x, n = e.y, i = e.width, a = e.height, o = e.r, s, l, u, c;
    i < 0 && (t = t + i, i = -i), a < 0 && (n = n + a, a = -a), typeof o == "number" ? s = l = u = c = o : o instanceof Array ? o.length === 1 ? s = l = u = c = o[0] : o.length === 2 ? (s = u = o[0], l = c = o[1]) : o.length === 3 ? (s = o[0], l = c = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], c = o[3]) : s = l = u = c = 0;
    var h;
    s + l > i && (h = s + l, s *= i / h, l *= i / h), u + c > i && (h = u + c, u *= i / h, c *= i / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), s + c > a && (h = s + c, s *= a / h, c *= a / h), r.moveTo(t + s, n), r.lineTo(t + i - l, n), l !== 0 && r.arc(t + i - l, n + l, l, -Math.PI / 2, 0), r.lineTo(t + i, n + a - u), u !== 0 && r.arc(t + i - u, n + a - u, u, 0, Math.PI / 2), r.lineTo(t + c, n + a), c !== 0 && r.arc(t + c, n + a - c, c, Math.PI / 2, Math.PI), r.lineTo(t, n + s), s !== 0 && r.arc(t + s, n + s, s, Math.PI, Math.PI * 1.5);
  }
  var ql = Math.round;
  function GR(r, e, t) {
    if (e) {
      var n = e.x1, i = e.x2, a = e.y1, o = e.y2;
      r.x1 = n, r.x2 = i, r.y1 = a, r.y2 = o;
      var s = t && t.lineWidth;
      return s && (ql(n * 2) === ql(i * 2) && (r.x1 = r.x2 = gs(n, s, true)), ql(a * 2) === ql(o * 2) && (r.y1 = r.y2 = gs(a, s, true))), r;
    }
  }
  function WR(r, e, t) {
    if (e) {
      var n = e.x, i = e.y, a = e.width, o = e.height;
      r.x = n, r.y = i, r.width = a, r.height = o;
      var s = t && t.lineWidth;
      return s && (r.x = gs(n, s, true), r.y = gs(i, s, true), r.width = Math.max(gs(n + a, s, false) - r.x, a === 0 ? 0 : 1), r.height = Math.max(gs(i + o, s, false) - r.y, o === 0 ? 0 : 1)), r;
    }
  }
  function gs(r, e, t) {
    if (!e) return r;
    var n = ql(r * 2);
    return (n + ql(e)) % 2 === 0 ? n / 2 : (n + (t ? 1 : -1)) / 2;
  }
  var B6 = /* @__PURE__ */ function() {
    function r() {
      this.x = 0, this.y = 0, this.width = 0, this.height = 0;
    }
    return r;
  }(), z6 = {}, et = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new B6();
    }, e.prototype.buildPath = function(t, n) {
      var i, a, o, s;
      if (this.subPixelOptimize) {
        var l = WR(z6, n, this.style);
        i = l.x, a = l.y, o = l.width, s = l.height, l.r = n.r, n = l;
      } else i = n.x, a = n.y, o = n.width, s = n.height;
      n.r ? F6(t, n) : t.rect(i, a, o, s);
    }, e.prototype.isZeroArea = function() {
      return !this.shape.width || !this.shape.height;
    }, e;
  }(Ue);
  et.prototype.type = "rect";
  var zC = {
    fill: "#000"
  }, VC = 2, V6 = {
    style: ye({
      fill: true,
      stroke: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineWidth: true,
      fontSize: true,
      lineHeight: true,
      width: true,
      height: true,
      textShadowColor: true,
      textShadowBlur: true,
      textShadowOffsetX: true,
      textShadowOffsetY: true,
      backgroundColor: true,
      padding: true,
      borderColor: true,
      borderWidth: true,
      borderRadius: true
    }, Qv.style)
  }, rt = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this) || this;
      return n.type = "text", n._children = [], n._defaultStyle = zC, n.attr(t), n;
    }
    return e.prototype.childrenRef = function() {
      return this._children;
    }, e.prototype.update = function() {
      r.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
      for (var t = 0; t < this._children.length; t++) {
        var n = this._children[t];
        n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
      }
    }, e.prototype.updateTransform = function() {
      var t = this.innerTransformable;
      t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : r.prototype.updateTransform.call(this);
    }, e.prototype.getLocalTransform = function(t) {
      var n = this.innerTransformable;
      return n ? n.getLocalTransform(t) : r.prototype.getLocalTransform.call(this, t);
    }, e.prototype.getComputedTransform = function() {
      return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(true)), r.prototype.getComputedTransform.call(this);
    }, e.prototype._updateSubTexts = function() {
      this._childCursor = 0, W6(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
    }, e.prototype.addSelfToZr = function(t) {
      r.prototype.addSelfToZr.call(this, t);
      for (var n = 0; n < this._children.length; n++) this._children[n].__zr = t;
    }, e.prototype.removeSelfFromZr = function(t) {
      r.prototype.removeSelfFromZr.call(this, t);
      for (var n = 0; n < this._children.length; n++) this._children[n].__zr = null;
    }, e.prototype.getBoundingRect = function() {
      if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
        for (var t = new Oe(0, 0, 0, 0), n = this._children, i = [], a = null, o = 0; o < n.length; o++) {
          var s = n[o], l = s.getBoundingRect(), u = s.getLocalTransform(i);
          u ? (t.copy(l), t.applyTransform(u), a = a || t.clone(), a.union(t)) : (a = a || l.clone(), a.union(l));
        }
        this._rect = a || t;
      }
      return this._rect;
    }, e.prototype.setDefaultTextStyle = function(t) {
      this._defaultStyle = t || zC;
    }, e.prototype.setTextContent = function(t) {
    }, e.prototype._mergeStyle = function(t, n) {
      if (!n) return t;
      var i = n.rich, a = t.rich || i && {};
      return H(t, n), i && a ? (this._mergeRich(a, i), t.rich = a) : a && (t.rich = a), t;
    }, e.prototype._mergeRich = function(t, n) {
      for (var i = je(n), a = 0; a < i.length; a++) {
        var o = i[a];
        t[o] = t[o] || {}, H(t[o], n[o]);
      }
    }, e.prototype.getAnimationStyleProps = function() {
      return V6;
    }, e.prototype._getOrCreateChild = function(t) {
      var n = this._children[this._childCursor];
      return (!n || !(n instanceof t)) && (n = new t()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
    }, e.prototype._updatePlainTexts = function() {
      var t = this.style, n = t.font || oo, i = t.padding, a = XC(t), o = c6(a, t), s = Tm(t), l = !!t.backgroundColor, u = o.outerHeight, c = o.outerWidth, h = o.contentWidth, f = o.lines, d = o.lineHeight, p = this._defaultStyle;
      this.isTruncated = !!o.isTruncated;
      var v = t.x || 0, g = t.y || 0, m = t.align || p.align || "left", y = t.verticalAlign || p.verticalAlign || "top", x = v, _ = Bl(g, o.contentHeight, y);
      if (s || i) {
        var S = kc(v, c, m), b = Bl(g, u, y);
        s && this._renderBackground(t, t, S, b, c, u);
      }
      _ += d / 2, i && (x = YC(v, m, i), y === "top" ? _ += i[0] : y === "bottom" && (_ -= i[2]));
      for (var w = 0, C = false, T = HC("fill" in t ? t.fill : (C = true, p.fill)), A = UC("stroke" in t ? t.stroke : !l && (!p.autoStroke || C) ? (w = VC, p.stroke) : null), M = t.textShadowBlur > 0, E = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), k = o.calculatedLineHeight, R = 0; R < f.length; R++) {
        var N = this._getOrCreateChild(lu), I = N.createStyle();
        N.useStyle(I), I.text = f[R], I.x = x, I.y = _, I.textAlign = m, I.textBaseline = "middle", I.opacity = t.opacity, I.strokeFirst = true, M && (I.shadowBlur = t.textShadowBlur || 0, I.shadowColor = t.textShadowColor || "transparent", I.shadowOffsetX = t.textShadowOffsetX || 0, I.shadowOffsetY = t.textShadowOffsetY || 0), I.stroke = A, I.fill = T, A && (I.lineWidth = t.lineWidth || w, I.lineDash = t.lineDash, I.lineDashOffset = t.lineDashOffset || 0), I.font = n, GC(I, t), _ += d, E && N.setBoundingRect(new Oe(kc(I.x, h, I.textAlign), Bl(I.y, k, I.textBaseline), h, k));
      }
    }, e.prototype._updateRichTexts = function() {
      var t = this.style, n = XC(t), i = d6(n, t), a = i.width, o = i.outerWidth, s = i.outerHeight, l = t.padding, u = t.x || 0, c = t.y || 0, h = this._defaultStyle, f = t.align || h.align, d = t.verticalAlign || h.verticalAlign;
      this.isTruncated = !!i.isTruncated;
      var p = kc(u, o, f), v = Bl(c, s, d), g = p, m = v;
      l && (g += l[3], m += l[0]);
      var y = g + a;
      Tm(t) && this._renderBackground(t, t, p, v, o, s);
      for (var x = !!t.backgroundColor, _ = 0; _ < i.lines.length; _++) {
        for (var S = i.lines[_], b = S.tokens, w = b.length, C = S.lineHeight, T = S.width, A = 0, M = g, E = y, k = w - 1, R = void 0; A < w && (R = b[A], !R.align || R.align === "left"); ) this._placeToken(R, t, C, m, M, "left", x), T -= R.width, M += R.width, A++;
        for (; k >= 0 && (R = b[k], R.align === "right"); ) this._placeToken(R, t, C, m, E, "right", x), T -= R.width, E -= R.width, k--;
        for (M += (a - (M - g) - (y - E) - T) / 2; A <= k; ) R = b[A], this._placeToken(R, t, C, m, M + R.width / 2, "center", x), M += R.width, A++;
        m += C;
      }
    }, e.prototype._placeToken = function(t, n, i, a, o, s, l) {
      var u = n.rich[t.styleName] || {};
      u.text = t.text;
      var c = t.verticalAlign, h = a + i / 2;
      c === "top" ? h = a + t.height / 2 : c === "bottom" && (h = a + i - t.height / 2);
      var f = !t.isLineHolder && Tm(u);
      f && this._renderBackground(u, n, s === "right" ? o - t.width : s === "center" ? o - t.width / 2 : o, h - t.height / 2, t.width, t.height);
      var d = !!u.backgroundColor, p = t.textPadding;
      p && (o = YC(o, s, p), h -= t.height / 2 - p[0] - t.innerHeight / 2);
      var v = this._getOrCreateChild(lu), g = v.createStyle();
      v.useStyle(g);
      var m = this._defaultStyle, y = false, x = 0, _ = HC("fill" in u ? u.fill : "fill" in n ? n.fill : (y = true, m.fill)), S = UC("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !d && !l && (!m.autoStroke || y) ? (x = VC, m.stroke) : null), b = u.textShadowBlur > 0 || n.textShadowBlur > 0;
      g.text = t.text, g.x = o, g.y = h, b && (g.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, g.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", g.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, g.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), g.textAlign = s, g.textBaseline = "middle", g.font = t.font || oo, g.opacity = Li(u.opacity, n.opacity, 1), GC(g, u), S && (g.lineWidth = Li(u.lineWidth, n.lineWidth, x), g.lineDash = Pe(u.lineDash, n.lineDash), g.lineDashOffset = n.lineDashOffset || 0, g.stroke = S), _ && (g.fill = _);
      var w = t.contentWidth, C = t.contentHeight;
      v.setBoundingRect(new Oe(kc(g.x, w, g.textAlign), Bl(g.y, C, g.textBaseline), w, C));
    }, e.prototype._renderBackground = function(t, n, i, a, o, s) {
      var l = t.backgroundColor, u = t.borderWidth, c = t.borderColor, h = l && l.image, f = l && !h, d = t.borderRadius, p = this, v, g;
      if (f || t.lineHeight || u && c) {
        v = this._getOrCreateChild(et), v.useStyle(v.createStyle()), v.style.fill = null;
        var m = v.shape;
        m.x = i, m.y = a, m.width = o, m.height = s, m.r = d, v.dirtyShape();
      }
      if (f) {
        var y = v.style;
        y.fill = l || null, y.fillOpacity = Pe(t.fillOpacity, 1);
      } else if (h) {
        g = this._getOrCreateChild(mr), g.onload = function() {
          p.dirtyStyle();
        };
        var x = g.style;
        x.image = l.image, x.x = i, x.y = a, x.width = o, x.height = s;
      }
      if (u && c) {
        var y = v.style;
        y.lineWidth = u, y.stroke = c, y.strokeOpacity = Pe(t.strokeOpacity, 1), y.lineDash = t.borderDash, y.lineDashOffset = t.borderDashOffset || 0, v.strokeContainThreshold = 0, v.hasFill() && v.hasStroke() && (y.strokeFirst = true, y.lineWidth *= 2);
      }
      var _ = (v || g).style;
      _.shadowBlur = t.shadowBlur || 0, _.shadowColor = t.shadowColor || "transparent", _.shadowOffsetX = t.shadowOffsetX || 0, _.shadowOffsetY = t.shadowOffsetY || 0, _.opacity = Li(t.opacity, n.opacity, 1);
    }, e.makeFont = function(t) {
      var n = "";
      return HR(t) && (n = [
        t.fontStyle,
        t.fontWeight,
        UR(t.fontSize),
        t.fontFamily || "sans-serif"
      ].join(" ")), n && ei(n) || t.textFont || t.font;
    }, e;
  }(zn), $6 = {
    left: true,
    right: 1,
    center: 1
  }, G6 = {
    top: 1,
    bottom: 1,
    middle: 1
  }, $C = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily"
  ];
  function UR(r) {
    return typeof r == "string" && (r.indexOf("px") !== -1 || r.indexOf("rem") !== -1 || r.indexOf("em") !== -1) ? r : isNaN(+r) ? Wb + "px" : r + "px";
  }
  function GC(r, e) {
    for (var t = 0; t < $C.length; t++) {
      var n = $C[t], i = e[n];
      i != null && (r[n] = i);
    }
  }
  function HR(r) {
    return r.fontSize != null || r.fontFamily || r.fontWeight;
  }
  function W6(r) {
    return WC(r), D(r.rich, WC), r;
  }
  function WC(r) {
    if (r) {
      r.font = rt.makeFont(r);
      var e = r.align;
      e === "middle" && (e = "center"), r.align = e == null || $6[e] ? e : "left";
      var t = r.verticalAlign;
      t === "center" && (t = "middle"), r.verticalAlign = t == null || G6[t] ? t : "top";
      var n = r.padding;
      n && (r.padding = Kb(r.padding));
    }
  }
  function UC(r, e) {
    return r == null || e <= 0 || r === "transparent" || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
  }
  function HC(r) {
    return r == null || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
  }
  function YC(r, e, t) {
    return e === "right" ? r - t[1] : e === "center" ? r + t[3] / 2 - t[1] / 2 : r + t[3];
  }
  function XC(r) {
    var e = r.text;
    return e != null && (e += ""), e;
  }
  function Tm(r) {
    return !!(r.backgroundColor || r.lineHeight || r.borderWidth && r.borderColor);
  }
  var De = tt(), Rx = function(r, e, t, n) {
    if (n) {
      var i = De(n);
      i.dataIndex = t, i.dataType = e, i.seriesIndex = r, i.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
        var o = De(a);
        o.seriesIndex = r, o.dataIndex = t, o.dataType = e, o.ssrType = "chart";
      });
    }
  }, qC = 1, KC = {}, YR = tt(), l1 = tt(), u1 = 0, gf = 1, eg = 2, Xr = [
    "emphasis",
    "blur",
    "select"
  ], Ah = [
    "normal",
    "emphasis",
    "blur",
    "select"
  ], Lu = 10, U6 = 9, Ds = "highlight", mp = "downplay", Jc = "select", yp = "unselect", eh = "toggleSelect";
  function fl(r) {
    return r != null && r !== "none";
  }
  function tg(r, e, t) {
    r.onHoverStateChange && (r.hoverState || 0) !== t && r.onHoverStateChange(e), r.hoverState = t;
  }
  function XR(r) {
    tg(r, "emphasis", eg);
  }
  function qR(r) {
    r.hoverState === eg && tg(r, "normal", u1);
  }
  function c1(r) {
    tg(r, "blur", gf);
  }
  function KR(r) {
    r.hoverState === gf && tg(r, "normal", u1);
  }
  function H6(r) {
    r.selected = true;
  }
  function Y6(r) {
    r.selected = false;
  }
  function ZC(r, e, t) {
    e(r, t);
  }
  function Ca(r, e, t) {
    ZC(r, e, t), r.isGroup && r.traverse(function(n) {
      ZC(n, e, t);
    });
  }
  function Up(r, e) {
    switch (e) {
      case "emphasis":
        r.hoverState = eg;
        break;
      case "normal":
        r.hoverState = u1;
        break;
      case "blur":
        r.hoverState = gf;
        break;
      case "select":
        r.selected = true;
    }
  }
  function X6(r, e, t, n) {
    for (var i = r.style, a = {}, o = 0; o < e.length; o++) {
      var s = e[o], l = i[s];
      a[s] = l ?? (n && n[s]);
    }
    for (var o = 0; o < r.animators.length; o++) {
      var u = r.animators[o];
      u.__fromStateTransition && u.__fromStateTransition.indexOf(t) < 0 && u.targetName === "style" && u.saveTo(a, e);
    }
    return a;
  }
  function q6(r, e, t, n) {
    var i = t && Be(t, "select") >= 0, a = false;
    if (r instanceof Ue) {
      var o = YR(r), s = i && o.selectFill || o.normalFill, l = i && o.selectStroke || o.normalStroke;
      if (fl(s) || fl(l)) {
        n = n || {};
        var u = n.style || {};
        u.fill === "inherit" ? (a = true, n = H({}, n), u = H({}, u), u.fill = s) : !fl(u.fill) && fl(s) ? (a = true, n = H({}, n), u = H({}, u), u.fill = mx(s)) : !fl(u.stroke) && fl(l) && (a || (n = H({}, n), u = H({}, u)), u.stroke = mx(l)), n.style = u;
      }
    }
    if (n && n.z2 == null) {
      a || (n = H({}, n));
      var c = r.z2EmphasisLift;
      n.z2 = r.z2 + (c ?? Lu);
    }
    return n;
  }
  function K6(r, e, t) {
    if (t && t.z2 == null) {
      t = H({}, t);
      var n = r.z2SelectLift;
      t.z2 = r.z2 + (n ?? U6);
    }
    return t;
  }
  function Z6(r, e, t) {
    var n = Be(r.currentStates, e) >= 0, i = r.style.opacity, a = n ? null : X6(r, [
      "opacity"
    ], e, {
      opacity: 1
    });
    t = t || {};
    var o = t.style || {};
    return o.opacity == null && (t = H({}, t), o = H({
      opacity: n ? i : a.opacity * 0.1
    }, o), t.style = o), t;
  }
  function Am(r, e) {
    var t = this.states[r];
    if (this.style) {
      if (r === "emphasis") return q6(this, r, e, t);
      if (r === "blur") return Z6(this, r, t);
      if (r === "select") return K6(this, r, t);
    }
    return t;
  }
  function $s(r) {
    r.stateProxy = Am;
    var e = r.getTextContent(), t = r.getTextGuideLine();
    e && (e.stateProxy = Am), t && (t.stateProxy = Am);
  }
  function jC(r, e) {
    !JR(r, e) && !r.__highByOuter && Ca(r, XR);
  }
  function QC(r, e) {
    !JR(r, e) && !r.__highByOuter && Ca(r, qR);
  }
  function ga(r, e) {
    r.__highByOuter |= 1 << (e || 0), Ca(r, XR);
  }
  function ma(r, e) {
    !(r.__highByOuter &= ~(1 << (e || 0))) && Ca(r, qR);
  }
  function ZR(r) {
    Ca(r, c1);
  }
  function h1(r) {
    Ca(r, KR);
  }
  function jR(r) {
    Ca(r, H6);
  }
  function QR(r) {
    Ca(r, Y6);
  }
  function JR(r, e) {
    return r.__highDownSilentOnTouch && e.zrByTouch;
  }
  function eE(r) {
    var e = r.getModel(), t = [], n = [];
    e.eachComponent(function(i, a) {
      var o = l1(a), s = i === "series", l = s ? r.getViewOfSeriesModel(a) : r.getViewOfComponentModel(a);
      !s && n.push(l), o.isBlured && (l.group.traverse(function(u) {
        KR(u);
      }), s && t.push(a)), o.isBlured = false;
    }), D(n, function(i) {
      i && i.toggleBlurSeries && i.toggleBlurSeries(t, false, e);
    });
  }
  function Ex(r, e, t, n) {
    var i = n.getModel();
    t = t || "coordinateSystem";
    function a(u, c) {
      for (var h = 0; h < c.length; h++) {
        var f = u.getItemGraphicEl(c[h]);
        f && h1(f);
      }
    }
    if (r != null && !(!e || e === "none")) {
      var o = i.getSeriesByIndex(r), s = o.coordinateSystem;
      s && s.master && (s = s.master);
      var l = [];
      i.eachSeries(function(u) {
        var c = o === u, h = u.coordinateSystem;
        h && h.master && (h = h.master);
        var f = h && s ? h === s : c;
        if (!(t === "series" && !c || t === "coordinateSystem" && !f || e === "series" && c)) {
          var d = n.getViewOfSeriesModel(u);
          if (d.group.traverse(function(g) {
            g.__highByOuter && c && e === "self" || c1(g);
          }), Lr(e)) a(u.getData(), e);
          else if (_e(e)) for (var p = je(e), v = 0; v < p.length; v++) a(u.getData(p[v]), e[p[v]]);
          l.push(u), l1(u).isBlured = true;
        }
      }), i.eachComponent(function(u, c) {
        if (u !== "series") {
          var h = n.getViewOfComponentModel(c);
          h && h.toggleBlurSeries && h.toggleBlurSeries(l, true, i);
        }
      });
    }
  }
  function Nx(r, e, t) {
    if (!(r == null || e == null)) {
      var n = t.getModel().getComponent(r, e);
      if (n) {
        l1(n).isBlured = true;
        var i = t.getViewOfComponentModel(n);
        !i || !i.focusBlurEnabled || i.group.traverse(function(a) {
          c1(a);
        });
      }
    }
  }
  function j6(r, e, t) {
    var n = r.seriesIndex, i = r.getData(e.dataType);
    if (i) {
      var a = zs(i, e);
      a = (X(a) ? a[0] : a) || 0;
      var o = i.getItemGraphicEl(a);
      if (!o) for (var s = i.count(), l = 0; !o && l < s; ) o = i.getItemGraphicEl(l++);
      if (o) {
        var u = De(o);
        Ex(n, u.focus, u.blurScope, t);
      } else {
        var c = r.get([
          "emphasis",
          "focus"
        ]), h = r.get([
          "emphasis",
          "blurScope"
        ]);
        c != null && Ex(n, c, h, t);
      }
    }
  }
  function f1(r, e, t, n) {
    var i = {
      focusSelf: false,
      dispatchers: null
    };
    if (r == null || r === "series" || e == null || t == null) return i;
    var a = n.getModel().getComponent(r, e);
    if (!a) return i;
    var o = n.getViewOfComponentModel(a);
    if (!o || !o.findHighDownDispatchers) return i;
    for (var s = o.findHighDownDispatchers(t), l, u = 0; u < s.length; u++) if (De(s[u]).focus === "self") {
      l = true;
      break;
    }
    return {
      focusSelf: l,
      dispatchers: s
    };
  }
  function Q6(r, e, t) {
    var n = De(r), i = f1(n.componentMainType, n.componentIndex, n.componentHighDownName, t), a = i.dispatchers, o = i.focusSelf;
    a ? (o && Nx(n.componentMainType, n.componentIndex, t), D(a, function(s) {
      return jC(s, e);
    })) : (Ex(n.seriesIndex, n.focus, n.blurScope, t), n.focus === "self" && Nx(n.componentMainType, n.componentIndex, t), jC(r, e));
  }
  function J6(r, e, t) {
    eE(t);
    var n = De(r), i = f1(n.componentMainType, n.componentIndex, n.componentHighDownName, t).dispatchers;
    i ? D(i, function(a) {
      return QC(a, e);
    }) : QC(r, e);
  }
  function e8(r, e, t) {
    if (Fx(e)) {
      var n = e.dataType, i = r.getData(n), a = zs(i, e);
      X(a) || (a = [
        a
      ]), r[e.type === eh ? "toggleSelect" : e.type === Jc ? "select" : "unselect"](a, n);
    }
  }
  function JC(r) {
    var e = r.getAllData();
    D(e, function(t) {
      var n = t.data, i = t.type;
      n.eachItemGraphicEl(function(a, o) {
        r.isSelected(o, i) ? jR(a) : QR(a);
      });
    });
  }
  function t8(r) {
    var e = [];
    return r.eachSeries(function(t) {
      var n = t.getAllData();
      D(n, function(i) {
        i.data;
        var a = i.type, o = t.getSelectedDataIndices();
        if (o.length > 0) {
          var s = {
            dataIndex: o,
            seriesIndex: t.seriesIndex
          };
          a != null && (s.dataType = a), e.push(s);
        }
      });
    }), e;
  }
  function Ps(r, e, t) {
    ms(r, true), Ca(r, $s), Ox(r, e, t);
  }
  function r8(r) {
    ms(r, false);
  }
  function Nt(r, e, t, n) {
    n ? r8(r) : Ps(r, e, t);
  }
  function Ox(r, e, t) {
    var n = De(r);
    e != null ? (n.focus = e, n.blurScope = t) : n.focus && (n.focus = null);
  }
  var e2 = [
    "emphasis",
    "blur",
    "select"
  ], n8 = {
    itemStyle: "getItemStyle",
    lineStyle: "getLineStyle",
    areaStyle: "getAreaStyle"
  };
  function br(r, e, t, n) {
    t = t || "itemStyle";
    for (var i = 0; i < e2.length; i++) {
      var a = e2[i], o = e.getModel([
        a,
        t
      ]), s = r.ensureState(a);
      s.style = n ? n(o) : o[n8[t]]();
    }
  }
  function ms(r, e) {
    var t = e === false, n = r;
    r.highDownSilentOnTouch && (n.__highDownSilentOnTouch = r.highDownSilentOnTouch), (!t || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !t);
  }
  function Ih(r) {
    return !!(r && r.__highDownDispatcher);
  }
  function i8(r, e, t) {
    var n = De(r);
    n.componentMainType = e.mainType, n.componentIndex = e.componentIndex, n.componentHighDownName = t;
  }
  function a8(r) {
    var e = KC[r];
    return e == null && qC <= 32 && (e = KC[r] = qC++), e;
  }
  function Fx(r) {
    var e = r.type;
    return e === Jc || e === yp || e === eh;
  }
  function t2(r) {
    var e = r.type;
    return e === Ds || e === mp;
  }
  function o8(r) {
    var e = YR(r);
    e.normalFill = r.style.fill, e.normalStroke = r.style.stroke;
    var t = r.states.select || {};
    e.selectFill = t.style && t.style.fill || null, e.selectStroke = t.style && t.style.stroke || null;
  }
  var dl = $i.CMD, s8 = [
    [],
    [],
    []
  ], r2 = Math.sqrt, l8 = Math.atan2;
  function tE(r, e) {
    if (e) {
      var t = r.data, n = r.len(), i, a, o, s, l, u, c = dl.M, h = dl.C, f = dl.L, d = dl.R, p = dl.A, v = dl.Q;
      for (o = 0, s = 0; o < n; ) {
        switch (i = t[o++], s = o, a = 0, i) {
          case c:
            a = 1;
            break;
          case f:
            a = 1;
            break;
          case h:
            a = 3;
            break;
          case v:
            a = 2;
            break;
          case p:
            var g = e[4], m = e[5], y = r2(e[0] * e[0] + e[1] * e[1]), x = r2(e[2] * e[2] + e[3] * e[3]), _ = l8(-e[1] / x, e[0] / y);
            t[o] *= y, t[o++] += g, t[o] *= x, t[o++] += m, t[o++] *= y, t[o++] *= x, t[o++] += _, t[o++] += _, o += 2, s = o;
            break;
          case d:
            u[0] = t[o++], u[1] = t[o++], xr(u, u, e), t[s++] = u[0], t[s++] = u[1], u[0] += t[o++], u[1] += t[o++], xr(u, u, e), t[s++] = u[0], t[s++] = u[1];
        }
        for (l = 0; l < a; l++) {
          var S = s8[l];
          S[0] = t[o++], S[1] = t[o++], xr(S, S, e), t[s++] = S[0], t[s++] = S[1];
        }
      }
      r.increaseVersion();
    }
  }
  var Im = Math.sqrt, Qf = Math.sin, Jf = Math.cos, tc = Math.PI;
  function n2(r) {
    return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
  }
  function Bx(r, e) {
    return (r[0] * e[0] + r[1] * e[1]) / (n2(r) * n2(e));
  }
  function i2(r, e) {
    return (r[0] * e[1] < r[1] * e[0] ? -1 : 1) * Math.acos(Bx(r, e));
  }
  function a2(r, e, t, n, i, a, o, s, l, u, c) {
    var h = l * (tc / 180), f = Jf(h) * (r - t) / 2 + Qf(h) * (e - n) / 2, d = -1 * Qf(h) * (r - t) / 2 + Jf(h) * (e - n) / 2, p = f * f / (o * o) + d * d / (s * s);
    p > 1 && (o *= Im(p), s *= Im(p));
    var v = (i === a ? -1 : 1) * Im((o * o * (s * s) - o * o * (d * d) - s * s * (f * f)) / (o * o * (d * d) + s * s * (f * f))) || 0, g = v * o * d / s, m = v * -s * f / o, y = (r + t) / 2 + Jf(h) * g - Qf(h) * m, x = (e + n) / 2 + Qf(h) * g + Jf(h) * m, _ = i2([
      1,
      0
    ], [
      (f - g) / o,
      (d - m) / s
    ]), S = [
      (f - g) / o,
      (d - m) / s
    ], b = [
      (-1 * f - g) / o,
      (-1 * d - m) / s
    ], w = i2(S, b);
    if (Bx(S, b) <= -1 && (w = tc), Bx(S, b) >= 1 && (w = 0), w < 0) {
      var C = Math.round(w / tc * 1e6) / 1e6;
      w = tc * 2 + C % 2 * tc;
    }
    c.addData(u, y, x, o, s, _, w, h, a);
  }
  var u8 = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, c8 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function h8(r) {
    var e = new $i();
    if (!r) return e;
    var t = 0, n = 0, i = t, a = n, o, s = $i.CMD, l = r.match(u8);
    if (!l) return e;
    for (var u = 0; u < l.length; u++) {
      for (var c = l[u], h = c.charAt(0), f = void 0, d = c.match(c8) || [], p = d.length, v = 0; v < p; v++) d[v] = parseFloat(d[v]);
      for (var g = 0; g < p; ) {
        var m = void 0, y = void 0, x = void 0, _ = void 0, S = void 0, b = void 0, w = void 0, C = t, T = n, A = void 0, M = void 0;
        switch (h) {
          case "l":
            t += d[g++], n += d[g++], f = s.L, e.addData(f, t, n);
            break;
          case "L":
            t = d[g++], n = d[g++], f = s.L, e.addData(f, t, n);
            break;
          case "m":
            t += d[g++], n += d[g++], f = s.M, e.addData(f, t, n), i = t, a = n, h = "l";
            break;
          case "M":
            t = d[g++], n = d[g++], f = s.M, e.addData(f, t, n), i = t, a = n, h = "L";
            break;
          case "h":
            t += d[g++], f = s.L, e.addData(f, t, n);
            break;
          case "H":
            t = d[g++], f = s.L, e.addData(f, t, n);
            break;
          case "v":
            n += d[g++], f = s.L, e.addData(f, t, n);
            break;
          case "V":
            n = d[g++], f = s.L, e.addData(f, t, n);
            break;
          case "C":
            f = s.C, e.addData(f, d[g++], d[g++], d[g++], d[g++], d[g++], d[g++]), t = d[g - 2], n = d[g - 1];
            break;
          case "c":
            f = s.C, e.addData(f, d[g++] + t, d[g++] + n, d[g++] + t, d[g++] + n, d[g++] + t, d[g++] + n), t += d[g - 2], n += d[g - 1];
            break;
          case "S":
            m = t, y = n, A = e.len(), M = e.data, o === s.C && (m += t - M[A - 4], y += n - M[A - 3]), f = s.C, C = d[g++], T = d[g++], t = d[g++], n = d[g++], e.addData(f, m, y, C, T, t, n);
            break;
          case "s":
            m = t, y = n, A = e.len(), M = e.data, o === s.C && (m += t - M[A - 4], y += n - M[A - 3]), f = s.C, C = t + d[g++], T = n + d[g++], t += d[g++], n += d[g++], e.addData(f, m, y, C, T, t, n);
            break;
          case "Q":
            C = d[g++], T = d[g++], t = d[g++], n = d[g++], f = s.Q, e.addData(f, C, T, t, n);
            break;
          case "q":
            C = d[g++] + t, T = d[g++] + n, t += d[g++], n += d[g++], f = s.Q, e.addData(f, C, T, t, n);
            break;
          case "T":
            m = t, y = n, A = e.len(), M = e.data, o === s.Q && (m += t - M[A - 4], y += n - M[A - 3]), t = d[g++], n = d[g++], f = s.Q, e.addData(f, m, y, t, n);
            break;
          case "t":
            m = t, y = n, A = e.len(), M = e.data, o === s.Q && (m += t - M[A - 4], y += n - M[A - 3]), t += d[g++], n += d[g++], f = s.Q, e.addData(f, m, y, t, n);
            break;
          case "A":
            x = d[g++], _ = d[g++], S = d[g++], b = d[g++], w = d[g++], C = t, T = n, t = d[g++], n = d[g++], f = s.A, a2(C, T, t, n, b, w, x, _, S, f, e);
            break;
          case "a":
            x = d[g++], _ = d[g++], S = d[g++], b = d[g++], w = d[g++], C = t, T = n, t += d[g++], n += d[g++], f = s.A, a2(C, T, t, n, b, w, x, _, S, f, e);
            break;
        }
      }
      (h === "z" || h === "Z") && (f = s.Z, e.addData(f), t = i, n = a), o = f;
    }
    return e.toStatic(), e;
  }
  var rE = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.applyTransform = function(t) {
    }, e;
  }(Ue);
  function nE(r) {
    return r.setData != null;
  }
  function iE(r, e) {
    var t = h8(r), n = H({}, e);
    return n.buildPath = function(i) {
      if (nE(i)) {
        i.setData(t.data);
        var a = i.getContext();
        a && i.rebuildPath(a, 1);
      } else {
        var a = i;
        t.rebuildPath(a, 1);
      }
    }, n.applyTransform = function(i) {
      tE(t, i), this.dirtyShape();
    }, n;
  }
  function aE(r, e) {
    return new rE(iE(r, e));
  }
  function f8(r, e) {
    var t = iE(r, e), n = function(i) {
      G(a, i);
      function a(o) {
        var s = i.call(this, o) || this;
        return s.applyTransform = t.applyTransform, s.buildPath = t.buildPath, s;
      }
      return a;
    }(rE);
    return n;
  }
  function d8(r, e) {
    for (var t = [], n = r.length, i = 0; i < n; i++) {
      var a = r[i];
      t.push(a.getUpdatedPathProxy(true));
    }
    var o = new Ue(e);
    return o.createPathProxy(), o.buildPath = function(s) {
      if (nE(s)) {
        s.appendPath(t);
        var l = s.getContext();
        l && s.rebuildPath(l, 1);
      }
    }, o;
  }
  function d1(r, e) {
    e = e || {};
    var t = new Ue();
    return r.shape && t.setShape(r.shape), t.setStyle(r.style), e.bakeTransform ? tE(t.path, r.getComputedTransform()) : e.toLocal ? t.setLocalTransform(r.getComputedTransform()) : t.copyTransform(r), t.buildPath = r.buildPath, t.applyTransform = t.applyTransform, t.z = r.z, t.z2 = r.z2, t.zlevel = r.zlevel, t;
  }
  var p8 = /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r = 0;
    }
    return r;
  }(), Ta = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new p8();
    }, e.prototype.buildPath = function(t, n) {
      t.moveTo(n.cx + n.r, n.cy), t.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
    }, e;
  }(Ue);
  Ta.prototype.type = "circle";
  var v8 = /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
    }
    return r;
  }(), rg = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new v8();
    }, e.prototype.buildPath = function(t, n) {
      var i = 0.5522848, a = n.cx, o = n.cy, s = n.rx, l = n.ry, u = s * i, c = l * i;
      t.moveTo(a - s, o), t.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l), t.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o), t.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l), t.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o), t.closePath();
    }, e;
  }(Ue);
  rg.prototype.type = "ellipse";
  var oE = Math.PI, Mm = oE * 2, Bo = Math.sin, pl = Math.cos, g8 = Math.acos, Cr = Math.atan2, o2 = Math.abs, th = Math.sqrt, Lc = Math.max, mi = Math.min, qn = 1e-4;
  function m8(r, e, t, n, i, a, o, s) {
    var l = t - r, u = n - e, c = o - i, h = s - a, f = h * l - c * u;
    if (!(f * f < qn)) return f = (c * (e - a) - h * (r - i)) / f, [
      r + f * l,
      e + f * u
    ];
  }
  function ed(r, e, t, n, i, a, o) {
    var s = r - t, l = e - n, u = (o ? a : -a) / th(s * s + l * l), c = u * l, h = -u * s, f = r + c, d = e + h, p = t + c, v = n + h, g = (f + p) / 2, m = (d + v) / 2, y = p - f, x = v - d, _ = y * y + x * x, S = i - a, b = f * v - p * d, w = (x < 0 ? -1 : 1) * th(Lc(0, S * S * _ - b * b)), C = (b * x - y * w) / _, T = (-b * y - x * w) / _, A = (b * x + y * w) / _, M = (-b * y + x * w) / _, E = C - g, k = T - m, R = A - g, N = M - m;
    return E * E + k * k > R * R + N * N && (C = A, T = M), {
      cx: C,
      cy: T,
      x0: -c,
      y0: -h,
      x1: C * (i / S - 1),
      y1: T * (i / S - 1)
    };
  }
  function y8(r) {
    var e;
    if (X(r)) {
      var t = r.length;
      if (!t) return r;
      t === 1 ? e = [
        r[0],
        r[0],
        0,
        0
      ] : t === 2 ? e = [
        r[0],
        r[0],
        r[1],
        r[1]
      ] : t === 3 ? e = r.concat(r[2]) : e = r;
    } else e = [
      r,
      r,
      r,
      r
    ];
    return e;
  }
  function x8(r, e) {
    var t, n = Lc(e.r, 0), i = Lc(e.r0 || 0, 0), a = n > 0, o = i > 0;
    if (!(!a && !o)) {
      if (a || (n = i, i = 0), i > n) {
        var s = n;
        n = i, i = s;
      }
      var l = e.startAngle, u = e.endAngle;
      if (!(isNaN(l) || isNaN(u))) {
        var c = e.cx, h = e.cy, f = !!e.clockwise, d = o2(u - l), p = d > Mm && d % Mm;
        if (p > qn && (d = p), !(n > qn)) r.moveTo(c, h);
        else if (d > Mm - qn) r.moveTo(c + n * pl(l), h + n * Bo(l)), r.arc(c, h, n, l, u, !f), i > qn && (r.moveTo(c + i * pl(u), h + i * Bo(u)), r.arc(c, h, i, u, l, f));
        else {
          var v = void 0, g = void 0, m = void 0, y = void 0, x = void 0, _ = void 0, S = void 0, b = void 0, w = void 0, C = void 0, T = void 0, A = void 0, M = void 0, E = void 0, k = void 0, R = void 0, N = n * pl(l), I = n * Bo(l), L = i * pl(u), P = i * Bo(u), O = d > qn;
          if (O) {
            var F = e.cornerRadius;
            F && (t = y8(F), v = t[0], g = t[1], m = t[2], y = t[3]);
            var B = o2(n - i) / 2;
            if (x = mi(B, m), _ = mi(B, y), S = mi(B, v), b = mi(B, g), T = w = Lc(x, _), A = C = Lc(S, b), (w > qn || C > qn) && (M = n * pl(u), E = n * Bo(u), k = i * pl(l), R = i * Bo(l), d < oE)) {
              var V = m8(N, I, k, R, M, E, L, P);
              if (V) {
                var U = N - V[0], Y = I - V[1], q = M - V[0], me = E - V[1], Me = 1 / Bo(g8((U * q + Y * me) / (th(U * U + Y * Y) * th(q * q + me * me))) / 2), re = th(V[0] * V[0] + V[1] * V[1]);
                T = mi(w, (n - re) / (Me + 1)), A = mi(C, (i - re) / (Me - 1));
              }
            }
          }
          if (!O) r.moveTo(c + N, h + I);
          else if (T > qn) {
            var J = mi(m, T), le = mi(y, T), te = ed(k, R, N, I, n, J, f), he = ed(M, E, L, P, n, le, f);
            r.moveTo(c + te.cx + te.x0, h + te.cy + te.y0), T < w && J === le ? r.arc(c + te.cx, h + te.cy, T, Cr(te.y0, te.x0), Cr(he.y0, he.x0), !f) : (J > 0 && r.arc(c + te.cx, h + te.cy, J, Cr(te.y0, te.x0), Cr(te.y1, te.x1), !f), r.arc(c, h, n, Cr(te.cy + te.y1, te.cx + te.x1), Cr(he.cy + he.y1, he.cx + he.x1), !f), le > 0 && r.arc(c + he.cx, h + he.cy, le, Cr(he.y1, he.x1), Cr(he.y0, he.x0), !f));
          } else r.moveTo(c + N, h + I), r.arc(c, h, n, l, u, !f);
          if (!(i > qn) || !O) r.lineTo(c + L, h + P);
          else if (A > qn) {
            var J = mi(v, A), le = mi(g, A), te = ed(L, P, M, E, i, -le, f), he = ed(N, I, k, R, i, -J, f);
            r.lineTo(c + te.cx + te.x0, h + te.cy + te.y0), A < C && J === le ? r.arc(c + te.cx, h + te.cy, A, Cr(te.y0, te.x0), Cr(he.y0, he.x0), !f) : (le > 0 && r.arc(c + te.cx, h + te.cy, le, Cr(te.y0, te.x0), Cr(te.y1, te.x1), !f), r.arc(c, h, i, Cr(te.cy + te.y1, te.cx + te.x1), Cr(he.cy + he.y1, he.cx + he.x1), f), J > 0 && r.arc(c + he.cx, h + he.cy, J, Cr(he.y1, he.x1), Cr(he.y0, he.x0), !f));
          } else r.lineTo(c + L, h + P), r.arc(c, h, i, u, l, f);
        }
        r.closePath();
      }
    }
  }
  var _8 = /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true, this.cornerRadius = 0;
    }
    return r;
  }(), qr = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new _8();
    }, e.prototype.buildPath = function(t, n) {
      x8(t, n);
    }, e.prototype.isZeroArea = function() {
      return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
    }, e;
  }(Ue);
  qr.prototype.type = "sector";
  var b8 = /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
    }
    return r;
  }(), mf = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new b8();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.cx, a = n.cy, o = Math.PI * 2;
      t.moveTo(i + n.r, a), t.arc(i, a, n.r, 0, o, false), t.moveTo(i + n.r0, a), t.arc(i, a, n.r0, 0, o, true);
    }, e;
  }(Ue);
  mf.prototype.type = "ring";
  function S8(r, e, t, n) {
    var i = [], a = [], o = [], s = [], l, u, c, h;
    if (n) {
      c = [
        1 / 0,
        1 / 0
      ], h = [
        -1 / 0,
        -1 / 0
      ];
      for (var f = 0, d = r.length; f < d; f++) Ya(c, c, r[f]), Xa(h, h, r[f]);
      Ya(c, c, n[0]), Xa(h, h, n[1]);
    }
    for (var f = 0, d = r.length; f < d; f++) {
      var p = r[f];
      if (t) l = r[f ? f - 1 : d - 1], u = r[(f + 1) % d];
      else if (f === 0 || f === d - 1) {
        i.push(oa(r[f]));
        continue;
      } else l = r[f - 1], u = r[f + 1];
      vs(a, u, l), up(a, a, e);
      var v = lx(p, l), g = lx(p, u), m = v + g;
      m !== 0 && (v /= m, g /= m), up(o, a, -v), up(s, a, g);
      var y = rC([], p, o), x = rC([], p, s);
      n && (Xa(y, y, c), Ya(y, y, h), Xa(x, x, c), Ya(x, x, h)), i.push(y), i.push(x);
    }
    return t && i.push(i.shift()), i;
  }
  function sE(r, e, t) {
    var n = e.smooth, i = e.points;
    if (i && i.length >= 2) {
      if (n) {
        var a = S8(i, n, t, e.smoothConstraint);
        r.moveTo(i[0][0], i[0][1]);
        for (var o = i.length, s = 0; s < (t ? o : o - 1); s++) {
          var l = a[s * 2], u = a[s * 2 + 1], c = i[(s + 1) % o];
          r.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
        }
      } else {
        r.moveTo(i[0][0], i[0][1]);
        for (var s = 1, h = i.length; s < h; s++) r.lineTo(i[s][0], i[s][1]);
      }
      t && r.closePath();
    }
  }
  var w8 = /* @__PURE__ */ function() {
    function r() {
      this.points = null, this.smooth = 0, this.smoothConstraint = null;
    }
    return r;
  }(), Kr = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new w8();
    }, e.prototype.buildPath = function(t, n) {
      sE(t, n, true);
    }, e;
  }(Ue);
  Kr.prototype.type = "polygon";
  var C8 = /* @__PURE__ */ function() {
    function r() {
      this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
    }
    return r;
  }(), Zr = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new C8();
    }, e.prototype.buildPath = function(t, n) {
      sE(t, n, false);
    }, e;
  }(Ue);
  Zr.prototype.type = "polyline";
  var T8 = {}, A8 = /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return r;
  }(), ir = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new A8();
    }, e.prototype.buildPath = function(t, n) {
      var i, a, o, s;
      if (this.subPixelOptimize) {
        var l = GR(T8, n, this.style);
        i = l.x1, a = l.y1, o = l.x2, s = l.y2;
      } else i = n.x1, a = n.y1, o = n.x2, s = n.y2;
      var u = n.percent;
      u !== 0 && (t.moveTo(i, a), u < 1 && (o = i * (1 - u) + o * u, s = a * (1 - u) + s * u), t.lineTo(o, s));
    }, e.prototype.pointAt = function(t) {
      var n = this.shape;
      return [
        n.x1 * (1 - t) + n.x2 * t,
        n.y1 * (1 - t) + n.y2 * t
      ];
    }, e;
  }(Ue);
  ir.prototype.type = "line";
  var jr = [], I8 = /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
    }
    return r;
  }();
  function s2(r, e, t) {
    var n = r.cpx2, i = r.cpy2;
    return n != null || i != null ? [
      (t ? pC : tr)(r.x1, r.cpx1, r.cpx2, r.x2, e),
      (t ? pC : tr)(r.y1, r.cpy1, r.cpy2, r.y2, e)
    ] : [
      (t ? dx : dr)(r.x1, r.cpx1, r.x2, e),
      (t ? dx : dr)(r.y1, r.cpy1, r.y2, e)
    ];
  }
  var yf = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new I8();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.x1, a = n.y1, o = n.x2, s = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, h = n.cpy2, f = n.percent;
      f !== 0 && (t.moveTo(i, a), c == null || h == null ? (f < 1 && (bh(i, l, o, f, jr), l = jr[1], o = jr[2], bh(a, u, s, f, jr), u = jr[1], s = jr[2]), t.quadraticCurveTo(l, u, o, s)) : (f < 1 && (lo(i, l, c, o, f, jr), l = jr[1], c = jr[2], o = jr[3], lo(a, u, h, s, f, jr), u = jr[1], h = jr[2], s = jr[3]), t.bezierCurveTo(l, u, c, h, o, s)));
    }, e.prototype.pointAt = function(t) {
      return s2(this.shape, t, false);
    }, e.prototype.tangentAt = function(t) {
      var n = s2(this.shape, t, true);
      return Du(n, n);
    }, e;
  }(Ue);
  yf.prototype.type = "bezier-curve";
  var M8 = /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
    }
    return r;
  }(), ng = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new M8();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.cx, a = n.cy, o = Math.max(n.r, 0), s = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(s), h = Math.sin(s);
      t.moveTo(c * o + i, h * o + a), t.arc(i, a, o, s, l, !u);
    }, e;
  }(Ue);
  ng.prototype.type = "arc";
  var p1 = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "compound", t;
    }
    return e.prototype._updatePathDirty = function() {
      for (var t = this.shape.paths, n = this.shapeChanged(), i = 0; i < t.length; i++) n = n || t[i].shapeChanged();
      n && this.dirtyShape();
    }, e.prototype.beforeBrush = function() {
      this._updatePathDirty();
      for (var t = this.shape.paths || [], n = this.getGlobalScale(), i = 0; i < t.length; i++) t[i].path || t[i].createPathProxy(), t[i].path.setScale(n[0], n[1], t[i].segmentIgnoreThreshold);
    }, e.prototype.buildPath = function(t, n) {
      for (var i = n.paths || [], a = 0; a < i.length; a++) i[a].buildPath(t, i[a].shape, true);
    }, e.prototype.afterBrush = function() {
      for (var t = this.shape.paths || [], n = 0; n < t.length; n++) t[n].pathUpdated();
    }, e.prototype.getBoundingRect = function() {
      return this._updatePathDirty.call(this), Ue.prototype.getBoundingRect.call(this);
    }, e;
  }(Ue), lE = function() {
    function r(e) {
      this.colorStops = e || [];
    }
    return r.prototype.addColorStop = function(e, t) {
      this.colorStops.push({
        offset: e,
        color: t
      });
    }, r;
  }(), xf = function(r) {
    G(e, r);
    function e(t, n, i, a, o, s) {
      var l = r.call(this, o) || this;
      return l.x = t ?? 0, l.y = n ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || false, l;
    }
    return e;
  }(lE), uE = function(r) {
    G(e, r);
    function e(t, n, i, a, o) {
      var s = r.call(this, a) || this;
      return s.x = t ?? 0.5, s.y = n ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = o || false, s;
    }
    return e;
  }(lE), zo = [
    0,
    0
  ], Vo = [
    0,
    0
  ], td = new Ne(), rd = new Ne(), Hp = function() {
    function r(e, t) {
      this._corners = [], this._axes = [], this._origin = [
        0,
        0
      ];
      for (var n = 0; n < 4; n++) this._corners[n] = new Ne();
      for (var n = 0; n < 2; n++) this._axes[n] = new Ne();
      e && this.fromBoundingRect(e, t);
    }
    return r.prototype.fromBoundingRect = function(e, t) {
      var n = this._corners, i = this._axes, a = e.x, o = e.y, s = a + e.width, l = o + e.height;
      if (n[0].set(a, o), n[1].set(s, o), n[2].set(s, l), n[3].set(a, l), t) for (var u = 0; u < 4; u++) n[u].transform(t);
      Ne.sub(i[0], n[1], n[0]), Ne.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize();
      for (var u = 0; u < 2; u++) this._origin[u] = i[u].dot(n[0]);
    }, r.prototype.intersect = function(e, t) {
      var n = true, i = !t;
      return td.set(1 / 0, 1 / 0), rd.set(0, 0), !this._intersectCheckOneSide(this, e, td, rd, i, 1) && (n = false, i) || !this._intersectCheckOneSide(e, this, td, rd, i, -1) && (n = false, i) || i || Ne.copy(t, n ? td : rd), n;
    }, r.prototype._intersectCheckOneSide = function(e, t, n, i, a, o) {
      for (var s = true, l = 0; l < 2; l++) {
        var u = this._axes[l];
        if (this._getProjMinMaxOnAxis(l, e._corners, zo), this._getProjMinMaxOnAxis(l, t._corners, Vo), zo[1] < Vo[0] || zo[0] > Vo[1]) {
          if (s = false, a) return s;
          var c = Math.abs(Vo[0] - zo[1]), h = Math.abs(zo[0] - Vo[1]);
          Math.min(c, h) > i.len() && (c < h ? Ne.scale(i, u, -c * o) : Ne.scale(i, u, h * o));
        } else if (n) {
          var c = Math.abs(Vo[0] - zo[1]), h = Math.abs(zo[0] - Vo[1]);
          Math.min(c, h) < n.len() && (c < h ? Ne.scale(n, u, c * o) : Ne.scale(n, u, -h * o));
        }
      }
      return s;
    }, r.prototype._getProjMinMaxOnAxis = function(e, t, n) {
      for (var i = this._axes[e], a = this._origin, o = t[0].dot(i) + a[e], s = o, l = o, u = 1; u < t.length; u++) {
        var c = t[u].dot(i) + a[e];
        s = Math.min(c, s), l = Math.max(c, l);
      }
      n[0] = s, n[1] = l;
    }, r;
  }(), D8 = [], P8 = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.notClear = true, t.incremental = true, t._displayables = [], t._temporaryDisplayables = [], t._cursor = 0, t;
    }
    return e.prototype.traverse = function(t, n) {
      t.call(n, this);
    }, e.prototype.useStyle = function() {
      this.style = {};
    }, e.prototype.getCursor = function() {
      return this._cursor;
    }, e.prototype.innerAfterBrush = function() {
      this._cursor = this._displayables.length;
    }, e.prototype.clearDisplaybles = function() {
      this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = false;
    }, e.prototype.clearTemporalDisplayables = function() {
      this._temporaryDisplayables = [];
    }, e.prototype.addDisplayable = function(t, n) {
      n ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw();
    }, e.prototype.addDisplayables = function(t, n) {
      n = n || false;
      for (var i = 0; i < t.length; i++) this.addDisplayable(t[i], n);
    }, e.prototype.getDisplayables = function() {
      return this._displayables;
    }, e.prototype.getTemporalDisplayables = function() {
      return this._temporaryDisplayables;
    }, e.prototype.eachPendingDisplayable = function(t) {
      for (var n = this._cursor; n < this._displayables.length; n++) t && t(this._displayables[n]);
      for (var n = 0; n < this._temporaryDisplayables.length; n++) t && t(this._temporaryDisplayables[n]);
    }, e.prototype.update = function() {
      this.updateTransform();
      for (var t = this._cursor; t < this._displayables.length; t++) {
        var n = this._displayables[t];
        n.parent = this, n.update(), n.parent = null;
      }
      for (var t = 0; t < this._temporaryDisplayables.length; t++) {
        var n = this._temporaryDisplayables[t];
        n.parent = this, n.update(), n.parent = null;
      }
    }, e.prototype.getBoundingRect = function() {
      if (!this._rect) {
        for (var t = new Oe(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
          var i = this._displayables[n], a = i.getBoundingRect().clone();
          i.needLocalTransform() && a.applyTransform(i.getLocalTransform(D8)), t.union(a);
        }
        this._rect = t;
      }
      return this._rect;
    }, e.prototype.contain = function(t, n) {
      var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
      if (a.contain(i[0], i[1])) for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(t, n)) return true;
      }
      return false;
    }, e;
  }(zn), cE = tt();
  function Ru(r, e, t, n, i) {
    var a;
    if (e && e.ecModel) {
      var o = e.ecModel.getUpdatePayload();
      a = o && o.animation;
    }
    var s = e && e.isAnimationEnabled(), l = r === "update";
    if (s) {
      var u = void 0, c = void 0, h = void 0;
      n ? (u = Pe(n.duration, 200), c = Pe(n.easing, "cubicOut"), h = 0) : (u = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), ge(h) && (h = h(t, i)), ge(u) && (u = u(t));
      var f = {
        duration: u || 0,
        delay: h,
        easing: c
      };
      return f;
    } else return null;
  }
  function v1(r, e, t, n, i, a, o) {
    var s = false, l;
    ge(i) ? (o = a, a = i, i = null) : _e(i) && (a = i.cb, o = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
    var u = r === "leave";
    u || e.stopAnimation("leave");
    var c = Ru(r, n, i, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(e, i) : null);
    if (c && c.duration > 0) {
      var h = c.duration, f = c.delay, d = c.easing, p = {
        duration: h,
        delay: f || 0,
        easing: d,
        done: a,
        force: !!a || !!o,
        setToFinal: !u,
        scope: r,
        during: o
      };
      s ? e.animateFrom(t, p) : e.animateTo(t, p);
    } else e.stopAnimation(), !s && e.attr(t), o && o(1), a && a();
  }
  function it(r, e, t, n, i, a) {
    v1("update", r, e, t, n, i, a);
  }
  function kt(r, e, t, n, i, a) {
    v1("enter", r, e, t, n, i, a);
  }
  function eu(r) {
    if (!r.__zr) return true;
    for (var e = 0; e < r.animators.length; e++) {
      var t = r.animators[e];
      if (t.scope === "leave") return true;
    }
    return false;
  }
  function uo(r, e, t, n, i, a) {
    eu(r) || v1("leave", r, e, t, n, i, a);
  }
  function l2(r, e, t, n) {
    r.removeTextContent(), r.removeTextGuideLine(), uo(r, {
      style: {
        opacity: 0
      }
    }, e, t, n);
  }
  function Mh(r, e, t) {
    function n() {
      r.parent && r.parent.remove(r);
    }
    r.isGroup ? r.traverse(function(i) {
      i.isGroup || l2(i, e, t, n);
    }) : l2(r, e, t, n);
  }
  function li(r) {
    cE(r).oldStyle = r.style;
  }
  function k8(r) {
    return cE(r).oldStyle;
  }
  var Yp = Math.max, Xp = Math.min, zx = {};
  function L8(r) {
    return Ue.extend(r);
  }
  var R8 = f8;
  function E8(r, e) {
    return R8(r, e);
  }
  function ci(r, e) {
    zx[r] = e;
  }
  function g1(r) {
    if (zx.hasOwnProperty(r)) return zx[r];
  }
  function ig(r, e, t, n) {
    var i = aE(r, e);
    return t && (n === "center" && (t = fE(t, i.getBoundingRect())), dE(i, t)), i;
  }
  function hE(r, e, t) {
    var n = new mr({
      style: {
        image: r,
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      onload: function(i) {
        if (t === "center") {
          var a = {
            width: i.width,
            height: i.height
          };
          n.setStyle(fE(e, a));
        }
      }
    });
    return n;
  }
  function fE(r, e) {
    var t = e.width / e.height, n = r.height * t, i;
    n <= r.width ? i = r.height : (n = r.width, i = n / t);
    var a = r.x + r.width / 2, o = r.y + r.height / 2;
    return {
      x: a - n / 2,
      y: o - i / 2,
      width: n,
      height: i
    };
  }
  var En = d8;
  function dE(r, e) {
    if (r.applyTransform) {
      var t = r.getBoundingRect(), n = t.calculateTransform(e);
      r.applyTransform(n);
    }
  }
  function uu(r, e) {
    return GR(r, r, {
      lineWidth: e
    }), r;
  }
  function N8(r) {
    return WR(r.shape, r.shape, r.style), r;
  }
  var xp = gs;
  function ks(r, e) {
    for (var t = Yv([]); r && r !== e; ) sa(t, r.getLocalTransform(), t), r = r.parent;
    return t;
  }
  function ai(r, e, t) {
    return e && !Lr(e) && (e = ta.getLocalTransform(e)), t && (e = Pu([], e)), xr([], r, e);
  }
  function ag(r, e, t) {
    var n = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), i = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), a = [
      r === "left" ? -n : r === "right" ? n : 0,
      r === "top" ? -i : r === "bottom" ? i : 0
    ];
    return a = ai(a, e, t), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
  }
  function u2(r) {
    return !r.isGroup;
  }
  function O8(r) {
    return r.shape != null;
  }
  function _f(r, e, t) {
    if (!r || !e) return;
    function n(o) {
      var s = {};
      return o.traverse(function(l) {
        u2(l) && l.anid && (s[l.anid] = l);
      }), s;
    }
    function i(o) {
      var s = {
        x: o.x,
        y: o.y,
        rotation: o.rotation
      };
      return O8(o) && (s.shape = H({}, o.shape)), s;
    }
    var a = n(r);
    e.traverse(function(o) {
      if (u2(o) && o.anid) {
        var s = a[o.anid];
        if (s) {
          var l = i(o);
          o.attr(i(s)), it(o, l, t, De(o).dataIndex);
        }
      }
    });
  }
  function pE(r, e) {
    return K(r, function(t) {
      var n = t[0];
      n = Yp(n, e.x), n = Xp(n, e.x + e.width);
      var i = t[1];
      return i = Yp(i, e.y), i = Xp(i, e.y + e.height), [
        n,
        i
      ];
    });
  }
  function F8(r, e) {
    var t = Yp(r.x, e.x), n = Xp(r.x + r.width, e.x + e.width), i = Yp(r.y, e.y), a = Xp(r.y + r.height, e.y + e.height);
    if (n >= t && a >= i) return {
      x: t,
      y: i,
      width: n - t,
      height: a - i
    };
  }
  function bf(r, e, t) {
    var n = H({
      rectHover: true
    }, e), i = n.style = {
      strokeNoScale: true
    };
    if (t = t || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }, r) return r.indexOf("image://") === 0 ? (i.image = r.slice(8), ye(i, t), new mr(n)) : ig(r.replace("path://", ""), n, t, "center");
  }
  function Rc(r, e, t, n, i) {
    for (var a = 0, o = i[i.length - 1]; a < i.length; a++) {
      var s = i[a];
      if (vE(r, e, t, n, s[0], s[1], o[0], o[1])) return true;
      o = s;
    }
  }
  function vE(r, e, t, n, i, a, o, s) {
    var l = t - r, u = n - e, c = o - i, h = s - a, f = Dm(c, h, l, u);
    if (B8(f)) return false;
    var d = r - i, p = e - a, v = Dm(d, p, l, u) / f;
    if (v < 0 || v > 1) return false;
    var g = Dm(d, p, c, h) / f;
    return !(g < 0 || g > 1);
  }
  function Dm(r, e, t, n) {
    return r * n - t * e;
  }
  function B8(r) {
    return r <= 1e-6 && r >= -1e-6;
  }
  function Ks(r) {
    var e = r.itemTooltipOption, t = r.componentModel, n = r.itemName, i = ee(e) ? {
      formatter: e
    } : e, a = t.mainType, o = t.componentIndex, s = {
      componentType: a,
      name: n,
      $vars: [
        "name"
      ]
    };
    s[a + "Index"] = o;
    var l = r.formatterParamsExtra;
    l && D(je(l), function(c) {
      oe(s, c) || (s[c] = l[c], s.$vars.push(c));
    });
    var u = De(r.el);
    u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
      name: n,
      option: ye({
        content: n,
        encodeHTMLContent: true,
        formatterParams: s
      }, i)
    };
  }
  function c2(r, e) {
    var t;
    r.isGroup && (t = e(r)), t || r.traverse(e);
  }
  function mo(r, e) {
    if (r) if (X(r)) for (var t = 0; t < r.length; t++) c2(r[t], e);
    else c2(r, e);
  }
  ci("circle", Ta);
  ci("ellipse", rg);
  ci("sector", qr);
  ci("ring", mf);
  ci("polygon", Kr);
  ci("polyline", Zr);
  ci("rect", et);
  ci("line", ir);
  ci("bezierCurve", yf);
  ci("arc", ng);
  const Zs = Object.freeze(Object.defineProperty({
    __proto__: null,
    Arc: ng,
    BezierCurve: yf,
    BoundingRect: Oe,
    Circle: Ta,
    CompoundPath: p1,
    Ellipse: rg,
    Group: Ce,
    Image: mr,
    IncrementalDisplayable: P8,
    Line: ir,
    LinearGradient: xf,
    OrientedBoundingRect: Hp,
    Path: Ue,
    Point: Ne,
    Polygon: Kr,
    Polyline: Zr,
    RadialGradient: uE,
    Rect: et,
    Ring: mf,
    Sector: qr,
    Text: rt,
    applyTransform: ai,
    clipPointsByRect: pE,
    clipRectByRect: F8,
    createIcon: bf,
    extendPath: E8,
    extendShape: L8,
    getShapeClass: g1,
    getTransform: ks,
    groupTransition: _f,
    initProps: kt,
    isElementRemoved: eu,
    lineLineIntersect: vE,
    linePolygonIntersect: Rc,
    makeImage: hE,
    makePath: ig,
    mergePath: En,
    registerShape: ci,
    removeElement: uo,
    removeElementWithFadeOut: Mh,
    resizePath: dE,
    setTooltipConfig: Ks,
    subPixelOptimize: xp,
    subPixelOptimizeLine: uu,
    subPixelOptimizeRect: N8,
    transformDirection: ag,
    traverseElements: mo,
    updateProps: it
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var og = {};
  function gE(r, e) {
    for (var t = 0; t < Xr.length; t++) {
      var n = Xr[t], i = e[n], a = r.ensureState(n);
      a.style = a.style || {}, a.style.text = i;
    }
    var o = r.currentStates.slice();
    r.clearStates(true), r.setStyle({
      text: e.normal
    }), r.useStates(o, true);
  }
  function Vx(r, e, t) {
    var n = r.labelFetcher, i = r.labelDataIndex, a = r.labelDimIndex, o = e.normal, s;
    n && (s = n.getFormattedLabel(i, "normal", null, a, o && o.get("formatter"), t != null ? {
      interpolatedValue: t
    } : null)), s == null && (s = ge(r.defaultText) ? r.defaultText(i, r, t) : r.defaultText);
    for (var l = {
      normal: s
    }, u = 0; u < Xr.length; u++) {
      var c = Xr[u], h = e[c];
      l[c] = Pe(n ? n.getFormattedLabel(i, c, null, a, h && h.get("formatter")) : null, s);
    }
    return l;
  }
  function Sr(r, e, t, n) {
    t = t || og;
    for (var i = r instanceof rt, a = false, o = 0; o < Ah.length; o++) {
      var s = e[Ah[o]];
      if (s && s.getShallow("show")) {
        a = true;
        break;
      }
    }
    var l = i ? r : r.getTextContent();
    if (a) {
      i || (l || (l = new rt(), r.setTextContent(l)), r.stateProxy && (l.stateProxy = r.stateProxy));
      var u = Vx(t, e), c = e.normal, h = !!c.getShallow("show"), f = wt(c, n && n.normal, t, false, !i);
      f.text = u.normal, i || r.setTextConfig(qp(c, t, false));
      for (var o = 0; o < Xr.length; o++) {
        var d = Xr[o], s = e[d];
        if (s) {
          var p = l.ensureState(d), v = !!Pe(s.getShallow("show"), h);
          if (v !== h && (p.ignore = !v), p.style = wt(s, n && n[d], t, true, !i), p.style.text = u[d], !i) {
            var g = r.ensureState(d);
            g.textConfig = qp(s, t, true);
          }
        }
      }
      l.silent = !!c.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !h, l.useStyle(f), l.dirty(), t.enableTextSetter && (Eu(l).setLabelText = function(m) {
        var y = Vx(t, e, m);
        gE(l, y);
      });
    } else l && (l.ignore = true);
    r.dirty();
  }
  function lr(r, e) {
    e = e || "label";
    for (var t = {
      normal: r.getModel(e)
    }, n = 0; n < Xr.length; n++) {
      var i = Xr[n];
      t[i] = r.getModel([
        i,
        e
      ]);
    }
    return t;
  }
  function wt(r, e, t, n, i) {
    var a = {};
    return z8(a, r, t, n, i), e && H(a, e), a;
  }
  function qp(r, e, t) {
    e = e || {};
    var n = {}, i, a = r.getShallow("rotate"), o = Pe(r.getShallow("distance"), t ? null : 5), s = r.getShallow("offset");
    return i = r.getShallow("position") || (t ? null : "inside"), i === "outside" && (i = e.defaultOutsidePosition || "top"), i != null && (n.position = i), s != null && (n.offset = s), a != null && (a *= Math.PI / 180, n.rotation = a), o != null && (n.distance = o), n.outsideFill = r.get("color") === "inherit" ? e.inheritColor || null : "auto", n;
  }
  function z8(r, e, t, n, i) {
    t = t || og;
    var a = e.ecModel, o = a && a.option.textStyle, s = V8(e), l;
    if (s) {
      l = {};
      for (var u in s) if (s.hasOwnProperty(u)) {
        var c = e.getModel([
          "rich",
          u
        ]);
        p2(l[u] = {}, c, o, t, n, i, false, true);
      }
    }
    l && (r.rich = l);
    var h = e.get("overflow");
    h && (r.overflow = h);
    var f = e.get("minMargin");
    f != null && (r.margin = f), p2(r, e, o, t, n, i, true, false);
  }
  function V8(r) {
    for (var e; r && r !== r.ecModel; ) {
      var t = (r.option || og).rich;
      if (t) {
        e = e || {};
        for (var n = je(t), i = 0; i < n.length; i++) {
          var a = n[i];
          e[a] = 1;
        }
      }
      r = r.parentModel;
    }
    return e;
  }
  var h2 = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "textShadowColor",
    "textShadowBlur",
    "textShadowOffsetX",
    "textShadowOffsetY"
  ], f2 = [
    "align",
    "lineHeight",
    "width",
    "height",
    "tag",
    "verticalAlign",
    "ellipsis"
  ], d2 = [
    "padding",
    "borderWidth",
    "borderRadius",
    "borderDashOffset",
    "backgroundColor",
    "borderColor",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY"
  ];
  function p2(r, e, t, n, i, a, o, s) {
    t = !i && t || og;
    var l = n && n.inheritColor, u = e.getShallow("color"), c = e.getShallow("textBorderColor"), h = Pe(e.getShallow("opacity"), t.opacity);
    (u === "inherit" || u === "auto") && (l ? u = l : u = null), (c === "inherit" || c === "auto") && (l ? c = l : c = null), a || (u = u || t.color, c = c || t.textBorderColor), u != null && (r.fill = u), c != null && (r.stroke = c);
    var f = Pe(e.getShallow("textBorderWidth"), t.textBorderWidth);
    f != null && (r.lineWidth = f);
    var d = Pe(e.getShallow("textBorderType"), t.textBorderType);
    d != null && (r.lineDash = d);
    var p = Pe(e.getShallow("textBorderDashOffset"), t.textBorderDashOffset);
    p != null && (r.lineDashOffset = p), !i && h == null && !s && (h = n && n.defaultOpacity), h != null && (r.opacity = h), !i && !a && r.fill == null && n.inheritColor && (r.fill = n.inheritColor);
    for (var v = 0; v < h2.length; v++) {
      var g = h2[v], m = Pe(e.getShallow(g), t[g]);
      m != null && (r[g] = m);
    }
    for (var v = 0; v < f2.length; v++) {
      var g = f2[v], m = e.getShallow(g);
      m != null && (r[g] = m);
    }
    if (r.verticalAlign == null) {
      var y = e.getShallow("baseline");
      y != null && (r.verticalAlign = y);
    }
    if (!o || !n.disableBox) {
      for (var v = 0; v < d2.length; v++) {
        var g = d2[v], m = e.getShallow(g);
        m != null && (r[g] = m);
      }
      var x = e.getShallow("borderType");
      x != null && (r.borderDash = x), (r.backgroundColor === "auto" || r.backgroundColor === "inherit") && l && (r.backgroundColor = l), (r.borderColor === "auto" || r.borderColor === "inherit") && l && (r.borderColor = l);
    }
  }
  function m1(r, e) {
    var t = e && e.getModel("textStyle");
    return ei([
      r.fontStyle || t && t.getShallow("fontStyle") || "",
      r.fontWeight || t && t.getShallow("fontWeight") || "",
      (r.fontSize || t && t.getShallow("fontSize") || 12) + "px",
      r.fontFamily || t && t.getShallow("fontFamily") || "sans-serif"
    ].join(" "));
  }
  var Eu = tt();
  function mE(r, e, t, n) {
    if (r) {
      var i = Eu(r);
      i.prevValue = i.value, i.value = t;
      var a = e.normal;
      i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = n, i.statesModels = e);
    }
  }
  function yE(r, e, t, n, i) {
    var a = Eu(r);
    if (!a.valueAnimation || a.prevValue === a.value) return;
    var o = a.defaultInterpolatedText, s = Pe(a.interpolatedValue, a.prevValue), l = a.value;
    function u(c) {
      var h = ER(t, a.precision, s, l, c);
      a.interpolatedValue = c === 1 ? null : h;
      var f = Vx({
        labelDataIndex: e,
        labelFetcher: i,
        defaultText: o ? o(h) : h + ""
      }, a.statesModels, h);
      gE(r, f);
    }
    r.percent = 0, (a.prevValue == null ? kt : it)(r, {
      percent: 1
    }, n, e, null, u);
  }
  var $8 = [
    "textStyle",
    "color"
  ], Pm = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "padding",
    "lineHeight",
    "rich",
    "width",
    "height",
    "overflow"
  ], km = new rt(), G8 = function() {
    function r() {
    }
    return r.prototype.getTextColor = function(e) {
      var t = this.ecModel;
      return this.getShallow("color") || (!e && t ? t.get($8) : null);
    }, r.prototype.getFont = function() {
      return m1({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, r.prototype.getTextRect = function(e) {
      for (var t = {
        text: e,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < Pm.length; n++) t[Pm[n]] = this.getShallow(Pm[n]);
      return km.useStyle(t), km.update(), km.getBoundingRect();
    }, r;
  }(), xE = [
    [
      "lineWidth",
      "width"
    ],
    [
      "stroke",
      "color"
    ],
    [
      "opacity"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ],
    [
      "lineDash",
      "type"
    ],
    [
      "lineDashOffset",
      "dashOffset"
    ],
    [
      "lineCap",
      "cap"
    ],
    [
      "lineJoin",
      "join"
    ],
    [
      "miterLimit"
    ]
  ], W8 = Vs(xE), U8 = function() {
    function r() {
    }
    return r.prototype.getLineStyle = function(e) {
      return W8(this, e);
    }, r;
  }(), _E = [
    [
      "fill",
      "color"
    ],
    [
      "stroke",
      "borderColor"
    ],
    [
      "lineWidth",
      "borderWidth"
    ],
    [
      "opacity"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ],
    [
      "lineDash",
      "borderType"
    ],
    [
      "lineDashOffset",
      "borderDashOffset"
    ],
    [
      "lineCap",
      "borderCap"
    ],
    [
      "lineJoin",
      "borderJoin"
    ],
    [
      "miterLimit",
      "borderMiterLimit"
    ]
  ], H8 = Vs(_E), Y8 = function() {
    function r() {
    }
    return r.prototype.getItemStyle = function(e, t) {
      return H8(this, e, t);
    }, r;
  }(), ft = function() {
    function r(e, t, n) {
      this.parentModel = t, this.ecModel = n, this.option = e;
    }
    return r.prototype.init = function(e, t, n) {
    }, r.prototype.mergeOption = function(e, t) {
      Ee(this.option, e, true);
    }, r.prototype.get = function(e, t) {
      return e == null ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel);
    }, r.prototype.getShallow = function(e, t) {
      var n = this.option, i = n == null ? n : n[e];
      if (i == null && !t) {
        var a = this.parentModel;
        a && (i = a.getShallow(e));
      }
      return i;
    }, r.prototype.getModel = function(e, t) {
      var n = e != null, i = n ? this.parsePath(e) : null, a = n ? this._doGet(i) : this.option;
      return t = t || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new r(a, t, this.ecModel);
    }, r.prototype.isEmpty = function() {
      return this.option == null;
    }, r.prototype.restoreData = function() {
    }, r.prototype.clone = function() {
      var e = this.constructor;
      return new e(be(this.option));
    }, r.prototype.parsePath = function(e) {
      return typeof e == "string" ? e.split(".") : e;
    }, r.prototype.resolveParentPath = function(e) {
      return e;
    }, r.prototype.isAnimationEnabled = function() {
      if (!He.node && this.option) {
        if (this.option.animation != null) return !!this.option.animation;
        if (this.parentModel) return this.parentModel.isAnimationEnabled();
      }
    }, r.prototype._doGet = function(e, t) {
      var n = this.option;
      if (!e) return n;
      for (var i = 0; i < e.length && !(e[i] && (n = n && typeof n == "object" ? n[e[i]] : null, n == null)); i++) ;
      return n == null && t && (n = t._doGet(this.resolveParentPath(e), t.parentModel)), n;
    }, r;
  }();
  a1(ft);
  t6(ft);
  qt(ft, U8);
  qt(ft, Y8);
  qt(ft, o6);
  qt(ft, G8);
  var X8 = Math.round(Math.random() * 10);
  function Nu(r) {
    return [
      r || "",
      X8++
    ].join("_");
  }
  function q8(r) {
    var e = {};
    r.registerSubTypeDefaulter = function(t, n) {
      var i = Di(t);
      e[i.main] = n;
    }, r.determineSubType = function(t, n) {
      var i = n.type;
      if (!i) {
        var a = Di(t).main;
        r.hasSubTypes(t) && e[a] && (i = e[a](n));
      }
      return i;
    };
  }
  function K8(r, e) {
    r.topologicalTravel = function(a, o, s, l) {
      if (!a.length) return;
      var u = t(o), c = u.graph, h = u.noEntryList, f = {};
      for (D(a, function(y) {
        f[y] = true;
      }); h.length; ) {
        var d = h.pop(), p = c[d], v = !!f[d];
        v && (s.call(l, d, p.originalDeps.slice()), delete f[d]), D(p.successor, v ? m : g);
      }
      D(f, function() {
        var y = "";
        throw new Error(y);
      });
      function g(y) {
        c[y].entryCount--, c[y].entryCount === 0 && h.push(y);
      }
      function m(y) {
        f[y] = true, g(y);
      }
    };
    function t(a) {
      var o = {}, s = [];
      return D(a, function(l) {
        var u = n(o, l), c = u.originalDeps = e(l), h = i(c, a);
        u.entryCount = h.length, u.entryCount === 0 && s.push(l), D(h, function(f) {
          Be(u.predecessor, f) < 0 && u.predecessor.push(f);
          var d = n(o, f);
          Be(d.successor, f) < 0 && d.successor.push(l);
        });
      }), {
        graph: o,
        noEntryList: s
      };
    }
    function n(a, o) {
      return a[o] || (a[o] = {
        predecessor: [],
        successor: []
      }), a[o];
    }
    function i(a, o) {
      var s = [];
      return D(a, function(l) {
        Be(o, l) >= 0 && s.push(l);
      }), s;
    }
  }
  function yo(r, e) {
    return Ee(Ee({}, r, true), e, true);
  }
  const Z8 = {
    time: {
      month: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ],
      monthAbbr: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      dayOfWeek: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ],
      dayOfWeekAbbr: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ]
    },
    legend: {
      selector: {
        all: "All",
        inverse: "Inv"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "Box Select",
          polygon: "Lasso Select",
          lineX: "Horizontally Select",
          lineY: "Vertically Select",
          keep: "Keep Selections",
          clear: "Clear Selections"
        }
      },
      dataView: {
        title: "Data View",
        lang: [
          "Data View",
          "Close",
          "Refresh"
        ]
      },
      dataZoom: {
        title: {
          zoom: "Zoom",
          back: "Zoom Reset"
        }
      },
      magicType: {
        title: {
          line: "Switch to Line Chart",
          bar: "Switch to Bar Chart",
          stack: "Stack",
          tiled: "Tile"
        }
      },
      restore: {
        title: "Restore"
      },
      saveAsImage: {
        title: "Save as Image",
        lang: [
          "Right Click to Save Image"
        ]
      }
    },
    series: {
      typeNames: {
        pie: "Pie chart",
        bar: "Bar chart",
        line: "Line chart",
        scatter: "Scatter plot",
        effectScatter: "Ripple scatter plot",
        radar: "Radar chart",
        tree: "Tree",
        treemap: "Treemap",
        boxplot: "Boxplot",
        candlestick: "Candlestick",
        k: "K line chart",
        heatmap: "Heat map",
        map: "Map",
        parallel: "Parallel coordinate map",
        lines: "Line graph",
        graph: "Relationship graph",
        sankey: "Sankey diagram",
        funnel: "Funnel chart",
        gauge: "Gauge",
        pictorialBar: "Pictorial bar",
        themeRiver: "Theme River Map",
        sunburst: "Sunburst",
        custom: "Custom chart",
        chart: "Chart"
      }
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: "This is a chart"
      },
      series: {
        single: {
          prefix: "",
          withName: " with type {seriesType} named {seriesName}.",
          withoutName: " with type {seriesType}."
        },
        multiple: {
          prefix: ". It consists of {seriesCount} series count.",
          withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
          withoutName: " The {seriesId} series is a {seriesType}.",
          separator: {
            middle: "",
            end: ""
          }
        }
      },
      data: {
        allData: "The data is as follows: ",
        partialData: "The first {displayCnt} items are: ",
        withName: "the data for {name} is {value}",
        withoutName: "{value}",
        separator: {
          middle: ", ",
          end: ". "
        }
      }
    }
  }, j8 = {
    time: {
      month: [
        "\u4E00\u6708",
        "\u4E8C\u6708",
        "\u4E09\u6708",
        "\u56DB\u6708",
        "\u4E94\u6708",
        "\u516D\u6708",
        "\u4E03\u6708",
        "\u516B\u6708",
        "\u4E5D\u6708",
        "\u5341\u6708",
        "\u5341\u4E00\u6708",
        "\u5341\u4E8C\u6708"
      ],
      monthAbbr: [
        "1\u6708",
        "2\u6708",
        "3\u6708",
        "4\u6708",
        "5\u6708",
        "6\u6708",
        "7\u6708",
        "8\u6708",
        "9\u6708",
        "10\u6708",
        "11\u6708",
        "12\u6708"
      ],
      dayOfWeek: [
        "\u661F\u671F\u65E5",
        "\u661F\u671F\u4E00",
        "\u661F\u671F\u4E8C",
        "\u661F\u671F\u4E09",
        "\u661F\u671F\u56DB",
        "\u661F\u671F\u4E94",
        "\u661F\u671F\u516D"
      ],
      dayOfWeekAbbr: [
        "\u65E5",
        "\u4E00",
        "\u4E8C",
        "\u4E09",
        "\u56DB",
        "\u4E94",
        "\u516D"
      ]
    },
    legend: {
      selector: {
        all: "\u5168\u9009",
        inverse: "\u53CD\u9009"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "\u77E9\u5F62\u9009\u62E9",
          polygon: "\u5708\u9009",
          lineX: "\u6A2A\u5411\u9009\u62E9",
          lineY: "\u7EB5\u5411\u9009\u62E9",
          keep: "\u4FDD\u6301\u9009\u62E9",
          clear: "\u6E05\u9664\u9009\u62E9"
        }
      },
      dataView: {
        title: "\u6570\u636E\u89C6\u56FE",
        lang: [
          "\u6570\u636E\u89C6\u56FE",
          "\u5173\u95ED",
          "\u5237\u65B0"
        ]
      },
      dataZoom: {
        title: {
          zoom: "\u533A\u57DF\u7F29\u653E",
          back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
        }
      },
      magicType: {
        title: {
          line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
          bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
          stack: "\u5207\u6362\u4E3A\u5806\u53E0",
          tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
        }
      },
      restore: {
        title: "\u8FD8\u539F"
      },
      saveAsImage: {
        title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
        lang: [
          "\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"
        ]
      }
    },
    series: {
      typeNames: {
        pie: "\u997C\u56FE",
        bar: "\u67F1\u72B6\u56FE",
        line: "\u6298\u7EBF\u56FE",
        scatter: "\u6563\u70B9\u56FE",
        effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
        radar: "\u96F7\u8FBE\u56FE",
        tree: "\u6811\u56FE",
        treemap: "\u77E9\u5F62\u6811\u56FE",
        boxplot: "\u7BB1\u578B\u56FE",
        candlestick: "K\u7EBF\u56FE",
        k: "K\u7EBF\u56FE",
        heatmap: "\u70ED\u529B\u56FE",
        map: "\u5730\u56FE",
        parallel: "\u5E73\u884C\u5750\u6807\u56FE",
        lines: "\u7EBF\u56FE",
        graph: "\u5173\u7CFB\u56FE",
        sankey: "\u6851\u57FA\u56FE",
        funnel: "\u6F0F\u6597\u56FE",
        gauge: "\u4EEA\u8868\u76D8\u56FE",
        pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
        themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
        sunburst: "\u65ED\u65E5\u56FE",
        custom: "\u81EA\u5B9A\u4E49\u56FE\u8868",
        chart: "\u56FE\u8868"
      }
    },
    aria: {
      general: {
        withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
        withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
      },
      series: {
        single: {
          prefix: "",
          withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
          withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
        },
        multiple: {
          prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
          withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
          withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
          separator: {
            middle: "\uFF1B",
            end: "\u3002"
          }
        }
      },
      data: {
        allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
        partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
        withName: "{name}\u7684\u6570\u636E\u662F{value}",
        withoutName: "{value}",
        separator: {
          middle: "\uFF0C",
          end: ""
        }
      }
    }
  };
  var Kp = "ZH", y1 = "EN", tu = y1, _p = {}, x1 = {}, bE = He.domSupported ? function() {
    var r = (document.documentElement.lang || navigator.language || navigator.browserLanguage || tu).toUpperCase();
    return r.indexOf(Kp) > -1 ? Kp : tu;
  }() : tu;
  function SE(r, e) {
    r = r.toUpperCase(), x1[r] = new ft(e), _p[r] = e;
  }
  function Q8(r) {
    if (ee(r)) {
      var e = _p[r.toUpperCase()] || {};
      return r === Kp || r === y1 ? be(e) : Ee(be(e), be(_p[tu]), false);
    } else return Ee(be(r), be(_p[tu]), false);
  }
  function $x(r) {
    return x1[r];
  }
  function J8() {
    return x1[tu];
  }
  SE(y1, Z8);
  SE(Kp, j8);
  var _1 = 1e3, b1 = _1 * 60, rh = b1 * 60, Nn = rh * 24, v2 = Nn * 365, Ec = {
    year: "{yyyy}",
    month: "{MMM}",
    day: "{d}",
    hour: "{HH}:{mm}",
    minute: "{HH}:{mm}",
    second: "{HH}:{mm}:{ss}",
    millisecond: "{HH}:{mm}:{ss} {SSS}",
    none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
  }, nd = "{yyyy}-{MM}-{dd}", g2 = {
    year: "{yyyy}",
    month: "{yyyy}-{MM}",
    day: nd,
    hour: nd + " " + Ec.hour,
    minute: nd + " " + Ec.minute,
    second: nd + " " + Ec.second,
    millisecond: Ec.none
  }, Lm = [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ], wE = [
    "year",
    "half-year",
    "quarter",
    "month",
    "week",
    "half-week",
    "day",
    "half-day",
    "quarter-day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  function Pa(r, e) {
    return r += "", "0000".substr(0, e - r.length) + r;
  }
  function ru(r) {
    switch (r) {
      case "half-year":
      case "quarter":
        return "month";
      case "week":
      case "half-week":
        return "day";
      case "half-day":
      case "quarter-day":
        return "hour";
      default:
        return r;
    }
  }
  function eY(r) {
    return r === ru(r);
  }
  function tY(r) {
    switch (r) {
      case "year":
      case "month":
        return "day";
      case "millisecond":
        return "millisecond";
      default:
        return "second";
    }
  }
  function sg(r, e, t, n) {
    var i = Vi(r), a = i[S1(t)](), o = i[nu(t)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = i[lg(t)](), u = i["get" + (t ? "UTC" : "") + "Day"](), c = i[Dh(t)](), h = (c - 1) % 12 + 1, f = i[ug(t)](), d = i[cg(t)](), p = i[hg(t)](), v = c >= 12 ? "pm" : "am", g = v.toUpperCase(), m = n instanceof ft ? n : $x(n || bE) || J8(), y = m.getModel("time"), x = y.get("month"), _ = y.get("monthAbbr"), S = y.get("dayOfWeek"), b = y.get("dayOfWeekAbbr");
    return (e || "").replace(/{a}/g, v + "").replace(/{A}/g, g + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, Pa(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, x[o - 1]).replace(/{MMM}/g, _[o - 1]).replace(/{MM}/g, Pa(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, Pa(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, S[u]).replace(/{ee}/g, b[u]).replace(/{e}/g, u + "").replace(/{HH}/g, Pa(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, Pa(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, Pa(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, Pa(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, Pa(p, 3)).replace(/{S}/g, p + "");
  }
  function rY(r, e, t, n, i) {
    var a = null;
    if (ee(t)) a = t;
    else if (ge(t)) a = t(r.value, e, {
      level: r.level
    });
    else {
      var o = H({}, Ec);
      if (r.level > 0) for (var s = 0; s < Lm.length; ++s) o[Lm[s]] = "{primary|" + o[Lm[s]] + "}";
      var l = t ? t.inherit === false ? t : ye(t, o) : o, u = CE(r.value, i);
      if (l[u]) a = l[u];
      else if (l.inherit) {
        for (var c = wE.indexOf(u), s = c - 1; s >= 0; --s) if (l[u]) {
          a = l[u];
          break;
        }
        a = a || o.none;
      }
      if (X(a)) {
        var h = r.level == null ? 0 : r.level >= 0 ? r.level : a.length + r.level;
        h = Math.min(h, a.length - 1), a = a[h];
      }
    }
    return sg(new Date(r.value), a, i, n);
  }
  function CE(r, e) {
    var t = Vi(r), n = t[nu(e)]() + 1, i = t[lg(e)](), a = t[Dh(e)](), o = t[ug(e)](), s = t[cg(e)](), l = t[hg(e)](), u = l === 0, c = u && s === 0, h = c && o === 0, f = h && a === 0, d = f && i === 1, p = d && n === 1;
    return p ? "year" : d ? "month" : f ? "day" : h ? "hour" : c ? "minute" : u ? "second" : "millisecond";
  }
  function m2(r, e, t) {
    var n = nt(r) ? Vi(r) : r;
    switch (e = e || CE(r, t), e) {
      case "year":
        return n[S1(t)]();
      case "half-year":
        return n[nu(t)]() >= 6 ? 1 : 0;
      case "quarter":
        return Math.floor((n[nu(t)]() + 1) / 4);
      case "month":
        return n[nu(t)]();
      case "day":
        return n[lg(t)]();
      case "half-day":
        return n[Dh(t)]() / 24;
      case "hour":
        return n[Dh(t)]();
      case "minute":
        return n[ug(t)]();
      case "second":
        return n[cg(t)]();
      case "millisecond":
        return n[hg(t)]();
    }
  }
  function S1(r) {
    return r ? "getUTCFullYear" : "getFullYear";
  }
  function nu(r) {
    return r ? "getUTCMonth" : "getMonth";
  }
  function lg(r) {
    return r ? "getUTCDate" : "getDate";
  }
  function Dh(r) {
    return r ? "getUTCHours" : "getHours";
  }
  function ug(r) {
    return r ? "getUTCMinutes" : "getMinutes";
  }
  function cg(r) {
    return r ? "getUTCSeconds" : "getSeconds";
  }
  function hg(r) {
    return r ? "getUTCMilliseconds" : "getMilliseconds";
  }
  function nY(r) {
    return r ? "setUTCFullYear" : "setFullYear";
  }
  function TE(r) {
    return r ? "setUTCMonth" : "setMonth";
  }
  function AE(r) {
    return r ? "setUTCDate" : "setDate";
  }
  function IE(r) {
    return r ? "setUTCHours" : "setHours";
  }
  function ME(r) {
    return r ? "setUTCMinutes" : "setMinutes";
  }
  function DE(r) {
    return r ? "setUTCSeconds" : "setSeconds";
  }
  function PE(r) {
    return r ? "setUTCMilliseconds" : "setMilliseconds";
  }
  function kE(r) {
    if (!AR(r)) return ee(r) ? r : "-";
    var e = (r + "").split(".");
    return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "");
  }
  function LE(r, e) {
    return r = (r || "").toLowerCase().replace(/-(.)/g, function(t, n) {
      return n.toUpperCase();
    }), e && r && (r = r.charAt(0).toUpperCase() + r.slice(1)), r;
  }
  var Ou = Kb;
  function Gx(r, e, t) {
    var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
    function i(c) {
      return c && ei(c) ? c : "-";
    }
    function a(c) {
      return !!(c != null && !isNaN(c) && isFinite(c));
    }
    var o = e === "time", s = r instanceof Date;
    if (o || s) {
      var l = o ? Vi(r) : r;
      if (isNaN(+l)) {
        if (s) return "-";
      } else return sg(l, n, t);
    }
    if (e === "ordinal") return ax(r) ? i(r) : nt(r) && a(r) ? r + "" : "-";
    var u = va(r);
    return a(u) ? kE(u) : ax(r) ? i(r) : typeof r == "boolean" ? r + "" : "-";
  }
  var y2 = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g"
  ], Rm = function(r, e) {
    return "{" + r + (e ?? "") + "}";
  };
  function RE(r, e, t) {
    X(e) || (e = [
      e
    ]);
    var n = e.length;
    if (!n) return "";
    for (var i = e[0].$vars || [], a = 0; a < i.length; a++) {
      var o = y2[a];
      r = r.replace(Rm(o), Rm(o, 0));
    }
    for (var s = 0; s < n; s++) for (var l = 0; l < i.length; l++) {
      var u = e[s][i[l]];
      r = r.replace(Rm(y2[l], s), t ? Vr(u) : u);
    }
    return r;
  }
  function iY(r, e, t) {
    return D(e, function(n, i) {
      r = r.replace("{" + i + "}", n);
    }), r;
  }
  function aY(r, e) {
    var t = ee(r) ? {
      color: r,
      extraCssText: e
    } : r || {}, n = t.color, i = t.type;
    e = t.extraCssText;
    var a = t.renderMode || "html";
    if (!n) return "";
    if (a === "html") return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Vr(n) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Vr(n) + ";" + (e || "") + '"></span>';
    var o = t.markerId || "markerX";
    return {
      renderMode: a,
      content: "{" + o + "|}  ",
      style: i === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: n
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: n
      }
    };
  }
  function Gs(r, e) {
    return e = e || "transparent", ee(r) ? r : _e(r) && r.colorStops && (r.colorStops[0] || {}).color || e;
  }
  function Zp(r, e) {
    if (e === "_blank" || e === "blank") {
      var t = window.open();
      t.opener = null, t.location.href = r;
    } else window.open(r, e);
  }
  var bp = D, EE = [
    "left",
    "right",
    "top",
    "bottom",
    "width",
    "height"
  ], ys = [
    [
      "width",
      "left",
      "right"
    ],
    [
      "height",
      "top",
      "bottom"
    ]
  ];
  function w1(r, e, t, n, i) {
    var a = 0, o = 0;
    n == null && (n = 1 / 0), i == null && (i = 1 / 0);
    var s = 0;
    e.eachChild(function(l, u) {
      var c = l.getBoundingRect(), h = e.childAt(u + 1), f = h && h.getBoundingRect(), d, p;
      if (r === "horizontal") {
        var v = c.width + (f ? -f.x + c.x : 0);
        d = a + v, d > n || l.newline ? (a = 0, d = v, o += s + t, s = c.height) : s = Math.max(s, c.height);
      } else {
        var g = c.height + (f ? -f.y + c.y : 0);
        p = o + g, p > i || l.newline ? (a += s + t, o = 0, p = g, s = c.width) : s = Math.max(s, c.width);
      }
      l.newline || (l.x = a, l.y = o, l.markRedraw(), r === "horizontal" ? a = d + t : o = p + t);
    });
  }
  var Ls = w1;
  Le(w1, "vertical");
  Le(w1, "horizontal");
  function oY(r, e, t) {
    var n = e.width, i = e.height, a = Q(r.left, n), o = Q(r.top, i), s = Q(r.right, n), l = Q(r.bottom, i);
    return (isNaN(a) || isNaN(parseFloat(r.left))) && (a = 0), (isNaN(s) || isNaN(parseFloat(r.right))) && (s = n), (isNaN(o) || isNaN(parseFloat(r.top))) && (o = 0), (isNaN(l) || isNaN(parseFloat(r.bottom))) && (l = i), t = Ou(t || 0), {
      width: Math.max(s - a - t[1] - t[3], 0),
      height: Math.max(l - o - t[0] - t[2], 0)
    };
  }
  function er(r, e, t) {
    t = Ou(t || 0);
    var n = e.width, i = e.height, a = Q(r.left, n), o = Q(r.top, i), s = Q(r.right, n), l = Q(r.bottom, i), u = Q(r.width, n), c = Q(r.height, i), h = t[2] + t[0], f = t[1] + t[3], d = r.aspect;
    switch (isNaN(u) && (u = n - s - f - a), isNaN(c) && (c = i - l - h - o), d != null && (isNaN(u) && isNaN(c) && (d > n / i ? u = n * 0.8 : c = i * 0.8), isNaN(u) && (u = d * c), isNaN(c) && (c = u / d)), isNaN(a) && (a = n - s - u - f), isNaN(o) && (o = i - l - c - h), r.left || r.right) {
      case "center":
        a = n / 2 - u / 2 - t[3];
        break;
      case "right":
        a = n - u - f;
        break;
    }
    switch (r.top || r.bottom) {
      case "middle":
      case "center":
        o = i / 2 - c / 2 - t[0];
        break;
      case "bottom":
        o = i - c - h;
        break;
    }
    a = a || 0, o = o || 0, isNaN(u) && (u = n - f - a - (s || 0)), isNaN(c) && (c = i - h - o - (l || 0));
    var p = new Oe(a + t[3], o + t[0], u, c);
    return p.margin = t, p;
  }
  function fg(r, e, t, n, i, a) {
    var o = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
    if (a = a || r, a.x = r.x, a.y = r.y, !o && !s) return false;
    var u;
    if (l === "raw") u = r.type === "group" ? new Oe(0, 0, +e.width || 0, +e.height || 0) : r.getBoundingRect();
    else if (u = r.getBoundingRect(), r.needLocalTransform()) {
      var c = r.getLocalTransform();
      u = u.clone(), u.applyTransform(c);
    }
    var h = er(ye({
      width: u.width,
      height: u.height
    }, e), t, n), f = o ? h.x - u.x : 0, d = s ? h.y - u.y : 0;
    return l === "raw" ? (a.x = f, a.y = d) : (a.x += f, a.y += d), a === r && r.markRedraw(), true;
  }
  function sY(r, e) {
    return r[ys[e][0]] != null || r[ys[e][1]] != null && r[ys[e][2]] != null;
  }
  function Ph(r) {
    var e = r.layoutMode || r.constructor.layoutMode;
    return _e(e) ? e : e ? {
      type: e
    } : null;
  }
  function co(r, e, t) {
    var n = t && t.ignoreSize;
    !X(n) && (n = [
      n,
      n
    ]);
    var i = o(ys[0], 0), a = o(ys[1], 1);
    u(ys[0], r, i), u(ys[1], r, a);
    function o(c, h) {
      var f = {}, d = 0, p = {}, v = 0, g = 2;
      if (bp(c, function(x) {
        p[x] = r[x];
      }), bp(c, function(x) {
        s(e, x) && (f[x] = p[x] = e[x]), l(f, x) && d++, l(p, x) && v++;
      }), n[h]) return l(e, c[1]) ? p[c[2]] = null : l(e, c[2]) && (p[c[1]] = null), p;
      if (v === g || !d) return p;
      if (d >= g) return f;
      for (var m = 0; m < c.length; m++) {
        var y = c[m];
        if (!s(f, y) && s(r, y)) {
          f[y] = r[y];
          break;
        }
      }
      return f;
    }
    function s(c, h) {
      return c.hasOwnProperty(h);
    }
    function l(c, h) {
      return c[h] != null && c[h] !== "auto";
    }
    function u(c, h, f) {
      bp(c, function(d) {
        h[d] = f[d];
      });
    }
  }
  function Fu(r) {
    return NE({}, r);
  }
  function NE(r, e) {
    return e && r && bp(EE, function(t) {
      e.hasOwnProperty(t) && (r[t] = e[t]);
    }), r;
  }
  var lY = tt(), Ke = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this, t, n, i) || this;
      return a.uid = Nu("ec_cpt_model"), a;
    }
    return e.prototype.init = function(t, n, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.mergeDefaultAndTheme = function(t, n) {
      var i = Ph(this), a = i ? Fu(t) : {}, o = n.getTheme();
      Ee(t, o.get(this.mainType)), Ee(t, this.getDefaultOption()), i && co(t, a, i);
    }, e.prototype.mergeOption = function(t, n) {
      Ee(this.option, t, true);
      var i = Ph(this);
      i && co(this.option, t, i);
    }, e.prototype.optionUpdated = function(t, n) {
    }, e.prototype.getDefaultOption = function() {
      var t = this.constructor;
      if (!QH(t)) return t.defaultOption;
      var n = lY(this);
      if (!n.defaultOption) {
        for (var i = [], a = t; a; ) {
          var o = a.prototype.defaultOption;
          o && i.push(o), a = a.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--) s = Ee(s, i[l], true);
        n.defaultOption = s;
      }
      return n.defaultOption;
    }, e.prototype.getReferringComponents = function(t, n) {
      var i = t + "Index", a = t + "Id";
      return vf(this.ecModel, t, {
        index: this.get(i, true),
        id: this.get(a, true)
      }, n);
    }, e.prototype.getBoxLayoutParams = function() {
      var t = this;
      return {
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      };
    }, e.prototype.getZLevelKey = function() {
      return "";
    }, e.prototype.setZLevel = function(t) {
      this.option.zlevel = t;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0;
    }(), e;
  }(ft);
  OR(Ke, ft);
  Zv(Ke);
  q8(Ke);
  K8(Ke, uY);
  function uY(r) {
    var e = [];
    return D(Ke.getClassesByMainType(r), function(t) {
      e = e.concat(t.dependencies || t.prototype.dependencies || []);
    }), e = K(e, function(t) {
      return Di(t).main;
    }), r !== "dataset" && Be(e, "dataset") <= 0 && e.unshift("dataset"), e;
  }
  var OE = "";
  typeof navigator < "u" && (OE = navigator.platform || "");
  var vl = "rgba(0, 0, 0, 0.2)";
  const cY = {
    darkMode: "auto",
    colorBy: "series",
    color: [
      "#5470c6",
      "#91cc75",
      "#fac858",
      "#ee6666",
      "#73c0de",
      "#3ba272",
      "#fc8452",
      "#9a60b4",
      "#ea7ccc"
    ],
    gradientColor: [
      "#f6efa6",
      "#d88273",
      "#bf444c"
    ],
    aria: {
      decal: {
        decals: [
          {
            color: vl,
            dashArrayX: [
              1,
              0
            ],
            dashArrayY: [
              2,
              5
            ],
            symbolSize: 1,
            rotation: Math.PI / 6
          },
          {
            color: vl,
            symbol: "circle",
            dashArrayX: [
              [
                8,
                8
              ],
              [
                0,
                8,
                8,
                0
              ]
            ],
            dashArrayY: [
              6,
              0
            ],
            symbolSize: 0.8
          },
          {
            color: vl,
            dashArrayX: [
              1,
              0
            ],
            dashArrayY: [
              4,
              3
            ],
            rotation: -Math.PI / 4
          },
          {
            color: vl,
            dashArrayX: [
              [
                6,
                6
              ],
              [
                0,
                6,
                6,
                0
              ]
            ],
            dashArrayY: [
              6,
              0
            ]
          },
          {
            color: vl,
            dashArrayX: [
              [
                1,
                0
              ],
              [
                1,
                6
              ]
            ],
            dashArrayY: [
              1,
              0,
              6,
              0
            ],
            rotation: Math.PI / 4
          },
          {
            color: vl,
            symbol: "triangle",
            dashArrayX: [
              [
                9,
                9
              ],
              [
                0,
                9,
                9,
                0
              ]
            ],
            dashArrayY: [
              7,
              2
            ],
            symbolSize: 0.75
          }
        ]
      }
    },
    textStyle: {
      fontFamily: OE.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
      fontSize: 12,
      fontStyle: "normal",
      fontWeight: "normal"
    },
    blendMode: null,
    stateAnimation: {
      duration: 300,
      easing: "cubicOut"
    },
    animation: "auto",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut",
    animationEasingUpdate: "cubicInOut",
    animationThreshold: 2e3,
    progressiveThreshold: 3e3,
    progressive: 400,
    hoverLayerThreshold: 3e3,
    useUTC: false
  };
  var FE = ce([
    "tooltip",
    "label",
    "itemName",
    "itemId",
    "itemGroupId",
    "itemChildGroupId",
    "seriesName"
  ]), $n = "original", Rr = "arrayRows", Gn = "objectRows", Wi = "keyedColumns", ro = "typedArray", BE = "unknown", Ei = "column", Bu = "row", yr = {
    Must: 1,
    Might: 2,
    Not: 3
  }, zE = tt();
  function hY(r) {
    zE(r).datasetMap = ce();
  }
  function VE(r, e, t) {
    var n = {}, i = T1(e);
    if (!i || !r) return n;
    var a = [], o = [], s = e.ecModel, l = zE(s).datasetMap, u = i.uid + "_" + t.seriesLayoutBy, c, h;
    r = r.slice(), D(r, function(v, g) {
      var m = _e(v) ? v : r[g] = {
        name: v
      };
      m.type === "ordinal" && c == null && (c = g, h = p(m)), n[m.name] = [];
    });
    var f = l.get(u) || l.set(u, {
      categoryWayDim: h,
      valueWayDim: 0
    });
    D(r, function(v, g) {
      var m = v.name, y = p(v);
      if (c == null) {
        var x = f.valueWayDim;
        d(n[m], x, y), d(o, x, y), f.valueWayDim += y;
      } else if (c === g) d(n[m], 0, y), d(a, 0, y);
      else {
        var x = f.categoryWayDim;
        d(n[m], x, y), d(o, x, y), f.categoryWayDim += y;
      }
    });
    function d(v, g, m) {
      for (var y = 0; y < m; y++) v.push(g + y);
    }
    function p(v) {
      var g = v.dimsDef;
      return g ? g.length : 1;
    }
    return a.length && (n.itemName = a), o.length && (n.seriesName = o), n;
  }
  function C1(r, e, t) {
    var n = {}, i = T1(r);
    if (!i) return n;
    var a = e.sourceFormat, o = e.dimensionsDefine, s;
    (a === Gn || a === Wi) && D(o, function(c, h) {
      (_e(c) ? c.name : c) === "name" && (s = h);
    });
    var l = function() {
      for (var c = {}, h = {}, f = [], d = 0, p = Math.min(5, t); d < p; d++) {
        var v = GE(e.data, a, e.seriesLayoutBy, o, e.startIndex, d);
        f.push(v);
        var g = v === yr.Not;
        if (g && c.v == null && d !== s && (c.v = d), (c.n == null || c.n === c.v || !g && f[c.n] === yr.Not) && (c.n = d), m(c) && f[c.n] !== yr.Not) return c;
        g || (v === yr.Might && h.v == null && d !== s && (h.v = d), (h.n == null || h.n === h.v) && (h.n = d));
      }
      function m(y) {
        return y.v != null && y.n != null;
      }
      return m(c) ? c : m(h) ? h : null;
    }();
    if (l) {
      n.value = [
        l.v
      ];
      var u = s ?? l.n;
      n.itemName = [
        u
      ], n.seriesName = [
        u
      ];
    }
    return n;
  }
  function T1(r) {
    var e = r.get("data", true);
    if (!e) return vf(r.ecModel, "dataset", {
      index: r.get("datasetIndex", true),
      id: r.get("datasetId", true)
    }, Yt).models[0];
  }
  function fY(r) {
    return !r.get("transform", true) && !r.get("fromTransformResult", true) ? [] : vf(r.ecModel, "dataset", {
      index: r.get("fromDatasetIndex", true),
      id: r.get("fromDatasetId", true)
    }, Yt).models;
  }
  function $E(r, e) {
    return GE(r.data, r.sourceFormat, r.seriesLayoutBy, r.dimensionsDefine, r.startIndex, e);
  }
  function GE(r, e, t, n, i, a) {
    var o, s = 5;
    if (sn(r)) return yr.Not;
    var l, u;
    if (n) {
      var c = n[a];
      _e(c) ? (l = c.name, u = c.type) : ee(c) && (l = c);
    }
    if (u != null) return u === "ordinal" ? yr.Must : yr.Not;
    if (e === Rr) {
      var h = r;
      if (t === Bu) {
        for (var f = h[a], d = 0; d < (f || []).length && d < s; d++) if ((o = _(f[i + d])) != null) return o;
      } else for (var d = 0; d < h.length && d < s; d++) {
        var p = h[i + d];
        if (p && (o = _(p[a])) != null) return o;
      }
    } else if (e === Gn) {
      var v = r;
      if (!l) return yr.Not;
      for (var d = 0; d < v.length && d < s; d++) {
        var g = v[d];
        if (g && (o = _(g[l])) != null) return o;
      }
    } else if (e === Wi) {
      var m = r;
      if (!l) return yr.Not;
      var f = m[l];
      if (!f || sn(f)) return yr.Not;
      for (var d = 0; d < f.length && d < s; d++) if ((o = _(f[d])) != null) return o;
    } else if (e === $n) for (var y = r, d = 0; d < y.length && d < s; d++) {
      var g = y[d], x = ku(g);
      if (!X(x)) return yr.Not;
      if ((o = _(x[a])) != null) return o;
    }
    function _(S) {
      var b = ee(S);
      if (S != null && Number.isFinite(Number(S)) && S !== "") return b ? yr.Might : yr.Not;
      if (b && S !== "-") return yr.Must;
    }
    return yr.Not;
  }
  var Wx = ce();
  function dY(r, e) {
    Yr(Wx.get(r) == null && e), Wx.set(r, e);
  }
  function pY(r, e, t) {
    var n = Wx.get(e);
    if (!n) return t;
    var i = n(r);
    return i ? t.concat(i) : t;
  }
  var x2 = tt(), vY = tt(), A1 = function() {
    function r() {
    }
    return r.prototype.getColorFromPalette = function(e, t, n) {
      var i = gt(this.get("color", true)), a = this.get("colorLayer", true);
      return WE(this, x2, i, a, e, t, n);
    }, r.prototype.clearColorPalette = function() {
      mY(this, x2);
    }, r;
  }();
  function Ux(r, e, t, n) {
    var i = gt(r.get([
      "aria",
      "decal",
      "decals"
    ]));
    return WE(r, vY, i, null, e, t, n);
  }
  function gY(r, e) {
    for (var t = r.length, n = 0; n < t; n++) if (r[n].length > e) return r[n];
    return r[t - 1];
  }
  function WE(r, e, t, n, i, a, o) {
    a = a || r;
    var s = e(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
    if (u.hasOwnProperty(i)) return u[i];
    var c = o == null || !n ? t : gY(n, o);
    if (c = c || t, !(!c || !c.length)) {
      var h = c[l];
      return i && (u[i] = h), s.paletteIdx = (l + 1) % c.length, h;
    }
  }
  function mY(r, e) {
    e(r).paletteIdx = 0, e(r).paletteNameMap = {};
  }
  var id, rc, _2, b2 = "\0_ec_inner", yY = 1, I1 = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, n, i, a, o, s) {
      a = a || {}, this.option = null, this._theme = new ft(a), this._locale = new ft(o), this._optionManager = s;
    }, e.prototype.setOption = function(t, n, i) {
      var a = C2(n);
      this._optionManager.setOption(t, i, a), this._resetOption(null, a);
    }, e.prototype.resetOption = function(t, n) {
      return this._resetOption(t, C2(n));
    }, e.prototype._resetOption = function(t, n) {
      var i = false, a = this._optionManager;
      if (!t || t === "recreate") {
        var o = a.mountOption(t === "recreate");
        !this.option || t === "recreate" ? _2(this, o) : (this.restoreData(), this._mergeOption(o, n)), i = true;
      }
      if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") {
        var s = a.getTimelineOption(this);
        s && (i = true, this._mergeOption(s, n));
      }
      if (!t || t === "recreate" || t === "media") {
        var l = a.getMediaOption(this);
        l.length && D(l, function(u) {
          i = true, this._mergeOption(u, n);
        }, this);
      }
      return i;
    }, e.prototype.mergeOption = function(t) {
      this._mergeOption(t, null);
    }, e.prototype._mergeOption = function(t, n) {
      var i = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = ce(), u = n && n.replaceMergeMainTypeMap;
      hY(this), D(t, function(h, f) {
        h != null && (Ke.hasClass(f) ? f && (s.push(f), l.set(f, true)) : i[f] = i[f] == null ? be(h) : Ee(i[f], h, true));
      }), u && u.each(function(h, f) {
        Ke.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, true));
      }), Ke.topologicalTravel(s, Ke.getAllClassMainTypes(), c, this);
      function c(h) {
        var f = pY(this, h, gt(t[h])), d = a.get(h), p = d ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll", v = kR(d, f, p);
        WH(v, h, Ke), i[h] = null, a.set(h, null), o.set(h, 0);
        var g = [], m = [], y = 0, x;
        D(v, function(_, S) {
          var b = _.existing, w = _.newOption;
          if (!w) b && (b.mergeOption({}, this), b.optionUpdated({}, false));
          else {
            var C = h === "series", T = Ke.getClass(h, _.keyInfo.subType, !C);
            if (!T) return;
            if (h === "tooltip") {
              if (x) return;
              x = true;
            }
            if (b && b.constructor === T) b.name = _.keyInfo.name, b.mergeOption(w, this), b.optionUpdated(w, false);
            else {
              var A = H({
                componentIndex: S
              }, _.keyInfo);
              b = new T(w, this, this, A), H(b, A), _.brandNew && (b.__requireNewView = true), b.init(w, this, this), b.optionUpdated(null, true);
            }
          }
          b ? (g.push(b.option), m.push(b), y++) : (g.push(void 0), m.push(void 0));
        }, this), i[h] = g, a.set(h, m), o.set(h, y), h === "series" && id(this);
      }
      this._seriesIndices || id(this);
    }, e.prototype.getOption = function() {
      var t = be(this.option);
      return D(t, function(n, i) {
        if (Ke.hasClass(i)) {
          for (var a = gt(n), o = a.length, s = false, l = o - 1; l >= 0; l--) a[l] && !Th(a[l]) ? s = true : (a[l] = null, !s && o--);
          a.length = o, t[i] = a;
        }
      }), delete t[b2], t;
    }, e.prototype.getTheme = function() {
      return this._theme;
    }, e.prototype.getLocaleModel = function() {
      return this._locale;
    }, e.prototype.setUpdatePayload = function(t) {
      this._payload = t;
    }, e.prototype.getUpdatePayload = function() {
      return this._payload;
    }, e.prototype.getComponent = function(t, n) {
      var i = this._componentsMap.get(t);
      if (i) {
        var a = i[n || 0];
        if (a) return a;
        if (n == null) {
          for (var o = 0; o < i.length; o++) if (i[o]) return i[o];
        }
      }
    }, e.prototype.queryComponents = function(t) {
      var n = t.mainType;
      if (!n) return [];
      var i = t.index, a = t.id, o = t.name, s = this._componentsMap.get(n);
      if (!s || !s.length) return [];
      var l;
      return i != null ? (l = [], D(gt(i), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = S2("id", a, s) : o != null ? l = S2("name", o, s) : l = ct(s, function(u) {
        return !!u;
      }), w2(l, t);
    }, e.prototype.findComponents = function(t) {
      var n = t.query, i = t.mainType, a = s(n), o = a ? this.queryComponents(a) : ct(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(w2(o, t));
      function s(u) {
        var c = i + "Index", h = i + "Id", f = i + "Name";
        return u && (u[c] != null || u[h] != null || u[f] != null) ? {
          mainType: i,
          index: u[c],
          id: u[h],
          name: u[f]
        } : null;
      }
      function l(u) {
        return t.filter ? ct(u, t.filter) : u;
      }
    }, e.prototype.eachComponent = function(t, n, i) {
      var a = this._componentsMap;
      if (ge(t)) {
        var o = n, s = t;
        a.each(function(h, f) {
          for (var d = 0; h && d < h.length; d++) {
            var p = h[d];
            p && s.call(o, f, p, p.componentIndex);
          }
        });
      } else for (var l = ee(t) ? a.get(t) : _e(t) ? this.findComponents(t) : null, u = 0; l && u < l.length; u++) {
        var c = l[u];
        c && n.call(i, c, c.componentIndex);
      }
    }, e.prototype.getSeriesByName = function(t) {
      var n = jt(t, null);
      return ct(this._componentsMap.get("series"), function(i) {
        return !!i && n != null && i.name === n;
      });
    }, e.prototype.getSeriesByIndex = function(t) {
      return this._componentsMap.get("series")[t];
    }, e.prototype.getSeriesByType = function(t) {
      return ct(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === t;
      });
    }, e.prototype.getSeries = function() {
      return ct(this._componentsMap.get("series"), function(t) {
        return !!t;
      });
    }, e.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, e.prototype.eachSeries = function(t, n) {
      rc(this), D(this._seriesIndices, function(i) {
        var a = this._componentsMap.get("series")[i];
        t.call(n, a, i);
      }, this);
    }, e.prototype.eachRawSeries = function(t, n) {
      D(this._componentsMap.get("series"), function(i) {
        i && t.call(n, i, i.componentIndex);
      });
    }, e.prototype.eachSeriesByType = function(t, n, i) {
      rc(this), D(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === t && n.call(i, o, a);
      }, this);
    }, e.prototype.eachRawSeriesByType = function(t, n, i) {
      return D(this.getSeriesByType(t), n, i);
    }, e.prototype.isSeriesFiltered = function(t) {
      return rc(this), this._seriesIndicesMap.get(t.componentIndex) == null;
    }, e.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, e.prototype.filterSeries = function(t, n) {
      rc(this);
      var i = [];
      D(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        t.call(n, o, a) && i.push(a);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = ce(i);
    }, e.prototype.restoreData = function(t) {
      id(this);
      var n = this._componentsMap, i = [];
      n.each(function(a, o) {
        Ke.hasClass(o) && i.push(o);
      }), Ke.topologicalTravel(i, Ke.getAllClassMainTypes(), function(a) {
        D(n.get(a), function(o) {
          o && (a !== "series" || !xY(o, t)) && o.restoreData();
        });
      });
    }, e.internalField = function() {
      id = function(t) {
        var n = t._seriesIndices = [];
        D(t._componentsMap.get("series"), function(i) {
          i && n.push(i.componentIndex);
        }), t._seriesIndicesMap = ce(n);
      }, rc = function(t) {
      }, _2 = function(t, n) {
        t.option = {}, t.option[b2] = yY, t._componentsMap = ce({
          series: []
        }), t._componentsCount = ce();
        var i = n.aria;
        _e(i) && i.enabled == null && (i.enabled = true), _Y(n, t._theme.option), Ee(n, cY, false), t._mergeOption(n, null);
      };
    }(), e;
  }(ft);
  function xY(r, e) {
    if (e) {
      var t = e.seriesIndex, n = e.seriesId, i = e.seriesName;
      return t != null && r.componentIndex !== t || n != null && r.id !== n || i != null && r.name !== i;
    }
  }
  function _Y(r, e) {
    var t = r.color && !r.colorLayer;
    D(e, function(n, i) {
      i === "colorLayer" && t || Ke.hasClass(i) || (typeof n == "object" ? r[i] = r[i] ? Ee(r[i], n, false) : be(n) : r[i] == null && (r[i] = n));
    });
  }
  function S2(r, e, t) {
    if (X(e)) {
      var n = ce();
      return D(e, function(a) {
        if (a != null) {
          var o = jt(a, null);
          o != null && n.set(a, true);
        }
      }), ct(t, function(a) {
        return a && n.get(a[r]);
      });
    } else {
      var i = jt(e, null);
      return ct(t, function(a) {
        return a && i != null && a[r] === i;
      });
    }
  }
  function w2(r, e) {
    return e.hasOwnProperty("subType") ? ct(r, function(t) {
      return t && t.subType === e.subType;
    }) : r;
  }
  function C2(r) {
    var e = ce();
    return r && D(gt(r.replaceMerge), function(t) {
      e.set(t, true);
    }), {
      replaceMergeMainTypeMap: e
    };
  }
  qt(I1, A1);
  var bY = [
    "getDom",
    "getZr",
    "getWidth",
    "getHeight",
    "getDevicePixelRatio",
    "dispatchAction",
    "isSSR",
    "isDisposed",
    "on",
    "off",
    "getDataURL",
    "getConnectedDataURL",
    "getOption",
    "getId",
    "updateLabelLayout"
  ], UE = /* @__PURE__ */ function() {
    function r(e) {
      D(bY, function(t) {
        this[t] = ne(e[t], e);
      }, this);
    }
    return r;
  }(), Em = {}, Sf = function() {
    function r() {
      this._coordinateSystems = [];
    }
    return r.prototype.create = function(e, t) {
      var n = [];
      D(Em, function(i, a) {
        var o = i.create(e, t);
        n = n.concat(o || []);
      }), this._coordinateSystems = n;
    }, r.prototype.update = function(e, t) {
      D(this._coordinateSystems, function(n) {
        n.update && n.update(e, t);
      });
    }, r.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, r.register = function(e, t) {
      Em[e] = t;
    }, r.get = function(e) {
      return Em[e];
    }, r;
  }(), SY = /^(min|max)?(.+)$/, wY = function() {
    function r(e) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e;
    }
    return r.prototype.setOption = function(e, t, n) {
      e && (D(gt(e.series), function(o) {
        o && o.data && sn(o.data) && Np(o.data);
      }), D(gt(e.dataset), function(o) {
        o && o.source && sn(o.source) && Np(o.source);
      })), e = be(e);
      var i = this._optionBackup, a = CY(e, t, !i);
      this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, r.prototype.mountOption = function(e) {
      var t = this._optionBackup;
      return this._timelineOptions = t.timelineOptions, this._mediaList = t.mediaList, this._mediaDefault = t.mediaDefault, this._currentMediaIndices = [], be(e ? t.baseOption : this._newBaseOption);
    }, r.prototype.getTimelineOption = function(e) {
      var t, n = this._timelineOptions;
      if (n.length) {
        var i = e.getComponent("timeline");
        i && (t = be(n[i.getCurrentIndex()]));
      }
      return t;
    }, r.prototype.getMediaOption = function(e) {
      var t = this._api.getWidth(), n = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!i.length && !a) return s;
      for (var l = 0, u = i.length; l < u; l++) TY(i[l].query, t, n) && o.push(l);
      return !o.length && a && (o = [
        -1
      ]), o.length && !IY(o, this._currentMediaIndices) && (s = K(o, function(c) {
        return be(c === -1 ? a.option : i[c].option);
      })), this._currentMediaIndices = o, s;
    }, r;
  }();
  function CY(r, e, t) {
    var n = [], i, a, o = r.baseOption, s = r.timeline, l = r.options, u = r.media, c = !!r.media, h = !!(l || s || o && o.timeline);
    o ? (a = o, a.timeline || (a.timeline = s)) : ((h || c) && (r.options = r.media = null), a = r), c && X(u) && D(u, function(d) {
      d && d.option && (d.query ? n.push(d) : i || (i = d));
    }), f(a), D(l, function(d) {
      return f(d);
    }), D(n, function(d) {
      return f(d.option);
    });
    function f(d) {
      D(e, function(p) {
        p(d, t);
      });
    }
    return {
      baseOption: a,
      timelineOptions: l || [],
      mediaDefault: i,
      mediaList: n
    };
  }
  function TY(r, e, t) {
    var n = {
      width: e,
      height: t,
      aspectratio: e / t
    }, i = true;
    return D(r, function(a, o) {
      var s = o.match(SY);
      if (!(!s || !s[1] || !s[2])) {
        var l = s[1], u = s[2].toLowerCase();
        AY(n[u], a, l) || (i = false);
      }
    }), i;
  }
  function AY(r, e, t) {
    return t === "min" ? r >= e : t === "max" ? r <= e : r === e;
  }
  function IY(r, e) {
    return r.join(",") === e.join(",");
  }
  var Hn = D, kh = _e, T2 = [
    "areaStyle",
    "lineStyle",
    "nodeStyle",
    "linkStyle",
    "chordStyle",
    "label",
    "labelLine"
  ];
  function Nm(r) {
    var e = r && r.itemStyle;
    if (e) for (var t = 0, n = T2.length; t < n; t++) {
      var i = T2[t], a = e.normal, o = e.emphasis;
      a && a[i] && (r[i] = r[i] || {}, r[i].normal ? Ee(r[i].normal, a[i]) : r[i].normal = a[i], a[i] = null), o && o[i] && (r[i] = r[i] || {}, r[i].emphasis ? Ee(r[i].emphasis, o[i]) : r[i].emphasis = o[i], o[i] = null);
    }
  }
  function Ir(r, e, t) {
    if (r && r[e] && (r[e].normal || r[e].emphasis)) {
      var n = r[e].normal, i = r[e].emphasis;
      n && (t ? (r[e].normal = r[e].emphasis = null, ye(r[e], n)) : r[e] = n), i && (r.emphasis = r.emphasis || {}, r.emphasis[e] = i, i.focus && (r.emphasis.focus = i.focus), i.blurScope && (r.emphasis.blurScope = i.blurScope));
    }
  }
  function Nc(r) {
    Ir(r, "itemStyle"), Ir(r, "lineStyle"), Ir(r, "areaStyle"), Ir(r, "label"), Ir(r, "labelLine"), Ir(r, "upperLabel"), Ir(r, "edgeLabel");
  }
  function Ht(r, e) {
    var t = kh(r) && r[e], n = kh(t) && t.textStyle;
    if (n) for (var i = 0, a = kC.length; i < a; i++) {
      var o = kC[i];
      n.hasOwnProperty(o) && (t[o] = n[o]);
    }
  }
  function Mn(r) {
    r && (Nc(r), Ht(r, "label"), r.emphasis && Ht(r.emphasis, "label"));
  }
  function MY(r) {
    if (kh(r)) {
      Nm(r), Nc(r), Ht(r, "label"), Ht(r, "upperLabel"), Ht(r, "edgeLabel"), r.emphasis && (Ht(r.emphasis, "label"), Ht(r.emphasis, "upperLabel"), Ht(r.emphasis, "edgeLabel"));
      var e = r.markPoint;
      e && (Nm(e), Mn(e));
      var t = r.markLine;
      t && (Nm(t), Mn(t));
      var n = r.markArea;
      n && Mn(n);
      var i = r.data;
      if (r.type === "graph") {
        i = i || r.nodes;
        var a = r.links || r.edges;
        if (a && !sn(a)) for (var o = 0; o < a.length; o++) Mn(a[o]);
        D(r.categories, function(u) {
          Nc(u);
        });
      }
      if (i && !sn(i)) for (var o = 0; o < i.length; o++) Mn(i[o]);
      if (e = r.markPoint, e && e.data) for (var s = e.data, o = 0; o < s.length; o++) Mn(s[o]);
      if (t = r.markLine, t && t.data) for (var l = t.data, o = 0; o < l.length; o++) X(l[o]) ? (Mn(l[o][0]), Mn(l[o][1])) : Mn(l[o]);
      r.type === "gauge" ? (Ht(r, "axisLabel"), Ht(r, "title"), Ht(r, "detail")) : r.type === "treemap" ? (Ir(r.breadcrumb, "itemStyle"), D(r.levels, function(u) {
        Nc(u);
      })) : r.type === "tree" && Nc(r.leaves);
    }
  }
  function qi(r) {
    return X(r) ? r : r ? [
      r
    ] : [];
  }
  function A2(r) {
    return (X(r) ? r[0] : r) || {};
  }
  function DY(r, e) {
    Hn(qi(r.series), function(n) {
      kh(n) && MY(n);
    });
    var t = [
      "xAxis",
      "yAxis",
      "radiusAxis",
      "angleAxis",
      "singleAxis",
      "parallelAxis",
      "radar"
    ];
    e && t.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Hn(t, function(n) {
      Hn(qi(r[n]), function(i) {
        i && (Ht(i, "axisLabel"), Ht(i.axisPointer, "label"));
      });
    }), Hn(qi(r.parallel), function(n) {
      var i = n && n.parallelAxisDefault;
      Ht(i, "axisLabel"), Ht(i && i.axisPointer, "label");
    }), Hn(qi(r.calendar), function(n) {
      Ir(n, "itemStyle"), Ht(n, "dayLabel"), Ht(n, "monthLabel"), Ht(n, "yearLabel");
    }), Hn(qi(r.radar), function(n) {
      Ht(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap);
    }), Hn(qi(r.geo), function(n) {
      kh(n) && (Mn(n), Hn(qi(n.regions), function(i) {
        Mn(i);
      }));
    }), Hn(qi(r.timeline), function(n) {
      Mn(n), Ir(n, "label"), Ir(n, "itemStyle"), Ir(n, "controlStyle", true);
      var i = n.data;
      X(i) && D(i, function(a) {
        _e(a) && (Ir(a, "label"), Ir(a, "itemStyle"));
      });
    }), Hn(qi(r.toolbox), function(n) {
      Ir(n, "iconStyle"), Hn(n.feature, function(i) {
        Ir(i, "iconStyle");
      });
    }), Ht(A2(r.axisPointer), "label"), Ht(A2(r.tooltip).axisPointer, "label");
  }
  function PY(r, e) {
    for (var t = e.split(","), n = r, i = 0; i < t.length && (n = n && n[t[i]], n != null); i++) ;
    return n;
  }
  function kY(r, e, t, n) {
    for (var i = e.split(","), a = r, o, s = 0; s < i.length - 1; s++) o = i[s], a[o] == null && (a[o] = {}), a = a[o];
    a[i[s]] == null && (a[i[s]] = t);
  }
  function I2(r) {
    r && D(LY, function(e) {
      e[0] in r && !(e[1] in r) && (r[e[1]] = r[e[0]]);
    });
  }
  var LY = [
    [
      "x",
      "left"
    ],
    [
      "y",
      "top"
    ],
    [
      "x2",
      "right"
    ],
    [
      "y2",
      "bottom"
    ]
  ], RY = [
    "grid",
    "geo",
    "parallel",
    "legend",
    "toolbox",
    "title",
    "visualMap",
    "dataZoom",
    "timeline"
  ], Om = [
    [
      "borderRadius",
      "barBorderRadius"
    ],
    [
      "borderColor",
      "barBorderColor"
    ],
    [
      "borderWidth",
      "barBorderWidth"
    ]
  ];
  function nc(r) {
    var e = r && r.itemStyle;
    if (e) for (var t = 0; t < Om.length; t++) {
      var n = Om[t][1], i = Om[t][0];
      e[n] != null && (e[i] = e[n]);
    }
  }
  function M2(r) {
    r && r.alignTo === "edge" && r.margin != null && r.edgeDistance == null && (r.edgeDistance = r.margin);
  }
  function D2(r) {
    r && r.downplay && !r.blur && (r.blur = r.downplay);
  }
  function EY(r) {
    r && r.focusNodeAdjacency != null && (r.emphasis = r.emphasis || {}, r.emphasis.focus == null && (r.emphasis.focus = "adjacency"));
  }
  function HE(r, e) {
    if (r) for (var t = 0; t < r.length; t++) e(r[t]), r[t] && HE(r[t].children, e);
  }
  function YE(r, e) {
    DY(r, e), r.series = gt(r.series), D(r.series, function(t) {
      if (_e(t)) {
        var n = t.type;
        if (n === "line") t.clipOverflow != null && (t.clip = t.clipOverflow);
        else if (n === "pie" || n === "gauge") {
          t.clockWise != null && (t.clockwise = t.clockWise), M2(t.label);
          var i = t.data;
          if (i && !sn(i)) for (var a = 0; a < i.length; a++) M2(i[a]);
          t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && (t.emphasis.scaleSize = t.hoverOffset));
        } else if (n === "gauge") {
          var o = PY(t, "pointer.color");
          o != null && kY(t, "itemStyle.color", o);
        } else if (n === "bar") {
          nc(t), nc(t.backgroundStyle), nc(t.emphasis);
          var i = t.data;
          if (i && !sn(i)) for (var a = 0; a < i.length; a++) typeof i[a] == "object" && (nc(i[a]), nc(i[a] && i[a].emphasis));
        } else if (n === "sunburst") {
          var s = t.highlightPolicy;
          s && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = s)), D2(t), HE(t.data, D2);
        } else n === "graph" || n === "sankey" ? EY(t) : n === "map" && (t.mapType && !t.map && (t.map = t.mapType), t.mapLocation && ye(t, t.mapLocation));
        t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && (t.emphasis.scale = t.hoverAnimation)), I2(t);
      }
    }), r.dataRange && (r.visualMap = r.dataRange), D(RY, function(t) {
      var n = r[t];
      n && (X(n) || (n = [
        n
      ]), D(n, function(i) {
        I2(i);
      }));
    });
  }
  function NY(r) {
    var e = ce();
    r.eachSeries(function(t) {
      var n = t.get("stack");
      if (n) {
        var i = e.get(n) || e.set(n, []), a = t.getData(), o = {
          stackResultDimension: a.getCalculationInfo("stackResultDimension"),
          stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
          stackedDimension: a.getCalculationInfo("stackedDimension"),
          stackedByDimension: a.getCalculationInfo("stackedByDimension"),
          isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
          data: a,
          seriesModel: t
        };
        if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension)) return;
        i.length && a.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(o);
      }
    }), e.each(OY);
  }
  function OY(r) {
    D(r, function(e, t) {
      var n = [], i = [
        NaN,
        NaN
      ], a = [
        e.stackResultDimension,
        e.stackedOverDimension
      ], o = e.data, s = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign";
      o.modify(a, function(u, c, h) {
        var f = o.get(e.stackedDimension, h);
        if (isNaN(f)) return i;
        var d, p;
        s ? p = o.getRawIndex(h) : d = o.get(e.stackedByDimension, h);
        for (var v = NaN, g = t - 1; g >= 0; g--) {
          var m = r[g];
          if (s || (p = m.data.rawIndexOf(m.stackedByDimension, d)), p >= 0) {
            var y = m.data.getByRawIndex(m.stackResultDimension, p);
            if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && f >= 0 && y > 0 || l === "samesign" && f <= 0 && y < 0) {
              f = LH(f, y), v = y;
              break;
            }
          }
        }
        return n[0] = f, n[1] = v, n;
      });
    });
  }
  var dg = /* @__PURE__ */ function() {
    function r(e) {
      this.data = e.data || (e.sourceFormat === Wi ? {} : []), this.sourceFormat = e.sourceFormat || BE, this.seriesLayoutBy = e.seriesLayoutBy || Ei, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption;
      var t = this.dimensionsDefine = e.dimensionsDefine;
      if (t) for (var n = 0; n < t.length; n++) {
        var i = t[n];
        i.type == null && $E(this, n) === yr.Must && (i.type = "ordinal");
      }
    }
    return r;
  }();
  function M1(r) {
    return r instanceof dg;
  }
  function Hx(r, e, t) {
    t = t || XE(r);
    var n = e.seriesLayoutBy, i = BY(r, t, n, e.sourceHeader, e.dimensions), a = new dg({
      data: r,
      sourceFormat: t,
      seriesLayoutBy: n,
      dimensionsDefine: i.dimensionsDefine,
      startIndex: i.startIndex,
      dimensionsDetectedCount: i.dimensionsDetectedCount,
      metaRawOption: be(e)
    });
    return a;
  }
  function D1(r) {
    return new dg({
      data: r,
      sourceFormat: sn(r) ? ro : $n
    });
  }
  function FY(r) {
    return new dg({
      data: r.data,
      sourceFormat: r.sourceFormat,
      seriesLayoutBy: r.seriesLayoutBy,
      dimensionsDefine: be(r.dimensionsDefine),
      startIndex: r.startIndex,
      dimensionsDetectedCount: r.dimensionsDetectedCount
    });
  }
  function XE(r) {
    var e = BE;
    if (sn(r)) e = ro;
    else if (X(r)) {
      r.length === 0 && (e = Rr);
      for (var t = 0, n = r.length; t < n; t++) {
        var i = r[t];
        if (i != null) {
          if (X(i) || sn(i)) {
            e = Rr;
            break;
          } else if (_e(i)) {
            e = Gn;
            break;
          }
        }
      }
    } else if (_e(r)) {
      for (var a in r) if (oe(r, a) && Lr(r[a])) {
        e = Wi;
        break;
      }
    }
    return e;
  }
  function BY(r, e, t, n, i) {
    var a, o;
    if (!r) return {
      dimensionsDefine: P2(i),
      startIndex: o,
      dimensionsDetectedCount: a
    };
    if (e === Rr) {
      var s = r;
      n === "auto" || n == null ? k2(function(u) {
        u != null && u !== "-" && (ee(u) ? o == null && (o = 1) : o = 0);
      }, t, s, 10) : o = nt(n) ? n : n ? 1 : 0, !i && o === 1 && (i = [], k2(function(u, c) {
        i[c] = u != null ? u + "" : "";
      }, t, s, 1 / 0)), a = i ? i.length : t === Bu ? s.length : s[0] ? s[0].length : null;
    } else if (e === Gn) i || (i = zY(r));
    else if (e === Wi) i || (i = [], D(r, function(u, c) {
      i.push(c);
    }));
    else if (e === $n) {
      var l = ku(r[0]);
      a = X(l) && l.length || 1;
    }
    return {
      startIndex: o,
      dimensionsDefine: P2(i),
      dimensionsDetectedCount: a
    };
  }
  function zY(r) {
    for (var e = 0, t; e < r.length && !(t = r[e++]); ) ;
    if (t) return je(t);
  }
  function P2(r) {
    if (r) {
      var e = ce();
      return K(r, function(t, n) {
        t = _e(t) ? t : {
          name: t
        };
        var i = {
          name: t.name,
          displayName: t.displayName,
          type: t.type
        };
        if (i.name == null) return i;
        i.name += "", i.displayName == null && (i.displayName = i.name);
        var a = e.get(i.name);
        return a ? i.name += "-" + a.count++ : e.set(i.name, {
          count: 1
        }), i;
      });
    }
  }
  function k2(r, e, t, n) {
    if (e === Bu) for (var i = 0; i < t.length && i < n; i++) r(t[i] ? t[i][0] : null, i);
    else for (var a = t[0] || [], i = 0; i < a.length && i < n; i++) r(a[i], i);
  }
  function qE(r) {
    var e = r.sourceFormat;
    return e === Gn || e === Wi;
  }
  var $o, Go, Wo, L2, R2, KE = function() {
    function r(e, t) {
      var n = M1(e) ? e : D1(e);
      this._source = n;
      var i = this._data = n.data;
      n.sourceFormat === ro && (this._offset = 0, this._dimSize = t, this._data = i), R2(this, i, n);
    }
    return r.prototype.getSource = function() {
      return this._source;
    }, r.prototype.count = function() {
      return 0;
    }, r.prototype.getItem = function(e, t) {
    }, r.prototype.appendData = function(e) {
    }, r.prototype.clean = function() {
    }, r.protoInitialize = function() {
      var e = r.prototype;
      e.pure = false, e.persistent = true;
    }(), r.internalField = function() {
      var e;
      R2 = function(o, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, f = l.dimensionsDefine, d = L2[P1(u, c)];
        if (H(o, d), u === ro) o.getItem = t, o.count = i, o.fillStorage = n;
        else {
          var p = ZE(u, c);
          o.getItem = ne(p, null, s, h, f);
          var v = jE(u, c);
          o.count = ne(v, null, s, h, f);
        }
      };
      var t = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * o, h = 0; h < u; h++) s[h] = l[c + h];
        return s;
      }, n = function(o, s, l, u) {
        for (var c = this._data, h = this._dimSize, f = 0; f < h; f++) {
          for (var d = u[f], p = d[0] == null ? 1 / 0 : d[0], v = d[1] == null ? -1 / 0 : d[1], g = s - o, m = l[f], y = 0; y < g; y++) {
            var x = c[y * h + f];
            m[o + y] = x, x < p && (p = x), x > v && (v = x);
          }
          d[0] = p, d[1] = v;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      L2 = (e = {}, e[Rr + "_" + Ei] = {
        pure: true,
        appendData: a
      }, e[Rr + "_" + Bu] = {
        pure: true,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, e[Gn] = {
        pure: true,
        appendData: a
      }, e[Wi] = {
        pure: true,
        appendData: function(o) {
          var s = this._data;
          D(o, function(l, u) {
            for (var c = s[u] || (s[u] = []), h = 0; h < (l || []).length; h++) c.push(l[h]);
          });
        }
      }, e[$n] = {
        appendData: a
      }, e[ro] = {
        persistent: false,
        pure: true,
        appendData: function(o) {
          this._data = o;
        },
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, e);
      function a(o) {
        for (var s = 0; s < o.length; s++) this._data.push(o[s]);
      }
    }(), r;
  }(), E2 = function(r, e, t, n) {
    return r[n];
  }, VY = ($o = {}, $o[Rr + "_" + Ei] = function(r, e, t, n) {
    return r[n + e];
  }, $o[Rr + "_" + Bu] = function(r, e, t, n, i) {
    n += e;
    for (var a = i || [], o = r, s = 0; s < o.length; s++) {
      var l = o[s];
      a[s] = l ? l[n] : null;
    }
    return a;
  }, $o[Gn] = E2, $o[Wi] = function(r, e, t, n, i) {
    for (var a = i || [], o = 0; o < t.length; o++) {
      var s = t[o].name, l = r[s];
      a[o] = l ? l[n] : null;
    }
    return a;
  }, $o[$n] = E2, $o);
  function ZE(r, e) {
    var t = VY[P1(r, e)];
    return t;
  }
  var N2 = function(r, e, t) {
    return r.length;
  }, $Y = (Go = {}, Go[Rr + "_" + Ei] = function(r, e, t) {
    return Math.max(0, r.length - e);
  }, Go[Rr + "_" + Bu] = function(r, e, t) {
    var n = r[0];
    return n ? Math.max(0, n.length - e) : 0;
  }, Go[Gn] = N2, Go[Wi] = function(r, e, t) {
    var n = t[0].name, i = r[n];
    return i ? i.length : 0;
  }, Go[$n] = N2, Go);
  function jE(r, e) {
    var t = $Y[P1(r, e)];
    return t;
  }
  var Fm = function(r, e, t) {
    return r[e];
  }, GY = (Wo = {}, Wo[Rr] = Fm, Wo[Gn] = function(r, e, t) {
    return r[t];
  }, Wo[Wi] = Fm, Wo[$n] = function(r, e, t) {
    var n = ku(r);
    return n instanceof Array ? n[e] : n;
  }, Wo[ro] = Fm, Wo);
  function QE(r) {
    var e = GY[r];
    return e;
  }
  function P1(r, e) {
    return r === Rr ? r + "_" + e : r;
  }
  function cu(r, e, t) {
    if (r) {
      var n = r.getRawDataItem(e);
      if (n != null) {
        var i = r.getStore(), a = i.getSource().sourceFormat;
        if (t != null) {
          var o = r.getDimensionIndex(t), s = i.getDimensionProperty(o);
          return QE(a)(n, o, s);
        } else {
          var l = n;
          return a === $n && (l = ku(n)), l;
        }
      }
    }
  }
  var WY = /\{@(.+?)\}/g, pg = function() {
    function r() {
    }
    return r.prototype.getDataParams = function(e, t) {
      var n = this.getData(t), i = this.getRawValue(e, t), a = n.getRawIndex(e), o = n.getName(e), s = n.getRawDataItem(e), l = n.getItemVisual(e, "style"), u = l && l[n.getItemVisual(e, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, f = h === "series", d = n.userOutput && n.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: f ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: f ? this.id : null,
        seriesName: f ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: t,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        $vars: [
          "seriesName",
          "name",
          "value"
        ]
      };
    }, r.prototype.getFormattedLabel = function(e, t, n, i, a, o) {
      t = t || "normal";
      var s = this.getData(n), l = this.getDataParams(e, n);
      if (o && (l.value = o.interpolatedValue), i != null && X(l.value) && (l.value = l.value[i]), !a) {
        var u = s.getItemModel(e);
        a = u.get(t === "normal" ? [
          "label",
          "formatter"
        ] : [
          t,
          "label",
          "formatter"
        ]);
      }
      if (ge(a)) return l.status = t, l.dimensionIndex = i, a(l);
      if (ee(a)) {
        var c = RE(a, l);
        return c.replace(WY, function(h, f) {
          var d = f.length, p = f;
          p.charAt(0) === "[" && p.charAt(d - 1) === "]" && (p = +p.slice(1, d - 1));
          var v = cu(s, e, p);
          if (o && X(o.interpolatedValue)) {
            var g = s.getDimensionIndex(p);
            g >= 0 && (v = o.interpolatedValue[g]);
          }
          return v != null ? v + "" : "";
        });
      }
    }, r.prototype.getRawValue = function(e, t) {
      return cu(this.getData(t), e);
    }, r.prototype.formatTooltip = function(e, t, n) {
    }, r;
  }();
  function O2(r) {
    var e, t;
    return _e(r) ? r.type && (t = r) : e = r, {
      text: e,
      frag: t
    };
  }
  function nh(r) {
    return new UY(r);
  }
  var UY = function() {
    function r(e) {
      e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = true;
    }
    return r.prototype.perform = function(e) {
      var t = this._upstream, n = e && e.skip;
      if (this._dirty && t) {
        var i = this.context;
        i.data = i.outputData = t.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var o = c(this._modBy), s = this._modDataCount || 0, l = c(e && e.modBy), u = e && e.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = false, h = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var f = e && e.step;
      if (t ? this._dueEnd = t._outputDueEnd : this._dueEnd = this._count ? this._count(this.context) : 1 / 0, this._progress) {
        var d = this._dueIndex, p = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
        if (!n && (h || d < p)) {
          var v = this._progress;
          if (X(v)) for (var g = 0; g < v.length; g++) this._doProgress(v[g], d, p, l, u);
          else this._doProgress(v, d, p, l, u);
        }
        this._dueIndex = p;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        this._outputDueEnd = m;
      } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, r.prototype.dirty = function() {
      this._dirty = true, this._onDirty && this._onDirty(this.context);
    }, r.prototype._doProgress = function(e, t, n, i, a) {
      F2.reset(t, n, i, a), this._callingProgress = e, this._callingProgress({
        start: t,
        end: n,
        count: n - t,
        next: F2.next
      }, this.context);
    }, r.prototype._doReset = function(e) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var t, n;
      !e && this._reset && (t = this._reset(this.context), t && t.progress && (n = t.forceFirstProgress, t = t.progress), X(t) && !t.length && (t = null)), this._progress = t, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), n;
    }, r.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, r.prototype.pipe = function(e) {
      (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty());
    }, r.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = false, this._disposed = true);
    }, r.prototype.getUpstream = function() {
      return this._upstream;
    }, r.prototype.getDownstream = function() {
      return this._downstream;
    }, r.prototype.setOutputEnd = function(e) {
      this._outputDueEnd = this._settedOutputEnd = e;
    }, r;
  }(), F2 = /* @__PURE__ */ function() {
    var r, e, t, n, i, a = {
      reset: function(l, u, c, h) {
        e = l, r = u, t = c, n = h, i = Math.ceil(n / t), a.next = t > 1 && n > 0 ? s : o;
      }
    };
    return a;
    function o() {
      return e < r ? e++ : null;
    }
    function s() {
      var l = e % i * t + Math.ceil(e / i), u = e >= r ? null : l < n ? l : e;
      return e++, u;
    }
  }();
  function no(r, e) {
    var t = e && e.type;
    return t === "ordinal" ? r : (t === "time" && !nt(r) && r != null && r !== "-" && (r = +Vi(r)), r == null || r === "" ? NaN : Number(r));
  }
  var HY = ce({
    number: function(r) {
      return parseFloat(r);
    },
    time: function(r) {
      return +Vi(r);
    },
    trim: function(r) {
      return ee(r) ? ei(r) : r;
    }
  });
  function JE(r) {
    return HY.get(r);
  }
  var e3 = {
    lt: function(r, e) {
      return r < e;
    },
    lte: function(r, e) {
      return r <= e;
    },
    gt: function(r, e) {
      return r > e;
    },
    gte: function(r, e) {
      return r >= e;
    }
  }, YY = function() {
    function r(e, t) {
      if (!nt(t)) {
        var n = "";
        ut(n);
      }
      this._opFn = e3[e], this._rvalFloat = va(t);
    }
    return r.prototype.evaluate = function(e) {
      return nt(e) ? this._opFn(e, this._rvalFloat) : this._opFn(va(e), this._rvalFloat);
    }, r;
  }(), t3 = function() {
    function r(e, t) {
      var n = e === "desc";
      this._resultLT = n ? 1 : -1, t == null && (t = n ? "min" : "max"), this._incomparable = t === "min" ? -1 / 0 : 1 / 0;
    }
    return r.prototype.evaluate = function(e, t) {
      var n = nt(e) ? e : va(e), i = nt(t) ? t : va(t), a = isNaN(n), o = isNaN(i);
      if (a && (n = this._incomparable), o && (i = this._incomparable), a && o) {
        var s = ee(e), l = ee(t);
        s && (n = l ? e : 0), l && (i = s ? t : 0);
      }
      return n < i ? this._resultLT : n > i ? -this._resultLT : 0;
    }, r;
  }(), XY = function() {
    function r(e, t) {
      this._rval = t, this._isEQ = e, this._rvalTypeof = typeof t, this._rvalFloat = va(t);
    }
    return r.prototype.evaluate = function(e) {
      var t = e === this._rval;
      if (!t) {
        var n = typeof e;
        n !== this._rvalTypeof && (n === "number" || this._rvalTypeof === "number") && (t = va(e) === this._rvalFloat);
      }
      return this._isEQ ? t : !t;
    }, r;
  }();
  function qY(r, e) {
    return r === "eq" || r === "ne" ? new XY(r === "eq", e) : oe(e3, r) ? new YY(r, e) : null;
  }
  var KY = function() {
    function r() {
    }
    return r.prototype.getRawData = function() {
      throw new Error("not supported");
    }, r.prototype.getRawDataItem = function(e) {
      throw new Error("not supported");
    }, r.prototype.cloneRawData = function() {
    }, r.prototype.getDimensionInfo = function(e) {
    }, r.prototype.cloneAllDimensionInfo = function() {
    }, r.prototype.count = function() {
    }, r.prototype.retrieveValue = function(e, t) {
    }, r.prototype.retrieveValueFromItem = function(e, t) {
    }, r.prototype.convertValue = function(e, t) {
      return no(e, t);
    }, r;
  }();
  function ZY(r, e) {
    var t = new KY(), n = r.data, i = t.sourceFormat = r.sourceFormat, a = r.startIndex, o = "";
    r.seriesLayoutBy !== Ei && ut(o);
    var s = [], l = {}, u = r.dimensionsDefine;
    if (u) D(u, function(v, g) {
      var m = v.name, y = {
        index: g,
        name: m,
        displayName: v.displayName
      };
      if (s.push(y), m != null) {
        var x = "";
        oe(l, m) && ut(x), l[m] = y;
      }
    });
    else for (var c = 0; c < r.dimensionsDetectedCount; c++) s.push({
      index: c
    });
    var h = ZE(i, Ei);
    e.__isBuiltIn && (t.getRawDataItem = function(v) {
      return h(n, a, s, v);
    }, t.getRawData = ne(jY, null, r)), t.cloneRawData = ne(QY, null, r);
    var f = jE(i, Ei);
    t.count = ne(f, null, n, a, s);
    var d = QE(i);
    t.retrieveValue = function(v, g) {
      var m = h(n, a, s, v);
      return p(m, g);
    };
    var p = t.retrieveValueFromItem = function(v, g) {
      if (v != null) {
        var m = s[g];
        if (m) return d(v, g, m.name);
      }
    };
    return t.getDimensionInfo = ne(JY, null, s, l), t.cloneAllDimensionInfo = ne(eX, null, s), t;
  }
  function jY(r) {
    var e = r.sourceFormat;
    if (!k1(e)) {
      var t = "";
      ut(t);
    }
    return r.data;
  }
  function QY(r) {
    var e = r.sourceFormat, t = r.data;
    if (!k1(e)) {
      var n = "";
      ut(n);
    }
    if (e === Rr) {
      for (var i = [], a = 0, o = t.length; a < o; a++) i.push(t[a].slice());
      return i;
    } else if (e === Gn) {
      for (var i = [], a = 0, o = t.length; a < o; a++) i.push(H({}, t[a]));
      return i;
    }
  }
  function JY(r, e, t) {
    if (t != null) {
      if (nt(t) || !isNaN(t) && !oe(e, t)) return r[t];
      if (oe(e, t)) return e[t];
    }
  }
  function eX(r) {
    return be(r);
  }
  var r3 = ce();
  function tX(r) {
    r = be(r);
    var e = r.type, t = "";
    e || ut(t);
    var n = e.split(":");
    n.length !== 2 && ut(t);
    var i = false;
    n[0] === "echarts" && (e = n[1], i = true), r.__isBuiltIn = i, r3.set(e, r);
  }
  function rX(r, e, t) {
    var n = gt(r), i = n.length, a = "";
    i || ut(a);
    for (var o = 0, s = i; o < s; o++) {
      var l = n[o];
      e = nX(l, e), o !== s - 1 && (e.length = Math.max(e.length, 1));
    }
    return e;
  }
  function nX(r, e, t, n) {
    var i = "";
    e.length || ut(i), _e(r) || ut(i);
    var a = r.type, o = r3.get(a);
    o || ut(i);
    var s = K(e, function(u) {
      return ZY(u, o);
    }), l = gt(o.transform({
      upstream: s[0],
      upstreamList: s,
      config: be(r.config)
    }));
    return K(l, function(u, c) {
      var h = "";
      _e(u) || ut(h), u.data || ut(h);
      var f = XE(u.data);
      k1(f) || ut(h);
      var d, p = e[0];
      if (p && c === 0 && !u.dimensions) {
        var v = p.startIndex;
        v && (u.data = p.data.slice(0, v).concat(u.data)), d = {
          seriesLayoutBy: Ei,
          sourceHeader: v,
          dimensions: p.metaRawOption.dimensions
        };
      } else d = {
        seriesLayoutBy: Ei,
        sourceHeader: 0,
        dimensions: u.dimensions
      };
      return Hx(u.data, d, null);
    });
  }
  function k1(r) {
    return r === Rr || r === Gn;
  }
  var vg = "undefined", iX = typeof Uint32Array === vg ? Array : Uint32Array, aX = typeof Uint16Array === vg ? Array : Uint16Array, n3 = typeof Int32Array === vg ? Array : Int32Array, B2 = typeof Float64Array === vg ? Array : Float64Array, i3 = {
    float: B2,
    int: n3,
    ordinal: Array,
    number: Array,
    time: B2
  }, Bm;
  function gl(r) {
    return r > 65535 ? iX : aX;
  }
  function ml() {
    return [
      1 / 0,
      -1 / 0
    ];
  }
  function oX(r) {
    var e = r.constructor;
    return e === Array ? r.slice() : new e(r);
  }
  function z2(r, e, t, n, i) {
    var a = i3[t || "float"];
    if (i) {
      var o = r[e], s = o && o.length;
      if (s !== n) {
        for (var l = new a(n), u = 0; u < s; u++) l[u] = o[u];
        r[e] = l;
      }
    } else r[e] = new a(n);
  }
  var Yx = function() {
    function r() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = ce();
    }
    return r.prototype.initData = function(e, t, n) {
      this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = e.getSource(), a = this.defaultDimValueGetter = Bm[i.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [], qE(i), this._dimensions = K(t, function(o) {
        return {
          type: o.type,
          property: o.property
        };
      }), this._initDataFromProvider(0, e.count());
    }, r.prototype.getProvider = function() {
      return this._provider;
    }, r.prototype.getSource = function() {
      return this._provider.getSource();
    }, r.prototype.ensureCalculationDimension = function(e, t) {
      var n = this._calcDimNameToIdx, i = this._dimensions, a = n.get(e);
      if (a != null) {
        if (i[a].type === t) return a;
      } else a = i.length;
      return i[a] = {
        type: t
      }, n.set(e, a), this._chunks[a] = new i3[t || "float"](this._rawCount), this._rawExtent[a] = ml(), a;
    }, r.prototype.collectOrdinalMeta = function(e, t) {
      var n = this._chunks[e], i = this._dimensions[e], a = this._rawExtent, o = i.ordinalOffset || 0, s = n.length;
      o === 0 && (a[e] = ml());
      for (var l = a[e], u = o; u < s; u++) {
        var c = n[u] = t.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = t, i.ordinalOffset = s, i.type = "ordinal";
    }, r.prototype.getOrdinalMeta = function(e) {
      var t = this._dimensions[e], n = t.ordinalMeta;
      return n;
    }, r.prototype.getDimensionProperty = function(e) {
      var t = this._dimensions[e];
      return t && t.property;
    }, r.prototype.appendData = function(e) {
      var t = this._provider, n = this.count();
      t.appendData(e);
      var i = t.count();
      return t.persistent || (i += n), n < i && this._initDataFromProvider(n, i, true), [
        n,
        i
      ];
    }, r.prototype.appendValues = function(e, t) {
      for (var n = this._chunks, i = this._dimensions, a = i.length, o = this._rawExtent, s = this.count(), l = s + Math.max(e.length, t || 0), u = 0; u < a; u++) {
        var c = i[u];
        z2(n, u, c.type, l, true);
      }
      for (var h = [], f = s; f < l; f++) for (var d = f - s, p = 0; p < a; p++) {
        var c = i[p], v = Bm.arrayRows.call(this, e[d] || h, c.property, d, p);
        n[p][f] = v;
        var g = o[p];
        v < g[0] && (g[0] = v), v > g[1] && (g[1] = v);
      }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, r.prototype._initDataFromProvider = function(e, t, n) {
      for (var i = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = K(o, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var h = o[c];
        l[c] || (l[c] = ml()), z2(a, c, h.type, t, n);
      }
      if (i.fillStorage) i.fillStorage(e, t, a, l);
      else for (var f = [], d = e; d < t; d++) {
        f = i.getItem(d, f);
        for (var p = 0; p < s; p++) {
          var v = a[p], g = this._dimValueGetter(f, u[p], d, p);
          v[d] = g;
          var m = l[p];
          g < m[0] && (m[0] = g), g > m[1] && (m[1] = g);
        }
      }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = t, this._extent = [];
    }, r.prototype.count = function() {
      return this._count;
    }, r.prototype.get = function(e, t) {
      if (!(t >= 0 && t < this._count)) return NaN;
      var n = this._chunks[e];
      return n ? n[this.getRawIndex(t)] : NaN;
    }, r.prototype.getValues = function(e, t) {
      var n = [], i = [];
      if (t == null) {
        t = e, e = [];
        for (var a = 0; a < this._dimensions.length; a++) i.push(a);
      } else i = e;
      for (var a = 0, o = i.length; a < o; a++) n.push(this.get(i[a], t));
      return n;
    }, r.prototype.getByRawIndex = function(e, t) {
      if (!(t >= 0 && t < this._rawCount)) return NaN;
      var n = this._chunks[e];
      return n ? n[t] : NaN;
    }, r.prototype.getSum = function(e) {
      var t = this._chunks[e], n = 0;
      if (t) for (var i = 0, a = this.count(); i < a; i++) {
        var o = this.get(e, i);
        isNaN(o) || (n += o);
      }
      return n;
    }, r.prototype.getMedian = function(e) {
      var t = [];
      this.each([
        e
      ], function(a) {
        isNaN(a) || t.push(a);
      });
      var n = t.sort(function(a, o) {
        return a - o;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2;
    }, r.prototype.indexOfRawIndex = function(e) {
      if (e >= this._rawCount || e < 0) return -1;
      if (!this._indices) return e;
      var t = this._indices, n = t[e];
      if (n != null && n < this._count && n === e) return e;
      for (var i = 0, a = this._count - 1; i <= a; ) {
        var o = (i + a) / 2 | 0;
        if (t[o] < e) i = o + 1;
        else if (t[o] > e) a = o - 1;
        else return o;
      }
      return -1;
    }, r.prototype.indicesOfNearest = function(e, t, n) {
      var i = this._chunks, a = i[e], o = [];
      if (!a) return o;
      n == null && (n = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, c = 0, h = this.count(); c < h; c++) {
        var f = this.getRawIndex(c), d = t - a[f], p = Math.abs(d);
        p <= n && ((p < s || p === s && d >= 0 && l < 0) && (s = p, l = d, u = 0), d === l && (o[u++] = c));
      }
      return o.length = u, o;
    }, r.prototype.getIndices = function() {
      var e, t = this._indices;
      if (t) {
        var n = t.constructor, i = this._count;
        if (n === Array) {
          e = new n(i);
          for (var a = 0; a < i; a++) e[a] = t[a];
        } else e = new n(t.buffer, 0, i);
      } else {
        var n = gl(this._rawCount);
        e = new n(this.count());
        for (var a = 0; a < e.length; a++) e[a] = a;
      }
      return e;
    }, r.prototype.filter = function(e, t) {
      if (!this._count) return this;
      for (var n = this.clone(), i = n.count(), a = gl(n._rawCount), o = new a(i), s = [], l = e.length, u = 0, c = e[0], h = n._chunks, f = 0; f < i; f++) {
        var d = void 0, p = n.getRawIndex(f);
        if (l === 0) d = t(f);
        else if (l === 1) {
          var v = h[c][p];
          d = t(v, f);
        } else {
          for (var g = 0; g < l; g++) s[g] = h[e[g]][p];
          s[g] = f, d = t.apply(null, s);
        }
        d && (o[u++] = p);
      }
      return u < i && (n._indices = o), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, r.prototype.selectRange = function(e) {
      var t = this.clone(), n = t._count;
      if (!n) return this;
      var i = je(e), a = i.length;
      if (!a) return this;
      var o = t.count(), s = gl(t._rawCount), l = new s(o), u = 0, c = i[0], h = e[c][0], f = e[c][1], d = t._chunks, p = false;
      if (!t._indices) {
        var v = 0;
        if (a === 1) {
          for (var g = d[i[0]], m = 0; m < n; m++) {
            var y = g[m];
            (y >= h && y <= f || isNaN(y)) && (l[u++] = v), v++;
          }
          p = true;
        } else if (a === 2) {
          for (var g = d[i[0]], x = d[i[1]], _ = e[i[1]][0], S = e[i[1]][1], m = 0; m < n; m++) {
            var y = g[m], b = x[m];
            (y >= h && y <= f || isNaN(y)) && (b >= _ && b <= S || isNaN(b)) && (l[u++] = v), v++;
          }
          p = true;
        }
      }
      if (!p) if (a === 1) for (var m = 0; m < o; m++) {
        var w = t.getRawIndex(m), y = d[i[0]][w];
        (y >= h && y <= f || isNaN(y)) && (l[u++] = w);
      }
      else for (var m = 0; m < o; m++) {
        for (var C = true, w = t.getRawIndex(m), T = 0; T < a; T++) {
          var A = i[T], y = d[A][w];
          (y < e[A][0] || y > e[A][1]) && (C = false);
        }
        C && (l[u++] = t.getRawIndex(m));
      }
      return u < o && (t._indices = l), t._count = u, t._extent = [], t._updateGetRawIdx(), t;
    }, r.prototype.map = function(e, t) {
      var n = this.clone(e);
      return this._updateDims(n, e, t), n;
    }, r.prototype.modify = function(e, t) {
      this._updateDims(this, e, t);
    }, r.prototype._updateDims = function(e, t, n) {
      for (var i = e._chunks, a = [], o = t.length, s = e.count(), l = [], u = e._rawExtent, c = 0; c < t.length; c++) u[t[c]] = ml();
      for (var h = 0; h < s; h++) {
        for (var f = e.getRawIndex(h), d = 0; d < o; d++) l[d] = i[t[d]][f];
        l[o] = h;
        var p = n && n.apply(null, l);
        if (p != null) {
          typeof p != "object" && (a[0] = p, p = a);
          for (var c = 0; c < p.length; c++) {
            var v = t[c], g = p[c], m = u[v], y = i[v];
            y && (y[f] = g), g < m[0] && (m[0] = g), g > m[1] && (m[1] = g);
          }
        }
      }
    }, r.prototype.lttbDownSample = function(e, t) {
      var n = this.clone([
        e
      ], true), i = n._chunks, a = i[e], o = this.count(), s = 0, l = Math.floor(1 / t), u = this.getRawIndex(0), c, h, f, d = new (gl(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      d[s++] = u;
      for (var p = 1; p < o - 1; p += l) {
        for (var v = Math.min(p + l, o - 1), g = Math.min(p + l * 2, o), m = (g + v) / 2, y = 0, x = v; x < g; x++) {
          var _ = this.getRawIndex(x), S = a[_];
          isNaN(S) || (y += S);
        }
        y /= g - v;
        var b = p, w = Math.min(p + l, o), C = p - 1, T = a[u];
        c = -1, f = b;
        for (var A = -1, M = 0, x = b; x < w; x++) {
          var _ = this.getRawIndex(x), S = a[_];
          if (isNaN(S)) {
            M++, A < 0 && (A = _);
            continue;
          }
          h = Math.abs((C - m) * (S - T) - (C - x) * (y - T)), h > c && (c = h, f = _);
        }
        M > 0 && M < w - b && (d[s++] = Math.min(A, f), f = Math.max(A, f)), d[s++] = f, u = f;
      }
      return d[s++] = this.getRawIndex(o - 1), n._count = s, n._indices = d, n.getRawIndex = this._getRawIdx, n;
    }, r.prototype.minmaxDownSample = function(e, t) {
      for (var n = this.clone([
        e
      ], true), i = n._chunks, a = Math.floor(1 / t), o = i[e], s = this.count(), l = new (gl(this._rawCount))(Math.ceil(s / a) * 2), u = 0, c = 0; c < s; c += a) {
        var h = c, f = o[this.getRawIndex(h)], d = c, p = o[this.getRawIndex(d)], v = a;
        c + a > s && (v = s - c);
        for (var g = 0; g < v; g++) {
          var m = this.getRawIndex(c + g), y = o[m];
          y < f && (f = y, h = c + g), y > p && (p = y, d = c + g);
        }
        var x = this.getRawIndex(h), _ = this.getRawIndex(d);
        h < d ? (l[u++] = x, l[u++] = _) : (l[u++] = _, l[u++] = x);
      }
      return n._count = u, n._indices = l, n._updateGetRawIdx(), n;
    }, r.prototype.downSample = function(e, t, n, i) {
      for (var a = this.clone([
        e
      ], true), o = a._chunks, s = [], l = Math.floor(1 / t), u = o[e], c = this.count(), h = a._rawExtent[e] = ml(), f = new (gl(this._rawCount))(Math.ceil(c / l)), d = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, s.length = l);
        for (var v = 0; v < l; v++) {
          var g = this.getRawIndex(p + v);
          s[v] = u[g];
        }
        var m = n(s), y = this.getRawIndex(Math.min(p + i(s, m) || 0, c - 1));
        u[y] = m, m < h[0] && (h[0] = m), m > h[1] && (h[1] = m), f[d++] = y;
      }
      return a._count = d, a._indices = f, a._updateGetRawIdx(), a;
    }, r.prototype.each = function(e, t) {
      if (this._count) for (var n = e.length, i = this._chunks, a = 0, o = this.count(); a < o; a++) {
        var s = this.getRawIndex(a);
        switch (n) {
          case 0:
            t(a);
            break;
          case 1:
            t(i[e[0]][s], a);
            break;
          case 2:
            t(i[e[0]][s], i[e[1]][s], a);
            break;
          default:
            for (var l = 0, u = []; l < n; l++) u[l] = i[e[l]][s];
            u[l] = a, t.apply(null, u);
        }
      }
    }, r.prototype.getDataExtent = function(e) {
      var t = this._chunks[e], n = ml();
      if (!t) return n;
      var i = this.count(), a = !this._indices, o;
      if (a) return this._rawExtent[e].slice();
      if (o = this._extent[e], o) return o.slice();
      o = n;
      for (var s = o[0], l = o[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), h = t[c];
        h < s && (s = h), h > l && (l = h);
      }
      return o = [
        s,
        l
      ], this._extent[e] = o, o;
    }, r.prototype.getRawDataItem = function(e) {
      var t = this.getRawIndex(e);
      if (this._provider.persistent) return this._provider.getItem(t);
      for (var n = [], i = this._chunks, a = 0; a < i.length; a++) n.push(i[a][t]);
      return n;
    }, r.prototype.clone = function(e, t) {
      var n = new r(), i = this._chunks, a = e && Fi(e, function(s, l) {
        return s[l] = true, s;
      }, {});
      if (a) for (var o = 0; o < i.length; o++) n._chunks[o] = a[o] ? oX(i[o]) : i[o];
      else n._chunks = i;
      return this._copyCommonProps(n), t || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, r.prototype._copyCommonProps = function(e) {
      e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = be(this._extent), e._rawExtent = be(this._rawExtent);
    }, r.prototype._cloneIndices = function() {
      if (this._indices) {
        var e = this._indices.constructor, t = void 0;
        if (e === Array) {
          var n = this._indices.length;
          t = new e(n);
          for (var i = 0; i < n; i++) t[i] = this._indices[i];
        } else t = new e(this._indices);
        return t;
      }
      return null;
    }, r.prototype._getRawIdxIdentity = function(e) {
      return e;
    }, r.prototype._getRawIdx = function(e) {
      return e < this._count && e >= 0 ? this._indices[e] : -1;
    }, r.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, r.internalField = function() {
      function e(t, n, i, a) {
        return no(t[a], this._dimensions[a]);
      }
      Bm = {
        arrayRows: e,
        objectRows: function(t, n, i, a) {
          return no(t[n], this._dimensions[a]);
        },
        keyedColumns: e,
        original: function(t, n, i, a) {
          var o = t && (t.value == null ? t : t.value);
          return no(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(t, n, i, a) {
          return t[a];
        }
      };
    }(), r;
  }(), a3 = function() {
    function r(e) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = true, this._sourceHost = e;
    }
    return r.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = true;
    }, r.prototype._setLocalSource = function(e, t) {
      this._sourceList = e, this._upstreamSignList = t, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, r.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, r.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = false);
    }, r.prototype._createSource = function() {
      this._setLocalSource([], []);
      var e = this._sourceHost, t = this._getUpstreamSourceManagers(), n = !!t.length, i, a;
      if (ad(e)) {
        var o = e, s = void 0, l = void 0, u = void 0;
        if (n) {
          var c = t[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, a = [
            c._getVersionSign()
          ];
        } else s = o.get("data", true), l = sn(s) ? ro : $n, a = [];
        var h = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, d = Pe(h.seriesLayoutBy, f.seriesLayoutBy) || null, p = Pe(h.sourceHeader, f.sourceHeader), v = Pe(h.dimensions, f.dimensions), g = d !== f.seriesLayoutBy || !!p != !!f.sourceHeader || v;
        i = g ? [
          Hx(s, {
            seriesLayoutBy: d,
            sourceHeader: p,
            dimensions: v
          }, l)
        ] : [];
      } else {
        var m = e;
        if (n) {
          var y = this._applyTransform(t);
          i = y.sourceList, a = y.upstreamSignList;
        } else {
          var x = m.get("source", true);
          i = [
            Hx(x, this._getSourceMetaRawOption(), null)
          ], a = [];
        }
      }
      this._setLocalSource(i, a);
    }, r.prototype._applyTransform = function(e) {
      var t = this._sourceHost, n = t.get("transform", true), i = t.get("fromTransformResult", true);
      if (i != null) {
        var a = "";
        e.length !== 1 && $2(a);
      }
      var o, s = [], l = [];
      return D(e, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), h = "";
        i != null && !c && $2(h), s.push(c), l.push(u._getVersionSign());
      }), n ? o = rX(n, s, {
        datasetIndex: t.componentIndex
      }) : i != null && (o = [
        FY(s[0])
      ]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, r.prototype._isDirty = function() {
      if (this._dirty) return true;
      for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) {
        var n = e[t];
        if (n._isDirty() || this._upstreamSignList[t] !== n._getVersionSign()) return true;
      }
    }, r.prototype.getSource = function(e) {
      e = e || 0;
      var t = this._sourceList[e];
      if (!t) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(e);
      }
      return t;
    }, r.prototype.getSharedDataStore = function(e) {
      var t = e.makeStoreSchema();
      return this._innerGetDataStore(t.dimensions, e.source, t.hash);
    }, r.prototype._innerGetDataStore = function(e, t, n) {
      var i = 0, a = this._storeList, o = a[i];
      o || (o = a[i] = {});
      var s = o[n];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        ad(this._sourceHost) && l ? s = l._innerGetDataStore(e, t, n) : (s = new Yx(), s.initData(new KE(t, e.length), e)), o[n] = s;
      }
      return s;
    }, r.prototype._getUpstreamSourceManagers = function() {
      var e = this._sourceHost;
      if (ad(e)) {
        var t = T1(e);
        return t ? [
          t.getSourceManager()
        ] : [];
      } else return K(fY(e), function(n) {
        return n.getSourceManager();
      });
    }, r.prototype._getSourceMetaRawOption = function() {
      var e = this._sourceHost, t, n, i;
      if (ad(e)) t = e.get("seriesLayoutBy", true), n = e.get("sourceHeader", true), i = e.get("dimensions", true);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = e;
        t = a.get("seriesLayoutBy", true), n = a.get("sourceHeader", true), i = a.get("dimensions", true);
      }
      return {
        seriesLayoutBy: t,
        sourceHeader: n,
        dimensions: i
      };
    }, r;
  }();
  function V2(r) {
    var e = r.option.transform;
    e && Np(r.option.transform);
  }
  function ad(r) {
    return r.mainType === "series";
  }
  function $2(r) {
    throw new Error(r);
  }
  var sX = "line-height:1";
  function o3(r) {
    var e = r.lineHeight;
    return e == null ? sX : "line-height:" + Vr(e + "") + "px";
  }
  function s3(r, e) {
    var t = r.color || "#6e7079", n = r.fontSize || 12, i = r.fontWeight || "400", a = r.color || "#464646", o = r.fontSize || 14, s = r.fontWeight || "900";
    return e === "html" ? {
      nameStyle: "font-size:" + Vr(n + "") + "px;color:" + Vr(t) + ";font-weight:" + Vr(i + ""),
      valueStyle: "font-size:" + Vr(o + "") + "px;color:" + Vr(a) + ";font-weight:" + Vr(s + "")
    } : {
      nameStyle: {
        fontSize: n,
        fill: t,
        fontWeight: i
      },
      valueStyle: {
        fontSize: o,
        fill: a,
        fontWeight: s
      }
    };
  }
  var lX = [
    0,
    10,
    20,
    30
  ], uX = [
    "",
    `
`,
    `

`,
    `


`
  ];
  function ur(r, e) {
    return e.type = r, e;
  }
  function Xx(r) {
    return r.type === "section";
  }
  function l3(r) {
    return Xx(r) ? cX : hX;
  }
  function u3(r) {
    if (Xx(r)) {
      var e = 0, t = r.blocks.length, n = t > 1 || t > 0 && !r.noHeader;
      return D(r.blocks, function(i) {
        var a = u3(i);
        a >= e && (e = a + +(n && (!a || Xx(i) && !i.noHeader)));
      }), e;
    }
    return 0;
  }
  function cX(r, e, t, n) {
    var i = e.noHeader, a = fX(u3(e)), o = [], s = e.blocks || [];
    Yr(!s || X(s)), s = s || [];
    var l = r.orderMode;
    if (e.sortBlocks && l) {
      s = s.slice();
      var u = {
        valueAsc: "asc",
        valueDesc: "desc"
      };
      if (oe(u, l)) {
        var c = new t3(u[l], null);
        s.sort(function(v, g) {
          return c.evaluate(v.sortParam, g.sortParam);
        });
      } else l === "seriesDesc" && s.reverse();
    }
    D(s, function(v, g) {
      var m = e.valueFormatter, y = l3(v)(m ? H(H({}, r), {
        valueFormatter: m
      }) : r, v, g > 0 ? a.html : 0, n);
      y != null && o.push(y);
    });
    var h = r.renderMode === "richText" ? o.join(a.richText) : qx(n, o.join(""), i ? t : a.html);
    if (i) return h;
    var f = Gx(e.header, "ordinal", r.useUTC), d = s3(n, r.renderMode).nameStyle, p = o3(n);
    return r.renderMode === "richText" ? c3(r, f, d) + a.richText + h : qx(n, '<div style="' + d + ";" + p + ';">' + Vr(f) + "</div>" + h, t);
  }
  function hX(r, e, t, n) {
    var i = r.renderMode, a = e.noName, o = e.noValue, s = !e.markerType, l = e.name, u = r.useUTC, c = e.valueFormatter || r.valueFormatter || function(_) {
      return _ = X(_) ? _ : [
        _
      ], K(_, function(S, b) {
        return Gx(S, X(d) ? d[b] : d, u);
      });
    };
    if (!(a && o)) {
      var h = s ? "" : r.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", i), f = a ? "" : Gx(l, "ordinal", u), d = e.valueType, p = o ? [] : c(e.value, e.dataIndex), v = !s || !a, g = !s && a, m = s3(n, i), y = m.nameStyle, x = m.valueStyle;
      return i === "richText" ? (s ? "" : h) + (a ? "" : c3(r, f, y)) + (o ? "" : vX(r, p, v, g, x)) : qx(n, (s ? "" : h) + (a ? "" : dX(f, !s, y)) + (o ? "" : pX(p, v, g, x)), t);
    }
  }
  function G2(r, e, t, n, i, a) {
    if (r) {
      var o = l3(r), s = {
        useUTC: i,
        renderMode: t,
        orderMode: n,
        markupStyleCreator: e,
        valueFormatter: r.valueFormatter
      };
      return o(s, r, 0, a);
    }
  }
  function fX(r) {
    return {
      html: lX[r],
      richText: uX[r]
    };
  }
  function qx(r, e, t) {
    var n = '<div style="clear:both"></div>', i = "margin: " + t + "px 0 0", a = o3(r);
    return '<div style="' + i + ";" + a + ';">' + e + n + "</div>";
  }
  function dX(r, e, t) {
    var n = e ? "margin-left:2px" : "";
    return '<span style="' + t + ";" + n + '">' + Vr(r) + "</span>";
  }
  function pX(r, e, t, n) {
    var i = t ? "10px" : "20px", a = e ? "float:right;margin-left:" + i : "";
    return r = X(r) ? r : [
      r
    ], '<span style="' + a + ";" + n + '">' + K(r, function(o) {
      return Vr(o);
    }).join("&nbsp;&nbsp;") + "</span>";
  }
  function c3(r, e, t) {
    return r.markupStyleCreator.wrapRichTextStyle(e, t);
  }
  function vX(r, e, t, n, i) {
    var a = [
      i
    ], o = n ? 10 : 20;
    return t && a.push({
      padding: [
        0,
        0,
        0,
        o
      ],
      align: "right"
    }), r.markupStyleCreator.wrapRichTextStyle(X(e) ? e.join("  ") : e, a);
  }
  function h3(r, e) {
    var t = r.getData().getItemVisual(e, "style"), n = t[r.visualDrawType];
    return Gs(n);
  }
  function f3(r, e) {
    var t = r.get("padding");
    return t ?? (e === "richText" ? [
      8,
      10
    ] : 10);
  }
  var zm = function() {
    function r() {
      this.richTextStyles = {}, this._nextStyleNameId = IR();
    }
    return r.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, r.prototype.makeTooltipMarker = function(e, t, n) {
      var i = n === "richText" ? this._generateStyleName() : null, a = aY({
        color: t,
        type: e,
        renderMode: n,
        markerId: i
      });
      return ee(a) ? a : (this.richTextStyles[i] = a.style, a.content);
    }, r.prototype.wrapRichTextStyle = function(e, t) {
      var n = {};
      X(t) ? D(t, function(a) {
        return H(n, a);
      }) : H(n, t);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = n, "{" + i + "|" + e + "}";
    }, r;
  }();
  function d3(r) {
    var e = r.series, t = r.dataIndex, n = r.multipleSeries, i = e.getData(), a = i.mapDimensionsAll("defaultedTooltip"), o = a.length, s = e.getRawValue(t), l = X(s), u = h3(e, t), c, h, f, d;
    if (o > 1 || l && !o) {
      var p = gX(s, e, t, a, u);
      c = p.inlineValues, h = p.inlineValueTypes, f = p.blocks, d = p.inlineValues[0];
    } else if (o) {
      var v = i.getDimensionInfo(a[0]);
      d = c = cu(i, t, a[0]), h = v.type;
    } else d = c = l ? s[0] : s;
    var g = n1(e), m = g && e.name || "", y = i.getName(t), x = n ? m : y;
    return ur("section", {
      header: m,
      noHeader: n || !g,
      sortParam: d,
      blocks: [
        ur("nameValue", {
          markerType: "item",
          markerColor: u,
          name: x,
          noName: !ei(x),
          value: c,
          valueType: h,
          dataIndex: t
        })
      ].concat(f || [])
    });
  }
  function gX(r, e, t, n, i) {
    var a = e.getData(), o = Fi(r, function(h, f, d) {
      var p = a.getDimensionInfo(d);
      return h = h || p && p.tooltip !== false && p.displayName != null;
    }, false), s = [], l = [], u = [];
    n.length ? D(n, function(h) {
      c(cu(a, t, h), h);
    }) : D(r, c);
    function c(h, f) {
      var d = a.getDimensionInfo(f);
      !d || d.otherDims.tooltip === false || (o ? u.push(ur("nameValue", {
        markerType: "subItem",
        markerColor: i,
        name: d.displayName,
        value: h,
        valueType: d.type
      })) : (s.push(h), l.push(d.type)));
    }
    return {
      inlineValues: s,
      inlineValueTypes: l,
      blocks: u
    };
  }
  var ka = tt();
  function od(r, e) {
    return r.getName(e) || r.getId(e);
  }
  var Sp = "__universalTransitionEnabled", Tt = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t._selectedDataIndicesMap = {}, t;
    }
    return e.prototype.init = function(t, n, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = nh({
        count: yX,
        reset: xX
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(t, i);
      var a = ka(this).sourceManager = new a3(this);
      a.prepareSource();
      var o = this.getInitialData(t, i);
      U2(o, this), this.dataTask.context.data = o, ka(this).dataBeforeProcessed = o, W2(this), this._initSelectedMapFromData(o);
    }, e.prototype.mergeDefaultAndTheme = function(t, n) {
      var i = Ph(this), a = i ? Fu(t) : {}, o = this.subType;
      Ke.hasClass(o) && (o += "Series"), Ee(t, n.getTheme().get(this.subType)), Ee(t, this.getDefaultOption()), Bs(t, "label", [
        "show"
      ]), this.fillDataTextStyle(t.data), i && co(t, a, i);
    }, e.prototype.mergeOption = function(t, n) {
      t = Ee(this.option, t, true), this.fillDataTextStyle(t.data);
      var i = Ph(this);
      i && co(this.option, t, i);
      var a = ka(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(t, n);
      U2(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, ka(this).dataBeforeProcessed = o, W2(this), this._initSelectedMapFromData(o);
    }, e.prototype.fillDataTextStyle = function(t) {
      if (t && !sn(t)) for (var n = [
        "show"
      ], i = 0; i < t.length; i++) t[i] && t[i].label && Bs(t[i], "label", n);
    }, e.prototype.getInitialData = function(t, n) {
    }, e.prototype.appendData = function(t) {
      var n = this.getRawData();
      n.appendData(t.data);
    }, e.prototype.getData = function(t) {
      var n = Kx(this);
      if (n) {
        var i = n.context.data;
        return t == null || !i.getLinkedData ? i : i.getLinkedData(t);
      } else return ka(this).data;
    }, e.prototype.getAllData = function() {
      var t = this.getData();
      return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [
        {
          data: t
        }
      ];
    }, e.prototype.setData = function(t) {
      var n = Kx(this);
      if (n) {
        var i = n.context;
        i.outputData = t, n !== this.dataTask && (i.data = t);
      }
      ka(this).data = t;
    }, e.prototype.getEncode = function() {
      var t = this.get("encode", true);
      if (t) return ce(t);
    }, e.prototype.getSourceManager = function() {
      return ka(this).sourceManager;
    }, e.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, e.prototype.getRawData = function() {
      return ka(this).dataBeforeProcessed;
    }, e.prototype.getColorBy = function() {
      var t = this.get("colorBy");
      return t || "series";
    }, e.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, e.prototype.getBaseAxis = function() {
      var t = this.coordinateSystem;
      return t && t.getBaseAxis && t.getBaseAxis();
    }, e.prototype.formatTooltip = function(t, n, i) {
      return d3({
        series: this,
        dataIndex: t,
        multipleSeries: n
      });
    }, e.prototype.isAnimationEnabled = function() {
      var t = this.ecModel;
      if (He.node && !(t && t.ssr)) return false;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = false), !!n;
    }, e.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, e.prototype.getColorFromPalette = function(t, n, i) {
      var a = this.ecModel, o = A1.prototype.getColorFromPalette.call(this, t, n, i);
      return o || (o = a.getColorFromPalette(t, n, i)), o;
    }, e.prototype.coordDimToDataDim = function(t) {
      return this.getRawData().mapDimensionsAll(t);
    }, e.prototype.getProgressive = function() {
      return this.get("progressive");
    }, e.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, e.prototype.select = function(t, n) {
      this._innerSelect(this.getData(n), t);
    }, e.prototype.unselect = function(t, n) {
      var i = this.option.selectedMap;
      if (i) {
        var a = this.option.selectedMode, o = this.getData(n);
        if (a === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < t.length; s++) {
          var l = t[s], u = od(o, l);
          i[u] = false, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, e.prototype.toggleSelect = function(t, n) {
      for (var i = [], a = 0; a < t.length; a++) i[0] = t[a], this.isSelected(t[a], n) ? this.unselect(i, n) : this.select(i, n);
    }, e.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
      for (var t = this._selectedDataIndicesMap, n = je(t), i = [], a = 0; a < n.length; a++) {
        var o = t[n[a]];
        o >= 0 && i.push(o);
      }
      return i;
    }, e.prototype.isSelected = function(t, n) {
      var i = this.option.selectedMap;
      if (!i) return false;
      var a = this.getData(n);
      return (i === "all" || i[od(a, t)]) && !a.getItemModel(t).get([
        "select",
        "disabled"
      ]);
    }, e.prototype.isUniversalTransitionEnabled = function() {
      if (this[Sp]) return true;
      var t = this.option.universalTransition;
      return t ? t === true ? true : t && t.enabled : false;
    }, e.prototype._innerSelect = function(t, n) {
      var i, a, o = this.option, s = o.selectedMode, l = n.length;
      if (!(!s || !l)) {
        if (s === "series") o.selectedMap = "all";
        else if (s === "multiple") {
          _e(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, c = 0; c < l; c++) {
            var h = n[c], f = od(t, h);
            u[f] = true, this._selectedDataIndicesMap[f] = t.getRawIndex(h);
          }
        } else if (s === "single" || s === true) {
          var d = n[l - 1], f = od(t, d);
          o.selectedMap = (i = {}, i[f] = true, i), this._selectedDataIndicesMap = (a = {}, a[f] = t.getRawIndex(d), a);
        }
      }
    }, e.prototype._initSelectedMapFromData = function(t) {
      if (!this.option.selectedMap) {
        var n = [];
        t.hasItemOption && t.each(function(i) {
          var a = t.getRawDataItem(i);
          a && a.selected && n.push(i);
        }), n.length > 0 && this._innerSelect(t, n);
      }
    }, e.registerClass = function(t) {
      return Ke.registerClass(t);
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = false, t.hasSymbolVisual = false, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill";
    }(), e;
  }(Ke);
  qt(Tt, pg);
  qt(Tt, A1);
  OR(Tt, Ke);
  function W2(r) {
    var e = r.name;
    n1(r) || (r.name = mX(r) || e);
  }
  function mX(r) {
    var e = r.getRawData(), t = e.mapDimensionsAll("seriesName"), n = [];
    return D(t, function(i) {
      var a = e.getDimensionInfo(i);
      a.displayName && n.push(a.displayName);
    }), n.join(" ");
  }
  function yX(r) {
    return r.model.getRawData().count();
  }
  function xX(r) {
    var e = r.model;
    return e.setData(e.getRawData().cloneShallow()), _X;
  }
  function _X(r, e) {
    e.outputData && r.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
  }
  function U2(r, e) {
    D(_h(r.CHANGABLE_METHODS, r.DOWNSAMPLE_METHODS), function(t) {
      r.wrapMethod(t, Le(bX, e));
    });
  }
  function bX(r, e) {
    var t = Kx(r);
    return t && t.setOutputEnd((e || this).count()), e;
  }
  function Kx(r) {
    var e = (r.ecModel || {}).scheduler, t = e && e.getPipeline(r.uid);
    if (t) {
      var n = t.currentTask;
      if (n) {
        var i = n.agentStubMap;
        i && (n = i.get(r.uid));
      }
      return n;
    }
  }
  var Rt = function() {
    function r() {
      this.group = new Ce(), this.uid = Nu("viewComponent");
    }
    return r.prototype.init = function(e, t) {
    }, r.prototype.render = function(e, t, n, i) {
    }, r.prototype.dispose = function(e, t) {
    }, r.prototype.updateView = function(e, t, n, i) {
    }, r.prototype.updateLayout = function(e, t, n, i) {
    }, r.prototype.updateVisual = function(e, t, n, i) {
    }, r.prototype.toggleBlurSeries = function(e, t, n) {
    }, r.prototype.eachRendered = function(e) {
      var t = this.group;
      t && t.traverse(e);
    }, r;
  }();
  a1(Rt);
  Zv(Rt);
  function zu() {
    var r = tt();
    return function(e) {
      var t = r(e), n = e.pipelineContext, i = !!t.large, a = !!t.progressiveRender, o = t.large = !!(n && n.large), s = t.progressiveRender = !!(n && n.progressiveRender);
      return (i !== o || a !== s) && "reset";
    };
  }
  var p3 = tt(), SX = zu(), yt = function() {
    function r() {
      this.group = new Ce(), this.uid = Nu("viewChart"), this.renderTask = nh({
        plan: wX,
        reset: CX
      }), this.renderTask.context = {
        view: this
      };
    }
    return r.prototype.init = function(e, t) {
    }, r.prototype.render = function(e, t, n, i) {
    }, r.prototype.highlight = function(e, t, n, i) {
      var a = e.getData(i && i.dataType);
      a && Y2(a, i, "emphasis");
    }, r.prototype.downplay = function(e, t, n, i) {
      var a = e.getData(i && i.dataType);
      a && Y2(a, i, "normal");
    }, r.prototype.remove = function(e, t) {
      this.group.removeAll();
    }, r.prototype.dispose = function(e, t) {
    }, r.prototype.updateView = function(e, t, n, i) {
      this.render(e, t, n, i);
    }, r.prototype.updateLayout = function(e, t, n, i) {
      this.render(e, t, n, i);
    }, r.prototype.updateVisual = function(e, t, n, i) {
      this.render(e, t, n, i);
    }, r.prototype.eachRendered = function(e) {
      mo(this.group, e);
    }, r.markUpdateMethod = function(e, t) {
      p3(e).updateMethod = t;
    }, r.protoInitialize = function() {
      var e = r.prototype;
      e.type = "chart";
    }(), r;
  }();
  function H2(r, e, t) {
    r && Ih(r) && (e === "emphasis" ? ga : ma)(r, t);
  }
  function Y2(r, e, t) {
    var n = zs(r, e), i = e && e.highlightKey != null ? a8(e.highlightKey) : null;
    n != null ? D(gt(n), function(a) {
      H2(r.getItemGraphicEl(a), t, i);
    }) : r.eachItemGraphicEl(function(a) {
      H2(a, t, i);
    });
  }
  a1(yt);
  Zv(yt);
  function wX(r) {
    return SX(r.model);
  }
  function CX(r) {
    var e = r.model, t = r.ecModel, n = r.api, i = r.payload, a = e.pipelineContext.progressiveRender, o = r.view, s = i && p3(i).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
    return l !== "render" && o[l](e, t, n, i), TX[l];
  }
  var TX = {
    incrementalPrepareRender: {
      progress: function(r, e) {
        e.view.incrementalRender(r, e.model, e.ecModel, e.api, e.payload);
      }
    },
    render: {
      forceFirstProgress: true,
      progress: function(r, e) {
        e.view.render(e.model, e.ecModel, e.api, e.payload);
      }
    }
  }, jp = "\0__throttleOriginMethod", X2 = "\0__throttleRate", q2 = "\0__throttleType";
  function L1(r, e, t) {
    var n, i = 0, a = 0, o = null, s, l, u, c;
    e = e || 0;
    function h() {
      a = (/* @__PURE__ */ new Date()).getTime(), o = null, r.apply(l, u || []);
    }
    var f = function() {
      for (var d = [], p = 0; p < arguments.length; p++) d[p] = arguments[p];
      n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
      var v = c || e, g = c || t;
      c = null, s = n - (g ? i : a) - v, clearTimeout(o), g ? o = setTimeout(h, v) : s >= 0 ? h() : o = setTimeout(h, -s), i = n;
    };
    return f.clear = function() {
      o && (clearTimeout(o), o = null);
    }, f.debounceNextCall = function(d) {
      c = d;
    }, f;
  }
  function Vu(r, e, t, n) {
    var i = r[e];
    if (i) {
      var a = i[jp] || i, o = i[q2], s = i[X2];
      if (s !== t || o !== n) {
        if (t == null || !n) return r[e] = a;
        i = r[e] = L1(a, t, n === "debounce"), i[jp] = a, i[q2] = n, i[X2] = t;
      }
      return i;
    }
  }
  function Lh(r, e) {
    var t = r[e];
    t && t[jp] && (t.clear && t.clear(), r[e] = t[jp]);
  }
  var K2 = tt(), Z2 = {
    itemStyle: Vs(_E, true),
    lineStyle: Vs(xE, true)
  }, AX = {
    lineStyle: "stroke",
    itemStyle: "fill"
  };
  function v3(r, e) {
    var t = r.visualStyleMapper || Z2[e];
    return t || (console.warn("Unknown style type '" + e + "'."), Z2.itemStyle);
  }
  function g3(r, e) {
    var t = r.visualDrawType || AX[e];
    return t || (console.warn("Unknown style type '" + e + "'."), "fill");
  }
  var IX = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(r, e) {
      var t = r.getData(), n = r.visualStyleAccessPath || "itemStyle", i = r.getModel(n), a = v3(r, n), o = a(i), s = i.getShallow("decal");
      s && (t.setVisual("decal", s), s.dirty = true);
      var l = g3(r, n), u = o[l], c = ge(u) ? u : null, h = o.fill === "auto" || o.stroke === "auto";
      if (!o[l] || c || h) {
        var f = r.getColorFromPalette(r.name, null, e.getSeriesCount());
        o[l] || (o[l] = f, t.setVisual("colorFromPalette", true)), o.fill = o.fill === "auto" || ge(o.fill) ? f : o.fill, o.stroke = o.stroke === "auto" || ge(o.stroke) ? f : o.stroke;
      }
      if (t.setVisual("style", o), t.setVisual("drawType", l), !e.isSeriesFiltered(r) && c) return t.setVisual("colorFromPalette", false), {
        dataEach: function(d, p) {
          var v = r.getDataParams(p), g = H({}, o);
          g[l] = c(v), d.setItemVisual(p, "style", g);
        }
      };
    }
  }, ic = new ft(), MX = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(r, e) {
      if (!(r.ignoreStyleOnData || e.isSeriesFiltered(r))) {
        var t = r.getData(), n = r.visualStyleAccessPath || "itemStyle", i = v3(r, n), a = t.getVisual("drawType");
        return {
          dataEach: t.hasItemOption ? function(o, s) {
            var l = o.getRawDataItem(s);
            if (l && l[n]) {
              ic.option = l[n];
              var u = i(ic), c = o.ensureUniqueItemVisual(s, "style");
              H(c, u), ic.option.decal && (o.setItemVisual(s, "decal", ic.option.decal), ic.option.decal.dirty = true), a in u && o.setItemVisual(s, "colorFromPalette", false);
            }
          } : null
        };
      }
    }
  }, DX = {
    performRawSeries: true,
    overallReset: function(r) {
      var e = ce();
      r.eachSeries(function(t) {
        var n = t.getColorBy();
        if (!t.isColorBySeries()) {
          var i = t.type + "-" + n, a = e.get(i);
          a || (a = {}, e.set(i, a)), K2(t).scope = a;
        }
      }), r.eachSeries(function(t) {
        if (!(t.isColorBySeries() || r.isSeriesFiltered(t))) {
          var n = t.getRawData(), i = {}, a = t.getData(), o = K2(t).scope, s = t.visualStyleAccessPath || "itemStyle", l = g3(t, s);
          a.each(function(u) {
            var c = a.getRawIndex(u);
            i[c] = u;
          }), n.each(function(u) {
            var c = i[u], h = a.getItemVisual(c, "colorFromPalette");
            if (h) {
              var f = a.ensureUniqueItemVisual(c, "style"), d = n.getName(u) || u + "", p = n.count();
              f[l] = t.getColorFromPalette(d, o, p);
            }
          });
        }
      });
    }
  }, sd = Math.PI;
  function PX(r, e) {
    e = e || {}, ye(e, {
      text: "loading",
      textColor: "#000",
      fontSize: 12,
      fontWeight: "normal",
      fontStyle: "normal",
      fontFamily: "sans-serif",
      maskColor: "rgba(255, 255, 255, 0.8)",
      showSpinner: true,
      color: "#5470c6",
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    });
    var t = new Ce(), n = new et({
      style: {
        fill: e.maskColor
      },
      zlevel: e.zlevel,
      z: 1e4
    });
    t.add(n);
    var i = new rt({
      style: {
        text: e.text,
        fill: e.textColor,
        fontSize: e.fontSize,
        fontWeight: e.fontWeight,
        fontStyle: e.fontStyle,
        fontFamily: e.fontFamily
      },
      zlevel: e.zlevel,
      z: 10001
    }), a = new et({
      style: {
        fill: "none"
      },
      textContent: i,
      textConfig: {
        position: "right",
        distance: 10
      },
      zlevel: e.zlevel,
      z: 10001
    });
    t.add(a);
    var o;
    return e.showSpinner && (o = new ng({
      shape: {
        startAngle: -sd / 2,
        endAngle: -sd / 2 + 0.1,
        r: e.spinnerRadius
      },
      style: {
        stroke: e.color,
        lineCap: "round",
        lineWidth: e.lineWidth
      },
      zlevel: e.zlevel,
      z: 10001
    }), o.animateShape(true).when(1e3, {
      endAngle: sd * 3 / 2
    }).start("circularInOut"), o.animateShape(true).when(1e3, {
      startAngle: sd * 3 / 2
    }).delay(300).start("circularInOut"), t.add(o)), t.resize = function() {
      var s = i.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, u = (r.getWidth() - l * 2 - (e.showSpinner && s ? 10 : 0) - s) / 2 - (e.showSpinner && s ? 0 : 5 + s / 2) + (e.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = r.getHeight() / 2;
      e.showSpinner && o.setShape({
        cx: u,
        cy: c
      }), a.setShape({
        x: u - l,
        y: c - l,
        width: l * 2,
        height: l * 2
      }), n.setShape({
        x: 0,
        y: 0,
        width: r.getWidth(),
        height: r.getHeight()
      });
    }, t.resize(), t;
  }
  var m3 = function() {
    function r(e, t, n, i) {
      this._stageTaskMap = ce(), this.ecInstance = e, this.api = t, n = this._dataProcessorHandlers = n.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i);
    }
    return r.prototype.restoreData = function(e, t) {
      e.restoreData(t), this._stageTaskMap.each(function(n) {
        var i = n.overallTask;
        i && i.dirty();
      });
    }, r.prototype.getPerformArgs = function(e, t) {
      if (e.__pipeline) {
        var n = this._pipelineMap.get(e.__pipeline.id), i = n.context, a = !t && n.progressiveEnabled && (!i || i.progressiveRender) && e.__idxInPipeline > n.blockIndex, o = a ? n.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, r.prototype.getPipeline = function(e) {
      return this._pipelineMap.get(e);
    }, r.prototype.updateStreamModes = function(e, t) {
      var n = this._pipelineMap.get(e.uid), i = e.getData(), a = i.count(), o = n.progressiveEnabled && t.incrementalPrepareRender && a >= n.threshold, s = e.get("large") && a >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? a : null;
      e.pipelineContext = n.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, r.prototype.restorePipelines = function(e) {
      var t = this, n = t._pipelineMap = ce();
      e.eachSeries(function(i) {
        var a = i.getProgressive(), o = i.uid;
        n.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), t._pipe(i, i.dataTask);
      });
    }, r.prototype.prepareStageTasks = function() {
      var e = this._stageTaskMap, t = this.api.getModel(), n = this.api;
      D(this._allHandlers, function(i) {
        var a = e.get(i.uid) || e.set(i.uid, {}), o = "";
        Yr(!(i.reset && i.overallReset), o), i.reset && this._createSeriesStageTask(i, a, t, n), i.overallReset && this._createOverallStageTask(i, a, t, n);
      }, this);
    }, r.prototype.prepareView = function(e, t, n, i) {
      var a = e.renderTask, o = a.context;
      o.model = t, o.ecModel = n, o.api = i, a.__block = !e.incrementalPrepareRender, this._pipe(t, a);
    }, r.prototype.performDataProcessorTasks = function(e, t) {
      this._performStageTasks(this._dataProcessorHandlers, e, t, {
        block: true
      });
    }, r.prototype.performVisualTasks = function(e, t, n) {
      this._performStageTasks(this._visualHandlers, e, t, n);
    }, r.prototype._performStageTasks = function(e, t, n, i) {
      i = i || {};
      var a = false, o = this;
      D(e, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid), h = c.seriesTaskMap, f = c.overallTask;
          if (f) {
            var d, p = f.agentStubMap;
            p.each(function(g) {
              s(i, g) && (g.dirty(), d = true);
            }), d && f.dirty(), o.updatePayload(f, n);
            var v = o.getPerformArgs(f, i.block);
            p.each(function(g) {
              g.perform(v);
            }), f.perform(v) && (a = true);
          } else h && h.each(function(g, m) {
            s(i, g) && g.dirty();
            var y = o.getPerformArgs(g, i.block);
            y.skip = !l.performRawSeries && t.isSeriesFiltered(g.context.model), o.updatePayload(g, n), g.perform(y) && (a = true);
          });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, r.prototype.performSeriesTasks = function(e) {
      var t;
      e.eachSeries(function(n) {
        t = n.dataTask.perform() || t;
      }), this.unfinished = t || this.unfinished;
    }, r.prototype.plan = function() {
      this._pipelineMap.each(function(e) {
        var t = e.tail;
        do {
          if (t.__block) {
            e.blockIndex = t.__idxInPipeline;
            break;
          }
          t = t.getUpstream();
        } while (t);
      });
    }, r.prototype.updatePayload = function(e, t) {
      t !== "remain" && (e.context.payload = t);
    }, r.prototype._createSeriesStageTask = function(e, t, n, i) {
      var a = this, o = t.seriesTaskMap, s = t.seriesTaskMap = ce(), l = e.seriesType, u = e.getTargetSeries;
      e.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, i).each(c);
      function c(h) {
        var f = h.uid, d = s.set(f, o && o.get(f) || nh({
          plan: NX,
          reset: OX,
          count: BX
        }));
        d.context = {
          model: h,
          ecModel: n,
          api: i,
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: a
        }, a._pipe(h, d);
      }
    }, r.prototype._createOverallStageTask = function(e, t, n, i) {
      var a = this, o = t.overallTask = t.overallTask || nh({
        reset: kX
      });
      o.context = {
        ecModel: n,
        api: i,
        overallReset: e.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = ce(), u = e.seriesType, c = e.getTargetSeries, h = true, f = false, d = "";
      Yr(!e.createOnAllSeries, d), u ? n.eachRawSeriesByType(u, p) : c ? c(n, i).each(p) : (h = false, D(n.getSeries(), p));
      function p(v) {
        var g = v.uid, m = l.set(g, s && s.get(g) || (f = true, nh({
          reset: LX,
          onDirty: EX
        })));
        m.context = {
          model: v,
          overallProgress: h
        }, m.agent = o, m.__block = h, a._pipe(v, m);
      }
      f && o.dirty();
    }, r.prototype._pipe = function(e, t) {
      var n = e.uid, i = this._pipelineMap.get(n);
      !i.head && (i.head = t), i.tail && i.tail.pipe(t), i.tail = t, t.__idxInPipeline = i.count++, t.__pipeline = i;
    }, r.wrapStageHandler = function(e, t) {
      return ge(e) && (e = {
        overallReset: e,
        seriesType: zX(e)
      }), e.uid = Nu("stageHandler"), t && (e.visualType = t), e;
    }, r;
  }();
  function kX(r) {
    r.overallReset(r.ecModel, r.api, r.payload);
  }
  function LX(r) {
    return r.overallProgress && RX;
  }
  function RX() {
    this.agent.dirty(), this.getDownstream().dirty();
  }
  function EX() {
    this.agent && this.agent.dirty();
  }
  function NX(r) {
    return r.plan ? r.plan(r.model, r.ecModel, r.api, r.payload) : null;
  }
  function OX(r) {
    r.useClearVisual && r.data.clearAllVisual();
    var e = r.resetDefines = gt(r.reset(r.model, r.ecModel, r.api, r.payload));
    return e.length > 1 ? K(e, function(t, n) {
      return y3(n);
    }) : FX;
  }
  var FX = y3(0);
  function y3(r) {
    return function(e, t) {
      var n = t.data, i = t.resetDefines[r];
      if (i && i.dataEach) for (var a = e.start; a < e.end; a++) i.dataEach(n, a);
      else i && i.progress && i.progress(e, n);
    };
  }
  function BX(r) {
    return r.data.count();
  }
  function zX(r) {
    Qp = null;
    try {
      r(Rh, x3);
    } catch {
    }
    return Qp;
  }
  var Rh = {}, x3 = {}, Qp;
  _3(Rh, I1);
  _3(x3, UE);
  Rh.eachSeriesByType = Rh.eachRawSeriesByType = function(r) {
    Qp = r;
  };
  Rh.eachComponent = function(r) {
    r.mainType === "series" && r.subType && (Qp = r.subType);
  };
  function _3(r, e) {
    for (var t in e.prototype) r[t] = Wt;
  }
  var j2 = [
    "#37A2DA",
    "#32C5E9",
    "#67E0E3",
    "#9FE6B8",
    "#FFDB5C",
    "#ff9f7f",
    "#fb7293",
    "#E062AE",
    "#E690D1",
    "#e7bcf3",
    "#9d96f5",
    "#8378EA",
    "#96BFFF"
  ];
  const VX = {
    color: j2,
    colorLayer: [
      [
        "#37A2DA",
        "#ffd85c",
        "#fd7b5f"
      ],
      [
        "#37A2DA",
        "#67E0E3",
        "#FFDB5C",
        "#ff9f7f",
        "#E062AE",
        "#9d96f5"
      ],
      [
        "#37A2DA",
        "#32C5E9",
        "#9FE6B8",
        "#FFDB5C",
        "#ff9f7f",
        "#fb7293",
        "#e7bcf3",
        "#8378EA",
        "#96BFFF"
      ],
      j2
    ]
  };
  var Ar = "#B9B8CE", Q2 = "#100C2A", ld = function() {
    return {
      axisLine: {
        lineStyle: {
          color: Ar
        }
      },
      splitLine: {
        lineStyle: {
          color: "#484753"
        }
      },
      splitArea: {
        areaStyle: {
          color: [
            "rgba(255,255,255,0.02)",
            "rgba(255,255,255,0.05)"
          ]
        }
      },
      minorSplitLine: {
        lineStyle: {
          color: "#20203B"
        }
      }
    };
  }, J2 = [
    "#4992ff",
    "#7cffb2",
    "#fddd60",
    "#ff6e76",
    "#58d9f9",
    "#05c091",
    "#ff8a45",
    "#8d48e3",
    "#dd79ff"
  ], b3 = {
    darkMode: true,
    color: J2,
    backgroundColor: Q2,
    axisPointer: {
      lineStyle: {
        color: "#817f91"
      },
      crossStyle: {
        color: "#817f91"
      },
      label: {
        color: "#fff"
      }
    },
    legend: {
      textStyle: {
        color: Ar
      },
      pageTextStyle: {
        color: Ar
      }
    },
    textStyle: {
      color: Ar
    },
    title: {
      textStyle: {
        color: "#EEF1FA"
      },
      subtextStyle: {
        color: "#B9B8CE"
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: Ar
      }
    },
    dataZoom: {
      borderColor: "#71708A",
      textStyle: {
        color: Ar
      },
      brushStyle: {
        color: "rgba(135,163,206,0.3)"
      },
      handleStyle: {
        color: "#353450",
        borderColor: "#C5CBE3"
      },
      moveHandleStyle: {
        color: "#B0B6C3",
        opacity: 0.3
      },
      fillerColor: "rgba(135,163,206,0.2)",
      emphasis: {
        handleStyle: {
          borderColor: "#91B7F2",
          color: "#4D587D"
        },
        moveHandleStyle: {
          color: "#636D9A",
          opacity: 0.7
        }
      },
      dataBackground: {
        lineStyle: {
          color: "#71708A",
          width: 1
        },
        areaStyle: {
          color: "#71708A"
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#87A3CE"
        },
        areaStyle: {
          color: "#87A3CE"
        }
      }
    },
    visualMap: {
      textStyle: {
        color: Ar
      }
    },
    timeline: {
      lineStyle: {
        color: Ar
      },
      label: {
        color: Ar
      },
      controlStyle: {
        color: Ar,
        borderColor: Ar
      }
    },
    calendar: {
      itemStyle: {
        color: Q2
      },
      dayLabel: {
        color: Ar
      },
      monthLabel: {
        color: Ar
      },
      yearLabel: {
        color: Ar
      }
    },
    timeAxis: ld(),
    logAxis: ld(),
    valueAxis: ld(),
    categoryAxis: ld(),
    line: {
      symbol: "circle"
    },
    graph: {
      color: J2
    },
    gauge: {
      title: {
        color: Ar
      },
      axisLine: {
        lineStyle: {
          color: [
            [
              1,
              "rgba(207,212,219,0.2)"
            ]
          ]
        }
      },
      axisLabel: {
        color: Ar
      },
      detail: {
        color: "#EEF1FA"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#f64e56",
        color0: "#54ea92",
        borderColor: "#f64e56",
        borderColor0: "#54ea92"
      }
    }
  };
  b3.categoryAxis.splitLine.show = false;
  var $X = function() {
    function r() {
    }
    return r.prototype.normalizeQuery = function(e) {
      var t = {}, n = {}, i = {};
      if (ee(e)) {
        var a = Di(e);
        t.mainType = a.main || null, t.subType = a.sub || null;
      } else {
        var o = [
          "Index",
          "Name",
          "Id"
        ], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        D(e, function(l, u) {
          for (var c = false, h = 0; h < o.length; h++) {
            var f = o[h], d = u.lastIndexOf(f);
            if (d > 0 && d === u.length - f.length) {
              var p = u.slice(0, d);
              p !== "data" && (t.mainType = p, t[f.toLowerCase()] = l, c = true);
            }
          }
          s.hasOwnProperty(u) && (n[u] = l, c = true), c || (i[u] = l);
        });
      }
      return {
        cptQuery: t,
        dataQuery: n,
        otherQuery: i
      };
    }, r.prototype.filter = function(e, t) {
      var n = this.eventInfo;
      if (!n) return true;
      var i = n.targetEl, a = n.packedEvent, o = n.model, s = n.view;
      if (!o || !s) return true;
      var l = t.cptQuery, u = t.dataQuery;
      return c(l, o, "mainType") && c(l, o, "subType") && c(l, o, "index", "componentIndex") && c(l, o, "name") && c(l, o, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(e, t.otherQuery, i, a));
      function c(h, f, d, p) {
        return h[d] == null || f[p || d] === h[d];
      }
    }, r.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, r;
  }(), Zx = [
    "symbol",
    "symbolSize",
    "symbolRotate",
    "symbolOffset"
  ], eT = Zx.concat([
    "symbolKeepAspect"
  ]), GX = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(r, e) {
      var t = r.getData();
      if (r.legendIcon && t.setVisual("legendIcon", r.legendIcon), !r.hasSymbolVisual) return;
      for (var n = {}, i = {}, a = false, o = 0; o < Zx.length; o++) {
        var s = Zx[o], l = r.get(s);
        ge(l) ? (a = true, i[s] = l) : n[s] = l;
      }
      if (n.symbol = n.symbol || r.defaultSymbol, t.setVisual(H({
        legendIcon: r.legendIcon || n.symbol,
        symbolKeepAspect: r.get("symbolKeepAspect")
      }, n)), e.isSeriesFiltered(r)) return;
      var u = je(i);
      function c(h, f) {
        for (var d = r.getRawValue(f), p = r.getDataParams(f), v = 0; v < u.length; v++) {
          var g = u[v];
          h.setItemVisual(f, g, i[g](d, p));
        }
      }
      return {
        dataEach: a ? c : null
      };
    }
  }, WX = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(r, e) {
      if (!r.hasSymbolVisual || e.isSeriesFiltered(r)) return;
      var t = r.getData();
      function n(i, a) {
        for (var o = i.getItemModel(a), s = 0; s < eT.length; s++) {
          var l = eT[s], u = o.getShallow(l, true);
          u != null && i.setItemVisual(a, l, u);
        }
      }
      return {
        dataEach: t.hasItemOption ? n : null
      };
    }
  };
  function R1(r, e, t) {
    switch (t) {
      case "color":
        var n = r.getItemVisual(e, "style");
        return n[r.getVisual("drawType")];
      case "opacity":
        return r.getItemVisual(e, "style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return r.getItemVisual(e, t);
    }
  }
  function wf(r, e) {
    switch (e) {
      case "color":
        var t = r.getVisual("style");
        return t[r.getVisual("drawType")];
      case "opacity":
        return r.getVisual("style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return r.getVisual(e);
    }
  }
  function S3(r, e, t, n) {
    switch (t) {
      case "color":
        var i = r.ensureUniqueItemVisual(e, "style");
        i[r.getVisual("drawType")] = n, r.setItemVisual(e, "colorFromPalette", false);
        break;
      case "opacity":
        r.ensureUniqueItemVisual(e, "style").opacity = n;
        break;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        r.setItemVisual(e, t, n);
        break;
    }
  }
  function w3(r, e) {
    function t(n, i) {
      var a = [];
      return n.eachComponent({
        mainType: "series",
        subType: r,
        query: i
      }, function(o) {
        a.push(o.seriesIndex);
      }), a;
    }
    D([
      [
        r + "ToggleSelect",
        "toggleSelect"
      ],
      [
        r + "Select",
        "select"
      ],
      [
        r + "UnSelect",
        "unselect"
      ]
    ], function(n) {
      e(n[0], function(i, a, o) {
        i = H({}, i), o.dispatchAction(H(i, {
          type: n[1],
          seriesIndex: t(a, i)
        }));
      });
    });
  }
  function yl(r, e, t, n, i) {
    var a = r + e;
    t.isSilent(a) || n.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(o) {
      for (var s = o.seriesIndex, l = o.option.selectedMap, u = i.selected, c = 0; c < u.length; c++) if (u[c].seriesIndex === s) {
        var h = o.getData(), f = zs(h, i.fromActionPayload);
        t.trigger(a, {
          type: a,
          seriesId: o.id,
          name: X(f) ? h.getName(f[0]) : h.getName(f),
          selected: ee(l) ? l : H({}, l)
        });
      }
    });
  }
  function UX(r, e, t) {
    r.on("selectchanged", function(n) {
      var i = t.getModel();
      n.isFromClick ? (yl("map", "selectchanged", e, i, n), yl("pie", "selectchanged", e, i, n)) : n.fromAction === "select" ? (yl("map", "selected", e, i, n), yl("pie", "selected", e, i, n)) : n.fromAction === "unselect" && (yl("map", "unselected", e, i, n), yl("pie", "unselected", e, i, n));
    });
  }
  function xs(r, e, t) {
    for (var n; r && !(e(r) && (n = r, t)); ) r = r.__hostTarget || r.parent;
    return n;
  }
  var HX = Math.round(Math.random() * 9), YX = typeof Object.defineProperty == "function", XX = function() {
    function r() {
      this._id = "__ec_inner_" + HX++;
    }
    return r.prototype.get = function(e) {
      return this._guard(e)[this._id];
    }, r.prototype.set = function(e, t) {
      var n = this._guard(e);
      return YX ? Object.defineProperty(n, this._id, {
        value: t,
        enumerable: false,
        configurable: true
      }) : n[this._id] = t, this;
    }, r.prototype.delete = function(e) {
      return this.has(e) ? (delete this._guard(e)[this._id], true) : false;
    }, r.prototype.has = function(e) {
      return !!this._guard(e)[this._id];
    }, r.prototype._guard = function(e) {
      if (e !== Object(e)) throw TypeError("Value of WeakMap is not a non-null object.");
      return e;
    }, r;
  }(), qX = Ue.extend({
    type: "triangle",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(r, e) {
      var t = e.cx, n = e.cy, i = e.width / 2, a = e.height / 2;
      r.moveTo(t, n - a), r.lineTo(t + i, n + a), r.lineTo(t - i, n + a), r.closePath();
    }
  }), KX = Ue.extend({
    type: "diamond",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(r, e) {
      var t = e.cx, n = e.cy, i = e.width / 2, a = e.height / 2;
      r.moveTo(t, n - a), r.lineTo(t + i, n), r.lineTo(t, n + a), r.lineTo(t - i, n), r.closePath();
    }
  }), ZX = Ue.extend({
    type: "pin",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(r, e) {
      var t = e.x, n = e.y, i = e.width / 5 * 3, a = Math.max(i, e.height), o = i / 2, s = o * o / (a - o), l = n - a + o + s, u = Math.asin(s / o), c = Math.cos(u) * o, h = Math.sin(u), f = Math.cos(u), d = o * 0.6, p = o * 0.7;
      r.moveTo(t - c, l + s), r.arc(t, l, o, Math.PI - u, Math.PI * 2 + u), r.bezierCurveTo(t + c - h * d, l + s + f * d, t, n - p, t, n), r.bezierCurveTo(t, n - p, t - c + h * d, l + s + f * d, t - c, l + s), r.closePath();
    }
  }), jX = Ue.extend({
    type: "arrow",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(r, e) {
      var t = e.height, n = e.width, i = e.x, a = e.y, o = n / 3 * 2;
      r.moveTo(i, a), r.lineTo(i + o, a + t), r.lineTo(i, a + t / 4 * 3), r.lineTo(i - o, a + t), r.lineTo(i, a), r.closePath();
    }
  }), QX = {
    line: ir,
    rect: et,
    roundRect: et,
    square: et,
    circle: Ta,
    diamond: KX,
    pin: ZX,
    arrow: jX,
    triangle: qX
  }, JX = {
    line: function(r, e, t, n, i) {
      i.x1 = r, i.y1 = e + n / 2, i.x2 = r + t, i.y2 = e + n / 2;
    },
    rect: function(r, e, t, n, i) {
      i.x = r, i.y = e, i.width = t, i.height = n;
    },
    roundRect: function(r, e, t, n, i) {
      i.x = r, i.y = e, i.width = t, i.height = n, i.r = Math.min(t, n) / 4;
    },
    square: function(r, e, t, n, i) {
      var a = Math.min(t, n);
      i.x = r, i.y = e, i.width = a, i.height = a;
    },
    circle: function(r, e, t, n, i) {
      i.cx = r + t / 2, i.cy = e + n / 2, i.r = Math.min(t, n) / 2;
    },
    diamond: function(r, e, t, n, i) {
      i.cx = r + t / 2, i.cy = e + n / 2, i.width = t, i.height = n;
    },
    pin: function(r, e, t, n, i) {
      i.x = r + t / 2, i.y = e + n / 2, i.width = t, i.height = n;
    },
    arrow: function(r, e, t, n, i) {
      i.x = r + t / 2, i.y = e + n / 2, i.width = t, i.height = n;
    },
    triangle: function(r, e, t, n, i) {
      i.cx = r + t / 2, i.cy = e + n / 2, i.width = t, i.height = n;
    }
  }, Jp = {};
  D(QX, function(r, e) {
    Jp[e] = new r();
  });
  var e9 = Ue.extend({
    type: "symbol",
    shape: {
      symbolType: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function(r, e, t) {
      var n = Gp(r, e, t), i = this.shape;
      return i && i.symbolType === "pin" && e.position === "inside" && (n.y = t.y + t.height * 0.4), n;
    },
    buildPath: function(r, e, t) {
      var n = e.symbolType;
      if (n !== "none") {
        var i = Jp[n];
        i || (n = "rect", i = Jp[n]), JX[n](e.x, e.y, e.width, e.height, i.shape), i.buildPath(r, i.shape, t);
      }
    }
  });
  function t9(r, e) {
    if (this.type !== "image") {
      var t = this.style;
      this.__isEmptyBrush ? (t.stroke = r, t.fill = e || "#fff", t.lineWidth = 2) : this.shape.symbolType === "line" ? t.stroke = r : t.fill = r, this.markRedraw();
    }
  }
  function Xt(r, e, t, n, i, a, o) {
    var s = r.indexOf("empty") === 0;
    s && (r = r.substr(5, 1).toLowerCase() + r.substr(6));
    var l;
    return r.indexOf("image://") === 0 ? l = hE(r.slice(8), new Oe(e, t, n, i), o ? "center" : "cover") : r.indexOf("path://") === 0 ? l = ig(r.slice(7), {}, new Oe(e, t, n, i), o ? "center" : "cover") : l = new e9({
      shape: {
        symbolType: r,
        x: e,
        y: t,
        width: n,
        height: i
      }
    }), l.__isEmptyBrush = s, l.setColor = t9, a && l.setColor(a), l;
  }
  function $u(r) {
    return X(r) || (r = [
      +r,
      +r
    ]), [
      r[0] || 0,
      r[1] || 0
    ];
  }
  function js(r, e) {
    if (r != null) return X(r) || (r = [
      r,
      r
    ]), [
      Q(r[0], e[0]) || 0,
      Q(Pe(r[1], r[0]), e[1]) || 0
    ];
  }
  function _s(r) {
    return isFinite(r);
  }
  function r9(r, e, t) {
    var n = e.x == null ? 0 : e.x, i = e.x2 == null ? 1 : e.x2, a = e.y == null ? 0 : e.y, o = e.y2 == null ? 0 : e.y2;
    e.global || (n = n * t.width + t.x, i = i * t.width + t.x, a = a * t.height + t.y, o = o * t.height + t.y), n = _s(n) ? n : 0, i = _s(i) ? i : 1, a = _s(a) ? a : 0, o = _s(o) ? o : 0;
    var s = r.createLinearGradient(n, a, i, o);
    return s;
  }
  function n9(r, e, t) {
    var n = t.width, i = t.height, a = Math.min(n, i), o = e.x == null ? 0.5 : e.x, s = e.y == null ? 0.5 : e.y, l = e.r == null ? 0.5 : e.r;
    e.global || (o = o * n + t.x, s = s * i + t.y, l = l * a), o = _s(o) ? o : 0.5, s = _s(s) ? s : 0.5, l = l >= 0 && _s(l) ? l : 0.5;
    var u = r.createRadialGradient(o, s, 0, o, s, l);
    return u;
  }
  function jx(r, e, t) {
    for (var n = e.type === "radial" ? n9(r, e, t) : r9(r, e, t), i = e.colorStops, a = 0; a < i.length; a++) n.addColorStop(i[a].offset, i[a].color);
    return n;
  }
  function i9(r, e) {
    if (r === e || !r && !e) return false;
    if (!r || !e || r.length !== e.length) return true;
    for (var t = 0; t < r.length; t++) if (r[t] !== e[t]) return true;
    return false;
  }
  function ud(r) {
    return parseInt(r, 10);
  }
  function Kl(r, e, t) {
    var n = [
      "width",
      "height"
    ][e], i = [
      "clientWidth",
      "clientHeight"
    ][e], a = [
      "paddingLeft",
      "paddingTop"
    ][e], o = [
      "paddingRight",
      "paddingBottom"
    ][e];
    if (t[n] != null && t[n] !== "auto") return parseFloat(t[n]);
    var s = document.defaultView.getComputedStyle(r);
    return (r[i] || ud(s[n]) || ud(r.style[n])) - (ud(s[a]) || 0) - (ud(s[o]) || 0) | 0;
  }
  function a9(r, e) {
    return !r || r === "solid" || !(e > 0) ? null : r === "dashed" ? [
      4 * e,
      2 * e
    ] : r === "dotted" ? [
      e
    ] : nt(r) ? [
      r
    ] : X(r) ? r : null;
  }
  function E1(r) {
    var e = r.style, t = e.lineDash && e.lineWidth > 0 && a9(e.lineDash, e.lineWidth), n = e.lineDashOffset;
    if (t) {
      var i = e.strokeNoScale && r.getLineScale ? r.getLineScale() : 1;
      i && i !== 1 && (t = K(t, function(a) {
        return a / i;
      }), n /= i);
    }
    return [
      t,
      n
    ];
  }
  var o9 = new $i(true);
  function ev(r) {
    var e = r.stroke;
    return !(e == null || e === "none" || !(r.lineWidth > 0));
  }
  function tT(r) {
    return typeof r == "string" && r !== "none";
  }
  function tv(r) {
    var e = r.fill;
    return e != null && e !== "none";
  }
  function rT(r, e) {
    if (e.fillOpacity != null && e.fillOpacity !== 1) {
      var t = r.globalAlpha;
      r.globalAlpha = e.fillOpacity * e.opacity, r.fill(), r.globalAlpha = t;
    } else r.fill();
  }
  function nT(r, e) {
    if (e.strokeOpacity != null && e.strokeOpacity !== 1) {
      var t = r.globalAlpha;
      r.globalAlpha = e.strokeOpacity * e.opacity, r.stroke(), r.globalAlpha = t;
    } else r.stroke();
  }
  function Qx(r, e, t) {
    var n = o1(e.image, e.__image, t);
    if (jv(n)) {
      var i = r.createPattern(n, e.repeat || "repeat");
      if (typeof DOMMatrix == "function" && i && i.setTransform) {
        var a = new DOMMatrix();
        a.translateSelf(e.x || 0, e.y || 0), a.rotateSelf(0, 0, (e.rotation || 0) * lp), a.scaleSelf(e.scaleX || 1, e.scaleY || 1), i.setTransform(a);
      }
      return i;
    }
  }
  function s9(r, e, t, n) {
    var i, a = ev(t), o = tv(t), s = t.strokePercent, l = s < 1, u = !e.path;
    (!e.silent || l) && u && e.createPathProxy();
    var c = e.path || o9, h = e.__dirty;
    if (!n) {
      var f = t.fill, d = t.stroke, p = o && !!f.colorStops, v = a && !!d.colorStops, g = o && !!f.image, m = a && !!d.image, y = void 0, x = void 0, _ = void 0, S = void 0, b = void 0;
      (p || v) && (b = e.getBoundingRect()), p && (y = h ? jx(r, f, b) : e.__canvasFillGradient, e.__canvasFillGradient = y), v && (x = h ? jx(r, d, b) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = x), g && (_ = h || !e.__canvasFillPattern ? Qx(r, f, e) : e.__canvasFillPattern, e.__canvasFillPattern = _), m && (S = h || !e.__canvasStrokePattern ? Qx(r, d, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = _), p ? r.fillStyle = y : g && (_ ? r.fillStyle = _ : o = false), v ? r.strokeStyle = x : m && (S ? r.strokeStyle = S : a = false);
    }
    var w = e.getGlobalScale();
    c.setScale(w[0], w[1], e.segmentIgnoreThreshold);
    var C, T;
    r.setLineDash && t.lineDash && (i = E1(e), C = i[0], T = i[1]);
    var A = true;
    (u || h & Dc) && (c.setDPR(r.dpr), l ? c.setContext(null) : (c.setContext(r), A = false), c.reset(), e.buildPath(c, e.shape, n), c.toStatic(), e.pathUpdated()), A && c.rebuildPath(r, l ? s : 1), C && (r.setLineDash(C), r.lineDashOffset = T), n || (t.strokeFirst ? (a && nT(r, t), o && rT(r, t)) : (o && rT(r, t), a && nT(r, t))), C && r.setLineDash([]);
  }
  function l9(r, e, t) {
    var n = e.__image = o1(t.image, e.__image, e, e.onload);
    if (!(!n || !jv(n))) {
      var i = t.x || 0, a = t.y || 0, o = e.getWidth(), s = e.getHeight(), l = n.width / n.height;
      if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = n.width, s = n.height), t.sWidth && t.sHeight) {
        var u = t.sx || 0, c = t.sy || 0;
        r.drawImage(n, u, c, t.sWidth, t.sHeight, i, a, o, s);
      } else if (t.sx && t.sy) {
        var u = t.sx, c = t.sy, h = o - u, f = s - c;
        r.drawImage(n, u, c, h, f, i, a, o, s);
      } else r.drawImage(n, i, a, o, s);
    }
  }
  function u9(r, e, t) {
    var n, i = t.text;
    if (i != null && (i += ""), i) {
      r.font = t.font || oo, r.textAlign = t.textAlign, r.textBaseline = t.textBaseline;
      var a = void 0, o = void 0;
      r.setLineDash && t.lineDash && (n = E1(e), a = n[0], o = n[1]), a && (r.setLineDash(a), r.lineDashOffset = o), t.strokeFirst ? (ev(t) && r.strokeText(i, t.x, t.y), tv(t) && r.fillText(i, t.x, t.y)) : (tv(t) && r.fillText(i, t.x, t.y), ev(t) && r.strokeText(i, t.x, t.y)), a && r.setLineDash([]);
    }
  }
  var iT = [
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY"
  ], aT = [
    [
      "lineCap",
      "butt"
    ],
    [
      "lineJoin",
      "miter"
    ],
    [
      "miterLimit",
      10
    ]
  ];
  function C3(r, e, t, n, i) {
    var a = false;
    if (!n && (t = t || {}, e === t)) return false;
    if (n || e.opacity !== t.opacity) {
      nn(r, i), a = true;
      var o = Math.max(Math.min(e.opacity, 1), 0);
      r.globalAlpha = isNaN(o) ? Ms.opacity : o;
    }
    (n || e.blend !== t.blend) && (a || (nn(r, i), a = true), r.globalCompositeOperation = e.blend || Ms.blend);
    for (var s = 0; s < iT.length; s++) {
      var l = iT[s];
      (n || e[l] !== t[l]) && (a || (nn(r, i), a = true), r[l] = r.dpr * (e[l] || 0));
    }
    return (n || e.shadowColor !== t.shadowColor) && (a || (nn(r, i), a = true), r.shadowColor = e.shadowColor || Ms.shadowColor), a;
  }
  function oT(r, e, t, n, i) {
    var a = Eh(e, i.inHover), o = n ? null : t && Eh(t, i.inHover) || {};
    if (a === o) return false;
    var s = C3(r, a, o, n, i);
    if ((n || a.fill !== o.fill) && (s || (nn(r, i), s = true), tT(a.fill) && (r.fillStyle = a.fill)), (n || a.stroke !== o.stroke) && (s || (nn(r, i), s = true), tT(a.stroke) && (r.strokeStyle = a.stroke)), (n || a.opacity !== o.opacity) && (s || (nn(r, i), s = true), r.globalAlpha = a.opacity == null ? 1 : a.opacity), e.hasStroke()) {
      var l = a.lineWidth, u = l / (a.strokeNoScale && e.getLineScale ? e.getLineScale() : 1);
      r.lineWidth !== u && (s || (nn(r, i), s = true), r.lineWidth = u);
    }
    for (var c = 0; c < aT.length; c++) {
      var h = aT[c], f = h[0];
      (n || a[f] !== o[f]) && (s || (nn(r, i), s = true), r[f] = a[f] || h[1]);
    }
    return s;
  }
  function c9(r, e, t, n, i) {
    return C3(r, Eh(e, i.inHover), t && Eh(t, i.inHover), n, i);
  }
  function T3(r, e) {
    var t = e.transform, n = r.dpr || 1;
    t ? r.setTransform(n * t[0], n * t[1], n * t[2], n * t[3], n * t[4], n * t[5]) : r.setTransform(n, 0, 0, n, 0, 0);
  }
  function h9(r, e, t) {
    for (var n = false, i = 0; i < r.length; i++) {
      var a = r[i];
      n = n || a.isZeroArea(), T3(e, a), e.beginPath(), a.buildPath(e, a.shape), e.clip();
    }
    t.allClipped = n;
  }
  function f9(r, e) {
    return r && e ? r[0] !== e[0] || r[1] !== e[1] || r[2] !== e[2] || r[3] !== e[3] || r[4] !== e[4] || r[5] !== e[5] : !(!r && !e);
  }
  var sT = 1, lT = 2, uT = 3, cT = 4;
  function d9(r) {
    var e = tv(r), t = ev(r);
    return !(r.lineDash || !(+e ^ +t) || e && typeof r.fill != "string" || t && typeof r.stroke != "string" || r.strokePercent < 1 || r.strokeOpacity < 1 || r.fillOpacity < 1);
  }
  function nn(r, e) {
    e.batchFill && r.fill(), e.batchStroke && r.stroke(), e.batchFill = "", e.batchStroke = "";
  }
  function Eh(r, e) {
    return e && r.__hoverStyle || r.style;
  }
  function A3(r, e) {
    bs(r, e, {
      inHover: false,
      viewWidth: 0,
      viewHeight: 0
    }, true);
  }
  function bs(r, e, t, n) {
    var i = e.transform;
    if (!e.shouldBePainted(t.viewWidth, t.viewHeight, false, false)) {
      e.__dirty &= -2, e.__isRendered = false;
      return;
    }
    var a = e.__clipPaths, o = t.prevElClipPaths, s = false, l = false;
    if ((!o || i9(a, o)) && (o && o.length && (nn(r, t), r.restore(), l = s = true, t.prevElClipPaths = null, t.allClipped = false, t.prevEl = null), a && a.length && (nn(r, t), r.save(), h9(a, r, t), s = true), t.prevElClipPaths = a), t.allClipped) {
      e.__isRendered = false;
      return;
    }
    e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
    var u = t.prevEl;
    u || (l = s = true);
    var c = e instanceof Ue && e.autoBatch && d9(e.style);
    s || f9(i, u.transform) ? (nn(r, t), T3(r, e)) : c || nn(r, t);
    var h = Eh(e, t.inHover);
    e instanceof Ue ? (t.lastDrawType !== sT && (l = true, t.lastDrawType = sT), oT(r, e, u, l, t), (!c || !t.batchFill && !t.batchStroke) && r.beginPath(), s9(r, e, h, c), c && (t.batchFill = h.fill || "", t.batchStroke = h.stroke || "")) : e instanceof lu ? (t.lastDrawType !== uT && (l = true, t.lastDrawType = uT), oT(r, e, u, l, t), u9(r, e, h)) : e instanceof mr ? (t.lastDrawType !== lT && (l = true, t.lastDrawType = lT), c9(r, e, u, l, t), l9(r, e, h)) : e.getTemporalDisplayables && (t.lastDrawType !== cT && (l = true, t.lastDrawType = cT), p9(r, e, t)), c && n && nn(r, t), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), t.prevEl = e, e.__dirty = 0, e.__isRendered = true;
  }
  function p9(r, e, t) {
    var n = e.getDisplayables(), i = e.getTemporalDisplayables();
    r.save();
    var a = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: false,
      viewWidth: t.viewWidth,
      viewHeight: t.viewHeight,
      inHover: t.inHover
    }, o, s;
    for (o = e.getCursor(), s = n.length; o < s; o++) {
      var l = n[o];
      l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), bs(r, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
    }
    for (var u = 0, c = i.length; u < c; u++) {
      var l = i[u];
      l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), bs(r, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
    }
    e.clearTemporalDisplayables(), e.notClear = true, r.restore();
  }
  var Vm = new XX(), hT = new df(100), fT = [
    "symbol",
    "symbolSize",
    "symbolKeepAspect",
    "color",
    "backgroundColor",
    "dashArrayX",
    "dashArrayY",
    "maxTileWidth",
    "maxTileHeight"
  ];
  function hu(r, e) {
    if (r === "none") return null;
    var t = e.getDevicePixelRatio(), n = e.getZr(), i = n.painter.type === "svg";
    r.dirty && Vm.delete(r);
    var a = Vm.get(r);
    if (a) return a;
    var o = ye(r, {
      symbol: "rect",
      symbolSize: 1,
      symbolKeepAspect: true,
      color: "rgba(0, 0, 0, 0.2)",
      backgroundColor: null,
      dashArrayX: 5,
      dashArrayY: 5,
      rotation: 0,
      maxTileWidth: 512,
      maxTileHeight: 512
    });
    o.backgroundColor === "none" && (o.backgroundColor = null);
    var s = {
      repeat: "repeat"
    };
    return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / t, Vm.set(r, s), r.dirty = false, s;
    function l(u) {
      for (var c = [
        t
      ], h = true, f = 0; f < fT.length; ++f) {
        var d = o[fT[f]];
        if (d != null && !X(d) && !ee(d) && !nt(d) && typeof d != "boolean") {
          h = false;
          break;
        }
        c.push(d);
      }
      var p;
      if (h) {
        p = c.join(",") + (i ? "-svg" : "");
        var v = hT.get(p);
        v && (i ? u.svgElement = v : u.image = v);
      }
      var g = M3(o.dashArrayX), m = v9(o.dashArrayY), y = I3(o.symbol), x = g9(g), _ = D3(m), S = !i && so.createCanvas(), b = i && {
        tag: "g",
        attrs: {},
        key: "dcl",
        children: []
      }, w = T(), C;
      S && (S.width = w.width * t, S.height = w.height * t, C = S.getContext("2d")), A(), h && hT.put(p, S || b), u.image = S, u.svgElement = b, u.svgWidth = w.width, u.svgHeight = w.height;
      function T() {
        for (var M = 1, E = 0, k = x.length; E < k; ++E) M = DC(M, x[E]);
        for (var R = 1, E = 0, k = y.length; E < k; ++E) R = DC(R, y[E].length);
        M *= R;
        var N = _ * x.length * y.length;
        return {
          width: Math.max(1, Math.min(M, o.maxTileWidth)),
          height: Math.max(1, Math.min(N, o.maxTileHeight))
        };
      }
      function A() {
        C && (C.clearRect(0, 0, S.width, S.height), o.backgroundColor && (C.fillStyle = o.backgroundColor, C.fillRect(0, 0, S.width, S.height)));
        for (var M = 0, E = 0; E < m.length; ++E) M += m[E];
        if (M <= 0) return;
        for (var k = -_, R = 0, N = 0, I = 0; k < w.height; ) {
          if (R % 2 === 0) {
            for (var L = N / 2 % y.length, P = 0, O = 0, F = 0; P < w.width * 2; ) {
              for (var B = 0, E = 0; E < g[I].length; ++E) B += g[I][E];
              if (B <= 0) break;
              if (O % 2 === 0) {
                var V = (1 - o.symbolSize) * 0.5, U = P + g[I][O] * V, Y = k + m[R] * V, q = g[I][O] * o.symbolSize, me = m[R] * o.symbolSize, Me = F / 2 % y[L].length;
                re(U, Y, q, me, y[L][Me]);
              }
              P += g[I][O], ++F, ++O, O === g[I].length && (O = 0);
            }
            ++I, I === g.length && (I = 0);
          }
          k += m[R], ++N, ++R, R === m.length && (R = 0);
        }
        function re(J, le, te, he, Xe) {
          var Fe = i ? 1 : t, fe = Xt(Xe, J * Fe, le * Fe, te * Fe, he * Fe, o.color, o.symbolKeepAspect);
          if (i) {
            var Se = n.painter.renderOneToVNode(fe);
            Se && b.children.push(Se);
          } else A3(C, fe);
        }
      }
    }
  }
  function I3(r) {
    if (!r || r.length === 0) return [
      [
        "rect"
      ]
    ];
    if (ee(r)) return [
      [
        r
      ]
    ];
    for (var e = true, t = 0; t < r.length; ++t) if (!ee(r[t])) {
      e = false;
      break;
    }
    if (e) return I3([
      r
    ]);
    for (var n = [], t = 0; t < r.length; ++t) ee(r[t]) ? n.push([
      r[t]
    ]) : n.push(r[t]);
    return n;
  }
  function M3(r) {
    if (!r || r.length === 0) return [
      [
        0,
        0
      ]
    ];
    if (nt(r)) {
      var e = Math.ceil(r);
      return [
        [
          e,
          e
        ]
      ];
    }
    for (var t = true, n = 0; n < r.length; ++n) if (!nt(r[n])) {
      t = false;
      break;
    }
    if (t) return M3([
      r
    ]);
    for (var i = [], n = 0; n < r.length; ++n) if (nt(r[n])) {
      var e = Math.ceil(r[n]);
      i.push([
        e,
        e
      ]);
    } else {
      var e = K(r[n], function(s) {
        return Math.ceil(s);
      });
      e.length % 2 === 1 ? i.push(e.concat(e)) : i.push(e);
    }
    return i;
  }
  function v9(r) {
    if (!r || typeof r == "object" && r.length === 0) return [
      0,
      0
    ];
    if (nt(r)) {
      var e = Math.ceil(r);
      return [
        e,
        e
      ];
    }
    var t = K(r, function(n) {
      return Math.ceil(n);
    });
    return r.length % 2 ? t.concat(t) : t;
  }
  function g9(r) {
    return K(r, function(e) {
      return D3(e);
    });
  }
  function D3(r) {
    for (var e = 0, t = 0; t < r.length; ++t) e += r[t];
    return r.length % 2 === 1 ? e * 2 : e;
  }
  function m9(r, e) {
    r.eachRawSeries(function(t) {
      if (!r.isSeriesFiltered(t)) {
        var n = t.getData();
        n.hasItemVisual() && n.each(function(o) {
          var s = n.getItemVisual(o, "decal");
          if (s) {
            var l = n.ensureUniqueItemVisual(o, "style");
            l.decal = hu(s, e);
          }
        });
        var i = n.getVisual("decal");
        if (i) {
          var a = n.getVisual("style");
          a.decal = hu(i, e);
        }
      }
    });
  }
  var jn = new Vn(), P3 = {};
  function y9(r, e) {
    P3[r] = e;
  }
  function x9(r) {
    return P3[r];
  }
  var _9 = 1, b9 = 800, S9 = 900, w9 = 1e3, C9 = 2e3, T9 = 5e3, k3 = 1e3, A9 = 1100, N1 = 2e3, L3 = 3e3, I9 = 4e3, gg = 4500, M9 = 4600, D9 = 5e3, P9 = 6e3, R3 = 7e3, k9 = {
    PROCESSOR: {
      FILTER: w9,
      SERIES_FILTER: b9,
      STATISTIC: T9
    },
    VISUAL: {
      LAYOUT: k3,
      PROGRESSIVE_LAYOUT: A9,
      GLOBAL: N1,
      CHART: L3,
      POST_CHART_LAYOUT: M9,
      COMPONENT: I9,
      BRUSH: D9,
      CHART_ITEM: gg,
      ARIA: P9,
      DECAL: R3
    }
  }, Tr = "__flagInMainProcess", Qr = "__pendingUpdate", $m = "__needsUpdateStatus", dT = /^[a-zA-Z0-9_]+$/, Gm = "__connectUpdateStatus", pT = 0, L9 = 1, R9 = 2;
  function E3(r) {
    return function() {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      if (this.isDisposed()) {
        this.id;
        return;
      }
      return O3(this, r, e);
    };
  }
  function N3(r) {
    return function() {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      return O3(this, r, e);
    };
  }
  function O3(r, e, t) {
    return t[0] = t[0] && t[0].toLowerCase(), Vn.prototype[e].apply(r, t);
  }
  var F3 = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  }(Vn), B3 = F3.prototype;
  B3.on = N3("on");
  B3.off = N3("off");
  var xl, Wm, cd, La, Um, Hm, Ym, ac, oc, vT, gT, Xm, mT, hd, yT, z3, Sn, xT, V3 = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this, new $X()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, ee(n) && (n = $3[n]), a._dom = t;
      var o = "canvas", s = "auto", l = false;
      i.ssr && IH(function(f) {
        var d = De(f), p = d.dataIndex;
        if (p != null) {
          var v = ce();
          return v.set("series_index", d.seriesIndex), v.set("data_index", p), d.ssrType && v.set("ssr_type", d.ssrType), v;
        }
      });
      var u = a._zr = AC(t, {
        renderer: i.renderer || o,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: Pe(i.useDirtyRect, l),
        useCoarsePointer: Pe(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      a._ssr = i.ssr, a._throttledZrFlush = L1(ne(u.flush, u), 17), n = be(n), n && YE(n, true), a._theme = n, a._locale = Q8(i.locale || bE), a._coordSysMgr = new Sf();
      var c = a._api = yT(a);
      function h(f, d) {
        return f.__prio - d.__prio;
      }
      return hp(nv, h), hp(Jx, h), a._scheduler = new m3(a, c, Jx, nv), a._messageCenter = new F3(), a._initEvents(), a.resize = ne(a.resize, a), u.animation.on("frame", a._onframe, a), vT(u, a), gT(u, a), Np(a), a;
    }
    return e.prototype._onframe = function() {
      if (!this._disposed) {
        xT(this);
        var t = this._scheduler;
        if (this[Qr]) {
          var n = this[Qr].silent;
          this[Tr] = true;
          try {
            xl(this), La.update.call(this, null, this[Qr].updateParams);
          } catch (l) {
            throw this[Tr] = false, this[Qr] = null, l;
          }
          this._zr.flush(), this[Tr] = false, this[Qr] = null, ac.call(this, n), oc.call(this, n);
        } else if (t.unfinished) {
          var i = _9, a = this._model, o = this._api;
          t.unfinished = false;
          do {
            var s = +/* @__PURE__ */ new Date();
            t.performSeriesTasks(a), t.performDataProcessorTasks(a), Hm(this, a), t.performVisualTasks(a), hd(this, this._model, o, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && t.unfinished);
          t.unfinished || this._zr.flush();
        }
      }
    }, e.prototype.getDom = function() {
      return this._dom;
    }, e.prototype.getId = function() {
      return this.id;
    }, e.prototype.getZr = function() {
      return this._zr;
    }, e.prototype.isSSR = function() {
      return this._ssr;
    }, e.prototype.setOption = function(t, n, i) {
      if (!this[Tr]) {
        if (this._disposed) {
          this.id;
          return;
        }
        var a, o, s;
        if (_e(n) && (i = n.lazyUpdate, a = n.silent, o = n.replaceMerge, s = n.transition, n = n.notMerge), this[Tr] = true, !this._model || n) {
          var l = new wY(this._api), u = this._theme, c = this._model = new I1();
          c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
        }
        this._model.setOption(t, {
          replaceMerge: o
        }, e_);
        var h = {
          seriesTransition: s,
          optionChanged: true
        };
        if (i) this[Qr] = {
          silent: a,
          updateParams: h
        }, this[Tr] = false, this.getZr().wakeUp();
        else {
          try {
            xl(this), La.update.call(this, null, h);
          } catch (f) {
            throw this[Qr] = null, this[Tr] = false, f;
          }
          this._ssr || this._zr.flush(), this[Qr] = null, this[Tr] = false, ac.call(this, a), oc.call(this, a);
        }
      }
    }, e.prototype.setTheme = function() {
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, e.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, e.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, e.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || He.hasGlobalWindow && window.devicePixelRatio || 1;
    }, e.prototype.getRenderedCanvas = function(t) {
      return this.renderToCanvas(t);
    }, e.prototype.renderToCanvas = function(t) {
      t = t || {};
      var n = this._zr.painter;
      return n.getRenderedCanvas({
        backgroundColor: t.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
      });
    }, e.prototype.renderToSVGString = function(t) {
      t = t || {};
      var n = this._zr.painter;
      return n.renderToString({
        useViewBox: t.useViewBox
      });
    }, e.prototype.getSvgDataURL = function() {
      if (He.svgSupported) {
        var t = this._zr, n = t.storage.getDisplayList();
        return D(n, function(i) {
          i.stopAnimation(null, true);
        }), t.painter.toDataURL();
      }
    }, e.prototype.getDataURL = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      t = t || {};
      var n = t.excludeComponents, i = this._model, a = [], o = this;
      D(n, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = o._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = true);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png"));
      return D(a, function(l) {
        l.group.ignore = false;
      }), s;
    }, e.prototype.getConnectedDataURL = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      var n = t.type === "svg", i = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (_T[i]) {
        var l = s, u = s, c = -s, h = -s, f = [], d = t && t.pixelRatio || this.getDevicePixelRatio();
        D(ah, function(x, _) {
          if (x.group === i) {
            var S = n ? x.getZr().painter.getSvgDom().innerHTML : x.renderToCanvas(be(t)), b = x.getDom().getBoundingClientRect();
            l = a(b.left, l), u = a(b.top, u), c = o(b.right, c), h = o(b.bottom, h), f.push({
              dom: S,
              left: b.left,
              top: b.top
            });
          }
        }), l *= d, u *= d, c *= d, h *= d;
        var p = c - l, v = h - u, g = so.createCanvas(), m = AC(g, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: p,
          height: v
        }), n) {
          var y = "";
          return D(f, function(x) {
            var _ = x.left - l, S = x.top - u;
            y += '<g transform="translate(' + _ + "," + S + ')">' + x.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, t.connectedBackgroundColor && m.painter.setBackgroundColor(t.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else return t.connectedBackgroundColor && m.add(new et({
          shape: {
            x: 0,
            y: 0,
            width: p,
            height: v
          },
          style: {
            fill: t.connectedBackgroundColor
          }
        })), D(f, function(x) {
          var _ = new mr({
            style: {
              x: x.left * d - l,
              y: x.top * d - u,
              image: x.dom
            }
          });
          m.add(_);
        }), m.refreshImmediately(), g.toDataURL("image/" + (t && t.type || "png"));
      } else return this.getDataURL(t);
    }, e.prototype.convertToPixel = function(t, n) {
      return Um(this, "convertToPixel", t, n);
    }, e.prototype.convertFromPixel = function(t, n) {
      return Um(this, "convertFromPixel", t, n);
    }, e.prototype.containPixel = function(t, n) {
      if (this._disposed) {
        this.id;
        return;
      }
      var i = this._model, a, o = Qc(i, t);
      return D(o, function(s, l) {
        l.indexOf("Models") >= 0 && D(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint) a = a || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint && (a = a || h.containPoint(n, u));
          }
        }, this);
      }, this), !!a;
    }, e.prototype.getVisual = function(t, n) {
      var i = this._model, a = Qc(i, t, {
        defaultMainType: "series"
      }), o = a.seriesModel, s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? R1(s, l, n) : wf(s, n);
    }, e.prototype.getViewOfComponentModel = function(t) {
      return this._componentsMap[t.__viewId];
    }, e.prototype.getViewOfSeriesModel = function(t) {
      return this._chartsMap[t.__viewId];
    }, e.prototype._initEvents = function() {
      var t = this;
      D(E9, function(n) {
        var i = function(a) {
          var o = t.getModel(), s = a.target, l, u = n === "globalout";
          if (u ? l = {} : s && xs(s, function(p) {
            var v = De(p);
            if (v && v.dataIndex != null) {
              var g = v.dataModel || o.getSeriesByIndex(v.seriesIndex);
              return l = g && g.getDataParams(v.dataIndex, v.dataType, s) || {}, true;
            } else if (v.eventData) return l = H({}, v.eventData), true;
          }, true), l) {
            var c = l.componentType, h = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", h = l.seriesIndex);
            var f = c && h != null && o.getComponent(c, h), d = f && t[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            l.event = a, l.type = n, t._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: f,
              view: d
            }, t.trigger(n, l);
          }
        };
        i.zrEventfulCallAtLast = true, t._zr.on(n, i, t);
      }), D(ih, function(n, i) {
        t._messageCenter.on(i, function(a) {
          this.trigger(i, a);
        }, t);
      }), D([
        "selectchanged"
      ], function(n) {
        t._messageCenter.on(n, function(i) {
          this.trigger(n, i);
        }, t);
      }), UX(this._messageCenter, this, this._api);
    }, e.prototype.isDisposed = function() {
      return this._disposed;
    }, e.prototype.clear = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this.setOption({
        series: []
      }, true);
    }, e.prototype.dispose = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._disposed = true;
      var t = this.getDom();
      t && RR(this.getDom(), F1, "");
      var n = this, i = n._api, a = n._model;
      D(n._componentsViews, function(o) {
        o.dispose(a, i);
      }), D(n._chartsViews, function(o) {
        o.dispose(a, i);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete ah[n.id];
    }, e.prototype.resize = function(t) {
      if (!this[Tr]) {
        if (this._disposed) {
          this.id;
          return;
        }
        this._zr.resize(t);
        var n = this._model;
        if (this._loadingFX && this._loadingFX.resize(), !!n) {
          var i = n.resetOption("media"), a = t && t.silent;
          this[Qr] && (a == null && (a = this[Qr].silent), i = true, this[Qr] = null), this[Tr] = true;
          try {
            i && xl(this), La.update.call(this, {
              type: "resize",
              animation: H({
                duration: 0
              }, t && t.animation)
            });
          } catch (o) {
            throw this[Tr] = false, o;
          }
          this[Tr] = false, ac.call(this, a), oc.call(this, a);
        }
      }
    }, e.prototype.showLoading = function(t, n) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (_e(t) && (n = t, t = ""), t = t || "default", this.hideLoading(), !!t_[t]) {
        var i = t_[t](this._api, n), a = this._zr;
        this._loadingFX = i, a.add(i);
      }
    }, e.prototype.hideLoading = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, e.prototype.makeActionFromEvent = function(t) {
      var n = H({}, t);
      return n.type = ih[t.type], n;
    }, e.prototype.dispatchAction = function(t, n) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (_e(n) || (n = {
        silent: !!n
      }), !!rv[t.type] && this._model) {
        if (this[Tr]) {
          this._pendingActions.push(t);
          return;
        }
        var i = n.silent;
        Ym.call(this, t, i);
        var a = n.flush;
        a ? this._zr.flush() : a !== false && He.browser.weChat && this._throttledZrFlush(), ac.call(this, i), oc.call(this, i);
      }
    }, e.prototype.updateLabelLayout = function() {
      jn.trigger("series:layoutlabels", this._model, this._api, {
        updatedSeries: []
      });
    }, e.prototype.appendData = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      var n = t.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(n);
      a.appendData(t), this._scheduler.unfinished = true, this.getZr().wakeUp();
    }, e.internalField = function() {
      xl = function(h) {
        var f = h._scheduler;
        f.restorePipelines(h._model), f.prepareStageTasks(), Wm(h, true), Wm(h, false), f.plan();
      }, Wm = function(h, f) {
        for (var d = h._model, p = h._scheduler, v = f ? h._componentsViews : h._chartsViews, g = f ? h._componentsMap : h._chartsMap, m = h._zr, y = h._api, x = 0; x < v.length; x++) v[x].__alive = false;
        f ? d.eachComponent(function(b, w) {
          b !== "series" && _(w);
        }) : d.eachSeries(_);
        function _(b) {
          var w = b.__requireNewView;
          b.__requireNewView = false;
          var C = "_ec_" + b.id + "_" + b.type, T = !w && g[C];
          if (!T) {
            var A = Di(b.type), M = f ? Rt.getClass(A.main, A.sub) : yt.getClass(A.sub);
            T = new M(), T.init(d, y), g[C] = T, v.push(T), m.add(T.group);
          }
          b.__viewId = T.__id = C, T.__alive = true, T.__model = b, T.group.__ecComponentInfo = {
            mainType: b.mainType,
            index: b.componentIndex
          }, !f && p.prepareView(T, b, d, y);
        }
        for (var x = 0; x < v.length; ) {
          var S = v[x];
          S.__alive ? x++ : (!f && S.renderTask.dispose(), m.remove(S.group), S.dispose(d, y), v.splice(x, 1), g[S.__id] === S && delete g[S.__id], S.__id = S.group.__ecComponentInfo = null);
        }
      }, cd = function(h, f, d, p, v) {
        var g = h._model;
        if (g.setUpdatePayload(d), !p) {
          D([].concat(h._componentsViews).concat(h._chartsViews), S);
          return;
        }
        var m = {};
        m[p + "Id"] = d[p + "Id"], m[p + "Index"] = d[p + "Index"], m[p + "Name"] = d[p + "Name"];
        var y = {
          mainType: p,
          query: m
        };
        v && (y.subType = v);
        var x = d.excludeSeriesId, _;
        x != null && (_ = ce(), D(gt(x), function(b) {
          var w = jt(b, null);
          w != null && _.set(w, true);
        })), g && g.eachComponent(y, function(b) {
          var w = _ && _.get(b.id) != null;
          if (!w) if (t2(d)) if (b instanceof Tt) d.type === Ds && !d.notBlur && !b.get([
            "emphasis",
            "disabled"
          ]) && j6(b, d, h._api);
          else {
            var C = f1(b.mainType, b.componentIndex, d.name, h._api), T = C.focusSelf, A = C.dispatchers;
            d.type === Ds && T && !d.notBlur && Nx(b.mainType, b.componentIndex, h._api), A && D(A, function(M) {
              d.type === Ds ? ga(M) : ma(M);
            });
          }
          else Fx(d) && b instanceof Tt && (e8(b, d, h._api), JC(b), Sn(h));
        }, h), g && g.eachComponent(y, function(b) {
          var w = _ && _.get(b.id) != null;
          w || S(h[p === "series" ? "_chartsMap" : "_componentsMap"][b.__viewId]);
        }, h);
        function S(b) {
          b && b.__alive && b[f] && b[f](b.__model, g, h._api, d);
        }
      }, La = {
        prepareAndUpdate: function(h) {
          xl(this), La.update.call(this, h, {
            optionChanged: h.newOption != null
          });
        },
        update: function(h, f) {
          var d = this._model, p = this._api, v = this._zr, g = this._coordSysMgr, m = this._scheduler;
          if (d) {
            d.setUpdatePayload(h), m.restoreData(d, h), m.performSeriesTasks(d), g.create(d, p), m.performDataProcessorTasks(d, h), Hm(this, d), g.update(d, p), t(d), m.performVisualTasks(d, h), Xm(this, d, p, h, f);
            var y = d.get("backgroundColor") || "transparent", x = d.get("darkMode");
            v.setBackgroundColor(y), x != null && x !== "auto" && v.setDarkMode(x), jn.trigger("afterupdate", d, p);
          }
        },
        updateTransform: function(h) {
          var f = this, d = this._model, p = this._api;
          if (d) {
            d.setUpdatePayload(h);
            var v = [];
            d.eachComponent(function(m, y) {
              if (m !== "series") {
                var x = f.getViewOfComponentModel(y);
                if (x && x.__alive) if (x.updateTransform) {
                  var _ = x.updateTransform(y, d, p, h);
                  _ && _.update && v.push(x);
                } else v.push(x);
              }
            });
            var g = ce();
            d.eachSeries(function(m) {
              var y = f._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var x = y.updateTransform(m, d, p, h);
                x && x.update && g.set(m.uid, 1);
              } else g.set(m.uid, 1);
            }), t(d), this._scheduler.performVisualTasks(d, h, {
              setDirty: true,
              dirtyMap: g
            }), hd(this, d, p, h, {}, g), jn.trigger("afterupdate", d, p);
          }
        },
        updateView: function(h) {
          var f = this._model;
          f && (f.setUpdatePayload(h), yt.markUpdateMethod(h, "updateView"), t(f), this._scheduler.performVisualTasks(f, h, {
            setDirty: true
          }), Xm(this, f, this._api, h, {}), jn.trigger("afterupdate", f, this._api));
        },
        updateVisual: function(h) {
          var f = this, d = this._model;
          d && (d.setUpdatePayload(h), d.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), yt.markUpdateMethod(h, "updateVisual"), t(d), this._scheduler.performVisualTasks(d, h, {
            visualType: "visual",
            setDirty: true
          }), d.eachComponent(function(p, v) {
            if (p !== "series") {
              var g = f.getViewOfComponentModel(v);
              g && g.__alive && g.updateVisual(v, d, f._api, h);
            }
          }), d.eachSeries(function(p) {
            var v = f._chartsMap[p.__viewId];
            v.updateVisual(p, d, f._api, h);
          }), jn.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(h) {
          La.update.call(this, h);
        }
      }, Um = function(h, f, d, p) {
        if (h._disposed) {
          h.id;
          return;
        }
        for (var v = h._model, g = h._coordSysMgr.getCoordinateSystems(), m, y = Qc(v, d), x = 0; x < g.length; x++) {
          var _ = g[x];
          if (_[f] && (m = _[f](v, y, p)) != null) return m;
        }
      }, Hm = function(h, f) {
        var d = h._chartsMap, p = h._scheduler;
        f.eachSeries(function(v) {
          p.updateStreamModes(v, d[v.__viewId]);
        });
      }, Ym = function(h, f) {
        var d = this, p = this.getModel(), v = h.type, g = h.escapeConnect, m = rv[v], y = m.actionInfo, x = (y.update || "update").split(":"), _ = x.pop(), S = x[0] != null && Di(x[0]);
        this[Tr] = true;
        var b = [
          h
        ], w = false;
        h.batch && (w = true, b = K(h.batch, function(R) {
          return R = ye(H({}, R), h), R.batch = null, R;
        }));
        var C = [], T, A = Fx(h), M = t2(h);
        if (M && eE(this._api), D(b, function(R) {
          if (T = m.action(R, d._model, d._api), T = T || H({}, R), T.type = y.event || T.type, C.push(T), M) {
            var N = i1(h), I = N.queryOptionMap, L = N.mainTypeSpecified, P = L ? I.keys()[0] : "series";
            cd(d, _, R, P), Sn(d);
          } else A ? (cd(d, _, R, "series"), Sn(d)) : S && cd(d, _, R, S.main, S.sub);
        }), _ !== "none" && !M && !A && !S) try {
          this[Qr] ? (xl(this), La.update.call(this, h), this[Qr] = null) : La[_].call(this, h);
        } catch (R) {
          throw this[Tr] = false, R;
        }
        if (w ? T = {
          type: y.event || v,
          escapeConnect: g,
          batch: C
        } : T = C[0], this[Tr] = false, !f) {
          var E = this._messageCenter;
          if (E.trigger(T.type, T), A) {
            var k = {
              type: "selectchanged",
              escapeConnect: g,
              selected: t8(p),
              isFromClick: h.isFromClick || false,
              fromAction: h.type,
              fromActionPayload: h
            };
            E.trigger(k.type, k);
          }
        }
      }, ac = function(h) {
        for (var f = this._pendingActions; f.length; ) {
          var d = f.shift();
          Ym.call(this, d, h);
        }
      }, oc = function(h) {
        !h && this.trigger("updated");
      }, vT = function(h, f) {
        h.on("rendered", function(d) {
          f.trigger("rendered", d), h.animation.isFinished() && !f[Qr] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
        });
      }, gT = function(h, f) {
        h.on("mouseover", function(d) {
          var p = d.target, v = xs(p, Ih);
          v && (Q6(v, d, f._api), Sn(f));
        }).on("mouseout", function(d) {
          var p = d.target, v = xs(p, Ih);
          v && (J6(v, d, f._api), Sn(f));
        }).on("click", function(d) {
          var p = d.target, v = xs(p, function(y) {
            return De(y).dataIndex != null;
          }, true);
          if (v) {
            var g = v.selected ? "unselect" : "select", m = De(v);
            f._api.dispatchAction({
              type: g,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: true
            });
          }
        });
      };
      function t(h) {
        h.clearColorPalette(), h.eachSeries(function(f) {
          f.clearColorPalette();
        });
      }
      function n(h) {
        var f = [], d = [], p = false;
        if (h.eachComponent(function(y, x) {
          var _ = x.get("zlevel") || 0, S = x.get("z") || 0, b = x.getZLevelKey();
          p = p || !!b, (y === "series" ? d : f).push({
            zlevel: _,
            z: S,
            idx: x.componentIndex,
            type: y,
            key: b
          });
        }), p) {
          var v = f.concat(d), g, m;
          hp(v, function(y, x) {
            return y.zlevel === x.zlevel ? y.z - x.z : y.zlevel - x.zlevel;
          }), D(v, function(y) {
            var x = h.getComponent(y.type, y.idx), _ = y.zlevel, S = y.key;
            g != null && (_ = Math.max(g, _)), S ? (_ === g && S !== m && _++, m = S) : m && (_ === g && _++, m = ""), g = _, x.setZLevel(_);
          });
        }
      }
      Xm = function(h, f, d, p, v) {
        n(f), mT(h, f, d, p, v), D(h._chartsViews, function(g) {
          g.__alive = false;
        }), hd(h, f, d, p, v), D(h._chartsViews, function(g) {
          g.__alive || g.remove(f, d);
        });
      }, mT = function(h, f, d, p, v, g) {
        D(g || h._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, f, d, p), s(y, m), c(y, m);
        });
      }, hd = function(h, f, d, p, v, g) {
        var m = h._scheduler;
        v = H(v || {}, {
          updatedSeries: f.getSeries()
        }), jn.trigger("series:beforeupdate", f, d, v);
        var y = false;
        f.eachSeries(function(x) {
          var _ = h._chartsMap[x.__viewId];
          _.__alive = true;
          var S = _.renderTask;
          m.updatePayload(S, p), u(x, _), g && g.get(x.uid) && S.dirty(), S.perform(m.getPerformArgs(S)) && (y = true), _.group.silent = !!x.get("silent"), o(x, _), JC(x);
        }), m.unfinished = y || m.unfinished, jn.trigger("series:layoutlabels", f, d, v), jn.trigger("series:transition", f, d, v), f.eachSeries(function(x) {
          var _ = h._chartsMap[x.__viewId];
          s(x, _), c(x, _);
        }), a(h, f), jn.trigger("series:afterupdate", f, d, v);
      }, Sn = function(h) {
        h[$m] = true, h.getZr().wakeUp();
      }, xT = function(h) {
        h[$m] && (h.getZr().storage.traverse(function(f) {
          eu(f) || i(f);
        }), h[$m] = false);
      };
      function i(h) {
        for (var f = [], d = h.currentStates, p = 0; p < d.length; p++) {
          var v = d[p];
          v === "emphasis" || v === "blur" || v === "select" || f.push(v);
        }
        h.selected && h.states.select && f.push("select"), h.hoverState === eg && h.states.emphasis ? f.push("emphasis") : h.hoverState === gf && h.states.blur && f.push("blur"), h.useStates(f);
      }
      function a(h, f) {
        var d = h._zr, p = d.storage, v = 0;
        p.traverse(function(g) {
          g.isGroup || v++;
        }), v > f.get("hoverLayerThreshold") && !He.node && !He.worker && f.eachSeries(function(g) {
          if (!g.preventUsingHoverLayer) {
            var m = h._chartsMap[g.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = true);
            });
          }
        });
      }
      function o(h, f) {
        var d = h.get("blendMode") || null;
        f.eachRendered(function(p) {
          p.isGroup || (p.style.blend = d);
        });
      }
      function s(h, f) {
        if (!h.preventAutoZ) {
          var d = h.get("z") || 0, p = h.get("zlevel") || 0;
          f.eachRendered(function(v) {
            return l(v, d, p, -1 / 0), true;
          });
        }
      }
      function l(h, f, d, p) {
        var v = h.getTextContent(), g = h.getTextGuideLine(), m = h.isGroup;
        if (m) for (var y = h.childrenRef(), x = 0; x < y.length; x++) p = Math.max(l(y[x], f, d, p), p);
        else h.z = f, h.zlevel = d, p = Math.max(h.z2, p);
        if (v && (v.z = f, v.zlevel = d, isFinite(p) && (v.z2 = p + 2)), g) {
          var _ = h.textGuideLineConfig;
          g.z = f, g.zlevel = d, isFinite(p) && (g.z2 = p + (_ && _.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(h, f) {
        f.eachRendered(function(d) {
          if (!eu(d)) {
            var p = d.getTextContent(), v = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), v && v.stateTransition && (v.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function c(h, f) {
        var d = h.getModel("stateAnimation"), p = h.isAnimationEnabled(), v = d.get("duration"), g = v > 0 ? {
          duration: v,
          delay: d.get("delay"),
          easing: d.get("easing")
        } : null;
        f.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (eu(m)) return;
            if (m instanceof Ue && o8(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (p) {
              m.stateTransition = g;
              var x = m.getTextContent(), _ = m.getTextGuideLine();
              x && (x.stateTransition = g), _ && (_.stateTransition = g);
            }
            m.__dirty && i(m);
          }
        });
      }
      yT = function(h) {
        return new (function(f) {
          G(d, f);
          function d() {
            return f !== null && f.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var v = p.__ecComponentInfo;
              if (v != null) return h._model.getComponent(v.mainType, v.index);
              p = p.parent;
            }
          }, d.prototype.enterEmphasis = function(p, v) {
            ga(p, v), Sn(h);
          }, d.prototype.leaveEmphasis = function(p, v) {
            ma(p, v), Sn(h);
          }, d.prototype.enterBlur = function(p) {
            ZR(p), Sn(h);
          }, d.prototype.leaveBlur = function(p) {
            h1(p), Sn(h);
          }, d.prototype.enterSelect = function(p) {
            jR(p), Sn(h);
          }, d.prototype.leaveSelect = function(p) {
            QR(p), Sn(h);
          }, d.prototype.getModel = function() {
            return h.getModel();
          }, d.prototype.getViewOfComponentModel = function(p) {
            return h.getViewOfComponentModel(p);
          }, d.prototype.getViewOfSeriesModel = function(p) {
            return h.getViewOfSeriesModel(p);
          }, d;
        }(UE))(h);
      }, z3 = function(h) {
        function f(d, p) {
          for (var v = 0; v < d.length; v++) {
            var g = d[v];
            g[Gm] = p;
          }
        }
        D(ih, function(d, p) {
          h._messageCenter.on(p, function(v) {
            if (_T[h.group] && h[Gm] !== pT) {
              if (v && v.escapeConnect) return;
              var g = h.makeActionFromEvent(v), m = [];
              D(ah, function(y) {
                y !== h && y.group === h.group && m.push(y);
              }), f(m, pT), D(m, function(y) {
                y[Gm] !== L9 && y.dispatchAction(g);
              }), f(m, R9);
            }
          });
        });
      };
    }(), e;
  }(Vn), O1 = V3.prototype;
  O1.on = E3("on");
  O1.off = E3("off");
  O1.one = function(r, e, t) {
    var n = this;
    function i() {
      for (var a = [], o = 0; o < arguments.length; o++) a[o] = arguments[o];
      e && e.apply && e.apply(this, a), n.off(r, i);
    }
    this.on.call(this, r, i, t);
  };
  var E9 = [
    "click",
    "dblclick",
    "mouseover",
    "mouseout",
    "mousemove",
    "mousedown",
    "mouseup",
    "globalout",
    "contextmenu"
  ];
  var rv = {}, ih = {}, Jx = [], e_ = [], nv = [], $3 = {}, t_ = {}, ah = {}, _T = {}, N9 = +/* @__PURE__ */ new Date() - 0, F1 = "_echarts_instance_";
  function O9(r, e, t) {
    {
      var n = F9(r);
      if (n) return n;
    }
    var i = new V3(r, e, t);
    return i.id = "ec_" + N9++, ah[i.id] = i, RR(r, F1, i.id), z3(i), jn.trigger("afterinit", i), i;
  }
  function F9(r) {
    return ah[qH(r, F1)];
  }
  function G3(r, e) {
    $3[r] = e;
  }
  function W3(r) {
    Be(e_, r) < 0 && e_.push(r);
  }
  function U3(r, e) {
    z1(Jx, r, e, C9);
  }
  function B9(r) {
    B1("afterinit", r);
  }
  function z9(r) {
    B1("afterupdate", r);
  }
  function B1(r, e) {
    jn.on(r, e);
  }
  function Ui(r, e, t) {
    ge(e) && (t = e, e = "");
    var n = _e(r) ? r.type : [
      r,
      r = {
        event: e
      }
    ][0];
    r.event = (r.event || n).toLowerCase(), e = r.event, !ih[e] && (Yr(dT.test(n) && dT.test(e)), rv[n] || (rv[n] = {
      action: t,
      actionInfo: r
    }), ih[e] = n);
  }
  function V9(r, e) {
    Sf.register(r, e);
  }
  function $9(r, e) {
    z1(nv, r, e, k3, "layout");
  }
  function Qs(r, e) {
    z1(nv, r, e, L3, "visual");
  }
  var bT = [];
  function z1(r, e, t, n, i) {
    if ((ge(e) || _e(e)) && (t = e, e = n), !(Be(bT, t) >= 0)) {
      bT.push(t);
      var a = m3.wrapStageHandler(t, i);
      a.__prio = e, a.__raw = t, r.push(a);
    }
  }
  function H3(r, e) {
    t_[r] = e;
  }
  function G9(r, e, t) {
    var n = x9("registerMap");
    n && n(r, e, t);
  }
  var W9 = tX;
  Qs(N1, IX);
  Qs(gg, MX);
  Qs(gg, DX);
  Qs(N1, GX);
  Qs(gg, WX);
  Qs(R3, m9);
  W3(YE);
  U3(S9, NY);
  H3("default", PX);
  Ui({
    type: Ds,
    event: Ds,
    update: Ds
  }, Wt);
  Ui({
    type: mp,
    event: mp,
    update: mp
  }, Wt);
  Ui({
    type: Jc,
    event: Jc,
    update: Jc
  }, Wt);
  Ui({
    type: yp,
    event: yp,
    update: yp
  }, Wt);
  Ui({
    type: eh,
    event: eh,
    update: eh
  }, Wt);
  G3("light", VX);
  G3("dark", b3);
  var ST = [], U9 = {
    registerPreprocessor: W3,
    registerProcessor: U3,
    registerPostInit: B9,
    registerPostUpdate: z9,
    registerUpdateLifecycle: B1,
    registerAction: Ui,
    registerCoordinateSystem: V9,
    registerLayout: $9,
    registerVisual: Qs,
    registerTransform: W9,
    registerLoading: H3,
    registerMap: G9,
    registerImpl: y9,
    PRIORITY: k9,
    ComponentModel: Ke,
    ComponentView: Rt,
    SeriesModel: Tt,
    ChartView: yt,
    registerComponentModel: function(r) {
      Ke.registerClass(r);
    },
    registerComponentView: function(r) {
      Rt.registerClass(r);
    },
    registerSeriesModel: function(r) {
      Tt.registerClass(r);
    },
    registerChartView: function(r) {
      yt.registerClass(r);
    },
    registerSubTypeDefaulter: function(r, e) {
      Ke.registerSubTypeDefaulter(r, e);
    },
    registerPainter: function(r, e) {
      TH(r, e);
    }
  };
  function Ve(r) {
    if (X(r)) {
      D(r, function(e) {
        Ve(e);
      });
      return;
    }
    Be(ST, r) >= 0 || (ST.push(r), ge(r) && (r = {
      install: r
    }), r.install(U9));
  }
  function sc(r) {
    return r == null ? 0 : r.length || 1;
  }
  function wT(r) {
    return r;
  }
  var ya = function() {
    function r(e, t, n, i, a, o) {
      this._old = e, this._new = t, this._oldKeyGetter = n || wT, this._newKeyGetter = i || wT, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return r.prototype.add = function(e) {
      return this._add = e, this;
    }, r.prototype.update = function(e) {
      return this._update = e, this;
    }, r.prototype.updateManyToOne = function(e) {
      return this._updateManyToOne = e, this;
    }, r.prototype.updateOneToMany = function(e) {
      return this._updateOneToMany = e, this;
    }, r.prototype.updateManyToMany = function(e) {
      return this._updateManyToMany = e, this;
    }, r.prototype.remove = function(e) {
      return this._remove = e, this;
    }, r.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, r.prototype._executeOneToOne = function() {
      var e = this._old, t = this._new, n = {}, i = new Array(e.length), a = new Array(t.length);
      this._initIndexMap(e, null, i, "_oldKeyGetter"), this._initIndexMap(t, n, a, "_newKeyGetter");
      for (var o = 0; o < e.length; o++) {
        var s = i[o], l = n[s], u = sc(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[s] = l[0]), this._update && this._update(c, o);
        } else u === 1 ? (n[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, n);
    }, r.prototype._executeMultiple = function() {
      var e = this._old, t = this._new, n = {}, i = {}, a = [], o = [];
      this._initIndexMap(e, n, a, "_oldKeyGetter"), this._initIndexMap(t, i, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = n[l], c = i[l], h = sc(u), f = sc(c);
        if (h > 1 && f === 1) this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (h === 1 && f > 1) this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (h === 1 && f === 1) this._update && this._update(c, u), i[l] = null;
        else if (h > 1 && f > 1) this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (h > 1) for (var d = 0; d < h; d++) this._remove && this._remove(u[d]);
        else this._remove && this._remove(u);
      }
      this._performRestAdd(o, i);
    }, r.prototype._performRestAdd = function(e, t) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n], a = t[i], o = sc(a);
        if (o > 1) for (var s = 0; s < o; s++) this._add && this._add(a[s]);
        else o === 1 && this._add && this._add(a);
        t[i] = null;
      }
    }, r.prototype._initIndexMap = function(e, t, n, i) {
      for (var a = this._diffModeMultiple, o = 0; o < e.length; o++) {
        var s = "_ec_" + this[i](e[o], o);
        if (a || (n[o] = s), !!t) {
          var l = t[s], u = sc(l);
          u === 0 ? (t[s] = o, a && n.push(s)) : u === 1 ? t[s] = [
            l,
            o
          ] : l.push(o);
        }
      }
    }, r;
  }(), H9 = function() {
    function r(e, t) {
      this._encode = e, this._schema = t;
    }
    return r.prototype.get = function() {
      return {
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, r.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, r;
  }();
  function Y9(r, e) {
    var t = {}, n = t.encode = {}, i = ce(), a = [], o = [], s = {};
    D(r.dimensions, function(f) {
      var d = r.getDimensionInfo(f), p = d.coordDim;
      if (p) {
        var v = d.coordDimIndex;
        qm(n, p)[v] = f, d.isExtraCoord || (i.set(p, 1), X9(d.type) && (a[0] = f), qm(s, p)[v] = r.getDimensionIndex(d.name)), d.defaultTooltip && o.push(f);
      }
      FE.each(function(g, m) {
        var y = qm(n, m), x = d.otherDims[m];
        x != null && x !== false && (y[x] = d.name);
      });
    });
    var l = [], u = {};
    i.each(function(f, d) {
      var p = n[d];
      u[d] = p[0], l = l.concat(p);
    }), t.dataDimsOnCoord = l, t.dataDimIndicesOnCoord = K(l, function(f) {
      return r.getDimensionInfo(f).storeDimIndex;
    }), t.encodeFirstDimNotExtra = u;
    var c = n.label;
    c && c.length && (a = c.slice());
    var h = n.tooltip;
    return h && h.length ? o = h.slice() : o.length || (o = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = o, t.userOutput = new H9(s, e), t;
  }
  function qm(r, e) {
    return r.hasOwnProperty(e) || (r[e] = []), r[e];
  }
  function iv(r) {
    return r === "category" ? "ordinal" : r === "time" ? "time" : "float";
  }
  function X9(r) {
    return !(r === "ordinal" || r === "time");
  }
  var wp = /* @__PURE__ */ function() {
    function r(e) {
      this.otherDims = {}, e != null && H(this, e);
    }
    return r;
  }(), q9 = tt(), K9 = {
    float: "f",
    int: "i",
    ordinal: "o",
    number: "n",
    time: "t"
  }, Y3 = function() {
    function r(e) {
      this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted);
    }
    return r.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, r.prototype._updateDimOmitted = function(e) {
      this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = K3(this.source)));
    }, r.prototype.getSourceDimensionIndex = function(e) {
      return Pe(this._dimNameMap.get(e), -1);
    }, r.prototype.getSourceDimension = function(e) {
      var t = this.source.dimensionsDefine;
      if (t) return t[e];
    }, r.prototype.makeStoreSchema = function() {
      for (var e = this._fullDimCount, t = qE(this.source), n = !Z3(e), i = "", a = [], o = 0, s = 0; o < e; o++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[s];
        if (h && h.storeDimIndex === o) l = t ? h.name : null, u = h.type, c = h.ordinalMeta, s++;
        else {
          var f = this.getSourceDimension(o);
          f && (l = t ? f.name : null, u = f.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), t && l != null && (!h || !h.isCalculationCoord) && (i += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += K9[u] || "f", c && (i += c.uid), i += "$";
      }
      var d = this.source, p = [
        d.seriesLayoutBy,
        d.startIndex,
        i
      ].join("$$");
      return {
        dimensions: a,
        hash: p
      };
    }, r.prototype.makeOutputDimensionNames = function() {
      for (var e = [], t = 0, n = 0; t < this._fullDimCount; t++) {
        var i = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === t) a.isCalculationCoord || (i = a.name), n++;
        else {
          var o = this.getSourceDimension(t);
          o && (i = o.name);
        }
        e.push(i);
      }
      return e;
    }, r.prototype.appendCalculationDimension = function(e) {
      this.dimensions.push(e), e.isCalculationCoord = true, this._fullDimCount++, this._updateDimOmitted(true);
    }, r;
  }();
  function X3(r) {
    return r instanceof Y3;
  }
  function q3(r) {
    for (var e = ce(), t = 0; t < (r || []).length; t++) {
      var n = r[t], i = _e(n) ? n.name : n;
      i != null && e.get(i) == null && e.set(i, t);
    }
    return e;
  }
  function K3(r) {
    var e = q9(r);
    return e.dimNameMap || (e.dimNameMap = q3(r.dimensionsDefine));
  }
  function Z3(r) {
    return r > 30;
  }
  var lc = _e, Ra = K, Z9 = typeof Int32Array > "u" ? Array : Int32Array, j9 = "e\0\0", CT = -1, Q9 = [
    "hasItemOption",
    "_nameList",
    "_idList",
    "_invertedIndicesMap",
    "_dimSummary",
    "userOutput",
    "_rawData",
    "_dimValueGetter",
    "_nameDimIdx",
    "_idDimIdx",
    "_nameRepeatCount"
  ], J9 = [
    "_approximateExtent"
  ], TT, fd, uc, cc, Km, hc, Zm, Wr = function() {
    function r(e, t) {
      this.type = "list", this._dimOmitted = false, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = false, this.TRANSFERABLE_METHODS = [
        "cloneShallow",
        "downSample",
        "minmaxDownSample",
        "lttbDownSample",
        "map"
      ], this.CHANGABLE_METHODS = [
        "filterSelf",
        "selectRange"
      ], this.DOWNSAMPLE_METHODS = [
        "downSample",
        "minmaxDownSample",
        "lttbDownSample"
      ];
      var n, i = false;
      X3(e) ? (n = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (i = true, n = e), n = n || [
        "x",
        "y"
      ];
      for (var a = {}, o = [], s = {}, l = false, u = {}, c = 0; c < n.length; c++) {
        var h = n[c], f = ee(h) ? new wp({
          name: h
        }) : h instanceof wp ? h : new wp(h), d = f.name;
        f.type = f.type || "float", f.coordDim || (f.coordDim = d, f.coordDimIndex = 0);
        var p = f.otherDims = f.otherDims || {};
        o.push(d), a[d] = f, u[d] != null && (l = true), f.createInvertedIndices && (s[d] = []), p.itemName === 0 && (this._nameDimIdx = c), p.itemId === 0 && (this._idDimIdx = c), i && (f.storeDimIndex = c);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = t, this._invertedIndicesMap = s, this._dimOmitted) {
        var v = this._dimIdxToName = ce();
        D(o, function(g) {
          v.set(a[g].storeDimIndex, g);
        });
      }
    }
    return r.prototype.getDimension = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t == null) return e;
      if (t = e, !this._dimOmitted) return this.dimensions[t];
      var n = this._dimIdxToName.get(t);
      if (n != null) return n;
      var i = this._schema.getSourceDimension(t);
      if (i) return i.name;
    }, r.prototype.getDimensionIndex = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t != null) return t;
      if (e == null) return -1;
      var n = this._getDimInfo(e);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1;
    }, r.prototype._recognizeDimIndex = function(e) {
      if (nt(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0)) return +e;
    }, r.prototype._getStoreDimIndex = function(e) {
      var t = this.getDimensionIndex(e);
      return t;
    }, r.prototype.getDimensionInfo = function(e) {
      return this._getDimInfo(this.getDimension(e));
    }, r.prototype._initGetDimensionInfo = function(e) {
      var t = this._dimInfos;
      this._getDimInfo = e ? function(n) {
        return t.hasOwnProperty(n) ? t[n] : void 0;
      } : function(n) {
        return t[n];
      };
    }, r.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, r.prototype.mapDimension = function(e, t) {
      var n = this._dimSummary;
      if (t == null) return n.encodeFirstDimNotExtra[e];
      var i = n.encode[e];
      return i ? i[t] : null;
    }, r.prototype.mapDimensionsAll = function(e) {
      var t = this._dimSummary, n = t.encode[e];
      return (n || []).slice();
    }, r.prototype.getStore = function() {
      return this._store;
    }, r.prototype.initData = function(e, t, n) {
      var i = this, a;
      if (e instanceof Yx && (a = e), !a) {
        var o = this.dimensions, s = M1(e) || Lr(e) ? new KE(e, o.length) : e;
        a = new Yx();
        var l = Ra(o, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, n);
      }
      this._store = a, this._nameList = (t || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = Y9(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, r.prototype.appendData = function(e) {
      var t = this._store.appendData(e);
      this._doInit(t[0], t[1]);
    }, r.prototype.appendValues = function(e, t) {
      var n = this._store.appendValues(e, t && t.length), i = n.start, a = n.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), t) for (var s = i; s < a; s++) {
        var l = s - i;
        this._nameList[s] = t[l], o && Zm(this, s);
      }
    }, r.prototype._updateOrdinalMeta = function() {
      for (var e = this._store, t = this.dimensions, n = 0; n < t.length; n++) {
        var i = this._dimInfos[t[n]];
        i.ordinalMeta && e.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, r.prototype._shouldMakeIdFromName = function() {
      var e = this._store.getProvider();
      return this._idDimIdx == null && e.getSource().sourceFormat !== ro && !e.fillStorage;
    }, r.prototype._doInit = function(e, t) {
      if (!(e >= t)) {
        var n = this._store, i = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = i.getSource().sourceFormat, l = s === $n;
        if (l && !i.pure) for (var u = [], c = e; c < t; c++) {
          var h = i.getItem(c, u);
          if (!this.hasItemOption && NH(h) && (this.hasItemOption = true), h) {
            var f = h.name;
            a[c] == null && f != null && (a[c] = jt(f, null));
            var d = h.id;
            o[c] == null && d != null && (o[c] = jt(d, null));
          }
        }
        if (this._shouldMakeIdFromName()) for (var c = e; c < t; c++) Zm(this, c);
        TT(this);
      }
    }, r.prototype.getApproximateExtent = function(e) {
      return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e));
    }, r.prototype.setApproximateExtent = function(e, t) {
      t = this.getDimension(t), this._approximateExtent[t] = e.slice();
    }, r.prototype.getCalculationInfo = function(e) {
      return this._calculationInfo[e];
    }, r.prototype.setCalculationInfo = function(e, t) {
      lc(e) ? H(this._calculationInfo, e) : this._calculationInfo[e] = t;
    }, r.prototype.getName = function(e) {
      var t = this.getRawIndex(e), n = this._nameList[t];
      return n == null && this._nameDimIdx != null && (n = uc(this, this._nameDimIdx, t)), n == null && (n = ""), n;
    }, r.prototype._getCategory = function(e, t) {
      var n = this._store.get(e, t), i = this._store.getOrdinalMeta(e);
      return i ? i.categories[n] : n;
    }, r.prototype.getId = function(e) {
      return fd(this, this.getRawIndex(e));
    }, r.prototype.count = function() {
      return this._store.count();
    }, r.prototype.get = function(e, t) {
      var n = this._store, i = this._dimInfos[e];
      if (i) return n.get(i.storeDimIndex, t);
    }, r.prototype.getByRawIndex = function(e, t) {
      var n = this._store, i = this._dimInfos[e];
      if (i) return n.getByRawIndex(i.storeDimIndex, t);
    }, r.prototype.getIndices = function() {
      return this._store.getIndices();
    }, r.prototype.getDataExtent = function(e) {
      return this._store.getDataExtent(this._getStoreDimIndex(e));
    }, r.prototype.getSum = function(e) {
      return this._store.getSum(this._getStoreDimIndex(e));
    }, r.prototype.getMedian = function(e) {
      return this._store.getMedian(this._getStoreDimIndex(e));
    }, r.prototype.getValues = function(e, t) {
      var n = this, i = this._store;
      return X(e) ? i.getValues(Ra(e, function(a) {
        return n._getStoreDimIndex(a);
      }), t) : i.getValues(e);
    }, r.prototype.hasValue = function(e) {
      for (var t = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = t.length; n < i; n++) if (isNaN(this._store.get(t[n], e))) return false;
      return true;
    }, r.prototype.indexOfName = function(e) {
      for (var t = 0, n = this._store.count(); t < n; t++) if (this.getName(t) === e) return t;
      return -1;
    }, r.prototype.getRawIndex = function(e) {
      return this._store.getRawIndex(e);
    }, r.prototype.indexOfRawIndex = function(e) {
      return this._store.indexOfRawIndex(e);
    }, r.prototype.rawIndexOf = function(e, t) {
      var n = e && this._invertedIndicesMap[e], i = n && n[t];
      return i == null || isNaN(i) ? CT : i;
    }, r.prototype.indicesOfNearest = function(e, t, n) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(e), t, n);
    }, r.prototype.each = function(e, t, n) {
      ge(e) && (n = t, t = e, e = []);
      var i = n || this, a = Ra(cc(e), this._getStoreDimIndex, this);
      this._store.each(a, i ? ne(t, i) : t);
    }, r.prototype.filterSelf = function(e, t, n) {
      ge(e) && (n = t, t = e, e = []);
      var i = n || this, a = Ra(cc(e), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, i ? ne(t, i) : t), this;
    }, r.prototype.selectRange = function(e) {
      var t = this, n = {}, i = je(e);
      return D(i, function(a) {
        var o = t._getStoreDimIndex(a);
        n[o] = e[a];
      }), this._store = this._store.selectRange(n), this;
    }, r.prototype.mapArray = function(e, t, n) {
      ge(e) && (n = t, t = e, e = []), n = n || this;
      var i = [];
      return this.each(e, function() {
        i.push(t && t.apply(this, arguments));
      }, n), i;
    }, r.prototype.map = function(e, t, n, i) {
      var a = n || i || this, o = Ra(cc(e), this._getStoreDimIndex, this), s = hc(this);
      return s._store = this._store.map(o, a ? ne(t, a) : t), s;
    }, r.prototype.modify = function(e, t, n, i) {
      var a = n || i || this, o = Ra(cc(e), this._getStoreDimIndex, this);
      this._store.modify(o, a ? ne(t, a) : t);
    }, r.prototype.downSample = function(e, t, n, i) {
      var a = hc(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(e), t, n, i), a;
    }, r.prototype.minmaxDownSample = function(e, t) {
      var n = hc(this);
      return n._store = this._store.minmaxDownSample(this._getStoreDimIndex(e), t), n;
    }, r.prototype.lttbDownSample = function(e, t) {
      var n = hc(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(e), t), n;
    }, r.prototype.getRawDataItem = function(e) {
      return this._store.getRawDataItem(e);
    }, r.prototype.getItemModel = function(e) {
      var t = this.hostModel, n = this.getRawDataItem(e);
      return new ft(n, t, t && t.ecModel);
    }, r.prototype.diff = function(e) {
      var t = this;
      return new ya(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return fd(e, n);
      }, function(n) {
        return fd(t, n);
      });
    }, r.prototype.getVisual = function(e) {
      var t = this._visual;
      return t && t[e];
    }, r.prototype.setVisual = function(e, t) {
      this._visual = this._visual || {}, lc(e) ? H(this._visual, e) : this._visual[e] = t;
    }, r.prototype.getItemVisual = function(e, t) {
      var n = this._itemVisuals[e], i = n && n[t];
      return i ?? this.getVisual(t);
    }, r.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, r.prototype.ensureUniqueItemVisual = function(e, t) {
      var n = this._itemVisuals, i = n[e];
      i || (i = n[e] = {});
      var a = i[t];
      return a == null && (a = this.getVisual(t), X(a) ? a = a.slice() : lc(a) && (a = H({}, a)), i[t] = a), a;
    }, r.prototype.setItemVisual = function(e, t, n) {
      var i = this._itemVisuals[e] || {};
      this._itemVisuals[e] = i, lc(t) ? H(i, t) : i[t] = n;
    }, r.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, r.prototype.setLayout = function(e, t) {
      lc(e) ? H(this._layout, e) : this._layout[e] = t;
    }, r.prototype.getLayout = function(e) {
      return this._layout[e];
    }, r.prototype.getItemLayout = function(e) {
      return this._itemLayouts[e];
    }, r.prototype.setItemLayout = function(e, t, n) {
      this._itemLayouts[e] = n ? H(this._itemLayouts[e] || {}, t) : t;
    }, r.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, r.prototype.setItemGraphicEl = function(e, t) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      Rx(n, this.dataType, e, t), this._graphicEls[e] = t;
    }, r.prototype.getItemGraphicEl = function(e) {
      return this._graphicEls[e];
    }, r.prototype.eachItemGraphicEl = function(e, t) {
      D(this._graphicEls, function(n, i) {
        n && e && e.call(t, n, i);
      });
    }, r.prototype.cloneShallow = function(e) {
      return e || (e = new r(this._schema ? this._schema : Ra(this.dimensions, this._getDimInfo, this), this.hostModel)), Km(e, this), e._store = this._store, e;
    }, r.prototype.wrapMethod = function(e, t) {
      var n = this[e];
      ge(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function() {
        var i = n.apply(this, arguments);
        return t.apply(this, [
          i
        ].concat(qb(arguments)));
      });
    }, r.internalField = function() {
      TT = function(e) {
        var t = e._invertedIndicesMap;
        D(t, function(n, i) {
          var a = e._dimInfos[i], o = a.ordinalMeta, s = e._store;
          if (o) {
            n = t[i] = new Z9(o.categories.length);
            for (var l = 0; l < n.length; l++) n[l] = CT;
            for (var l = 0; l < s.count(); l++) n[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, uc = function(e, t, n) {
        return jt(e._getCategory(t, n), null);
      }, fd = function(e, t) {
        var n = e._idList[t];
        return n == null && e._idDimIdx != null && (n = uc(e, e._idDimIdx, t)), n == null && (n = j9 + t), n;
      }, cc = function(e) {
        return X(e) || (e = e != null ? [
          e
        ] : []), e;
      }, hc = function(e) {
        var t = new r(e._schema ? e._schema : Ra(e.dimensions, e._getDimInfo, e), e.hostModel);
        return Km(t, e), t;
      }, Km = function(e, t) {
        D(Q9.concat(t.__wrappedMethods || []), function(n) {
          t.hasOwnProperty(n) && (e[n] = t[n]);
        }), e.__wrappedMethods = t.__wrappedMethods, D(J9, function(n) {
          e[n] = be(t[n]);
        }), e._calculationInfo = H({}, t._calculationInfo);
      }, Zm = function(e, t) {
        var n = e._nameList, i = e._idList, a = e._nameDimIdx, o = e._idDimIdx, s = n[t], l = i[t];
        if (s == null && a != null && (n[t] = s = uc(e, a, t)), l == null && o != null && (i[t] = l = uc(e, o, t)), l == null && s != null) {
          var u = e._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), i[t] = l;
        }
      };
    }(), r;
  }();
  function Cf(r, e) {
    M1(r) || (r = D1(r)), e = e || {};
    var t = e.coordDimensions || [], n = e.dimensionsDefine || r.dimensionsDefine || [], i = ce(), a = [], o = t7(r, t, n, e.dimensionsCount), s = e.canOmitUnusedDimensions && Z3(o), l = n === r.dimensionsDefine, u = l ? K3(r) : q3(n), c = e.encodeDefine;
    !c && e.encodeDefaulter && (c = e.encodeDefaulter(r, o));
    for (var h = ce(c), f = new n3(o), d = 0; d < f.length; d++) f[d] = -1;
    function p(T) {
      var A = f[T];
      if (A < 0) {
        var M = n[T], E = _e(M) ? M : {
          name: M
        }, k = new wp(), R = E.name;
        R != null && u.get(R) != null && (k.name = k.displayName = R), E.type != null && (k.type = E.type), E.displayName != null && (k.displayName = E.displayName);
        var N = a.length;
        return f[T] = N, k.storeDimIndex = T, a.push(k), k;
      }
      return a[A];
    }
    if (!s) for (var d = 0; d < o; d++) p(d);
    h.each(function(T, A) {
      var M = gt(T).slice();
      if (M.length === 1 && !ee(M[0]) && M[0] < 0) {
        h.set(A, false);
        return;
      }
      var E = h.set(A, []);
      D(M, function(k, R) {
        var N = ee(k) ? u.get(k) : k;
        N != null && N < o && (E[R] = N, g(p(N), A, R));
      });
    });
    var v = 0;
    D(t, function(T) {
      var A, M, E, k;
      if (ee(T)) A = T, k = {};
      else {
        k = T, A = k.name;
        var R = k.ordinalMeta;
        k.ordinalMeta = null, k = H({}, k), k.ordinalMeta = R, M = k.dimsDef, E = k.otherDims, k.name = k.coordDim = k.coordDimIndex = k.dimsDef = k.otherDims = null;
      }
      var N = h.get(A);
      if (N !== false) {
        if (N = gt(N), !N.length) for (var I = 0; I < (M && M.length || 1); I++) {
          for (; v < o && p(v).coordDim != null; ) v++;
          v < o && N.push(v++);
        }
        D(N, function(L, P) {
          var O = p(L);
          if (l && k.type != null && (O.type = k.type), g(ye(O, k), A, P), O.name == null && M) {
            var F = M[P];
            !_e(F) && (F = {
              name: F
            }), O.name = O.displayName = F.name, O.defaultTooltip = F.defaultTooltip;
          }
          E && ye(O.otherDims, E);
        });
      }
    });
    function g(T, A, M) {
      FE.get(A) != null ? T.otherDims[A] = M : (T.coordDim = A, T.coordDimIndex = M, i.set(A, true));
    }
    var m = e.generateCoord, y = e.generateCoordCount, x = y != null;
    y = m ? y || 1 : 0;
    var _ = m || "value";
    function S(T) {
      T.name == null && (T.name = T.coordDim);
    }
    if (s) D(a, function(T) {
      S(T);
    }), a.sort(function(T, A) {
      return T.storeDimIndex - A.storeDimIndex;
    });
    else for (var b = 0; b < o; b++) {
      var w = p(b), C = w.coordDim;
      C == null && (w.coordDim = r7(_, i, x), w.coordDimIndex = 0, (!m || y <= 0) && (w.isExtraCoord = true), y--), S(w), w.type == null && ($E(r, b) === yr.Must || w.isExtraCoord && (w.otherDims.itemName != null || w.otherDims.seriesName != null)) && (w.type = "ordinal");
    }
    return e7(a), new Y3({
      source: r,
      dimensions: a,
      fullDimensionCount: o,
      dimensionOmitted: s
    });
  }
  function e7(r) {
    for (var e = ce(), t = 0; t < r.length; t++) {
      var n = r[t], i = n.name, a = e.get(i) || 0;
      a > 0 && (n.name = i + (a - 1)), a++, e.set(i, a);
    }
  }
  function t7(r, e, t, n) {
    var i = Math.max(r.dimensionsDetectedCount || 1, e.length, t.length, n || 0);
    return D(e, function(a) {
      var o;
      _e(a) && (o = a.dimsDef) && (i = Math.max(i, o.length));
    }), i;
  }
  function r7(r, e, t) {
    if (t || e.hasKey(r)) {
      for (var n = 0; e.hasKey(r + n); ) n++;
      r += n;
    }
    return e.set(r, true), r;
  }
  var n7 = /* @__PURE__ */ function() {
    function r(e) {
      this.coordSysDims = [], this.axisMap = ce(), this.categoryAxisMap = ce(), this.coordSysName = e;
    }
    return r;
  }();
  function i7(r) {
    var e = r.get("coordinateSystem"), t = new n7(e), n = a7[e];
    if (n) return n(r, t, t.axisMap, t.categoryAxisMap), t;
  }
  var a7 = {
    cartesian2d: function(r, e, t, n) {
      var i = r.getReferringComponents("xAxis", Yt).models[0], a = r.getReferringComponents("yAxis", Yt).models[0];
      e.coordSysDims = [
        "x",
        "y"
      ], t.set("x", i), t.set("y", a), _l(i) && (n.set("x", i), e.firstCategoryDimIndex = 0), _l(a) && (n.set("y", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
    },
    singleAxis: function(r, e, t, n) {
      var i = r.getReferringComponents("singleAxis", Yt).models[0];
      e.coordSysDims = [
        "single"
      ], t.set("single", i), _l(i) && (n.set("single", i), e.firstCategoryDimIndex = 0);
    },
    polar: function(r, e, t, n) {
      var i = r.getReferringComponents("polar", Yt).models[0], a = i.findAxisModel("radiusAxis"), o = i.findAxisModel("angleAxis");
      e.coordSysDims = [
        "radius",
        "angle"
      ], t.set("radius", a), t.set("angle", o), _l(a) && (n.set("radius", a), e.firstCategoryDimIndex = 0), _l(o) && (n.set("angle", o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
    },
    geo: function(r, e, t, n) {
      e.coordSysDims = [
        "lng",
        "lat"
      ];
    },
    parallel: function(r, e, t, n) {
      var i = r.ecModel, a = i.getComponent("parallel", r.get("parallelIndex")), o = e.coordSysDims = a.dimensions.slice();
      D(a.parallelAxisIndex, function(s, l) {
        var u = i.getComponent("parallelAxis", s), c = o[l];
        t.set(c, u), _l(u) && (n.set(c, u), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l));
      });
    }
  };
  function _l(r) {
    return r.get("type") === "category";
  }
  function o7(r, e, t) {
    t = t || {};
    var n = t.byIndex, i = t.stackedCoordDimension, a, o, s;
    s7(e) ? a = e : (o = e.schema, a = o.dimensions, s = e.store);
    var l = !!(r && r.get("stack")), u, c, h, f;
    if (D(a, function(y, x) {
      ee(y) && (a[x] = y = {
        name: y
      }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
    }), c && !n && !u && (n = true), c) {
      h = "__\0ecstackresult_" + r.id, f = "__\0ecstackedover_" + r.id, u && (u.createInvertedIndices = true);
      var d = c.coordDim, p = c.type, v = 0;
      D(a, function(y) {
        y.coordDim === d && v++;
      });
      var g = {
        name: h,
        coordDim: d,
        coordDimIndex: v,
        type: p,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: a.length
      }, m = {
        name: f,
        coordDim: f,
        coordDimIndex: v + 1,
        type: p,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: a.length + 1
      };
      o ? (s && (g.storeDimIndex = s.ensureCalculationDimension(f, p), m.storeDimIndex = s.ensureCalculationDimension(h, p)), o.appendCalculationDimension(g), o.appendCalculationDimension(m)) : (a.push(g), a.push(m));
    }
    return {
      stackedDimension: c && c.name,
      stackedByDimension: u && u.name,
      isStackedByIndex: n,
      stackedOverDimension: f,
      stackResultDimension: h
    };
  }
  function s7(r) {
    return !X3(r.schema);
  }
  function ho(r, e) {
    return !!e && e === r.getCalculationInfo("stackedDimension");
  }
  function j3(r, e) {
    return ho(r, e) ? r.getCalculationInfo("stackResultDimension") : e;
  }
  function l7(r, e) {
    var t = r.get("coordinateSystem"), n = Sf.get(t), i;
    return e && e.coordSysDims && (i = K(e.coordSysDims, function(a) {
      var o = {
        name: a
      }, s = e.axisMap.get(a);
      if (s) {
        var l = s.get("type");
        o.type = iv(l);
      }
      return o;
    })), i || (i = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || [
      "x",
      "y"
    ]), i;
  }
  function u7(r, e, t) {
    var n, i;
    return t && D(r, function(a, o) {
      var s = a.coordDim, l = t.categoryAxisMap.get(s);
      l && (n == null && (n = o), a.ordinalMeta = l.getOrdinalMeta(), e && (a.createInvertedIndices = true)), a.otherDims.itemName != null && (i = true);
    }), !i && n != null && (r[n].otherDims.itemName = 0), n;
  }
  function Aa(r, e, t) {
    t = t || {};
    var n = e.getSourceManager(), i, a = false;
    r ? (a = true, i = D1(r)) : (i = n.getSource(), a = i.sourceFormat === $n);
    var o = i7(e), s = l7(e, o), l = t.useEncodeDefaulter, u = ge(l) ? l : l ? Le(VE, s, e) : null, c = {
      coordDimensions: s,
      generateCoord: t.generateCoord,
      encodeDefine: e.getEncode(),
      encodeDefaulter: u,
      canOmitUnusedDimensions: !a
    }, h = Cf(i, c), f = u7(h.dimensions, t.createInvertedIndices, o), d = a ? null : n.getSharedDataStore(h), p = o7(e, {
      schema: h,
      store: d
    }), v = new Wr(h, e);
    v.setCalculationInfo(p);
    var g = f != null && c7(i) ? function(m, y, x, _) {
      return _ === f ? x : this.defaultDimValueGetter(m, y, x, _);
    } : null;
    return v.hasItemOption = false, v.initData(a ? i : d, null, g), v;
  }
  function c7(r) {
    if (r.sourceFormat === $n) {
      var e = h7(r.data || []);
      return !X(ku(e));
    }
  }
  function h7(r) {
    for (var e = 0; e < r.length && r[e] == null; ) e++;
    return r[e];
  }
  var Hi = function() {
    function r(e) {
      this._setting = e || {}, this._extent = [
        1 / 0,
        -1 / 0
      ];
    }
    return r.prototype.getSetting = function(e) {
      return this._setting[e];
    }, r.prototype.unionExtent = function(e) {
      var t = this._extent;
      e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]);
    }, r.prototype.unionExtentFromData = function(e, t) {
      this.unionExtent(e.getApproximateExtent(t));
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.setExtent = function(e, t) {
      var n = this._extent;
      isNaN(e) || (n[0] = e), isNaN(t) || (n[1] = t);
    }, r.prototype.isInExtentRange = function(e) {
      return this._extent[0] <= e && this._extent[1] >= e;
    }, r.prototype.isBlank = function() {
      return this._isBlank;
    }, r.prototype.setBlank = function(e) {
      this._isBlank = e;
    }, r;
  }();
  Zv(Hi);
  var f7 = 0, r_ = function() {
    function r(e) {
      this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++f7;
    }
    return r.createByAxisModel = function(e) {
      var t = e.option, n = t.data, i = n && K(n, d7);
      return new r({
        categories: i,
        needCollect: !i,
        deduplication: t.dedplication !== false
      });
    }, r.prototype.getOrdinal = function(e) {
      return this._getOrCreateMap().get(e);
    }, r.prototype.parseAndCollect = function(e) {
      var t, n = this._needCollect;
      if (!ee(e) && !n) return e;
      if (n && !this._deduplication) return t = this.categories.length, this.categories[t] = e, t;
      var i = this._getOrCreateMap();
      return t = i.get(e), t == null && (n ? (t = this.categories.length, this.categories[t] = e, i.set(e, t)) : t = NaN), t;
    }, r.prototype._getOrCreateMap = function() {
      return this._map || (this._map = ce(this.categories));
    }, r;
  }();
  function d7(r) {
    return _e(r) && r.value != null ? r.value : r + "";
  }
  function n_(r) {
    return r.type === "interval" || r.type === "log";
  }
  function p7(r, e, t, n) {
    var i = {}, a = r[1] - r[0], o = i.interval = TR(a / e);
    t != null && o < t && (o = i.interval = t), n != null && o > n && (o = i.interval = n);
    var s = i.intervalPrecision = Q3(o), l = i.niceTickExtent = [
      Bt(Math.ceil(r[0] / o) * o, s),
      Bt(Math.floor(r[1] / o) * o, s)
    ];
    return v7(l, r), i;
  }
  function jm(r) {
    var e = Math.pow(10, r1(r)), t = r / e;
    return t ? t === 2 ? t = 3 : t === 3 ? t = 5 : t *= 2 : t = 1, Bt(t * e);
  }
  function Q3(r) {
    return Mi(r) + 2;
  }
  function AT(r, e, t) {
    r[e] = Math.max(Math.min(r[e], t[1]), t[0]);
  }
  function v7(r, e) {
    !isFinite(r[0]) && (r[0] = e[0]), !isFinite(r[1]) && (r[1] = e[1]), AT(r, 0, e), AT(r, 1, e), r[0] > r[1] && (r[0] = r[1]);
  }
  function mg(r, e) {
    return r >= e[0] && r <= e[1];
  }
  function yg(r, e) {
    return e[1] === e[0] ? 0.5 : (r - e[0]) / (e[1] - e[0]);
  }
  function xg(r, e) {
    return r * (e[1] - e[0]) + e[0];
  }
  var _g = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      n.type = "ordinal";
      var i = n.getSetting("ordinalMeta");
      return i || (i = new r_({})), X(i) && (i = new r_({
        categories: K(i, function(a) {
          return _e(a) ? a.value : a;
        })
      })), n._ordinalMeta = i, n._extent = n.getSetting("extent") || [
        0,
        i.categories.length - 1
      ], n;
    }
    return e.prototype.parse = function(t) {
      return t == null ? NaN : ee(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
    }, e.prototype.contain = function(t) {
      return t = this.parse(t), mg(t, this._extent) && this._ordinalMeta.categories[t] != null;
    }, e.prototype.normalize = function(t) {
      return t = this._getTickNumber(this.parse(t)), yg(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = Math.round(xg(t, this._extent)), this.getRawOrdinalNumber(t);
    }, e.prototype.getTicks = function() {
      for (var t = [], n = this._extent, i = n[0]; i <= n[1]; ) t.push({
        value: i
      }), i++;
      return t;
    }, e.prototype.getMinorTicks = function(t) {
    }, e.prototype.setSortInfo = function(t) {
      if (t == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var n = t.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, n.length); o < l; ++o) {
        var u = n[o];
        i[o] = u, a[u] = o;
      }
      for (var c = 0; o < s; ++o) {
        for (; a[c] != null; ) c++;
        i.push(c), a[c] = o;
      }
    }, e.prototype._getTickNumber = function(t) {
      var n = this._ticksByOrdinalNumber;
      return n && t >= 0 && t < n.length ? n[t] : t;
    }, e.prototype.getRawOrdinalNumber = function(t) {
      var n = this._ordinalNumbersByTick;
      return n && t >= 0 && t < n.length ? n[t] : t;
    }, e.prototype.getLabel = function(t) {
      if (!this.isBlank()) {
        var n = this.getRawOrdinalNumber(t.value), i = this._ordinalMeta.categories[n];
        return i == null ? "" : i + "";
      }
    }, e.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, e.prototype.unionExtentFromData = function(t, n) {
      this.unionExtent(t.getApproximateExtent(n));
    }, e.prototype.isInExtentRange = function(t) {
      return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, e.prototype.calcNiceTicks = function() {
    }, e.prototype.calcNiceExtent = function() {
    }, e.type = "ordinal", e;
  }(Hi);
  Hi.registerClass(_g);
  var Uo = Bt, xa = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t;
    }
    return e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return mg(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return yg(t, this._extent);
    }, e.prototype.scale = function(t) {
      return xg(t, this._extent);
    }, e.prototype.setExtent = function(t, n) {
      var i = this._extent;
      isNaN(t) || (i[0] = parseFloat(t)), isNaN(n) || (i[1] = parseFloat(n));
    }, e.prototype.unionExtent = function(t) {
      var n = this._extent;
      t[0] < n[0] && (n[0] = t[0]), t[1] > n[1] && (n[1] = t[1]), this.setExtent(n[0], n[1]);
    }, e.prototype.getInterval = function() {
      return this._interval;
    }, e.prototype.setInterval = function(t) {
      this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = Q3(t);
    }, e.prototype.getTicks = function(t) {
      var n = this._interval, i = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
      if (!n) return s;
      var l = 1e4;
      i[0] < a[0] && (t ? s.push({
        value: Uo(a[0] - n, o)
      }) : s.push({
        value: i[0]
      }));
      for (var u = a[0]; u <= a[1] && (s.push({
        value: u
      }), u = Uo(u + n, o), u !== s[s.length - 1].value); ) if (s.length > l) return [];
      var c = s.length ? s[s.length - 1].value : a[1];
      return i[1] > c && (t ? s.push({
        value: Uo(c + n, o)
      }) : s.push({
        value: i[1]
      })), s;
    }, e.prototype.getMinorTicks = function(t) {
      for (var n = this.getTicks(true), i = [], a = this.getExtent(), o = 1; o < n.length; o++) {
        for (var s = n[o], l = n[o - 1], u = 0, c = [], h = s.value - l.value, f = h / t; u < t - 1; ) {
          var d = Uo(l.value + (u + 1) * f);
          d > a[0] && d < a[1] && c.push(d), u++;
        }
        i.push(c);
      }
      return i;
    }, e.prototype.getLabel = function(t, n) {
      if (t == null) return "";
      var i = n && n.precision;
      i == null ? i = Mi(t.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var a = Uo(t.value, i, true);
      return kE(a);
    }, e.prototype.calcNiceTicks = function(t, n, i) {
      t = t || 5;
      var a = this._extent, o = a[1] - a[0];
      if (isFinite(o)) {
        o < 0 && (o = -o, a.reverse());
        var s = p7(a, t, n, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      var n = this._extent;
      if (n[0] === n[1]) if (n[0] !== 0) {
        var i = Math.abs(n[0]);
        t.fixMax || (n[1] += i / 2), n[0] -= i / 2;
      } else n[1] = 1;
      var a = n[1] - n[0];
      isFinite(a) || (n[0] = 0, n[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
      var o = this._interval;
      t.fixMin || (n[0] = Uo(Math.floor(n[0] / o) * o)), t.fixMax || (n[1] = Uo(Math.ceil(n[1] / o) * o));
    }, e.prototype.setNiceExtent = function(t, n) {
      this._niceExtent = [
        t,
        n
      ];
    }, e.type = "interval", e;
  }(Hi);
  Hi.registerClass(xa);
  var J3 = typeof Float32Array < "u", g7 = J3 ? Float32Array : Array;
  function Pi(r) {
    return X(r) ? J3 ? new Float32Array(r) : r : new g7(r);
  }
  var i_ = "__ec_stack_";
  function eN(r) {
    return r.get("stack") || i_ + r.seriesIndex;
  }
  function V1(r) {
    return r.dim + r.index;
  }
  function m7(r) {
    var e = [], t = r.axis, n = "axis0";
    if (t.type === "category") {
      for (var i = t.getBandWidth(), a = 0; a < r.count; a++) e.push(ye({
        bandWidth: i,
        axisKey: n,
        stackId: i_ + a
      }, r));
      for (var o = nN(e), s = [], a = 0; a < r.count; a++) {
        var l = o[n][i_ + a];
        l.offsetCenter = l.offset + l.width / 2, s.push(l);
      }
      return s;
    }
  }
  function tN(r, e) {
    var t = [];
    return e.eachSeriesByType(r, function(n) {
      oN(n) && t.push(n);
    }), t;
  }
  function y7(r) {
    var e = {};
    D(r, function(l) {
      var u = l.coordinateSystem, c = u.getBaseAxis();
      if (!(c.type !== "time" && c.type !== "value")) for (var h = l.getData(), f = c.dim + "_" + c.index, d = h.getDimensionIndex(h.mapDimension(c.dim)), p = h.getStore(), v = 0, g = p.count(); v < g; ++v) {
        var m = p.get(d, v);
        e[f] ? e[f].push(m) : e[f] = [
          m
        ];
      }
    });
    var t = {};
    for (var n in e) if (e.hasOwnProperty(n)) {
      var i = e[n];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, o = 1; o < i.length; ++o) {
          var s = i[o] - i[o - 1];
          s > 0 && (a = a === null ? s : Math.min(a, s));
        }
        t[n] = a;
      }
    }
    return t;
  }
  function rN(r) {
    var e = y7(r), t = [];
    return D(r, function(n) {
      var i = n.coordinateSystem, a = i.getBaseAxis(), o = a.getExtent(), s;
      if (a.type === "category") s = a.getBandWidth();
      else if (a.type === "value" || a.type === "time") {
        var l = a.dim + "_" + a.index, u = e[l], c = Math.abs(o[1] - o[0]), h = a.scale.getExtent(), f = Math.abs(h[1] - h[0]);
        s = u ? c / f * u : c;
      } else {
        var d = n.getData();
        s = Math.abs(o[1] - o[0]) / d.count();
      }
      var p = Q(n.get("barWidth"), s), v = Q(n.get("barMaxWidth"), s), g = Q(n.get("barMinWidth") || (sN(n) ? 0.5 : 1), s), m = n.get("barGap"), y = n.get("barCategoryGap");
      t.push({
        bandWidth: s,
        barWidth: p,
        barMaxWidth: v,
        barMinWidth: g,
        barGap: m,
        barCategoryGap: y,
        axisKey: V1(a),
        stackId: eN(n)
      });
    }), nN(t);
  }
  function nN(r) {
    var e = {};
    D(r, function(n, i) {
      var a = n.axisKey, o = n.bandWidth, s = e[a] || {
        bandWidth: o,
        remainedWidth: o,
        autoWidthCount: 0,
        categoryGap: null,
        gap: "20%",
        stacks: {}
      }, l = s.stacks;
      e[a] = s;
      var u = n.stackId;
      l[u] || s.autoWidthCount++, l[u] = l[u] || {
        width: 0,
        maxWidth: 0
      };
      var c = n.barWidth;
      c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
      var h = n.barMaxWidth;
      h && (l[u].maxWidth = h);
      var f = n.barMinWidth;
      f && (l[u].minWidth = f);
      var d = n.barGap;
      d != null && (s.gap = d);
      var p = n.barCategoryGap;
      p != null && (s.categoryGap = p);
    });
    var t = {};
    return D(e, function(n, i) {
      t[i] = {};
      var a = n.stacks, o = n.bandWidth, s = n.categoryGap;
      if (s == null) {
        var l = je(a).length;
        s = Math.max(35 - l * 4, 15) + "%";
      }
      var u = Q(s, o), c = Q(n.gap, 1), h = n.remainedWidth, f = n.autoWidthCount, d = (h - u) / (f + (f - 1) * c);
      d = Math.max(d, 0), D(a, function(m) {
        var y = m.maxWidth, x = m.minWidth;
        if (m.width) {
          var _ = m.width;
          y && (_ = Math.min(_, y)), x && (_ = Math.max(_, x)), m.width = _, h -= _ + c * _, f--;
        } else {
          var _ = d;
          y && y < _ && (_ = Math.min(y, h)), x && x > _ && (_ = x), _ !== d && (m.width = _, h -= _ + c * _, f--);
        }
      }), d = (h - u) / (f + (f - 1) * c), d = Math.max(d, 0);
      var p = 0, v;
      D(a, function(m, y) {
        m.width || (m.width = d), v = m, p += m.width * (1 + c);
      }), v && (p -= v.width * c);
      var g = -p / 2;
      D(a, function(m, y) {
        t[i][y] = t[i][y] || {
          bandWidth: o,
          offset: g,
          width: m.width
        }, g += m.width * (1 + c);
      });
    }), t;
  }
  function x7(r, e, t) {
    if (r && e) {
      var n = r[V1(e)];
      return n;
    }
  }
  function iN(r, e) {
    var t = tN(r, e), n = rN(t);
    D(t, function(i) {
      var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = eN(i), u = n[V1(s)][l], c = u.offset, h = u.width;
      a.setLayout({
        bandWidth: u.bandWidth,
        offset: c,
        size: h
      });
    });
  }
  function aN(r) {
    return {
      seriesType: r,
      plan: zu(),
      reset: function(e) {
        if (oN(e)) {
          var t = e.getData(), n = e.coordinateSystem, i = n.getBaseAxis(), a = n.getOtherAxis(i), o = t.getDimensionIndex(t.mapDimension(a.dim)), s = t.getDimensionIndex(t.mapDimension(i.dim)), l = e.get("showBackground", true), u = t.mapDimension(a.dim), c = t.getCalculationInfo("stackResultDimension"), h = ho(t, u) && !!t.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), d = _7(i, a), p = sN(e), v = e.get("barMinHeight") || 0, g = c && t.getDimensionIndex(c), m = t.getLayout("size"), y = t.getLayout("offset");
          return {
            progress: function(x, _) {
              for (var S = x.count, b = p && Pi(S * 3), w = p && l && Pi(S * 3), C = p && Pi(S), T = n.master.getRect(), A = f ? T.width : T.height, M, E = _.getStore(), k = 0; (M = x.next()) != null; ) {
                var R = E.get(h ? g : o, M), N = E.get(s, M), I = d, L = void 0;
                h && (L = +R - E.get(o, M));
                var P = void 0, O = void 0, F = void 0, B = void 0;
                if (f) {
                  var V = n.dataToPoint([
                    R,
                    N
                  ]);
                  if (h) {
                    var U = n.dataToPoint([
                      L,
                      N
                    ]);
                    I = U[0];
                  }
                  P = I, O = V[1] + y, F = V[0] - I, B = m, Math.abs(F) < v && (F = (F < 0 ? -1 : 1) * v);
                } else {
                  var V = n.dataToPoint([
                    N,
                    R
                  ]);
                  if (h) {
                    var U = n.dataToPoint([
                      N,
                      L
                    ]);
                    I = U[1];
                  }
                  P = V[0] + y, O = I, F = m, B = V[1] - I, Math.abs(B) < v && (B = (B <= 0 ? -1 : 1) * v);
                }
                p ? (b[k] = P, b[k + 1] = O, b[k + 2] = f ? F : B, w && (w[k] = f ? T.x : P, w[k + 1] = f ? O : T.y, w[k + 2] = A), C[M] = M) : _.setItemLayout(M, {
                  x: P,
                  y: O,
                  width: F,
                  height: B
                }), k += 3;
              }
              p && _.setLayout({
                largePoints: b,
                largeDataIndices: C,
                largeBackgroundPoints: w,
                valueAxisHorizontal: f
              });
            }
          };
        }
      }
    };
  }
  function oN(r) {
    return r.coordinateSystem && r.coordinateSystem.type === "cartesian2d";
  }
  function sN(r) {
    return r.pipelineContext && r.pipelineContext.large;
  }
  function _7(r, e) {
    var t = e.model.get("startValue");
    return t || (t = 0), e.toGlobalCoord(e.dataToCoord(e.type === "log" ? t > 0 ? t : 1 : t));
  }
  var b7 = function(r, e, t, n) {
    for (; t < n; ) {
      var i = t + n >>> 1;
      r[i][1] < e ? t = i + 1 : n = i;
    }
    return t;
  }, $1 = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "time", n;
    }
    return e.prototype.getLabel = function(t) {
      var n = this.getSetting("useUTC");
      return sg(t.value, g2[tY(ru(this._minLevelUnit))] || g2.second, n, this.getSetting("locale"));
    }, e.prototype.getFormattedLabel = function(t, n, i) {
      var a = this.getSetting("useUTC"), o = this.getSetting("locale");
      return rY(t, n, i, o, a);
    }, e.prototype.getTicks = function() {
      var t = this._interval, n = this._extent, i = [];
      if (!t) return i;
      i.push({
        value: n[0],
        level: 0
      });
      var a = this.getSetting("useUTC"), o = M7(this._minLevelUnit, this._approxInterval, a, n);
      return i = i.concat(o), i.push({
        value: n[1],
        level: 0
      }), i;
    }, e.prototype.calcNiceExtent = function(t) {
      var n = this._extent;
      if (n[0] === n[1] && (n[0] -= Nn, n[1] += Nn), n[1] === -1 / 0 && n[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        n[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), n[0] = n[1] - Nn;
      }
      this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
    }, e.prototype.calcNiceTicks = function(t, n, i) {
      t = t || 10;
      var a = this._extent, o = a[1] - a[0];
      this._approxInterval = o / t, n != null && this._approxInterval < n && (this._approxInterval = n), i != null && this._approxInterval > i && (this._approxInterval = i);
      var s = dd.length, l = Math.min(b7(dd, this._approxInterval, 0, s), s - 1);
      this._interval = dd[l][1], this._minLevelUnit = dd[Math.max(l - 1, 0)][0];
    }, e.prototype.parse = function(t) {
      return nt(t) ? t : +Vi(t);
    }, e.prototype.contain = function(t) {
      return mg(this.parse(t), this._extent);
    }, e.prototype.normalize = function(t) {
      return yg(this.parse(t), this._extent);
    }, e.prototype.scale = function(t) {
      return xg(t, this._extent);
    }, e.type = "time", e;
  }(xa), dd = [
    [
      "second",
      _1
    ],
    [
      "minute",
      b1
    ],
    [
      "hour",
      rh
    ],
    [
      "quarter-day",
      rh * 6
    ],
    [
      "half-day",
      rh * 12
    ],
    [
      "day",
      Nn * 1.2
    ],
    [
      "half-week",
      Nn * 3.5
    ],
    [
      "week",
      Nn * 7
    ],
    [
      "month",
      Nn * 31
    ],
    [
      "quarter",
      Nn * 95
    ],
    [
      "half-year",
      v2 / 2
    ],
    [
      "year",
      v2
    ]
  ];
  function S7(r, e, t, n) {
    var i = Vi(e), a = Vi(t), o = function(p) {
      return m2(i, p, n) === m2(a, p, n);
    }, s = function() {
      return o("year");
    }, l = function() {
      return s() && o("month");
    }, u = function() {
      return l() && o("day");
    }, c = function() {
      return u() && o("hour");
    }, h = function() {
      return c() && o("minute");
    }, f = function() {
      return h() && o("second");
    }, d = function() {
      return f() && o("millisecond");
    };
    switch (r) {
      case "year":
        return s();
      case "month":
        return l();
      case "day":
        return u();
      case "hour":
        return c();
      case "minute":
        return h();
      case "second":
        return f();
      case "millisecond":
        return d();
    }
  }
  function w7(r, e) {
    return r /= Nn, r > 16 ? 16 : r > 7.5 ? 7 : r > 3.5 ? 4 : r > 1.5 ? 2 : 1;
  }
  function C7(r) {
    var e = 30 * Nn;
    return r /= e, r > 6 ? 6 : r > 3 ? 3 : r > 2 ? 2 : 1;
  }
  function T7(r) {
    return r /= rh, r > 12 ? 12 : r > 6 ? 6 : r > 3.5 ? 4 : r > 2 ? 2 : 1;
  }
  function IT(r, e) {
    return r /= e ? b1 : _1, r > 30 ? 30 : r > 20 ? 20 : r > 15 ? 15 : r > 10 ? 10 : r > 5 ? 5 : r > 2 ? 2 : 1;
  }
  function A7(r) {
    return TR(r);
  }
  function I7(r, e, t) {
    var n = new Date(r);
    switch (ru(e)) {
      case "year":
      case "month":
        n[TE(t)](0);
      case "day":
        n[AE(t)](1);
      case "hour":
        n[IE(t)](0);
      case "minute":
        n[ME(t)](0);
      case "second":
        n[DE(t)](0), n[PE(t)](0);
    }
    return n.getTime();
  }
  function M7(r, e, t, n) {
    var i = 1e4, a = wE, o = 0;
    function s(A, M, E, k, R, N, I) {
      for (var L = new Date(M), P = M, O = L[k](); P < E && P <= n[1]; ) I.push({
        value: P
      }), O += A, L[R](O), P = L.getTime();
      I.push({
        value: P,
        notAdd: true
      });
    }
    function l(A, M, E) {
      var k = [], R = !M.length;
      if (!S7(ru(A), n[0], n[1], t)) {
        R && (M = [
          {
            value: I7(new Date(n[0]), A, t)
          },
          {
            value: n[1]
          }
        ]);
        for (var N = 0; N < M.length - 1; N++) {
          var I = M[N].value, L = M[N + 1].value;
          if (I !== L) {
            var P = void 0, O = void 0, F = void 0, B = false;
            switch (A) {
              case "year":
                P = Math.max(1, Math.round(e / Nn / 365)), O = S1(t), F = nY(t);
                break;
              case "half-year":
              case "quarter":
              case "month":
                P = C7(e), O = nu(t), F = TE(t);
                break;
              case "week":
              case "half-week":
              case "day":
                P = w7(e), O = lg(t), F = AE(t), B = true;
                break;
              case "half-day":
              case "quarter-day":
              case "hour":
                P = T7(e), O = Dh(t), F = IE(t);
                break;
              case "minute":
                P = IT(e, true), O = ug(t), F = ME(t);
                break;
              case "second":
                P = IT(e, false), O = cg(t), F = DE(t);
                break;
              case "millisecond":
                P = A7(e), O = hg(t), F = PE(t);
                break;
            }
            s(P, I, L, O, F, B, k), A === "year" && E.length > 1 && N === 0 && E.unshift({
              value: E[0].value - P
            });
          }
        }
        for (var N = 0; N < k.length; N++) E.push(k[N]);
        return k;
      }
    }
    for (var u = [], c = [], h = 0, f = 0, d = 0; d < a.length && o++ < i; ++d) {
      var p = ru(a[d]);
      if (eY(a[d])) {
        l(a[d], u[u.length - 1] || [], c);
        var v = a[d + 1] ? ru(a[d + 1]) : null;
        if (p !== v) {
          if (c.length) {
            f = h, c.sort(function(A, M) {
              return A.value - M.value;
            });
            for (var g = [], m = 0; m < c.length; ++m) {
              var y = c[m].value;
              (m === 0 || c[m - 1].value !== y) && (g.push(c[m]), y >= n[0] && y <= n[1] && h++);
            }
            var x = (n[1] - n[0]) / e;
            if (h > x * 1.5 && f > x / 1.5 || (u.push(g), h > x || r === a[d])) break;
          }
          c = [];
        }
      }
    }
    for (var _ = ct(K(u, function(A) {
      return ct(A, function(M) {
        return M.value >= n[0] && M.value <= n[1] && !M.notAdd;
      });
    }), function(A) {
      return A.length > 0;
    }), S = [], b = _.length - 1, d = 0; d < _.length; ++d) for (var w = _[d], C = 0; C < w.length; ++C) S.push({
      value: w[C].value,
      level: b - d
    });
    S.sort(function(A, M) {
      return A.value - M.value;
    });
    for (var T = [], d = 0; d < S.length; ++d) (d === 0 || S[d].value !== S[d - 1].value) && T.push(S[d]);
    return T;
  }
  Hi.registerClass($1);
  var MT = Hi.prototype, oh = xa.prototype, D7 = Bt, P7 = Math.floor, k7 = Math.ceil, pd = Math.pow, Yn = Math.log, G1 = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "log", t.base = 10, t._originalScale = new xa(), t._interval = 0, t;
    }
    return e.prototype.getTicks = function(t) {
      var n = this._originalScale, i = this._extent, a = n.getExtent(), o = oh.getTicks.call(this, t);
      return K(o, function(s) {
        var l = s.value, u = Bt(pd(this.base, l));
        return u = l === i[0] && this._fixMin ? vd(u, a[0]) : u, u = l === i[1] && this._fixMax ? vd(u, a[1]) : u, {
          value: u
        };
      }, this);
    }, e.prototype.setExtent = function(t, n) {
      var i = Yn(this.base);
      t = Yn(Math.max(0, t)) / i, n = Yn(Math.max(0, n)) / i, oh.setExtent.call(this, t, n);
    }, e.prototype.getExtent = function() {
      var t = this.base, n = MT.getExtent.call(this);
      n[0] = pd(t, n[0]), n[1] = pd(t, n[1]);
      var i = this._originalScale, a = i.getExtent();
      return this._fixMin && (n[0] = vd(n[0], a[0])), this._fixMax && (n[1] = vd(n[1], a[1])), n;
    }, e.prototype.unionExtent = function(t) {
      this._originalScale.unionExtent(t);
      var n = this.base;
      t[0] = Yn(t[0]) / Yn(n), t[1] = Yn(t[1]) / Yn(n), MT.unionExtent.call(this, t);
    }, e.prototype.unionExtentFromData = function(t, n) {
      this.unionExtent(t.getApproximateExtent(n));
    }, e.prototype.calcNiceTicks = function(t) {
      t = t || 10;
      var n = this._extent, i = n[1] - n[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var a = EH(i), o = t / i * a;
        for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; ) a *= 10;
        var s = [
          Bt(k7(n[0] / a) * a),
          Bt(P7(n[1] / a) * a)
        ];
        this._interval = a, this._niceExtent = s;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      oh.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax;
    }, e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return t = Yn(t) / Yn(this.base), mg(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return t = Yn(t) / Yn(this.base), yg(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = xg(t, this._extent), pd(this.base, t);
    }, e.type = "log", e;
  }(Hi), lN = G1.prototype;
  lN.getMinorTicks = oh.getMinorTicks;
  lN.getLabel = oh.getLabel;
  function vd(r, e) {
    return D7(r, Mi(e));
  }
  Hi.registerClass(G1);
  var L7 = function() {
    function r(e, t, n) {
      this._prepareParams(e, t, n);
    }
    return r.prototype._prepareParams = function(e, t, n) {
      n[1] < n[0] && (n = [
        NaN,
        NaN
      ]), this._dataMin = n[0], this._dataMax = n[1];
      var i = this._isOrdinal = e.type === "ordinal";
      this._needCrossZero = e.type === "interval" && t.getNeedCrossZero && t.getNeedCrossZero();
      var a = t.get("min", true);
      a == null && (a = t.get("startValue", true));
      var o = this._modelMinRaw = a;
      ge(o) ? this._modelMinNum = gd(e, o({
        min: n[0],
        max: n[1]
      })) : o !== "dataMin" && (this._modelMinNum = gd(e, o));
      var s = this._modelMaxRaw = t.get("max", true);
      if (ge(s) ? this._modelMaxNum = gd(e, s({
        min: n[0],
        max: n[1]
      })) : s !== "dataMax" && (this._modelMaxNum = gd(e, s)), i) this._axisDataLen = t.getCategories().length;
      else {
        var l = t.get("boundaryGap"), u = X(l) ? l : [
          l || 0,
          l || 0
        ];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? this._boundaryGapInner = [
          0,
          0
        ] : this._boundaryGapInner = [
          si(u[0], 1),
          si(u[1], 1)
        ];
      }
    }, r.prototype.calculate = function() {
      var e = this._isOrdinal, t = this._dataMin, n = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, o = e ? null : n - t || Math.abs(t), s = this._modelMinRaw === "dataMin" ? t : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? n : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = e ? i ? 0 : NaN : t - a[0] * o), l == null && (l = e ? i ? i - 1 : NaN : n + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var h = xh(s) || xh(l) || e && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var f = this._determinedMin, d = this._determinedMax;
      return f != null && (s = f, u = true), d != null && (l = d, c = true), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: h
      };
    }, r.prototype.modifyDataMinMax = function(e, t) {
      this[E7[e]] = t;
    }, r.prototype.setDeterminedMinMax = function(e, t) {
      var n = R7[e];
      this[n] = t;
    }, r.prototype.freeze = function() {
      this.frozen = true;
    }, r;
  }(), R7 = {
    min: "_determinedMin",
    max: "_determinedMax"
  }, E7 = {
    min: "_dataMin",
    max: "_dataMax"
  };
  function uN(r, e, t) {
    var n = r.rawExtentInfo;
    return n || (n = new L7(r, e, t), r.rawExtentInfo = n, n);
  }
  function gd(r, e) {
    return e == null ? null : xh(e) ? NaN : r.parse(e);
  }
  function cN(r, e) {
    var t = r.type, n = uN(r, e, r.getExtent()).calculate();
    r.setBlank(n.isBlank);
    var i = n.min, a = n.max, o = e.ecModel;
    if (o && t === "time") {
      var s = tN("bar", o), l = false;
      if (D(s, function(h) {
        l = l || h.getBaseAxis() === e.axis;
      }), l) {
        var u = rN(s), c = N7(i, a, e, u);
        i = c.min, a = c.max;
      }
    }
    return {
      extent: [
        i,
        a
      ],
      fixMin: n.minFixed,
      fixMax: n.maxFixed
    };
  }
  function N7(r, e, t, n) {
    var i = t.axis.getExtent(), a = Math.abs(i[1] - i[0]), o = x7(n, t.axis);
    if (o === void 0) return {
      min: r,
      max: e
    };
    var s = 1 / 0;
    D(o, function(d) {
      s = Math.min(d.offset, s);
    });
    var l = -1 / 0;
    D(o, function(d) {
      l = Math.max(d.offset + d.width, l);
    }), s = Math.abs(s), l = Math.abs(l);
    var u = s + l, c = e - r, h = 1 - (s + l) / a, f = c / h - c;
    return e += f * (l / u), r -= f * (s / u), {
      min: r,
      max: e
    };
  }
  function fu(r, e) {
    var t = e, n = cN(r, t), i = n.extent, a = t.get("splitNumber");
    r instanceof G1 && (r.base = t.get("logBase"));
    var o = r.type, s = t.get("interval"), l = o === "interval" || o === "time";
    r.setExtent(i[0], i[1]), r.calcNiceExtent({
      splitNumber: a,
      fixMin: n.fixMin,
      fixMax: n.fixMax,
      minInterval: l ? t.get("minInterval") : null,
      maxInterval: l ? t.get("maxInterval") : null
    }), s != null && r.setInterval && r.setInterval(s);
  }
  function bg(r, e) {
    if (e = e || r.get("type"), e) switch (e) {
      case "category":
        return new _g({
          ordinalMeta: r.getOrdinalMeta ? r.getOrdinalMeta() : r.getCategories(),
          extent: [
            1 / 0,
            -1 / 0
          ]
        });
      case "time":
        return new $1({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new (Hi.getClass(e) || xa)();
    }
  }
  function O7(r) {
    var e = r.scale.getExtent(), t = e[0], n = e[1];
    return !(t > 0 && n > 0 || t < 0 && n < 0);
  }
  function Gu(r) {
    var e = r.getLabelModel().get("formatter"), t = r.type === "category" ? r.scale.getExtent()[0] : null;
    return r.scale.type === "time" ? /* @__PURE__ */ function(n) {
      return function(i, a) {
        return r.scale.getFormattedLabel(i, a, n);
      };
    }(e) : ee(e) ? /* @__PURE__ */ function(n) {
      return function(i) {
        var a = r.scale.getLabel(i), o = n.replace("{value}", a ?? "");
        return o;
      };
    }(e) : ge(e) ? /* @__PURE__ */ function(n) {
      return function(i, a) {
        return t != null && (a = i.value - t), n(W1(r, i), a, i.level != null ? {
          level: i.level
        } : null);
      };
    }(e) : function(n) {
      return r.scale.getLabel(n);
    };
  }
  function W1(r, e) {
    return r.type === "category" ? r.scale.getLabel(e) : e.value;
  }
  function F7(r) {
    var e = r.model, t = r.scale;
    if (!(!e.get([
      "axisLabel",
      "show"
    ]) || t.isBlank())) {
      var n, i, a = t.getExtent();
      t instanceof _g ? i = t.count() : (n = t.getTicks(), i = n.length);
      var o = r.getLabelModel(), s = Gu(r), l, u = 1;
      i > 40 && (u = Math.ceil(i / 40));
      for (var c = 0; c < i; c += u) {
        var h = n ? n[c] : {
          value: a[0] + c
        }, f = s(h, c), d = o.getTextRect(f), p = B7(d, o.get("rotate") || 0);
        l ? l.union(p) : l = p;
      }
      return l;
    }
  }
  function B7(r, e) {
    var t = e * Math.PI / 180, n = r.width, i = r.height, a = n * Math.abs(Math.cos(t)) + Math.abs(i * Math.sin(t)), o = n * Math.abs(Math.sin(t)) + Math.abs(i * Math.cos(t)), s = new Oe(r.x, r.y, a, o);
    return s;
  }
  function U1(r) {
    var e = r.get("interval");
    return e ?? "auto";
  }
  function hN(r) {
    return r.type === "category" && U1(r.getLabelModel()) === 0;
  }
  function av(r, e) {
    var t = {};
    return D(r.mapDimensionsAll(e), function(n) {
      t[j3(r, n)] = true;
    }), je(t);
  }
  function z7(r, e, t) {
    e && D(av(e, t), function(n) {
      var i = e.getApproximateExtent(n);
      i[0] < r[0] && (r[0] = i[0]), i[1] > r[1] && (r[1] = i[1]);
    });
  }
  var Tf = function() {
    function r() {
    }
    return r.prototype.getNeedCrossZero = function() {
      var e = this.option;
      return !e.scale;
    }, r.prototype.getCoordSysModel = function() {
    }, r;
  }(), V7 = 1e-8;
  function DT(r, e) {
    return Math.abs(r - e) < V7;
  }
  function cs(r, e, t) {
    var n = 0, i = r[0];
    if (!i) return false;
    for (var a = 1; a < r.length; a++) {
      var o = r[a];
      n += ea(i[0], i[1], o[0], o[1], e, t), i = o;
    }
    var s = r[0];
    return (!DT(i[0], s[0]) || !DT(i[1], s[1])) && (n += ea(i[0], i[1], s[0], s[1], e, t)), n !== 0;
  }
  var $7 = [];
  function Qm(r, e) {
    for (var t = 0; t < r.length; t++) xr(r[t], r[t], e);
  }
  function PT(r, e, t, n) {
    for (var i = 0; i < r.length; i++) {
      var a = r[i];
      n && (a = n.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Ya(e, e, a), Xa(t, t, a));
    }
  }
  function G7(r) {
    for (var e = 0, t = 0, n = 0, i = r.length, a = r[i - 1][0], o = r[i - 1][1], s = 0; s < i; s++) {
      var l = r[s][0], u = r[s][1], c = a * u - l * o;
      e += c, t += (a + l) * c, n += (o + u) * c, a = l, o = u;
    }
    return e ? [
      t / e / 3,
      n / e / 3,
      e
    ] : [
      r[0][0] || 0,
      r[0][1] || 0
    ];
  }
  var fN = function() {
    function r(e) {
      this.name = e;
    }
    return r.prototype.setCenter = function(e) {
      this._center = e;
    }, r.prototype.getCenter = function() {
      var e = this._center;
      return e || (e = this._center = this.calcCenter()), e;
    }, r;
  }(), kT = /* @__PURE__ */ function() {
    function r(e, t) {
      this.type = "polygon", this.exterior = e, this.interiors = t;
    }
    return r;
  }(), LT = /* @__PURE__ */ function() {
    function r(e) {
      this.type = "linestring", this.points = e;
    }
    return r;
  }(), dN = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this, t) || this;
      return a.type = "geoJSON", a.geometries = n, a._center = i && [
        i[0],
        i[1]
      ], a;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this.geometries, n, i = 0, a = 0; a < t.length; a++) {
        var o = t[a], s = o.exterior, l = s && s.length;
        l > i && (n = o, i = l);
      }
      if (n) return G7(n.exterior);
      var u = this.getBoundingRect();
      return [
        u.x + u.width / 2,
        u.y + u.height / 2
      ];
    }, e.prototype.getBoundingRect = function(t) {
      var n = this._rect;
      if (n && !t) return n;
      var i = [
        1 / 0,
        1 / 0
      ], a = [
        -1 / 0,
        -1 / 0
      ], o = this.geometries;
      return D(o, function(s) {
        s.type === "polygon" ? PT(s.exterior, i, a, t) : D(s.points, function(l) {
          PT(l, i, a, t);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), n = new Oe(i[0], i[1], a[0] - i[0], a[1] - i[1]), t || (this._rect = n), n;
    }, e.prototype.contain = function(t) {
      var n = this.getBoundingRect(), i = this.geometries;
      if (!n.contain(t[0], t[1])) return false;
      e: for (var a = 0, o = i.length; a < o; a++) {
        var s = i[a];
        if (s.type === "polygon") {
          var l = s.exterior, u = s.interiors;
          if (cs(l, t[0], t[1])) {
            for (var c = 0; c < (u ? u.length : 0); c++) if (cs(u[c], t[0], t[1])) continue e;
            return true;
          }
        }
      }
      return false;
    }, e.prototype.transformTo = function(t, n, i, a) {
      var o = this.getBoundingRect(), s = o.width / o.height;
      i ? a || (a = i / s) : i = s * a;
      for (var l = new Oe(t, n, i, a), u = o.calculateTransform(l), c = this.geometries, h = 0; h < c.length; h++) {
        var f = c[h];
        f.type === "polygon" ? (Qm(f.exterior, u), D(f.interiors, function(d) {
          Qm(d, u);
        })) : D(f.points, function(d) {
          Qm(d, u);
        });
      }
      o = this._rect, o.copy(l), this._center = [
        o.x + o.width / 2,
        o.y + o.height / 2
      ];
    }, e.prototype.cloneShallow = function(t) {
      t == null && (t = this.name);
      var n = new e(t, this.geometries, this._center);
      return n._rect = this._rect, n.transformTo = null, n;
    }, e;
  }(fN), W7 = function(r) {
    G(e, r);
    function e(t, n) {
      var i = r.call(this, t) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = n, i;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this._elOnlyForCalculate, n = t.getBoundingRect(), i = [
        n.x + n.width / 2,
        n.y + n.height / 2
      ], a = Yv($7), o = t; o && !o.isGeoSVGGraphicRoot; ) sa(a, o.getLocalTransform(), a), o = o.parent;
      return Pu(a, a), xr(i, i, a), i;
    }, e;
  }(fN);
  function U7(r) {
    if (!r.UTF8Encoding) return r;
    var e = r, t = e.UTF8Scale;
    t == null && (t = 1024);
    var n = e.features;
    return D(n, function(i) {
      var a = i.geometry, o = a.encodeOffsets, s = a.coordinates;
      if (o) switch (a.type) {
        case "LineString":
          a.coordinates = pN(s, o, t);
          break;
        case "Polygon":
          Jm(s, o, t);
          break;
        case "MultiLineString":
          Jm(s, o, t);
          break;
        case "MultiPolygon":
          D(s, function(l, u) {
            return Jm(l, o[u], t);
          });
      }
    }), e.UTF8Encoding = false, e;
  }
  function Jm(r, e, t) {
    for (var n = 0; n < r.length; n++) r[n] = pN(r[n], e[n], t);
  }
  function pN(r, e, t) {
    for (var n = [], i = e[0], a = e[1], o = 0; o < r.length; o += 2) {
      var s = r.charCodeAt(o) - 64, l = r.charCodeAt(o + 1) - 64;
      s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += a, i = s, a = l, n.push([
        s / t,
        l / t
      ]);
    }
    return n;
  }
  function H7(r, e) {
    return r = U7(r), K(ct(r.features, function(t) {
      return t.geometry && t.properties && t.geometry.coordinates.length > 0;
    }), function(t) {
      var n = t.properties, i = t.geometry, a = [];
      switch (i.type) {
        case "Polygon":
          var o = i.coordinates;
          a.push(new kT(o[0], o.slice(1)));
          break;
        case "MultiPolygon":
          D(i.coordinates, function(l) {
            l[0] && a.push(new kT(l[0], l.slice(1)));
          });
          break;
        case "LineString":
          a.push(new LT([
            i.coordinates
          ]));
          break;
        case "MultiLineString":
          a.push(new LT(i.coordinates));
      }
      var s = new dN(n[e || "name"], a, n.cp);
      return s.properties = n, s;
    });
  }
  var Nh = tt();
  function vN(r, e) {
    var t = K(e, function(n) {
      return r.scale.parse(n);
    });
    return r.type === "time" && t.length > 0 && (t.sort(), t.unshift(t[0]), t.push(t[t.length - 1])), t;
  }
  function Y7(r) {
    var e = r.getLabelModel().get("customValues");
    if (e) {
      var t = Gu(r), n = r.scale.getExtent(), i = vN(r, e), a = ct(i, function(o) {
        return o >= n[0] && o <= n[1];
      });
      return {
        labels: K(a, function(o) {
          var s = {
            value: o
          };
          return {
            formattedLabel: t(s),
            rawLabel: r.scale.getLabel(s),
            tickValue: o
          };
        })
      };
    }
    return r.type === "category" ? q7(r) : Z7(r);
  }
  function X7(r, e) {
    var t = r.getTickModel().get("customValues");
    if (t) {
      var n = r.scale.getExtent(), i = vN(r, t);
      return {
        ticks: ct(i, function(a) {
          return a >= n[0] && a <= n[1];
        })
      };
    }
    return r.type === "category" ? K7(r, e) : {
      ticks: K(r.scale.getTicks(), function(a) {
        return a.value;
      })
    };
  }
  function q7(r) {
    var e = r.getLabelModel(), t = gN(r, e);
    return !e.get("show") || r.scale.isBlank() ? {
      labels: [],
      labelCategoryInterval: t.labelCategoryInterval
    } : t;
  }
  function gN(r, e) {
    var t = mN(r, "labels"), n = U1(e), i = yN(t, n);
    if (i) return i;
    var a, o;
    return ge(n) ? a = bN(r, n) : (o = n === "auto" ? j7(r) : n, a = _N(r, o)), xN(t, n, {
      labels: a,
      labelCategoryInterval: o
    });
  }
  function K7(r, e) {
    var t = mN(r, "ticks"), n = U1(e), i = yN(t, n);
    if (i) return i;
    var a, o;
    if ((!e.get("show") || r.scale.isBlank()) && (a = []), ge(n)) a = bN(r, n, true);
    else if (n === "auto") {
      var s = gN(r, r.getLabelModel());
      o = s.labelCategoryInterval, a = K(s.labels, function(l) {
        return l.tickValue;
      });
    } else o = n, a = _N(r, o, true);
    return xN(t, n, {
      ticks: a,
      tickCategoryInterval: o
    });
  }
  function Z7(r) {
    var e = r.scale.getTicks(), t = Gu(r);
    return {
      labels: K(e, function(n, i) {
        return {
          level: n.level,
          formattedLabel: t(n, i),
          rawLabel: r.scale.getLabel(n),
          tickValue: n.value
        };
      })
    };
  }
  function mN(r, e) {
    return Nh(r)[e] || (Nh(r)[e] = []);
  }
  function yN(r, e) {
    for (var t = 0; t < r.length; t++) if (r[t].key === e) return r[t].value;
  }
  function xN(r, e, t) {
    return r.push({
      key: e,
      value: t
    }), t;
  }
  function j7(r) {
    var e = Nh(r).autoInterval;
    return e ?? (Nh(r).autoInterval = r.calculateCategoryInterval());
  }
  function Q7(r) {
    var e = J7(r), t = Gu(r), n = (e.axisRotate - e.labelRotate) / 180 * Math.PI, i = r.scale, a = i.getExtent(), o = i.count();
    if (a[1] - a[0] < 1) return 0;
    var s = 1;
    o > 40 && (s = Math.max(1, Math.floor(o / 40)));
    for (var l = a[0], u = r.dataToCoord(l + 1) - r.dataToCoord(l), c = Math.abs(u * Math.cos(n)), h = Math.abs(u * Math.sin(n)), f = 0, d = 0; l <= a[1]; l += s) {
      var p = 0, v = 0, g = pf(t({
        value: l
      }), e.font, "center", "top");
      p = g.width * 1.3, v = g.height * 1.3, f = Math.max(f, p, 7), d = Math.max(d, v, 7);
    }
    var m = f / c, y = d / h;
    isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0);
    var x = Math.max(0, Math.floor(Math.min(m, y))), _ = Nh(r.model), S = r.getExtent(), b = _.lastAutoInterval, w = _.lastTickCount;
    return b != null && w != null && Math.abs(b - x) <= 1 && Math.abs(w - o) <= 1 && b > x && _.axisExtent0 === S[0] && _.axisExtent1 === S[1] ? x = b : (_.lastTickCount = o, _.lastAutoInterval = x, _.axisExtent0 = S[0], _.axisExtent1 = S[1]), x;
  }
  function J7(r) {
    var e = r.getLabelModel();
    return {
      axisRotate: r.getRotate ? r.getRotate() : r.isHorizontal && !r.isHorizontal() ? 90 : 0,
      labelRotate: e.get("rotate") || 0,
      font: e.getFont()
    };
  }
  function _N(r, e, t) {
    var n = Gu(r), i = r.scale, a = i.getExtent(), o = r.getLabelModel(), s = [], l = Math.max((e || 0) + 1, 1), u = a[0], c = i.count();
    u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
    var h = hN(r), f = o.get("showMinLabel") || h, d = o.get("showMaxLabel") || h;
    f && u !== a[0] && v(a[0]);
    for (var p = u; p <= a[1]; p += l) v(p);
    d && p - l !== a[1] && v(a[1]);
    function v(g) {
      var m = {
        value: g
      };
      s.push(t ? g : {
        formattedLabel: n(m),
        rawLabel: i.getLabel(m),
        tickValue: g
      });
    }
    return s;
  }
  function bN(r, e, t) {
    var n = r.scale, i = Gu(r), a = [];
    return D(n.getTicks(), function(o) {
      var s = n.getLabel(o), l = o.value;
      e(o.value, s) && a.push(t ? l : {
        formattedLabel: i(o),
        rawLabel: s,
        tickValue: l
      });
    }), a;
  }
  var RT = [
    0,
    1
  ], hi = function() {
    function r(e, t, n) {
      this.onBand = false, this.inverse = false, this.dim = e, this.scale = t, this._extent = n || [
        0,
        0
      ];
    }
    return r.prototype.contain = function(e) {
      var t = this._extent, n = Math.min(t[0], t[1]), i = Math.max(t[0], t[1]);
      return e >= n && e <= i;
    }, r.prototype.containData = function(e) {
      return this.scale.contain(e);
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.getPixelPrecision = function(e) {
      return wR(e || this.scale.getExtent(), this._extent);
    }, r.prototype.setExtent = function(e, t) {
      var n = this._extent;
      n[0] = e, n[1] = t;
    }, r.prototype.dataToCoord = function(e, t) {
      var n = this._extent, i = this.scale;
      return e = i.normalize(e), this.onBand && i.type === "ordinal" && (n = n.slice(), ET(n, i.count())), ht(e, RT, n, t);
    }, r.prototype.coordToData = function(e, t) {
      var n = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (n = n.slice(), ET(n, i.count()));
      var a = ht(e, n, RT, t);
      return this.scale.scale(a);
    }, r.prototype.pointToData = function(e, t) {
    }, r.prototype.getTicksCoords = function(e) {
      e = e || {};
      var t = e.tickModel || this.getTickModel(), n = X7(this, t), i = n.ticks, a = K(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), o = t.get("alignWithLabel");
      return eq(this, a, o, e.clamp), a;
    }, r.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal") return [];
      var e = this.model.getModel("minorTick"), t = e.get("splitNumber");
      t > 0 && t < 100 || (t = 5);
      var n = this.scale.getMinorTicks(t), i = K(n, function(a) {
        return K(a, function(o) {
          return {
            coord: this.dataToCoord(o),
            tickValue: o
          };
        }, this);
      }, this);
      return i;
    }, r.prototype.getViewLabels = function() {
      return Y7(this).labels;
    }, r.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, r.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, r.prototype.getBandWidth = function() {
      var e = this._extent, t = this.scale.getExtent(), n = t[1] - t[0] + (this.onBand ? 1 : 0);
      n === 0 && (n = 1);
      var i = Math.abs(e[1] - e[0]);
      return Math.abs(i) / n;
    }, r.prototype.calculateCategoryInterval = function() {
      return Q7(this);
    }, r;
  }();
  function ET(r, e) {
    var t = r[1] - r[0], n = e, i = t / n / 2;
    r[0] += i, r[1] -= i;
  }
  function eq(r, e, t, n) {
    var i = e.length;
    if (!r.onBand || t || !i) return;
    var a = r.getExtent(), o, s;
    if (i === 1) e[0].coord = a[0], o = e[1] = {
      coord: a[1],
      tickValue: e[0].tickValue
    };
    else {
      var l = e[i - 1].tickValue - e[0].tickValue, u = (e[i - 1].coord - e[0].coord) / l;
      D(e, function(d) {
        d.coord -= u / 2;
      });
      var c = r.scale.getExtent();
      s = 1 + c[1] - e[i - 1].tickValue, o = {
        coord: e[i - 1].coord + u * s,
        tickValue: c[1] + 1
      }, e.push(o);
    }
    var h = a[0] > a[1];
    f(e[0].coord, a[0]) && (n ? e[0].coord = a[0] : e.shift()), n && f(a[0], e[0].coord) && e.unshift({
      coord: a[0]
    }), f(a[1], o.coord) && (n ? o.coord = a[1] : e.pop()), n && f(o.coord, a[1]) && e.push({
      coord: a[1]
    });
    function f(d, p) {
      return d = Bt(d), p = Bt(p), h ? d > p : d < p;
    }
  }
  var fc = Math.PI * 2, Ho = $i.CMD, tq = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function rq(r, e, t, n, i) {
    var a = t.width, o = t.height;
    switch (r) {
      case "top":
        n.set(t.x + a / 2, t.y - e), i.set(0, -1);
        break;
      case "bottom":
        n.set(t.x + a / 2, t.y + o + e), i.set(0, 1);
        break;
      case "left":
        n.set(t.x - e, t.y + o / 2), i.set(-1, 0);
        break;
      case "right":
        n.set(t.x + a + e, t.y + o / 2), i.set(1, 0);
        break;
    }
  }
  function nq(r, e, t, n, i, a, o, s, l) {
    o -= r, s -= e;
    var u = Math.sqrt(o * o + s * s);
    o /= u, s /= u;
    var c = o * t + r, h = s * t + e;
    if (Math.abs(n - i) % fc < 1e-4) return l[0] = c, l[1] = h, u - t;
    if (a) {
      var f = n;
      n = dn(i), i = dn(f);
    } else n = dn(n), i = dn(i);
    n > i && (i += fc);
    var d = Math.atan2(s, o);
    if (d < 0 && (d += fc), d >= n && d <= i || d + fc >= n && d + fc <= i) return l[0] = c, l[1] = h, u - t;
    var p = t * Math.cos(n) + r, v = t * Math.sin(n) + e, g = t * Math.cos(i) + r, m = t * Math.sin(i) + e, y = (p - o) * (p - o) + (v - s) * (v - s), x = (g - o) * (g - o) + (m - s) * (m - s);
    return y < x ? (l[0] = p, l[1] = v, Math.sqrt(y)) : (l[0] = g, l[1] = m, Math.sqrt(x));
  }
  function ov(r, e, t, n, i, a, o, s) {
    var l = i - r, u = a - e, c = t - r, h = n - e, f = Math.sqrt(c * c + h * h);
    c /= f, h /= f;
    var d = l * c + u * h, p = d / f;
    s && (p = Math.min(Math.max(p, 0), 1)), p *= f;
    var v = o[0] = r + p * c, g = o[1] = e + p * h;
    return Math.sqrt((v - i) * (v - i) + (g - a) * (g - a));
  }
  function SN(r, e, t, n, i, a, o) {
    t < 0 && (r = r + t, t = -t), n < 0 && (e = e + n, n = -n);
    var s = r + t, l = e + n, u = o[0] = Math.min(Math.max(i, r), s), c = o[1] = Math.min(Math.max(a, e), l);
    return Math.sqrt((u - i) * (u - i) + (c - a) * (c - a));
  }
  var Qn = [];
  function iq(r, e, t) {
    var n = SN(e.x, e.y, e.width, e.height, r.x, r.y, Qn);
    return t.set(Qn[0], Qn[1]), n;
  }
  function aq(r, e, t) {
    for (var n = 0, i = 0, a = 0, o = 0, s, l, u = 1 / 0, c = e.data, h = r.x, f = r.y, d = 0; d < c.length; ) {
      var p = c[d++];
      d === 1 && (n = c[d], i = c[d + 1], a = n, o = i);
      var v = u;
      switch (p) {
        case Ho.M:
          a = c[d++], o = c[d++], n = a, i = o;
          break;
        case Ho.L:
          v = ov(n, i, c[d], c[d + 1], h, f, Qn, true), n = c[d++], i = c[d++];
          break;
        case Ho.C:
          v = aR(n, i, c[d++], c[d++], c[d++], c[d++], c[d], c[d + 1], h, f, Qn), n = c[d++], i = c[d++];
          break;
        case Ho.Q:
          v = sR(n, i, c[d++], c[d++], c[d], c[d + 1], h, f, Qn), n = c[d++], i = c[d++];
          break;
        case Ho.A:
          var g = c[d++], m = c[d++], y = c[d++], x = c[d++], _ = c[d++], S = c[d++];
          d += 1;
          var b = !!(1 - c[d++]);
          s = Math.cos(_) * y + g, l = Math.sin(_) * x + m, d <= 1 && (a = s, o = l);
          var w = (h - g) * x / y + g;
          v = nq(g, m, x, _, _ + S, b, w, f, Qn), n = Math.cos(_ + S) * y + g, i = Math.sin(_ + S) * x + m;
          break;
        case Ho.R:
          a = n = c[d++], o = i = c[d++];
          var C = c[d++], T = c[d++];
          v = SN(a, o, C, T, h, f, Qn);
          break;
        case Ho.Z:
          v = ov(n, i, a, o, h, f, Qn, true), n = a, i = o;
          break;
      }
      v < u && (u = v, t.set(Qn[0], Qn[1]));
    }
    return u;
  }
  var ti = new Ne(), St = new Ne(), Vt = new Ne(), ki = new Ne(), Ii = new Ne();
  function NT(r, e) {
    if (r) {
      var t = r.getTextGuideLine(), n = r.getTextContent();
      if (n && t) {
        var i = r.textGuideLineConfig || {}, a = [
          [
            0,
            0
          ],
          [
            0,
            0
          ],
          [
            0,
            0
          ]
        ], o = i.candidates || tq, s = n.getBoundingRect().clone();
        s.applyTransform(n.getComputedTransform());
        var l = 1 / 0, u = i.anchor, c = r.getComputedTransform(), h = c && Pu([], c), f = e.get("length2") || 0;
        u && Vt.copy(u);
        for (var d = 0; d < o.length; d++) {
          var p = o[d];
          rq(p, 0, s, ti, ki), Ne.scaleAndAdd(St, ti, ki, f), St.transform(h);
          var v = r.getBoundingRect(), g = u ? u.distance(St) : r instanceof Ue ? aq(St, r.path, Vt) : iq(St, v, Vt);
          g < l && (l = g, St.transform(c), Vt.transform(c), Vt.toArray(a[0]), St.toArray(a[1]), ti.toArray(a[2]));
        }
        wN(a, e.get("minTurnAngle")), t.setShape({
          points: a
        });
      }
    }
  }
  var sv = [], zr = new Ne();
  function wN(r, e) {
    if (e <= 180 && e > 0) {
      e = e / 180 * Math.PI, ti.fromArray(r[0]), St.fromArray(r[1]), Vt.fromArray(r[2]), Ne.sub(ki, ti, St), Ne.sub(Ii, Vt, St);
      var t = ki.len(), n = Ii.len();
      if (!(t < 1e-3 || n < 1e-3)) {
        ki.scale(1 / t), Ii.scale(1 / n);
        var i = ki.dot(Ii), a = Math.cos(e);
        if (a < i) {
          var o = ov(St.x, St.y, Vt.x, Vt.y, ti.x, ti.y, sv, false);
          zr.fromArray(sv), zr.scaleAndAdd(Ii, o / Math.tan(Math.PI - e));
          var s = Vt.x !== St.x ? (zr.x - St.x) / (Vt.x - St.x) : (zr.y - St.y) / (Vt.y - St.y);
          if (isNaN(s)) return;
          s < 0 ? Ne.copy(zr, St) : s > 1 && Ne.copy(zr, Vt), zr.toArray(r[1]);
        }
      }
    }
  }
  function oq(r, e, t) {
    if (t <= 180 && t > 0) {
      t = t / 180 * Math.PI, ti.fromArray(r[0]), St.fromArray(r[1]), Vt.fromArray(r[2]), Ne.sub(ki, St, ti), Ne.sub(Ii, Vt, St);
      var n = ki.len(), i = Ii.len();
      if (!(n < 1e-3 || i < 1e-3)) {
        ki.scale(1 / n), Ii.scale(1 / i);
        var a = ki.dot(e), o = Math.cos(t);
        if (a < o) {
          var s = ov(St.x, St.y, Vt.x, Vt.y, ti.x, ti.y, sv, false);
          zr.fromArray(sv);
          var l = Math.PI / 2, u = Math.acos(Ii.dot(e)), c = l + u - t;
          if (c >= l) Ne.copy(zr, Vt);
          else {
            zr.scaleAndAdd(Ii, s / Math.tan(Math.PI / 2 - c));
            var h = Vt.x !== St.x ? (zr.x - St.x) / (Vt.x - St.x) : (zr.y - St.y) / (Vt.y - St.y);
            if (isNaN(h)) return;
            h < 0 ? Ne.copy(zr, St) : h > 1 && Ne.copy(zr, Vt);
          }
          zr.toArray(r[1]);
        }
      }
    }
  }
  function ey(r, e, t, n) {
    var i = t === "normal", a = i ? r : r.ensureState(t);
    a.ignore = e;
    var o = n.get("smooth");
    o && o === true && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
    var s = n.getModel("lineStyle").getLineStyle();
    i ? r.useStyle(s) : a.style = s;
  }
  function sq(r, e) {
    var t = e.smooth, n = e.points;
    if (n) if (r.moveTo(n[0][0], n[0][1]), t > 0 && n.length >= 3) {
      var i = Ha(n[0], n[1]), a = Ha(n[1], n[2]);
      if (!i || !a) {
        r.lineTo(n[1][0], n[1][1]), r.lineTo(n[2][0], n[2][1]);
        return;
      }
      var o = Math.min(i, a) * t, s = cp([], n[1], n[0], o / i), l = cp([], n[1], n[2], o / a), u = cp([], s, l, 0.5);
      r.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), r.bezierCurveTo(l[0], l[1], l[0], l[1], n[2][0], n[2][1]);
    } else for (var c = 1; c < n.length; c++) r.lineTo(n[c][0], n[c][1]);
  }
  function H1(r, e, t) {
    var n = r.getTextGuideLine(), i = r.getTextContent();
    if (!i) {
      n && r.removeTextGuideLine();
      return;
    }
    for (var a = e.normal, o = a.get("show"), s = i.ignore, l = 0; l < Ah.length; l++) {
      var u = Ah[l], c = e[u], h = u === "normal";
      if (c) {
        var f = c.get("show"), d = h ? s : Pe(i.states[u] && i.states[u].ignore, s);
        if (d || !Pe(f, o)) {
          var p = h ? n : n && n.states[u];
          p && (p.ignore = true), n && ey(n, true, u, c);
          continue;
        }
        n || (n = new Zr(), r.setTextGuideLine(n), !h && (s || !o) && ey(n, true, "normal", e.normal), r.stateProxy && (n.stateProxy = r.stateProxy)), ey(n, false, u, c);
      }
    }
    if (n) {
      ye(n.style, t), n.style.fill = null;
      var v = a.get("showAbove"), g = r.textGuideLineConfig = r.textGuideLineConfig || {};
      g.showAbove = v || false, n.buildPath = sq;
    }
  }
  function Y1(r, e) {
    e = e || "labelLine";
    for (var t = {
      normal: r.getModel(e)
    }, n = 0; n < Xr.length; n++) {
      var i = Xr[n];
      t[i] = r.getModel([
        i,
        e
      ]);
    }
    return t;
  }
  function CN(r) {
    for (var e = [], t = 0; t < r.length; t++) {
      var n = r[t];
      if (!n.defaultAttr.ignore) {
        var i = n.label, a = i.getComputedTransform(), o = i.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = i.style.margin || 0, u = o.clone();
        u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
        var c = s ? new Hp(o, a) : null;
        e.push({
          label: i,
          labelLine: n.labelLine,
          rect: u,
          localRect: o,
          obb: c,
          priority: n.priority,
          defaultAttr: n.defaultAttr,
          layoutOption: n.computedLayoutOption,
          axisAligned: s,
          transform: a
        });
      }
    }
    return e;
  }
  function TN(r, e, t, n, i, a) {
    var o = r.length;
    if (o < 2) return;
    r.sort(function(b, w) {
      return b.rect[e] - w.rect[e];
    });
    for (var s = 0, l, u = false, c = 0; c < o; c++) {
      var h = r[c], f = h.rect;
      l = f[e] - s, l < 0 && (f[e] -= l, h.label[e] -= l, u = true), s = f[e] + f[t];
    }
    var d = r[0], p = r[o - 1], v, g;
    m(), v < 0 && _(-v, 0.8), g < 0 && _(g, 0.8), m(), y(v, g, 1), y(g, v, -1), m(), v < 0 && S(-v), g < 0 && S(g);
    function m() {
      v = d.rect[e] - n, g = i - p.rect[e] - p.rect[t];
    }
    function y(b, w, C) {
      if (b < 0) {
        var T = Math.min(w, -b);
        if (T > 0) {
          x(T * C, 0, o);
          var A = T + b;
          A < 0 && _(-A * C, 1);
        } else _(-b * C, 1);
      }
    }
    function x(b, w, C) {
      b !== 0 && (u = true);
      for (var T = w; T < C; T++) {
        var A = r[T], M = A.rect;
        M[e] += b, A.label[e] += b;
      }
    }
    function _(b, w) {
      for (var C = [], T = 0, A = 1; A < o; A++) {
        var M = r[A - 1].rect, E = Math.max(r[A].rect[e] - M[e] - M[t], 0);
        C.push(E), T += E;
      }
      if (T) {
        var k = Math.min(Math.abs(b) / T, w);
        if (b > 0) for (var A = 0; A < o - 1; A++) {
          var R = C[A] * k;
          x(R, 0, A + 1);
        }
        else for (var A = o - 1; A > 0; A--) {
          var R = C[A - 1] * k;
          x(-R, A, o);
        }
      }
    }
    function S(b) {
      var w = b < 0 ? -1 : 1;
      b = Math.abs(b);
      for (var C = Math.ceil(b / (o - 1)), T = 0; T < o - 1; T++) if (w > 0 ? x(C, 0, T + 1) : x(-C, o - T - 1, o), b -= C, b <= 0) return;
    }
    return u;
  }
  function lq(r, e, t, n) {
    return TN(r, "x", "width", e, t);
  }
  function AN(r, e, t, n) {
    return TN(r, "y", "height", e, t);
  }
  function IN(r) {
    var e = [];
    r.sort(function(v, g) {
      return g.priority - v.priority;
    });
    var t = new Oe(0, 0, 0, 0);
    function n(v) {
      if (!v.ignore) {
        var g = v.ensureState("emphasis");
        g.ignore == null && (g.ignore = false);
      }
      v.ignore = true;
    }
    for (var i = 0; i < r.length; i++) {
      var a = r[i], o = a.axisAligned, s = a.localRect, l = a.transform, u = a.label, c = a.labelLine;
      t.copy(a.rect), t.width -= 0.1, t.height -= 0.1, t.x += 0.05, t.y += 0.05;
      for (var h = a.obb, f = false, d = 0; d < e.length; d++) {
        var p = e[d];
        if (t.intersect(p.rect)) {
          if (o && p.axisAligned) {
            f = true;
            break;
          }
          if (p.obb || (p.obb = new Hp(p.localRect, p.transform)), h || (h = new Hp(s, l)), h.intersect(p.obb)) {
            f = true;
            break;
          }
        }
      }
      f ? (n(u), c && n(c)) : (u.attr("ignore", a.defaultAttr.ignore), c && c.attr("ignore", a.defaultAttr.labelGuideIgnore), e.push(a));
    }
  }
  function uq(r) {
    if (r) {
      for (var e = [], t = 0; t < r.length; t++) e.push(r[t].slice());
      return e;
    }
  }
  function cq(r, e) {
    var t = r.label, n = e && e.getTextGuideLine();
    return {
      dataIndex: r.dataIndex,
      dataType: r.dataType,
      seriesIndex: r.seriesModel.seriesIndex,
      text: r.label.style.text,
      rect: r.hostRect,
      labelRect: r.rect,
      align: t.style.align,
      verticalAlign: t.style.verticalAlign,
      labelLinePoints: uq(n && n.shape.points)
    };
  }
  var OT = [
    "align",
    "verticalAlign",
    "width",
    "height",
    "fontSize"
  ], Nr = new ta(), ty = tt(), hq = tt();
  function md(r, e, t) {
    for (var n = 0; n < t.length; n++) {
      var i = t[n];
      e[i] != null && (r[i] = e[i]);
    }
  }
  var yd = [
    "x",
    "y",
    "rotation"
  ], fq = function() {
    function r() {
      this._labelList = [], this._chartViewList = [];
    }
    return r.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, r.prototype._addLabel = function(e, t, n, i, a) {
      var o = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      Oe.applyTransform(c, c, u), u ? Nr.setLocalTransform(u) : (Nr.x = Nr.y = Nr.rotation = Nr.originX = Nr.originY = 0, Nr.scaleX = Nr.scaleY = 1), Nr.rotation = dn(Nr.rotation);
      var h = i.__hostTarget, f;
      if (h) {
        f = h.getBoundingRect().plain();
        var d = h.getComputedTransform();
        Oe.applyTransform(f, f, d);
      }
      var p = f && h.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: n,
        dataIndex: e,
        dataType: t,
        layoutOption: a,
        computedLayoutOption: null,
        rect: c,
        hostRect: f,
        priority: f ? f.width * f.height : 0,
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: Nr.x,
          y: Nr.y,
          scaleX: Nr.scaleX,
          scaleY: Nr.scaleY,
          rotation: Nr.rotation,
          style: {
            x: o.x,
            y: o.y,
            align: o.align,
            verticalAlign: o.verticalAlign,
            width: o.width,
            height: o.height,
            fontSize: o.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, r.prototype.addLabelsOfSeries = function(e) {
      var t = this;
      this._chartViewList.push(e);
      var n = e.__model, i = n.get("labelLayout");
      (ge(i) || je(i).length) && e.group.traverse(function(a) {
        if (a.ignore) return true;
        var o = a.getTextContent(), s = De(a);
        o && !o.disableLabelLayout && t._addLabel(s.dataIndex, s.dataType, n, o, i);
      });
    }, r.prototype.updateLayoutConfig = function(e) {
      var t = e.getWidth(), n = e.getHeight();
      function i(x, _) {
        return function() {
          NT(x, _);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, c = void 0;
        ge(o.layoutOption) ? c = o.layoutOption(cq(o, l)) : c = o.layoutOption, c = c || {}, o.computedLayoutOption = c;
        var h = Math.PI / 180;
        l && l.setTextConfig({
          local: false,
          position: c.x != null || c.y != null ? null : u.attachedPos,
          rotation: c.rotate != null ? c.rotate * h : u.attachedRot,
          offset: [
            c.dx || 0,
            c.dy || 0
          ]
        });
        var f = false;
        if (c.x != null ? (s.x = Q(c.x, t), s.setStyle("x", 0), f = true) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = Q(c.y, n), s.setStyle("y", 0), f = true) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var d = l.getTextGuideLine();
          d && (d.setShape({
            points: c.labelLinePoints
          }), f = false);
        }
        var p = ty(s);
        p.needsUpdateLabelLine = f, s.rotation = c.rotate != null ? c.rotate * h : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var v = 0; v < OT.length; v++) {
          var g = OT[v];
          s.setStyle(g, c[g] != null ? c[g] : u.style[g]);
        }
        if (c.draggable) {
          if (s.draggable = true, s.cursor = "move", l) {
            var m = o.seriesModel;
            if (o.dataIndex != null) {
              var y = o.seriesModel.getData(o.dataType);
              m = y.getItemModel(o.dataIndex);
            }
            s.on("drag", i(l, m.getModel("labelLine")));
          }
        } else s.off("drag"), s.cursor = u.cursor;
      }
    }, r.prototype.layout = function(e) {
      var t = e.getWidth(), n = e.getHeight(), i = CN(this._labelList), a = ct(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), o = ct(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      lq(a, 0, t), AN(o, 0, n);
      var s = ct(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      IN(s);
    }, r.prototype.processLabelsOverall = function() {
      var e = this;
      D(this._chartViewList, function(t) {
        var n = t.__model, i = t.ignoreLabelLineUpdate, a = n.isAnimationEnabled();
        t.group.traverse(function(o) {
          if (o.ignore && !o.forceLabelAnimation) return true;
          var s = !i, l = o.getTextContent();
          !s && l && (s = ty(l).needsUpdateLabelLine), s && e._updateLabelLine(o, n), a && e._animateLabels(o, n);
        });
      });
    }, r.prototype._updateLabelLine = function(e, t) {
      var n = e.getTextContent(), i = De(e), a = i.dataIndex;
      if (n && a != null) {
        var o = t.getData(i.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
        if (u) {
          var c = o.getVisual("drawType");
          l.stroke = u[c];
        }
        var h = s.getModel("labelLine");
        H1(e, Y1(s), l), NT(e, h);
      }
    }, r.prototype._animateLabels = function(e, t) {
      var n = e.getTextContent(), i = e.getTextGuideLine();
      if (n && (e.forceLabelAnimation || !n.ignore && !n.invisible && !e.disableLabelAnimation && !eu(e))) {
        var a = ty(n), o = a.oldLayout, s = De(e), l = s.dataIndex, u = {
          x: n.x,
          y: n.y,
          rotation: n.rotation
        }, c = t.getData(s.dataType);
        if (o) {
          n.attr(o);
          var f = e.prevStates;
          f && (Be(f, "select") >= 0 && n.attr(a.oldLayoutSelect), Be(f, "emphasis") >= 0 && n.attr(a.oldLayoutEmphasis)), it(n, u, t, l);
        } else if (n.attr(u), !Eu(n).valueAnimation) {
          var h = Pe(n.style.opacity, 1);
          n.style.opacity = 0, kt(n, {
            style: {
              opacity: h
            }
          }, t, l);
        }
        if (a.oldLayout = u, n.states.select) {
          var d = a.oldLayoutSelect = {};
          md(d, u, yd), md(d, n.states.select, yd);
        }
        if (n.states.emphasis) {
          var p = a.oldLayoutEmphasis = {};
          md(p, u, yd), md(p, n.states.emphasis, yd);
        }
        yE(n, l, c, t, t);
      }
      if (i && !i.ignore && !i.invisible) {
        var a = hq(i), o = a.oldLayout, v = {
          points: i.shape.points
        };
        o ? (i.attr({
          shape: o
        }), it(i, {
          shape: v
        }, t)) : (i.setShape(v), i.style.strokePercent = 0, kt(i, {
          style: {
            strokePercent: 1
          }
        }, t)), a.oldLayout = v;
      }
    }, r;
  }(), ry = tt();
  function dq(r) {
    r.registerUpdateLifecycle("series:beforeupdate", function(e, t, n) {
      var i = ry(t).labelManager;
      i || (i = ry(t).labelManager = new fq()), i.clearLabels();
    }), r.registerUpdateLifecycle("series:layoutlabels", function(e, t, n) {
      var i = ry(t).labelManager;
      n.updatedSeries.forEach(function(a) {
        i.addLabelsOfSeries(t.getViewOfSeriesModel(a));
      }), i.updateLayoutConfig(t), i.layout(t), i.processLabelsOverall();
    });
  }
  var ny = Math.sin, iy = Math.cos, MN = Math.PI, Yo = Math.PI * 2, pq = 180 / MN, DN = function() {
    function r() {
    }
    return r.prototype.reset = function(e) {
      this._start = true, this._d = [], this._str = "", this._p = Math.pow(10, e || 4);
    }, r.prototype.moveTo = function(e, t) {
      this._add("M", e, t);
    }, r.prototype.lineTo = function(e, t) {
      this._add("L", e, t);
    }, r.prototype.bezierCurveTo = function(e, t, n, i, a, o) {
      this._add("C", e, t, n, i, a, o);
    }, r.prototype.quadraticCurveTo = function(e, t, n, i) {
      this._add("Q", e, t, n, i);
    }, r.prototype.arc = function(e, t, n, i, a, o) {
      this.ellipse(e, t, n, n, 0, i, a, o);
    }, r.prototype.ellipse = function(e, t, n, i, a, o, s, l) {
      var u = s - o, c = !l, h = Math.abs(u), f = Za(h - Yo) || (c ? u >= Yo : -u >= Yo), d = u > 0 ? u % Yo : u % Yo + Yo, p = false;
      f ? p = true : Za(h) ? p = false : p = d >= MN == !!c;
      var v = e + n * iy(o), g = t + i * ny(o);
      this._start && this._add("M", v, g);
      var m = Math.round(a * pq);
      if (f) {
        var y = 1 / this._p, x = (c ? 1 : -1) * (Yo - y);
        this._add("A", n, i, m, 1, +c, e + n * iy(o + x), t + i * ny(o + x)), y > 0.01 && this._add("A", n, i, m, 0, +c, v, g);
      } else {
        var _ = e + n * iy(s), S = t + i * ny(s);
        this._add("A", n, i, m, +p, +c, _, S);
      }
    }, r.prototype.rect = function(e, t, n, i) {
      this._add("M", e, t), this._add("l", n, 0), this._add("l", 0, i), this._add("l", -n, 0), this._add("Z");
    }, r.prototype.closePath = function() {
      this._d.length > 0 && this._add("Z");
    }, r.prototype._add = function(e, t, n, i, a, o, s, l, u) {
      for (var c = [], h = this._p, f = 1; f < arguments.length; f++) {
        var d = arguments[f];
        if (isNaN(d)) {
          this._invalid = true;
          return;
        }
        c.push(Math.round(d * h) / h);
      }
      this._d.push(e + c.join(" ")), this._start = e === "Z";
    }, r.prototype.generateStr = function() {
      this._str = this._invalid ? "" : this._d.join(""), this._d = [];
    }, r.prototype.getStr = function() {
      return this._str;
    }, r;
  }(), X1 = "none", vq = Math.round;
  function gq(r) {
    var e = r.fill;
    return e != null && e !== X1;
  }
  function mq(r) {
    var e = r.stroke;
    return e != null && e !== X1;
  }
  var a_ = [
    "lineCap",
    "miterLimit",
    "lineJoin"
  ], yq = K(a_, function(r) {
    return "stroke-" + r.toLowerCase();
  });
  function xq(r, e, t, n) {
    var i = e.opacity == null ? 1 : e.opacity;
    if (t instanceof mr) {
      r("opacity", i);
      return;
    }
    if (gq(e)) {
      var a = wh(e.fill);
      r("fill", a.color);
      var o = e.fillOpacity != null ? e.fillOpacity * a.opacity * i : a.opacity * i;
      o < 1 && r("fill-opacity", o);
    } else r("fill", X1);
    if (mq(e)) {
      var s = wh(e.stroke);
      r("stroke", s.color);
      var l = e.strokeNoScale ? t.getLineScale() : 1, u = l ? (e.lineWidth || 0) / l : 0, c = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * i : s.opacity * i, h = e.strokeFirst;
      if (u !== 1 && r("stroke-width", u), h && r("paint-order", h ? "stroke" : "fill"), c < 1 && r("stroke-opacity", c), e.lineDash) {
        var f = E1(t), d = f[0], p = f[1];
        d && (p = vq(p || 0), r("stroke-dasharray", d.join(",")), (p || n) && r("stroke-dashoffset", p));
      }
      for (var v = 0; v < a_.length; v++) {
        var g = a_[v];
        if (e[g] !== Wp[g]) {
          var m = e[g] || Wp[g];
          m && r(yq[v], m);
        }
      }
    }
  }
  var PN = "http://www.w3.org/2000/svg", kN = "http://www.w3.org/1999/xlink", _q = "http://www.w3.org/2000/xmlns/", bq = "http://www.w3.org/XML/1998/namespace", FT = "ecmeta_";
  function LN(r) {
    return document.createElementNS(PN, r);
  }
  function ar(r, e, t, n, i) {
    return {
      tag: r,
      attrs: t || {},
      children: n,
      text: i,
      key: e
    };
  }
  function Sq(r, e) {
    var t = [];
    if (e) for (var n in e) {
      var i = e[n], a = n;
      i !== false && (i !== true && i != null && (a += '="' + i + '"'), t.push(a));
    }
    return "<" + r + " " + t.join(" ") + ">";
  }
  function wq(r) {
    return "</" + r + ">";
  }
  function q1(r, e) {
    e = e || {};
    var t = e.newline ? `
` : "";
    function n(i) {
      var a = i.children, o = i.tag, s = i.attrs, l = i.text;
      return Sq(o, s) + (o !== "style" ? Vr(l) : l || "") + (a ? "" + t + K(a, function(u) {
        return n(u);
      }).join(t) + t : "") + wq(o);
    }
    return n(r);
  }
  function Cq(r, e, t) {
    t = t || {};
    var n = t.newline ? `
` : "", i = " {" + n, a = n + "}", o = K(je(r), function(l) {
      return l + i + K(je(r[l]), function(u) {
        return u + ":" + r[l][u] + ";";
      }).join(n) + a;
    }).join(n), s = K(je(e), function(l) {
      return "@keyframes " + l + i + K(je(e[l]), function(u) {
        return u + i + K(je(e[l][u]), function(c) {
          var h = e[l][u][c];
          return c === "d" && (h = 'path("' + h + '")'), c + ":" + h + ";";
        }).join(n) + a;
      }).join(n) + a;
    }).join(n);
    return !o && !s ? "" : [
      "<![CDATA[",
      o,
      s,
      "]]>"
    ].join(n);
  }
  function o_(r) {
    return {
      zrId: r,
      shadowCache: {},
      patternCache: {},
      gradientCache: {},
      clipPathCache: {},
      defs: {},
      cssNodes: {},
      cssAnims: {},
      cssStyleCache: {},
      cssAnimIdx: 0,
      shadowIdx: 0,
      gradientIdx: 0,
      patternIdx: 0,
      clipPathIdx: 0
    };
  }
  function BT(r, e, t, n) {
    return ar("svg", "root", {
      width: r,
      height: e,
      xmlns: PN,
      "xmlns:xlink": kN,
      version: "1.1",
      baseProfile: "full",
      viewBox: n ? "0 0 " + r + " " + e : false
    }, t);
  }
  var Tq = 0;
  function RN() {
    return Tq++;
  }
  var zT = {
    cubicIn: "0.32,0,0.67,0",
    cubicOut: "0.33,1,0.68,1",
    cubicInOut: "0.65,0,0.35,1",
    quadraticIn: "0.11,0,0.5,0",
    quadraticOut: "0.5,1,0.89,1",
    quadraticInOut: "0.45,0,0.55,1",
    quarticIn: "0.5,0,0.75,0",
    quarticOut: "0.25,1,0.5,1",
    quarticInOut: "0.76,0,0.24,1",
    quinticIn: "0.64,0,0.78,0",
    quinticOut: "0.22,1,0.36,1",
    quinticInOut: "0.83,0,0.17,1",
    sinusoidalIn: "0.12,0,0.39,0",
    sinusoidalOut: "0.61,1,0.88,1",
    sinusoidalInOut: "0.37,0,0.63,1",
    exponentialIn: "0.7,0,0.84,0",
    exponentialOut: "0.16,1,0.3,1",
    exponentialInOut: "0.87,0,0.13,1",
    circularIn: "0.55,0,1,0.45",
    circularOut: "0,0.55,0.45,1",
    circularInOut: "0.85,0,0.15,1"
  }, Jo = "transform-origin";
  function Aq(r, e, t) {
    var n = H({}, r.shape);
    H(n, e), r.buildPath(t, n);
    var i = new DN();
    return i.reset(pR(r)), t.rebuildPath(i, 1), i.generateStr(), i.getStr();
  }
  function Iq(r, e) {
    var t = e.originX, n = e.originY;
    (t || n) && (r[Jo] = t + "px " + n + "px");
  }
  var Mq = {
    fill: "fill",
    opacity: "opacity",
    lineWidth: "stroke-width",
    lineDashOffset: "stroke-dashoffset"
  };
  function EN(r, e) {
    var t = e.zrId + "-ani-" + e.cssAnimIdx++;
    return e.cssAnims[t] = r, t;
  }
  function Dq(r, e, t) {
    var n = r.shape.paths, i = {}, a, o;
    if (D(n, function(l) {
      var u = o_(t.zrId);
      u.animation = true, Sg(l, {}, u, true);
      var c = u.cssAnims, h = u.cssNodes, f = je(c), d = f.length;
      if (d) {
        o = f[d - 1];
        var p = c[o];
        for (var v in p) {
          var g = p[v];
          i[v] = i[v] || {
            d: ""
          }, i[v].d += g.d || "";
        }
        for (var m in h) {
          var y = h[m].animation;
          y.indexOf(o) >= 0 && (a = y);
        }
      }
    }), !!a) {
      e.d = false;
      var s = EN(i, t);
      return a.replace(o, s);
    }
  }
  function VT(r) {
    return ee(r) ? zT[r] ? "cubic-bezier(" + zT[r] + ")" : Jb(r) ? r : "" : "";
  }
  function Sg(r, e, t, n) {
    var i = r.animators, a = i.length, o = [];
    if (r instanceof p1) {
      var s = Dq(r, e, t);
      if (s) o.push(s);
      else if (!a) return;
    } else if (!a) return;
    for (var l = {}, u = 0; u < a; u++) {
      var c = i[u], h = [
        c.getMaxTime() / 1e3 + "s"
      ], f = VT(c.getClip().easing), d = c.getDelay();
      f ? h.push(f) : h.push("linear"), d && h.push(d / 1e3 + "s"), c.getLoop() && h.push("infinite");
      var p = h.join(" ");
      l[p] = l[p] || [
        p,
        []
      ], l[p][1].push(c);
    }
    function v(y) {
      var x = y[1], _ = x.length, S = {}, b = {}, w = {}, C = "animation-timing-function";
      function T(re, J, le) {
        for (var te = re.getTracks(), he = re.getMaxTime(), Xe = 0; Xe < te.length; Xe++) {
          var Fe = te[Xe];
          if (Fe.needsAnimate()) {
            var fe = Fe.keyframes, Se = Fe.propName;
            if (le && (Se = le(Se)), Se) for (var Lt = 0; Lt < fe.length; Lt++) {
              var z = fe[Lt], $ = Math.round(z.time / he * 100) + "%", j = VT(z.easing), Te = z.rawValue;
              (ee(Te) || nt(Te)) && (J[$] = J[$] || {}, J[$][Se] = z.rawValue, j && (J[$][C] = j));
            }
          }
        }
      }
      for (var A = 0; A < _; A++) {
        var M = x[A], E = M.targetName;
        E ? E === "shape" && T(M, b) : !n && T(M, S);
      }
      for (var k in S) {
        var R = {};
        xR(R, r), H(R, S[k]);
        var N = vR(R), I = S[k][C];
        w[k] = N ? {
          transform: N
        } : {}, Iq(w[k], R), I && (w[k][C] = I);
      }
      var L, P = true;
      for (var k in b) {
        w[k] = w[k] || {};
        var O = !L, I = b[k][C];
        O && (L = new $i());
        var F = L.len();
        L.reset(), w[k].d = Aq(r, b[k], L);
        var B = L.len();
        if (!O && F !== B) {
          P = false;
          break;
        }
        I && (w[k][C] = I);
      }
      if (!P) for (var k in w) delete w[k].d;
      if (!n) for (var A = 0; A < _; A++) {
        var M = x[A], E = M.targetName;
        E === "style" && T(M, w, function(te) {
          return Mq[te];
        });
      }
      for (var V = je(w), U = true, Y, A = 1; A < V.length; A++) {
        var q = V[A - 1], me = V[A];
        if (w[q][Jo] !== w[me][Jo]) {
          U = false;
          break;
        }
        Y = w[q][Jo];
      }
      if (U && Y) {
        for (var k in w) w[k][Jo] && delete w[k][Jo];
        e[Jo] = Y;
      }
      if (ct(V, function(re) {
        return je(w[re]).length > 0;
      }).length) {
        var Me = EN(w, t);
        return Me + " " + y[0] + " both";
      }
    }
    for (var g in l) {
      var s = v(l[g]);
      s && o.push(s);
    }
    if (o.length) {
      var m = t.zrId + "-cls-" + RN();
      t.cssNodes["." + m] = {
        animation: o.join(",")
      }, e.class = m;
    }
  }
  function Pq(r, e, t) {
    if (!r.ignore) if (r.isSilent()) {
      var n = {
        "pointer-events": "none"
      };
      $T(n, e, t);
    } else {
      var i = r.states.emphasis && r.states.emphasis.style ? r.states.emphasis.style : {}, a = i.fill;
      if (!a) {
        var o = r.style && r.style.fill, s = r.states.select && r.states.select.style && r.states.select.style.fill, l = r.currentStates.indexOf("select") >= 0 && s || o;
        l && (a = mx(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && r.transform ? r.transform[0] : 1;
        u = u / c;
      }
      var n = {
        cursor: "pointer"
      };
      a && (n.fill = a), i.stroke && (n.stroke = i.stroke), u && (n["stroke-width"] = u), $T(n, e, t);
    }
  }
  function $T(r, e, t, n) {
    var i = JSON.stringify(r), a = t.cssStyleCache[i];
    a || (a = t.zrId + "-cls-" + RN(), t.cssStyleCache[i] = a, t.cssNodes["." + a + ":hover"] = r), e.class = e.class ? e.class + " " + a : a;
  }
  var Oh = Math.round;
  function NN(r) {
    return r && ee(r.src);
  }
  function ON(r) {
    return r && ge(r.toDataURL);
  }
  function K1(r, e, t, n) {
    xq(function(i, a) {
      var o = i === "fill" || i === "stroke";
      o && dR(a) ? BN(e, r, i, n) : o && e1(a) ? zN(t, r, i, n) : r[i] = a, o && n.ssr && a === "none" && (r["pointer-events"] = "visible");
    }, e, t, false), Fq(t, r, n);
  }
  function Z1(r, e) {
    var t = AH(e);
    t && (t.each(function(n, i) {
      n != null && (r[(FT + i).toLowerCase()] = n + "");
    }), e.isSilent() && (r[FT + "silent"] = "true"));
  }
  function GT(r) {
    return Za(r[0] - 1) && Za(r[1]) && Za(r[2]) && Za(r[3] - 1);
  }
  function kq(r) {
    return Za(r[4]) && Za(r[5]);
  }
  function j1(r, e, t) {
    if (e && !(kq(e) && GT(e))) {
      var n = 1e4;
      r.transform = GT(e) ? "translate(" + Oh(e[4] * n) / n + " " + Oh(e[5] * n) / n + ")" : qU(e);
    }
  }
  function WT(r, e, t) {
    for (var n = r.points, i = [], a = 0; a < n.length; a++) i.push(Oh(n[a][0] * t) / t), i.push(Oh(n[a][1] * t) / t);
    e.points = i.join(" ");
  }
  function UT(r) {
    return !r.smooth;
  }
  function Lq(r) {
    var e = K(r, function(t) {
      return typeof t == "string" ? [
        t,
        t
      ] : t;
    });
    return function(t, n, i) {
      for (var a = 0; a < e.length; a++) {
        var o = e[a], s = t[o[0]];
        s != null && (n[o[1]] = Oh(s * i) / i);
      }
    };
  }
  var Rq = {
    circle: [
      Lq([
        "cx",
        "cy",
        "r"
      ])
    ],
    polyline: [
      WT,
      UT
    ],
    polygon: [
      WT,
      UT
    ]
  };
  function Eq(r) {
    for (var e = r.animators, t = 0; t < e.length; t++) if (e[t].targetName === "shape") return true;
    return false;
  }
  function FN(r, e) {
    var t = r.style, n = r.shape, i = Rq[r.type], a = {}, o = e.animation, s = "path", l = r.style.strokePercent, u = e.compress && pR(r) || 4;
    if (i && !e.willUpdate && !(i[1] && !i[1](n)) && !(o && Eq(r)) && !(l < 1)) {
      s = r.type;
      var c = Math.pow(10, u);
      i[0](n, a, c);
    } else {
      var h = !r.path || r.shapeChanged();
      r.path || r.createPathProxy();
      var f = r.path;
      h && (f.beginPath(), r.buildPath(f, r.shape), r.pathUpdated());
      var d = f.getVersion(), p = r, v = p.__svgPathBuilder;
      (p.__svgPathVersion !== d || !v || l !== p.__svgPathStrokePercent) && (v || (v = p.__svgPathBuilder = new DN()), v.reset(u), f.rebuildPath(v, l), v.generateStr(), p.__svgPathVersion = d, p.__svgPathStrokePercent = l), a.d = v.getStr();
    }
    return j1(a, r.transform), K1(a, t, r, e), Z1(a, r), e.animation && Sg(r, a, e), e.emphasis && Pq(r, a, e), ar(s, r.id + "", a);
  }
  function Nq(r, e) {
    var t = r.style, n = t.image;
    if (n && !ee(n) && (NN(n) ? n = n.src : ON(n) && (n = n.toDataURL())), !!n) {
      var i = t.x || 0, a = t.y || 0, o = t.width, s = t.height, l = {
        href: n,
        width: o,
        height: s
      };
      return i && (l.x = i), a && (l.y = a), j1(l, r.transform), K1(l, t, r, e), Z1(l, r), e.animation && Sg(r, l, e), ar("image", r.id + "", l);
    }
  }
  function Oq(r, e) {
    var t = r.style, n = t.text;
    if (n != null && (n += ""), !(!n || isNaN(t.x) || isNaN(t.y))) {
      var i = t.font || oo, a = t.x || 0, o = ZU(t.y || 0, qv(i), t.textBaseline), s = KU[t.textAlign] || t.textAlign, l = {
        "dominant-baseline": "central",
        "text-anchor": s
      };
      if (HR(t)) {
        var u = "", c = t.fontStyle, h = UR(t.fontSize);
        if (!parseFloat(h)) return;
        var f = t.fontFamily || WL, d = t.fontWeight;
        u += "font-size:" + h + ";font-family:" + f + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), d && d !== "normal" && (u += "font-weight:" + d + ";"), l.style = u;
      } else l.style = "font: " + i;
      return n.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), j1(l, r.transform), K1(l, t, r, e), Z1(l, r), e.animation && Sg(r, l, e), ar("text", r.id + "", l, void 0, n);
    }
  }
  function HT(r, e) {
    if (r instanceof Ue) return FN(r, e);
    if (r instanceof mr) return Nq(r, e);
    if (r instanceof lu) return Oq(r, e);
  }
  function Fq(r, e, t) {
    var n = r.style;
    if (jU(n)) {
      var i = QU(r), a = t.shadowCache, o = a[i];
      if (!o) {
        var s = r.getGlobalScale(), l = s[0], u = s[1];
        if (!l || !u) return;
        var c = n.shadowOffsetX || 0, h = n.shadowOffsetY || 0, f = n.shadowBlur, d = wh(n.shadowColor), p = d.opacity, v = d.color, g = f / 2 / l, m = f / 2 / u, y = g + " " + m;
        o = t.zrId + "-s" + t.shadowIdx++, t.defs[o] = ar("filter", o, {
          id: o,
          x: "-100%",
          y: "-100%",
          width: "300%",
          height: "300%"
        }, [
          ar("feDropShadow", "", {
            dx: c / l,
            dy: h / u,
            stdDeviation: y,
            "flood-color": v,
            "flood-opacity": p
          })
        ]), a[i] = o;
      }
      e.filter = Xv(o);
    }
  }
  function BN(r, e, t, n) {
    var i = r[t], a, o = {
      gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
    };
    if (hR(i)) a = "linearGradient", o.x1 = i.x, o.y1 = i.y, o.x2 = i.x2, o.y2 = i.y2;
    else if (fR(i)) a = "radialGradient", o.cx = Pe(i.x, 0.5), o.cy = Pe(i.y, 0.5), o.r = Pe(i.r, 0.5);
    else return;
    for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
      var h = yx(s[u].offset) * 100 + "%", f = s[u].color, d = wh(f), p = d.color, v = d.opacity, g = {
        offset: h
      };
      g["stop-color"] = p, v < 1 && (g["stop-opacity"] = v), l.push(ar("stop", u + "", g));
    }
    var m = ar(a, "", o, l), y = q1(m), x = n.gradientCache, _ = x[y];
    _ || (_ = n.zrId + "-g" + n.gradientIdx++, x[y] = _, o.id = _, n.defs[_] = ar(a, _, o, l)), e[t] = Xv(_);
  }
  function zN(r, e, t, n) {
    var i = r.style[t], a = r.getBoundingRect(), o = {}, s = i.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", h;
    if (cR(i)) {
      var f = i.imageWidth, d = i.imageHeight, p = void 0, v = i.image;
      if (ee(v) ? p = v : NN(v) ? p = v.src : ON(v) && (p = v.toDataURL()), typeof Image > "u") {
        var g = "Image width/height must been given explictly in svg-ssr renderer.";
        Yr(f, g), Yr(d, g);
      } else if (f == null || d == null) {
        var m = function(A, M) {
          if (A) {
            var E = A.elm, k = f || M.width, R = d || M.height;
            A.tag === "pattern" && (u ? (R = 1, k /= a.width) : c && (k = 1, R /= a.height)), A.attrs.width = k, A.attrs.height = R, E && (E.setAttribute("width", k), E.setAttribute("height", R));
          }
        }, y = o1(p, null, r, function(A) {
          l || m(b, A), m(h, A);
        });
        y && y.width && y.height && (f = f || y.width, d = d || y.height);
      }
      h = ar("image", "img", {
        href: p,
        width: f,
        height: d
      }), o.width = f, o.height = d;
    } else i.svgElement && (h = be(i.svgElement), o.width = i.svgWidth, o.height = i.svgHeight);
    if (h) {
      var x, _;
      l ? x = _ = 1 : u ? (_ = 1, x = o.width / a.width) : c ? (x = 1, _ = o.height / a.height) : o.patternUnits = "userSpaceOnUse", x != null && !isNaN(x) && (o.width = x), _ != null && !isNaN(_) && (o.height = _);
      var S = vR(i);
      S && (o.patternTransform = S);
      var b = ar("pattern", "", o, [
        h
      ]), w = q1(b), C = n.patternCache, T = C[w];
      T || (T = n.zrId + "-p" + n.patternIdx++, C[w] = T, o.id = T, b = n.defs[T] = ar("pattern", T, o, [
        h
      ])), e[t] = Xv(T);
    }
  }
  function Bq(r, e, t) {
    var n = t.clipPathCache, i = t.defs, a = n[r.id];
    if (!a) {
      a = t.zrId + "-c" + t.clipPathIdx++;
      var o = {
        id: a
      };
      n[r.id] = a, i[a] = ar("clipPath", a, o, [
        FN(r, t)
      ]);
    }
    e["clip-path"] = Xv(a);
  }
  function YT(r) {
    return document.createTextNode(r);
  }
  function hs(r, e, t) {
    r.insertBefore(e, t);
  }
  function XT(r, e) {
    r.removeChild(e);
  }
  function qT(r, e) {
    r.appendChild(e);
  }
  function VN(r) {
    return r.parentNode;
  }
  function $N(r) {
    return r.nextSibling;
  }
  function ay(r, e) {
    r.textContent = e;
  }
  var KT = 58, zq = 120, Vq = ar("", "");
  function s_(r) {
    return r === void 0;
  }
  function Ti(r) {
    return r !== void 0;
  }
  function $q(r, e, t) {
    for (var n = {}, i = e; i <= t; ++i) {
      var a = r[i].key;
      a !== void 0 && (n[a] = i);
    }
    return n;
  }
  function Oc(r, e) {
    var t = r.key === e.key, n = r.tag === e.tag;
    return n && t;
  }
  function Fh(r) {
    var e, t = r.children, n = r.tag;
    if (Ti(n)) {
      var i = r.elm = LN(n);
      if (Q1(Vq, r), X(t)) for (e = 0; e < t.length; ++e) {
        var a = t[e];
        a != null && qT(i, Fh(a));
      }
      else Ti(r.text) && !_e(r.text) && qT(i, YT(r.text));
    } else r.elm = YT(r.text);
    return r.elm;
  }
  function GN(r, e, t, n, i) {
    for (; n <= i; ++n) {
      var a = t[n];
      a != null && hs(r, Fh(a), e);
    }
  }
  function lv(r, e, t, n) {
    for (; t <= n; ++t) {
      var i = e[t];
      if (i != null) if (Ti(i.tag)) {
        var a = VN(i.elm);
        XT(a, i.elm);
      } else XT(r, i.elm);
    }
  }
  function Q1(r, e) {
    var t, n = e.elm, i = r && r.attrs || {}, a = e.attrs || {};
    if (i !== a) {
      for (t in a) {
        var o = a[t], s = i[t];
        s !== o && (o === true ? n.setAttribute(t, "") : o === false ? n.removeAttribute(t) : t === "style" ? n.style.cssText = o : t.charCodeAt(0) !== zq ? n.setAttribute(t, o) : t === "xmlns:xlink" || t === "xmlns" ? n.setAttributeNS(_q, t, o) : t.charCodeAt(3) === KT ? n.setAttributeNS(bq, t, o) : t.charCodeAt(5) === KT ? n.setAttributeNS(kN, t, o) : n.setAttribute(t, o));
      }
      for (t in i) t in a || n.removeAttribute(t);
    }
  }
  function Gq(r, e, t) {
    for (var n = 0, i = 0, a = e.length - 1, o = e[0], s = e[a], l = t.length - 1, u = t[0], c = t[l], h, f, d, p; n <= a && i <= l; ) o == null ? o = e[++n] : s == null ? s = e[--a] : u == null ? u = t[++i] : c == null ? c = t[--l] : Oc(o, u) ? (zl(o, u), o = e[++n], u = t[++i]) : Oc(s, c) ? (zl(s, c), s = e[--a], c = t[--l]) : Oc(o, c) ? (zl(o, c), hs(r, o.elm, $N(s.elm)), o = e[++n], c = t[--l]) : Oc(s, u) ? (zl(s, u), hs(r, s.elm, o.elm), s = e[--a], u = t[++i]) : (s_(h) && (h = $q(e, n, a)), f = h[u.key], s_(f) ? hs(r, Fh(u), o.elm) : (d = e[f], d.tag !== u.tag ? hs(r, Fh(u), o.elm) : (zl(d, u), e[f] = void 0, hs(r, d.elm, o.elm))), u = t[++i]);
    (n <= a || i <= l) && (n > a ? (p = t[l + 1] == null ? null : t[l + 1].elm, GN(r, p, t, i, l)) : lv(r, e, n, a));
  }
  function zl(r, e) {
    var t = e.elm = r.elm, n = r.children, i = e.children;
    r !== e && (Q1(r, e), s_(e.text) ? Ti(n) && Ti(i) ? n !== i && Gq(t, n, i) : Ti(i) ? (Ti(r.text) && ay(t, ""), GN(t, null, i, 0, i.length - 1)) : Ti(n) ? lv(t, n, 0, n.length - 1) : Ti(r.text) && ay(t, "") : r.text !== e.text && (Ti(n) && lv(t, n, 0, n.length - 1), ay(t, e.text)));
  }
  function Wq(r, e) {
    if (Oc(r, e)) zl(r, e);
    else {
      var t = r.elm, n = VN(t);
      Fh(e), n !== null && (hs(n, e.elm, $N(t)), lv(n, [
        r
      ], 0, 0));
    }
    return e;
  }
  var Uq = 0, Hq = function() {
    function r(e, t, n) {
      if (this.type = "svg", this.refreshHover = ZT(), this.configLayer = ZT(), this.storage = t, this._opts = n = H({}, n), this.root = e, this._id = "zr" + Uq++, this._oldVNode = BT(n.width, n.height), e && !n.ssr) {
        var i = this._viewport = document.createElement("div");
        i.style.cssText = "position:relative;overflow:hidden";
        var a = this._svgDom = this._oldVNode.elm = LN("svg");
        Q1(null, this._oldVNode), i.appendChild(a), e.appendChild(i);
      }
      this.resize(n.width, n.height);
    }
    return r.prototype.getType = function() {
      return this.type;
    }, r.prototype.getViewportRoot = function() {
      return this._viewport;
    }, r.prototype.getViewportRootOffset = function() {
      var e = this.getViewportRoot();
      if (e) return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
    }, r.prototype.getSvgDom = function() {
      return this._svgDom;
    }, r.prototype.refresh = function() {
      if (this.root) {
        var e = this.renderToVNode({
          willUpdate: true
        });
        e.attrs.style = "position:absolute;left:0;top:0;user-select:none", Wq(this._oldVNode, e), this._oldVNode = e;
      }
    }, r.prototype.renderOneToVNode = function(e) {
      return HT(e, o_(this._id));
    }, r.prototype.renderToVNode = function(e) {
      e = e || {};
      var t = this.storage.getDisplayList(true), n = this._width, i = this._height, a = o_(this._id);
      a.animation = e.animation, a.willUpdate = e.willUpdate, a.compress = e.compress, a.emphasis = e.emphasis, a.ssr = this._opts.ssr;
      var o = [], s = this._bgVNode = Yq(n, i, this._backgroundColor, a);
      s && o.push(s);
      var l = e.compress ? null : this._mainVNode = ar("g", "main", {}, []);
      this._paintList(t, a, l ? l.children : o), l && o.push(l);
      var u = K(je(a.defs), function(f) {
        return a.defs[f];
      });
      if (u.length && o.push(ar("defs", "defs", {}, u)), e.animation) {
        var c = Cq(a.cssNodes, a.cssAnims, {
          newline: true
        });
        if (c) {
          var h = ar("style", "stl", {}, [], c);
          o.push(h);
        }
      }
      return BT(n, i, o, e.useViewBox);
    }, r.prototype.renderToString = function(e) {
      return e = e || {}, q1(this.renderToVNode({
        animation: Pe(e.cssAnimation, true),
        emphasis: Pe(e.cssEmphasis, true),
        willUpdate: false,
        compress: true,
        useViewBox: Pe(e.useViewBox, true)
      }), {
        newline: true
      });
    }, r.prototype.setBackgroundColor = function(e) {
      this._backgroundColor = e;
    }, r.prototype.getSvgRoot = function() {
      return this._mainVNode && this._mainVNode.elm;
    }, r.prototype._paintList = function(e, t, n) {
      for (var i = e.length, a = [], o = 0, s, l, u = 0, c = 0; c < i; c++) {
        var h = e[c];
        if (!h.invisible) {
          var f = h.__clipPaths, d = f && f.length || 0, p = l && l.length || 0, v = void 0;
          for (v = Math.max(d - 1, p - 1); v >= 0 && !(f && l && f[v] === l[v]); v--) ;
          for (var g = p - 1; g > v; g--) o--, s = a[o - 1];
          for (var m = v + 1; m < d; m++) {
            var y = {};
            Bq(f[m], y, t);
            var x = ar("g", "clip-g-" + u++, y, []);
            (s ? s.children : n).push(x), a[o++] = x, s = x;
          }
          l = f;
          var _ = HT(h, t);
          _ && (s ? s.children : n).push(_);
        }
      }
    }, r.prototype.resize = function(e, t) {
      var n = this._opts, i = this.root, a = this._viewport;
      if (e != null && (n.width = e), t != null && (n.height = t), i && a && (a.style.display = "none", e = Kl(i, 0, n), t = Kl(i, 1, n), a.style.display = ""), this._width !== e || this._height !== t) {
        if (this._width = e, this._height = t, a) {
          var o = a.style;
          o.width = e + "px", o.height = t + "px";
        }
        if (e1(this._backgroundColor)) this.refresh();
        else {
          var s = this._svgDom;
          s && (s.setAttribute("width", e), s.setAttribute("height", t));
          var l = this._bgVNode && this._bgVNode.elm;
          l && (l.setAttribute("width", e), l.setAttribute("height", t));
        }
      }
    }, r.prototype.getWidth = function() {
      return this._width;
    }, r.prototype.getHeight = function() {
      return this._height;
    }, r.prototype.dispose = function() {
      this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
    }, r.prototype.clear = function() {
      this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
    }, r.prototype.toDataURL = function(e) {
      var t = this.renderToString(), n = "data:image/svg+xml;";
      return e ? (t = eH(t), t && n + "base64," + t) : n + "charset=UTF-8," + encodeURIComponent(t);
    }, r;
  }();
  function ZT(r) {
    return function() {
    };
  }
  function Yq(r, e, t, n) {
    var i;
    if (t && t !== "none") if (i = ar("rect", "bg", {
      width: r,
      height: e,
      x: "0",
      y: "0"
    }), dR(t)) BN({
      fill: t
    }, i.attrs, "fill", n);
    else if (e1(t)) zN({
      style: {
        fill: t
      },
      dirty: Wt,
      getBoundingRect: function() {
        return {
          width: r,
          height: e
        };
      }
    }, i.attrs, "fill", n);
    else {
      var a = wh(t), o = a.color, s = a.opacity;
      i.attrs.fill = o, s < 1 && (i.attrs["fill-opacity"] = s);
    }
    return i;
  }
  function Xq(r) {
    r.registerPainter("svg", Hq);
  }
  function jT(r, e, t) {
    var n = so.createCanvas(), i = e.getWidth(), a = e.getHeight(), o = n.style;
    return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = i + "px", o.height = a + "px", n.setAttribute("data-zr-dom-id", r)), n.width = i * t, n.height = a * t, n;
  }
  var oy = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      a.motionBlur = false, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = false, a.config = {}, a.incremental = false, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = true, a.__firstTimePaint = true, a.__used = false, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
      var o;
      i = i || $p, typeof t == "string" ? o = jT(t, n, i) : _e(t) && (o = t, t = o.id), a.id = t, a.dom = o;
      var s = o.style;
      return s && (KL(o), o.onselectstart = function() {
        return false;
      }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = n, a.dpr = i, a;
    }
    return e.prototype.getElementCount = function() {
      return this.__endIndex - this.__startIndex;
    }, e.prototype.afterBrush = function() {
      this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
    }, e.prototype.initContext = function() {
      this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
    }, e.prototype.setUnpainted = function() {
      this.__firstTimePaint = true;
    }, e.prototype.createBackBuffer = function() {
      var t = this.dpr;
      this.domBack = jT("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t);
    }, e.prototype.createRepaintRects = function(t, n, i, a) {
      if (this.__firstTimePaint) return this.__firstTimePaint = false, null;
      var o = [], s = this.maxRepaintRectCount, l = false, u = new Oe(0, 0, 0, 0);
      function c(y) {
        if (!(!y.isFinite() || y.isZero())) if (o.length === 0) {
          var x = new Oe(0, 0, 0, 0);
          x.copy(y), o.push(x);
        } else {
          for (var _ = false, S = 1 / 0, b = 0, w = 0; w < o.length; ++w) {
            var C = o[w];
            if (C.intersect(y)) {
              var T = new Oe(0, 0, 0, 0);
              T.copy(C), T.union(y), o[w] = T, _ = true;
              break;
            } else if (l) {
              u.copy(y), u.union(C);
              var A = y.width * y.height, M = C.width * C.height, E = u.width * u.height, k = E - A - M;
              k < S && (S = k, b = w);
            }
          }
          if (l && (o[b].union(y), _ = true), !_) {
            var x = new Oe(0, 0, 0, 0);
            x.copy(y), o.push(x);
          }
          l || (l = o.length >= s);
        }
      }
      for (var h = this.__startIndex; h < this.__endIndex; ++h) {
        var f = t[h];
        if (f) {
          var d = f.shouldBePainted(i, a, true, true), p = f.__isRendered && (f.__dirty & Ri || !d) ? f.getPrevPaintRect() : null;
          p && c(p);
          var v = d && (f.__dirty & Ri || !f.__isRendered) ? f.getPaintRect() : null;
          v && c(v);
        }
      }
      for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
        var f = n[h], d = f && f.shouldBePainted(i, a, true, true);
        if (f && (!d || !f.__zr) && f.__isRendered) {
          var p = f.getPrevPaintRect();
          p && c(p);
        }
      }
      var g;
      do {
        g = false;
        for (var h = 0; h < o.length; ) {
          if (o[h].isZero()) {
            o.splice(h, 1);
            continue;
          }
          for (var m = h + 1; m < o.length; ) o[h].intersect(o[m]) ? (g = true, o[h].union(o[m]), o.splice(m, 1)) : m++;
          h++;
        }
      } while (g);
      return this._paintRects = o, o;
    }, e.prototype.debugGetPaintRects = function() {
      return (this._paintRects || []).slice();
    }, e.prototype.resize = function(t, n) {
      var i = this.dpr, a = this.dom, o = a.style, s = this.domBack;
      o && (o.width = t + "px", o.height = n + "px"), a.width = t * i, a.height = n * i, s && (s.width = t * i, s.height = n * i, i !== 1 && this.ctxBack.scale(i, i));
    }, e.prototype.clear = function(t, n, i) {
      var a = this.dom, o = this.ctx, s = a.width, l = a.height;
      n = n || this.clearColor;
      var u = this.motionBlur && !t, c = this.lastFrameAlpha, h = this.dpr, f = this;
      u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / h, l / h));
      var d = this.domBack;
      function p(v, g, m, y) {
        if (o.clearRect(v, g, m, y), n && n !== "transparent") {
          var x = void 0;
          if (Uv(n)) {
            var _ = n.global || n.__width === m && n.__height === y;
            x = _ && n.__canvasGradient || jx(o, n, {
              x: 0,
              y: 0,
              width: m,
              height: y
            }), n.__canvasGradient = x, n.__width = m, n.__height = y;
          } else sU(n) && (n.scaleX = n.scaleX || h, n.scaleY = n.scaleY || h, x = Qx(o, n, {
            dirty: function() {
              f.setUnpainted(), f.painter.refresh();
            }
          }));
          o.save(), o.fillStyle = x || n, o.fillRect(v, g, m, y), o.restore();
        }
        u && (o.save(), o.globalAlpha = c, o.drawImage(d, v, g, m, y), o.restore());
      }
      !i || u ? p(0, 0, s, l) : i.length && D(i, function(v) {
        p(v.x * h, v.y * h, v.width * h, v.height * h);
      });
    }, e;
  }(Vn), QT = 1e5, Xo = 314159, xd = 0.01, qq = 1e-3;
  function Kq(r) {
    return r ? r.__builtin__ ? true : !(typeof r.resize != "function" || typeof r.refresh != "function") : false;
  }
  function Zq(r, e) {
    var t = document.createElement("div");
    return t.style.cssText = [
      "position:relative",
      "width:" + r + "px",
      "height:" + e + "px",
      "padding:0",
      "margin:0",
      "border-width:0"
    ].join(";") + ";", t;
  }
  var jq = function() {
    function r(e, t, n, i) {
      this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = false, this.type = "canvas";
      var a = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
      this._opts = n = H({}, n || {}), this.dpr = n.devicePixelRatio || $p, this._singleCanvas = a, this.root = e;
      var o = e.style;
      o && (KL(e), e.innerHTML = ""), this.storage = t;
      var s = this._zlevelList;
      this._prevDisplayList = [];
      var l = this._layers;
      if (a) {
        var c = e, h = c.width, f = c.height;
        n.width != null && (h = n.width), n.height != null && (f = n.height), this.dpr = n.devicePixelRatio || 1, c.width = h * this.dpr, c.height = f * this.dpr, this._width = h, this._height = f;
        var d = new oy(c, this, this.dpr);
        d.__builtin__ = true, d.initContext(), l[Xo] = d, d.zlevel = Xo, s.push(Xo), this._domRoot = e;
      } else {
        this._width = Kl(e, 0, n), this._height = Kl(e, 1, n);
        var u = this._domRoot = Zq(this._width, this._height);
        e.appendChild(u);
      }
    }
    return r.prototype.getType = function() {
      return "canvas";
    }, r.prototype.isSingleCanvas = function() {
      return this._singleCanvas;
    }, r.prototype.getViewportRoot = function() {
      return this._domRoot;
    }, r.prototype.getViewportRootOffset = function() {
      var e = this.getViewportRoot();
      if (e) return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
    }, r.prototype.refresh = function(e) {
      var t = this.storage.getDisplayList(true), n = this._prevDisplayList, i = this._zlevelList;
      this._redrawId = Math.random(), this._paintList(t, n, e, this._redrawId);
      for (var a = 0; a < i.length; a++) {
        var o = i[a], s = this._layers[o];
        if (!s.__builtin__ && s.refresh) {
          var l = a === 0 ? this._backgroundColor : null;
          s.refresh(l);
        }
      }
      return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this;
    }, r.prototype.refreshHover = function() {
      this._paintHoverList(this.storage.getDisplayList(false));
    }, r.prototype._paintHoverList = function(e) {
      var t = e.length, n = this._hoverlayer;
      if (n && n.clear(), !!t) {
        for (var i = {
          inHover: true,
          viewWidth: this._width,
          viewHeight: this._height
        }, a, o = 0; o < t; o++) {
          var s = e[o];
          s.__inHover && (n || (n = this._hoverlayer = this.getLayer(QT)), a || (a = n.ctx, a.save()), bs(a, s, i, o === t - 1));
        }
        a && a.restore();
      }
    }, r.prototype.getHoverLayer = function() {
      return this.getLayer(QT);
    }, r.prototype.paintOne = function(e, t) {
      A3(e, t);
    }, r.prototype._paintList = function(e, t, n, i) {
      if (this._redrawId === i) {
        n = n || false, this._updateLayerStatus(e);
        var a = this._doPaintList(e, t, n), o = a.finished, s = a.needsRefreshHover;
        if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), o) this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
        else {
          var l = this;
          Op(function() {
            l._paintList(e, t, n, i);
          });
        }
      }
    }, r.prototype._compositeManually = function() {
      var e = this.getLayer(Xo).ctx, t = this._domRoot.width, n = this._domRoot.height;
      e.clearRect(0, 0, t, n), this.eachBuiltinLayer(function(i) {
        i.virtual && e.drawImage(i.dom, 0, 0, t, n);
      });
    }, r.prototype._doPaintList = function(e, t, n) {
      for (var i = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
        var l = this._zlevelList[s], u = this._layers[l];
        u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
      }
      for (var c = true, h = false, f = function(v) {
        var g = a[v], m = g.ctx, y = o && g.createRepaintRects(e, t, d._width, d._height), x = n ? g.__startIndex : g.__drawIndex, _ = !n && g.incremental && Date.now, S = _ && Date.now(), b = g.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
        if (g.__startIndex === g.__endIndex) g.clear(false, b, y);
        else if (x === g.__startIndex) {
          var w = e[x];
          (!w.incremental || !w.notClear || n) && g.clear(false, b, y);
        }
        x === -1 && (console.error("For some unknown reason. drawIndex is -1"), x = g.__startIndex);
        var C, T = function(k) {
          var R = {
            inHover: false,
            allClipped: false,
            prevEl: null,
            viewWidth: i._width,
            viewHeight: i._height
          };
          for (C = x; C < g.__endIndex; C++) {
            var N = e[C];
            if (N.__inHover && (h = true), i._doPaintEl(N, g, o, k, R, C === g.__endIndex - 1), _) {
              var I = Date.now() - S;
              if (I > 15) break;
            }
          }
          R.prevElClipPaths && m.restore();
        };
        if (y) if (y.length === 0) C = g.__endIndex;
        else for (var A = d.dpr, M = 0; M < y.length; ++M) {
          var E = y[M];
          m.save(), m.beginPath(), m.rect(E.x * A, E.y * A, E.width * A, E.height * A), m.clip(), T(E), m.restore();
        }
        else m.save(), T(), m.restore();
        g.__drawIndex = C, g.__drawIndex < g.__endIndex && (c = false);
      }, d = this, p = 0; p < a.length; p++) f(p);
      return He.wxa && D(this._layers, function(v) {
        v && v.ctx && v.ctx.draw && v.ctx.draw();
      }), {
        finished: c,
        needsRefreshHover: h
      };
    }, r.prototype._doPaintEl = function(e, t, n, i, a, o) {
      var s = t.ctx;
      if (n) {
        var l = e.getPaintRect();
        (!i || l && l.intersect(i)) && (bs(s, e, a, o), e.setPrevPaintRect(l));
      } else bs(s, e, a, o);
    }, r.prototype.getLayer = function(e, t) {
      this._singleCanvas && !this._needsManuallyCompositing && (e = Xo);
      var n = this._layers[e];
      return n || (n = new oy("zr_" + e, this, this.dpr), n.zlevel = e, n.__builtin__ = true, this._layerConfig[e] ? Ee(n, this._layerConfig[e], true) : this._layerConfig[e - xd] && Ee(n, this._layerConfig[e - xd], true), t && (n.virtual = t), this.insertLayer(e, n), n.initContext()), n;
    }, r.prototype.insertLayer = function(e, t) {
      var n = this._layers, i = this._zlevelList, a = i.length, o = this._domRoot, s = null, l = -1;
      if (!n[e] && Kq(t)) {
        if (a > 0 && e > i[0]) {
          for (l = 0; l < a - 1 && !(i[l] < e && i[l + 1] > e); l++) ;
          s = n[i[l]];
        }
        if (i.splice(l + 1, 0, e), n[e] = t, !t.virtual) if (s) {
          var u = s.dom;
          u.nextSibling ? o.insertBefore(t.dom, u.nextSibling) : o.appendChild(t.dom);
        } else o.firstChild ? o.insertBefore(t.dom, o.firstChild) : o.appendChild(t.dom);
        t.painter || (t.painter = this);
      }
    }, r.prototype.eachLayer = function(e, t) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i];
        e.call(t, this._layers[a], a);
      }
    }, r.prototype.eachBuiltinLayer = function(e, t) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i], o = this._layers[a];
        o.__builtin__ && e.call(t, o, a);
      }
    }, r.prototype.eachOtherLayer = function(e, t) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i], o = this._layers[a];
        o.__builtin__ || e.call(t, o, a);
      }
    }, r.prototype.getLayers = function() {
      return this._layers;
    }, r.prototype._updateLayerStatus = function(e) {
      this.eachBuiltinLayer(function(h, f) {
        h.__dirty = h.__used = false;
      });
      function t(h) {
        a && (a.__endIndex !== h && (a.__dirty = true), a.__endIndex = h);
      }
      if (this._singleCanvas) for (var n = 1; n < e.length; n++) {
        var i = e[n];
        if (i.zlevel !== e[n - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
      var a = null, o = 0, s, l;
      for (l = 0; l < e.length; l++) {
        var i = e[l], u = i.zlevel, c = void 0;
        s !== u && (s = u, o = 0), i.incremental ? (c = this.getLayer(u + qq, this._needsManuallyCompositing), c.incremental = true, o = 1) : c = this.getLayer(u + (o > 0 ? xd : 0), this._needsManuallyCompositing), c.__builtin__ || Yb("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = true, c.__startIndex !== l && (c.__dirty = true), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, t(l), a = c), i.__dirty & Ri && !i.__inHover && (c.__dirty = true, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
      }
      t(l), this.eachBuiltinLayer(function(h, f) {
        !h.__used && h.getElementCount() > 0 && (h.__dirty = true, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
      });
    }, r.prototype.clear = function() {
      return this.eachBuiltinLayer(this._clearLayer), this;
    }, r.prototype._clearLayer = function(e) {
      e.clear();
    }, r.prototype.setBackgroundColor = function(e) {
      this._backgroundColor = e, D(this._layers, function(t) {
        t.setUnpainted();
      });
    }, r.prototype.configLayer = function(e, t) {
      if (t) {
        var n = this._layerConfig;
        n[e] ? Ee(n[e], t, true) : n[e] = t;
        for (var i = 0; i < this._zlevelList.length; i++) {
          var a = this._zlevelList[i];
          if (a === e || a === e + xd) {
            var o = this._layers[a];
            Ee(o, n[e], true);
          }
        }
      }
    }, r.prototype.delLayer = function(e) {
      var t = this._layers, n = this._zlevelList, i = t[e];
      i && (i.dom.parentNode.removeChild(i.dom), delete t[e], n.splice(Be(n, e), 1));
    }, r.prototype.resize = function(e, t) {
      if (this._domRoot.style) {
        var n = this._domRoot;
        n.style.display = "none";
        var i = this._opts, a = this.root;
        if (e != null && (i.width = e), t != null && (i.height = t), e = Kl(a, 0, i), t = Kl(a, 1, i), n.style.display = "", this._width !== e || t !== this._height) {
          n.style.width = e + "px", n.style.height = t + "px";
          for (var o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(e, t);
          this.refresh(true);
        }
        this._width = e, this._height = t;
      } else {
        if (e == null || t == null) return;
        this._width = e, this._height = t, this.getLayer(Xo).resize(e, t);
      }
      return this;
    }, r.prototype.clearLayer = function(e) {
      var t = this._layers[e];
      t && t.clear();
    }, r.prototype.dispose = function() {
      this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
    }, r.prototype.getRenderedCanvas = function(e) {
      if (e = e || {}, this._singleCanvas && !this._compositeManually) return this._layers[Xo].dom;
      var t = new oy("image", this, e.pixelRatio || this.dpr);
      t.initContext(), t.clear(false, e.backgroundColor || this._backgroundColor);
      var n = t.ctx;
      if (e.pixelRatio <= this.dpr) {
        this.refresh();
        var i = t.dom.width, a = t.dom.height;
        this.eachLayer(function(h) {
          h.__builtin__ ? n.drawImage(h.dom, 0, 0, i, a) : h.renderToCanvas && (n.save(), h.renderToCanvas(n), n.restore());
        });
      } else for (var o = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(true), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        bs(n, c, o, l === u - 1);
      }
      return t.dom;
    }, r.prototype.getWidth = function() {
      return this._width;
    }, r.prototype.getHeight = function() {
      return this._height;
    }, r;
  }();
  function Qq(r) {
    r.registerPainter("canvas", jq);
  }
  var Jq = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.getInitialData = function(t) {
      return Aa(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getLegendIcon = function(t) {
      var n = new Ce(), i = Xt("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, false);
      n.add(i), i.setStyle(t.lineStyle);
      var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = t.itemHeight * 0.8, u = Xt(s, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill);
      n.add(u), u.setStyle(t.itemStyle);
      var c = t.iconRotate === "inherit" ? o : t.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([
        t.itemWidth / 2,
        t.itemHeight / 2
      ]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), n;
    }, e.type = "series.line", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = {
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      clip: true,
      label: {
        position: "top"
      },
      endLabel: {
        show: false,
        valueAnimation: true,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: true
      },
      step: false,
      smooth: false,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: true,
      showAllSymbol: "auto",
      connectNulls: false,
      sampling: "none",
      animationEasing: "linear",
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: false
    }, e;
  }(Tt);
  function du(r, e) {
    var t = r.mapDimensionsAll("defaultedLabel"), n = t.length;
    if (n === 1) {
      var i = cu(r, e, t[0]);
      return i != null ? i + "" : null;
    } else if (n) {
      for (var a = [], o = 0; o < t.length; o++) a.push(cu(r, e, t[o]));
      return a.join(" ");
    }
  }
  function WN(r, e) {
    var t = r.mapDimensionsAll("defaultedLabel");
    if (!X(e)) return e + "";
    for (var n = [], i = 0; i < t.length; i++) {
      var a = r.getDimensionIndex(t[i]);
      a >= 0 && n.push(e[a]);
    }
    return n.join(" ");
  }
  var Af = function(r) {
    G(e, r);
    function e(t, n, i, a) {
      var o = r.call(this) || this;
      return o.updateData(t, n, i, a), o;
    }
    return e.prototype._createSymbol = function(t, n, i, a, o) {
      this.removeAll();
      var s = Xt(t, -1, -1, 2, 2, null, o);
      s.attr({
        z2: 100,
        culling: true,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), s.drift = eK, this._symbolType = t, this.add(s);
    }, e.prototype.stopSymbolAnimation = function(t) {
      this.childAt(0).stopAnimation(null, t);
    }, e.prototype.getSymbolType = function() {
      return this._symbolType;
    }, e.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, e.prototype.highlight = function() {
      ga(this.childAt(0));
    }, e.prototype.downplay = function() {
      ma(this.childAt(0));
    }, e.prototype.setZ = function(t, n) {
      var i = this.childAt(0);
      i.zlevel = t, i.z = n;
    }, e.prototype.setDraggable = function(t, n) {
      var i = this.childAt(0);
      i.draggable = t, i.cursor = !n && t ? "move" : i.cursor;
    }, e.prototype.updateData = function(t, n, i, a) {
      this.silent = false;
      var o = t.getItemVisual(n, "symbol") || "circle", s = t.hostModel, l = e.getSymbolSize(t, n), u = o !== this._symbolType, c = a && a.disableAnimation;
      if (u) {
        var h = t.getItemVisual(n, "symbolKeepAspect");
        this._createSymbol(o, t, n, l, h);
      } else {
        var f = this.childAt(0);
        f.silent = false;
        var d = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? f.attr(d) : it(f, d, s, n), li(f);
      }
      if (this._updateCommon(t, n, l, i, a), u) {
        var f = this.childAt(0);
        if (!c) {
          var d = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              opacity: f.style.opacity
            }
          };
          f.scaleX = f.scaleY = 0, f.style.opacity = 0, kt(f, d, s, n);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, e.prototype._updateCommon = function(t, n, i, a, o) {
      var s = this.childAt(0), l = t.hostModel, u, c, h, f, d, p, v, g, m;
      if (a && (u = a.emphasisItemStyle, c = a.blurItemStyle, h = a.selectItemStyle, f = a.focus, d = a.blurScope, v = a.labelStatesModels, g = a.hoverScale, m = a.cursorStyle, p = a.emphasisDisabled), !a || t.hasItemOption) {
        var y = a && a.itemModel ? a.itemModel : t.getItemModel(n), x = y.getModel("emphasis");
        u = x.getModel("itemStyle").getItemStyle(), h = y.getModel([
          "select",
          "itemStyle"
        ]).getItemStyle(), c = y.getModel([
          "blur",
          "itemStyle"
        ]).getItemStyle(), f = x.get("focus"), d = x.get("blurScope"), p = x.get("disabled"), v = lr(y), g = x.getShallow("scale"), m = y.getShallow("cursor");
      }
      var _ = t.getItemVisual(n, "symbolRotate");
      s.attr("rotation", (_ || 0) * Math.PI / 180 || 0);
      var S = js(t.getItemVisual(n, "symbolOffset"), i);
      S && (s.x = S[0], s.y = S[1]), m && s.attr("cursor", m);
      var b = t.getItemVisual(n, "style"), w = b.fill;
      if (s instanceof mr) {
        var C = s.style;
        s.useStyle(H({
          image: C.image,
          x: C.x,
          y: C.y,
          width: C.width,
          height: C.height
        }, b));
      } else s.__isEmptyBrush ? s.useStyle(H({}, b)) : s.useStyle(b), s.style.decal = null, s.setColor(w, o && o.symbolInnerColor), s.style.strokeNoScale = true;
      var T = t.getItemVisual(n, "liftZ"), A = this._z2;
      T != null ? A == null && (this._z2 = s.z2, s.z2 += T) : A != null && (s.z2 = A, this._z2 = null);
      var M = o && o.useNameLabel;
      Sr(s, v, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: E,
        inheritColor: w,
        defaultOpacity: b.opacity
      });
      function E(N) {
        return M ? t.getName(N) : du(t, N);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var k = s.ensureState("emphasis");
      k.style = u, s.ensureState("select").style = h, s.ensureState("blur").style = c;
      var R = g == null || g === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(g) && g > 0 ? +g : 1;
      k.scaleX = this._sizeX * R, k.scaleY = this._sizeY * R, this.setSymbolScale(1), Nt(this, f, d, p);
    }, e.prototype.setSymbolScale = function(t) {
      this.scaleX = this.scaleY = t;
    }, e.prototype.fadeOut = function(t, n, i) {
      var a = this.childAt(0), o = De(this).dataIndex, s = i && i.animation;
      if (this.silent = a.silent = true, i && i.fadeLabel) {
        var l = a.getTextContent();
        l && uo(l, {
          style: {
            opacity: 0
          }
        }, n, {
          dataIndex: o,
          removeOpt: s,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else a.removeTextContent();
      uo(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, n, {
        dataIndex: o,
        cb: t,
        removeOpt: s
      });
    }, e.getSymbolSize = function(t, n) {
      return $u(t.getItemVisual(n, "symbolSize"));
    }, e;
  }(Ce);
  function eK(r, e) {
    this.parent.drift(r, e);
  }
  function sy(r, e, t, n) {
    return e && !isNaN(e[0]) && !isNaN(e[1]) && !(n.isIgnore && n.isIgnore(t)) && !(n.clipShape && !n.clipShape.contain(e[0], e[1])) && r.getItemVisual(t, "symbol") !== "none";
  }
  function JT(r) {
    return r != null && !_e(r) && (r = {
      isIgnore: r
    }), r || {};
  }
  function eA(r) {
    var e = r.hostModel, t = e.getModel("emphasis");
    return {
      emphasisItemStyle: t.getModel("itemStyle").getItemStyle(),
      blurItemStyle: e.getModel([
        "blur",
        "itemStyle"
      ]).getItemStyle(),
      selectItemStyle: e.getModel([
        "select",
        "itemStyle"
      ]).getItemStyle(),
      focus: t.get("focus"),
      blurScope: t.get("blurScope"),
      emphasisDisabled: t.get("disabled"),
      hoverScale: t.get("scale"),
      labelStatesModels: lr(e),
      cursorStyle: e.get("cursor")
    };
  }
  var If = function() {
    function r(e) {
      this.group = new Ce(), this._SymbolCtor = e || Af;
    }
    return r.prototype.updateData = function(e, t) {
      this._progressiveEls = null, t = JT(t);
      var n = this.group, i = e.hostModel, a = this._data, o = this._SymbolCtor, s = t.disableAnimation, l = eA(e), u = {
        disableAnimation: s
      }, c = t.getSymbolPoint || function(h) {
        return e.getItemLayout(h);
      };
      a || n.removeAll(), e.diff(a).add(function(h) {
        var f = c(h);
        if (sy(e, f, h, t)) {
          var d = new o(e, h, l, u);
          d.setPosition(f), e.setItemGraphicEl(h, d), n.add(d);
        }
      }).update(function(h, f) {
        var d = a.getItemGraphicEl(f), p = c(h);
        if (!sy(e, p, h, t)) {
          n.remove(d);
          return;
        }
        var v = e.getItemVisual(h, "symbol") || "circle", g = d && d.getSymbolType && d.getSymbolType();
        if (!d || g && g !== v) n.remove(d), d = new o(e, h, l, u), d.setPosition(p);
        else {
          d.updateData(e, h, l, u);
          var m = {
            x: p[0],
            y: p[1]
          };
          s ? d.attr(m) : it(d, m, i);
        }
        n.add(d), e.setItemGraphicEl(h, d);
      }).remove(function(h) {
        var f = a.getItemGraphicEl(h);
        f && f.fadeOut(function() {
          n.remove(f);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = e;
    }, r.prototype.updateLayout = function() {
      var e = this, t = this._data;
      t && t.eachItemGraphicEl(function(n, i) {
        var a = e._getSymbolPoint(i);
        n.setPosition(a), n.markRedraw();
      });
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = eA(e), this._data = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(e, t, n) {
      this._progressiveEls = [], n = JT(n);
      function i(l) {
        l.isGroup || (l.incremental = true, l.ensureState("emphasis").hoverLayer = true);
      }
      for (var a = e.start; a < e.end; a++) {
        var o = t.getItemLayout(a);
        if (sy(t, o, a, n)) {
          var s = new this._SymbolCtor(t, a, this._seriesScope);
          s.traverse(i), s.setPosition(o), this.group.add(s), t.setItemGraphicEl(a, s), this._progressiveEls.push(s);
        }
      }
    }, r.prototype.eachRendered = function(e) {
      mo(this._progressiveEls || this.group, e);
    }, r.prototype.remove = function(e) {
      var t = this.group, n = this._data;
      n && e ? n.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          t.remove(i);
        }, n.hostModel);
      }) : t.removeAll();
    }, r;
  }();
  function UN(r, e, t) {
    var n = r.getBaseAxis(), i = r.getOtherAxis(n), a = tK(i, t), o = n.dim, s = i.dim, l = e.mapDimension(s), u = e.mapDimension(o), c = s === "x" || s === "radius" ? 1 : 0, h = K(r.dimensions, function(p) {
      return e.mapDimension(p);
    }), f = false, d = e.getCalculationInfo("stackResultDimension");
    return ho(e, h[0]) && (f = true, h[0] = d), ho(e, h[1]) && (f = true, h[1] = d), {
      dataDimsForPoint: h,
      valueStart: a,
      valueAxisDim: s,
      baseAxisDim: o,
      stacked: !!f,
      valueDim: l,
      baseDim: u,
      baseDataOffset: c,
      stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
    };
  }
  function tK(r, e) {
    var t = 0, n = r.scale.getExtent();
    return e === "start" ? t = n[0] : e === "end" ? t = n[1] : nt(e) && !isNaN(e) ? t = e : n[0] > 0 ? t = n[0] : n[1] < 0 && (t = n[1]), t;
  }
  function HN(r, e, t, n) {
    var i = NaN;
    r.stacked && (i = t.get(t.getCalculationInfo("stackedOverDimension"), n)), isNaN(i) && (i = r.valueStart);
    var a = r.baseDataOffset, o = [];
    return o[a] = t.get(r.baseDim, n), o[1 - a] = i, e.dataToPoint(o);
  }
  function rK(r, e) {
    var t = [];
    return e.diff(r).add(function(n) {
      t.push({
        cmd: "+",
        idx: n
      });
    }).update(function(n, i) {
      t.push({
        cmd: "=",
        idx: i,
        idx1: n
      });
    }).remove(function(n) {
      t.push({
        cmd: "-",
        idx: n
      });
    }).execute(), t;
  }
  function nK(r, e, t, n, i, a, o, s) {
    for (var l = rK(r, e), u = [], c = [], h = [], f = [], d = [], p = [], v = [], g = UN(i, e, o), m = r.getLayout("points") || [], y = e.getLayout("points") || [], x = 0; x < l.length; x++) {
      var _ = l[x], S = true, b = void 0, w = void 0;
      switch (_.cmd) {
        case "=":
          b = _.idx * 2, w = _.idx1 * 2;
          var C = m[b], T = m[b + 1], A = y[w], M = y[w + 1];
          (isNaN(C) || isNaN(T)) && (C = A, T = M), u.push(C, T), c.push(A, M), h.push(t[b], t[b + 1]), f.push(n[w], n[w + 1]), v.push(e.getRawIndex(_.idx1));
          break;
        case "+":
          var E = _.idx, k = g.dataDimsForPoint, R = i.dataToPoint([
            e.get(k[0], E),
            e.get(k[1], E)
          ]);
          w = E * 2, u.push(R[0], R[1]), c.push(y[w], y[w + 1]);
          var N = HN(g, i, e, E);
          h.push(N[0], N[1]), f.push(n[w], n[w + 1]), v.push(e.getRawIndex(E));
          break;
        case "-":
          S = false;
      }
      S && (d.push(_), p.push(p.length));
    }
    p.sort(function(q, me) {
      return v[q] - v[me];
    });
    for (var I = u.length, L = Pi(I), P = Pi(I), O = Pi(I), F = Pi(I), B = [], x = 0; x < p.length; x++) {
      var V = p[x], U = x * 2, Y = V * 2;
      L[U] = u[Y], L[U + 1] = u[Y + 1], P[U] = c[Y], P[U + 1] = c[Y + 1], O[U] = h[Y], O[U + 1] = h[Y + 1], F[U] = f[Y], F[U + 1] = f[Y + 1], B[x] = d[V];
    }
    return {
      current: L,
      next: P,
      stackedOnCurrent: O,
      stackedOnNext: F,
      status: B
    };
  }
  var Ea = Math.min, Na = Math.max;
  function Rs(r, e) {
    return isNaN(r) || isNaN(e);
  }
  function l_(r, e, t, n, i, a, o, s, l) {
    for (var u, c, h, f, d, p, v = t, g = 0; g < n; g++) {
      var m = e[v * 2], y = e[v * 2 + 1];
      if (v >= i || v < 0) break;
      if (Rs(m, y)) {
        if (l) {
          v += a;
          continue;
        }
        break;
      }
      if (v === t) r[a > 0 ? "moveTo" : "lineTo"](m, y), h = m, f = y;
      else {
        var x = m - u, _ = y - c;
        if (x * x + _ * _ < 0.5) {
          v += a;
          continue;
        }
        if (o > 0) {
          for (var S = v + a, b = e[S * 2], w = e[S * 2 + 1]; b === m && w === y && g < n; ) g++, S += a, v += a, b = e[S * 2], w = e[S * 2 + 1], m = e[v * 2], y = e[v * 2 + 1], x = m - u, _ = y - c;
          var C = g + 1;
          if (l) for (; Rs(b, w) && C < n; ) C++, S += a, b = e[S * 2], w = e[S * 2 + 1];
          var T = 0.5, A = 0, M = 0, E = void 0, k = void 0;
          if (C >= n || Rs(b, w)) d = m, p = y;
          else {
            A = b - u, M = w - c;
            var R = m - u, N = b - m, I = y - c, L = w - y, P = void 0, O = void 0;
            if (s === "x") {
              P = Math.abs(R), O = Math.abs(N);
              var F = A > 0 ? 1 : -1;
              d = m - F * P * o, p = y, E = m + F * O * o, k = y;
            } else if (s === "y") {
              P = Math.abs(I), O = Math.abs(L);
              var B = M > 0 ? 1 : -1;
              d = m, p = y - B * P * o, E = m, k = y + B * O * o;
            } else P = Math.sqrt(R * R + I * I), O = Math.sqrt(N * N + L * L), T = O / (O + P), d = m - A * o * (1 - T), p = y - M * o * (1 - T), E = m + A * o * T, k = y + M * o * T, E = Ea(E, Na(b, m)), k = Ea(k, Na(w, y)), E = Na(E, Ea(b, m)), k = Na(k, Ea(w, y)), A = E - m, M = k - y, d = m - A * P / O, p = y - M * P / O, d = Ea(d, Na(u, m)), p = Ea(p, Na(c, y)), d = Na(d, Ea(u, m)), p = Na(p, Ea(c, y)), A = m - d, M = y - p, E = m + A * O / P, k = y + M * O / P;
          }
          r.bezierCurveTo(h, f, d, p, m, y), h = E, f = k;
        } else r.lineTo(m, y);
      }
      u = m, c = y, v += a;
    }
    return g;
  }
  var YN = /* @__PURE__ */ function() {
    function r() {
      this.smooth = 0, this.smoothConstraint = true;
    }
    return r;
  }(), iK = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "ec-polyline", n;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new YN();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.points, a = 0, o = i.length / 2;
      if (n.connectNulls) {
        for (; o > 0 && Rs(i[o * 2 - 2], i[o * 2 - 1]); o--) ;
        for (; a < o && Rs(i[a * 2], i[a * 2 + 1]); a++) ;
      }
      for (; a < o; ) a += l_(t, i, a, o, o, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1;
    }, e.prototype.getPointOn = function(t, n) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, a = i.data, o = $i.CMD, s, l, u = n === "x", c = [], h = 0; h < a.length; ) {
        var f = a[h++], d = void 0, p = void 0, v = void 0, g = void 0, m = void 0, y = void 0, x = void 0;
        switch (f) {
          case o.M:
            s = a[h++], l = a[h++];
            break;
          case o.L:
            if (d = a[h++], p = a[h++], x = u ? (t - s) / (d - s) : (t - l) / (p - l), x <= 1 && x >= 0) {
              var _ = u ? (p - l) * x + l : (d - s) * x + s;
              return u ? [
                t,
                _
              ] : [
                _,
                t
              ];
            }
            s = d, l = p;
            break;
          case o.C:
            d = a[h++], p = a[h++], v = a[h++], g = a[h++], m = a[h++], y = a[h++];
            var S = u ? Fp(s, d, v, m, t, c) : Fp(l, p, g, y, t, c);
            if (S > 0) for (var b = 0; b < S; b++) {
              var w = c[b];
              if (w <= 1 && w >= 0) {
                var _ = u ? tr(l, p, g, y, w) : tr(s, d, v, m, w);
                return u ? [
                  t,
                  _
                ] : [
                  _,
                  t
                ];
              }
            }
            s = m, l = y;
            break;
        }
      }
    }, e;
  }(Ue), aK = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  }(YN), XN = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "ec-polygon", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new aK();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.points, a = n.stackedOnPoints, o = 0, s = i.length / 2, l = n.smoothMonotone;
      if (n.connectNulls) {
        for (; s > 0 && Rs(i[s * 2 - 2], i[s * 2 - 1]); s--) ;
        for (; o < s && Rs(i[o * 2], i[o * 2 + 1]); o++) ;
      }
      for (; o < s; ) {
        var u = l_(t, i, o, s, s, 1, n.smooth, l, n.connectNulls);
        l_(t, a, o + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls), o += u + 1, t.closePath();
      }
    }, e;
  }(Ue);
  function qN(r, e, t, n, i) {
    var a = r.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, c = t.get([
      "lineStyle",
      "width"
    ]) || 0;
    o -= c / 2, s -= c / 2, l += c, u += c, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++);
    var h = new et({
      shape: {
        x: o,
        y: s,
        width: l,
        height: u
      }
    });
    if (e) {
      var f = r.getBaseAxis(), d = f.isHorizontal(), p = f.inverse;
      d ? (p && (h.shape.x += l), h.shape.width = 0) : (p || (h.shape.y += u), h.shape.height = 0);
      var v = ge(i) ? function(g) {
        i(g, h);
      } : null;
      kt(h, {
        shape: {
          width: l,
          height: u,
          x: o,
          y: s
        }
      }, t, null, n, v);
    }
    return h;
  }
  function KN(r, e, t) {
    var n = r.getArea(), i = Bt(n.r0, 1), a = Bt(n.r, 1), o = new qr({
      shape: {
        cx: Bt(r.cx, 1),
        cy: Bt(r.cy, 1),
        r0: i,
        r: a,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        clockwise: n.clockwise
      }
    });
    if (e) {
      var s = r.getBaseAxis().dim === "angle";
      s ? o.shape.endAngle = n.startAngle : o.shape.r = i, kt(o, {
        shape: {
          endAngle: n.endAngle,
          r: a
        }
      }, t);
    }
    return o;
  }
  function Mf(r, e, t, n, i) {
    if (r) {
      if (r.type === "polar") return KN(r, e, t);
      if (r.type === "cartesian2d") return qN(r, e, t, n, i);
    } else return null;
    return null;
  }
  function Js(r, e) {
    return r.type === e;
  }
  function tA(r, e) {
    if (r.length === e.length) {
      for (var t = 0; t < r.length; t++) if (r[t] !== e[t]) return;
      return true;
    }
  }
  function rA(r) {
    for (var e = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0; a < r.length; ) {
      var o = r[a++], s = r[a++];
      isNaN(o) || (e = Math.min(o, e), n = Math.max(o, n)), isNaN(s) || (t = Math.min(s, t), i = Math.max(s, i));
    }
    return [
      [
        e,
        t
      ],
      [
        n,
        i
      ]
    ];
  }
  function nA(r, e) {
    var t = rA(r), n = t[0], i = t[1], a = rA(e), o = a[0], s = a[1];
    return Math.max(Math.abs(n[0] - o[0]), Math.abs(n[1] - o[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
  }
  function iA(r) {
    return nt(r) ? r : r ? 0.5 : 0;
  }
  function oK(r, e, t) {
    if (!t.valueDim) return [];
    for (var n = e.count(), i = Pi(n * 2), a = 0; a < n; a++) {
      var o = HN(t, r, e, a);
      i[a * 2] = o[0], i[a * 2 + 1] = o[1];
    }
    return i;
  }
  function Oa(r, e, t, n, i) {
    var a = t.getBaseAxis(), o = a.dim === "x" || a.dim === "radius" ? 0 : 1, s = [], l = 0, u = [], c = [], h = [], f = [];
    if (i) {
      for (l = 0; l < r.length; l += 2) {
        var d = e || r;
        !isNaN(d[l]) && !isNaN(d[l + 1]) && f.push(r[l], r[l + 1]);
      }
      r = f;
    }
    for (l = 0; l < r.length - 2; l += 2) switch (h[0] = r[l + 2], h[1] = r[l + 3], c[0] = r[l], c[1] = r[l + 1], s.push(c[0], c[1]), n) {
      case "end":
        u[o] = h[o], u[1 - o] = c[1 - o], s.push(u[0], u[1]);
        break;
      case "middle":
        var p = (c[o] + h[o]) / 2, v = [];
        u[o] = v[o] = p, u[1 - o] = c[1 - o], v[1 - o] = h[1 - o], s.push(u[0], u[1]), s.push(v[0], v[1]);
        break;
      default:
        u[o] = c[o], u[1 - o] = h[1 - o], s.push(u[0], u[1]);
    }
    return s.push(r[l++], r[l++]), s;
  }
  function sK(r, e) {
    var t = [], n = r.length, i, a;
    function o(c, h, f) {
      var d = c.coord, p = (f - d) / (h.coord - d), v = YU(p, [
        c.color,
        h.color
      ]);
      return {
        coord: f,
        color: v
      };
    }
    for (var s = 0; s < n; s++) {
      var l = r[s], u = l.coord;
      if (u < 0) i = l;
      else if (u > e) {
        a ? t.push(o(a, l, e)) : i && t.push(o(i, l, 0), o(i, l, e));
        break;
      } else i && (t.push(o(i, l, 0)), i = null), t.push(l), a = l;
    }
    return t;
  }
  function lK(r, e, t) {
    var n = r.getVisual("visualMeta");
    if (!(!n || !n.length || !r.count()) && e.type === "cartesian2d") {
      for (var i, a, o = n.length - 1; o >= 0; o--) {
        var s = r.getDimensionInfo(n[o].dimension);
        if (i = s && s.coordDim, i === "x" || i === "y") {
          a = n[o];
          break;
        }
      }
      if (a) {
        var l = e.getAxis(i), u = K(a.stops, function(x) {
          return {
            coord: l.toGlobalCoord(l.dataToCoord(x.value)),
            color: x.color
          };
        }), c = u.length, h = a.outerColors.slice();
        c && u[0].coord > u[c - 1].coord && (u.reverse(), h.reverse());
        var f = sK(u, i === "x" ? t.getWidth() : t.getHeight()), d = f.length;
        if (!d && c) return u[0].coord < 0 ? h[1] ? h[1] : u[c - 1].color : h[0] ? h[0] : u[0].color;
        var p = 10, v = f[0].coord - p, g = f[d - 1].coord + p, m = g - v;
        if (m < 1e-3) return "transparent";
        D(f, function(x) {
          x.offset = (x.coord - v) / m;
        }), f.push({
          offset: d ? f[d - 1].offset : 0.5,
          color: h[1] || "transparent"
        }), f.unshift({
          offset: d ? f[0].offset : 0.5,
          color: h[0] || "transparent"
        });
        var y = new xf(0, 0, 0, 0, f, true);
        return y[i] = v, y[i + "2"] = g, y;
      }
    }
  }
  function uK(r, e, t) {
    var n = r.get("showAllSymbol"), i = n === "auto";
    if (!(n && !i)) {
      var a = t.getAxesByScale("ordinal")[0];
      if (a && !(i && cK(a, e))) {
        var o = e.mapDimension(a.dim), s = {};
        return D(a.getViewLabels(), function(l) {
          var u = a.scale.getRawOrdinalNumber(l.tickValue);
          s[u] = 1;
        }), function(l) {
          return !s.hasOwnProperty(e.get(o, l));
        };
      }
    }
  }
  function cK(r, e) {
    var t = r.getExtent(), n = Math.abs(t[1] - t[0]) / r.scale.count();
    isNaN(n) && (n = 0);
    for (var i = e.count(), a = Math.max(1, Math.round(i / 5)), o = 0; o < i; o += a) if (Af.getSymbolSize(e, o)[r.isHorizontal() ? 1 : 0] * 1.5 > n) return false;
    return true;
  }
  function hK(r, e) {
    return isNaN(r) || isNaN(e);
  }
  function fK(r) {
    for (var e = r.length / 2; e > 0 && hK(r[e * 2 - 2], r[e * 2 - 1]); e--) ;
    return e - 1;
  }
  function aA(r, e) {
    return [
      r[e * 2],
      r[e * 2 + 1]
    ];
  }
  function dK(r, e, t) {
    for (var n = r.length / 2, i = t === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < n; u++) if (o = r[u * 2 + i], !(isNaN(o) || isNaN(r[u * 2 + 1 - i]))) {
      if (u === 0) {
        a = o;
        continue;
      }
      if (a <= e && o >= e || a >= e && o <= e) {
        l = u;
        break;
      }
      s = u, a = o;
    }
    return {
      range: [
        s,
        l
      ],
      t: (e - a) / (o - a)
    };
  }
  function ZN(r) {
    if (r.get([
      "endLabel",
      "show"
    ])) return true;
    for (var e = 0; e < Xr.length; e++) if (r.get([
      Xr[e],
      "endLabel",
      "show"
    ])) return true;
    return false;
  }
  function ly(r, e, t, n) {
    if (Js(e, "cartesian2d")) {
      var i = n.getModel("endLabel"), a = i.get("valueAnimation"), o = n.getData(), s = {
        lastFrameIndex: 0
      }, l = ZN(n) ? function(d, p) {
        r._endLabelOnDuring(d, p, o, s, a, i, e);
      } : null, u = e.getBaseAxis().isHorizontal(), c = qN(e, t, n, function() {
        var d = r._endLabel;
        d && t && s.originalX != null && d.attr({
          x: s.originalX,
          y: s.originalY
        });
      }, l);
      if (!n.get("clip", true)) {
        var h = c.shape, f = Math.max(h.width, h.height);
        u ? (h.y -= f, h.height += f * 2) : (h.x -= f, h.width += f * 2);
      }
      return l && l(1, c), c;
    } else return KN(e, t, n);
  }
  function pK(r, e) {
    var t = e.getBaseAxis(), n = t.isHorizontal(), i = t.inverse, a = n ? i ? "right" : "left" : "center", o = n ? "middle" : i ? "top" : "bottom";
    return {
      normal: {
        align: r.get("align") || a,
        verticalAlign: r.get("verticalAlign") || o
      }
    };
  }
  var vK = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      var t = new Ce(), n = new If();
      this.group.add(n.group), this._symbolDraw = n, this._lineGroup = t, this._changePolyState = ne(this._changePolyState, this);
    }, e.prototype.render = function(t, n, i) {
      var a = t.coordinateSystem, o = this.group, s = t.getData(), l = t.getModel("lineStyle"), u = t.getModel("areaStyle"), c = s.getLayout("points") || [], h = a.type === "polar", f = this._coordSys, d = this._symbolDraw, p = this._polyline, v = this._polygon, g = this._lineGroup, m = !n.ssr && t.get("animation"), y = !u.isEmpty(), x = u.get("origin"), _ = UN(a, s, x), S = y && oK(a, s, _), b = t.get("showSymbol"), w = t.get("connectNulls"), C = b && !h && uK(t, s, a), T = this._data;
      T && T.eachItemGraphicEl(function(q, me) {
        q.__temp && (o.remove(q), T.setItemGraphicEl(me, null));
      }), b || d.remove(), o.add(g);
      var A = h ? false : t.get("step"), M;
      a && a.getArea && t.get("clip", true) && (M = a.getArea(), M.width != null ? (M.x -= 0.1, M.y -= 0.1, M.width += 0.2, M.height += 0.2) : M.r0 && (M.r0 -= 0.5, M.r += 0.5)), this._clipShapeForSymbol = M;
      var E = lK(s, a, i) || s.getVisual("style")[s.getVisual("drawType")];
      if (!(p && f.type === a.type && A === this._step)) b && d.updateData(s, {
        isIgnore: C,
        clipShape: M,
        disableAnimation: true,
        getSymbolPoint: function(q) {
          return [
            c[q * 2],
            c[q * 2 + 1]
          ];
        }
      }), m && this._initSymbolLabelAnimation(s, a, M), A && (S && (S = Oa(S, c, a, A, w)), c = Oa(c, null, a, A, w)), p = this._newPolyline(c), y ? v = this._newPolygon(c, S) : v && (g.remove(v), v = this._polygon = null), h || this._initOrUpdateEndLabel(t, a, Gs(E)), g.setClipPath(ly(this, a, true, t));
      else {
        y && !v ? v = this._newPolygon(c, S) : v && !y && (g.remove(v), v = this._polygon = null), h || this._initOrUpdateEndLabel(t, a, Gs(E));
        var k = g.getClipPath();
        if (k) {
          var R = ly(this, a, false, t);
          kt(k, {
            shape: R.shape
          }, t);
        } else g.setClipPath(ly(this, a, true, t));
        b && d.updateData(s, {
          isIgnore: C,
          clipShape: M,
          disableAnimation: true,
          getSymbolPoint: function(q) {
            return [
              c[q * 2],
              c[q * 2 + 1]
            ];
          }
        }), (!tA(this._stackedOnPoints, S) || !tA(this._points, c)) && (m ? this._doUpdateAnimation(s, S, a, i, A, x, w) : (A && (S && (S = Oa(S, c, a, A, w)), c = Oa(c, null, a, A, w)), p.setShape({
          points: c
        }), v && v.setShape({
          points: c,
          stackedOnPoints: S
        })));
      }
      var N = t.getModel("emphasis"), I = N.get("focus"), L = N.get("blurScope"), P = N.get("disabled");
      if (p.useStyle(ye(l.getLineStyle(), {
        fill: "none",
        stroke: E,
        lineJoin: "bevel"
      })), br(p, t, "lineStyle"), p.style.lineWidth > 0 && t.get([
        "emphasis",
        "lineStyle",
        "width"
      ]) === "bolder") {
        var O = p.getState("emphasis").style;
        O.lineWidth = +p.style.lineWidth + 1;
      }
      De(p).seriesIndex = t.seriesIndex, Nt(p, I, L, P);
      var F = iA(t.get("smooth")), B = t.get("smoothMonotone");
      if (p.setShape({
        smooth: F,
        smoothMonotone: B,
        connectNulls: w
      }), v) {
        var V = s.getCalculationInfo("stackedOnSeries"), U = 0;
        v.useStyle(ye(u.getAreaStyle(), {
          fill: E,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: s.getVisual("style").decal
        })), V && (U = iA(V.get("smooth"))), v.setShape({
          smooth: F,
          stackedOnSmooth: U,
          smoothMonotone: B,
          connectNulls: w
        }), br(v, t, "areaStyle"), De(v).seriesIndex = t.seriesIndex, Nt(v, I, L, P);
      }
      var Y = this._changePolyState;
      s.eachItemGraphicEl(function(q) {
        q && (q.onHoverStateChange = Y);
      }), this._polyline.onHoverStateChange = Y, this._data = s, this._coordSys = a, this._stackedOnPoints = S, this._points = c, this._step = A, this._valueOrigin = x, t.get("triggerLineEvent") && (this.packEventData(t, p), v && this.packEventData(t, v));
    }, e.prototype.packEventData = function(t, n) {
      De(n).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: t.componentIndex,
        seriesIndex: t.seriesIndex,
        seriesName: t.name,
        seriesType: "line"
      };
    }, e.prototype.highlight = function(t, n, i, a) {
      var o = t.getData(), s = zs(o, a);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], h = l[s * 2 + 1];
          if (isNaN(c) || isNaN(h) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, h)) return;
          var f = t.get("zlevel") || 0, d = t.get("z") || 0;
          u = new Af(o, s), u.x = c, u.y = h, u.setZ(f, d);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = f, p.z = d, p.z2 = this._polyline.z2 + 1), u.__temp = true, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(true), this.group.add(u);
        }
        u.highlight();
      } else yt.prototype.highlight.call(this, t, n, i, a);
    }, e.prototype.downplay = function(t, n, i, a) {
      var o = t.getData(), s = zs(o, a);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = o.getItemGraphicEl(s);
        l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else yt.prototype.downplay.call(this, t, n, i, a);
    }, e.prototype._changePolyState = function(t) {
      var n = this._polygon;
      Up(this._polyline, t), n && Up(n, t);
    }, e.prototype._newPolyline = function(t) {
      var n = this._polyline;
      return n && this._lineGroup.remove(n), n = new iK({
        shape: {
          points: t
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(n), this._polyline = n, n;
    }, e.prototype._newPolygon = function(t, n) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new XN({
        shape: {
          points: t,
          stackedOnPoints: n
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, e.prototype._initSymbolLabelAnimation = function(t, n, i) {
      var a, o, s = n.getBaseAxis(), l = s.inverse;
      n.type === "cartesian2d" ? (a = s.isHorizontal(), o = false) : n.type === "polar" && (a = s.dim === "angle", o = true);
      var u = t.hostModel, c = u.get("animationDuration");
      ge(c) && (c = c(null));
      var h = u.get("animationDelay") || 0, f = ge(h) ? h(null) : h;
      t.eachItemGraphicEl(function(d, p) {
        var v = d;
        if (v) {
          var g = [
            d.x,
            d.y
          ], m = void 0, y = void 0, x = void 0;
          if (i) if (o) {
            var _ = i, S = n.pointToCoord(g);
            a ? (m = _.startAngle, y = _.endAngle, x = -S[1] / 180 * Math.PI) : (m = _.r0, y = _.r, x = S[0]);
          } else {
            var b = i;
            a ? (m = b.x, y = b.x + b.width, x = d.x) : (m = b.y + b.height, y = b.y, x = d.y);
          }
          var w = y === m ? 0 : (x - m) / (y - m);
          l && (w = 1 - w);
          var C = ge(h) ? h(p) : c * w + f, T = v.getSymbolPath(), A = T.getTextContent();
          v.attr({
            scaleX: 0,
            scaleY: 0
          }), v.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: true,
            delay: C
          }), A && A.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: C
          }), T.disableLabelAnimation = true;
        }
      });
    }, e.prototype._initOrUpdateEndLabel = function(t, n, i) {
      var a = t.getModel("endLabel");
      if (ZN(t)) {
        var o = t.getData(), s = this._polyline, l = o.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new rt({
          z2: 200
        }), u.ignoreClip = true, s.setTextContent(this._endLabel), s.disableLabelAnimation = true);
        var c = fK(l);
        c >= 0 && (Sr(s, lr(t, "endLabel"), {
          inheritColor: i,
          labelFetcher: t,
          labelDataIndex: c,
          defaultText: function(h, f, d) {
            return d != null ? WN(o, d) : du(o, h);
          },
          enableTextSetter: true
        }, pK(a, n)), s.textConfig.position = null);
      } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, e.prototype._endLabelOnDuring = function(t, n, i, a, o, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        t < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var h = i.getLayout("points"), f = i.hostModel, d = f.get("connectNulls"), p = s.get("precision"), v = s.get("distance") || 0, g = l.getBaseAxis(), m = g.isHorizontal(), y = g.inverse, x = n.shape, _ = y ? m ? x.x : x.y + x.height : m ? x.x + x.width : x.y, S = (m ? v : 0) * (y ? -1 : 1), b = (m ? 0 : -v) * (y ? -1 : 1), w = m ? "x" : "y", C = dK(h, _, w), T = C.range, A = T[1] - T[0], M = void 0;
        if (A >= 1) {
          if (A > 1 && !d) {
            var E = aA(h, T[0]);
            u.attr({
              x: E[0] + S,
              y: E[1] + b
            }), o && (M = f.getRawValue(T[0]));
          } else {
            var E = c.getPointOn(_, w);
            E && u.attr({
              x: E[0] + S,
              y: E[1] + b
            });
            var k = f.getRawValue(T[0]), R = f.getRawValue(T[1]);
            o && (M = ER(i, p, k, R, C.t));
          }
          a.lastFrameIndex = T[0];
        } else {
          var N = t === 1 || a.lastFrameIndex > 0 ? T[0] : 0, E = aA(h, N);
          o && (M = f.getRawValue(N)), u.attr({
            x: E[0] + S,
            y: E[1] + b
          });
        }
        if (o) {
          var I = Eu(u);
          typeof I.setLabelText == "function" && I.setLabelText(M);
        }
      }
    }, e.prototype._doUpdateAnimation = function(t, n, i, a, o, s, l) {
      var u = this._polyline, c = this._polygon, h = t.hostModel, f = nK(this._data, t, this._stackedOnPoints, n, this._coordSys, i, this._valueOrigin), d = f.current, p = f.stackedOnCurrent, v = f.next, g = f.stackedOnNext;
      if (o && (p = Oa(f.stackedOnCurrent, f.current, i, o, l), d = Oa(f.current, null, i, o, l), g = Oa(f.stackedOnNext, f.next, i, o, l), v = Oa(f.next, null, i, o, l)), nA(d, v) > 3e3 || c && nA(p, g) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: v
        }), c && (c.stopAnimation(), c.setShape({
          points: v,
          stackedOnPoints: g
        }));
        return;
      }
      u.shape.__points = f.current, u.shape.points = d;
      var m = {
        shape: {
          points: v
        }
      };
      f.current !== d && (m.shape.__points = f.next), u.stopAnimation(), it(u, m, h), c && (c.setShape({
        points: d,
        stackedOnPoints: p
      }), c.stopAnimation(), it(c, {
        shape: {
          stackedOnPoints: g
        }
      }, h), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], x = f.status, _ = 0; _ < x.length; _++) {
        var S = x[_].cmd;
        if (S === "=") {
          var b = t.getItemGraphicEl(x[_].idx1);
          b && y.push({
            el: b,
            ptIdx: _
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var w = u.shape.__points, C = 0; C < y.length; C++) {
          var T = y[C].el, A = y[C].ptIdx * 2;
          T.x = w[A], T.y = w[A + 1], T.markRedraw();
        }
      });
    }, e.prototype.remove = function(t) {
      var n = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(true), i && i.eachItemGraphicEl(function(a, o) {
        a.__temp && (n.remove(a), i.setItemGraphicEl(o, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, e.type = "line", e;
  }(yt);
  function Df(r, e) {
    return {
      seriesType: r,
      plan: zu(),
      reset: function(t) {
        var n = t.getData(), i = t.coordinateSystem, a = t.pipelineContext, o = e || a.large;
        if (i) {
          var s = K(i.dimensions, function(d) {
            return n.mapDimension(d);
          }).slice(0, 2), l = s.length, u = n.getCalculationInfo("stackResultDimension");
          ho(n, s[0]) && (s[0] = u), ho(n, s[1]) && (s[1] = u);
          var c = n.getStore(), h = n.getDimensionIndex(s[0]), f = n.getDimensionIndex(s[1]);
          return l && {
            progress: function(d, p) {
              for (var v = d.end - d.start, g = o && Pi(v * l), m = [], y = [], x = d.start, _ = 0; x < d.end; x++) {
                var S = void 0;
                if (l === 1) {
                  var b = c.get(h, x);
                  S = i.dataToPoint(b, null, y);
                } else m[0] = c.get(h, x), m[1] = c.get(f, x), S = i.dataToPoint(m, null, y);
                o ? (g[_++] = S[0], g[_++] = S[1]) : p.setItemLayout(x, S.slice());
              }
              o && p.setLayout("points", g);
            }
          };
        }
      }
    };
  }
  var gK = {
    average: function(r) {
      for (var e = 0, t = 0, n = 0; n < r.length; n++) isNaN(r[n]) || (e += r[n], t++);
      return t === 0 ? NaN : e / t;
    },
    sum: function(r) {
      for (var e = 0, t = 0; t < r.length; t++) e += r[t] || 0;
      return e;
    },
    max: function(r) {
      for (var e = -1 / 0, t = 0; t < r.length; t++) r[t] > e && (e = r[t]);
      return isFinite(e) ? e : NaN;
    },
    min: function(r) {
      for (var e = 1 / 0, t = 0; t < r.length; t++) r[t] < e && (e = r[t]);
      return isFinite(e) ? e : NaN;
    },
    nearest: function(r) {
      return r[0];
    }
  }, mK = function(r) {
    return Math.round(r.length / 2);
  };
  function jN(r) {
    return {
      seriesType: r,
      reset: function(e, t, n) {
        var i = e.getData(), a = e.get("sampling"), o = e.coordinateSystem, s = i.count();
        if (s > 10 && o.type === "cartesian2d" && a) {
          var l = o.getBaseAxis(), u = o.getOtherAxis(l), c = l.getExtent(), h = n.getDevicePixelRatio(), f = Math.abs(c[1] - c[0]) * (h || 1), d = Math.round(s / f);
          if (isFinite(d) && d > 1) {
            a === "lttb" ? e.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / d)) : a === "minmax" && e.setData(i.minmaxDownSample(i.mapDimension(u.dim), 1 / d));
            var p = void 0;
            ee(a) ? p = gK[a] : ge(a) && (p = a), p && e.setData(i.downSample(i.mapDimension(u.dim), 1 / d, p, mK));
          }
        }
      }
    };
  }
  function yK(r) {
    r.registerChartView(vK), r.registerSeriesModel(Jq), r.registerLayout(Df("line", true)), r.registerVisual({
      seriesType: "line",
      reset: function(e) {
        var t = e.getData(), n = e.getModel("lineStyle").getLineStyle();
        n && !n.stroke && (n.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", n);
      }
    }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, jN("line"));
  }
  var Bh = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      return Aa(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getMarkerPosition = function(t, n, i) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var o = a.clampData(t), s = a.dataToPoint(o);
        if (i) D(a.getAxes(), function(f, d) {
          if (f.type === "category" && n != null) {
            var p = f.getTicksCoords(), v = f.getTickModel().get("alignWithLabel"), g = o[d], m = n[d] === "x1" || n[d] === "y1";
            if (m && !v && (g += 1), p.length < 2) return;
            if (p.length === 2) {
              s[d] = f.toGlobalCoord(f.getExtent()[m ? 1 : 0]);
              return;
            }
            for (var y = void 0, x = void 0, _ = 1, S = 0; S < p.length; S++) {
              var b = p[S].coord, w = S === p.length - 1 ? p[S - 1].tickValue + _ : p[S].tickValue;
              if (w === g) {
                x = b;
                break;
              } else if (w < g) y = b;
              else if (y != null && w > g) {
                x = (b + y) / 2;
                break;
              }
              S === 1 && (_ = w - p[0].tickValue);
            }
            x == null && (y ? y && (x = p[p.length - 1].coord) : x = p[0].coord), s[d] = f.toGlobalCoord(x);
          }
        });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), h = a.getBaseAxis().isHorizontal() ? 0 : 1;
          s[h] += u + c / 2;
        }
        return s;
      }
      return [
        NaN,
        NaN
      ];
    }, e.type = "series.__base_bar__", e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      barMinHeight: 0,
      barMinAngle: 0,
      large: false,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, e;
  }(Tt);
  Tt.registerClass(Bh);
  var xK = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function() {
      return Aa(null, this, {
        useEncodeDefaulter: true,
        createInvertedIndices: !!this.get("realtimeSort", true) || null
      });
    }, e.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : false;
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.get("progressiveThreshold"), n = this.get("largeThreshold");
      return n > t && (t = n), t;
    }, e.prototype.brushSelector = function(t, n, i) {
      return i.rect(n.getItemLayout(t));
    }, e.type = "series.bar", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = yo(Bh.defaultOption, {
      clip: true,
      roundCap: false,
      showBackground: false,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: false
    }), e;
  }(Bh), _K = /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
    }
    return r;
  }(), uv = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "sausage", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new _K();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.cx, a = n.cy, o = Math.max(n.r0 || 0, 0), s = Math.max(n.r, 0), l = (s - o) * 0.5, u = o + l, c = n.startAngle, h = n.endAngle, f = n.clockwise, d = Math.PI * 2, p = f ? h - c < d : c - h < d;
      p || (c = h - (f ? d : -d));
      var v = Math.cos(c), g = Math.sin(c), m = Math.cos(h), y = Math.sin(h);
      p ? (t.moveTo(v * o + i, g * o + a), t.arc(v * u + i, g * u + a, l, -Math.PI + c, c, !f)) : t.moveTo(v * s + i, g * s + a), t.arc(i, a, s, c, h, !f), t.arc(m * u + i, y * u + a, l, h - Math.PI * 2, h - Math.PI, !f), o !== 0 && t.arc(i, a, o, h, c, f);
    }, e;
  }(Ue);
  function bK(r, e) {
    e = e || {};
    var t = e.isRoundCap;
    return function(n, i, a) {
      var o = i.position;
      if (!o || o instanceof Array) return Gp(n, i, a);
      var s = r(o), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, h = u.cy, f = u.r, d = u.r0, p = (f + d) / 2, v = u.startAngle, g = u.endAngle, m = (v + g) / 2, y = t ? Math.abs(f - d) / 2 : 0, x = Math.cos, _ = Math.sin, S = c + f * x(v), b = h + f * _(v), w = "left", C = "top";
      switch (s) {
        case "startArc":
          S = c + (d - l) * x(m), b = h + (d - l) * _(m), w = "center", C = "top";
          break;
        case "insideStartArc":
          S = c + (d + l) * x(m), b = h + (d + l) * _(m), w = "center", C = "bottom";
          break;
        case "startAngle":
          S = c + p * x(v) + _d(v, l + y, false), b = h + p * _(v) + bd(v, l + y, false), w = "right", C = "middle";
          break;
        case "insideStartAngle":
          S = c + p * x(v) + _d(v, -l + y, false), b = h + p * _(v) + bd(v, -l + y, false), w = "left", C = "middle";
          break;
        case "middle":
          S = c + p * x(m), b = h + p * _(m), w = "center", C = "middle";
          break;
        case "endArc":
          S = c + (f + l) * x(m), b = h + (f + l) * _(m), w = "center", C = "bottom";
          break;
        case "insideEndArc":
          S = c + (f - l) * x(m), b = h + (f - l) * _(m), w = "center", C = "top";
          break;
        case "endAngle":
          S = c + p * x(g) + _d(g, l + y, true), b = h + p * _(g) + bd(g, l + y, true), w = "left", C = "middle";
          break;
        case "insideEndAngle":
          S = c + p * x(g) + _d(g, -l + y, true), b = h + p * _(g) + bd(g, -l + y, true), w = "right", C = "middle";
          break;
        default:
          return Gp(n, i, a);
      }
      return n = n || {}, n.x = S, n.y = b, n.align = w, n.verticalAlign = C, n;
    };
  }
  function SK(r, e, t, n) {
    if (nt(n)) {
      r.setTextConfig({
        rotation: n
      });
      return;
    } else if (X(e)) {
      r.setTextConfig({
        rotation: 0
      });
      return;
    }
    var i = r.shape, a = i.clockwise ? i.startAngle : i.endAngle, o = i.clockwise ? i.endAngle : i.startAngle, s = (a + o) / 2, l, u = t(e);
    switch (u) {
      case "startArc":
      case "insideStartArc":
      case "middle":
      case "insideEndArc":
      case "endArc":
        l = s;
        break;
      case "startAngle":
      case "insideStartAngle":
        l = a;
        break;
      case "endAngle":
      case "insideEndAngle":
        l = o;
        break;
      default:
        r.setTextConfig({
          rotation: 0
        });
        return;
    }
    var c = Math.PI * 1.5 - l;
    u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), r.setTextConfig({
      rotation: c
    });
  }
  function _d(r, e, t) {
    return e * Math.sin(r) * (t ? -1 : 1);
  }
  function bd(r, e, t) {
    return e * Math.cos(r) * (t ? 1 : -1);
  }
  function Ss(r, e, t) {
    var n = r.get("borderRadius");
    if (n == null) return t ? {
      cornerRadius: 0
    } : null;
    X(n) || (n = [
      n,
      n,
      n,
      n
    ]);
    var i = Math.abs(e.r || 0 - e.r0 || 0);
    return {
      cornerRadius: K(n, function(a) {
        return si(a, i);
      })
    };
  }
  var uy = Math.max, cy = Math.min;
  function wK(r, e) {
    var t = r.getArea && r.getArea();
    if (Js(r, "cartesian2d")) {
      var n = r.getBaseAxis();
      if (n.type !== "category" || !n.onBand) {
        var i = e.getLayout("bandWidth");
        n.isHorizontal() ? (t.x -= i, t.width += i * 2) : (t.y -= i, t.height += i * 2);
      }
    }
    return t;
  }
  var CK = function(r) {
    G(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.type = e.type, t._isFirstFrame = true, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this._model = t, this._removeOnRenderedListener(i), this._updateDrawMode(t);
      var o = t.get("coordinateSystem");
      (o === "cartesian2d" || o === "polar") && (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, n, i) : this._renderNormal(t, n, i, a));
    }, e.prototype.incrementalPrepareRender = function(t) {
      this._clear(), this._updateDrawMode(t), this._updateLargeClip(t);
    }, e.prototype.incrementalRender = function(t, n) {
      this._progressiveEls = [], this._incrementalRenderLarge(t, n);
    }, e.prototype.eachRendered = function(t) {
      mo(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var n = t.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, e.prototype._renderNormal = function(t, n, i, a) {
      var o = this.group, s = t.getData(), l = this._data, u = t.coordinateSystem, c = u.getBaseAxis(), h;
      u.type === "cartesian2d" ? h = c.isHorizontal() : u.type === "polar" && (h = c.dim === "angle");
      var f = t.isAnimationEnabled() ? t : null, d = TK(t, u);
      d && this._enableRealtimeSort(d, s, i);
      var p = t.get("clip", true) || d, v = wK(u, s);
      o.removeClipPath();
      var g = t.get("roundCap", true), m = t.get("showBackground", true), y = t.getModel("backgroundStyle"), x = y.get("borderRadius") || 0, _ = [], S = this._backgroundEls, b = a && a.isInitSort, w = a && a.type === "changeAxisOrder";
      function C(M) {
        var E = Sd[u.type](s, M), k = LK(u, h, E);
        return k.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? k.setShape("r", x) : k.setShape("cornerRadius", x), _[M] = k, k;
      }
      s.diff(l).add(function(M) {
        var E = s.getItemModel(M), k = Sd[u.type](s, M, E);
        if (m && C(M), !(!s.hasValue(M) || !cA[u.type](k))) {
          var R = false;
          p && (R = oA[u.type](v, k));
          var N = sA[u.type](t, s, M, k, h, f, c.model, false, g);
          d && (N.forceLabelAnimation = true), hA(N, s, M, E, k, t, h, u.type === "polar"), b ? N.attr({
            shape: k
          }) : d ? lA(d, f, N, k, M, h, false, false) : kt(N, {
            shape: k
          }, t, M), s.setItemGraphicEl(M, N), o.add(N), N.ignore = R;
        }
      }).update(function(M, E) {
        var k = s.getItemModel(M), R = Sd[u.type](s, M, k);
        if (m) {
          var N = void 0;
          S.length === 0 ? N = C(E) : (N = S[E], N.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? N.setShape("r", x) : N.setShape("cornerRadius", x), _[M] = N);
          var I = Sd[u.type](s, M), L = JN(h, I, u);
          it(N, {
            shape: L
          }, f, M);
        }
        var P = l.getItemGraphicEl(E);
        if (!s.hasValue(M) || !cA[u.type](R)) {
          o.remove(P);
          return;
        }
        var O = false;
        if (p && (O = oA[u.type](v, R), O && o.remove(P)), P ? li(P) : P = sA[u.type](t, s, M, R, h, f, c.model, !!P, g), d && (P.forceLabelAnimation = true), w) {
          var F = P.getTextContent();
          if (F) {
            var B = Eu(F);
            B.prevValue != null && (B.prevValue = B.value);
          }
        } else hA(P, s, M, k, R, t, h, u.type === "polar");
        b ? P.attr({
          shape: R
        }) : d ? lA(d, f, P, R, M, h, true, w) : it(P, {
          shape: R
        }, t, M, null), s.setItemGraphicEl(M, P), P.ignore = O, o.add(P);
      }).remove(function(M) {
        var E = l.getItemGraphicEl(M);
        E && Mh(E, t, M);
      }).execute();
      var T = this._backgroundGroup || (this._backgroundGroup = new Ce());
      T.removeAll();
      for (var A = 0; A < _.length; ++A) T.add(_[A]);
      o.add(T), this._backgroundEls = _, this._data = s;
    }, e.prototype._renderLarge = function(t, n, i) {
      this._clear(), dA(t, this.group), this._updateLargeClip(t);
    }, e.prototype._incrementalRenderLarge = function(t, n) {
      this._removeBackground(), dA(n, this.group, this._progressiveEls, true);
    }, e.prototype._updateLargeClip = function(t) {
      var n = t.get("clip", true) && Mf(t.coordinateSystem, false, t), i = this.group;
      n ? i.setClipPath(n) : i.removeClipPath();
    }, e.prototype._enableRealtimeSort = function(t, n, i) {
      var a = this;
      if (n.count()) {
        var o = t.baseAxis;
        if (this._isFirstFrame) this._dispatchInitSort(n, t, i), this._isFirstFrame = false;
        else {
          var s = function(l) {
            var u = n.getItemGraphicEl(l), c = u && u.shape;
            return c && Math.abs(o.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(n, s, o, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, e.prototype._dataSort = function(t, n, i) {
      var a = [];
      return t.each(t.mapDimension(n.dim), function(o, s) {
        var l = i(s);
        l = l ?? NaN, a.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: o
        });
      }), a.sort(function(o, s) {
        return s.mappedValue - o.mappedValue;
      }), {
        ordinalNumbers: K(a, function(o) {
          return o.ordinalNumber;
        })
      };
    }, e.prototype._isOrderChangedWithinSameData = function(t, n, i) {
      for (var a = i.scale, o = t.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = t.rawIndexOf(o, a.getRawOrdinalNumber(l)), h = c < 0 ? Number.MIN_VALUE : n(t.indexOfRawIndex(c));
        if (h > s) return true;
        s = h;
      }
      return false;
    }, e.prototype._isOrderDifferentInView = function(t, n) {
      for (var i = n.scale, a = i.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); o <= s; ++o) if (t.ordinalNumbers[o] !== i.getRawOrdinalNumber(o)) return true;
    }, e.prototype._updateSortWithinSameData = function(t, n, i, a) {
      if (this._isOrderChangedWithinSameData(t, n, i)) {
        var o = this._dataSort(t, i, n);
        this._isOrderDifferentInView(o, i) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: o
        }));
      }
    }, e.prototype._dispatchInitSort = function(t, n, i) {
      var a = n.baseAxis, o = this._dataSort(t, a, function(s) {
        return t.get(t.mapDimension(n.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: true,
        axisId: a.index,
        sortInfo: o
      });
    }, e.prototype.remove = function(t, n) {
      this._clear(this._model), this._removeOnRenderedListener(n);
    }, e.prototype.dispose = function(t, n) {
      this._removeOnRenderedListener(n);
    }, e.prototype._removeOnRenderedListener = function(t) {
      this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, e.prototype._clear = function(t) {
      var n = this.group, i = this._data;
      t && t.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(a) {
        Mh(a, t, De(a).dataIndex);
      })) : n.removeAll(), this._data = null, this._isFirstFrame = true;
    }, e.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, e.type = "bar", e;
  }(yt), oA = {
    cartesian2d: function(r, e) {
      var t = e.width < 0 ? -1 : 1, n = e.height < 0 ? -1 : 1;
      t < 0 && (e.x += e.width, e.width = -e.width), n < 0 && (e.y += e.height, e.height = -e.height);
      var i = r.x + r.width, a = r.y + r.height, o = uy(e.x, r.x), s = cy(e.x + e.width, i), l = uy(e.y, r.y), u = cy(e.y + e.height, a), c = s < o, h = u < l;
      return e.x = c && o > i ? s : o, e.y = h && l > a ? u : l, e.width = c ? 0 : s - o, e.height = h ? 0 : u - l, t < 0 && (e.x += e.width, e.width = -e.width), n < 0 && (e.y += e.height, e.height = -e.height), c || h;
    },
    polar: function(r, e) {
      var t = e.r0 <= e.r ? 1 : -1;
      if (t < 0) {
        var n = e.r;
        e.r = e.r0, e.r0 = n;
      }
      var i = cy(e.r, r.r), a = uy(e.r0, r.r0);
      e.r = i, e.r0 = a;
      var o = i - a < 0;
      if (t < 0) {
        var n = e.r;
        e.r = e.r0, e.r0 = n;
      }
      return o;
    }
  }, sA = {
    cartesian2d: function(r, e, t, n, i, a, o, s, l) {
      var u = new et({
        shape: H({}, n),
        z2: 1
      });
      if (u.__dataIndex = t, u.name = "item", a) {
        var c = u.shape, h = i ? "height" : "width";
        c[h] = 0;
      }
      return u;
    },
    polar: function(r, e, t, n, i, a, o, s, l) {
      var u = !i && l ? uv : qr, c = new u({
        shape: n,
        z2: 1
      });
      c.name = "item";
      var h = QN(i);
      if (c.calculateTextPosition = bK(h, {
        isRoundCap: u === uv
      }), a) {
        var f = c.shape, d = i ? "r" : "endAngle", p = {};
        f[d] = i ? n.r0 : n.startAngle, p[d] = n[d], (s ? it : kt)(c, {
          shape: p
        }, a);
      }
      return c;
    }
  };
  function TK(r, e) {
    var t = r.get("realtimeSort", true), n = e.getBaseAxis();
    if (t && n.type === "category" && e.type === "cartesian2d") return {
      baseAxis: n,
      otherAxis: e.getOtherAxis(n)
    };
  }
  function lA(r, e, t, n, i, a, o, s) {
    var l, u;
    a ? (u = {
      x: n.x,
      width: n.width
    }, l = {
      y: n.y,
      height: n.height
    }) : (u = {
      y: n.y,
      height: n.height
    }, l = {
      x: n.x,
      width: n.width
    }), s || (o ? it : kt)(t, {
      shape: l
    }, e, i, null);
    var c = e ? r.baseAxis.model : null;
    (o ? it : kt)(t, {
      shape: u
    }, c, i);
  }
  function uA(r, e) {
    for (var t = 0; t < e.length; t++) if (!isFinite(r[e[t]])) return true;
    return false;
  }
  var AK = [
    "x",
    "y",
    "width",
    "height"
  ], IK = [
    "cx",
    "cy",
    "r",
    "startAngle",
    "endAngle"
  ], cA = {
    cartesian2d: function(r) {
      return !uA(r, AK);
    },
    polar: function(r) {
      return !uA(r, IK);
    }
  }, Sd = {
    cartesian2d: function(r, e, t) {
      var n = r.getItemLayout(e), i = t ? DK(t, n) : 0, a = n.width > 0 ? 1 : -1, o = n.height > 0 ? 1 : -1;
      return {
        x: n.x + a * i / 2,
        y: n.y + o * i / 2,
        width: n.width - a * i,
        height: n.height - o * i
      };
    },
    polar: function(r, e, t) {
      var n = r.getItemLayout(e);
      return {
        cx: n.cx,
        cy: n.cy,
        r0: n.r0,
        r: n.r,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        clockwise: n.clockwise
      };
    }
  };
  function MK(r) {
    return r.startAngle != null && r.endAngle != null && r.startAngle === r.endAngle;
  }
  function QN(r) {
    return /* @__PURE__ */ function(e) {
      var t = e ? "Arc" : "Angle";
      return function(n) {
        switch (n) {
          case "start":
          case "insideStart":
          case "end":
          case "insideEnd":
            return n + t;
          default:
            return n;
        }
      };
    }(r);
  }
  function hA(r, e, t, n, i, a, o, s) {
    var l = e.getItemVisual(t, "style");
    if (s) {
      if (!a.get("roundCap")) {
        var c = r.shape, h = Ss(n.getModel("itemStyle"), c, true);
        H(c, h), r.setShape(c);
      }
    } else {
      var u = n.get([
        "itemStyle",
        "borderRadius"
      ]) || 0;
      r.setShape("r", u);
    }
    r.useStyle(l);
    var f = n.getShallow("cursor");
    f && r.attr("cursor", f);
    var d = s ? o ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : o ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = lr(n);
    Sr(r, p, {
      labelFetcher: a,
      labelDataIndex: t,
      defaultText: du(a.getData(), t),
      inheritColor: l.fill,
      defaultOpacity: l.opacity,
      defaultOutsidePosition: d
    });
    var v = r.getTextContent();
    if (s && v) {
      var g = n.get([
        "label",
        "position"
      ]);
      r.textConfig.inside = g === "middle" ? true : null, SK(r, g === "outside" ? d : g, QN(o), n.get([
        "label",
        "rotate"
      ]));
    }
    mE(v, p, a.getRawValue(t), function(y) {
      return WN(e, y);
    });
    var m = n.getModel([
      "emphasis"
    ]);
    Nt(r, m.get("focus"), m.get("blurScope"), m.get("disabled")), br(r, n), MK(i) && (r.style.fill = "none", r.style.stroke = "none", D(r.states, function(y) {
      y.style && (y.style.fill = y.style.stroke = "none");
    }));
  }
  function DK(r, e) {
    var t = r.get([
      "itemStyle",
      "borderColor"
    ]);
    if (!t || t === "none") return 0;
    var n = r.get([
      "itemStyle",
      "borderWidth"
    ]) || 0, i = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), a = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
    return Math.min(n, i, a);
  }
  var PK = /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }(), fA = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "largeBar", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new PK();
    }, e.prototype.buildPath = function(t, n) {
      for (var i = n.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3) l[a] = u, l[o] = i[c + 2], s[a] = i[c + a], s[o] = i[c + o], t.rect(s[0], s[1], l[0], l[1]);
    }, e;
  }(Ue);
  function dA(r, e, t, n) {
    var i = r.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, o = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = r.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
    if (u) {
      var c = new fA({
        shape: {
          points: u
        },
        incremental: !!n,
        silent: true,
        z2: 0
      });
      c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, c.useStyle(l.getItemStyle()), e.add(c), t && t.push(c);
    }
    var h = new fA({
      shape: {
        points: i.getLayout("largePoints")
      },
      incremental: !!n,
      ignoreCoarsePointer: true,
      z2: 1
    });
    h.baseDimIdx = a, h.largeDataIndices = o, h.barWidth = s, e.add(h), h.useStyle(i.getVisual("style")), h.style.stroke = null, De(h).seriesIndex = r.seriesIndex, r.get("silent") || (h.on("mousedown", pA), h.on("mousemove", pA)), t && t.push(h);
  }
  var pA = L1(function(r) {
    var e = this, t = kK(e, r.offsetX, r.offsetY);
    De(e).dataIndex = t >= 0 ? t : null;
  }, 30, false);
  function kK(r, e, t) {
    for (var n = r.baseDimIdx, i = 1 - n, a = r.shape.points, o = r.largeDataIndices, s = [], l = [], u = r.barWidth, c = 0, h = a.length / 3; c < h; c++) {
      var f = c * 3;
      if (l[n] = u, l[i] = a[f + 2], s[n] = a[f + n], s[i] = a[f + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), e >= s[0] && e <= s[0] + l[0] && t >= s[1] && t <= s[1] + l[1]) return o[c];
    }
    return -1;
  }
  function JN(r, e, t) {
    if (Js(t, "cartesian2d")) {
      var n = e, i = t.getArea();
      return {
        x: r ? n.x : i.x,
        y: r ? i.y : n.y,
        width: r ? n.width : i.width,
        height: r ? i.height : n.height
      };
    } else {
      var i = t.getArea(), a = e;
      return {
        cx: i.cx,
        cy: i.cy,
        r0: r ? i.r0 : a.r0,
        r: r ? i.r : a.r,
        startAngle: r ? a.startAngle : 0,
        endAngle: r ? a.endAngle : Math.PI * 2
      };
    }
  }
  function LK(r, e, t) {
    var n = r.type === "polar" ? qr : et;
    return new n({
      shape: JN(e, t, r),
      silent: true,
      z2: 0
    });
  }
  function RK(r) {
    r.registerChartView(CK), r.registerSeriesModel(xK), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Le(iN, "bar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, aN("bar")), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, jN("bar")), r.registerAction({
      type: "changeAxisOrder",
      event: "changeAxisOrder",
      update: "update"
    }, function(e, t) {
      var n = e.componentType || "series";
      t.eachComponent({
        mainType: n,
        query: e
      }, function(i) {
        e.sortInfo && i.axis.setCategorySortInfo(e.sortInfo);
      });
    });
  }
  var vA = Math.PI * 2, wd = Math.PI / 180;
  function eO(r, e) {
    return er(r.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function tO(r, e) {
    var t = eO(r, e), n = r.get("center"), i = r.get("radius");
    X(i) || (i = [
      0,
      i
    ]);
    var a = Q(t.width, e.getWidth()), o = Q(t.height, e.getHeight()), s = Math.min(a, o), l = Q(i[0], s / 2), u = Q(i[1], s / 2), c, h, f = r.coordinateSystem;
    if (f) {
      var d = f.dataToPoint(n);
      c = d[0] || 0, h = d[1] || 0;
    } else X(n) || (n = [
      n,
      n
    ]), c = Q(n[0], a) + t.x, h = Q(n[1], o) + t.y;
    return {
      cx: c,
      cy: h,
      r0: l,
      r: u
    };
  }
  function EK(r, e, t) {
    e.eachSeriesByType(r, function(n) {
      var i = n.getData(), a = i.mapDimension("value"), o = eO(n, t), s = tO(n, t), l = s.cx, u = s.cy, c = s.r, h = s.r0, f = -n.get("startAngle") * wd, d = n.get("endAngle"), p = n.get("padAngle") * wd;
      d = d === "auto" ? f - vA : -d * wd;
      var v = n.get("minAngle") * wd, g = v + p, m = 0;
      i.each(a, function(L) {
        !isNaN(L) && m++;
      });
      var y = i.getSum(a), x = Math.PI / (y || m) * 2, _ = n.get("clockwise"), S = n.get("roseType"), b = n.get("stillShowZeroSum"), w = i.getDataExtent(a);
      w[0] = 0;
      var C = _ ? 1 : -1, T = [
        f,
        d
      ], A = C * p / 2;
      s1(T, !_), f = T[0], d = T[1];
      var M = rO(n);
      M.startAngle = f, M.endAngle = d, M.clockwise = _;
      var E = Math.abs(d - f), k = E, R = 0, N = f;
      if (i.setLayout({
        viewRect: o,
        r: c
      }), i.each(a, function(L, P) {
        var O;
        if (isNaN(L)) {
          i.setItemLayout(P, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: _,
            cx: l,
            cy: u,
            r0: h,
            r: S ? NaN : c
          });
          return;
        }
        S !== "area" ? O = y === 0 && b ? x : L * x : O = E / m, O < g ? (O = g, k -= g) : R += L;
        var F = N + C * O, B = 0, V = 0;
        p > O ? (B = N + C * O / 2, V = B) : (B = N + A, V = F - A), i.setItemLayout(P, {
          angle: O,
          startAngle: B,
          endAngle: V,
          clockwise: _,
          cx: l,
          cy: u,
          r0: h,
          r: S ? ht(L, w, [
            h,
            c
          ]) : c
        }), N = F;
      }), k < vA && m) if (k <= 1e-3) {
        var I = E / m;
        i.each(a, function(L, P) {
          if (!isNaN(L)) {
            var O = i.getItemLayout(P);
            O.angle = I;
            var F = 0, B = 0;
            I < p ? (F = f + C * (P + 1 / 2) * I, B = F) : (F = f + C * P * I + A, B = f + C * (P + 1) * I - A), O.startAngle = F, O.endAngle = B;
          }
        });
      } else x = k / R, N = f, i.each(a, function(L, P) {
        if (!isNaN(L)) {
          var O = i.getItemLayout(P), F = O.angle === g ? g : L * x, B = 0, V = 0;
          F < p ? (B = N + C * F / 2, V = B) : (B = N + A, V = N + C * F - A), O.startAngle = B, O.endAngle = V, N += C * F;
        }
      });
    });
  }
  var rO = tt();
  function Pf(r) {
    return {
      seriesType: r,
      reset: function(e, t) {
        var n = t.findComponents({
          mainType: "legend"
        });
        if (!(!n || !n.length)) {
          var i = e.getData();
          i.filterSelf(function(a) {
            for (var o = i.getName(a), s = 0; s < n.length; s++) if (!n[s].isSelected(o)) return false;
            return true;
          });
        }
      }
    };
  }
  var NK = Math.PI / 180;
  function gA(r, e, t, n, i, a, o, s, l, u) {
    if (r.length < 2) return;
    function c(v) {
      for (var g = v.rB, m = g * g, y = 0; y < v.list.length; y++) {
        var x = v.list[y], _ = Math.abs(x.label.y - t), S = n + x.len, b = S * S, w = Math.sqrt(Math.abs((1 - _ * _ / m) * b)), C = e + (w + x.len2) * i, T = C - x.label.x, A = x.targetTextWidth - T * i;
        nO(x, A, true), x.label.x = C;
      }
    }
    function h(v) {
      for (var g = {
        list: [],
        maxY: 0
      }, m = {
        list: [],
        maxY: 0
      }, y = 0; y < v.length; y++) if (v[y].labelAlignTo === "none") {
        var x = v[y], _ = x.label.y > t ? m : g, S = Math.abs(x.label.y - t);
        if (S >= _.maxY) {
          var b = x.label.x - e - x.len2 * i, w = n + x.len, C = Math.abs(b) < w ? Math.sqrt(S * S / (1 - b * b / w / w)) : w;
          _.rB = C, _.maxY = S;
        }
        _.list.push(x);
      }
      c(g), c(m);
    }
    for (var f = r.length, d = 0; d < f; d++) if (r[d].position === "outer" && r[d].labelAlignTo === "labelLine") {
      var p = r[d].label.x - u;
      r[d].linePoints[1][0] += p, r[d].label.x = u;
    }
    AN(r, l, l + o) && h(r);
  }
  function OK(r, e, t, n, i, a, o, s) {
    for (var l = [], u = [], c = Number.MAX_VALUE, h = -Number.MAX_VALUE, f = 0; f < r.length; f++) {
      var d = r[f].label;
      hy(r[f]) || (d.x < e ? (c = Math.min(c, d.x), l.push(r[f])) : (h = Math.max(h, d.x), u.push(r[f])));
    }
    for (var f = 0; f < r.length; f++) {
      var p = r[f];
      if (!hy(p) && p.linePoints) {
        if (p.labelStyleWidth != null) continue;
        var d = p.label, v = p.linePoints, g = void 0;
        p.labelAlignTo === "edge" ? d.x < e ? g = v[2][0] - p.labelDistance - o - p.edgeDistance : g = o + i - p.edgeDistance - v[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? d.x < e ? g = c - o - p.bleedMargin : g = o + i - h - p.bleedMargin : d.x < e ? g = d.x - o - p.bleedMargin : g = o + i - d.x - p.bleedMargin, p.targetTextWidth = g, nO(p, g);
      }
    }
    gA(u, e, t, n, 1, i, a, o, s, h), gA(l, e, t, n, -1, i, a, o, s, c);
    for (var f = 0; f < r.length; f++) {
      var p = r[f];
      if (!hy(p) && p.linePoints) {
        var d = p.label, v = p.linePoints, m = p.labelAlignTo === "edge", y = d.style.padding, x = y ? y[1] + y[3] : 0, _ = d.style.backgroundColor ? 0 : x, S = p.rect.width + _, b = v[1][0] - v[2][0];
        m ? d.x < e ? v[2][0] = o + p.edgeDistance + S + p.labelDistance : v[2][0] = o + i - p.edgeDistance - S - p.labelDistance : (d.x < e ? v[2][0] = d.x + p.labelDistance : v[2][0] = d.x - p.labelDistance, v[1][0] = v[2][0] + b), v[1][1] = v[2][1] = d.y;
      }
    }
  }
  function nO(r, e, t) {
    if (t === void 0 && (t = false), r.labelStyleWidth == null) {
      var n = r.label, i = n.style, a = r.rect, o = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, c = a.width + (o ? 0 : l);
      if (e < c || t) {
        var h = a.height;
        if (u && u.match("break")) {
          n.setStyle("backgroundColor", null), n.setStyle("width", e - l);
          var f = n.getBoundingRect();
          n.setStyle("width", Math.ceil(f.width)), n.setStyle("backgroundColor", o);
        } else {
          var d = e - l, p = e < c ? d : t ? d > r.unconstrainedWidth ? null : d : null;
          n.setStyle("width", p);
        }
        var v = n.getBoundingRect();
        a.width = v.width;
        var g = (n.style.margin || 0) + 2.1;
        a.height = v.height + g, a.y -= (a.height - h) / 2;
      }
    }
  }
  function hy(r) {
    return r.position === "center";
  }
  function FK(r) {
    var e = r.getData(), t = [], n, i, a = false, o = (r.get("minShowLabelAngle") || 0) * NK, s = e.getLayout("viewRect"), l = e.getLayout("r"), u = s.width, c = s.x, h = s.y, f = s.height;
    function d(b) {
      b.ignore = true;
    }
    function p(b) {
      if (!b.ignore) return true;
      for (var w in b.states) if (b.states[w].ignore === false) return true;
      return false;
    }
    e.each(function(b) {
      var w = e.getItemGraphicEl(b), C = w.shape, T = w.getTextContent(), A = w.getTextGuideLine(), M = e.getItemModel(b), E = M.getModel("label"), k = E.get("position") || M.get([
        "emphasis",
        "label",
        "position"
      ]), R = E.get("distanceToLabelLine"), N = E.get("alignTo"), I = Q(E.get("edgeDistance"), u), L = E.get("bleedMargin"), P = M.getModel("labelLine"), O = P.get("length");
      O = Q(O, u);
      var F = P.get("length2");
      if (F = Q(F, u), Math.abs(C.endAngle - C.startAngle) < o) {
        D(T.states, d), T.ignore = true, A && (D(A.states, d), A.ignore = true);
        return;
      }
      if (p(T)) {
        var B = (C.startAngle + C.endAngle) / 2, V = Math.cos(B), U = Math.sin(B), Y, q, me, Me;
        n = C.cx, i = C.cy;
        var re = k === "inside" || k === "inner";
        if (k === "center") Y = C.cx, q = C.cy, Me = "center";
        else {
          var J = (re ? (C.r + C.r0) / 2 * V : C.r * V) + n, le = (re ? (C.r + C.r0) / 2 * U : C.r * U) + i;
          if (Y = J + V * 3, q = le + U * 3, !re) {
            var te = J + V * (O + l - C.r), he = le + U * (O + l - C.r), Xe = te + (V < 0 ? -1 : 1) * F, Fe = he;
            N === "edge" ? Y = V < 0 ? c + I : c + u - I : Y = Xe + (V < 0 ? -R : R), q = Fe, me = [
              [
                J,
                le
              ],
              [
                te,
                he
              ],
              [
                Xe,
                Fe
              ]
            ];
          }
          Me = re ? "center" : N === "edge" ? V > 0 ? "right" : "left" : V > 0 ? "left" : "right";
        }
        var fe = Math.PI, Se = 0, Lt = E.get("rotate");
        if (nt(Lt)) Se = Lt * (fe / 180);
        else if (k === "center") Se = 0;
        else if (Lt === "radial" || Lt === true) {
          var z = V < 0 ? -B + fe : -B;
          Se = z;
        } else if (Lt === "tangential" && k !== "outside" && k !== "outer") {
          var $ = Math.atan2(V, U);
          $ < 0 && ($ = fe * 2 + $);
          var j = U > 0;
          j && ($ = fe + $), Se = $ - fe;
        }
        if (a = !!Se, T.x = Y, T.y = q, T.rotation = Se, T.setStyle({
          verticalAlign: "middle"
        }), re) {
          T.setStyle({
            align: Me
          });
          var Qe = T.states.select;
          Qe && (Qe.x += T.x, Qe.y += T.y);
        } else {
          var Te = T.getBoundingRect().clone();
          Te.applyTransform(T.getComputedTransform());
          var Ot = (T.style.margin || 0) + 2.1;
          Te.y -= Ot / 2, Te.height += Ot, t.push({
            label: T,
            labelLine: A,
            position: k,
            len: O,
            len2: F,
            minTurnAngle: P.get("minTurnAngle"),
            maxSurfaceAngle: P.get("maxSurfaceAngle"),
            surfaceNormal: new Ne(V, U),
            linePoints: me,
            textAlign: Me,
            labelDistance: R,
            labelAlignTo: N,
            edgeDistance: I,
            bleedMargin: L,
            rect: Te,
            unconstrainedWidth: Te.width,
            labelStyleWidth: T.style.width
          });
        }
        w.setTextConfig({
          inside: re
        });
      }
    }), !a && r.get("avoidLabelOverlap") && OK(t, n, i, l, u, f, c, h);
    for (var v = 0; v < t.length; v++) {
      var g = t[v], m = g.label, y = g.labelLine, x = isNaN(m.x) || isNaN(m.y);
      if (m) {
        m.setStyle({
          align: g.textAlign
        }), x && (D(m.states, d), m.ignore = true);
        var _ = m.states.select;
        _ && (_.x += m.x, _.y += m.y);
      }
      if (y) {
        var S = g.linePoints;
        x || !S ? (D(y.states, d), y.ignore = true) : (wN(S, g.minTurnAngle), oq(S, g.surfaceNormal, g.maxSurfaceAngle), y.setShape({
          points: S
        }), m.__hostTarget.textGuideLineConfig = {
          anchor: new Ne(S[0][0], S[0][1])
        });
      }
    }
  }
  var BK = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      a.z2 = 2;
      var o = new rt();
      return a.setTextContent(o), a.updateData(t, n, i, true), a;
    }
    return e.prototype.updateData = function(t, n, i, a) {
      var o = this, s = t.hostModel, l = t.getItemModel(n), u = l.getModel("emphasis"), c = t.getItemLayout(n), h = H(Ss(l.getModel("itemStyle"), c, true), c);
      if (isNaN(h.startAngle)) {
        o.setShape(h);
        return;
      }
      if (a) {
        o.setShape(h);
        var f = s.getShallow("animationType");
        s.ecModel.ssr ? (kt(o, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: n,
          isFrom: true
        }), o.originX = h.cx, o.originY = h.cy) : f === "scale" ? (o.shape.r = c.r0, kt(o, {
          shape: {
            r: c.r
          }
        }, s, n)) : i != null ? (o.setShape({
          startAngle: i,
          endAngle: i
        }), kt(o, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, n)) : (o.shape.endAngle = c.startAngle, it(o, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, n));
      } else li(o), it(o, {
        shape: h
      }, s, n);
      o.useStyle(t.getItemVisual(n, "style")), br(o, l);
      var d = (c.startAngle + c.endAngle) / 2, p = s.get("selectedOffset"), v = Math.cos(d) * p, g = Math.sin(d) * p, m = l.getShallow("cursor");
      m && o.attr("cursor", m), this._updateLabel(s, t, n), o.ensureState("emphasis").shape = H({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, Ss(u.getModel("itemStyle"), c)), H(o.ensureState("select"), {
        x: v,
        y: g,
        shape: Ss(l.getModel([
          "select",
          "itemStyle"
        ]), c)
      }), H(o.ensureState("blur"), {
        shape: Ss(l.getModel([
          "blur",
          "itemStyle"
        ]), c)
      });
      var y = o.getTextGuideLine(), x = o.getTextContent();
      y && H(y.ensureState("select"), {
        x: v,
        y: g
      }), H(x.ensureState("select"), {
        x: v,
        y: g
      }), Nt(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, n, i) {
      var a = this, o = n.getItemModel(i), s = o.getModel("labelLine"), l = n.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      Sr(a, lr(o), {
        labelFetcher: n.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: t.getFormattedLabel(i, "normal") || n.getName(i)
      });
      var h = a.getTextContent();
      a.setTextConfig({
        position: null,
        rotation: null
      }), h.attr({
        z2: 10
      });
      var f = t.get([
        "label",
        "position"
      ]);
      if (f !== "outside" && f !== "outer") a.removeTextGuideLine();
      else {
        var d = this.getTextGuideLine();
        d || (d = new Zr(), this.setTextGuideLine(d)), H1(this, Y1(o), {
          stroke: u,
          opacity: Li(s.get([
            "lineStyle",
            "opacity"
          ]), c, 1)
        });
      }
    }, e;
  }(qr), zK = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.ignoreLabelLineUpdate = true, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      var o = t.getData(), s = this._data, l = this.group, u;
      if (!s && o.count() > 0) {
        for (var c = o.getItemLayout(0), h = 1; isNaN(c && c.startAngle) && h < o.count(); ++h) c = o.getItemLayout(h);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && t.get("showEmptyCircle")) {
        var f = rO(t), d = new qr({
          shape: H(tO(t, i), f)
        });
        d.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = d, l.add(d);
      }
      o.diff(s).add(function(p) {
        var v = new BK(o, p, u);
        o.setItemGraphicEl(p, v), l.add(v);
      }).update(function(p, v) {
        var g = s.getItemGraphicEl(v);
        g.updateData(o, p, u), g.off("click"), l.add(g), o.setItemGraphicEl(p, g);
      }).remove(function(p) {
        var v = s.getItemGraphicEl(p);
        Mh(v, t, p);
      }).execute(), FK(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = o);
    }, e.prototype.dispose = function() {
    }, e.prototype.containPoint = function(t, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "pie", e;
  }(yt);
  function Wu(r, e, t) {
    e = X(e) && {
      coordDimensions: e
    } || H({
      encodeDefine: r.getEncode()
    }, e);
    var n = r.getSource(), i = Cf(n, e).dimensions, a = new Wr(i, r);
    return a.initData(n, t), a;
  }
  var kf = function() {
    function r(e, t) {
      this._getDataWithEncodedVisual = e, this._getRawData = t;
    }
    return r.prototype.getAllNames = function() {
      var e = this._getRawData();
      return e.mapArray(e.getName);
    }, r.prototype.containName = function(e) {
      var t = this._getRawData();
      return t.indexOfName(e) >= 0;
    }, r.prototype.indexOfName = function(e) {
      var t = this._getDataWithEncodedVisual();
      return t.indexOfName(e);
    }, r.prototype.getItemVisual = function(e, t) {
      var n = this._getDataWithEncodedVisual();
      return n.getItemVisual(e, t);
    }, r;
  }(), VK = tt(), $K = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new kf(ne(this.getData, this), ne(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.mergeOption = function() {
      r.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.getInitialData = function() {
      return Wu(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: Le(C1, this)
      });
    }, e.prototype.getDataParams = function(t) {
      var n = this.getData(), i = VK(n), a = i.seats;
      if (!a) {
        var o = [];
        n.each(n.mapDimension("value"), function(l) {
          o.push(l);
        }), a = i.seats = kH(o, n.hostModel.get("percentPrecision"));
      }
      var s = r.prototype.getDataParams.call(this, t);
      return s.percent = a[t] || 0, s.$vars.push("percent"), s;
    }, e.prototype._defaultLabelLine = function(t) {
      Bs(t, "labelLine", [
        "show"
      ]);
      var n = t.labelLine, i = t.emphasis.labelLine;
      n.show = n.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.type = "series.pie", e.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      center: [
        "50%",
        "50%"
      ],
      radius: [
        0,
        "75%"
      ],
      clockwise: true,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      minAngle: 0,
      minShowLabelAngle: 0,
      selectedOffset: 10,
      percentPrecision: 2,
      stillShowZeroSum: true,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        rotate: 0,
        show: true,
        overflow: "truncate",
        position: "outer",
        alignTo: "none",
        edgeDistance: "25%",
        bleedMargin: 10,
        distanceToLabelLine: 5
      },
      labelLine: {
        show: true,
        length: 15,
        length2: 15,
        smooth: false,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: true,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        hideOverlap: true
      },
      emphasis: {
        scale: true,
        scaleSize: 5
      },
      avoidLabelOverlap: true,
      animationType: "expansion",
      animationDuration: 1e3,
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, e;
  }(Tt);
  function GK(r) {
    return {
      seriesType: r,
      reset: function(e, t) {
        var n = e.getData();
        n.filterSelf(function(i) {
          var a = n.mapDimension("value"), o = n.get(a, i);
          return !(nt(o) && !isNaN(o) && o < 0);
        });
      }
    };
  }
  function WK(r) {
    r.registerChartView(zK), r.registerSeriesModel($K), w3("pie", r.registerAction), r.registerLayout(Le(EK, "pie")), r.registerProcessor(Pf("pie")), r.registerProcessor(GK("pie"));
  }
  var UK = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      return Aa(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, e.prototype.brushSelector = function(t, n, i) {
      return i.point(n.getItemLayout(t));
    }, e.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, e.type = "series.scatter", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      symbolSize: 10,
      large: false,
      largeThreshold: 2e3,
      itemStyle: {
        opacity: 0.8
      },
      emphasis: {
        scale: true
      },
      clip: true,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
    }, e;
  }(Tt), iO = 4, HK = /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }(), YK = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return e.prototype.getDefaultShape = function() {
      return new HK();
    }, e.prototype.reset = function() {
      this.notClear = false, this._off = 0;
    }, e.prototype.buildPath = function(t, n) {
      var i = n.points, a = n.size, o = this.symbolProxy, s = o.shape, l = t.getContext ? t.getContext() : t, u = l && a[0] < iO, c = this.softClipShape, h;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, h = this._off; h < i.length; ) {
        var f = i[h++], d = i[h++];
        isNaN(f) || isNaN(d) || c && !c.contain(f, d) || (s.x = f - a[0] / 2, s.y = d - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(t, s, true));
      }
      this.incremental && (this._off = h, this.notClear = true);
    }, e.prototype.afterBrush = function() {
      var t = this.shape, n = t.points, i = t.size, a = this._ctx, o = this.softClipShape, s;
      if (a) {
        for (s = this._off; s < n.length; ) {
          var l = n[s++], u = n[s++];
          isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = s, this.notClear = true);
      }
    }, e.prototype.findDataIndex = function(t, n) {
      for (var i = this.shape, a = i.points, o = i.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, h = a[c] - s / 2, f = a[c + 1] - l / 2;
        if (t >= h && n >= f && t <= h + s && n <= f + l) return u;
      }
      return -1;
    }, e.prototype.contain = function(t, n) {
      var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
      if (t = i[0], n = i[1], a.contain(t, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, false;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var n = this.shape, i = n.points, a = n.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, h = -1 / 0, f = 0; f < i.length; ) {
          var d = i[f++], p = i[f++];
          l = Math.min(d, l), c = Math.max(d, c), u = Math.min(p, u), h = Math.max(p, h);
        }
        t = this._rect = new Oe(l - o / 2, u - s / 2, c - l + o, h - u + s);
      }
      return t;
    }, e;
  }(Ue), XK = function() {
    function r() {
      this.group = new Ce();
    }
    return r.prototype.updateData = function(e, t) {
      this._clear();
      var n = this._create();
      n.setShape({
        points: e.getLayout("points")
      }), this._setCommon(n, e, t);
    }, r.prototype.updateLayout = function(e) {
      var t = e.getLayout("points");
      this.group.eachChild(function(n) {
        if (n.startIndex != null) {
          var i = (n.endIndex - n.startIndex) * 2, a = n.startIndex * 4 * 2;
          t = new Float32Array(t.buffer, a, i);
        }
        n.setShape("points", t), n.reset();
      });
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._clear();
    }, r.prototype.incrementalUpdate = function(e, t, n) {
      var i = this._newAdded[0], a = t.getLayout("points"), o = i && i.shape.points;
      if (o && o.length < 2e4) {
        var s = o.length, l = new Float32Array(s + a.length);
        l.set(o), l.set(a, s), i.endIndex = e.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = e.start, u.endIndex = e.end, u.incremental = true, u.setShape({
          points: a
        }), this._setCommon(u, t, n);
      }
    }, r.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, r.prototype._create = function() {
      var e = new YK({
        cursor: "default"
      });
      return e.ignoreCoarsePointer = true, this.group.add(e), this._newAdded.push(e), e;
    }, r.prototype._setCommon = function(e, t, n) {
      var i = t.hostModel;
      n = n || {};
      var a = t.getVisual("symbolSize");
      e.setShape("size", a instanceof Array ? a : [
        a,
        a
      ]), e.softClipShape = n.clipShape || null, e.symbolProxy = Xt(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor;
      var o = e.shape.size[0] < iO;
      e.useStyle(i.getModel("itemStyle").getItemStyle(o ? [
        "color",
        "shadowBlur",
        "shadowColor"
      ] : [
        "color"
      ]));
      var s = t.getVisual("style"), l = s && s.fill;
      l && e.setColor(l);
      var u = De(e);
      u.seriesIndex = i.seriesIndex, e.on("mousemove", function(c) {
        u.dataIndex = null;
        var h = e.hoverDataIdx;
        h >= 0 && (u.dataIndex = h + (e.startIndex || 0));
      });
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }(), qK = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = this._updateSymbolDraw(a, t);
      o.updateData(a, {
        clipShape: this._getClipShape(t)
      }), this._finished = true;
    }, e.prototype.incrementalPrepareRender = function(t, n, i) {
      var a = t.getData(), o = this._updateSymbolDraw(a, t);
      o.incrementalPrepareUpdate(a), this._finished = false;
    }, e.prototype.incrementalRender = function(t, n, i) {
      this._symbolDraw.incrementalUpdate(t, n.getData(), {
        clipShape: this._getClipShape(n)
      }), this._finished = t.end === n.getData().count();
    }, e.prototype.updateTransform = function(t, n, i) {
      var a = t.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4) return {
        update: true
      };
      var o = Df("").reset(t, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, e.prototype.eachRendered = function(t) {
      this._symbolDraw && this._symbolDraw.eachRendered(t);
    }, e.prototype._getClipShape = function(t) {
      if (t.get("clip", true)) {
        var n = t.coordinateSystem;
        return n && n.getArea && n.getArea(0.1);
      }
    }, e.prototype._updateSymbolDraw = function(t, n) {
      var i = this._symbolDraw, a = n.pipelineContext, o = a.large;
      return (!i || o !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = o ? new XK() : new If(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), i;
    }, e.prototype.remove = function(t, n) {
      this._symbolDraw && this._symbolDraw.remove(true), this._symbolDraw = null;
    }, e.prototype.dispose = function() {
    }, e.type = "scatter", e;
  }(yt), KK = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.type = "grid", e.dependencies = [
      "xAxis",
      "yAxis"
    ], e.layoutMode = "box", e.defaultOption = {
      show: false,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      containLabel: false,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, e;
  }(Ke), u_ = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", Yt).models[0];
    }, e.type = "cartesian2dAxis", e;
  }(Ke);
  qt(u_, Tf);
  var aO = {
    show: true,
    z: 0,
    inverse: false,
    name: "",
    nameLocation: "end",
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: "...",
      placeholder: "."
    },
    nameTextStyle: {},
    nameGap: 15,
    silent: false,
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: "#6E7079",
        width: 1,
        type: "solid"
      },
      symbol: [
        "none",
        "none"
      ],
      symbolSize: [
        10,
        15
      ]
    },
    axisTick: {
      show: true,
      inside: false,
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      inside: false,
      rotate: 0,
      showMinLabel: null,
      showMaxLabel: null,
      margin: 8,
      fontSize: 12
    },
    splitLine: {
      show: true,
      showMinLine: true,
      showMaxLine: true,
      lineStyle: {
        color: [
          "#E0E6F1"
        ],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: [
          "rgba(250,250,250,0.2)",
          "rgba(210,219,238,0.2)"
        ]
      }
    }
  }, ZK = Ee({
    boundaryGap: true,
    deduplication: null,
    splitLine: {
      show: false
    },
    axisTick: {
      alignWithLabel: false,
      interval: "auto"
    },
    axisLabel: {
      interval: "auto"
    }
  }, aO), J1 = Ee({
    boundaryGap: [
      0,
      0
    ],
    axisLine: {
      show: "auto"
    },
    axisTick: {
      show: "auto"
    },
    splitNumber: 5,
    minorTick: {
      show: false,
      splitNumber: 5,
      length: 3,
      lineStyle: {}
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: "#F4F7FD",
        width: 1
      }
    }
  }, aO), jK = Ee({
    splitNumber: 6,
    axisLabel: {
      showMinLabel: false,
      showMaxLabel: false,
      rich: {
        primary: {
          fontWeight: "bold"
        }
      }
    },
    splitLine: {
      show: false
    }
  }, J1), QK = ye({
    logBase: 10
  }, J1);
  const oO = {
    category: ZK,
    value: J1,
    time: jK,
    log: QK
  };
  var JK = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
  };
  function pu(r, e, t, n) {
    D(JK, function(i, a) {
      var o = Ee(Ee({}, oO[a], true), n, true), s = function(l) {
        G(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = e + "Axis." + a, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, h) {
          var f = Ph(this), d = f ? Fu(c) : {}, p = h.getTheme();
          Ee(c, p.get(a + "Axis")), Ee(c, this.getDefaultOption()), c.type = mA(c), f && co(c, d, f);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = r_.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var h = this.option;
          if (h.type === "category") return c ? h.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = e + "Axis." + a, u.defaultOption = o, u;
      }(t);
      r.registerComponentModel(s);
    }), r.registerSubTypeDefaulter(e + "Axis", mA);
  }
  function mA(r) {
    return r.type || (r.data ? "category" : "value");
  }
  var eZ = function() {
    function r(e) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "";
    }
    return r.prototype.getAxis = function(e) {
      return this._axes[e];
    }, r.prototype.getAxes = function() {
      return K(this._dimList, function(e) {
        return this._axes[e];
      }, this);
    }, r.prototype.getAxesByScale = function(e) {
      return e = e.toLowerCase(), ct(this.getAxes(), function(t) {
        return t.scale.type === e;
      });
    }, r.prototype.addAxis = function(e) {
      var t = e.dim;
      this._axes[t] = e, this._dimList.push(t);
    }, r;
  }(), c_ = [
    "x",
    "y"
  ];
  function yA(r) {
    return r.type === "interval" || r.type === "time";
  }
  var tZ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "cartesian2d", t.dimensions = c_, t;
    }
    return e.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var t = this.getAxis("x").scale, n = this.getAxis("y").scale;
      if (!(!yA(t) || !yA(n))) {
        var i = t.getExtent(), a = n.getExtent(), o = this.dataToPoint([
          i[0],
          a[0]
        ]), s = this.dataToPoint([
          i[1],
          a[1]
        ]), l = i[1] - i[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var c = (s[0] - o[0]) / l, h = (s[1] - o[1]) / u, f = o[0] - i[0] * c, d = o[1] - a[0] * h, p = this._transform = [
            c,
            0,
            0,
            h,
            f,
            d
          ];
          this._invTransform = Pu([], p);
        }
      }
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, e.prototype.containPoint = function(t) {
      var n = this.getAxis("x"), i = this.getAxis("y");
      return n.contain(n.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
    }, e.prototype.containData = function(t) {
      return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
    }, e.prototype.containZone = function(t, n) {
      var i = this.dataToPoint(t), a = this.dataToPoint(n), o = this.getArea(), s = new Oe(i[0], i[1], a[0] - i[0], a[1] - i[1]);
      return o.intersect(s);
    }, e.prototype.dataToPoint = function(t, n, i) {
      i = i || [];
      var a = t[0], o = t[1];
      if (this._transform && a != null && isFinite(a) && o != null && isFinite(o)) return xr(i, t, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(a, n)), i[1] = l.toGlobalCoord(l.dataToCoord(o, n)), i;
    }, e.prototype.clampData = function(t, n) {
      var i = this.getAxis("x").scale, a = this.getAxis("y").scale, o = i.getExtent(), s = a.getExtent(), l = i.parse(t[0]), u = a.parse(t[1]);
      return n = n || [], n[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), n[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), n;
    }, e.prototype.pointToData = function(t, n) {
      var i = [];
      if (this._invTransform) return xr(i, t, this._invTransform);
      var a = this.getAxis("x"), o = this.getAxis("y");
      return i[0] = a.coordToData(a.toLocalCoord(t[0]), n), i[1] = o.coordToData(o.toLocalCoord(t[1]), n), i;
    }, e.prototype.getOtherAxis = function(t) {
      return this.getAxis(t.dim === "x" ? "y" : "x");
    }, e.prototype.getArea = function(t) {
      t = t || 0;
      var n = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(n[0], n[1]) - t, o = Math.min(i[0], i[1]) - t, s = Math.max(n[0], n[1]) - a + t, l = Math.max(i[0], i[1]) - o + t;
      return new Oe(a, o, s, l);
    }, e;
  }(eZ), rZ = function(r) {
    G(e, r);
    function e(t, n, i, a, o) {
      var s = r.call(this, t, n, i) || this;
      return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.getGlobalExtent = function(t) {
      var n = this.getExtent();
      return n[0] = this.toGlobalCoord(n[0]), n[1] = this.toGlobalCoord(n[1]), t && n[0] > n[1] && n.reverse(), n;
    }, e.prototype.pointToData = function(t, n) {
      return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), n);
    }, e.prototype.setCategorySortInfo = function(t) {
      if (this.type !== "category") return false;
      this.model.option.categorySortInfo = t, this.scale.setSortInfo(t);
    }, e;
  }(hi);
  function h_(r, e, t) {
    t = t || {};
    var n = r.coordinateSystem, i = e.axis, a = {}, o = i.getAxesOnZeroOf()[0], s = i.position, l = o ? "onZero" : s, u = i.dim, c = n.getRect(), h = [
      c.x,
      c.x + c.width,
      c.y,
      c.y + c.height
    ], f = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    }, d = e.get("offset") || 0, p = u === "x" ? [
      h[2] - d,
      h[3] + d
    ] : [
      h[0] - d,
      h[1] + d
    ];
    if (o) {
      var v = o.toGlobalCoord(o.dataToCoord(0));
      p[f.onZero] = Math.max(Math.min(v, p[1]), p[0]);
    }
    a.position = [
      u === "y" ? p[f[l]] : h[0],
      u === "x" ? p[f[l]] : h[3]
    ], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
    var g = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    a.labelDirection = a.tickDirection = a.nameDirection = g[s], a.labelOffset = o ? p[f[s]] - p[f.onZero] : 0, e.get([
      "axisTick",
      "inside"
    ]) && (a.tickDirection = -a.tickDirection), vr(t.labelInside, e.get([
      "axisLabel",
      "inside"
    ])) && (a.labelDirection = -a.labelDirection);
    var m = e.get([
      "axisLabel",
      "rotate"
    ]);
    return a.labelRotate = l === "top" ? -m : m, a.z2 = 1, a;
  }
  function xA(r) {
    return r.get("coordinateSystem") === "cartesian2d";
  }
  function _A(r) {
    var e = {
      xAxisModel: null,
      yAxisModel: null
    };
    return D(e, function(t, n) {
      var i = n.replace(/Model$/, ""), a = r.getReferringComponents(i, Yt).models[0];
      e[n] = a;
    }), e;
  }
  var fy = Math.log;
  function sO(r, e, t) {
    var n = xa.prototype, i = n.getTicks.call(t), a = n.getTicks.call(t, true), o = i.length - 1, s = n.getInterval.call(t), l = cN(r, e), u = l.extent, c = l.fixMin, h = l.fixMax;
    if (r.type === "log") {
      var f = fy(r.base);
      u = [
        fy(u[0]) / f,
        fy(u[1]) / f
      ];
    }
    r.setExtent(u[0], u[1]), r.calcNiceExtent({
      splitNumber: o,
      fixMin: c,
      fixMax: h
    });
    var d = n.getExtent.call(r);
    c && (u[0] = d[0]), h && (u[1] = d[1]);
    var p = n.getInterval.call(r), v = u[0], g = u[1];
    if (c && h) p = (g - v) / o;
    else if (c) for (g = u[0] + p * o; g < u[1] && isFinite(g) && isFinite(u[1]); ) p = jm(p), g = u[0] + p * o;
    else if (h) for (v = u[1] - p * o; v > u[0] && isFinite(v) && isFinite(u[0]); ) p = jm(p), v = u[1] - p * o;
    else {
      var m = r.getTicks().length - 1;
      m > o && (p = jm(p));
      var y = p * o;
      g = Math.ceil(u[1] / p) * p, v = Bt(g - y), v < 0 && u[0] >= 0 ? (v = 0, g = Bt(y)) : g > 0 && u[1] <= 0 && (g = 0, v = -Bt(y));
    }
    var x = (i[0].value - a[0].value) / s, _ = (i[o].value - a[o].value) / s;
    n.setExtent.call(r, v + p * x, g + p * _), n.setInterval.call(r, p), (x || _) && n.setNiceExtent.call(r, v + p, g - p);
  }
  var nZ = function() {
    function r(e, t, n) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = true, this.dimensions = c_, this._initCartesian(e, t, n), this.model = e;
    }
    return r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.update = function(e, t) {
      var n = this._axesMap;
      this._updateScale(e, this.model);
      function i(o) {
        var s, l = je(o), u = l.length;
        if (u) {
          for (var c = [], h = u - 1; h >= 0; h--) {
            var f = +l[h], d = o[f], p = d.model, v = d.scale;
            n_(v) && p.get("alignTicks") && p.get("interval") == null ? c.push(d) : (fu(v, p), n_(v) && (s = d));
          }
          c.length && (s || (s = c.pop(), fu(s.scale, s.model)), D(c, function(g) {
            sO(g.scale, g.model, s.scale);
          }));
        }
      }
      i(n.x), i(n.y);
      var a = {};
      D(n.x, function(o) {
        bA(n, "y", o, a);
      }), D(n.y, function(o) {
        bA(n, "x", o, a);
      }), this.resize(this.model, t);
    }, r.prototype.resize = function(e, t, n) {
      var i = e.getBoxLayoutParams(), a = !n && e.get("containLabel"), o = er(i, {
        width: t.getWidth(),
        height: t.getHeight()
      });
      this._rect = o;
      var s = this._axesList;
      l(), a && (D(s, function(u) {
        if (!u.model.get([
          "axisLabel",
          "inside"
        ])) {
          var c = F7(u);
          if (c) {
            var h = u.isHorizontal() ? "height" : "width", f = u.model.get([
              "axisLabel",
              "margin"
            ]);
            o[h] -= c[h] + f, u.position === "top" ? o.y += c.height + f : u.position === "left" && (o.x += c.width + f);
          }
        }
      }), l()), D(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        D(s, function(u) {
          var c = u.isHorizontal(), h = c ? [
            0,
            o.width
          ] : [
            0,
            o.height
          ], f = u.inverse ? 1 : 0;
          u.setExtent(h[f], h[1 - f]), iZ(u, c ? o.x : o.y);
        });
      }
    }, r.prototype.getAxis = function(e, t) {
      var n = this._axesMap[e];
      if (n != null) return n[t || 0];
    }, r.prototype.getAxes = function() {
      return this._axesList.slice();
    }, r.prototype.getCartesian = function(e, t) {
      if (e != null && t != null) {
        var n = "x" + e + "y" + t;
        return this._coordsMap[n];
      }
      _e(e) && (t = e.yAxisIndex, e = e.xAxisIndex);
      for (var i = 0, a = this._coordsList; i < a.length; i++) if (a[i].getAxis("x").index === e || a[i].getAxis("y").index === t) return a[i];
    }, r.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, r.prototype.convertToPixel = function(e, t, n) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null;
    }, r.prototype.convertFromPixel = function(e, t, n) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null;
    }, r.prototype._findConvertTarget = function(e) {
      var t = e.seriesModel, n = e.xAxisModel || t && t.getReferringComponents("xAxis", Yt).models[0], i = e.yAxisModel || t && t.getReferringComponents("yAxis", Yt).models[0], a = e.gridModel, o = this._coordsList, s, l;
      if (t) s = t.coordinateSystem, Be(o, s) < 0 && (s = null);
      else if (n && i) s = this.getCartesian(n.componentIndex, i.componentIndex);
      else if (n) l = this.getAxis("x", n.componentIndex);
      else if (i) l = this.getAxis("y", i.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, r.prototype.containPoint = function(e) {
      var t = this._coordsList[0];
      if (t) return t.containPoint(e);
    }, r.prototype._initCartesian = function(e, t, n) {
      var i = this, a = this, o = {
        left: false,
        right: false,
        top: false,
        bottom: false
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (t.eachComponent("xAxis", u("x"), this), t.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, D(s.x, function(c, h) {
        D(s.y, function(f, d) {
          var p = "x" + h + "y" + d, v = new tZ(p);
          v.master = i, v.model = e, i._coordsMap[p] = v, i._coordsList.push(v), v.addAxis(c), v.addAxis(f);
        });
      });
      function u(c) {
        return function(h, f) {
          if (dy(h, e)) {
            var d = h.get("position");
            c === "x" ? d !== "top" && d !== "bottom" && (d = o.bottom ? "top" : "bottom") : d !== "left" && d !== "right" && (d = o.left ? "right" : "left"), o[d] = true;
            var p = new rZ(c, bg(h), [
              0,
              0
            ], h.get("type"), d), v = p.type === "category";
            p.onBand = v && h.get("boundaryGap"), p.inverse = h.get("inverse"), h.axis = p, p.model = h, p.grid = a, p.index = f, a._axesList.push(p), s[c][f] = p, l[c]++;
          }
        };
      }
    }, r.prototype._updateScale = function(e, t) {
      D(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var a = i.model.get("categorySortInfo");
          i.scale.setSortInfo(a);
        }
      }), e.eachSeries(function(i) {
        if (xA(i)) {
          var a = _A(i), o = a.xAxisModel, s = a.yAxisModel;
          if (!dy(o, t) || !dy(s, t)) return;
          var l = this.getCartesian(o.componentIndex, s.componentIndex), u = i.getData(), c = l.getAxis("x"), h = l.getAxis("y");
          n(u, c), n(u, h);
        }
      }, this);
      function n(i, a) {
        D(av(i, a.dim), function(o) {
          a.scale.unionExtentFromData(i, o);
        });
      }
    }, r.prototype.getTooltipAxes = function(e) {
      var t = [], n = [];
      return D(this.getCartesians(), function(i) {
        var a = e != null && e !== "auto" ? i.getAxis(e) : i.getBaseAxis(), o = i.getOtherAxis(a);
        Be(t, a) < 0 && t.push(a), Be(n, o) < 0 && n.push(o);
      }), {
        baseAxes: t,
        otherAxes: n
      };
    }, r.create = function(e, t) {
      var n = [];
      return e.eachComponent("grid", function(i, a) {
        var o = new r(i, e, t);
        o.name = "grid_" + a, o.resize(i, t, true), i.coordinateSystem = o, n.push(o);
      }), e.eachSeries(function(i) {
        if (xA(i)) {
          var a = _A(i), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel(), u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex);
        }
      }), n;
    }, r.dimensions = c_, r;
  }();
  function dy(r, e) {
    return r.getCoordSysModel() === e;
  }
  function bA(r, e, t, n) {
    t.getAxesOnZeroOf = function() {
      return a ? [
        a
      ] : [];
    };
    var i = r[e], a, o = t.model, s = o.get([
      "axisLine",
      "onZero"
    ]), l = o.get([
      "axisLine",
      "onZeroAxisIndex"
    ]);
    if (!s) return;
    if (l != null) SA(i[l]) && (a = i[l]);
    else for (var u in i) if (i.hasOwnProperty(u) && SA(i[u]) && !n[c(i[u])]) {
      a = i[u];
      break;
    }
    a && (n[c(a)] = true);
    function c(h) {
      return h.dim + "_" + h.index;
    }
  }
  function SA(r) {
    return r && r.type !== "category" && r.type !== "time" && O7(r);
  }
  function iZ(r, e) {
    var t = r.getExtent(), n = t[0] + t[1];
    r.toGlobalCoord = r.dim === "x" ? function(i) {
      return i + e;
    } : function(i) {
      return n - i + e;
    }, r.toLocalCoord = r.dim === "x" ? function(i) {
      return i - e;
    } : function(i) {
      return n - i + e;
    };
  }
  var ja = Math.PI, Ur = function() {
    function r(e, t) {
      this.group = new Ce(), this.opt = t, this.axisModel = e, ye(t, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true,
        handleAutoShown: function() {
          return true;
        }
      });
      var n = new Ce({
        x: t.position[0],
        y: t.position[1],
        rotation: t.rotation
      });
      n.updateTransform(), this._transformGroup = n;
    }
    return r.prototype.hasBuilder = function(e) {
      return !!wA[e];
    }, r.prototype.add = function(e) {
      wA[e](this.opt, this.axisModel, this.group, this._transformGroup);
    }, r.prototype.getGroup = function() {
      return this.group;
    }, r.innerTextLayout = function(e, t, n) {
      var i = CR(t - e), a, o;
      return Ch(i) ? (o = n > 0 ? "top" : "bottom", a = "center") : Ch(i - ja) ? (o = n > 0 ? "bottom" : "top", a = "center") : (o = "middle", i > 0 && i < ja ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: a,
        textVerticalAlign: o
      };
    }, r.makeAxisEventDataBase = function(e) {
      var t = {
        componentType: e.mainType,
        componentIndex: e.componentIndex
      };
      return t[e.mainType + "Index"] = e.componentIndex, t;
    }, r.isLabelSilent = function(e) {
      var t = e.get("tooltip");
      return e.get("silent") || !(e.get("triggerEvent") || t && t.show);
    }, r;
  }(), wA = {
    axisLine: function(r, e, t, n) {
      var i = e.get([
        "axisLine",
        "show"
      ]);
      if (i === "auto" && r.handleAutoShown && (i = r.handleAutoShown("axisLine")), !!i) {
        var a = e.axis.getExtent(), o = n.transform, s = [
          a[0],
          0
        ], l = [
          a[1],
          0
        ], u = s[0] > l[0];
        o && (xr(s, s, o), xr(l, l, o));
        var c = H({
          lineCap: "round"
        }, e.getModel([
          "axisLine",
          "lineStyle"
        ]).getLineStyle()), h = new ir({
          shape: {
            x1: s[0],
            y1: s[1],
            x2: l[0],
            y2: l[1]
          },
          style: c,
          strokeContainThreshold: r.strokeContainThreshold || 5,
          silent: true,
          z2: 1
        });
        uu(h.shape, h.style.lineWidth), h.anid = "line", t.add(h);
        var f = e.get([
          "axisLine",
          "symbol"
        ]);
        if (f != null) {
          var d = e.get([
            "axisLine",
            "symbolSize"
          ]);
          ee(f) && (f = [
            f,
            f
          ]), (ee(d) || nt(d)) && (d = [
            d,
            d
          ]);
          var p = js(e.get([
            "axisLine",
            "symbolOffset"
          ]) || 0, d), v = d[0], g = d[1];
          D([
            {
              rotate: r.rotation + Math.PI / 2,
              offset: p[0],
              r: 0
            },
            {
              rotate: r.rotation - Math.PI / 2,
              offset: p[1],
              r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
            }
          ], function(m, y) {
            if (f[y] !== "none" && f[y] != null) {
              var x = Xt(f[y], -v / 2, -g / 2, v, g, c.stroke, true), _ = m.r + m.offset, S = u ? l : s;
              x.attr({
                rotation: m.rotate,
                x: S[0] + _ * Math.cos(r.rotation),
                y: S[1] - _ * Math.sin(r.rotation),
                silent: true,
                z2: 11
              }), t.add(x);
            }
          });
        }
      }
    },
    axisTickLabel: function(r, e, t, n) {
      var i = sZ(t, n, e, r), a = uZ(t, n, e, r);
      if (oZ(e, a, i), lZ(t, n, e, r.tickDirection), e.get([
        "axisLabel",
        "hideOverlap"
      ])) {
        var o = CN(K(a, function(s) {
          return {
            label: s,
            priority: s.z2,
            defaultAttr: {
              ignore: s.ignore
            }
          };
        }));
        IN(o);
      }
    },
    axisName: function(r, e, t, n) {
      var i = vr(r.axisName, e.get("name"));
      if (i) {
        var a = e.get("nameLocation"), o = r.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = e.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, h = [
          a === "start" ? u[0] - c * l : a === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
          TA(a) ? r.labelOffset + o * l : 0
        ], f, d = e.get("nameRotate");
        d != null && (d = d * ja / 180);
        var p;
        TA(a) ? f = Ur.innerTextLayout(r.rotation, d ?? r.rotation, o) : (f = aZ(r.rotation, a, d || 0, u), p = r.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(f.rotation)), !isFinite(p) && (p = null)));
        var v = s.getFont(), g = e.get("nameTruncate", true) || {}, m = g.ellipsis, y = vr(r.nameTruncateMaxWidth, g.maxWidth, p), x = new rt({
          x: h[0],
          y: h[1],
          rotation: f.rotation,
          silent: Ur.isLabelSilent(e),
          style: wt(s, {
            text: i,
            font: v,
            overflow: "truncate",
            width: y,
            ellipsis: m,
            fill: s.getTextColor() || e.get([
              "axisLine",
              "lineStyle",
              "color"
            ]),
            align: s.get("align") || f.textAlign,
            verticalAlign: s.get("verticalAlign") || f.textVerticalAlign
          }),
          z2: 1
        });
        if (Ks({
          el: x,
          componentModel: e,
          itemName: i
        }), x.__fullText = i, x.anid = "name", e.get("triggerEvent")) {
          var _ = Ur.makeAxisEventDataBase(e);
          _.targetType = "axisName", _.name = i, De(x).eventData = _;
        }
        n.add(x), x.updateTransform(), t.add(x), x.decomposeTransform();
      }
    }
  };
  function aZ(r, e, t, n) {
    var i = CR(t - r), a, o, s = n[0] > n[1], l = e === "start" && !s || e !== "start" && s;
    return Ch(i - ja / 2) ? (o = l ? "bottom" : "top", a = "center") : Ch(i - ja * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", i < ja * 1.5 && i > ja / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
      rotation: i,
      textAlign: a,
      textVerticalAlign: o
    };
  }
  function oZ(r, e, t) {
    if (!hN(r.axis)) {
      var n = r.get([
        "axisLabel",
        "showMinLabel"
      ]), i = r.get([
        "axisLabel",
        "showMaxLabel"
      ]);
      e = e || [], t = t || [];
      var a = e[0], o = e[1], s = e[e.length - 1], l = e[e.length - 2], u = t[0], c = t[1], h = t[t.length - 1], f = t[t.length - 2];
      n === false ? (wn(a), wn(u)) : CA(a, o) && (n ? (wn(o), wn(c)) : (wn(a), wn(u))), i === false ? (wn(s), wn(h)) : CA(l, s) && (i ? (wn(l), wn(f)) : (wn(s), wn(h)));
    }
  }
  function wn(r) {
    r && (r.ignore = true);
  }
  function CA(r, e) {
    var t = r && r.getBoundingRect().clone(), n = e && e.getBoundingRect().clone();
    if (!(!t || !n)) {
      var i = Yv([]);
      return qs(i, i, -r.rotation), t.applyTransform(sa([], i, r.getLocalTransform())), n.applyTransform(sa([], i, e.getLocalTransform())), t.intersect(n);
    }
  }
  function TA(r) {
    return r === "middle" || r === "center";
  }
  function lO(r, e, t, n, i) {
    for (var a = [], o = [], s = [], l = 0; l < r.length; l++) {
      var u = r[l].coord;
      o[0] = u, o[1] = 0, s[0] = u, s[1] = t, e && (xr(o, o, e), xr(s, s, e));
      var c = new ir({
        shape: {
          x1: o[0],
          y1: o[1],
          x2: s[0],
          y2: s[1]
        },
        style: n,
        z2: 2,
        autoBatch: true,
        silent: true
      });
      uu(c.shape, c.style.lineWidth), c.anid = i + "_" + r[l].tickValue, a.push(c);
    }
    return a;
  }
  function sZ(r, e, t, n) {
    var i = t.axis, a = t.getModel("axisTick"), o = a.get("show");
    if (o === "auto" && n.handleAutoShown && (o = n.handleAutoShown("axisTick")), !(!o || i.scale.isBlank())) {
      for (var s = a.getModel("lineStyle"), l = n.tickDirection * a.get("length"), u = i.getTicksCoords(), c = lO(u, e.transform, l, ye(s.getLineStyle(), {
        stroke: t.get([
          "axisLine",
          "lineStyle",
          "color"
        ])
      }), "ticks"), h = 0; h < c.length; h++) r.add(c[h]);
      return c;
    }
  }
  function lZ(r, e, t, n) {
    var i = t.axis, a = t.getModel("minorTick");
    if (!(!a.get("show") || i.scale.isBlank())) {
      var o = i.getMinorTicksCoords();
      if (o.length) for (var s = a.getModel("lineStyle"), l = n * a.get("length"), u = ye(s.getLineStyle(), ye(t.getModel("axisTick").getLineStyle(), {
        stroke: t.get([
          "axisLine",
          "lineStyle",
          "color"
        ])
      })), c = 0; c < o.length; c++) for (var h = lO(o[c], e.transform, l, u, "minorticks_" + c), f = 0; f < h.length; f++) r.add(h[f]);
    }
  }
  function uZ(r, e, t, n) {
    var i = t.axis, a = vr(n.axisLabelShow, t.get([
      "axisLabel",
      "show"
    ]));
    if (!(!a || i.scale.isBlank())) {
      var o = t.getModel("axisLabel"), s = o.get("margin"), l = i.getViewLabels(), u = (vr(n.labelRotate, o.get("rotate")) || 0) * ja / 180, c = Ur.innerTextLayout(n.rotation, u, n.labelDirection), h = t.getCategories && t.getCategories(true), f = [], d = Ur.isLabelSilent(t), p = t.get("triggerEvent");
      return D(l, function(v, g) {
        var m = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(v.tickValue) : v.tickValue, y = v.formattedLabel, x = v.rawLabel, _ = o;
        if (h && h[m]) {
          var S = h[m];
          _e(S) && S.textStyle && (_ = new ft(S.textStyle, o, t.ecModel));
        }
        var b = _.getTextColor() || t.get([
          "axisLine",
          "lineStyle",
          "color"
        ]), w = i.dataToCoord(m), C = _.getShallow("align", true) || c.textAlign, T = Pe(_.getShallow("alignMinLabel", true), C), A = Pe(_.getShallow("alignMaxLabel", true), C), M = _.getShallow("verticalAlign", true) || _.getShallow("baseline", true) || c.textVerticalAlign, E = Pe(_.getShallow("verticalAlignMinLabel", true), M), k = Pe(_.getShallow("verticalAlignMaxLabel", true), M), R = new rt({
          x: w,
          y: n.labelOffset + n.labelDirection * s,
          rotation: c.rotation,
          silent: d,
          z2: 10 + (v.level || 0),
          style: wt(_, {
            text: y,
            align: g === 0 ? T : g === l.length - 1 ? A : C,
            verticalAlign: g === 0 ? E : g === l.length - 1 ? k : M,
            fill: ge(b) ? b(i.type === "category" ? x : i.type === "value" ? m + "" : m, g) : b
          })
        });
        if (R.anid = "label_" + m, Ks({
          el: R,
          componentModel: t,
          itemName: y,
          formatterParamsExtra: {
            isTruncated: function() {
              return R.isTruncated;
            },
            value: x,
            tickIndex: g
          }
        }), p) {
          var N = Ur.makeAxisEventDataBase(t);
          N.targetType = "axisLabel", N.value = x, N.tickIndex = g, i.type === "category" && (N.dataIndex = m), De(R).eventData = N;
        }
        e.add(R), R.updateTransform(), f.push(R), r.add(R), R.decomposeTransform();
      }), f;
    }
  }
  function cZ(r, e) {
    var t = {
      axesInfo: {},
      seriesInvolved: false,
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    return hZ(t, r, e), t.seriesInvolved && dZ(t, r), t;
  }
  function hZ(r, e, t) {
    var n = e.getComponent("tooltip"), i = e.getComponent("axisPointer"), a = i.get("link", true) || [], o = [];
    D(t.getCoordinateSystems(), function(s) {
      if (!s.axisPointerEnabled) return;
      var l = zh(s.model), u = r.coordSysAxesInfo[l] = {};
      r.coordSysMap[l] = s;
      var c = s.model, h = c.getModel("tooltip", n);
      if (D(s.getAxes(), Le(v, false, null)), s.getTooltipAxes && n && h.get("show")) {
        var f = h.get("trigger") === "axis", d = h.get([
          "axisPointer",
          "type"
        ]) === "cross", p = s.getTooltipAxes(h.get([
          "axisPointer",
          "axis"
        ]));
        (f || d) && D(p.baseAxes, Le(v, d ? "cross" : true, f)), d && D(p.otherAxes, Le(v, "cross", false));
      }
      function v(g, m, y) {
        var x = y.model.getModel("axisPointer", i), _ = x.get("show");
        if (!(!_ || _ === "auto" && !g && !f_(x))) {
          m == null && (m = x.get("triggerTooltip")), x = g ? fZ(y, h, i, e, g, m) : x;
          var S = x.get("snap"), b = x.get("triggerEmphasis"), w = zh(y.model), C = m || S || y.type === "category", T = r.axesInfo[w] = {
            key: w,
            axis: y,
            coordSys: s,
            axisPointerModel: x,
            triggerTooltip: m,
            triggerEmphasis: b,
            involveSeries: C,
            snap: S,
            useHandle: f_(x),
            seriesModels: [],
            linkGroup: null
          };
          u[w] = T, r.seriesInvolved = r.seriesInvolved || C;
          var A = pZ(a, y);
          if (A != null) {
            var M = o[A] || (o[A] = {
              axesInfo: {}
            });
            M.axesInfo[w] = T, M.mapper = a[A].mapper, T.linkGroup = M;
          }
        }
      }
    });
  }
  function fZ(r, e, t, n, i, a) {
    var o = e.getModel("axisPointer"), s = [
      "type",
      "snap",
      "lineStyle",
      "shadowStyle",
      "label",
      "animation",
      "animationDurationUpdate",
      "animationEasingUpdate",
      "z"
    ], l = {};
    D(s, function(f) {
      l[f] = be(o.get(f));
    }), l.snap = r.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
    var u = l.label || (l.label = {});
    if (u.show == null && (u.show = false), i === "cross") {
      var c = o.get([
        "label",
        "show"
      ]);
      if (u.show = c ?? true, !a) {
        var h = l.lineStyle = o.get("crossStyle");
        h && ye(u, h.textStyle);
      }
    }
    return r.model.getModel("axisPointer", new ft(l, t, n));
  }
  function dZ(r, e) {
    e.eachSeries(function(t) {
      var n = t.coordinateSystem, i = t.get([
        "tooltip",
        "trigger"
      ], true), a = t.get([
        "tooltip",
        "show"
      ], true);
      !n || i === "none" || i === false || i === "item" || a === false || t.get([
        "axisPointer",
        "show"
      ], true) === false || D(r.coordSysAxesInfo[zh(n.model)], function(o) {
        var s = o.axis;
        n.getAxis(s.dim) === s && (o.seriesModels.push(t), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += t.getData().count());
      });
    });
  }
  function pZ(r, e) {
    for (var t = e.model, n = e.dim, i = 0; i < r.length; i++) {
      var a = r[i] || {};
      if (py(a[n + "AxisId"], t.id) || py(a[n + "AxisIndex"], t.componentIndex) || py(a[n + "AxisName"], t.name)) return i;
    }
  }
  function py(r, e) {
    return r === "all" || X(r) && Be(r, e) >= 0 || r === e;
  }
  function vZ(r) {
    var e = eS(r);
    if (e) {
      var t = e.axisPointerModel, n = e.axis.scale, i = t.option, a = t.get("status"), o = t.get("value");
      o != null && (o = n.parse(o));
      var s = f_(t);
      a == null && (i.status = s ? "show" : "hide");
      var l = n.getExtent().slice();
      l[0] > l[1] && l.reverse(), (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), i.value = o, s && (i.status = e.axis.scale.isBlank() ? "hide" : "show");
    }
  }
  function eS(r) {
    var e = (r.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return e && e.axesInfo[zh(r)];
  }
  function gZ(r) {
    var e = eS(r);
    return e && e.axisPointerModel;
  }
  function f_(r) {
    return !!r.get([
      "handle",
      "show"
    ]);
  }
  function zh(r) {
    return r.type + "||" + r.id;
  }
  var AA = {}, el = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this.axisPointerClass && vZ(t), r.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, i, true);
    }, e.prototype.updateAxisPointer = function(t, n, i, a) {
      this._doUpdateAxisPointerClass(t, i, false);
    }, e.prototype.remove = function(t, n) {
      var i = this._axisPointer;
      i && i.remove(n);
    }, e.prototype.dispose = function(t, n) {
      this._disposeAxisPointer(n), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._doUpdateAxisPointerClass = function(t, n, i) {
      var a = e.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = gZ(t);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(t, o, n, i) : this._disposeAxisPointer(n);
      }
    }, e.prototype._disposeAxisPointer = function(t) {
      this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null;
    }, e.registerAxisPointerClass = function(t, n) {
      AA[t] = n;
    }, e.getAxisPointerClass = function(t) {
      return t && AA[t];
    }, e.type = "axis", e;
  }(Rt), d_ = tt();
  function uO(r, e, t, n) {
    var i = t.axis;
    if (!i.scale.isBlank()) {
      var a = t.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = n.coordinateSystem.getRect(), u = i.getTicksCoords({
        tickModel: a,
        clamp: true
      });
      if (u.length) {
        var c = s.length, h = d_(r).splitAreaColors, f = ce(), d = 0;
        if (h) for (var p = 0; p < u.length; p++) {
          var v = h.get(u[p].tickValue);
          if (v != null) {
            d = (v + (c - 1) * p) % c;
            break;
          }
        }
        var g = i.toGlobalCoord(u[0].coord), m = o.getAreaStyle();
        s = X(s) ? s : [
          s
        ];
        for (var p = 1; p < u.length; p++) {
          var y = i.toGlobalCoord(u[p].coord), x = void 0, _ = void 0, S = void 0, b = void 0;
          i.isHorizontal() ? (x = g, _ = l.y, S = y - x, b = l.height, g = x + S) : (x = l.x, _ = g, S = l.width, b = y - _, g = _ + b);
          var w = u[p - 1].tickValue;
          w != null && f.set(w, d), e.add(new et({
            anid: w != null ? "area_" + w : null,
            shape: {
              x,
              y: _,
              width: S,
              height: b
            },
            style: ye({
              fill: s[d]
            }, m),
            autoBatch: true,
            silent: true
          })), d = (d + 1) % c;
        }
        d_(r).splitAreaColors = f;
      }
    }
  }
  function cO(r) {
    d_(r).splitAreaColors = null;
  }
  var mZ = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], yZ = [
    "splitArea",
    "splitLine",
    "minorSplitLine"
  ], hO = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this.group.removeAll();
      var o = this._axisGroup;
      if (this._axisGroup = new Ce(), this.group.add(this._axisGroup), !!t.get("show")) {
        var s = t.getCoordSysModel(), l = h_(s, t), u = new Ur(t, H({
          handleAutoShown: function(h) {
            for (var f = s.coordinateSystem.getCartesians(), d = 0; d < f.length; d++) if (n_(f[d].getOtherAxis(t.axis).scale)) return true;
            return false;
          }
        }, l));
        D(mZ, u.add, u), this._axisGroup.add(u.getGroup()), D(yZ, function(h) {
          t.get([
            h,
            "show"
          ]) && xZ[h](this, this._axisGroup, t, s);
        }, this);
        var c = a && a.type === "changeAxisOrder" && a.isInitSort;
        c || _f(o, this._axisGroup, t), r.prototype.render.call(this, t, n, i, a);
      }
    }, e.prototype.remove = function() {
      cO(this);
    }, e.type = "cartesianAxis", e;
  }(el), xZ = {
    splitLine: function(r, e, t, n) {
      var i = t.axis;
      if (!i.scale.isBlank()) {
        var a = t.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color"), l = a.get("showMinLine") !== false, u = a.get("showMaxLine") !== false;
        s = X(s) ? s : [
          s
        ];
        for (var c = n.coordinateSystem.getRect(), h = i.isHorizontal(), f = 0, d = i.getTicksCoords({
          tickModel: a
        }), p = [], v = [], g = o.getLineStyle(), m = 0; m < d.length; m++) {
          var y = i.toGlobalCoord(d[m].coord);
          if (!(m === 0 && !l || m === d.length - 1 && !u)) {
            var x = d[m].tickValue;
            h ? (p[0] = y, p[1] = c.y, v[0] = y, v[1] = c.y + c.height) : (p[0] = c.x, p[1] = y, v[0] = c.x + c.width, v[1] = y);
            var _ = f++ % s.length, S = new ir({
              anid: x != null ? "line_" + x : null,
              autoBatch: true,
              shape: {
                x1: p[0],
                y1: p[1],
                x2: v[0],
                y2: v[1]
              },
              style: ye({
                stroke: s[_]
              }, g),
              silent: true
            });
            uu(S.shape, g.lineWidth), e.add(S);
          }
        }
      }
    },
    minorSplitLine: function(r, e, t, n) {
      var i = t.axis, a = t.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = n.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
      if (u.length) for (var c = [], h = [], f = o.getLineStyle(), d = 0; d < u.length; d++) for (var p = 0; p < u[d].length; p++) {
        var v = i.toGlobalCoord(u[d][p].coord);
        l ? (c[0] = v, c[1] = s.y, h[0] = v, h[1] = s.y + s.height) : (c[0] = s.x, c[1] = v, h[0] = s.x + s.width, h[1] = v);
        var g = new ir({
          anid: "minor_line_" + u[d][p].tickValue,
          autoBatch: true,
          shape: {
            x1: c[0],
            y1: c[1],
            x2: h[0],
            y2: h[1]
          },
          style: f,
          silent: true
        });
        uu(g.shape, f.lineWidth), e.add(g);
      }
    },
    splitArea: function(r, e, t, n) {
      uO(r, e, t, n);
    }
  }, fO = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "xAxis", e;
  }(hO), _Z = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = fO.type, t;
    }
    return e.type = "yAxis", e;
  }(hO), bZ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "grid", t;
    }
    return e.prototype.render = function(t, n) {
      this.group.removeAll(), t.get("show") && this.group.add(new et({
        shape: t.coordinateSystem.getRect(),
        style: ye({
          fill: t.get("backgroundColor")
        }, t.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }, e.type = "grid", e;
  }(Rt), IA = {
    offset: 0
  };
  function dO(r) {
    r.registerComponentView(bZ), r.registerComponentModel(KK), r.registerCoordinateSystem("cartesian2d", nZ), pu(r, "x", u_, IA), pu(r, "y", u_, IA), r.registerComponentView(fO), r.registerComponentView(_Z), r.registerPreprocessor(function(e) {
      e.xAxis && e.yAxis && !e.grid && (e.grid = {});
    });
  }
  function SZ(r) {
    Ve(dO), r.registerSeriesModel(UK), r.registerChartView(qK), r.registerLayout(Df("scatter"));
  }
  function wZ(r) {
    r.eachSeriesByType("radar", function(e) {
      var t = e.getData(), n = [], i = e.coordinateSystem;
      if (i) {
        var a = i.getIndicatorAxes();
        D(a, function(o, s) {
          t.each(t.mapDimension(a[s].dim), function(l, u) {
            n[u] = n[u] || [];
            var c = i.dataToPoint(l, s);
            n[u][s] = MA(c) ? c : DA(i);
          });
        }), t.each(function(o) {
          var s = aU(n[o], function(l) {
            return MA(l);
          }) || DA(i);
          n[o].push(s.slice()), t.setItemLayout(o, n[o]);
        });
      }
    });
  }
  function MA(r) {
    return !isNaN(r[0]) && !isNaN(r[1]);
  }
  function DA(r) {
    return [
      r.cx,
      r.cy
    ];
  }
  function CZ(r) {
    var e = r.polar;
    if (e) {
      X(e) || (e = [
        e
      ]);
      var t = [];
      D(e, function(n, i) {
        n.indicator ? (n.type && !n.shape && (n.shape = n.type), r.radar = r.radar || [], X(r.radar) || (r.radar = [
          r.radar
        ]), r.radar.push(n)) : t.push(n);
      }), r.polar = t;
    }
    D(r.series, function(n) {
      n && n.type === "radar" && n.polarIndex && (n.radarIndex = n.polarIndex);
    });
  }
  var TZ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = t.coordinateSystem, o = this.group, s = t.getData(), l = this._data;
      function u(f, d) {
        var p = f.getItemVisual(d, "symbol") || "circle";
        if (p !== "none") {
          var v = $u(f.getItemVisual(d, "symbolSize")), g = Xt(p, -1, -1, 2, 2), m = f.getItemVisual(d, "symbolRotate") || 0;
          return g.attr({
            style: {
              strokeNoScale: true
            },
            z2: 100,
            scaleX: v[0] / 2,
            scaleY: v[1] / 2,
            rotation: m * Math.PI / 180 || 0
          }), g;
        }
      }
      function c(f, d, p, v, g, m) {
        p.removeAll();
        for (var y = 0; y < d.length - 1; y++) {
          var x = u(v, g);
          x && (x.__dimIdx = y, f[y] ? (x.setPosition(f[y]), Zs[m ? "initProps" : "updateProps"](x, {
            x: d[y][0],
            y: d[y][1]
          }, t, g)) : x.setPosition(d[y]), p.add(x));
        }
      }
      function h(f) {
        return K(f, function(d) {
          return [
            a.cx,
            a.cy
          ];
        });
      }
      s.diff(l).add(function(f) {
        var d = s.getItemLayout(f);
        if (d) {
          var p = new Kr(), v = new Zr(), g = {
            shape: {
              points: d
            }
          };
          p.shape.points = h(d), v.shape.points = h(d), kt(p, g, t, f), kt(v, g, t, f);
          var m = new Ce(), y = new Ce();
          m.add(v), m.add(p), m.add(y), c(v.shape.points, d, y, s, f, true), s.setItemGraphicEl(f, m);
        }
      }).update(function(f, d) {
        var p = l.getItemGraphicEl(d), v = p.childAt(0), g = p.childAt(1), m = p.childAt(2), y = {
          shape: {
            points: s.getItemLayout(f)
          }
        };
        y.shape.points && (c(v.shape.points, y.shape.points, m, s, f, false), li(g), li(v), it(v, y, t), it(g, y, t), s.setItemGraphicEl(f, p));
      }).remove(function(f) {
        o.remove(l.getItemGraphicEl(f));
      }).execute(), s.eachItemGraphicEl(function(f, d) {
        var p = s.getItemModel(d), v = f.childAt(0), g = f.childAt(1), m = f.childAt(2), y = s.getItemVisual(d, "style"), x = y.fill;
        o.add(f), v.useStyle(ye(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: x
        })), br(v, p, "lineStyle"), br(g, p, "areaStyle");
        var _ = p.getModel("areaStyle"), S = _.isEmpty() && _.parentModel.isEmpty();
        g.ignore = S, D([
          "emphasis",
          "select",
          "blur"
        ], function(C) {
          var T = p.getModel([
            C,
            "areaStyle"
          ]), A = T.isEmpty() && T.parentModel.isEmpty();
          g.ensureState(C).ignore = A && S;
        }), g.useStyle(ye(_.getAreaStyle(), {
          fill: x,
          opacity: 0.7,
          decal: y.decal
        }));
        var b = p.getModel("emphasis"), w = b.getModel("itemStyle").getItemStyle();
        m.eachChild(function(C) {
          if (C instanceof mr) {
            var T = C.style;
            C.useStyle(H({
              image: T.image,
              x: T.x,
              y: T.y,
              width: T.width,
              height: T.height
            }, y));
          } else C.useStyle(y), C.setColor(x), C.style.strokeNoScale = true;
          var A = C.ensureState("emphasis");
          A.style = be(w);
          var M = s.getStore().get(s.getDimensionIndex(C.__dimIdx), d);
          (M == null || isNaN(M)) && (M = ""), Sr(C, lr(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: d,
            labelDimIndex: C.__dimIdx,
            defaultText: M,
            inheritColor: x,
            defaultOpacity: y.opacity
          });
        }), Nt(f, b.get("focus"), b.get("blurScope"), b.get("disabled"));
      }), this._data = s;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "radar", e;
  }(yt), AZ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new kf(ne(this.getData, this), ne(this.getRawData, this));
    }, e.prototype.getInitialData = function(t, n) {
      return Wu(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, e.prototype.formatTooltip = function(t, n, i) {
      var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(t), u = l === "" ? this.name : l, c = h3(this, t);
      return ur("section", {
        header: u,
        sortBlocks: true,
        blocks: K(s, function(h) {
          var f = a.get(a.mapDimension(h.dim), t);
          return ur("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: h.name,
            value: f,
            sortParam: f
          });
        })
      });
    }, e.prototype.getTooltipPosition = function(t) {
      if (t != null) {
        for (var n = this.getData(), i = this.coordinateSystem, a = n.getValues(K(i.dimensions, function(u) {
          return n.mapDimension(u);
        }), t), o = 0, s = a.length; o < s; o++) if (!isNaN(a[o])) {
          var l = i.getIndicatorAxes();
          return i.coordToPoint(l[o].dataToCoord(a[o]), o);
        }
      }
    }, e.type = "series.radar", e.dependencies = [
      "radar"
    ], e.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: true,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      symbolSize: 8
    }, e;
  }(Tt), dc = oO.value;
  function Cd(r, e) {
    return ye({
      show: e
    }, r);
  }
  var IZ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      var t = this.get("boundaryGap"), n = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get([
        "axisName",
        "show"
      ]), c = this.get([
        "axisName",
        "formatter"
      ]), h = this.get("axisNameGap"), f = this.get("triggerEvent"), d = K(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var v = l;
        p.color != null && (v = ye({
          color: p.color
        }, l));
        var g = Ee(be(p), {
          boundaryGap: t,
          splitNumber: n,
          scale: i,
          axisLine: a,
          axisTick: o,
          axisLabel: s,
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: h,
          nameTextStyle: v,
          triggerEvent: f
        }, false);
        if (ee(c)) {
          var m = g.name;
          g.name = c.replace("{value}", m ?? "");
        } else ge(c) && (g.name = c(g.name, g));
        var y = new ft(g, null, this.ecModel);
        return qt(y, Tf.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = d;
    }, e.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, e.type = "radar", e.defaultOption = {
      z: 0,
      center: [
        "50%",
        "50%"
      ],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: true
      },
      boundaryGap: [
        0,
        0
      ],
      splitNumber: 5,
      axisNameGap: 15,
      scale: false,
      shape: "polygon",
      axisLine: Ee({
        lineStyle: {
          color: "#bbb"
        }
      }, dc.axisLine),
      axisLabel: Cd(dc.axisLabel, false),
      axisTick: Cd(dc.axisTick, false),
      splitLine: Cd(dc.splitLine, true),
      splitArea: Cd(dc.splitArea, true),
      indicator: []
    }, e;
  }(Ke), MZ = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], DZ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = this.group;
      a.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
    }, e.prototype._buildAxes = function(t) {
      var n = t.coordinateSystem, i = n.getIndicatorAxes(), a = K(i, function(o) {
        var s = o.model.get("showName") ? o.name : "", l = new Ur(o.model, {
          axisName: s,
          position: [
            n.cx,
            n.cy
          ],
          rotation: o.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      D(a, function(o) {
        D(MZ, o.add, o), this.group.add(o.getGroup());
      }, this);
    }, e.prototype._buildSplitLineAndArea = function(t) {
      var n = t.coordinateSystem, i = n.getIndicatorAxes();
      if (!i.length) return;
      var a = t.get("shape"), o = t.getModel("splitLine"), s = t.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), c = o.get("show"), h = s.get("show"), f = l.get("color"), d = u.get("color"), p = X(f) ? f : [
        f
      ], v = X(d) ? d : [
        d
      ], g = [], m = [];
      function y(N, I, L) {
        var P = L % I.length;
        return N[P] = N[P] || [], P;
      }
      if (a === "circle") for (var x = i[0].getTicksCoords(), _ = n.cx, S = n.cy, b = 0; b < x.length; b++) {
        if (c) {
          var w = y(g, p, b);
          g[w].push(new Ta({
            shape: {
              cx: _,
              cy: S,
              r: x[b].coord
            }
          }));
        }
        if (h && b < x.length - 1) {
          var w = y(m, v, b);
          m[w].push(new mf({
            shape: {
              cx: _,
              cy: S,
              r0: x[b].coord,
              r: x[b + 1].coord
            }
          }));
        }
      }
      else for (var C, T = K(i, function(N, I) {
        var L = N.getTicksCoords();
        return C = C == null ? L.length - 1 : Math.min(L.length - 1, C), K(L, function(P) {
          return n.coordToPoint(P.coord, I);
        });
      }), A = [], b = 0; b <= C; b++) {
        for (var M = [], E = 0; E < i.length; E++) M.push(T[E][b]);
        if (M[0] && M.push(M[0].slice()), c) {
          var w = y(g, p, b);
          g[w].push(new Zr({
            shape: {
              points: M
            }
          }));
        }
        if (h && A) {
          var w = y(m, v, b - 1);
          m[w].push(new Kr({
            shape: {
              points: M.concat(A)
            }
          }));
        }
        A = M.slice().reverse();
      }
      var k = l.getLineStyle(), R = u.getAreaStyle();
      D(m, function(N, I) {
        this.group.add(En(N, {
          style: ye({
            stroke: "none",
            fill: v[I % v.length]
          }, R),
          silent: true
        }));
      }, this), D(g, function(N, I) {
        this.group.add(En(N, {
          style: ye({
            fill: "none",
            stroke: p[I % p.length]
          }, k),
          silent: true
        }));
      }, this);
    }, e.type = "radar", e;
  }(Rt), PZ = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this, t, n, i) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return e;
  }(hi), kZ = function() {
    function r(e, t, n) {
      this.dimensions = [], this._model = e, this._indicatorAxes = K(e.getIndicatorModels(), function(i, a) {
        var o = "indicator_" + a, s = new PZ(o, new xa());
        return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(o), s;
      }, this), this.resize(e, n);
    }
    return r.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, r.prototype.dataToPoint = function(e, t) {
      var n = this._indicatorAxes[t];
      return this.coordToPoint(n.dataToCoord(e), t);
    }, r.prototype.coordToPoint = function(e, t) {
      var n = this._indicatorAxes[t], i = n.angle, a = this.cx + e * Math.cos(i), o = this.cy - e * Math.sin(i);
      return [
        a,
        o
      ];
    }, r.prototype.pointToData = function(e) {
      var t = e[0] - this.cx, n = e[1] - this.cy, i = Math.sqrt(t * t + n * n);
      t /= i, n /= i;
      for (var a = Math.atan2(-n, t), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], h = Math.abs(a - c.angle);
        h < o && (s = c, l = u, o = h);
      }
      return [
        l,
        +(s && s.coordToData(i))
      ];
    }, r.prototype.resize = function(e, t) {
      var n = e.get("center"), i = t.getWidth(), a = t.getHeight(), o = Math.min(i, a) / 2;
      this.cx = Q(n[0], i), this.cy = Q(n[1], a), this.startAngle = e.get("startAngle") * Math.PI / 180;
      var s = e.get("radius");
      (ee(s) || nt(s)) && (s = [
        0,
        s
      ]), this.r0 = Q(s[0], o), this.r = Q(s[1], o), D(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, r.prototype.update = function(e, t) {
      var n = this._indicatorAxes, i = this._model;
      D(n, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), e.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || e.getComponent("radar", s.get("radarIndex")) !== i)) {
          var u = s.getData();
          D(n, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var a = i.get("splitNumber"), o = new xa();
      o.setExtent(0, a), o.setInterval(1), D(n, function(s, l) {
        sO(s.scale, s.model, o);
      });
    }, r.prototype.convertToPixel = function(e, t, n) {
      return console.warn("Not implemented."), null;
    }, r.prototype.convertFromPixel = function(e, t, n) {
      return console.warn("Not implemented."), null;
    }, r.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), false;
    }, r.create = function(e, t) {
      var n = [];
      return e.eachComponent("radar", function(i) {
        var a = new r(i, e, t);
        n.push(a), i.coordinateSystem = a;
      }), e.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = n[i.get("radarIndex") || 0]);
      }), n;
    }, r.dimensions = [], r;
  }();
  function LZ(r) {
    r.registerCoordinateSystem("radar", kZ), r.registerComponentModel(IZ), r.registerComponentView(DZ), r.registerVisual({
      seriesType: "radar",
      reset: function(e) {
        var t = e.getData();
        t.each(function(n) {
          t.setItemVisual(n, "legendIcon", "roundRect");
        }), t.setVisual("legendIcon", "roundRect");
      }
    });
  }
  function RZ(r) {
    Ve(LZ), r.registerChartView(TZ), r.registerSeriesModel(AZ), r.registerLayout(wZ), r.registerProcessor(Pf("radar")), r.registerPreprocessor(CZ);
  }
  var PA = "\0_ec_interaction_mutex";
  function EZ(r, e, t) {
    var n = tS(r);
    n[e] = t;
  }
  function NZ(r, e, t) {
    var n = tS(r), i = n[e];
    i === t && (n[e] = null);
  }
  function kA(r, e) {
    return !!tS(r)[e];
  }
  function tS(r) {
    return r[PA] || (r[PA] = {});
  }
  Ui({
    type: "takeGlobalCursor",
    event: "globalCursorTaken",
    update: "update"
  }, Wt);
  var Lf = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this) || this;
      n._zr = t;
      var i = ne(n._mousedownHandler, n), a = ne(n._mousemoveHandler, n), o = ne(n._mouseupHandler, n), s = ne(n._mousewheelHandler, n), l = ne(n._pinchHandler, n);
      return n.enable = function(u, c) {
        this.disable(), this._opt = ye(be(c) || {}, {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: false,
          preventDefaultMouseMove: true
        }), u == null && (u = true), (u === true || u === "move" || u === "pan") && (t.on("mousedown", i), t.on("mousemove", a), t.on("mouseup", o)), (u === true || u === "scale" || u === "zoom") && (t.on("mousewheel", s), t.on("pinch", l));
      }, n.disable = function() {
        t.off("mousedown", i), t.off("mousemove", a), t.off("mouseup", o), t.off("mousewheel", s), t.off("pinch", l);
      }, n;
    }
    return e.prototype.isDragging = function() {
      return this._dragging;
    }, e.prototype.isPinching = function() {
      return this._pinching;
    }, e.prototype.setPointerChecker = function(t) {
      this.pointerChecker = t;
    }, e.prototype.dispose = function() {
      this.disable();
    }, e.prototype._mousedownHandler = function(t) {
      if (!oC(t)) {
        for (var n = t.target; n; ) {
          if (n.draggable) return;
          n = n.__hostTarget || n.parent;
        }
        var i = t.offsetX, a = t.offsetY;
        this.pointerChecker && this.pointerChecker(t, i, a) && (this._x = i, this._y = a, this._dragging = true);
      }
    }, e.prototype._mousemoveHandler = function(t) {
      if (!(!this._dragging || !Cp("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || kA(this._zr, "globalPan"))) {
        var n = t.offsetX, i = t.offsetY, a = this._x, o = this._y, s = n - a, l = i - o;
        this._x = n, this._y = i, this._opt.preventDefaultMouseMove && pa(t.event), pO(this, "pan", "moveOnMouseMove", t, {
          dx: s,
          dy: l,
          oldX: a,
          oldY: o,
          newX: n,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, e.prototype._mouseupHandler = function(t) {
      oC(t) || (this._dragging = false);
    }, e.prototype._mousewheelHandler = function(t) {
      var n = Cp("zoomOnMouseWheel", t, this._opt), i = Cp("moveOnMouseWheel", t, this._opt), a = t.wheelDelta, o = Math.abs(a), s = t.offsetX, l = t.offsetY;
      if (!(a === 0 || !n && !i)) {
        if (n) {
          var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
          vy(this, "zoom", "zoomOnMouseWheel", t, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var h = Math.abs(a), f = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
          vy(this, "scrollMove", "moveOnMouseWheel", t, {
            scrollDelta: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, e.prototype._pinchHandler = function(t) {
      if (!kA(this._zr, "globalPan")) {
        var n = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
        vy(this, "zoom", null, t, {
          scale: n,
          originX: t.pinchX,
          originY: t.pinchY,
          isAvailableBehavior: null
        });
      }
    }, e;
  }(Vn);
  function vy(r, e, t, n, i) {
    r.pointerChecker && r.pointerChecker(n, i.originX, i.originY) && (pa(n.event), pO(r, e, t, n, i));
  }
  function pO(r, e, t, n, i) {
    i.isAvailableBehavior = ne(Cp, null, t, n), r.trigger(e, i);
  }
  function Cp(r, e, t) {
    var n = t[r];
    return !r || n && (!ee(n) || e.event[n + "Key"]);
  }
  function rS(r, e, t) {
    var n = r.target;
    n.x += e, n.y += t, n.dirty();
  }
  function nS(r, e, t, n) {
    var i = r.target, a = r.zoomLimit, o = r.zoom = r.zoom || 1;
    if (o *= e, a) {
      var s = a.min || 0, l = a.max || 1 / 0;
      o = Math.max(Math.min(l, o), s);
    }
    var u = o / r.zoom;
    r.zoom = o, i.x -= (t - i.x) * (u - 1), i.y -= (n - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
  }
  var OZ = {
    axisPointer: 1,
    tooltip: 1,
    brush: 1
  };
  function wg(r, e, t) {
    var n = e.getComponentByElement(r.topTarget), i = n && n.coordinateSystem;
    return n && n !== t && !OZ.hasOwnProperty(n.mainType) && i && i.model !== t;
  }
  function vO(r) {
    if (ee(r)) {
      var e = new DOMParser();
      r = e.parseFromString(r, "text/xml");
    }
    var t = r;
    for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1; ) t = t.nextSibling;
    return t;
  }
  var gy, cv = {
    fill: "fill",
    stroke: "stroke",
    "stroke-width": "lineWidth",
    opacity: "opacity",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-miterlimit": "miterLimit",
    "font-family": "fontFamily",
    "font-size": "fontSize",
    "font-style": "fontStyle",
    "font-weight": "fontWeight",
    "text-anchor": "textAlign",
    visibility: "visibility",
    display: "display"
  }, LA = je(cv), hv = {
    "alignment-baseline": "textBaseline",
    "stop-color": "stopColor"
  }, RA = je(hv), FZ = function() {
    function r() {
      this._defs = {}, this._root = null;
    }
    return r.prototype.parse = function(e, t) {
      t = t || {};
      var n = vO(e);
      this._defsUsePending = [];
      var i = new Ce();
      this._root = i;
      var a = [], o = n.getAttribute("viewBox") || "", s = parseFloat(n.getAttribute("width") || t.width), l = parseFloat(n.getAttribute("height") || t.height);
      isNaN(s) && (s = null), isNaN(l) && (l = null), hn(n, i, null, true, false);
      for (var u = n.firstChild; u; ) this._parseNode(u, i, a, null, false, false), u = u.nextSibling;
      VZ(this._defs, this._defsUsePending), this._defsUsePending = [];
      var c, h;
      if (o) {
        var f = Cg(o);
        f.length >= 4 && (c = {
          x: parseFloat(f[0] || 0),
          y: parseFloat(f[1] || 0),
          width: parseFloat(f[2]),
          height: parseFloat(f[3])
        });
      }
      if (c && s != null && l != null && (h = mO(c, {
        x: 0,
        y: 0,
        width: s,
        height: l
      }), !t.ignoreViewBox)) {
        var d = i;
        i = new Ce(), i.add(d), d.scaleX = d.scaleY = h.scale, d.x = h.x, d.y = h.y;
      }
      return !t.ignoreRootClip && s != null && l != null && i.setClipPath(new et({
        shape: {
          x: 0,
          y: 0,
          width: s,
          height: l
        }
      })), {
        root: i,
        width: s,
        height: l,
        viewBoxRect: c,
        viewBoxTransform: h,
        named: a
      };
    }, r.prototype._parseNode = function(e, t, n, i, a, o) {
      var s = e.nodeName.toLowerCase(), l, u = i;
      if (s === "defs" && (a = true), s === "text" && (o = true), s === "defs" || s === "switch") l = t;
      else {
        if (!a) {
          var c = gy[s];
          if (c && oe(gy, s)) {
            l = c.call(this, e, t);
            var h = e.getAttribute("name");
            if (h) {
              var f = {
                name: h,
                namedFrom: null,
                svgNodeTagLower: s,
                el: l
              };
              n.push(f), s === "g" && (u = f);
            } else i && n.push({
              name: i.name,
              namedFrom: i,
              svgNodeTagLower: s,
              el: l
            });
            t.add(l);
          }
        }
        var d = EA[s];
        if (d && oe(EA, s)) {
          var p = d.call(this, e), v = e.getAttribute("id");
          v && (this._defs[v] = p);
        }
      }
      if (l && l.isGroup) for (var g = e.firstChild; g; ) g.nodeType === 1 ? this._parseNode(g, l, n, u, a, o) : g.nodeType === 3 && o && this._parseText(g, l), g = g.nextSibling;
    }, r.prototype._parseText = function(e, t) {
      var n = new lu({
        style: {
          text: e.textContent
        },
        silent: true,
        x: this._textX || 0,
        y: this._textY || 0
      });
      Cn(t, n), hn(e, n, this._defsUsePending, false, false), BZ(n, t);
      var i = n.style, a = i.fontSize;
      a && a < 9 && (i.fontSize = 9, n.scaleX *= a / 9, n.scaleY *= a / 9);
      var o = (i.fontSize || i.fontFamily) && [
        i.fontStyle,
        i.fontWeight,
        (i.fontSize || 12) + "px",
        i.fontFamily || "sans-serif"
      ].join(" ");
      i.font = o;
      var s = n.getBoundingRect();
      return this._textX += s.width, t.add(n), n;
    }, r.internalField = function() {
      gy = {
        g: function(e, t) {
          var n = new Ce();
          return Cn(t, n), hn(e, n, this._defsUsePending, false, false), n;
        },
        rect: function(e, t) {
          var n = new et();
          return Cn(t, n), hn(e, n, this._defsUsePending, false, false), n.setShape({
            x: parseFloat(e.getAttribute("x") || "0"),
            y: parseFloat(e.getAttribute("y") || "0"),
            width: parseFloat(e.getAttribute("width") || "0"),
            height: parseFloat(e.getAttribute("height") || "0")
          }), n.silent = true, n;
        },
        circle: function(e, t) {
          var n = new Ta();
          return Cn(t, n), hn(e, n, this._defsUsePending, false, false), n.setShape({
            cx: parseFloat(e.getAttribute("cx") || "0"),
            cy: parseFloat(e.getAttribute("cy") || "0"),
            r: parseFloat(e.getAttribute("r") || "0")
          }), n.silent = true, n;
        },
        line: function(e, t) {
          var n = new ir();
          return Cn(t, n), hn(e, n, this._defsUsePending, false, false), n.setShape({
            x1: parseFloat(e.getAttribute("x1") || "0"),
            y1: parseFloat(e.getAttribute("y1") || "0"),
            x2: parseFloat(e.getAttribute("x2") || "0"),
            y2: parseFloat(e.getAttribute("y2") || "0")
          }), n.silent = true, n;
        },
        ellipse: function(e, t) {
          var n = new rg();
          return Cn(t, n), hn(e, n, this._defsUsePending, false, false), n.setShape({
            cx: parseFloat(e.getAttribute("cx") || "0"),
            cy: parseFloat(e.getAttribute("cy") || "0"),
            rx: parseFloat(e.getAttribute("rx") || "0"),
            ry: parseFloat(e.getAttribute("ry") || "0")
          }), n.silent = true, n;
        },
        polygon: function(e, t) {
          var n = e.getAttribute("points"), i;
          n && (i = FA(n));
          var a = new Kr({
            shape: {
              points: i || []
            },
            silent: true
          });
          return Cn(t, a), hn(e, a, this._defsUsePending, false, false), a;
        },
        polyline: function(e, t) {
          var n = e.getAttribute("points"), i;
          n && (i = FA(n));
          var a = new Zr({
            shape: {
              points: i || []
            },
            silent: true
          });
          return Cn(t, a), hn(e, a, this._defsUsePending, false, false), a;
        },
        image: function(e, t) {
          var n = new mr();
          return Cn(t, n), hn(e, n, this._defsUsePending, false, false), n.setStyle({
            image: e.getAttribute("xlink:href") || e.getAttribute("href"),
            x: +e.getAttribute("x"),
            y: +e.getAttribute("y"),
            width: +e.getAttribute("width"),
            height: +e.getAttribute("height")
          }), n.silent = true, n;
        },
        text: function(e, t) {
          var n = e.getAttribute("x") || "0", i = e.getAttribute("y") || "0", a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0";
          this._textX = parseFloat(n) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(o);
          var s = new Ce();
          return Cn(t, s), hn(e, s, this._defsUsePending, false, true), s;
        },
        tspan: function(e, t) {
          var n = e.getAttribute("x"), i = e.getAttribute("y");
          n != null && (this._textX = parseFloat(n)), i != null && (this._textY = parseFloat(i));
          var a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0", s = new Ce();
          return Cn(t, s), hn(e, s, this._defsUsePending, false, true), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
        },
        path: function(e, t) {
          var n = e.getAttribute("d") || "", i = aE(n);
          return Cn(t, i), hn(e, i, this._defsUsePending, false, false), i.silent = true, i;
        }
      };
    }(), r;
  }(), EA = {
    lineargradient: function(r) {
      var e = parseInt(r.getAttribute("x1") || "0", 10), t = parseInt(r.getAttribute("y1") || "0", 10), n = parseInt(r.getAttribute("x2") || "10", 10), i = parseInt(r.getAttribute("y2") || "0", 10), a = new xf(e, t, n, i);
      return NA(r, a), OA(r, a), a;
    },
    radialgradient: function(r) {
      var e = parseInt(r.getAttribute("cx") || "0", 10), t = parseInt(r.getAttribute("cy") || "0", 10), n = parseInt(r.getAttribute("r") || "0", 10), i = new uE(e, t, n);
      return NA(r, i), OA(r, i), i;
    }
  };
  function NA(r, e) {
    var t = r.getAttribute("gradientUnits");
    t === "userSpaceOnUse" && (e.global = true);
  }
  function OA(r, e) {
    for (var t = r.firstChild; t; ) {
      if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") {
        var n = t.getAttribute("offset"), i = void 0;
        n && n.indexOf("%") > 0 ? i = parseInt(n, 10) / 100 : n ? i = parseFloat(n) : i = 0;
        var a = {};
        gO(t, a, a);
        var o = a.stopColor || t.getAttribute("stop-color") || "#000000";
        e.colorStops.push({
          offset: i,
          color: o
        });
      }
      t = t.nextSibling;
    }
  }
  function Cn(r, e) {
    r && r.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), ye(e.__inheritedStyle, r.__inheritedStyle));
  }
  function FA(r) {
    for (var e = Cg(r), t = [], n = 0; n < e.length; n += 2) {
      var i = parseFloat(e[n]), a = parseFloat(e[n + 1]);
      t.push([
        i,
        a
      ]);
    }
    return t;
  }
  function hn(r, e, t, n, i) {
    var a = e, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
    r.nodeType === 1 && (WZ(r, e), gO(r, o, s), n || UZ(r, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = BA(a, "fill", o.fill, t)), o.stroke != null && (a.style.stroke = BA(a, "stroke", o.stroke, t)), D([
      "lineWidth",
      "opacity",
      "fillOpacity",
      "strokeOpacity",
      "miterLimit",
      "fontSize"
    ], function(l) {
      o[l] != null && (a.style[l] = parseFloat(o[l]));
    }), D([
      "lineDashOffset",
      "lineCap",
      "lineJoin",
      "fontWeight",
      "fontFamily",
      "fontStyle",
      "textAlign"
    ], function(l) {
      o[l] != null && (a.style[l] = o[l]);
    }), i && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = K(Cg(o.lineDash), function(l) {
      return parseFloat(l);
    })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = true), o.display === "none" && (a.ignore = true);
  }
  function BZ(r, e) {
    var t = e.__selfStyle;
    if (t) {
      var n = t.textBaseline, i = n;
      !n || n === "auto" || n === "baseline" ? i = "alphabetic" : n === "before-edge" || n === "text-before-edge" ? i = "top" : n === "after-edge" || n === "text-after-edge" ? i = "bottom" : (n === "central" || n === "mathematical") && (i = "middle"), r.style.textBaseline = i;
    }
    var a = e.__inheritedStyle;
    if (a) {
      var o = a.textAlign, s = o;
      o && (o === "middle" && (s = "center"), r.style.textAlign = s);
    }
  }
  var zZ = /^url\(\s*#(.*?)\)/;
  function BA(r, e, t, n) {
    var i = t && t.match(zZ);
    if (i) {
      var a = ei(i[1]);
      n.push([
        r,
        e,
        a
      ]);
      return;
    }
    return t === "none" && (t = null), t;
  }
  function VZ(r, e) {
    for (var t = 0; t < e.length; t++) {
      var n = e[t];
      n[0].style[n[1]] = r[n[2]];
    }
  }
  var $Z = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function Cg(r) {
    return r.match($Z) || [];
  }
  var GZ = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, my = Math.PI / 180;
  function WZ(r, e) {
    var t = r.getAttribute("transform");
    if (t) {
      t = t.replace(/,/g, " ");
      var n = [], i = null;
      t.replace(GZ, function(h, f, d) {
        return n.push(f, d), "";
      });
      for (var a = n.length - 1; a > 0; a -= 2) {
        var o = n[a], s = n[a - 1], l = Cg(o);
        switch (i = i || pn(), s) {
          case "translate":
            Bi(i, i, [
              parseFloat(l[0]),
              parseFloat(l[1] || "0")
            ]);
            break;
          case "scale":
            Qb(i, i, [
              parseFloat(l[0]),
              parseFloat(l[1] || l[0])
            ]);
            break;
          case "rotate":
            qs(i, i, -parseFloat(l[0]) * my, [
              parseFloat(l[1] || "0"),
              parseFloat(l[2] || "0")
            ]);
            break;
          case "skewX":
            var u = Math.tan(parseFloat(l[0]) * my);
            sa(i, [
              1,
              0,
              u,
              1,
              0,
              0
            ], i);
            break;
          case "skewY":
            var c = Math.tan(parseFloat(l[0]) * my);
            sa(i, [
              1,
              c,
              0,
              1,
              0,
              0
            ], i);
            break;
          case "matrix":
            i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
            break;
        }
      }
      e.setLocalTransform(i);
    }
  }
  var zA = /([^\s:;]+)\s*:\s*([^:;]+)/g;
  function gO(r, e, t) {
    var n = r.getAttribute("style");
    if (n) {
      zA.lastIndex = 0;
      for (var i; (i = zA.exec(n)) != null; ) {
        var a = i[1], o = oe(cv, a) ? cv[a] : null;
        o && (e[o] = i[2]);
        var s = oe(hv, a) ? hv[a] : null;
        s && (t[s] = i[2]);
      }
    }
  }
  function UZ(r, e, t) {
    for (var n = 0; n < LA.length; n++) {
      var i = LA[n], a = r.getAttribute(i);
      a != null && (e[cv[i]] = a);
    }
    for (var n = 0; n < RA.length; n++) {
      var i = RA[n], a = r.getAttribute(i);
      a != null && (t[hv[i]] = a);
    }
  }
  function mO(r, e) {
    var t = e.width / r.width, n = e.height / r.height, i = Math.min(t, n);
    return {
      scale: i,
      x: -(r.x + r.width / 2) * i + (e.x + e.width / 2),
      y: -(r.y + r.height / 2) * i + (e.y + e.height / 2)
    };
  }
  function HZ(r, e) {
    var t = new FZ();
    return t.parse(r, e);
  }
  var YZ = ce([
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path",
    "text",
    "tspan",
    "g"
  ]), XZ = function() {
    function r(e, t) {
      this.type = "geoSVG", this._usedGraphicMap = ce(), this._freedGraphics = [], this._mapName = e, this._parsedXML = vO(t);
    }
    return r.prototype.load = function() {
      var e = this._firstGraphic;
      if (!e) {
        e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var t = KZ(e.named), n = t.regions, i = t.regionsMap;
        this._regions = n, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, r.prototype._buildGraphic = function(e) {
      var t, n;
      try {
        t = e && HZ(e, {
          ignoreViewBox: true,
          ignoreRootClip: true
        }) || {}, n = t.root, Yr(n != null);
      } catch (g) {
        throw new Error(`Invalid svg format
` + g.message);
      }
      var i = new Ce();
      i.add(n), i.isGeoSVGGraphicRoot = true;
      var a = t.width, o = t.height, s = t.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, h = void 0, f = void 0;
        if (a != null ? (u = 0, h = a) : s && (u = s.x, h = s.width), o != null ? (c = 0, f = o) : s && (c = s.y, f = s.height), u == null || c == null) {
          var d = n.getBoundingRect();
          u == null && (u = d.x, h = d.width), c == null && (c = d.y, f = d.height);
        }
        l = this._boundingRect = new Oe(u, c, h, f);
      }
      if (s) {
        var p = mO(s, l);
        n.scaleX = n.scaleY = p.scale, n.x = p.x, n.y = p.y;
      }
      i.setClipPath(new et({
        shape: l.plain()
      }));
      var v = [];
      return D(t.named, function(g) {
        YZ.get(g.svgNodeTagLower) != null && (v.push(g), qZ(g.el));
      }), {
        root: i,
        boundingRect: l,
        named: v
      };
    }, r.prototype.useGraphic = function(e) {
      var t = this._usedGraphicMap, n = t.get(e);
      return n || (n = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, n), n);
    }, r.prototype.freeGraphic = function(e) {
      var t = this._usedGraphicMap, n = t.get(e);
      n && (t.removeKey(e), this._freedGraphics.push(n));
    }, r;
  }();
  function qZ(r) {
    r.silent = false, r.isGroup && r.traverse(function(e) {
      e.silent = false;
    });
  }
  function KZ(r) {
    var e = [], t = ce();
    return D(r, function(n) {
      if (n.namedFrom == null) {
        var i = new W7(n.name, n.el);
        e.push(i), t.set(n.name, i);
      }
    }), {
      regions: e,
      regionsMap: t
    };
  }
  var p_ = [
    126,
    25
  ], VA = "\u5357\u6D77\u8BF8\u5C9B", es = [
    [
      [
        0,
        3.5
      ],
      [
        7,
        11.2
      ],
      [
        15,
        11.9
      ],
      [
        30,
        7
      ],
      [
        42,
        0.7
      ],
      [
        52,
        0.7
      ],
      [
        56,
        7.7
      ],
      [
        59,
        0.7
      ],
      [
        64,
        0.7
      ],
      [
        64,
        0
      ],
      [
        5,
        0
      ],
      [
        0,
        3.5
      ]
    ],
    [
      [
        13,
        16.1
      ],
      [
        19,
        14.7
      ],
      [
        16,
        21.7
      ],
      [
        11,
        23.1
      ],
      [
        13,
        16.1
      ]
    ],
    [
      [
        12,
        32.2
      ],
      [
        14,
        38.5
      ],
      [
        15,
        38.5
      ],
      [
        13,
        32.2
      ],
      [
        12,
        32.2
      ]
    ],
    [
      [
        16,
        47.6
      ],
      [
        12,
        53.2
      ],
      [
        13,
        53.2
      ],
      [
        18,
        47.6
      ],
      [
        16,
        47.6
      ]
    ],
    [
      [
        6,
        64.4
      ],
      [
        8,
        70
      ],
      [
        9,
        70
      ],
      [
        8,
        64.4
      ],
      [
        6,
        64.4
      ]
    ],
    [
      [
        23,
        82.6
      ],
      [
        29,
        79.8
      ],
      [
        30,
        79.8
      ],
      [
        25,
        82.6
      ],
      [
        23,
        82.6
      ]
    ],
    [
      [
        37,
        70.7
      ],
      [
        43,
        62.3
      ],
      [
        44,
        62.3
      ],
      [
        39,
        70.7
      ],
      [
        37,
        70.7
      ]
    ],
    [
      [
        48,
        51.1
      ],
      [
        51,
        45.5
      ],
      [
        53,
        45.5
      ],
      [
        50,
        51.1
      ],
      [
        48,
        51.1
      ]
    ],
    [
      [
        51,
        35
      ],
      [
        51,
        28.7
      ],
      [
        53,
        28.7
      ],
      [
        53,
        35
      ],
      [
        51,
        35
      ]
    ],
    [
      [
        52,
        22.4
      ],
      [
        55,
        17.5
      ],
      [
        56,
        17.5
      ],
      [
        53,
        22.4
      ],
      [
        52,
        22.4
      ]
    ],
    [
      [
        58,
        12.6
      ],
      [
        62,
        7
      ],
      [
        63,
        7
      ],
      [
        60,
        12.6
      ],
      [
        58,
        12.6
      ]
    ],
    [
      [
        0,
        3.5
      ],
      [
        0,
        93.1
      ],
      [
        64,
        93.1
      ],
      [
        64,
        0
      ],
      [
        63,
        0
      ],
      [
        63,
        92.4
      ],
      [
        1,
        92.4
      ],
      [
        1,
        3.5
      ],
      [
        0,
        3.5
      ]
    ]
  ];
  for (var qo = 0; qo < es.length; qo++) for (var bl = 0; bl < es[qo].length; bl++) es[qo][bl][0] /= 10.5, es[qo][bl][1] /= -10.5 / 0.75, es[qo][bl][0] += p_[0], es[qo][bl][1] += p_[1];
  function ZZ(r, e) {
    if (r === "china") {
      for (var t = 0; t < e.length; t++) if (e[t].name === VA) return;
      e.push(new dN(VA, K(es, function(n) {
        return {
          type: "polygon",
          exterior: n
        };
      }), p_));
    }
  }
  var jZ = {
    \u5357\u6D77\u8BF8\u5C9B: [
      32,
      80
    ],
    \u5E7F\u4E1C: [
      0,
      -10
    ],
    \u9999\u6E2F: [
      10,
      5
    ],
    \u6FB3\u95E8: [
      -10,
      10
    ],
    \u5929\u6D25: [
      5,
      5
    ]
  };
  function QZ(r, e) {
    if (r === "china") {
      var t = jZ[e.name];
      if (t) {
        var n = e.getCenter();
        n[0] += t[0] / 10.5, n[1] += -t[1] / (10.5 / 0.75), e.setCenter(n);
      }
    }
  }
  var JZ = [
    [
      [
        123.45165252685547,
        25.73527164402261
      ],
      [
        123.49731445312499,
        25.73527164402261
      ],
      [
        123.49731445312499,
        25.750734064600884
      ],
      [
        123.45165252685547,
        25.750734064600884
      ],
      [
        123.45165252685547,
        25.73527164402261
      ]
    ]
  ];
  function ej(r, e) {
    r === "china" && e.name === "\u53F0\u6E7E" && e.geometries.push({
      type: "polygon",
      exterior: JZ[0]
    });
  }
  var tj = "name", rj = function() {
    function r(e, t, n) {
      this.type = "geoJSON", this._parsedMap = ce(), this._mapName = e, this._specialAreas = n, this._geoJSON = ij(t);
    }
    return r.prototype.load = function(e, t) {
      t = t || tj;
      var n = this._parsedMap.get(t);
      if (!n) {
        var i = this._parseToRegions(t);
        n = this._parsedMap.set(t, {
          regions: i,
          boundingRect: nj(i)
        });
      }
      var a = ce(), o = [];
      return D(n.regions, function(s) {
        var l = s.name;
        e && oe(e, l) && (s = s.cloneShallow(l = e[l])), o.push(s), a.set(l, s);
      }), {
        regions: o,
        boundingRect: n.boundingRect || new Oe(0, 0, 0, 0),
        regionsMap: a
      };
    }, r.prototype._parseToRegions = function(e) {
      var t = this._mapName, n = this._geoJSON, i;
      try {
        i = n ? H7(n, e) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return ZZ(t, i), D(i, function(a) {
        var o = a.name;
        QZ(t, a), ej(t, a);
        var s = this._specialAreas && this._specialAreas[o];
        s && a.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, r.prototype.getMapForUser = function() {
      return {
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, r;
  }();
  function nj(r) {
    for (var e, t = 0; t < r.length; t++) {
      var n = r[t].getBoundingRect();
      e = e || n.clone(), e.union(n);
    }
    return e;
  }
  function ij(r) {
    return ee(r) ? typeof JSON < "u" && JSON.parse ? JSON.parse(r) : new Function("return (" + r + ");")() : r;
  }
  var pc = ce();
  const _a = {
    registerMap: function(r, e, t) {
      if (e.svg) {
        var n = new XZ(r, e.svg);
        pc.set(r, n);
      } else {
        var i = e.geoJson || e.geoJSON;
        i && !e.features ? t = e.specialAreas : i = e;
        var n = new rj(r, i, t);
        pc.set(r, n);
      }
    },
    getGeoResource: function(r) {
      return pc.get(r);
    },
    getMapForUser: function(r) {
      var e = pc.get(r);
      return e && e.type === "geoJSON" && e.getMapForUser();
    },
    load: function(r, e, t) {
      var n = pc.get(r);
      if (n) return n.load(e, t);
    }
  };
  var iS = [
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path"
  ], aj = ce(iS), oj = ce(iS.concat([
    "g"
  ])), sj = ce(iS.concat([
    "g"
  ])), yO = tt();
  function Td(r) {
    var e = r.getItemStyle(), t = r.get("areaColor");
    return t != null && (e.fill = t), e;
  }
  function $A(r) {
    var e = r.style;
    e && (e.stroke = e.stroke || e.fill, e.fill = null);
  }
  var xO = function() {
    function r(e) {
      var t = new Ce();
      this.uid = Nu("ec_map_draw"), this._controller = new Lf(e.getZr()), this._controllerHost = {
        target: t
      }, this.group = t, t.add(this._regionsGroup = new Ce()), t.add(this._svgGroup = new Ce());
    }
    return r.prototype.draw = function(e, t, n, i, a) {
      var o = e.mainType === "geo", s = e.getData && e.getData();
      o && t.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(m) {
        !s && m.getHostGeoModel() === e && (s = m.getData());
      });
      var l = e.coordinateSystem, u = this._regionsGroup, c = this.group, h = l.getTransformInfo(), f = h.raw, d = h.roam, p = !u.childAt(0) || a;
      p ? (c.x = d.x, c.y = d.y, c.scaleX = d.scaleX, c.scaleY = d.scaleY, c.dirty()) : it(c, d, e);
      var v = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, g = {
        api: n,
        geo: l,
        mapOrGeoModel: e,
        data: s,
        isVisualEncodedByVisualMap: v,
        isGeo: o,
        transformInfoRaw: f
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(g) : l.resourceType === "geoSVG" && this._buildSVG(g), this._updateController(e, t, n), this._updateMapSelectHandler(e, u, n, i);
    }, r.prototype._buildGeoJSON = function(e) {
      var t = this._regionsGroupByName = ce(), n = ce(), i = this._regionsGroup, a = e.transformInfoRaw, o = e.mapOrGeoModel, s = e.data, l = e.geo.projection, u = l && l.stream;
      function c(d, p) {
        return p && (d = p(d)), d && [
          d[0] * a.scaleX + a.x,
          d[1] * a.scaleY + a.y
        ];
      }
      function h(d) {
        for (var p = [], v = !u && l && l.project, g = 0; g < d.length; ++g) {
          var m = c(d[g], v);
          m && p.push(m);
        }
        return p;
      }
      function f(d) {
        return {
          shape: {
            points: h(d)
          }
        };
      }
      i.removeAll(), D(e.geo.regions, function(d) {
        var p = d.name, v = t.get(p), g = n.get(p) || {}, m = g.dataIdx, y = g.regionModel;
        if (!v) {
          v = t.set(p, new Ce()), i.add(v), m = s ? s.indexOfName(p) : null, y = e.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(m) : null;
          var x = y.get("silent", true);
          x != null && (v.silent = x), n.set(p, {
            dataIdx: m,
            regionModel: y
          });
        }
        var _ = [], S = [];
        D(d.geometries, function(C) {
          if (C.type === "polygon") {
            var T = [
              C.exterior
            ].concat(C.interiors || []);
            u && (T = XA(T, u)), D(T, function(M) {
              _.push(new Kr(f(M)));
            });
          } else {
            var A = C.points;
            u && (A = XA(A, u, true)), D(A, function(M) {
              S.push(new Zr(f(M)));
            });
          }
        });
        var b = c(d.getCenter(), l && l.project);
        function w(C, T) {
          if (C.length) {
            var A = new p1({
              culling: true,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: C
              }
            });
            v.add(A), GA(e, A, m, y), WA(e, A, p, y, o, m, b), T && ($A(A), D(A.states, $A));
          }
        }
        w(_), w(S, true);
      }), t.each(function(d, p) {
        var v = n.get(p), g = v.dataIdx, m = v.regionModel;
        UA(e, d, p, m, o, g), HA(e, d, p, m, o), YA(e, d, p, m, o);
      }, this);
    }, r.prototype._buildSVG = function(e) {
      var t = e.geo.map, n = e.transformInfoRaw;
      this._svgGroup.x = n.x, this._svgGroup.y = n.y, this._svgGroup.scaleX = n.scaleX, this._svgGroup.scaleY = n.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t));
      var i = this._svgDispatcherMap = ce(), a = false;
      D(this._svgGraphicRecord.named, function(o) {
        var s = o.name, l = e.mapOrGeoModel, u = e.data, c = o.svgNodeTagLower, h = o.el, f = u ? u.indexOfName(s) : null, d = l.getRegionModel(s);
        aj.get(c) != null && h instanceof zn && GA(e, h, f, d), h instanceof zn && (h.culling = true);
        var p = d.get("silent", true);
        if (p != null && (h.silent = p), h.z2EmphasisLift = 0, !o.namedFrom && (sj.get(c) != null && WA(e, h, s, d, l, f, null), UA(e, h, s, d, l, f), HA(e, h, s, d, l), oj.get(c) != null)) {
          var v = YA(e, h, s, d, l);
          v === "self" && (a = true);
          var g = i.get(s) || i.set(s, []);
          g.push(h);
        }
      }, this), this._enableBlurEntireSVG(a, e);
    }, r.prototype._enableBlurEntireSVG = function(e, t) {
      if (e && t.isGeo) {
        var n = t.mapOrGeoModel.getModel([
          "blur",
          "itemStyle"
        ]).getItemStyle(), i = n.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            $s(a);
            var o = a.ensureState("blur").style || {};
            o.opacity == null && i != null && (o.opacity = i), a.ensureState("emphasis");
          }
        });
      }
    }, r.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, r.prototype.findHighDownDispatchers = function(e, t) {
      if (e == null) return [];
      var n = t.coordinateSystem;
      if (n.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var a = i.get(e);
          return a ? [
            a
          ] : [];
        }
      } else if (n.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [];
    }, r.prototype._svgResourceChanged = function(e) {
      return this._svgMapName !== e;
    }, r.prototype._useSVG = function(e) {
      var t = _a.getGeoResource(e);
      if (t && t.type === "geoSVG") {
        var n = t.useGraphic(this.uid);
        this._svgGroup.add(n.root), this._svgGraphicRecord = n, this._svgMapName = e;
      }
    }, r.prototype._freeSVG = function() {
      var e = this._svgMapName;
      if (e != null) {
        var t = _a.getGeoResource(e);
        t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, r.prototype._updateController = function(e, t, n) {
      var i = e.coordinateSystem, a = this._controller, o = this._controllerHost;
      o.zoomLimit = e.get("scaleLimit"), o.zoom = i.getZoom(), a.enable(e.get("roam") || false);
      var s = e.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = e.id, u;
      }
      a.off("pan").on("pan", function(u) {
        this._mouseDownFlag = false, rS(o, u.dx, u.dy), n.dispatchAction(H(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), a.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = false, nS(o, u.scale, u.originX, u.originY), n.dispatchAction(H(l(), {
          totalZoom: o.zoom,
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), a.setPointerChecker(function(u, c, h) {
        return i.containPoint([
          c,
          h
        ]) && !wg(u, n, e);
      });
    }, r.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(e) {
        var t = e.getTextContent();
        t && (t.ignore = yO(t).ignore);
      });
    }, r.prototype._updateMapSelectHandler = function(e, t, n, i) {
      var a = this;
      t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function() {
        a._mouseDownFlag = true;
      }), t.on("click", function(o) {
        a._mouseDownFlag && (a._mouseDownFlag = false);
      }));
    }, r;
  }();
  function GA(r, e, t, n) {
    var i = n.getModel("itemStyle"), a = n.getModel([
      "emphasis",
      "itemStyle"
    ]), o = n.getModel([
      "blur",
      "itemStyle"
    ]), s = n.getModel([
      "select",
      "itemStyle"
    ]), l = Td(i), u = Td(a), c = Td(s), h = Td(o), f = r.data;
    if (f) {
      var d = f.getItemVisual(t, "style"), p = f.getItemVisual(t, "decal");
      r.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill), p && (l.decal = hu(p, r.api));
    }
    e.setStyle(l), e.style.strokeNoScale = true, e.ensureState("emphasis").style = u, e.ensureState("select").style = c, e.ensureState("blur").style = h, $s(e);
  }
  function WA(r, e, t, n, i, a, o) {
    var s = r.data, l = r.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), c = s && s.getItemLayout(a);
    if (l || u || c && c.showLabel) {
      var h = l ? t : a, f = void 0;
      (!s || a >= 0) && (f = i);
      var d = o ? {
        normal: {
          align: "center",
          verticalAlign: "middle"
        }
      } : null;
      Sr(e, lr(n), {
        labelFetcher: f,
        labelDataIndex: h,
        defaultText: t
      }, d);
      var p = e.getTextContent();
      if (p && (yO(p).ignore = p.ignore, e.textConfig && o)) {
        var v = e.getBoundingRect().clone();
        e.textConfig.layoutRect = v, e.textConfig.position = [
          (o[0] - v.x) / v.width * 100 + "%",
          (o[1] - v.y) / v.height * 100 + "%"
        ];
      }
      e.disableLabelAnimation = true;
    } else e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null;
  }
  function UA(r, e, t, n, i, a) {
    r.data ? r.data.setItemGraphicEl(a, e) : De(e).eventData = {
      componentType: "geo",
      componentIndex: i.componentIndex,
      geoIndex: i.componentIndex,
      name: t,
      region: n && n.option || {}
    };
  }
  function HA(r, e, t, n, i) {
    r.data || Ks({
      el: e,
      componentModel: i,
      itemName: t,
      itemTooltipOption: n.get("tooltip")
    });
  }
  function YA(r, e, t, n, i) {
    e.highDownSilentOnTouch = !!i.get("selectedMode");
    var a = n.getModel("emphasis"), o = a.get("focus");
    return Nt(e, o, a.get("blurScope"), a.get("disabled")), r.isGeo && i8(e, i, t), o;
  }
  function XA(r, e, t) {
    var n = [], i;
    function a() {
      i = [];
    }
    function o() {
      i.length && (n.push(i), i = []);
    }
    var s = e({
      polygonStart: a,
      polygonEnd: o,
      lineStart: a,
      lineEnd: o,
      point: function(l, u) {
        isFinite(l) && isFinite(u) && i.push([
          l,
          u
        ]);
      },
      sphere: function() {
      }
    });
    return !t && s.polygonStart(), D(r, function(l) {
      s.lineStart();
      for (var u = 0; u < l.length; u++) s.point(l[u][0], l[u][1]);
      s.lineEnd();
    }), !t && s.polygonEnd(), n;
  }
  var lj = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var o = this.group;
        if (o.removeAll(), !t.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === t.id) {
            var s = this._mapDraw;
            s && o.add(s.group);
          } else if (t.needsDrawMap) {
            var s = this._mapDraw || new xO(i);
            o.add(s.group), s.draw(t, n, i, this, a), this._mapDraw = s;
          } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          t.get("showLegendSymbol") && n.getComponent("legend") && this._renderSymbols(t, n, i);
        }
      }
    }, e.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, e.prototype._renderSymbols = function(t, n, i) {
      var a = t.originalData, o = this.group;
      a.each(a.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, h = u.offset, f = new Ta({
              style: {
                fill: t.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + h * 9,
                cy: c[1],
                r: 3
              },
              silent: true,
              z2: 8 + (h ? 0 : Lu + 1)
            });
            if (!h) {
              var d = t.mainSeries.getData(), p = a.getName(l), v = d.indexOfName(p), g = a.getItemModel(l), m = g.getModel("label"), y = d.getItemGraphicEl(v);
              Sr(f, lr(g), {
                labelFetcher: {
                  getFormattedLabel: function(x, _) {
                    return t.getFormattedLabel(v, _);
                  }
                },
                defaultText: p
              }), f.disableLabelAnimation = true, m.get("position") || f.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(x) {
                Up(f, x);
              };
            }
            o.add(f);
          }
        }
      });
    }, e.type = "map", e;
  }(yt), uj = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.needsDrawMap = false, t.seriesGroup = [], t.getTooltipPosition = function(n) {
        if (n != null) {
          var i = this.getData().getName(n), a = this.coordinateSystem, o = a.getRegion(i);
          return o && a.dataToPoint(o.getCenter());
        }
      }, t;
    }
    return e.prototype.getInitialData = function(t) {
      for (var n = Wu(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: Le(C1, this)
      }), i = ce(), a = [], o = 0, s = n.count(); o < s; o++) {
        var l = n.getName(o);
        i.set(l, o);
      }
      var u = _a.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return D(u.regions, function(c) {
        var h = c.name, f = i.get(h), d = c.properties && c.properties.echartsStyle, p;
        f == null ? (p = {
          name: h
        }, a.push(p)) : p = n.getRawDataItem(f), d && Ee(p, d);
      }), n.appendData(a), n;
    }, e.prototype.getHostGeoModel = function() {
      var t = this.option.geoIndex;
      return t != null ? this.ecModel.getComponent("geo", t) : null;
    }, e.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, e.prototype.getRawValue = function(t) {
      var n = this.getData();
      return n.get(n.mapDimension("value"), t);
    }, e.prototype.getRegionModel = function(t) {
      var n = this.getData();
      return n.getItemModel(n.indexOfName(t));
    }, e.prototype.formatTooltip = function(t, n, i) {
      for (var a = this.getData(), o = this.getRawValue(t), s = a.getName(t), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var h = l[c].originalData.indexOfName(s), f = a.mapDimension("value");
        isNaN(l[c].originalData.get(f, h)) || u.push(l[c].name);
      }
      return ur("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [
          ur("nameValue", {
            name: s,
            value: o
          })
        ]
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.getLegendIcon = function(t) {
      var n = t.icon || "roundRect", i = Xt(n, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
      return i.setStyle(t.itemStyle), i.style.stroke = "none", n.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, e.type = "series.map", e.dependencies = [
      "geo"
    ], e.layoutMode = "box", e.defaultOption = {
      z: 2,
      coordinateSystem: "geo",
      map: "",
      left: "center",
      top: "center",
      aspectScale: null,
      showLegendSymbol: true,
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: true,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, e;
  }(Tt);
  function cj(r, e) {
    var t = {};
    return D(r, function(n) {
      n.each(n.mapDimension("value"), function(i, a) {
        var o = "ec-" + n.getName(a);
        t[o] = t[o] || [], isNaN(i) || t[o].push(i);
      });
    }), r[0].map(r[0].mapDimension("value"), function(n, i) {
      for (var a = "ec-" + r[0].getName(i), o = 0, s = 1 / 0, l = -1 / 0, u = t[a].length, c = 0; c < u; c++) s = Math.min(s, t[a][c]), l = Math.max(l, t[a][c]), o += t[a][c];
      var h;
      return e === "min" ? h = s : e === "max" ? h = l : e === "average" ? h = o / u : h = o, u === 0 ? NaN : h;
    });
  }
  function hj(r) {
    var e = {};
    r.eachSeriesByType("map", function(t) {
      var n = t.getHostGeoModel(), i = n ? "o" + n.id : "i" + t.getMapType();
      (e[i] = e[i] || []).push(t);
    }), D(e, function(t, n) {
      for (var i = cj(K(t, function(o) {
        return o.getData();
      }), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++) t[a].originalData = t[a].getData();
      for (var a = 0; a < t.length; a++) t[a].seriesGroup = t, t[a].needsDrawMap = a === 0 && !t[a].getHostGeoModel(), t[a].setData(i.cloneShallow()), t[a].mainSeries = t[0];
    });
  }
  function fj(r) {
    var e = {};
    r.eachSeriesByType("map", function(t) {
      var n = t.getMapType();
      if (!(t.getHostGeoModel() || e[n])) {
        var i = {};
        D(t.seriesGroup, function(o) {
          var s = o.coordinateSystem, l = o.originalData;
          o.get("showLegendSymbol") && r.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
            var h = l.getName(c), f = s.getRegion(h);
            if (!(!f || isNaN(u))) {
              var d = i[h] || 0, p = s.dataToPoint(f.getCenter());
              i[h] = d + 1, l.setItemLayout(c, {
                point: p,
                offset: d
              });
            }
          });
        });
        var a = t.getData();
        a.each(function(o) {
          var s = a.getName(o), l = a.getItemLayout(o) || {};
          l.showLabel = !i[s], a.setItemLayout(o, l);
        }), e[n] = true;
      }
    });
  }
  var qA = xr, Rf = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this) || this;
      return n.type = "view", n.dimensions = [
        "x",
        "y"
      ], n._roamTransformable = new ta(), n._rawTransformable = new ta(), n.name = t, n;
    }
    return e.prototype.setBoundingRect = function(t, n, i, a) {
      return this._rect = new Oe(t, n, i, a), this._rect;
    }, e.prototype.getBoundingRect = function() {
      return this._rect;
    }, e.prototype.setViewRect = function(t, n, i, a) {
      this._transformTo(t, n, i, a), this._viewRect = new Oe(t, n, i, a);
    }, e.prototype._transformTo = function(t, n, i, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new Oe(t, n, i, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, e.prototype.setCenter = function(t, n) {
      t && (this._center = [
        Q(t[0], n.getWidth()),
        Q(t[1], n.getHeight())
      ], this._updateCenterAndZoom());
    }, e.prototype.setZoom = function(t) {
      t = t || 1;
      var n = this.zoomLimit;
      n && (n.max != null && (t = Math.min(n.max, t)), n.min != null && (t = Math.max(n.min, t))), this._zoom = t, this._updateCenterAndZoom();
    }, e.prototype.getDefaultCenter = function() {
      var t = this.getBoundingRect(), n = t.x + t.width / 2, i = t.y + t.height / 2;
      return [
        n,
        i
      ];
    }, e.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, e.prototype.getZoom = function() {
      return this._zoom || 1;
    }, e.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, e.prototype._updateCenterAndZoom = function() {
      var t = this._rawTransformable.getLocalTransform(), n = this._roamTransformable, i = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
      a = xr([], a, t), i = xr([], i, t), n.originX = a[0], n.originY = a[1], n.x = i[0] - a[0], n.y = i[1] - a[1], n.scaleX = n.scaleY = o, this._updateTransform();
    }, e.prototype._updateTransform = function() {
      var t = this._roamTransformable, n = this._rawTransformable;
      n.parent = t, t.updateTransform(), n.updateTransform(), jb(this.transform || (this.transform = []), n.transform || pn()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], Pu(this.invTransform, this.transform), this.decomposeTransform();
    }, e.prototype.getTransformInfo = function() {
      var t = this._rawTransformable, n = this._roamTransformable, i = new ta();
      return i.transform = n.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: t.x,
          y: t.y,
          scaleX: t.scaleX,
          scaleY: t.scaleY
        }
      };
    }, e.prototype.getViewRect = function() {
      return this._viewRect;
    }, e.prototype.getViewRectAfterRoam = function() {
      var t = this.getBoundingRect().clone();
      return t.applyTransform(this.transform), t;
    }, e.prototype.dataToPoint = function(t, n, i) {
      var a = n ? this._rawTransform : this.transform;
      return i = i || [], a ? qA(i, t, a) : Fr(i, t);
    }, e.prototype.pointToData = function(t) {
      var n = this.invTransform;
      return n ? qA([], t, n) : [
        t[0],
        t[1]
      ];
    }, e.prototype.convertToPixel = function(t, n, i) {
      var a = KA(n);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, n, i) {
      var a = KA(n);
      return a === this ? a.pointToData(i) : null;
    }, e.prototype.containPoint = function(t) {
      return this.getViewRectAfterRoam().contain(t[0], t[1]);
    }, e.dimensions = [
      "x",
      "y"
    ], e;
  }(ta);
  function KA(r) {
    var e = r.seriesModel;
    return e ? e.coordinateSystem : null;
  }
  var dj = {
    geoJSON: {
      aspectScale: 0.75,
      invertLongitute: true
    },
    geoSVG: {
      aspectScale: 1,
      invertLongitute: false
    }
  }, _O = [
    "lng",
    "lat"
  ], v_ = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this, t) || this;
      a.dimensions = _O, a.type = "geo", a._nameCoordMap = ce(), a.map = n;
      var o = i.projection, s = _a.load(n, i.nameMap, i.nameProperty), l = _a.getGeoResource(n);
      a.resourceType = l ? l.type : null;
      var u = a.regions = s.regions, c = dj[l.type];
      a._regionsMap = s.regionsMap, a.regions = s.regions, a.projection = o;
      var h;
      if (o) for (var f = 0; f < u.length; f++) {
        var d = u[f].getBoundingRect(o);
        h = h || d.clone(), h.union(d);
      }
      else h = s.boundingRect;
      return a.setBoundingRect(h.x, h.y, h.width, h.height), a.aspectScale = o ? 1 : Pe(i.aspectScale, c.aspectScale), a._invertLongitute = o ? false : c.invertLongitute, a;
    }
    return e.prototype._transformTo = function(t, n, i, a) {
      var o = this.getBoundingRect(), s = this._invertLongitute;
      o = o.clone(), s && (o.y = -o.y - o.height);
      var l = this._rawTransformable;
      l.transform = o.calculateTransform(new Oe(t, n, i, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, e.prototype.getRegion = function(t) {
      return this._regionsMap.get(t);
    }, e.prototype.getRegionByCoord = function(t) {
      for (var n = this.regions, i = 0; i < n.length; i++) {
        var a = n[i];
        if (a.type === "geoJSON" && a.contain(t)) return n[i];
      }
    }, e.prototype.addGeoCoord = function(t, n) {
      this._nameCoordMap.set(t, n);
    }, e.prototype.getGeoCoord = function(t) {
      var n = this._regionsMap.get(t);
      return this._nameCoordMap.get(t) || n && n.getCenter();
    }, e.prototype.dataToPoint = function(t, n, i) {
      if (ee(t) && (t = this.getGeoCoord(t)), t) {
        var a = this.projection;
        return a && (t = a.project(t)), t && this.projectedToPoint(t, n, i);
      }
    }, e.prototype.pointToData = function(t) {
      var n = this.projection;
      return n && (t = n.unproject(t)), t && this.pointToProjected(t);
    }, e.prototype.pointToProjected = function(t) {
      return r.prototype.pointToData.call(this, t);
    }, e.prototype.projectedToPoint = function(t, n, i) {
      return r.prototype.dataToPoint.call(this, t, n, i);
    }, e.prototype.convertToPixel = function(t, n, i) {
      var a = ZA(n);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, n, i) {
      var a = ZA(n);
      return a === this ? a.pointToData(i) : null;
    }, e;
  }(Rf);
  qt(v_, Rf);
  function ZA(r) {
    var e = r.geoModel, t = r.seriesModel;
    return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", Yt).models[0] || {}).coordinateSystem : null;
  }
  function jA(r, e) {
    var t = r.get("boundingCoords");
    if (t != null) {
      var n = t[0], i = t[1];
      if (isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])) {
        var a = this.projection;
        if (a) {
          var o = n[0], s = n[1], l = i[0], u = i[1];
          n = [
            1 / 0,
            1 / 0
          ], i = [
            -1 / 0,
            -1 / 0
          ];
          var c = function(b, w, C, T) {
            for (var A = C - b, M = T - w, E = 0; E <= 100; E++) {
              var k = E / 100, R = a.project([
                b + A * k,
                w + M * k
              ]);
              Ya(n, n, R), Xa(i, i, R);
            }
          };
          c(o, s, l, s), c(l, s, l, u), c(l, u, o, u), c(o, u, l, s);
        }
        this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1]);
      }
    }
    var h = this.getBoundingRect(), f = r.get("layoutCenter"), d = r.get("layoutSize"), p = e.getWidth(), v = e.getHeight(), g = h.width / h.height * this.aspectScale, m = false, y, x;
    f && d && (y = [
      Q(f[0], p),
      Q(f[1], v)
    ], x = Q(d, Math.min(p, v)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(x) && (m = true));
    var _;
    if (m) _ = {}, g > 1 ? (_.width = x, _.height = x / g) : (_.height = x, _.width = x * g), _.y = y[1] - _.height / 2, _.x = y[0] - _.width / 2;
    else {
      var S = r.getBoxLayoutParams();
      S.aspect = g, _ = er(S, {
        width: p,
        height: v
      });
    }
    this.setViewRect(_.x, _.y, _.width, _.height), this.setCenter(r.get("center"), e), this.setZoom(r.get("zoom"));
  }
  function pj(r, e) {
    D(e.get("geoCoord"), function(t, n) {
      r.addGeoCoord(n, t);
    });
  }
  var vj = function() {
    function r() {
      this.dimensions = _O;
    }
    return r.prototype.create = function(e, t) {
      var n = [];
      function i(o) {
        return {
          nameProperty: o.get("nameProperty"),
          aspectScale: o.get("aspectScale"),
          projection: o.get("projection")
        };
      }
      e.eachComponent("geo", function(o, s) {
        var l = o.get("map"), u = new v_(l + s, l, H({
          nameMap: o.get("nameMap")
        }, i(o)));
        u.zoomLimit = o.get("scaleLimit"), n.push(u), o.coordinateSystem = u, u.model = o, u.resize = jA, u.resize(o, t);
      }), e.eachSeries(function(o) {
        var s = o.get("coordinateSystem");
        if (s === "geo") {
          var l = o.get("geoIndex") || 0;
          o.coordinateSystem = n[l];
        }
      });
      var a = {};
      return e.eachSeriesByType("map", function(o) {
        if (!o.getHostGeoModel()) {
          var s = o.getMapType();
          a[s] = a[s] || [], a[s].push(o);
        }
      }), D(a, function(o, s) {
        var l = K(o, function(c) {
          return c.get("nameMap");
        }), u = new v_(s, s, H({
          nameMap: Xb(l)
        }, i(o[0])));
        u.zoomLimit = vr.apply(null, K(o, function(c) {
          return c.get("scaleLimit");
        })), n.push(u), u.resize = jA, u.resize(o[0], t), D(o, function(c) {
          c.coordinateSystem = u, pj(u, c);
        });
      }), n;
    }, r.prototype.getFilledRegions = function(e, t, n, i) {
      for (var a = (e || []).slice(), o = ce(), s = 0; s < a.length; s++) o.set(a[s].name, a[s]);
      var l = _a.load(t, n, i);
      return D(l.regions, function(u) {
        var c = u.name, h = o.get(c), f = u.properties && u.properties.echartsStyle;
        h || (h = {
          name: c
        }, a.push(h)), f && Ee(h, f);
      }), a;
    }, r;
  }(), bO = new vj(), gj = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n, i) {
      var a = _a.getGeoResource(t.map);
      if (a && a.type === "geoJSON") {
        var o = t.itemStyle = t.itemStyle || {};
        "color" in o || (o.color = "#eee");
      }
      this.mergeDefaultAndTheme(t, i), Bs(t, "label", [
        "show"
      ]);
    }, e.prototype.optionUpdated = function() {
      var t = this, n = this.option;
      n.regions = bO.getFilledRegions(n.regions, n.map, n.nameMap, n.nameProperty);
      var i = {};
      this._optionModelMap = Fi(n.regions || [], function(a, o) {
        var s = o.name;
        return s && (a.set(s, new ft(o, t, t.ecModel)), o.selected && (i[s] = true)), a;
      }, ce()), n.selectedMap || (n.selectedMap = i);
    }, e.prototype.getRegionModel = function(t) {
      return this._optionModelMap.get(t) || new ft(null, this, this.ecModel);
    }, e.prototype.getFormattedLabel = function(t, n) {
      var i = this.getRegionModel(t), a = n === "normal" ? i.get([
        "label",
        "formatter"
      ]) : i.get([
        "emphasis",
        "label",
        "formatter"
      ]), o = {
        name: t
      };
      if (ge(a)) return o.status = n, a(o);
      if (ee(a)) return a.replace("{a}", t ?? "");
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.select = function(t) {
      var n = this.option, i = n.selectedMode;
      if (i) {
        i !== "multiple" && (n.selectedMap = null);
        var a = n.selectedMap || (n.selectedMap = {});
        a[t] = true;
      }
    }, e.prototype.unSelect = function(t) {
      var n = this.option.selectedMap;
      n && (n[t] = false);
    }, e.prototype.toggleSelected = function(t) {
      this[this.isSelected(t) ? "unSelect" : "select"](t);
    }, e.prototype.isSelected = function(t) {
      var n = this.option.selectedMap;
      return !!(n && n[t]);
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
      z: 0,
      show: true,
      left: "center",
      top: "center",
      aspectScale: null,
      silent: false,
      map: "",
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
    }, e;
  }(Ke);
  function QA(r, e) {
    return r.pointToProjected ? r.pointToProjected(e) : r.pointToData(e);
  }
  function aS(r, e, t, n) {
    var i = r.getZoom(), a = r.getCenter(), o = e.zoom, s = r.projectedToPoint ? r.projectedToPoint(a) : r.dataToPoint(a);
    if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, r.setCenter(QA(r, s), n)), o != null) {
      if (t) {
        var l = t.min || 0, u = t.max || 1 / 0;
        o = Math.max(Math.min(i * o, u), l) / i;
      }
      r.scaleX *= o, r.scaleY *= o;
      var c = (e.originX - r.x) * (o - 1), h = (e.originY - r.y) * (o - 1);
      r.x -= c, r.y -= h, r.updateTransform(), r.setCenter(QA(r, s), n), r.setZoom(o * i);
    }
    return {
      center: r.getCenter(),
      zoom: r.getZoom()
    };
  }
  var mj = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.focusBlurEnabled = true, t;
    }
    return e.prototype.init = function(t, n) {
      this._api = n;
    }, e.prototype.render = function(t, n, i, a) {
      if (this._model = t, !t.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new xO(i));
      var o = this._mapDraw;
      o.draw(t, n, i, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = t.get("silent"), this.group.add(o.group), this.updateSelectStatus(t, n, i);
    }, e.prototype._handleRegionClick = function(t) {
      var n;
      xs(t.target, function(i) {
        return (n = De(i).eventData) != null;
      }, true), n && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: n.name
      });
    }, e.prototype.updateSelectStatus = function(t, n, i) {
      var a = this;
      this._mapDraw.group.traverse(function(o) {
        var s = De(o).eventData;
        if (s) return a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o), true;
      });
    }, e.prototype.findHighDownDispatchers = function(t) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model);
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, e.type = "geo", e;
  }(Rt);
  function yj(r, e, t) {
    _a.registerMap(r, e, t);
  }
  function SO(r) {
    r.registerCoordinateSystem("geo", bO), r.registerComponentModel(gj), r.registerComponentView(mj), r.registerImpl("registerMap", yj), r.registerImpl("getMap", function(t) {
      return _a.getMapForUser(t);
    });
    function e(t, n) {
      n.update = "geo:updateSelectStatus", r.registerAction(n, function(i, a) {
        var o = {}, s = [];
        return a.eachComponent({
          mainType: "geo",
          query: i
        }, function(l) {
          l[t](i.name);
          var u = l.coordinateSystem;
          D(u.regions, function(h) {
            o[h.name] = l.isSelected(h.name) || false;
          });
          var c = [];
          D(o, function(h, f) {
            o[f] && c.push(f);
          }), s.push({
            geoIndex: l.componentIndex,
            name: c
          });
        }), {
          selected: o,
          allSelected: s,
          name: i.name
        };
      });
    }
    e("toggleSelected", {
      type: "geoToggleSelect",
      event: "geoselectchanged"
    }), e("select", {
      type: "geoSelect",
      event: "geoselected"
    }), e("unSelect", {
      type: "geoUnSelect",
      event: "geounselected"
    }), r.registerAction({
      type: "geoRoam",
      event: "geoRoam",
      update: "updateTransform"
    }, function(t, n, i) {
      var a = t.componentType || "series";
      n.eachComponent({
        mainType: a,
        query: t
      }, function(o) {
        var s = o.coordinateSystem;
        if (s.type === "geo") {
          var l = aS(s, t, o.get("scaleLimit"), i);
          o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && D(o.seriesGroup, function(u) {
            u.setCenter(l.center), u.setZoom(l.zoom);
          });
        }
      });
    });
  }
  function xj(r) {
    Ve(SO), r.registerChartView(lj), r.registerSeriesModel(uj), r.registerLayout(fj), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, hj), w3("map", r.registerAction);
  }
  function _j(r) {
    var e = r;
    e.hierNode = {
      defaultAncestor: null,
      ancestor: e,
      prelim: 0,
      modifier: 0,
      change: 0,
      shift: 0,
      i: 0,
      thread: null
    };
    for (var t = [
      e
    ], n, i; n = t.pop(); ) if (i = n.children, n.isExpand && i.length) for (var a = i.length, o = a - 1; o >= 0; o--) {
      var s = i[o];
      s.hierNode = {
        defaultAncestor: null,
        ancestor: s,
        prelim: 0,
        modifier: 0,
        change: 0,
        shift: 0,
        i: o,
        thread: null
      }, t.push(s);
    }
  }
  function bj(r, e) {
    var t = r.isExpand ? r.children : [], n = r.parentNode.children, i = r.hierNode.i ? n[r.hierNode.i - 1] : null;
    if (t.length) {
      Cj(r);
      var a = (t[0].hierNode.prelim + t[t.length - 1].hierNode.prelim) / 2;
      i ? (r.hierNode.prelim = i.hierNode.prelim + e(r, i), r.hierNode.modifier = r.hierNode.prelim - a) : r.hierNode.prelim = a;
    } else i && (r.hierNode.prelim = i.hierNode.prelim + e(r, i));
    r.parentNode.hierNode.defaultAncestor = Tj(r, i, r.parentNode.hierNode.defaultAncestor || n[0], e);
  }
  function Sj(r) {
    var e = r.hierNode.prelim + r.parentNode.hierNode.modifier;
    r.setLayout({
      x: e
    }, true), r.hierNode.modifier += r.parentNode.hierNode.modifier;
  }
  function JA(r) {
    return arguments.length ? r : Mj;
  }
  function Fc(r, e) {
    return r -= Math.PI / 2, {
      x: e * Math.cos(r),
      y: e * Math.sin(r)
    };
  }
  function wj(r, e) {
    return er(r.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function Cj(r) {
    for (var e = r.children, t = e.length, n = 0, i = 0; --t >= 0; ) {
      var a = e[t];
      a.hierNode.prelim += n, a.hierNode.modifier += n, i += a.hierNode.change, n += a.hierNode.shift + i;
    }
  }
  function Tj(r, e, t, n) {
    if (e) {
      for (var i = r, a = r, o = a.parentNode.children[0], s = e, l = i.hierNode.modifier, u = a.hierNode.modifier, c = o.hierNode.modifier, h = s.hierNode.modifier; s = yy(s), a = xy(a), s && a; ) {
        i = yy(i), o = xy(o), i.hierNode.ancestor = r;
        var f = s.hierNode.prelim + h - a.hierNode.prelim - u + n(s, a);
        f > 0 && (Ij(Aj(s, r, t), r, f), u += f, l += f), h += s.hierNode.modifier, u += a.hierNode.modifier, l += i.hierNode.modifier, c += o.hierNode.modifier;
      }
      s && !yy(i) && (i.hierNode.thread = s, i.hierNode.modifier += h - l), a && !xy(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - c, t = r);
    }
    return t;
  }
  function yy(r) {
    var e = r.children;
    return e.length && r.isExpand ? e[e.length - 1] : r.hierNode.thread;
  }
  function xy(r) {
    var e = r.children;
    return e.length && r.isExpand ? e[0] : r.hierNode.thread;
  }
  function Aj(r, e, t) {
    return r.hierNode.ancestor.parentNode === e.parentNode ? r.hierNode.ancestor : t;
  }
  function Ij(r, e, t) {
    var n = t / (e.hierNode.i - r.hierNode.i);
    e.hierNode.change -= n, e.hierNode.shift += t, e.hierNode.modifier += t, e.hierNode.prelim += t, r.hierNode.change += n;
  }
  function Mj(r, e) {
    return r.parentNode === e.parentNode ? 1 : 2;
  }
  var Dj = /* @__PURE__ */ function() {
    function r() {
      this.parentPoint = [], this.childPoints = [];
    }
    return r;
  }(), Pj = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new Dj();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.childPoints, a = i.length, o = n.parentPoint, s = i[0], l = i[a - 1];
      if (a === 1) {
        t.moveTo(o[0], o[1]), t.lineTo(s[0], s[1]);
        return;
      }
      var u = n.orient, c = u === "TB" || u === "BT" ? 0 : 1, h = 1 - c, f = Q(n.forkPosition, 1), d = [];
      d[c] = o[c], d[h] = o[h] + (l[h] - o[h]) * f, t.moveTo(o[0], o[1]), t.lineTo(d[0], d[1]), t.moveTo(s[0], s[1]), d[c] = s[c], t.lineTo(d[0], d[1]), d[c] = l[c], t.lineTo(d[0], d[1]), t.lineTo(l[0], l[1]);
      for (var p = 1; p < a - 1; p++) {
        var v = i[p];
        t.moveTo(v[0], v[1]), d[c] = v[c], t.lineTo(d[0], d[1]);
      }
    }, e;
  }(Ue), kj = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._mainGroup = new Ce(), t;
    }
    return e.prototype.init = function(t, n) {
      this._controller = new Lf(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = t.layoutInfo, s = this._mainGroup, l = t.get("layout");
      l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(t, i), this._updateController(t, n, i);
      var u = this._data;
      a.diff(u).add(function(c) {
        eI(a, c) && tI(a, c, null, s, t);
      }).update(function(c, h) {
        var f = u.getItemGraphicEl(h);
        if (!eI(a, c)) {
          f && nI(u, h, f, s, t);
          return;
        }
        tI(a, c, f, s, t);
      }).remove(function(c) {
        var h = u.getItemGraphicEl(c);
        h && nI(u, c, h, s, t);
      }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === true && a.eachItemGraphicEl(function(c, h) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: t.id,
            dataIndex: h
          });
        });
      }), this._data = a;
    }, e.prototype._updateViewCoordSys = function(t, n) {
      var i = t.getData(), a = [];
      i.each(function(h) {
        var f = i.getItemLayout(h);
        f && !isNaN(f.x) && !isNaN(f.y) && a.push([
          +f.x,
          +f.y
        ]);
      });
      var o = [], s = [];
      Jv(a, o, s);
      var l = this._min, u = this._max;
      s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = t.coordinateSystem = new Rf();
      c.zoomLimit = t.get("scaleLimit"), c.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), c.setCenter(t.get("center"), n), c.setZoom(t.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = o, this._max = s;
    }, e.prototype._updateController = function(t, n, i) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      o.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !wg(u, i, t);
      }), o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        rS(s, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        nS(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(t), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function(t) {
      var n = t.getData(), i = this._getNodeGlobalScale(t);
      n.eachItemGraphicEl(function(a, o) {
        a.setSymbolScale(i);
      });
    }, e.prototype._getNodeGlobalScale = function(t) {
      var n = t.coordinateSystem;
      if (n.type !== "view") return 1;
      var i = this._nodeScaleRatio, a = n.scaleX || 1, o = n.getZoom(), s = (o - 1) * i + 1;
      return s / a;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, e.type = "tree", e;
  }(yt);
  function eI(r, e) {
    var t = r.getItemLayout(e);
    return t && !isNaN(t.x) && !isNaN(t.y);
  }
  function tI(r, e, t, n, i) {
    var a = !t, o = r.tree.getNodeByDataIndex(e), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === false && o.children.length !== 0 ? l : "#fff", c = r.tree.root, h = o.parentNode === c ? o : o.parentNode || o, f = r.getItemGraphicEl(h.dataIndex), d = h.getLayout(), p = f ? {
      x: f.__oldX,
      y: f.__oldY,
      rawX: f.__radialOldRawX,
      rawY: f.__radialOldRawY
    } : d, v = o.getLayout();
    a ? (t = new Af(r, e, null, {
      symbolInnerColor: u,
      useNameLabel: true
    }), t.x = p.x, t.y = p.y) : t.updateData(r, e, null, {
      symbolInnerColor: u,
      useNameLabel: true
    }), t.__radialOldRawX = t.__radialRawX, t.__radialOldRawY = t.__radialRawY, t.__radialRawX = v.rawX, t.__radialRawY = v.rawY, n.add(t), r.setItemGraphicEl(e, t), t.__oldX = t.x, t.__oldY = t.y, it(t, {
      x: v.x,
      y: v.y
    }, i);
    var g = t.getSymbolPath();
    if (i.get("layout") === "radial") {
      var m = c.children[0], y = m.getLayout(), x = m.children.length, _ = void 0, S = void 0;
      if (v.x === y.x && o.isExpand === true && m.children.length) {
        var b = {
          x: (m.children[0].getLayout().x + m.children[x - 1].getLayout().x) / 2,
          y: (m.children[0].getLayout().y + m.children[x - 1].getLayout().y) / 2
        };
        _ = Math.atan2(b.y - y.y, b.x - y.x), _ < 0 && (_ = Math.PI * 2 + _), S = b.x < y.x, S && (_ = _ - Math.PI);
      } else _ = Math.atan2(v.y - y.y, v.x - y.x), _ < 0 && (_ = Math.PI * 2 + _), o.children.length === 0 || o.children.length !== 0 && o.isExpand === false ? (S = v.x < y.x, S && (_ = _ - Math.PI)) : (S = v.x > y.x, S || (_ = _ - Math.PI));
      var w = S ? "left" : "right", C = s.getModel("label"), T = C.get("rotate"), A = T * (Math.PI / 180), M = g.getTextContent();
      M && (g.setTextConfig({
        position: C.get("position") || w,
        rotation: T == null ? -_ : A,
        origin: "center"
      }), M.setStyle("verticalAlign", "middle"));
    }
    var E = s.get([
      "emphasis",
      "focus"
    ]), k = E === "relative" ? _h(o.getAncestorsIndices(), o.getDescendantIndices()) : E === "ancestor" ? o.getAncestorsIndices() : E === "descendant" ? o.getDescendantIndices() : null;
    k && (De(t).focus = k), Lj(i, o, c, t, p, d, v, n), t.__edge && (t.onHoverStateChange = function(R) {
      if (R !== "blur") {
        var N = o.parentNode && r.getItemGraphicEl(o.parentNode.dataIndex);
        N && N.hoverState === gf || Up(t.__edge, R);
      }
    });
  }
  function Lj(r, e, t, n, i, a, o, s) {
    var l = e.getModel(), u = r.get("edgeShape"), c = r.get("layout"), h = r.getOrient(), f = r.get([
      "lineStyle",
      "curveness"
    ]), d = r.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), v = n.__edge;
    if (u === "curve") e.parentNode && e.parentNode !== t && (v || (v = n.__edge = new yf({
      shape: g_(c, h, f, i, i)
    })), it(v, {
      shape: g_(c, h, f, a, o)
    }, r));
    else if (u === "polyline" && c === "orthogonal" && e !== t && e.children && e.children.length !== 0 && e.isExpand === true) {
      for (var g = e.children, m = [], y = 0; y < g.length; y++) {
        var x = g[y].getLayout();
        m.push([
          x.x,
          x.y
        ]);
      }
      v || (v = n.__edge = new Pj({
        shape: {
          parentPoint: [
            o.x,
            o.y
          ],
          childPoints: [
            [
              o.x,
              o.y
            ]
          ],
          orient: h,
          forkPosition: d
        }
      })), it(v, {
        shape: {
          parentPoint: [
            o.x,
            o.y
          ],
          childPoints: m
        }
      }, r);
    }
    v && !(u === "polyline" && !e.isExpand) && (v.useStyle(ye({
      strokeNoScale: true,
      fill: null
    }, p)), br(v, l, "lineStyle"), $s(v), s.add(v));
  }
  function rI(r, e, t, n, i) {
    var a = e.tree.root, o = wO(a, r), s = o.source, l = o.sourceLayout, u = e.getItemGraphicEl(r.dataIndex);
    if (u) {
      var c = e.getItemGraphicEl(s.dataIndex), h = c.__edge, f = u.__edge || (s.isExpand === false || s.children.length === 1 ? h : void 0), d = n.get("edgeShape"), p = n.get("layout"), v = n.get("orient"), g = n.get([
        "lineStyle",
        "curveness"
      ]);
      f && (d === "curve" ? uo(f, {
        shape: g_(p, v, g, l, l),
        style: {
          opacity: 0
        }
      }, n, {
        cb: function() {
          t.remove(f);
        },
        removeOpt: i
      }) : d === "polyline" && n.get("layout") === "orthogonal" && uo(f, {
        shape: {
          parentPoint: [
            l.x,
            l.y
          ],
          childPoints: [
            [
              l.x,
              l.y
            ]
          ]
        },
        style: {
          opacity: 0
        }
      }, n, {
        cb: function() {
          t.remove(f);
        },
        removeOpt: i
      }));
    }
  }
  function wO(r, e) {
    for (var t = e.parentNode === r ? e : e.parentNode || e, n; n = t.getLayout(), n == null; ) t = t.parentNode === r ? t : t.parentNode || t;
    return {
      source: t,
      sourceLayout: n
    };
  }
  function nI(r, e, t, n, i) {
    var a = r.tree.getNodeByDataIndex(e), o = r.tree.root, s = wO(o, a).sourceLayout, l = {
      duration: i.get("animationDurationUpdate"),
      easing: i.get("animationEasingUpdate")
    };
    uo(t, {
      x: s.x + 1,
      y: s.y + 1
    }, i, {
      cb: function() {
        n.remove(t), r.setItemGraphicEl(e, null);
      },
      removeOpt: l
    }), t.fadeOut(null, r.hostModel, {
      fadeLabel: true,
      animation: l
    }), a.children.forEach(function(u) {
      rI(u, r, n, i, l);
    }), rI(a, r, n, i, l);
  }
  function g_(r, e, t, n, i) {
    var a, o, s, l, u, c, h, f;
    if (r === "radial") {
      u = n.rawX, h = n.rawY, c = i.rawX, f = i.rawY;
      var d = Fc(u, h), p = Fc(u, h + (f - h) * t), v = Fc(c, f + (h - f) * t), g = Fc(c, f);
      return {
        x1: d.x || 0,
        y1: d.y || 0,
        x2: g.x || 0,
        y2: g.y || 0,
        cpx1: p.x || 0,
        cpy1: p.y || 0,
        cpx2: v.x || 0,
        cpy2: v.y || 0
      };
    } else u = n.x, h = n.y, c = i.x, f = i.y, (e === "LR" || e === "RL") && (a = u + (c - u) * t, o = h, s = c + (u - c) * t, l = f), (e === "TB" || e === "BT") && (a = u, o = h + (f - h) * t, s = c, l = f + (h - f) * t);
    return {
      x1: u,
      y1: h,
      x2: c,
      y2: f,
      cpx1: a,
      cpy1: o,
      cpx2: s,
      cpy2: l
    };
  }
  var Bn = tt();
  function CO(r) {
    var e = r.mainData, t = r.datas;
    t || (t = {
      main: e
    }, r.datasAttr = {
      main: "data"
    }), r.datas = r.mainData = null, TO(e, t, r), D(t, function(n) {
      D(e.TRANSFERABLE_METHODS, function(i) {
        n.wrapMethod(i, Le(Rj, r));
      });
    }), e.wrapMethod("cloneShallow", Le(Nj, r)), D(e.CHANGABLE_METHODS, function(n) {
      e.wrapMethod(n, Le(Ej, r));
    }), Yr(t[e.dataType] === e);
  }
  function Rj(r, e) {
    if (Bj(this)) {
      var t = H({}, Bn(this).datas);
      t[this.dataType] = e, TO(e, t, r);
    } else oS(e, this.dataType, Bn(this).mainData, r);
    return e;
  }
  function Ej(r, e) {
    return r.struct && r.struct.update(), e;
  }
  function Nj(r, e) {
    return D(Bn(e).datas, function(t, n) {
      t !== e && oS(t.cloneShallow(), n, e, r);
    }), e;
  }
  function Oj(r) {
    var e = Bn(this).mainData;
    return r == null || e == null ? e : Bn(e).datas[r];
  }
  function Fj() {
    var r = Bn(this).mainData;
    return r == null ? [
      {
        data: r
      }
    ] : K(je(Bn(r).datas), function(e) {
      return {
        type: e,
        data: Bn(r).datas[e]
      };
    });
  }
  function Bj(r) {
    return Bn(r).mainData === r;
  }
  function TO(r, e, t) {
    Bn(r).datas = {}, D(e, function(n, i) {
      oS(n, i, r, t);
    });
  }
  function oS(r, e, t, n) {
    Bn(t).datas[e] = r, Bn(r).mainData = t, r.dataType = e, n.struct && (r[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = r), r.getLinkedData = Oj, r.getLinkedDataAll = Fj;
  }
  var zj = function() {
    function r(e, t) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = false, this.name = e || "", this.hostTree = t;
    }
    return r.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, r.prototype.eachNode = function(e, t, n) {
      ge(e) && (n = t, t = e, e = null), e = e || {}, ee(e) && (e = {
        order: e
      });
      var i = e.order || "preorder", a = this[e.attr || "children"], o;
      i === "preorder" && (o = t.call(n, this));
      for (var s = 0; !o && s < a.length; s++) a[s].eachNode(e, t, n);
      i === "postorder" && t.call(n, this);
    }, r.prototype.updateDepthAndHeight = function(e) {
      var t = 0;
      this.depth = e;
      for (var n = 0; n < this.children.length; n++) {
        var i = this.children[n];
        i.updateDepthAndHeight(e + 1), i.height > t && (t = i.height);
      }
      this.height = t + 1;
    }, r.prototype.getNodeById = function(e) {
      if (this.getId() === e) return this;
      for (var t = 0, n = this.children, i = n.length; t < i; t++) {
        var a = n[t].getNodeById(e);
        if (a) return a;
      }
    }, r.prototype.contains = function(e) {
      if (e === this) return true;
      for (var t = 0, n = this.children, i = n.length; t < i; t++) {
        var a = n[t].contains(e);
        if (a) return a;
      }
    }, r.prototype.getAncestors = function(e) {
      for (var t = [], n = e ? this : this.parentNode; n; ) t.push(n), n = n.parentNode;
      return t.reverse(), t;
    }, r.prototype.getAncestorsIndices = function() {
      for (var e = [], t = this; t; ) e.push(t.dataIndex), t = t.parentNode;
      return e.reverse(), e;
    }, r.prototype.getDescendantIndices = function() {
      var e = [];
      return this.eachNode(function(t) {
        e.push(t.dataIndex);
      }), e;
    }, r.prototype.getValue = function(e) {
      var t = this.hostTree.data;
      return t.getStore().get(t.getDimensionIndex(e || "value"), this.dataIndex);
    }, r.prototype.setLayout = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t);
    }, r.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostTree, n = t.data.getItemModel(this.dataIndex);
        return n.getModel(e);
      }
    }, r.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, r.prototype.setVisual = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t);
    }, r.prototype.getVisual = function(e) {
      return this.hostTree.data.getItemVisual(this.dataIndex, e);
    }, r.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, r.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, r.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var e = this.parentNode.children, t = 0; t < e.length; ++t) if (e[t] === this) return t;
        return -1;
      }
      return -1;
    }, r.prototype.isAncestorOf = function(e) {
      for (var t = e.parentNode; t; ) {
        if (t === this) return true;
        t = t.parentNode;
      }
      return false;
    }, r.prototype.isDescendantOf = function(e) {
      return e !== this && e.isAncestorOf(this);
    }, r;
  }(), sS = function() {
    function r(e) {
      this.type = "tree", this._nodes = [], this.hostModel = e;
    }
    return r.prototype.eachNode = function(e, t, n) {
      this.root.eachNode(e, t, n);
    }, r.prototype.getNodeByDataIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this._nodes[t];
    }, r.prototype.getNodeById = function(e) {
      return this.root.getNodeById(e);
    }, r.prototype.update = function() {
      for (var e = this.data, t = this._nodes, n = 0, i = t.length; n < i; n++) t[n].dataIndex = -1;
      for (var n = 0, i = e.count(); n < i; n++) t[e.getRawIndex(n)].dataIndex = n;
    }, r.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, r.createTree = function(e, t, n) {
      var i = new r(t), a = [], o = 1;
      s(e);
      function s(c, h) {
        var f = c.value;
        o = Math.max(o, X(f) ? f.length : 1), a.push(c);
        var d = new zj(jt(c.name, ""), i);
        h ? Vj(d, h) : i.root = d, i._nodes.push(d);
        var p = c.children;
        if (p) for (var v = 0; v < p.length; v++) s(p[v], d);
      }
      i.root.updateDepthAndHeight(0);
      var l = Cf(a, {
        coordDimensions: [
          "value"
        ],
        dimensionsCount: o
      }).dimensions, u = new Wr(l, t);
      return u.initData(a), n && n(u), CO({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, r;
  }();
  function Vj(r, e) {
    var t = e.children;
    r.parentNode !== e && (t.push(r), r.parentNode = e);
  }
  function Vh(r, e, t) {
    if (r && Be(e, r.type) >= 0) {
      var n = t.getData().tree.root, i = r.targetNode;
      if (ee(i) && (i = n.getNodeById(i)), i && n.contains(i)) return {
        node: i
      };
      var a = r.targetNodeId;
      if (a != null && (i = n.getNodeById(a))) return {
        node: i
      };
    }
  }
  function AO(r) {
    for (var e = []; r; ) r = r.parentNode, r && e.push(r);
    return e.reverse();
  }
  function lS(r, e) {
    var t = AO(r);
    return Be(t, e) >= 0;
  }
  function Tg(r, e) {
    for (var t = []; r; ) {
      var n = r.dataIndex;
      t.push({
        name: r.name,
        dataIndex: n,
        value: e.getRawValue(n)
      }), r = r.parentNode;
    }
    return t.reverse(), t;
  }
  var $j = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.hasSymbolVisual = true, t.ignoreStyleOnData = true, t;
    }
    return e.prototype.getInitialData = function(t) {
      var n = {
        name: t.name,
        children: t.data
      }, i = t.leaves || {}, a = new ft(i, this, this.ecModel), o = sS.createTree(n, this, s);
      function s(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = o.getNodeByDataIndex(d);
          return p && p.children.length && p.isExpand || (f.parentModel = a), f;
        });
      }
      var l = 0;
      o.eachNode("preorder", function(h) {
        h.depth > l && (l = h.depth);
      });
      var u = t.expandAndCollapse, c = u && t.initialTreeDepth >= 0 ? t.initialTreeDepth : l;
      return o.root.eachNode("preorder", function(h) {
        var f = h.hostTree.data.getRawDataItem(h.dataIndex);
        h.isExpand = f && f.collapsed != null ? !f.collapsed : h.depth <= c;
      }), o.data;
    }, e.prototype.getOrient = function() {
      var t = this.get("orient");
      return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t;
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.formatTooltip = function(t, n, i) {
      for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(t), l = s.getValue(), u = s.name; s && s !== o; ) u = s.parentNode.name + "." + u, s = s.parentNode;
      return ur("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, e.prototype.getDataParams = function(t) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return n.treeAncestors = Tg(i, this), n.collapsed = !i.isExpand, n;
    }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      layout: "orthogonal",
      edgeShape: "curve",
      edgeForkPosition: "50%",
      roam: false,
      nodeScaleRatio: 0.4,
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: true,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        borderWidth: 1.5
      },
      label: {
        show: true
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, e;
  }(Tt);
  function Gj(r, e, t) {
    for (var n = [
      r
    ], i = [], a; a = n.pop(); ) if (i.push(a), a.isExpand) {
      var o = a.children;
      if (o.length) for (var s = 0; s < o.length; s++) n.push(o[s]);
    }
    for (; a = i.pop(); ) e(a, t);
  }
  function vc(r, e) {
    for (var t = [
      r
    ], n; n = t.pop(); ) if (e(n), n.isExpand) {
      var i = n.children;
      if (i.length) for (var a = i.length - 1; a >= 0; a--) t.push(i[a]);
    }
  }
  function Wj(r, e) {
    r.eachSeriesByType("tree", function(t) {
      Uj(t, e);
    });
  }
  function Uj(r, e) {
    var t = wj(r, e);
    r.layoutInfo = t;
    var n = r.get("layout"), i = 0, a = 0, o = null;
    n === "radial" ? (i = 2 * Math.PI, a = Math.min(t.height, t.width) / 2, o = JA(function(x, _) {
      return (x.parentNode === _.parentNode ? 1 : 2) / x.depth;
    })) : (i = t.width, a = t.height, o = JA());
    var s = r.getData().tree.root, l = s.children[0];
    if (l) {
      _j(s), Gj(l, bj, o), s.hierNode.modifier = -l.hierNode.prelim, vc(l, Sj);
      var u = l, c = l, h = l;
      vc(l, function(x) {
        var _ = x.getLayout().x;
        _ < u.getLayout().x && (u = x), _ > c.getLayout().x && (c = x), x.depth > h.depth && (h = x);
      });
      var f = u === c ? 1 : o(u, c) / 2, d = f - u.getLayout().x, p = 0, v = 0, g = 0, m = 0;
      if (n === "radial") p = i / (c.getLayout().x + f + d), v = a / (h.depth - 1 || 1), vc(l, function(x) {
        g = (x.getLayout().x + d) * p, m = (x.depth - 1) * v;
        var _ = Fc(g, m);
        x.setLayout({
          x: _.x,
          y: _.y,
          rawX: g,
          rawY: m
        }, true);
      });
      else {
        var y = r.getOrient();
        y === "RL" || y === "LR" ? (v = a / (c.getLayout().x + f + d), p = i / (h.depth - 1 || 1), vc(l, function(x) {
          m = (x.getLayout().x + d) * v, g = y === "LR" ? (x.depth - 1) * p : i - (x.depth - 1) * p, x.setLayout({
            x: g,
            y: m
          }, true);
        })) : (y === "TB" || y === "BT") && (p = i / (c.getLayout().x + f + d), v = a / (h.depth - 1 || 1), vc(l, function(x) {
          g = (x.getLayout().x + d) * p, m = y === "TB" ? (x.depth - 1) * v : a - (x.depth - 1) * v, x.setLayout({
            x: g,
            y: m
          }, true);
        }));
      }
    }
  }
  function Hj(r) {
    r.eachSeriesByType("tree", function(e) {
      var t = e.getData(), n = t.tree;
      n.eachNode(function(i) {
        var a = i.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = t.ensureUniqueItemVisual(i.dataIndex, "style");
        H(s, o);
      });
    });
  }
  function Yj(r) {
    r.registerAction({
      type: "treeExpandAndCollapse",
      event: "treeExpandAndCollapse",
      update: "update"
    }, function(e, t) {
      t.eachComponent({
        mainType: "series",
        subType: "tree",
        query: e
      }, function(n) {
        var i = e.dataIndex, a = n.getData().tree, o = a.getNodeByDataIndex(i);
        o.isExpand = !o.isExpand;
      });
    }), r.registerAction({
      type: "treeRoam",
      event: "treeRoam",
      update: "none"
    }, function(e, t, n) {
      t.eachComponent({
        mainType: "series",
        subType: "tree",
        query: e
      }, function(i) {
        var a = i.coordinateSystem, o = aS(a, e, void 0, n);
        i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom);
      });
    });
  }
  function Xj(r) {
    r.registerChartView(kj), r.registerSeriesModel($j), r.registerLayout(Wj), r.registerVisual(Hj), Yj(r);
  }
  var iI = [
    "treemapZoomToNode",
    "treemapRender",
    "treemapMove"
  ];
  function qj(r) {
    for (var e = 0; e < iI.length; e++) r.registerAction({
      type: iI[e],
      update: "updateView"
    }, Wt);
    r.registerAction({
      type: "treemapRootToNode",
      update: "updateView"
    }, function(t, n) {
      n.eachComponent({
        mainType: "series",
        subType: "treemap",
        query: t
      }, i);
      function i(a, o) {
        var s = [
          "treemapZoomToNode",
          "treemapRootToNode"
        ], l = Vh(t, s, a);
        if (l) {
          var u = a.getViewRoot();
          u && (t.direction = lS(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
        }
      }
    });
  }
  function IO(r) {
    var e = r.getData(), t = e.tree, n = {};
    t.eachNode(function(i) {
      for (var a = i; a && a.depth > 1; ) a = a.parentNode;
      var o = Ux(r.ecModel, a.name || a.dataIndex + "", n);
      i.setVisual("decal", o);
    });
  }
  var Kj = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.preventUsingHoverLayer = true, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      var i = {
        name: t.name,
        children: t.data
      };
      MO(i);
      var a = t.levels || [], o = this.designatedVisualItemStyle = {}, s = new ft({
        itemStyle: o
      }, this, n);
      a = t.levels = Zj(a, n);
      var l = K(a || [], function(h) {
        return new ft(h, s, n);
      }, this), u = sS.createTree(i, this, c);
      function c(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = u.getNodeByDataIndex(d), v = p ? l[p.depth] : null;
          return f.parentModel = v || s, f;
        });
      }
      return u.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.formatTooltip = function(t, n, i) {
      var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
      return ur("nameValue", {
        name: s,
        value: o
      });
    }, e.prototype.getDataParams = function(t) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return n.treeAncestors = Tg(i, this), n.treePathInfo = n.treeAncestors, n;
    }, e.prototype.setLayoutInfo = function(t) {
      this.layoutInfo = this.layoutInfo || {}, H(this.layoutInfo, t);
    }, e.prototype.mapIdToIndex = function(t) {
      var n = this._idIndexMap;
      n || (n = this._idIndexMap = ce(), this._idIndexMapCount = 0);
      var i = n.get(t);
      return i == null && n.set(t, i = this._idIndexMapCount++), i;
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!t || t !== n && !n.contains(t)) && (this._viewRoot = n);
    }, e.prototype.enableAriaDecal = function() {
      IO(this);
    }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = {
      progressive: 0,
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: true,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "\u25B6",
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: true,
      nodeClick: "zoomToNode",
      animation: true,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: true,
        height: 22,
        left: "center",
        top: "bottom",
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
          }
        }
      },
      label: {
        show: true,
        distance: 0,
        padding: 5,
        position: "inside",
        color: "#fff",
        overflow: "truncate"
      },
      upperLabel: {
        show: false,
        position: [
          0,
          "50%"
        ],
        height: 20,
        overflow: "truncate",
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
      },
      emphasis: {
        upperLabel: {
          show: true,
          position: [
            0,
            "50%"
          ],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: []
    }, e;
  }(Tt);
  function MO(r) {
    var e = 0;
    D(r.children, function(n) {
      MO(n);
      var i = n.value;
      X(i) && (i = i[0]), e += i;
    });
    var t = r.value;
    X(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), X(r.value) ? r.value[0] = t : r.value = t;
  }
  function Zj(r, e) {
    var t = gt(e.get("color")), n = gt(e.get([
      "aria",
      "decal",
      "decals"
    ]));
    if (t) {
      r = r || [];
      var i, a;
      D(r, function(s) {
        var l = new ft(s), u = l.get("color"), c = l.get("decal");
        (l.get([
          "itemStyle",
          "color"
        ]) || u && u !== "none") && (i = true), (l.get([
          "itemStyle",
          "decal"
        ]) || c && c !== "none") && (a = true);
      });
      var o = r[0] || (r[0] = {});
      return i || (o.color = t.slice()), !a && n && (o.decal = n.slice()), r;
    }
  }
  var jj = 8, aI = 8, _y = 5, Qj = function() {
    function r(e) {
      this.group = new Ce(), e.add(this.group);
    }
    return r.prototype.render = function(e, t, n, i) {
      var a = e.getModel("breadcrumb"), o = this.group;
      if (o.removeAll(), !(!a.get("show") || !n)) {
        var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel([
          "itemStyle",
          "textStyle"
        ]), h = {
          pos: {
            left: a.get("left"),
            right: a.get("right"),
            top: a.get("top"),
            bottom: a.get("bottom")
          },
          box: {
            width: t.getWidth(),
            height: t.getHeight()
          },
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(n, h, u), this._renderContent(e, h, s, l, u, c, i), fg(o, h.pos, h.box);
      }
    }, r.prototype._prepare = function(e, t, n) {
      for (var i = e; i; i = i.parentNode) {
        var a = jt(i.getModel().get("name"), ""), o = n.getTextRect(a), s = Math.max(o.width + jj * 2, t.emptyItemWidth);
        t.totalWidth += s + aI, t.renderList.push({
          node: i,
          text: a,
          width: s
        });
      }
    }, r.prototype._renderContent = function(e, t, n, i, a, o, s) {
      for (var l = 0, u = t.emptyItemWidth, c = e.get([
        "breadcrumb",
        "height"
      ]), h = oY(t.pos, t.box), f = t.totalWidth, d = t.renderList, p = i.getModel("itemStyle").getItemStyle(), v = d.length - 1; v >= 0; v--) {
        var g = d[v], m = g.node, y = g.width, x = g.text;
        f > h.width && (f -= y - u, y = u, x = null);
        var _ = new Kr({
          shape: {
            points: Jj(l, 0, y, c, v === d.length - 1, v === 0)
          },
          style: ye(n.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new rt({
            style: wt(a, {
              text: x
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: Lu * 1e4,
          onclick: Le(s, m)
        });
        _.disableLabelAnimation = true, _.getTextContent().ensureState("emphasis").style = wt(o, {
          text: x
        }), _.ensureState("emphasis").style = p, Nt(_, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(_), eQ(_, e, m), l += y + aI;
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r;
  }();
  function Jj(r, e, t, n, i, a) {
    var o = [
      [
        i ? r : r - _y,
        e
      ],
      [
        r + t,
        e
      ],
      [
        r + t,
        e + n
      ],
      [
        i ? r : r - _y,
        e + n
      ]
    ];
    return !a && o.splice(2, 0, [
      r + t + _y,
      e + n / 2
    ]), !i && o.push([
      r,
      e + n / 2
    ]), o;
  }
  function eQ(r, e, t) {
    De(r).eventData = {
      componentType: "series",
      componentSubType: "treemap",
      componentIndex: e.componentIndex,
      seriesIndex: e.seriesIndex,
      seriesName: e.name,
      seriesType: "treemap",
      selfType: "breadcrumb",
      nodeData: {
        dataIndex: t && t.dataIndex,
        name: t && t.name
      },
      treePathInfo: t && Tg(t, e)
    };
  }
  var tQ = function() {
    function r() {
      this._storage = [], this._elExistsMap = {};
    }
    return r.prototype.add = function(e, t, n, i, a) {
      return this._elExistsMap[e.id] ? false : (this._elExistsMap[e.id] = true, this._storage.push({
        el: e,
        target: t,
        duration: n,
        delay: i,
        easing: a
      }), true);
    }, r.prototype.finished = function(e) {
      return this._finishedCallback = e, this;
    }, r.prototype.start = function() {
      for (var e = this, t = this._storage.length, n = function() {
        t--, t <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback());
      }, i = 0, a = this._storage.length; i < a; i++) {
        var o = this._storage[i];
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: true,
          done: n,
          aborted: n
        });
      }
      return this;
    }, r;
  }();
  function rQ() {
    return new tQ();
  }
  var m_ = Ce, oI = et, sI = 3, lI = "label", uI = "upperLabel", nQ = Lu * 10, iQ = Lu * 2, aQ = Lu * 3, ts = Vs([
    [
      "fill",
      "color"
    ],
    [
      "stroke",
      "strokeColor"
    ],
    [
      "lineWidth",
      "strokeWidth"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ]
  ]), cI = function(r) {
    var e = ts(r);
    return e.stroke = e.fill = e.lineWidth = null, e;
  }, fv = tt(), oQ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._state = "ready", t._storage = gc(), t;
    }
    return e.prototype.render = function(t, n, i, a) {
      var o = n.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(Be(o, t) < 0)) {
        this.seriesModel = t, this.api = i, this.ecModel = n;
        var s = [
          "treemapZoomToNode",
          "treemapRootToNode"
        ], l = Vh(a, s, t), u = a && a.type, c = t.layoutInfo, h = !this._oldTree, f = this._storage, d = u === "treemapRootToNode" && l && f ? {
          rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, p = this._giveContainerGroup(c), v = t.get("animation"), g = this._doRender(p, t, d);
        v && !h && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, g, t, d) : g.renderFinally(), this._resetController(i), this._renderBreadcrumb(t, i, l);
      }
    }, e.prototype._giveContainerGroup = function(t) {
      var n = this._containerGroup;
      return n || (n = this._containerGroup = new m_(), this._initEvents(n), this.group.add(n)), n.x = t.x, n.y = t.y, n;
    }, e.prototype._doRender = function(t, n, i) {
      var a = n.getData().tree, o = this._oldTree, s = gc(), l = gc(), u = this._storage, c = [];
      function h(y, x, _, S) {
        return sQ(n, l, u, i, s, c, y, x, _, S);
      }
      v(a.root ? [
        a.root
      ] : [], o && o.root ? [
        o.root
      ] : [], t, a === o || !o, 0);
      var f = g(u);
      if (this._oldTree = a, this._storage = l, this._controllerHost) {
        var d = this.seriesModel.layoutInfo, p = a.root.getLayout();
        p.width === d.width && p.height === d.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: s,
        willDeleteEls: f,
        renderFinally: m
      };
      function v(y, x, _, S, b) {
        S ? (x = y, D(y, function(T, A) {
          !T.isRemoved() && C(A, A);
        })) : new ya(x, y, w, w).add(C).update(C).remove(Le(C, null)).execute();
        function w(T) {
          return T.getId();
        }
        function C(T, A) {
          var M = T != null ? y[T] : null, E = A != null ? x[A] : null, k = h(M, E, _, b);
          k && v(M && M.viewChildren || [], E && E.viewChildren || [], k, S, b + 1);
        }
      }
      function g(y) {
        var x = gc();
        return y && D(y, function(_, S) {
          var b = x[S];
          D(_, function(w) {
            w && (b.push(w), fv(w).willDelete = true);
          });
        }), x;
      }
      function m() {
        D(f, function(y) {
          D(y, function(x) {
            x.parent && x.parent.remove(x);
          });
        }), D(c, function(y) {
          y.invisible = true, y.dirty();
        });
      }
    }, e.prototype._doAnimation = function(t, n, i, a) {
      var o = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (ge(o) ? 0 : o) || 0, u = (ge(s) ? null : s) || "cubicOut", c = rQ();
      D(n.willDeleteEls, function(h, f) {
        D(h, function(d, p) {
          if (!d.invisible) {
            var v = d.parent, g, m = fv(v);
            if (a && a.direction === "drillDown") g = v === a.rootNodeGroup ? {
              shape: {
                x: 0,
                y: 0,
                width: m.nodeWidth,
                height: m.nodeHeight
              },
              style: {
                opacity: 0
              }
            } : {
              style: {
                opacity: 0
              }
            };
            else {
              var y = 0, x = 0;
              m.willDelete || (y = m.nodeWidth / 2, x = m.nodeHeight / 2), g = f === "nodeGroup" ? {
                x: y,
                y: x,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: x,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            g && c.add(d, g, l, 0, u);
          }
        });
      }), D(this._storage, function(h, f) {
        D(h, function(d, p) {
          var v = n.lastsForAnimation[f][p], g = {};
          v && (d instanceof Ce ? v.oldX != null && (g.x = d.x, g.y = d.y, d.x = v.oldX, d.y = v.oldY) : (v.oldShape && (g.shape = H({}, d.shape), d.setShape(v.oldShape)), v.fadein ? (d.setStyle("opacity", 0), g.style = {
            opacity: 1
          }) : d.style.opacity !== 1 && (g.style = {
            opacity: 1
          })), c.add(d, g, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(ne(function() {
        this._state = "ready", n.renderFinally();
      }, this)).start();
    }, e.prototype._resetController = function(t) {
      var n = this._controller, i = this._controllerHost;
      i || (this._controllerHost = {
        target: this.group
      }, i = this._controllerHost), n || (n = this._controller = new Lf(t.getZr()), n.enable(this.seriesModel.get("roam")), i.zoomLimit = this.seriesModel.get("scaleLimit"), i.zoom = this.seriesModel.get("zoom"), n.on("pan", ne(this._onPan, this)), n.on("zoom", ne(this._onZoom, this)));
      var a = new Oe(0, 0, t.getWidth(), t.getHeight());
      n.setPointerChecker(function(o, s, l) {
        return a.contain(s, l);
      });
    }, e.prototype._clearController = function() {
      var t = this._controller;
      this._controllerHost = null, t && (t.dispose(), t = null);
    }, e.prototype._onPan = function(t) {
      if (this._state !== "animating" && (Math.abs(t.dx) > sI || Math.abs(t.dy) > sI)) {
        var n = this.seriesModel.getData().tree.root;
        if (!n) return;
        var i = n.getLayout();
        if (!i) return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + t.dx,
            y: i.y + t.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, e.prototype._onZoom = function(t) {
      var n = t.originX, i = t.originY, a = t.scale;
      if (this._state !== "animating") {
        var o = this.seriesModel.getData().tree.root;
        if (!o) return;
        var s = o.getLayout();
        if (!s) return;
        var l = new Oe(s.x, s.y, s.width, s.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var h = c.zoom = c.zoom || 1;
        if (h *= a, u) {
          var f = u.min || 0, d = u.max || 1 / 0;
          h = Math.max(Math.min(d, h), f);
        }
        var p = h / c.zoom;
        c.zoom = h;
        var v = this.seriesModel.layoutInfo;
        n -= v.x, i -= v.y;
        var g = pn();
        Bi(g, g, [
          -n,
          -i
        ]), Qb(g, g, [
          p,
          p
        ]), Bi(g, g, [
          n,
          i
        ]), l.applyTransform(g), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, e.prototype._initEvents = function(t) {
      var n = this;
      t.on("click", function(i) {
        if (n._state === "ready") {
          var a = n.seriesModel.get("nodeClick", true);
          if (a) {
            var o = n.findTarget(i.offsetX, i.offsetY);
            if (o) {
              var s = o.node;
              if (s.getLayout().isLeafRoot) n._rootToNode(o);
              else if (a === "zoomToNode") n._zoomToNode(o);
              else if (a === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", true), c = l.get("target", true) || "blank";
                u && Zp(u, c);
              }
            }
          }
        }
      }, this);
    }, e.prototype._renderBreadcrumb = function(t, n, i) {
      var a = this;
      i || (i = t.get("leafDepth", true) != null ? {
        node: t.getViewRoot()
      } : this.findTarget(n.getWidth() / 2, n.getHeight() / 2), i || (i = {
        node: t.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new Qj(this.group))).render(t, n, i.node, function(o) {
        a._state !== "animating" && (lS(t.getViewRoot(), o) ? a._rootToNode({
          node: o
        }) : a._zoomToNode({
          node: o
        }));
      });
    }, e.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = gc(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, e.prototype.dispose = function() {
      this._clearController();
    }, e.prototype._zoomToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype._rootToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype.findTarget = function(t, n) {
      var i, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(o) {
        var s = this._storage.background[o.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(t, n), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height) i = {
            node: o,
            offsetX: l[0],
            offsetY: l[1]
          };
          else return false;
        }
      }, this), i;
    }, e.type = "treemap", e;
  }(yt);
  function gc() {
    return {
      nodeGroup: [],
      background: [],
      content: []
    };
  }
  function sQ(r, e, t, n, i, a, o, s, l, u) {
    if (!o) return;
    var c = o.getLayout(), h = r.getData(), f = o.getModel();
    if (h.setItemGraphicEl(o.dataIndex, null), !c || !c.isInView) return;
    var d = c.width, p = c.height, v = c.borderWidth, g = c.invisible, m = o.getRawIndex(), y = s && s.getRawIndex(), x = o.viewChildren, _ = c.upperHeight, S = x && x.length, b = f.getModel("itemStyle"), w = f.getModel([
      "emphasis",
      "itemStyle"
    ]), C = f.getModel([
      "blur",
      "itemStyle"
    ]), T = f.getModel([
      "select",
      "itemStyle"
    ]), A = b.get("borderRadius") || 0, M = q("nodeGroup", m_);
    if (!M) return;
    if (l.add(M), M.x = c.x || 0, M.y = c.y || 0, M.markRedraw(), fv(M).nodeWidth = d, fv(M).nodeHeight = p, c.isAboveViewRoot) return M;
    var E = q("background", oI, u, iQ);
    E && F(M, E, S && c.upperLabelHeight);
    var k = f.getModel("emphasis"), R = k.get("focus"), N = k.get("blurScope"), I = k.get("disabled"), L = R === "ancestor" ? o.getAncestorsIndices() : R === "descendant" ? o.getDescendantIndices() : R;
    if (S) Ih(M) && ms(M, false), E && (ms(E, !I), h.setItemGraphicEl(o.dataIndex, E), Ox(E, L, N));
    else {
      var P = q("content", oI, u, aQ);
      P && B(M, P), E.disableMorphing = true, E && Ih(E) && ms(E, false), ms(M, !I), h.setItemGraphicEl(o.dataIndex, M);
      var O = f.getShallow("cursor");
      O && P.attr("cursor", O), Ox(M, L, N);
    }
    return M;
    function F(re, J, le) {
      var te = De(J);
      if (te.dataIndex = o.dataIndex, te.seriesIndex = r.seriesIndex, J.setShape({
        x: 0,
        y: 0,
        width: d,
        height: p,
        r: A
      }), g) V(J);
      else {
        J.invisible = false;
        var he = o.getVisual("style"), Xe = he.stroke, Fe = cI(b);
        Fe.fill = Xe;
        var fe = ts(w);
        fe.fill = w.get("borderColor");
        var Se = ts(C);
        Se.fill = C.get("borderColor");
        var Lt = ts(T);
        if (Lt.fill = T.get("borderColor"), le) {
          var z = d - 2 * v;
          U(J, Xe, he.opacity, {
            x: v,
            y: 0,
            width: z,
            height: _
          });
        } else J.removeTextContent();
        J.setStyle(Fe), J.ensureState("emphasis").style = fe, J.ensureState("blur").style = Se, J.ensureState("select").style = Lt, $s(J);
      }
      re.add(J);
    }
    function B(re, J) {
      var le = De(J);
      le.dataIndex = o.dataIndex, le.seriesIndex = r.seriesIndex;
      var te = Math.max(d - 2 * v, 0), he = Math.max(p - 2 * v, 0);
      if (J.culling = true, J.setShape({
        x: v,
        y: v,
        width: te,
        height: he,
        r: A
      }), g) V(J);
      else {
        J.invisible = false;
        var Xe = o.getVisual("style"), Fe = Xe.fill, fe = cI(b);
        fe.fill = Fe, fe.decal = Xe.decal;
        var Se = ts(w), Lt = ts(C), z = ts(T);
        U(J, Fe, Xe.opacity, null), J.setStyle(fe), J.ensureState("emphasis").style = Se, J.ensureState("blur").style = Lt, J.ensureState("select").style = z, $s(J);
      }
      re.add(J);
    }
    function V(re) {
      !re.invisible && a.push(re);
    }
    function U(re, J, le, te) {
      var he = f.getModel(te ? uI : lI), Xe = jt(f.get("name"), null), Fe = he.getShallow("show");
      Sr(re, lr(f, te ? uI : lI), {
        defaultText: Fe ? Xe : null,
        inheritColor: J,
        defaultOpacity: le,
        labelFetcher: r,
        labelDataIndex: o.dataIndex
      });
      var fe = re.getTextContent();
      if (fe) {
        var Se = fe.style, Lt = Kb(Se.padding || 0);
        te && (re.setTextConfig({
          layoutRect: te
        }), fe.disableLabelLayout = true), fe.beforeUpdate = function() {
          var $ = Math.max((te ? te.width : re.shape.width) - Lt[1] - Lt[3], 0), j = Math.max((te ? te.height : re.shape.height) - Lt[0] - Lt[2], 0);
          (Se.width !== $ || Se.height !== j) && fe.setStyle({
            width: $,
            height: j
          });
        }, Se.truncateMinChar = 2, Se.lineOverflow = "truncate", Y(Se, te, c);
        var z = fe.getState("emphasis");
        Y(z ? z.style : null, te, c);
      }
    }
    function Y(re, J, le) {
      var te = re ? re.text : null;
      if (!J && le.isLeafRoot && te != null) {
        var he = r.get("drillDownIcon", true);
        re.text = he ? he + " " + te : te;
      }
    }
    function q(re, J, le, te) {
      var he = y != null && t[re][y], Xe = i[re];
      return he ? (t[re][y] = null, me(Xe, he)) : g || (he = new J(), he instanceof zn && (he.z2 = lQ(le, te)), Me(Xe, he)), e[re][m] = he;
    }
    function me(re, J) {
      var le = re[m] = {};
      J instanceof m_ ? (le.oldX = J.x, le.oldY = J.y) : le.oldShape = H({}, J.shape);
    }
    function Me(re, J) {
      var le = re[m] = {}, te = o.parentNode, he = J instanceof Ce;
      if (te && (!n || n.direction === "drillDown")) {
        var Xe = 0, Fe = 0, fe = i.background[te.getRawIndex()];
        !n && fe && fe.oldShape && (Xe = fe.oldShape.width, Fe = fe.oldShape.height), he ? (le.oldX = 0, le.oldY = Fe) : le.oldShape = {
          x: Xe,
          y: Fe,
          width: 0,
          height: 0
        };
      }
      le.fadein = !he;
    }
  }
  function lQ(r, e) {
    return r * nQ + e;
  }
  var $h = D, uQ = _e, dv = -1, or = function() {
    function r(e) {
      var t = e.mappingMethod, n = e.type, i = this.option = be(e);
      this.type = n, this.mappingMethod = t, this._normalizeData = fQ[t];
      var a = r.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[t], t === "piecewise" ? (by(i), cQ(i)) : t === "category" ? i.categories ? hQ(i) : by(i, true) : (Yr(t !== "linear" || i.dataExtent), by(i));
    }
    return r.prototype.mapValueToVisual = function(e) {
      var t = this._normalizeData(e);
      return this._normalizedToVisual(t, e);
    }, r.prototype.getNormalizer = function() {
      return ne(this._normalizeData, this);
    }, r.listVisualTypes = function() {
      return je(r.visualHandlers);
    }, r.isValidType = function(e) {
      return r.visualHandlers.hasOwnProperty(e);
    }, r.eachVisual = function(e, t, n) {
      _e(e) ? D(e, t, n) : t.call(n, e);
    }, r.mapVisual = function(e, t, n) {
      var i, a = X(e) ? [] : _e(e) ? {} : (i = true, null);
      return r.eachVisual(e, function(o, s) {
        var l = t.call(n, o, s);
        i ? a = l : a[s] = l;
      }), a;
    }, r.retrieveVisuals = function(e) {
      var t = {}, n;
      return e && $h(r.visualHandlers, function(i, a) {
        e.hasOwnProperty(a) && (t[a] = e[a], n = true);
      }), n ? t : null;
    }, r.prepareVisualTypes = function(e) {
      if (X(e)) e = e.slice();
      else if (uQ(e)) {
        var t = [];
        $h(e, function(n, i) {
          t.push(i);
        }), e = t;
      } else return [];
      return e.sort(function(n, i) {
        return i === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), e;
    }, r.dependsOn = function(e, t) {
      return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t;
    }, r.findPieceIndex = function(e, t, n) {
      for (var i, a = 1 / 0, o = 0, s = t.length; o < s; o++) {
        var l = t[o].value;
        if (l != null) {
          if (l === e || ee(l) && l === e + "") return o;
          n && f(l, o);
        }
      }
      for (var o = 0, s = t.length; o < s; o++) {
        var u = t[o], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (Id(h[1], e, c[1])) return o;
          } else if (c[1] === 1 / 0) {
            if (Id(h[0], c[0], e)) return o;
          } else if (Id(h[0], c[0], e) && Id(h[1], e, c[1])) return o;
          n && f(c[0], o), n && f(c[1], o);
        }
      }
      if (n) return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : i;
      function f(d, p) {
        var v = Math.abs(d - e);
        v < a && (a = v, i = p);
      }
    }, r.visualHandlers = {
      color: {
        applyVisual: mc("color"),
        getColorMapper: function() {
          var e = this.option;
          return ne(e.mappingMethod === "category" ? function(t, n) {
            return !n && (t = this._normalizeData(t)), Bc.call(this, t);
          } : function(t, n, i) {
            var a = !!i;
            return !n && (t = this._normalizeData(t)), i = tm(t, e.parsedVisual, i), a ? i : la(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(e) {
            return la(tm(e, this.option.parsedVisual), "rgba");
          },
          category: Bc,
          piecewise: function(e, t) {
            var n = x_.call(this, t);
            return n == null && (n = la(tm(e, this.option.parsedVisual), "rgba")), n;
          },
          fixed: rs
        }
      },
      colorHue: Ad(function(e, t) {
        return Kc(e, t);
      }),
      colorSaturation: Ad(function(e, t) {
        return Kc(e, null, t);
      }),
      colorLightness: Ad(function(e, t) {
        return Kc(e, null, null, t);
      }),
      colorAlpha: Ad(function(e, t) {
        return Bp(e, t);
      }),
      decal: {
        applyVisual: mc("decal"),
        _normalizedToVisual: {
          linear: null,
          category: Bc,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: mc("opacity"),
        _normalizedToVisual: y_([
          0,
          1
        ])
      },
      liftZ: {
        applyVisual: mc("liftZ"),
        _normalizedToVisual: {
          linear: rs,
          category: rs,
          piecewise: rs,
          fixed: rs
        }
      },
      symbol: {
        applyVisual: function(e, t, n) {
          var i = this.mapValueToVisual(e);
          n("symbol", i);
        },
        _normalizedToVisual: {
          linear: hI,
          category: Bc,
          piecewise: function(e, t) {
            var n = x_.call(this, t);
            return n == null && (n = hI.call(this, e)), n;
          },
          fixed: rs
        }
      },
      symbolSize: {
        applyVisual: mc("symbolSize"),
        _normalizedToVisual: y_([
          0,
          1
        ])
      }
    }, r;
  }();
  function cQ(r) {
    var e = r.pieceList;
    r.hasSpecialVisual = false, D(e, function(t, n) {
      t.originIndex = n, t.visual != null && (r.hasSpecialVisual = true);
    });
  }
  function hQ(r) {
    var e = r.categories, t = r.categoryMap = {}, n = r.visual;
    if ($h(e, function(o, s) {
      t[o] = s;
    }), !X(n)) {
      var i = [];
      _e(n) ? $h(n, function(o, s) {
        var l = t[s];
        i[l ?? dv] = o;
      }) : i[dv] = n, n = DO(r, i);
    }
    for (var a = e.length - 1; a >= 0; a--) n[a] == null && (delete t[e[a]], e.pop());
  }
  function by(r, e) {
    var t = r.visual, n = [];
    _e(t) ? $h(t, function(a) {
      n.push(a);
    }) : t != null && n.push(t);
    var i = {
      color: 1,
      symbol: 1
    };
    !e && n.length === 1 && !i.hasOwnProperty(r.type) && (n[1] = n[0]), DO(r, n);
  }
  function Ad(r) {
    return {
      applyVisual: function(e, t, n) {
        var i = this.mapValueToVisual(e);
        n("color", r(t("color"), i));
      },
      _normalizedToVisual: y_([
        0,
        1
      ])
    };
  }
  function hI(r) {
    var e = this.option.visual;
    return e[Math.round(ht(r, [
      0,
      1
    ], [
      0,
      e.length - 1
    ], true))] || {};
  }
  function mc(r) {
    return function(e, t, n) {
      n(r, this.mapValueToVisual(e));
    };
  }
  function Bc(r) {
    var e = this.option.visual;
    return e[this.option.loop && r !== dv ? r % e.length : r];
  }
  function rs() {
    return this.option.visual[0];
  }
  function y_(r) {
    return {
      linear: function(e) {
        return ht(e, r, this.option.visual, true);
      },
      category: Bc,
      piecewise: function(e, t) {
        var n = x_.call(this, t);
        return n == null && (n = ht(e, r, this.option.visual, true)), n;
      },
      fixed: rs
    };
  }
  function x_(r) {
    var e = this.option, t = e.pieceList;
    if (e.hasSpecialVisual) {
      var n = or.findPieceIndex(r, t), i = t[n];
      if (i && i.visual) return i.visual[this.type];
    }
  }
  function DO(r, e) {
    return r.visual = e, r.type === "color" && (r.parsedVisual = K(e, function(t) {
      var n = vn(t);
      return n || [
        0,
        0,
        0,
        1
      ];
    })), e;
  }
  var fQ = {
    linear: function(r) {
      return ht(r, this.option.dataExtent, [
        0,
        1
      ], true);
    },
    piecewise: function(r) {
      var e = this.option.pieceList, t = or.findPieceIndex(r, e, true);
      if (t != null) return ht(t, [
        0,
        e.length - 1
      ], [
        0,
        1
      ], true);
    },
    category: function(r) {
      var e = this.option.categories ? this.option.categoryMap[r] : r;
      return e ?? dv;
    },
    fixed: Wt
  };
  function Id(r, e, t) {
    return r ? e <= t : e < t;
  }
  var dQ = "itemStyle", PO = tt();
  const pQ = {
    seriesType: "treemap",
    reset: function(r) {
      var e = r.getData().tree, t = e.root;
      t.isRemoved() || kO(t, {}, r.getViewRoot().getAncestors(), r);
    }
  };
  function kO(r, e, t, n) {
    var i = r.getModel(), a = r.getLayout(), o = r.hostTree.data;
    if (!(!a || a.invisible || !a.isInView)) {
      var s = i.getModel(dQ), l = vQ(s, e, n), u = o.ensureUniqueItemVisual(r.dataIndex, "style"), c = s.get("borderColor"), h = s.get("borderColorSaturation"), f;
      h != null && (f = fI(l), c = gQ(h, f)), u.stroke = c;
      var d = r.viewChildren;
      if (!d || !d.length) f = fI(l), u.fill = f;
      else {
        var p = mQ(r, i, a, s, l, d);
        D(d, function(v, g) {
          if (v.depth >= t.length || v === t[v.depth]) {
            var m = yQ(i, l, v, g, p, n);
            kO(v, m, t, n);
          }
        });
      }
    }
  }
  function vQ(r, e, t) {
    var n = H({}, e), i = t.designatedVisualItemStyle;
    return D([
      "color",
      "colorAlpha",
      "colorSaturation"
    ], function(a) {
      i[a] = e[a];
      var o = r.get(a);
      i[a] = null, o != null && (n[a] = o);
    }), n;
  }
  function fI(r) {
    var e = Sy(r, "color");
    if (e) {
      var t = Sy(r, "colorAlpha"), n = Sy(r, "colorSaturation");
      return n && (e = Kc(e, null, null, n)), t && (e = Bp(e, t)), e;
    }
  }
  function gQ(r, e) {
    return e != null ? Kc(e, null, null, r) : null;
  }
  function Sy(r, e) {
    var t = r[e];
    if (t != null && t !== "none") return t;
  }
  function mQ(r, e, t, n, i, a) {
    if (!(!a || !a.length)) {
      var o = wy(e, "color") || i.color != null && i.color !== "none" && (wy(e, "colorAlpha") || wy(e, "colorSaturation"));
      if (o) {
        var s = e.get("visualMin"), l = e.get("visualMax"), u = t.dataExtent.slice();
        s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
        var c = e.get("colorMappingBy"), h = {
          type: o.name,
          dataExtent: u,
          visual: o.range
        };
        h.type === "color" && (c === "index" || c === "id") ? (h.mappingMethod = "category", h.loop = true) : h.mappingMethod = "linear";
        var f = new or(h);
        return PO(f).drColorMappingBy = c, f;
      }
    }
  }
  function wy(r, e) {
    var t = r.get(e);
    return X(t) && t.length ? {
      name: e,
      range: t
    } : null;
  }
  function yQ(r, e, t, n, i, a) {
    var o = H({}, e);
    if (i) {
      var s = i.type, l = s === "color" && PO(i).drColorMappingBy, u = l === "index" ? n : l === "id" ? a.mapIdToIndex(t.getId()) : t.getValue(r.get("visualDimension"));
      o[s] = i.mapValueToVisual(u);
    }
    return o;
  }
  var Gh = Math.max, pv = Math.min, dI = vr, uS = D, LO = [
    "itemStyle",
    "borderWidth"
  ], xQ = [
    "itemStyle",
    "gapWidth"
  ], _Q = [
    "upperLabel",
    "show"
  ], bQ = [
    "upperLabel",
    "height"
  ];
  const SQ = {
    seriesType: "treemap",
    reset: function(r, e, t, n) {
      var i = t.getWidth(), a = t.getHeight(), o = r.option, s = er(r.getBoxLayoutParams(), {
        width: t.getWidth(),
        height: t.getHeight()
      }), l = o.size || [], u = Q(dI(s.width, l[0]), i), c = Q(dI(s.height, l[1]), a), h = n && n.type, f = [
        "treemapZoomToNode",
        "treemapRootToNode"
      ], d = Vh(n, f, r), p = h === "treemapRender" || h === "treemapMove" ? n.rootRect : null, v = r.getViewRoot(), g = AO(v);
      if (h !== "treemapMove") {
        var m = h === "treemapZoomToNode" ? MQ(r, d, v, u, c) : p ? [
          p.width,
          p.height
        ] : [
          u,
          c
        ], y = o.sort;
        y && y !== "asc" && y !== "desc" && (y = "desc");
        var x = {
          squareRatio: o.squareRatio,
          sort: y,
          leafDepth: o.leafDepth
        };
        v.hostTree.clearLayouts();
        var _ = {
          x: 0,
          y: 0,
          width: m[0],
          height: m[1],
          area: m[0] * m[1]
        };
        v.setLayout(_), RO(v, x, false, 0), _ = v.getLayout(), uS(g, function(b, w) {
          var C = (g[w + 1] || v).getValue();
          b.setLayout(H({
            dataExtent: [
              C,
              C
            ],
            borderWidth: 0,
            upperHeight: 0
          }, _));
        });
      }
      var S = r.getData().tree.root;
      S.setLayout(DQ(s, p, d), true), r.setLayoutInfo(s), EO(S, new Oe(-s.x, -s.y, i, a), g, v, 0);
    }
  };
  function RO(r, e, t, n) {
    var i, a;
    if (!r.isRemoved()) {
      var o = r.getLayout();
      i = o.width, a = o.height;
      var s = r.getModel(), l = s.get(LO), u = s.get(xQ) / 2, c = NO(s), h = Math.max(l, c), f = l - u, d = h - u;
      r.setLayout({
        borderWidth: l,
        upperHeight: h,
        upperLabelHeight: c
      }, true), i = Gh(i - 2 * f, 0), a = Gh(a - f - d, 0);
      var p = i * a, v = wQ(r, s, p, e, t, n);
      if (v.length) {
        var g = {
          x: f,
          y: d,
          width: i,
          height: a
        }, m = pv(i, a), y = 1 / 0, x = [];
        x.area = 0;
        for (var _ = 0, S = v.length; _ < S; ) {
          var b = v[_];
          x.push(b), x.area += b.getLayout().area;
          var w = IQ(x, m, e.squareRatio);
          w <= y ? (_++, y = w) : (x.area -= x.pop().getLayout().area, pI(x, m, g, u, false), m = pv(g.width, g.height), x.length = x.area = 0, y = 1 / 0);
        }
        if (x.length && pI(x, m, g, u, true), !t) {
          var C = s.get("childrenVisibleMin");
          C != null && p < C && (t = true);
        }
        for (var _ = 0, S = v.length; _ < S; _++) RO(v[_], e, t, n + 1);
      }
    }
  }
  function wQ(r, e, t, n, i, a) {
    var o = r.children || [], s = n.sort;
    s !== "asc" && s !== "desc" && (s = null);
    var l = n.leafDepth != null && n.leafDepth <= a;
    if (i && !l) return r.viewChildren = [];
    o = ct(o, function(d) {
      return !d.isRemoved();
    }), TQ(o, s);
    var u = AQ(e, o, s);
    if (u.sum === 0) return r.viewChildren = [];
    if (u.sum = CQ(e, t, u.sum, s, o), u.sum === 0) return r.viewChildren = [];
    for (var c = 0, h = o.length; c < h; c++) {
      var f = o[c].getValue() / u.sum * t;
      o[c].setLayout({
        area: f
      });
    }
    return l && (o.length && r.setLayout({
      isLeafRoot: true
    }, true), o.length = 0), r.viewChildren = o, r.setLayout({
      dataExtent: u.dataExtent
    }, true), o;
  }
  function CQ(r, e, t, n, i) {
    if (!n) return t;
    for (var a = r.get("visibleMin"), o = i.length, s = o, l = o - 1; l >= 0; l--) {
      var u = i[n === "asc" ? o - l - 1 : l].getValue();
      u / t * e < a && (s = l, t -= u);
    }
    return n === "asc" ? i.splice(0, o - s) : i.splice(s, o - s), t;
  }
  function TQ(r, e) {
    return e && r.sort(function(t, n) {
      var i = e === "asc" ? t.getValue() - n.getValue() : n.getValue() - t.getValue();
      return i === 0 ? e === "asc" ? t.dataIndex - n.dataIndex : n.dataIndex - t.dataIndex : i;
    }), r;
  }
  function AQ(r, e, t) {
    for (var n = 0, i = 0, a = e.length; i < a; i++) n += e[i].getValue();
    var o = r.get("visualDimension"), s;
    return !e || !e.length ? s = [
      NaN,
      NaN
    ] : o === "value" && t ? (s = [
      e[e.length - 1].getValue(),
      e[0].getValue()
    ], t === "asc" && s.reverse()) : (s = [
      1 / 0,
      -1 / 0
    ], uS(e, function(l) {
      var u = l.getValue(o);
      u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
    })), {
      sum: n,
      dataExtent: s
    };
  }
  function IQ(r, e, t) {
    for (var n = 0, i = 1 / 0, a = 0, o = void 0, s = r.length; a < s; a++) o = r[a].getLayout().area, o && (o < i && (i = o), o > n && (n = o));
    var l = r.area * r.area, u = e * e * t;
    return l ? Gh(u * n / l, l / (u * i)) : 1 / 0;
  }
  function pI(r, e, t, n, i) {
    var a = e === t.width ? 0 : 1, o = 1 - a, s = [
      "x",
      "y"
    ], l = [
      "width",
      "height"
    ], u = t[s[a]], c = e ? r.area / e : 0;
    (i || c > t[l[o]]) && (c = t[l[o]]);
    for (var h = 0, f = r.length; h < f; h++) {
      var d = r[h], p = {}, v = c ? d.getLayout().area / c : 0, g = p[l[o]] = Gh(c - 2 * n, 0), m = t[s[a]] + t[l[a]] - u, y = h === f - 1 || m < v ? m : v, x = p[l[a]] = Gh(y - 2 * n, 0);
      p[s[o]] = t[s[o]] + pv(n, g / 2), p[s[a]] = u + pv(n, x / 2), u += y, d.setLayout(p, true);
    }
    t[s[o]] += c, t[l[o]] -= c;
  }
  function MQ(r, e, t, n, i) {
    var a = (e || {}).node, o = [
      n,
      i
    ];
    if (!a || a === t) return o;
    for (var s, l = n * i, u = l * r.option.zoomToNodeRatio; s = a.parentNode; ) {
      for (var c = 0, h = s.children, f = 0, d = h.length; f < d; f++) c += h[f].getValue();
      var p = a.getValue();
      if (p === 0) return o;
      u *= c / p;
      var v = s.getModel(), g = v.get(LO), m = Math.max(g, NO(v));
      u += 4 * g * g + (3 * g + m) * Math.pow(u, 0.5), u > IC && (u = IC), a = s;
    }
    u < l && (u = l);
    var y = Math.pow(u / l, 0.5);
    return [
      n * y,
      i * y
    ];
  }
  function DQ(r, e, t) {
    if (e) return {
      x: e.x,
      y: e.y
    };
    var n = {
      x: 0,
      y: 0
    };
    if (!t) return n;
    var i = t.node, a = i.getLayout();
    if (!a) return n;
    for (var o = [
      a.width / 2,
      a.height / 2
    ], s = i; s; ) {
      var l = s.getLayout();
      o[0] += l.x, o[1] += l.y, s = s.parentNode;
    }
    return {
      x: r.width / 2 - o[0],
      y: r.height / 2 - o[1]
    };
  }
  function EO(r, e, t, n, i) {
    var a = r.getLayout(), o = t[i], s = o && o === r;
    if (!(o && !s || i === t.length && r !== n)) {
      r.setLayout({
        isInView: true,
        invisible: !s && !e.intersect(a),
        isAboveViewRoot: s
      }, true);
      var l = new Oe(e.x - a.x, e.y - a.y, e.width, e.height);
      uS(r.viewChildren || [], function(u) {
        EO(u, l, t, n, i + 1);
      });
    }
  }
  function NO(r) {
    return r.get(_Q) ? r.get(bQ) : 0;
  }
  function PQ(r) {
    r.registerSeriesModel(Kj), r.registerChartView(oQ), r.registerVisual(pQ), r.registerLayout(SQ), qj(r);
  }
  function kQ(r) {
    var e = r.findComponents({
      mainType: "legend"
    });
    !e || !e.length || r.eachSeriesByType("graph", function(t) {
      var n = t.getCategoriesData(), i = t.getGraph(), a = i.data, o = n.mapArray(n.getName);
      a.filterSelf(function(s) {
        var l = a.getItemModel(s), u = l.getShallow("category");
        if (u != null) {
          nt(u) && (u = o[u]);
          for (var c = 0; c < e.length; c++) if (!e[c].isSelected(u)) return false;
        }
        return true;
      });
    });
  }
  function LQ(r) {
    var e = {};
    r.eachSeriesByType("graph", function(t) {
      var n = t.getCategoriesData(), i = t.getData(), a = {};
      n.each(function(o) {
        var s = n.getName(o);
        a["ec-" + s] = o;
        var l = n.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
        u.fill || (u.fill = t.getColorFromPalette(s, e)), n.setItemVisual(o, "style", u);
        for (var c = [
          "symbol",
          "symbolSize",
          "symbolKeepAspect"
        ], h = 0; h < c.length; h++) {
          var f = l.getShallow(c[h], true);
          f != null && n.setItemVisual(o, c[h], f);
        }
      }), n.count() && i.each(function(o) {
        var s = i.getItemModel(o), l = s.getShallow("category");
        if (l != null) {
          ee(l) && (l = a["ec-" + l]);
          var u = n.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(o, "style");
          H(c, u);
          for (var h = [
            "symbol",
            "symbolSize",
            "symbolKeepAspect"
          ], f = 0; f < h.length; f++) i.setItemVisual(o, h[f], n.getItemVisual(l, h[f]));
        }
      });
    });
  }
  function Md(r) {
    return r instanceof Array || (r = [
      r,
      r
    ]), r;
  }
  function RQ(r) {
    r.eachSeriesByType("graph", function(e) {
      var t = e.getGraph(), n = e.getEdgeData(), i = Md(e.get("edgeSymbol")), a = Md(e.get("edgeSymbolSize"));
      n.setVisual("fromSymbol", i && i[0]), n.setVisual("toSymbol", i && i[1]), n.setVisual("fromSymbolSize", a && a[0]), n.setVisual("toSymbolSize", a && a[1]), n.setVisual("style", e.getModel("lineStyle").getLineStyle()), n.each(function(o) {
        var s = n.getItemModel(o), l = t.getEdgeByIndex(o), u = Md(s.getShallow("symbol", true)), c = Md(s.getShallow("symbolSize", true)), h = s.getModel("lineStyle").getLineStyle(), f = n.ensureUniqueItemVisual(o, "style");
        switch (H(f, h), f.stroke) {
          case "source": {
            var d = l.node1.getVisual("style");
            f.stroke = d && d.fill;
            break;
          }
          case "target": {
            var d = l.node2.getVisual("style");
            f.stroke = d && d.fill;
            break;
          }
        }
        u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
      });
    });
  }
  var __ = "-->", Ag = function(r) {
    return r.get("autoCurveness") || null;
  }, OO = function(r, e) {
    var t = Ag(r), n = 20, i = [];
    if (nt(t)) n = t;
    else if (X(t)) {
      r.__curvenessList = t;
      return;
    }
    e > n && (n = e);
    var a = n % 2 ? n + 2 : n + 3;
    i = [];
    for (var o = 0; o < a; o++) i.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
    r.__curvenessList = i;
  }, Wh = function(r, e, t) {
    var n = [
      r.id,
      r.dataIndex
    ].join("."), i = [
      e.id,
      e.dataIndex
    ].join(".");
    return [
      t.uid,
      n,
      i
    ].join(__);
  }, FO = function(r) {
    var e = r.split(__);
    return [
      e[0],
      e[2],
      e[1]
    ].join(__);
  }, EQ = function(r, e) {
    var t = Wh(r.node1, r.node2, e);
    return e.__edgeMap[t];
  }, NQ = function(r, e) {
    var t = b_(Wh(r.node1, r.node2, e), e), n = b_(Wh(r.node2, r.node1, e), e);
    return t + n;
  }, b_ = function(r, e) {
    var t = e.__edgeMap;
    return t[r] ? t[r].length : 0;
  };
  function OQ(r) {
    Ag(r) && (r.__curvenessList = [], r.__edgeMap = {}, OO(r));
  }
  function FQ(r, e, t, n) {
    if (Ag(t)) {
      var i = Wh(r, e, t), a = t.__edgeMap, o = a[FO(i)];
      a[i] && !o ? a[i].isForward = true : o && a[i] && (o.isForward = true, a[i].isForward = false), a[i] = a[i] || [], a[i].push(n);
    }
  }
  function cS(r, e, t, n) {
    var i = Ag(e), a = X(i);
    if (!i) return null;
    var o = EQ(r, e);
    if (!o) return null;
    for (var s = -1, l = 0; l < o.length; l++) if (o[l] === t) {
      s = l;
      break;
    }
    var u = NQ(r, e);
    OO(e, u), r.lineStyle = r.lineStyle || {};
    var c = Wh(r.node1, r.node2, e), h = e.__curvenessList, f = a || u % 2 ? 0 : 1;
    if (o.isForward) return h[f + s];
    var d = FO(c), p = b_(d, e), v = h[s + p + f];
    return n ? a ? i && i[0] === 0 ? (p + f) % 2 ? v : -v : ((p % 2 ? 0 : 1) + f) % 2 ? v : -v : (p + f) % 2 ? v : -v : h[s + p + f];
  }
  function BO(r) {
    var e = r.coordinateSystem;
    if (!(e && e.type !== "view")) {
      var t = r.getGraph();
      t.eachNode(function(n) {
        var i = n.getModel();
        n.setLayout([
          +i.get("x"),
          +i.get("y")
        ]);
      }), hS(t, r);
    }
  }
  function hS(r, e) {
    r.eachEdge(function(t, n) {
      var i = Li(t.getModel().get([
        "lineStyle",
        "curveness"
      ]), -cS(t, e, n, true), 0), a = oa(t.node1.getLayout()), o = oa(t.node2.getLayout()), s = [
        a,
        o
      ];
      +i && s.push([
        (a[0] + o[0]) / 2 - (a[1] - o[1]) * i,
        (a[1] + o[1]) / 2 - (o[0] - a[0]) * i
      ]), t.setLayout(s);
    });
  }
  function BQ(r, e) {
    r.eachSeriesByType("graph", function(t) {
      var n = t.get("layout"), i = t.coordinateSystem;
      if (i && i.type !== "view") {
        var a = t.getData(), o = [];
        D(i.dimensions, function(f) {
          o = o.concat(a.mapDimensionsAll(f));
        });
        for (var s = 0; s < a.count(); s++) {
          for (var l = [], u = false, c = 0; c < o.length; c++) {
            var h = a.get(o[c], s);
            isNaN(h) || (u = true), l.push(h);
          }
          u ? a.setItemLayout(s, i.dataToPoint(l)) : a.setItemLayout(s, [
            NaN,
            NaN
          ]);
        }
        hS(a.graph, t);
      } else (!n || n === "none") && BO(t);
    });
  }
  function zc(r) {
    var e = r.coordinateSystem;
    if (e.type !== "view") return 1;
    var t = r.option.nodeScaleRatio, n = e.scaleX, i = e.getZoom(), a = (i - 1) * t + 1;
    return a / n;
  }
  function Vc(r) {
    var e = r.getVisual("symbolSize");
    return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
  }
  var vI = Math.PI, Cy = [];
  function fS(r, e, t, n) {
    var i = r.coordinateSystem;
    if (!(i && i.type !== "view")) {
      var a = i.getBoundingRect(), o = r.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, c = Math.min(a.width, a.height) / 2, h = o.count();
      if (o.setLayout({
        cx: l,
        cy: u
      }), !!h) {
        if (t) {
          var f = i.pointToData(n), d = f[0], p = f[1], v = [
            d - l,
            p - u
          ];
          Du(v, v), up(v, v, c), t.setLayout([
            l + v[0],
            u + v[1]
          ], true);
          var g = r.get([
            "circular",
            "rotateLabel"
          ]);
          zO(t, g, l, u);
        }
        zQ[e](r, s, o, c, l, u, h), s.eachEdge(function(m, y) {
          var x = Li(m.getModel().get([
            "lineStyle",
            "curveness"
          ]), cS(m, r, y), 0), _ = oa(m.node1.getLayout()), S = oa(m.node2.getLayout()), b, w = (_[0] + S[0]) / 2, C = (_[1] + S[1]) / 2;
          +x && (x *= 3, b = [
            l * x + w * (1 - x),
            u * x + C * (1 - x)
          ]), m.setLayout([
            _,
            S,
            b
          ]);
        });
      }
    }
  }
  var zQ = {
    value: function(r, e, t, n, i, a, o) {
      var s = 0, l = t.getSum("value"), u = Math.PI * 2 / (l || o);
      e.eachNode(function(c) {
        var h = c.getValue("value"), f = u * (l ? h : 1) / 2;
        s += f, c.setLayout([
          n * Math.cos(s) + i,
          n * Math.sin(s) + a
        ]), s += f;
      });
    },
    symbolSize: function(r, e, t, n, i, a, o) {
      var s = 0;
      Cy.length = o;
      var l = zc(r);
      e.eachNode(function(h) {
        var f = Vc(h);
        isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
        var d = Math.asin(f / 2 / n);
        isNaN(d) && (d = vI / 2), Cy[h.dataIndex] = d, s += d * 2;
      });
      var u = (2 * vI - s) / o / 2, c = 0;
      e.eachNode(function(h) {
        var f = u + Cy[h.dataIndex];
        c += f, (!h.getLayout() || !h.getLayout().fixed) && h.setLayout([
          n * Math.cos(c) + i,
          n * Math.sin(c) + a
        ]), c += f;
      });
    }
  };
  function zO(r, e, t, n) {
    var i = r.getGraphicEl();
    if (i) {
      var a = r.getModel(), o = a.get([
        "label",
        "rotate"
      ]) || 0, s = i.getSymbolPath();
      if (e) {
        var l = r.getLayout(), u = Math.atan2(l[1] - n, l[0] - t);
        u < 0 && (u = Math.PI * 2 + u);
        var c = l[0] < t;
        c && (u = u - Math.PI);
        var h = c ? "left" : "right";
        s.setTextConfig({
          rotation: -u,
          position: h,
          origin: "center"
        });
        var f = s.ensureState("emphasis");
        H(f.textConfig || (f.textConfig = {}), {
          position: h
        });
      } else s.setTextConfig({
        rotation: o *= Math.PI / 180
      });
    }
  }
  function VQ(r) {
    r.eachSeriesByType("graph", function(e) {
      e.get("layout") === "circular" && fS(e, "symbolSize");
    });
  }
  var Sl = ox;
  function $Q(r, e, t) {
    for (var n = r, i = e, a = t.rect, o = a.width, s = a.height, l = [
      a.x + o / 2,
      a.y + s / 2
    ], u = t.gravity == null ? 0.1 : t.gravity, c = 0; c < n.length; c++) {
      var h = n[c];
      h.p || (h.p = Xs(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), h.pp = oa(h.p), h.edges = null;
    }
    var f = t.friction == null ? 0.6 : t.friction, d = f, p, v;
    return {
      warmUp: function() {
        d = f * 0.8;
      },
      setFixed: function(g) {
        n[g].fixed = true;
      },
      setUnfixed: function(g) {
        n[g].fixed = false;
      },
      beforeStep: function(g) {
        p = g;
      },
      afterStep: function(g) {
        v = g;
      },
      step: function(g) {
        p && p(n, i);
        for (var m = [], y = n.length, x = 0; x < i.length; x++) {
          var _ = i[x];
          if (!_.ignoreForceLayout) {
            var S = _.n1, b = _.n2;
            vs(m, b.p, S.p);
            var w = sx(m) - _.d, C = b.w / (S.w + b.w);
            isNaN(C) && (C = 0), Du(m, m), !S.fixed && Sl(S.p, S.p, m, C * w * d), !b.fixed && Sl(b.p, b.p, m, -(1 - C) * w * d);
          }
        }
        for (var x = 0; x < y; x++) {
          var T = n[x];
          T.fixed || (vs(m, l, T.p), Sl(T.p, T.p, m, u * d));
        }
        for (var x = 0; x < y; x++) for (var S = n[x], A = x + 1; A < y; A++) {
          var b = n[A];
          vs(m, b.p, S.p);
          var w = sx(m);
          w === 0 && (fU(m, Math.random() - 0.5, Math.random() - 0.5), w = 1);
          var M = (S.rep + b.rep) / w / w;
          !S.fixed && Sl(S.pp, S.pp, m, M), !b.fixed && Sl(b.pp, b.pp, m, -M);
        }
        for (var E = [], x = 0; x < y; x++) {
          var T = n[x];
          T.fixed || (vs(E, T.p, T.pp), Sl(T.p, T.p, E, d), Fr(T.pp, T.p));
        }
        d = d * 0.992;
        var k = d < 0.01;
        v && v(n, i, k), g && g(k);
      }
    };
  }
  function GQ(r) {
    r.eachSeriesByType("graph", function(e) {
      var t = e.coordinateSystem;
      if (!(t && t.type !== "view")) if (e.get("layout") === "force") {
        var n = e.preservedPoints || {}, i = e.getGraph(), a = i.data, o = i.edgeData, s = e.getModel("force"), l = s.get("initLayout");
        e.preservedPoints ? a.each(function(x) {
          var _ = a.getId(x);
          a.setItemLayout(x, n[_] || [
            NaN,
            NaN
          ]);
        }) : !l || l === "none" ? BO(e) : l === "circular" && fS(e, "value");
        var u = a.getDataExtent("value"), c = o.getDataExtent("value"), h = s.get("repulsion"), f = s.get("edgeLength"), d = X(h) ? h : [
          h,
          h
        ], p = X(f) ? f : [
          f,
          f
        ];
        p = [
          p[1],
          p[0]
        ];
        var v = a.mapArray("value", function(x, _) {
          var S = a.getItemLayout(_), b = ht(x, u, d);
          return isNaN(b) && (b = (d[0] + d[1]) / 2), {
            w: b,
            rep: b,
            fixed: a.getItemModel(_).get("fixed"),
            p: !S || isNaN(S[0]) || isNaN(S[1]) ? null : S
          };
        }), g = o.mapArray("value", function(x, _) {
          var S = i.getEdgeByIndex(_), b = ht(x, c, p);
          isNaN(b) && (b = (p[0] + p[1]) / 2);
          var w = S.getModel(), C = Li(S.getModel().get([
            "lineStyle",
            "curveness"
          ]), -cS(S, e, _, true), 0);
          return {
            n1: v[S.node1.dataIndex],
            n2: v[S.node2.dataIndex],
            d: b,
            curveness: C,
            ignoreForceLayout: w.get("ignoreForceLayout")
          };
        }), m = t.getBoundingRect(), y = $Q(v, g, {
          rect: m,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(x, _) {
          for (var S = 0, b = x.length; S < b; S++) x[S].fixed && Fr(x[S].p, i.getNodeByIndex(S).getLayout());
        }), y.afterStep(function(x, _, S) {
          for (var b = 0, w = x.length; b < w; b++) x[b].fixed || i.getNodeByIndex(b).setLayout(x[b].p), n[a.getId(b)] = x[b].p;
          for (var b = 0, w = _.length; b < w; b++) {
            var C = _[b], T = i.getEdgeByIndex(b), A = C.n1.p, M = C.n2.p, E = T.getLayout();
            E = E ? E.slice() : [], E[0] = E[0] || [], E[1] = E[1] || [], Fr(E[0], A), Fr(E[1], M), +C.curveness && (E[2] = [
              (A[0] + M[0]) / 2 - (A[1] - M[1]) * C.curveness,
              (A[1] + M[1]) / 2 - (M[0] - A[0]) * C.curveness
            ]), T.setLayout(E);
          }
        }), e.forceLayout = y, e.preservedPoints = n, y.step();
      } else e.forceLayout = null;
    });
  }
  function WQ(r, e, t) {
    var n = H(r.getBoxLayoutParams(), {
      aspect: t
    });
    return er(n, {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function UQ(r, e) {
    var t = [];
    return r.eachSeriesByType("graph", function(n) {
      var i = n.get("coordinateSystem");
      if (!i || i === "view") {
        var a = n.getData(), o = a.mapArray(function(g) {
          var m = a.getItemModel(g);
          return [
            +m.get("x"),
            +m.get("y")
          ];
        }), s = [], l = [];
        Jv(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
        var u = (l[0] - s[0]) / (l[1] - s[1]), c = WQ(n, e, u);
        isNaN(u) && (s = [
          c.x,
          c.y
        ], l = [
          c.x + c.width,
          c.y + c.height
        ]);
        var h = l[0] - s[0], f = l[1] - s[1], d = c.width, p = c.height, v = n.coordinateSystem = new Rf();
        v.zoomLimit = n.get("scaleLimit"), v.setBoundingRect(s[0], s[1], h, f), v.setViewRect(c.x, c.y, d, p), v.setCenter(n.get("center"), e), v.setZoom(n.get("zoom")), t.push(v);
      }
    }), t;
  }
  var gI = ir.prototype, Ty = yf.prototype, VO = /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return r;
  }();
  (function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  })(VO);
  function Ay(r) {
    return isNaN(+r.cpx1) || isNaN(+r.cpy1);
  }
  var HQ = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "ec-line", n;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new VO();
    }, e.prototype.buildPath = function(t, n) {
      Ay(n) ? gI.buildPath.call(this, t, n) : Ty.buildPath.call(this, t, n);
    }, e.prototype.pointAt = function(t) {
      return Ay(this.shape) ? gI.pointAt.call(this, t) : Ty.pointAt.call(this, t);
    }, e.prototype.tangentAt = function(t) {
      var n = this.shape, i = Ay(n) ? [
        n.x2 - n.x1,
        n.y2 - n.y1
      ] : Ty.tangentAt.call(this, t);
      return Du(i, i);
    }, e;
  }(Ue), Iy = [
    "fromSymbol",
    "toSymbol"
  ];
  function mI(r) {
    return "_" + r + "Type";
  }
  function yI(r, e, t) {
    var n = e.getItemVisual(t, r);
    if (!n || n === "none") return n;
    var i = e.getItemVisual(t, r + "Size"), a = e.getItemVisual(t, r + "Rotate"), o = e.getItemVisual(t, r + "Offset"), s = e.getItemVisual(t, r + "KeepAspect"), l = $u(i), u = js(o || 0, l);
    return n + l + u + (a || "") + (s || "");
  }
  function xI(r, e, t) {
    var n = e.getItemVisual(t, r);
    if (!(!n || n === "none")) {
      var i = e.getItemVisual(t, r + "Size"), a = e.getItemVisual(t, r + "Rotate"), o = e.getItemVisual(t, r + "Offset"), s = e.getItemVisual(t, r + "KeepAspect"), l = $u(i), u = js(o || 0, l), c = Xt(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
      return c.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, c.name = r, c;
    }
  }
  function YQ(r) {
    var e = new HQ({
      name: "line",
      subPixelOptimize: true
    });
    return S_(e.shape, r), e;
  }
  function S_(r, e) {
    r.x1 = e[0][0], r.y1 = e[0][1], r.x2 = e[1][0], r.y2 = e[1][1], r.percent = 1;
    var t = e[2];
    t ? (r.cpx1 = t[0], r.cpy1 = t[1]) : (r.cpx1 = NaN, r.cpy1 = NaN);
  }
  var dS = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      return a._createLine(t, n, i), a;
    }
    return e.prototype._createLine = function(t, n, i) {
      var a = t.hostModel, o = t.getItemLayout(n), s = YQ(o);
      s.shape.percent = 0, kt(s, {
        shape: {
          percent: 1
        }
      }, a, n), this.add(s), D(Iy, function(l) {
        var u = xI(l, t, n);
        this.add(u), this[mI(l)] = yI(l, t, n);
      }, this), this._updateCommonStl(t, n, i);
    }, e.prototype.updateData = function(t, n, i) {
      var a = t.hostModel, o = this.childOfName("line"), s = t.getItemLayout(n), l = {
        shape: {}
      };
      S_(l.shape, s), it(o, l, a, n), D(Iy, function(u) {
        var c = yI(u, t, n), h = mI(u);
        if (this[h] !== c) {
          this.remove(this.childOfName(u));
          var f = xI(u, t, n);
          this.add(f);
        }
        this[h] = c;
      }, this), this._updateCommonStl(t, n, i);
    }, e.prototype.getLinePath = function() {
      return this.childAt(0);
    }, e.prototype._updateCommonStl = function(t, n, i) {
      var a = t.hostModel, o = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, h = i && i.emphasisDisabled, f = i && i.focus, d = i && i.blurScope;
      if (!i || t.hasItemOption) {
        var p = t.getItemModel(n), v = p.getModel("emphasis");
        s = v.getModel("lineStyle").getLineStyle(), l = p.getModel([
          "blur",
          "lineStyle"
        ]).getLineStyle(), u = p.getModel([
          "select",
          "lineStyle"
        ]).getLineStyle(), h = v.get("disabled"), f = v.get("focus"), d = v.get("blurScope"), c = lr(p);
      }
      var g = t.getItemVisual(n, "style"), m = g.stroke;
      o.useStyle(g), o.style.fill = null, o.style.strokeNoScale = true, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, D(Iy, function(b) {
        var w = this.childOfName(b);
        if (w) {
          w.setColor(m), w.style.opacity = g.opacity;
          for (var C = 0; C < Xr.length; C++) {
            var T = Xr[C], A = o.getState(T);
            if (A) {
              var M = A.style || {}, E = w.ensureState(T), k = E.style || (E.style = {});
              M.stroke != null && (k[w.__isEmptyBrush ? "stroke" : "fill"] = M.stroke), M.opacity != null && (k.opacity = M.opacity);
            }
          }
          w.markRedraw();
        }
      }, this);
      var y = a.getRawValue(n);
      Sr(this, c, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function(b, w) {
            return a.getFormattedLabel(b, w, t.dataType);
          }
        },
        inheritColor: m || "#000",
        defaultOpacity: g.opacity,
        defaultText: (y == null ? t.getName(n) : isFinite(y) ? Bt(y) : y) + ""
      });
      var x = this.getTextContent();
      if (x) {
        var _ = c.normal;
        x.__align = x.style.align, x.__verticalAlign = x.style.verticalAlign, x.__position = _.get("position") || "middle";
        var S = _.get("distance");
        X(S) || (S = [
          S,
          S
        ]), x.__labelDistance = S;
      }
      this.setTextConfig({
        position: null,
        local: true,
        inside: false
      }), Nt(this, f, d, h);
    }, e.prototype.highlight = function() {
      ga(this);
    }, e.prototype.downplay = function() {
      ma(this);
    }, e.prototype.updateLayout = function(t, n) {
      this.setLinePoints(t.getItemLayout(n));
    }, e.prototype.setLinePoints = function(t) {
      var n = this.childOfName("line");
      S_(n.shape, t), n.dirty();
    }, e.prototype.beforeUpdate = function() {
      var t = this, n = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), a = t.getTextContent();
      if (!n && !i && (!a || a.ignore)) return;
      for (var o = 1, s = this.parent; s; ) s.scaleX && (o /= s.scaleX), s = s.parent;
      var l = t.childOfName("line");
      if (!this.__dirty && !l.__dirty) return;
      var u = l.shape.percent, c = l.pointAt(0), h = l.pointAt(u), f = vs([], h, c);
      Du(f, f);
      function d(A, M) {
        var E = A.__specifiedRotation;
        if (E == null) {
          var k = l.tangentAt(M);
          A.attr("rotation", (M === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(k[1], k[0]));
        } else A.attr("rotation", E);
      }
      if (n && (n.setPosition(c), d(n, 0), n.scaleX = n.scaleY = o * u, n.markRedraw()), i && (i.setPosition(h), d(i, 1), i.scaleX = i.scaleY = o * u, i.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var p = void 0, v = void 0, g = a.__labelDistance, m = g[0] * o, y = g[1] * o, x = u / 2, _ = l.tangentAt(x), S = [
          _[1],
          -_[0]
        ], b = l.pointAt(x);
        S[1] > 0 && (S[0] = -S[0], S[1] = -S[1]);
        var w = _[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var C = -Math.atan2(_[1], _[0]);
          h[0] < c[0] && (C = Math.PI + C), a.rotation = C;
        }
        var T = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            T = -y, v = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            T = y, v = "top";
            break;
          default:
            T = 0, v = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = f[0] * m + h[0], a.y = f[1] * y + h[1], p = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", v = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -f[0] * m + c[0], a.y = -f[1] * y + c[1], p = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", v = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = m * w + c[0], a.y = c[1] + T, p = _[0] < 0 ? "right" : "left", a.originX = -m * w, a.originY = -T;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = b[0], a.y = b[1] + T, p = "center", a.originY = -T;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -m * w + h[0], a.y = h[1] + T, p = _[0] >= 0 ? "right" : "left", a.originX = m * w, a.originY = -T;
            break;
        }
        a.scaleX = a.scaleY = o, a.setStyle({
          verticalAlign: a.__verticalAlign || v,
          align: a.__align || p
        });
      }
    }, e;
  }(Ce), pS = function() {
    function r(e) {
      this.group = new Ce(), this._LineCtor = e || dS;
    }
    return r.prototype.updateData = function(e) {
      var t = this;
      this._progressiveEls = null;
      var n = this, i = n.group, a = n._lineData;
      n._lineData = e, a || i.removeAll();
      var o = _I(e);
      e.diff(a).add(function(s) {
        t._doAdd(e, s, o);
      }).update(function(s, l) {
        t._doUpdate(a, e, l, s, o);
      }).remove(function(s) {
        i.remove(a.getItemGraphicEl(s));
      }).execute();
    }, r.prototype.updateLayout = function() {
      var e = this._lineData;
      e && e.eachItemGraphicEl(function(t, n) {
        t.updateLayout(e, n);
      }, this);
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = _I(e), this._lineData = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(e, t) {
      this._progressiveEls = [];
      function n(s) {
        !s.isGroup && !XQ(s) && (s.incremental = true, s.ensureState("emphasis").hoverLayer = true);
      }
      for (var i = e.start; i < e.end; i++) {
        var a = t.getItemLayout(i);
        if (My(a)) {
          var o = new this._LineCtor(t, i, this._seriesScope);
          o.traverse(n), this.group.add(o), t.setItemGraphicEl(i, o), this._progressiveEls.push(o);
        }
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r.prototype.eachRendered = function(e) {
      mo(this._progressiveEls || this.group, e);
    }, r.prototype._doAdd = function(e, t, n) {
      var i = e.getItemLayout(t);
      if (My(i)) {
        var a = new this._LineCtor(e, t, n);
        e.setItemGraphicEl(t, a), this.group.add(a);
      }
    }, r.prototype._doUpdate = function(e, t, n, i, a) {
      var o = e.getItemGraphicEl(n);
      if (!My(t.getItemLayout(i))) {
        this.group.remove(o);
        return;
      }
      o ? o.updateData(t, i, a) : o = new this._LineCtor(t, i, a), t.setItemGraphicEl(i, o), this.group.add(o);
    }, r;
  }();
  function XQ(r) {
    return r.animators && r.animators.length > 0;
  }
  function _I(r) {
    var e = r.hostModel, t = e.getModel("emphasis");
    return {
      lineStyle: e.getModel("lineStyle").getLineStyle(),
      emphasisLineStyle: t.getModel([
        "lineStyle"
      ]).getLineStyle(),
      blurLineStyle: e.getModel([
        "blur",
        "lineStyle"
      ]).getLineStyle(),
      selectLineStyle: e.getModel([
        "select",
        "lineStyle"
      ]).getLineStyle(),
      emphasisDisabled: t.get("disabled"),
      blurScope: t.get("blurScope"),
      focus: t.get("focus"),
      labelStatesModels: lr(e)
    };
  }
  function bI(r) {
    return isNaN(r[0]) || isNaN(r[1]);
  }
  function My(r) {
    return r && !bI(r[0]) && !bI(r[1]);
  }
  var Dy = [], Py = [], ky = [], wl = dr, Ly = As, SI = Math.abs;
  function wI(r, e, t) {
    for (var n = r[0], i = r[1], a = r[2], o = 1 / 0, s, l = t * t, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
      Dy[0] = wl(n[0], i[0], a[0], c), Dy[1] = wl(n[1], i[1], a[1], c);
      var h = SI(Ly(Dy, e) - l);
      h < o && (o = h, s = c);
    }
    for (var f = 0; f < 32; f++) {
      var d = s + u;
      Py[0] = wl(n[0], i[0], a[0], s), Py[1] = wl(n[1], i[1], a[1], s), ky[0] = wl(n[0], i[0], a[0], d), ky[1] = wl(n[1], i[1], a[1], d);
      var h = Ly(Py, e) - l;
      if (SI(h) < 0.01) break;
      var p = Ly(ky, e) - l;
      u /= 2, h < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
    }
    return s;
  }
  function Ry(r, e) {
    var t = [], n = bh, i = [
      [],
      [],
      []
    ], a = [
      [],
      []
    ], o = [];
    e /= 2, r.eachEdge(function(s, l) {
      var u = s.getLayout(), c = s.getVisual("fromSymbol"), h = s.getVisual("toSymbol");
      u.__original || (u.__original = [
        oa(u[0]),
        oa(u[1])
      ], u[2] && u.__original.push(oa(u[2])));
      var f = u.__original;
      if (u[2] != null) {
        if (Fr(i[0], f[0]), Fr(i[1], f[2]), Fr(i[2], f[1]), c && c !== "none") {
          var d = Vc(s.node1), p = wI(i, f[0], d * e);
          n(i[0][0], i[1][0], i[2][0], p, t), i[0][0] = t[3], i[1][0] = t[4], n(i[0][1], i[1][1], i[2][1], p, t), i[0][1] = t[3], i[1][1] = t[4];
        }
        if (h && h !== "none") {
          var d = Vc(s.node2), p = wI(i, f[1], d * e);
          n(i[0][0], i[1][0], i[2][0], p, t), i[1][0] = t[1], i[2][0] = t[2], n(i[0][1], i[1][1], i[2][1], p, t), i[1][1] = t[1], i[2][1] = t[2];
        }
        Fr(u[0], i[0]), Fr(u[1], i[2]), Fr(u[2], i[1]);
      } else {
        if (Fr(a[0], f[0]), Fr(a[1], f[1]), vs(o, a[1], a[0]), Du(o, o), c && c !== "none") {
          var d = Vc(s.node1);
          ox(a[0], a[0], o, d * e);
        }
        if (h && h !== "none") {
          var d = Vc(s.node2);
          ox(a[1], a[1], o, -d * e);
        }
        Fr(u[0], a[0]), Fr(u[1], a[1]);
      }
    });
  }
  function CI(r) {
    return r.type === "view";
  }
  var qQ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n) {
      var i = new If(), a = new pS(), o = this.group;
      this._controller = new Lf(n.getZr()), this._controllerHost = {
        target: o
      }, o.add(i.group), o.add(a.group), this._symbolDraw = i, this._lineDraw = a, this._firstRender = true;
    }, e.prototype.render = function(t, n, i) {
      var a = this, o = t.coordinateSystem;
      this._model = t;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (CI(o)) {
        var c = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY
        };
        this._firstRender ? u.attr(c) : it(u, c, t);
      }
      Ry(t.getGraph(), zc(t));
      var h = t.getData();
      s.updateData(h);
      var f = t.getEdgeData();
      l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(t, n, i), clearTimeout(this._layoutTimeout);
      var d = t.forceLayout, p = t.get([
        "force",
        "layoutAnimation"
      ]);
      d && this._startForceLayoutIteration(d, p);
      var v = t.get("layout");
      h.graph.eachNode(function(x) {
        var _ = x.dataIndex, S = x.getGraphicEl(), b = x.getModel();
        if (S) {
          S.off("drag").off("dragend");
          var w = b.get("draggable");
          w && S.on("drag", function(T) {
            switch (v) {
              case "force":
                d.warmUp(), !a._layouting && a._startForceLayoutIteration(d, p), d.setFixed(_), h.setItemLayout(_, [
                  S.x,
                  S.y
                ]);
                break;
              case "circular":
                h.setItemLayout(_, [
                  S.x,
                  S.y
                ]), x.setLayout({
                  fixed: true
                }, true), fS(t, "symbolSize", x, [
                  T.offsetX,
                  T.offsetY
                ]), a.updateLayout(t);
                break;
              case "none":
              default:
                h.setItemLayout(_, [
                  S.x,
                  S.y
                ]), hS(t.getGraph(), t), a.updateLayout(t);
                break;
            }
          }).on("dragend", function() {
            d && d.setUnfixed(_);
          }), S.setDraggable(w, !!b.get("cursor"));
          var C = b.get([
            "emphasis",
            "focus"
          ]);
          C === "adjacency" && (De(S).focus = x.getAdjacentDataIndices());
        }
      }), h.graph.eachEdge(function(x) {
        var _ = x.getGraphicEl(), S = x.getModel().get([
          "emphasis",
          "focus"
        ]);
        _ && S === "adjacency" && (De(_).focus = {
          edge: [
            x.dataIndex
          ],
          node: [
            x.node1.dataIndex,
            x.node2.dataIndex
          ]
        });
      });
      var g = t.get("layout") === "circular" && t.get([
        "circular",
        "rotateLabel"
      ]), m = h.getLayout("cx"), y = h.getLayout("cy");
      h.graph.eachNode(function(x) {
        zO(x, g, m, y);
      }), this._firstRender = false;
    }, e.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype._startForceLayoutIteration = function(t, n) {
      var i = this;
      (function a() {
        t.step(function(o) {
          i.updateLayout(i._model), (i._layouting = !o) && (n ? i._layoutTimeout = setTimeout(a, 16) : a());
        });
      })();
    }, e.prototype._updateController = function(t, n, i) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      if (o.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !wg(u, i, t);
      }), !CI(t.coordinateSystem)) {
        o.disable();
        return;
      }
      o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        rS(s, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        nS(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(), Ry(t.getGraph(), zc(t)), a._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function() {
      var t = this._model, n = t.getData(), i = zc(t);
      n.eachItemGraphicEl(function(a, o) {
        a && a.setSymbolScale(i);
      });
    }, e.prototype.updateLayout = function(t) {
      Ry(t.getGraph(), zc(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, e.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = false, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, e.type = "graph", e;
  }(yt);
  function Cl(r) {
    return "_EC_" + r;
  }
  var KQ = function() {
    function r(e) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || false;
    }
    return r.prototype.isDirected = function() {
      return this._directed;
    }, r.prototype.addNode = function(e, t) {
      e = e == null ? "" + t : "" + e;
      var n = this._nodesMap;
      if (!n[Cl(e)]) {
        var i = new ns(e, t);
        return i.hostGraph = this, this.nodes.push(i), n[Cl(e)] = i, i;
      }
    }, r.prototype.getNodeByIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this.nodes[t];
    }, r.prototype.getNodeById = function(e) {
      return this._nodesMap[Cl(e)];
    }, r.prototype.addEdge = function(e, t, n) {
      var i = this._nodesMap, a = this._edgesMap;
      if (nt(e) && (e = this.nodes[e]), nt(t) && (t = this.nodes[t]), e instanceof ns || (e = i[Cl(e)]), t instanceof ns || (t = i[Cl(t)]), !(!e || !t)) {
        var o = e.id + "-" + t.id, s = new $O(e, t, n);
        return s.hostGraph = this, this._directed && (e.outEdges.push(s), t.inEdges.push(s)), e.edges.push(s), e !== t && t.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, r.prototype.getEdgeByIndex = function(e) {
      var t = this.edgeData.getRawIndex(e);
      return this.edges[t];
    }, r.prototype.getEdge = function(e, t) {
      e instanceof ns && (e = e.id), t instanceof ns && (t = t.id);
      var n = this._edgesMap;
      return this._directed ? n[e + "-" + t] : n[e + "-" + t] || n[t + "-" + e];
    }, r.prototype.eachNode = function(e, t) {
      for (var n = this.nodes, i = n.length, a = 0; a < i; a++) n[a].dataIndex >= 0 && e.call(t, n[a], a);
    }, r.prototype.eachEdge = function(e, t) {
      for (var n = this.edges, i = n.length, a = 0; a < i; a++) n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && e.call(t, n[a], a);
    }, r.prototype.breadthFirstTraverse = function(e, t, n, i) {
      if (t instanceof ns || (t = this._nodesMap[Cl(t)]), !!t) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++) this.nodes[o].__visited = false;
        if (!e.call(i, t, null)) for (var s = [
          t
        ]; s.length; ) for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
          var c = u[o], h = c.node1 === l ? c.node2 : c.node1;
          if (!h.__visited) {
            if (e.call(i, h, l)) return;
            s.push(h), h.__visited = true;
          }
        }
      }
    }, r.prototype.update = function() {
      for (var e = this.data, t = this.edgeData, n = this.nodes, i = this.edges, a = 0, o = n.length; a < o; a++) n[a].dataIndex = -1;
      for (var a = 0, o = e.count(); a < o; a++) n[e.getRawIndex(a)].dataIndex = a;
      t.filterSelf(function(s) {
        var l = i[t.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = i.length; a < o; a++) i[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++) i[t.getRawIndex(a)].dataIndex = a;
    }, r.prototype.clone = function() {
      for (var e = new r(this._directed), t = this.nodes, n = this.edges, i = 0; i < t.length; i++) e.addNode(t[i].id, t[i].dataIndex);
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        e.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return e;
    }, r;
  }(), ns = function() {
    function r(e, t) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = t ?? -1;
    }
    return r.prototype.degree = function() {
      return this.edges.length;
    }, r.prototype.inDegree = function() {
      return this.inEdges.length;
    }, r.prototype.outDegree = function() {
      return this.outEdges.length;
    }, r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, n = t.data.getItemModel(this.dataIndex);
        return n.getModel(e);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      for (var e = {
        edge: [],
        node: []
      }, t = 0; t < this.edges.length; t++) {
        var n = this.edges[t];
        n.dataIndex < 0 || (e.edge.push(n.dataIndex), e.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return e;
    }, r.prototype.getTrajectoryDataIndices = function() {
      for (var e = ce(), t = ce(), n = 0; n < this.edges.length; n++) {
        var i = this.edges[n];
        if (!(i.dataIndex < 0)) {
          e.set(i.dataIndex, true);
          for (var a = [
            i.node1
          ], o = [
            i.node2
          ], s = 0; s < a.length; ) {
            var l = a[s];
            s++, t.set(l.dataIndex, true);
            for (var u = 0; u < l.inEdges.length; u++) e.set(l.inEdges[u].dataIndex, true), a.push(l.inEdges[u].node1);
          }
          for (s = 0; s < o.length; ) {
            var c = o[s];
            s++, t.set(c.dataIndex, true);
            for (var u = 0; u < c.outEdges.length; u++) e.set(c.outEdges[u].dataIndex, true), o.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, r;
  }(), $O = function() {
    function r(e, t, n) {
      this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = n ?? -1;
    }
    return r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, n = t.edgeData.getItemModel(this.dataIndex);
        return n.getModel(e);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [
          this.dataIndex
        ],
        node: [
          this.node1.dataIndex,
          this.node2.dataIndex
        ]
      };
    }, r.prototype.getTrajectoryDataIndices = function() {
      var e = ce(), t = ce();
      e.set(this.dataIndex, true);
      for (var n = [
        this.node1
      ], i = [
        this.node2
      ], a = 0; a < n.length; ) {
        var o = n[a];
        a++, t.set(o.dataIndex, true);
        for (var s = 0; s < o.inEdges.length; s++) e.set(o.inEdges[s].dataIndex, true), n.push(o.inEdges[s].node1);
      }
      for (a = 0; a < i.length; ) {
        var l = i[a];
        a++, t.set(l.dataIndex, true);
        for (var s = 0; s < l.outEdges.length; s++) e.set(l.outEdges[s].dataIndex, true), i.push(l.outEdges[s].node2);
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, r;
  }();
  function GO(r, e) {
    return {
      getValue: function(t) {
        var n = this[r][e];
        return n.getStore().get(n.getDimensionIndex(t || "value"), this.dataIndex);
      },
      setVisual: function(t, n) {
        this.dataIndex >= 0 && this[r][e].setItemVisual(this.dataIndex, t, n);
      },
      getVisual: function(t) {
        return this[r][e].getItemVisual(this.dataIndex, t);
      },
      setLayout: function(t, n) {
        this.dataIndex >= 0 && this[r][e].setItemLayout(this.dataIndex, t, n);
      },
      getLayout: function() {
        return this[r][e].getItemLayout(this.dataIndex);
      },
      getGraphicEl: function() {
        return this[r][e].getItemGraphicEl(this.dataIndex);
      },
      getRawIndex: function() {
        return this[r][e].getRawIndex(this.dataIndex);
      }
    };
  }
  qt(ns, GO("hostGraph", "data"));
  qt($O, GO("hostGraph", "edgeData"));
  function WO(r, e, t, n, i) {
    for (var a = new KQ(n), o = 0; o < r.length; o++) a.addNode(vr(r[o].id, r[o].name, o), o);
    for (var s = [], l = [], u = 0, o = 0; o < e.length; o++) {
      var c = e[o], h = c.source, f = c.target;
      a.addEdge(h, f, u) && (l.push(c), s.push(vr(jt(c.id, null), h + " > " + f)), u++);
    }
    var d = t.get("coordinateSystem"), p;
    if (d === "cartesian2d" || d === "polar") p = Aa(r, t);
    else {
      var v = Sf.get(d), g = v ? v.dimensions || [] : [];
      Be(g, "value") < 0 && g.concat([
        "value"
      ]);
      var m = Cf(r, {
        coordDimensions: g,
        encodeDefine: t.getEncode()
      }).dimensions;
      p = new Wr(m, t), p.initData(r);
    }
    var y = new Wr([
      "value"
    ], t);
    return y.initData(l, s), i && i(p, y), CO({
      mainData: p,
      struct: a,
      structAttr: "graph",
      datas: {
        node: p,
        edge: y
      },
      datasAttr: {
        node: "data",
        edge: "edgeData"
      }
    }), a.update(), a;
  }
  var ZQ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments);
      var n = this;
      function i() {
        return n._categoriesData;
      }
      this.legendVisualProvider = new kf(i, i), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeDefaultAndTheme = function(t) {
      r.prototype.mergeDefaultAndTheme.apply(this, arguments), Bs(t, "edgeLabel", [
        "show"
      ]);
    }, e.prototype.getInitialData = function(t, n) {
      var i = t.edges || t.links || [], a = t.data || t.nodes || [], o = this;
      if (a && i) {
        OQ(this);
        var s = WO(a, i, this, true, l);
        return D(s.edges, function(u) {
          FQ(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var v = o._categoriesModels, g = p.getShallow("category"), m = v[g];
          return m && (m.parentModel = p.parentModel, p.parentModel = m), p;
        });
        var h = ft.prototype.getModel;
        function f(p, v) {
          var g = h.call(this, p, v);
          return g.resolveParentPath = d, g;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = d, p.getModel = f, p;
        });
        function d(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var v = p.slice();
            return p[0] === "label" ? v[0] = "edgeLabel" : p[1] === "label" && (v[1] = "edgeLabel"), v;
          }
          return p;
        }
      }
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, e.prototype.formatTooltip = function(t, n, i) {
      if (i === "edge") {
        var a = this.getData(), o = this.getDataParams(t, i), s = a.graph.getEdgeByIndex(t), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), ur("nameValue", {
          name: c.join(" > "),
          value: o.value,
          noValue: o.value == null
        });
      }
      var h = d3({
        series: this,
        dataIndex: t,
        multipleSeries: n
      });
      return h;
    }, e.prototype._updateCategoriesData = function() {
      var t = K(this.option.categories || [], function(i) {
        return i.value != null ? i : H({
          value: 0
        }, i);
      }), n = new Wr([
        "value"
      ], this);
      n.initData(t), this._categoriesData = n, this._categoriesModels = n.mapArray(function(i) {
        return n.getItemModel(i);
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.isAnimationEnabled = function() {
      return r.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get([
        "force",
        "layoutAnimation"
      ]));
    }, e.type = "series.graph", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      legendHoverLink: true,
      layout: null,
      circular: {
        rotateLabel: false
      },
      force: {
        initLayout: null,
        repulsion: [
          0,
          50
        ],
        gravity: 0.1,
        friction: 0.6,
        edgeLength: 30,
        layoutAnimation: true
      },
      left: "center",
      top: "center",
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: [
        "none",
        "none"
      ],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: false,
      roam: false,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: {
        show: false,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: true,
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Tt), jQ = {
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  };
  function QQ(r) {
    r.registerChartView(qQ), r.registerSeriesModel(ZQ), r.registerProcessor(kQ), r.registerVisual(LQ), r.registerVisual(RQ), r.registerLayout(BQ), r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, VQ), r.registerLayout(GQ), r.registerCoordinateSystem("graphView", {
      dimensions: Rf.dimensions,
      create: UQ
    }), r.registerAction({
      type: "focusNodeAdjacency",
      event: "focusNodeAdjacency",
      update: "series:focusNodeAdjacency"
    }, Wt), r.registerAction({
      type: "unfocusNodeAdjacency",
      event: "unfocusNodeAdjacency",
      update: "series:unfocusNodeAdjacency"
    }, Wt), r.registerAction(jQ, function(e, t, n) {
      t.eachComponent({
        mainType: "series",
        query: e
      }, function(i) {
        var a = i.coordinateSystem, o = aS(a, e, void 0, n);
        i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom);
      });
    });
  }
  var JQ = /* @__PURE__ */ function() {
    function r() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return r;
  }(), eJ = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "pointer", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new JQ();
    }, e.prototype.buildPath = function(t, n) {
      var i = Math.cos, a = Math.sin, o = n.r, s = n.width, l = n.angle, u = n.x - i(l) * s * (s >= o / 3 ? 1 : 2), c = n.y - a(l) * s * (s >= o / 3 ? 1 : 2);
      l = n.angle - Math.PI / 2, t.moveTo(u, c), t.lineTo(n.x + i(l) * s, n.y + a(l) * s), t.lineTo(n.x + i(n.angle) * o, n.y + a(n.angle) * o), t.lineTo(n.x - i(l) * s, n.y - a(l) * s), t.lineTo(u, c);
    }, e;
  }(Ue);
  function tJ(r, e) {
    var t = r.get("center"), n = e.getWidth(), i = e.getHeight(), a = Math.min(n, i), o = Q(t[0], e.getWidth()), s = Q(t[1], e.getHeight()), l = Q(r.get("radius"), a / 2);
    return {
      cx: o,
      cy: s,
      r: l
    };
  }
  function Dd(r, e) {
    var t = r == null ? "" : r + "";
    return e && (ee(e) ? t = e.replace("{value}", t) : ge(e) && (t = e(r))), t;
  }
  var rJ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      this.group.removeAll();
      var a = t.get([
        "axisLine",
        "lineStyle",
        "color"
      ]), o = tJ(t, i);
      this._renderMain(t, n, i, a, o), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.prototype._renderMain = function(t, n, i, a, o) {
      var s = this.group, l = t.get("clockwise"), u = -t.get("startAngle") / 180 * Math.PI, c = -t.get("endAngle") / 180 * Math.PI, h = t.getModel("axisLine"), f = h.get("roundCap"), d = f ? uv : qr, p = h.get("show"), v = h.getModel("lineStyle"), g = v.get("width"), m = [
        u,
        c
      ];
      s1(m, !l), u = m[0], c = m[1];
      for (var y = c - u, x = u, _ = [], S = 0; p && S < a.length; S++) {
        var b = Math.min(Math.max(a[S][0], 0), 1);
        c = u + y * b;
        var w = new d({
          shape: {
            startAngle: x,
            endAngle: c,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - g,
            r: o.r
          },
          silent: true
        });
        w.setStyle({
          fill: a[S][1]
        }), w.setStyle(v.getLineStyle([
          "color",
          "width"
        ])), _.push(w), x = c;
      }
      _.reverse(), D(_, function(T) {
        return s.add(T);
      });
      var C = function(T) {
        if (T <= 0) return a[0][1];
        var A;
        for (A = 0; A < a.length; A++) if (a[A][0] >= T && (A === 0 ? 0 : a[A - 1][0]) < T) return a[A][1];
        return a[A - 1][1];
      };
      this._renderTicks(t, n, i, C, o, u, c, l, g), this._renderTitleAndDetail(t, n, i, C, o), this._renderAnchor(t, o), this._renderPointer(t, n, i, C, o, u, c, l, g);
    }, e.prototype._renderTicks = function(t, n, i, a, o, s, l, u, c) {
      for (var h = this.group, f = o.cx, d = o.cy, p = o.r, v = +t.get("min"), g = +t.get("max"), m = t.getModel("splitLine"), y = t.getModel("axisTick"), x = t.getModel("axisLabel"), _ = t.get("splitNumber"), S = y.get("splitNumber"), b = Q(m.get("length"), p), w = Q(y.get("length"), p), C = s, T = (l - s) / _, A = T / S, M = m.getModel("lineStyle").getLineStyle(), E = y.getModel("lineStyle").getLineStyle(), k = m.get("distance"), R, N, I = 0; I <= _; I++) {
        if (R = Math.cos(C), N = Math.sin(C), m.get("show")) {
          var L = k ? k + c : c, P = new ir({
            shape: {
              x1: R * (p - L) + f,
              y1: N * (p - L) + d,
              x2: R * (p - b - L) + f,
              y2: N * (p - b - L) + d
            },
            style: M,
            silent: true
          });
          M.stroke === "auto" && P.setStyle({
            stroke: a(I / _)
          }), h.add(P);
        }
        if (x.get("show")) {
          var L = x.get("distance") + k, O = Dd(Bt(I / _ * (g - v) + v), x.get("formatter")), F = a(I / _), B = R * (p - b - L) + f, V = N * (p - b - L) + d, U = x.get("rotate"), Y = 0;
          U === "radial" ? (Y = -C + 2 * Math.PI, Y > Math.PI / 2 && (Y += Math.PI)) : U === "tangential" ? Y = -C - Math.PI / 2 : nt(U) && (Y = U * Math.PI / 180), Y === 0 ? h.add(new rt({
            style: wt(x, {
              text: O,
              x: B,
              y: V,
              verticalAlign: N < -0.8 ? "top" : N > 0.8 ? "bottom" : "middle",
              align: R < -0.4 ? "left" : R > 0.4 ? "right" : "center"
            }, {
              inheritColor: F
            }),
            silent: true
          })) : h.add(new rt({
            style: wt(x, {
              text: O,
              x: B,
              y: V,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: F
            }),
            silent: true,
            originX: B,
            originY: V,
            rotation: Y
          }));
        }
        if (y.get("show") && I !== _) {
          var L = y.get("distance");
          L = L ? L + c : c;
          for (var q = 0; q <= S; q++) {
            R = Math.cos(C), N = Math.sin(C);
            var me = new ir({
              shape: {
                x1: R * (p - L) + f,
                y1: N * (p - L) + d,
                x2: R * (p - w - L) + f,
                y2: N * (p - w - L) + d
              },
              silent: true,
              style: E
            });
            E.stroke === "auto" && me.setStyle({
              stroke: a((I + q / S) / _)
            }), h.add(me), C += A;
          }
          C -= A;
        } else C += T;
      }
    }, e.prototype._renderPointer = function(t, n, i, a, o, s, l, u, c) {
      var h = this.group, f = this._data, d = this._progressEls, p = [], v = t.get([
        "pointer",
        "show"
      ]), g = t.getModel("progress"), m = g.get("show"), y = t.getData(), x = y.mapDimension("value"), _ = +t.get("min"), S = +t.get("max"), b = [
        _,
        S
      ], w = [
        s,
        l
      ];
      function C(A, M) {
        var E = y.getItemModel(A), k = E.getModel("pointer"), R = Q(k.get("width"), o.r), N = Q(k.get("length"), o.r), I = t.get([
          "pointer",
          "icon"
        ]), L = k.get("offsetCenter"), P = Q(L[0], o.r), O = Q(L[1], o.r), F = k.get("keepAspect"), B;
        return I ? B = Xt(I, P - R / 2, O - N, R, N, null, F) : B = new eJ({
          shape: {
            angle: -Math.PI / 2,
            width: R,
            r: N,
            x: P,
            y: O
          }
        }), B.rotation = -(M + Math.PI / 2), B.x = o.cx, B.y = o.cy, B;
      }
      function T(A, M) {
        var E = g.get("roundCap"), k = E ? uv : qr, R = g.get("overlap"), N = R ? g.get("width") : c / y.count(), I = R ? o.r - N : o.r - (A + 1) * N, L = R ? o.r : o.r - A * N, P = new k({
          shape: {
            startAngle: s,
            endAngle: M,
            cx: o.cx,
            cy: o.cy,
            clockwise: u,
            r0: I,
            r: L
          }
        });
        return R && (P.z2 = ht(y.get(x, A), [
          _,
          S
        ], [
          100,
          0
        ], true)), P;
      }
      (m || v) && (y.diff(f).add(function(A) {
        var M = y.get(x, A);
        if (v) {
          var E = C(A, s);
          kt(E, {
            rotation: -((isNaN(+M) ? w[0] : ht(M, b, w, true)) + Math.PI / 2)
          }, t), h.add(E), y.setItemGraphicEl(A, E);
        }
        if (m) {
          var k = T(A, s), R = g.get("clip");
          kt(k, {
            shape: {
              endAngle: ht(M, b, w, R)
            }
          }, t), h.add(k), Rx(t.seriesIndex, y.dataType, A, k), p[A] = k;
        }
      }).update(function(A, M) {
        var E = y.get(x, A);
        if (v) {
          var k = f.getItemGraphicEl(M), R = k ? k.rotation : s, N = C(A, R);
          N.rotation = R, it(N, {
            rotation: -((isNaN(+E) ? w[0] : ht(E, b, w, true)) + Math.PI / 2)
          }, t), h.add(N), y.setItemGraphicEl(A, N);
        }
        if (m) {
          var I = d[M], L = I ? I.shape.endAngle : s, P = T(A, L), O = g.get("clip");
          it(P, {
            shape: {
              endAngle: ht(E, b, w, O)
            }
          }, t), h.add(P), Rx(t.seriesIndex, y.dataType, A, P), p[A] = P;
        }
      }).execute(), y.each(function(A) {
        var M = y.getItemModel(A), E = M.getModel("emphasis"), k = E.get("focus"), R = E.get("blurScope"), N = E.get("disabled");
        if (v) {
          var I = y.getItemGraphicEl(A), L = y.getItemVisual(A, "style"), P = L.fill;
          if (I instanceof mr) {
            var O = I.style;
            I.useStyle(H({
              image: O.image,
              x: O.x,
              y: O.y,
              width: O.width,
              height: O.height
            }, L));
          } else I.useStyle(L), I.type !== "pointer" && I.setColor(P);
          I.setStyle(M.getModel([
            "pointer",
            "itemStyle"
          ]).getItemStyle()), I.style.fill === "auto" && I.setStyle("fill", a(ht(y.get(x, A), b, [
            0,
            1
          ], true))), I.z2EmphasisLift = 0, br(I, M), Nt(I, k, R, N);
        }
        if (m) {
          var F = p[A];
          F.useStyle(y.getItemVisual(A, "style")), F.setStyle(M.getModel([
            "progress",
            "itemStyle"
          ]).getItemStyle()), F.z2EmphasisLift = 0, br(F, M), Nt(F, k, R, N);
        }
      }), this._progressEls = p);
    }, e.prototype._renderAnchor = function(t, n) {
      var i = t.getModel("anchor"), a = i.get("show");
      if (a) {
        var o = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = Xt(s, n.cx - o / 2 + Q(l[0], n.r), n.cy - o / 2 + Q(l[1], n.r), o, o, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, e.prototype._renderTitleAndDetail = function(t, n, i, a, o) {
      var s = this, l = t.getData(), u = l.mapDimension("value"), c = +t.get("min"), h = +t.get("max"), f = new Ce(), d = [], p = [], v = t.isAnimationEnabled(), g = t.get([
        "pointer",
        "showAbove"
      ]);
      l.diff(this._data).add(function(m) {
        d[m] = new rt({
          silent: true
        }), p[m] = new rt({
          silent: true
        });
      }).update(function(m, y) {
        d[m] = s._titleEls[y], p[m] = s._detailEls[y];
      }).execute(), l.each(function(m) {
        var y = l.getItemModel(m), x = l.get(u, m), _ = new Ce(), S = a(ht(x, [
          c,
          h
        ], [
          0,
          1
        ], true)), b = y.getModel("title");
        if (b.get("show")) {
          var w = b.get("offsetCenter"), C = o.cx + Q(w[0], o.r), T = o.cy + Q(w[1], o.r), A = d[m];
          A.attr({
            z2: g ? 0 : 2,
            style: wt(b, {
              x: C,
              y: T,
              text: l.getName(m),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: S
            })
          }), _.add(A);
        }
        var M = y.getModel("detail");
        if (M.get("show")) {
          var E = M.get("offsetCenter"), k = o.cx + Q(E[0], o.r), R = o.cy + Q(E[1], o.r), N = Q(M.get("width"), o.r), I = Q(M.get("height"), o.r), L = t.get([
            "progress",
            "show"
          ]) ? l.getItemVisual(m, "style").fill : S, A = p[m], P = M.get("formatter");
          A.attr({
            z2: g ? 0 : 2,
            style: wt(M, {
              x: k,
              y: R,
              text: Dd(x, P),
              width: isNaN(N) ? null : N,
              height: isNaN(I) ? null : I,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: L
            })
          }), mE(A, {
            normal: M
          }, x, function(F) {
            return Dd(F, P);
          }), v && yE(A, m, l, t, {
            getFormattedLabel: function(F, B, V, U, Y, q) {
              return Dd(q ? q.interpolatedValue : x, P);
            }
          }), _.add(A);
        }
        f.add(_);
      }), this.group.add(f), this._titleEls = d, this._detailEls = p;
    }, e.type = "gauge", e;
  }(yt), nJ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "itemStyle", t;
    }
    return e.prototype.getInitialData = function(t, n) {
      return Wu(this, [
        "value"
      ]);
    }, e.type = "series.gauge", e.defaultOption = {
      z: 2,
      colorBy: "data",
      center: [
        "50%",
        "50%"
      ],
      legendHoverLink: true,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: true,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        show: true,
        roundCap: false,
        lineStyle: {
          color: [
            [
              1,
              "#E6EBF8"
            ]
          ],
          width: 10
        }
      },
      progress: {
        show: false,
        overlap: true,
        width: 10,
        roundCap: false,
        clip: true
      },
      splitLine: {
        show: true,
        length: 10,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      axisTick: {
        show: true,
        splitNumber: 5,
        length: 6,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: true,
        distance: 15,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [
          0,
          0
        ],
        show: true,
        showAbove: true,
        length: "60%",
        width: 6,
        keepAspect: false
      },
      anchor: {
        show: false,
        showAbove: false,
        size: 6,
        icon: "circle",
        offsetCenter: [
          0,
          0
        ],
        keepAspect: false,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: true,
        offsetCenter: [
          0,
          "20%"
        ],
        color: "#464646",
        fontSize: 16,
        valueAnimation: false
      },
      detail: {
        show: true,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [
          5,
          10
        ],
        offsetCenter: [
          0,
          "40%"
        ],
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: false
      }
    }, e;
  }(Tt);
  function iJ(r) {
    r.registerChartView(rJ), r.registerSeriesModel(nJ);
  }
  var aJ = [
    "itemStyle",
    "opacity"
  ], oJ = function(r) {
    G(e, r);
    function e(t, n) {
      var i = r.call(this) || this, a = i, o = new Zr(), s = new rt();
      return a.setTextContent(s), i.setTextGuideLine(o), i.updateData(t, n, true), i;
    }
    return e.prototype.updateData = function(t, n, i) {
      var a = this, o = t.hostModel, s = t.getItemModel(n), l = t.getItemLayout(n), u = s.getModel("emphasis"), c = s.get(aJ);
      c = c ?? 1, i || li(a), a.useStyle(t.getItemVisual(n, "style")), a.style.lineJoin = "round", i ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, kt(a, {
        style: {
          opacity: c
        }
      }, o, n)) : it(a, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, o, n), br(a, s), this._updateLabel(t, n), Nt(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, n) {
      var i = this, a = this.getTextGuideLine(), o = i.getTextContent(), s = t.hostModel, l = t.getItemModel(n), u = t.getItemLayout(n), c = u.label, h = t.getItemVisual(n, "style"), f = h.fill;
      Sr(o, lr(l), {
        labelFetcher: t.hostModel,
        labelDataIndex: n,
        defaultOpacity: h.opacity,
        defaultText: t.getName(n)
      }, {
        normal: {
          align: c.textAlign,
          verticalAlign: c.verticalAlign
        }
      }), i.setTextConfig({
        local: true,
        inside: !!c.inside,
        insideStroke: f,
        outsideFill: f
      });
      var d = c.linePoints;
      a.setShape({
        points: d
      }), i.textGuideLineConfig = {
        anchor: d ? new Ne(d[0][0], d[0][1]) : null
      }, it(o, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, n), o.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), H1(i, Y1(l), {
        stroke: f
      });
    }, e;
  }(Kr), sJ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreLabelLineUpdate = true, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = this._data, s = this.group;
      a.diff(o).add(function(l) {
        var u = new oJ(a, l);
        a.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = o.getItemGraphicEl(u);
        c.updateData(a, l), s.add(c), a.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        Mh(u, t, l);
      }).execute(), this._data = a;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.prototype.dispose = function() {
    }, e.type = "funnel", e;
  }(yt), lJ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new kf(ne(this.getData, this), ne(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.getInitialData = function(t, n) {
      return Wu(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: Le(C1, this)
      });
    }, e.prototype._defaultLabelLine = function(t) {
      Bs(t, "labelLine", [
        "show"
      ]);
      var n = t.labelLine, i = t.emphasis.labelLine;
      n.show = n.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.prototype.getDataParams = function(t) {
      var n = this.getData(), i = r.prototype.getDataParams.call(this, t), a = n.mapDimension("value"), o = n.getSum(a);
      return i.percent = o ? +(n.get(a, t) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, e.type = "series.funnel", e.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: true,
        position: "outer"
      },
      labelLine: {
        show: true,
        length: 20,
        lineStyle: {
          width: 1
        }
      },
      itemStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Tt);
  function uJ(r, e) {
    return er(r.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function cJ(r, e) {
    for (var t = r.mapDimension("value"), n = r.mapArray(t, function(l) {
      return l;
    }), i = [], a = e === "ascending", o = 0, s = r.count(); o < s; o++) i[o] = o;
    return ge(e) ? i.sort(e) : e !== "none" && i.sort(function(l, u) {
      return a ? n[l] - n[u] : n[u] - n[l];
    }), i;
  }
  function hJ(r) {
    var e = r.hostModel, t = e.get("orient");
    r.each(function(n) {
      var i = r.getItemModel(n), a = i.getModel("label"), o = a.get("position"), s = i.getModel("labelLine"), l = r.getItemLayout(n), u = l.points, c = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", h, f, d, p;
      if (c) o === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, d = (u[0][1] + u[3][1]) / 2, h = "left") : o === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, d = (u[1][1] + u[2][1]) / 2, h = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, h = "center"), p = [
        [
          f,
          d
        ],
        [
          f,
          d
        ]
      ];
      else {
        var v = void 0, g = void 0, m = void 0, y = void 0, x = s.get("length");
        o === "left" ? (v = (u[3][0] + u[0][0]) / 2, g = (u[3][1] + u[0][1]) / 2, m = v - x, f = m - 5, h = "right") : o === "right" ? (v = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, m = v + x, f = m + 5, h = "left") : o === "top" ? (v = (u[3][0] + u[0][0]) / 2, g = (u[3][1] + u[0][1]) / 2, y = g - x, d = y - 5, h = "center") : o === "bottom" ? (v = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, y = g + x, d = y + 5, h = "center") : o === "rightTop" ? (v = t === "horizontal" ? u[3][0] : u[1][0], g = t === "horizontal" ? u[3][1] : u[1][1], t === "horizontal" ? (y = g - x, d = y - 5, h = "center") : (m = v + x, f = m + 5, h = "top")) : o === "rightBottom" ? (v = u[2][0], g = u[2][1], t === "horizontal" ? (y = g + x, d = y + 5, h = "center") : (m = v + x, f = m + 5, h = "bottom")) : o === "leftTop" ? (v = u[0][0], g = t === "horizontal" ? u[0][1] : u[1][1], t === "horizontal" ? (y = g - x, d = y - 5, h = "center") : (m = v - x, f = m - 5, h = "right")) : o === "leftBottom" ? (v = t === "horizontal" ? u[1][0] : u[3][0], g = t === "horizontal" ? u[1][1] : u[2][1], t === "horizontal" ? (y = g + x, d = y + 5, h = "center") : (m = v - x, f = m - 5, h = "right")) : (v = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, t === "horizontal" ? (y = g + x, d = y + 5, h = "center") : (m = v + x, f = m + 5, h = "left")), t === "horizontal" ? (m = v, f = m) : (y = g, d = y), p = [
          [
            v,
            g
          ],
          [
            m,
            y
          ]
        ];
      }
      l.label = {
        linePoints: p,
        x: f,
        y: d,
        verticalAlign: "middle",
        textAlign: h,
        inside: c
      };
    });
  }
  function fJ(r, e) {
    r.eachSeriesByType("funnel", function(t) {
      var n = t.getData(), i = n.mapDimension("value"), a = t.get("sort"), o = uJ(t, e), s = t.get("orient"), l = o.width, u = o.height, c = cJ(n, a), h = o.x, f = o.y, d = s === "horizontal" ? [
        Q(t.get("minSize"), u),
        Q(t.get("maxSize"), u)
      ] : [
        Q(t.get("minSize"), l),
        Q(t.get("maxSize"), l)
      ], p = n.getDataExtent(i), v = t.get("min"), g = t.get("max");
      v == null && (v = Math.min(p[0], 0)), g == null && (g = p[1]);
      var m = t.get("funnelAlign"), y = t.get("gap"), x = s === "horizontal" ? l : u, _ = (x - y * (n.count() - 1)) / n.count(), S = function(R, N) {
        if (s === "horizontal") {
          var I = n.get(i, R) || 0, L = ht(I, [
            v,
            g
          ], d, true), P = void 0;
          switch (m) {
            case "top":
              P = f;
              break;
            case "center":
              P = f + (u - L) / 2;
              break;
            case "bottom":
              P = f + (u - L);
              break;
          }
          return [
            [
              N,
              P
            ],
            [
              N,
              P + L
            ]
          ];
        }
        var O = n.get(i, R) || 0, F = ht(O, [
          v,
          g
        ], d, true), B;
        switch (m) {
          case "left":
            B = h;
            break;
          case "center":
            B = h + (l - F) / 2;
            break;
          case "right":
            B = h + l - F;
            break;
        }
        return [
          [
            B,
            N
          ],
          [
            B + F,
            N
          ]
        ];
      };
      a === "ascending" && (_ = -_, y = -y, s === "horizontal" ? h += l : f += u, c = c.reverse());
      for (var b = 0; b < c.length; b++) {
        var w = c[b], C = c[b + 1], T = n.getItemModel(w);
        if (s === "horizontal") {
          var A = T.get([
            "itemStyle",
            "width"
          ]);
          A == null ? A = _ : (A = Q(A, l), a === "ascending" && (A = -A));
          var M = S(w, h), E = S(C, h + A);
          h += A + y, n.setItemLayout(w, {
            points: M.concat(E.slice().reverse())
          });
        } else {
          var k = T.get([
            "itemStyle",
            "height"
          ]);
          k == null ? k = _ : (k = Q(k, u), a === "ascending" && (k = -k));
          var M = S(w, f), E = S(C, f + k);
          f += k + y, n.setItemLayout(w, {
            points: M.concat(E.slice().reverse())
          });
        }
      }
      hJ(n);
    });
  }
  function dJ(r) {
    r.registerChartView(sJ), r.registerSeriesModel(lJ), r.registerLayout(fJ), r.registerProcessor(Pf("funnel"));
  }
  var pJ = 0.3, vJ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._dataGroup = new Ce(), t._initialized = false, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, e.prototype.render = function(t, n, i, a) {
      this._progressiveEls = null;
      var o = this._dataGroup, s = t.getData(), l = this._data, u = t.coordinateSystem, c = u.dimensions, h = AI(t);
      s.diff(l).add(f).update(d).remove(p).execute();
      function f(g) {
        var m = TI(s, o, g, c, u);
        Ey(m, s, g, h);
      }
      function d(g, m) {
        var y = l.getItemGraphicEl(m), x = UO(s, g, c, u);
        s.setItemGraphicEl(g, y), it(y, {
          shape: {
            points: x
          }
        }, t, g), li(y), Ey(y, s, g, h);
      }
      function p(g) {
        var m = l.getItemGraphicEl(g);
        o.remove(m);
      }
      if (!this._initialized) {
        this._initialized = true;
        var v = gJ(u, t, function() {
          setTimeout(function() {
            o.removeClipPath();
          });
        });
        o.setClipPath(v);
      }
      this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, n, i) {
      this._initialized = true, this._data = null, this._dataGroup.removeAll();
    }, e.prototype.incrementalRender = function(t, n, i) {
      for (var a = n.getData(), o = n.coordinateSystem, s = o.dimensions, l = AI(n), u = this._progressiveEls = [], c = t.start; c < t.end; c++) {
        var h = TI(a, this._dataGroup, c, s, o);
        h.incremental = true, Ey(h, a, c, l), u.push(h);
      }
    }, e.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, e.type = "parallel", e;
  }(yt);
  function gJ(r, e, t) {
    var n = r.model, i = r.getRect(), a = new et({
      shape: {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      }
    }), o = n.get("layout") === "horizontal" ? "width" : "height";
    return a.setShape(o, 0), kt(a, {
      shape: {
        width: i.width,
        height: i.height
      }
    }, e, t), a;
  }
  function UO(r, e, t, n) {
    for (var i = [], a = 0; a < t.length; a++) {
      var o = t[a], s = r.get(r.mapDimension(o), e);
      mJ(s, n.getAxis(o).type) || i.push(n.dataToPoint(s, o));
    }
    return i;
  }
  function TI(r, e, t, n, i) {
    var a = UO(r, t, n, i), o = new Zr({
      shape: {
        points: a
      },
      z2: 10
    });
    return e.add(o), r.setItemGraphicEl(t, o), o;
  }
  function AI(r) {
    var e = r.get("smooth", true);
    return e === true && (e = pJ), e = va(e), xh(e) && (e = 0), {
      smooth: e
    };
  }
  function Ey(r, e, t, n) {
    r.useStyle(e.getItemVisual(t, "style")), r.style.fill = null, r.setShape("smooth", n.smooth);
    var i = e.getItemModel(t), a = i.getModel("emphasis");
    br(r, i, "lineStyle"), Nt(r, a.get("focus"), a.get("blurScope"), a.get("disabled"));
  }
  function mJ(r, e) {
    return e === "category" ? r == null : r == null || isNaN(r);
  }
  var yJ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.getInitialData = function(t, n) {
      return Aa(null, this, {
        useEncodeDefaulter: ne(xJ, null, this)
      });
    }, e.prototype.getRawIndicesByActiveState = function(t) {
      var n = this.coordinateSystem, i = this.getData(), a = [];
      return n.eachActiveState(i, function(o, s) {
        t === o && a.push(i.getRawIndex(s));
      }), a;
    }, e.type = "series.parallel", e.dependencies = [
      "parallel"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: false
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: false
        }
      },
      progressive: 500,
      smooth: false,
      animationEasing: "linear"
    }, e;
  }(Tt);
  function xJ(r) {
    var e = r.ecModel.getComponent("parallel", r.get("parallelIndex"));
    if (e) {
      var t = {};
      return D(e.dimensions, function(n) {
        var i = _J(n);
        t[n] = i;
      }), t;
    }
  }
  function _J(r) {
    return +r.replace("dim", "");
  }
  var bJ = [
    "lineStyle",
    "opacity"
  ], SJ = {
    seriesType: "parallel",
    reset: function(r, e) {
      var t = r.coordinateSystem, n = {
        normal: r.get([
          "lineStyle",
          "opacity"
        ]),
        active: r.get("activeOpacity"),
        inactive: r.get("inactiveOpacity")
      };
      return {
        progress: function(i, a) {
          t.eachActiveState(a, function(o, s) {
            var l = n[o];
            if (o === "normal" && a.hasItemOption) {
              var u = a.getItemModel(s).get(bJ, true);
              u != null && (l = u);
            }
            var c = a.ensureUniqueItemVisual(s, "style");
            c.opacity = l;
          }, i.start, i.end);
        }
      };
    }
  };
  function wJ(r) {
    CJ(r), TJ(r);
  }
  function CJ(r) {
    if (!r.parallel) {
      var e = false;
      D(r.series, function(t) {
        t && t.type === "parallel" && (e = true);
      }), e && (r.parallel = [
        {}
      ]);
    }
  }
  function TJ(r) {
    var e = gt(r.parallelAxis);
    D(e, function(t) {
      if (_e(t)) {
        var n = t.parallelIndex || 0, i = gt(r.parallel)[n];
        i && i.parallelAxisDefault && Ee(t, i.parallelAxisDefault, false);
      }
    });
  }
  var AJ = 5, IJ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      this._model = t, this._api = i, this._handlers || (this._handlers = {}, D(MJ, function(a, o) {
        i.getZr().on(o, this._handlers[o] = ne(a, this));
      }, this)), Vu(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
    }, e.prototype.dispose = function(t, n) {
      Lh(this, "_throttledDispatchExpand"), D(this._handlers, function(i, a) {
        n.getZr().off(a, i);
      }), this._handlers = null;
    }, e.prototype._throttledDispatchExpand = function(t) {
      this._dispatchExpand(t);
    }, e.prototype._dispatchExpand = function(t) {
      t && this._api.dispatchAction(H({
        type: "parallelAxisExpand"
      }, t));
    }, e.type = "parallel", e;
  }(Rt), MJ = {
    mousedown: function(r) {
      Ny(this, "click") && (this._mouseDownPoint = [
        r.offsetX,
        r.offsetY
      ]);
    },
    mouseup: function(r) {
      var e = this._mouseDownPoint;
      if (Ny(this, "click") && e) {
        var t = [
          r.offsetX,
          r.offsetY
        ], n = Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
        if (n > AJ) return;
        var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([
          r.offsetX,
          r.offsetY
        ]);
        i.behavior !== "none" && this._dispatchExpand({
          axisExpandWindow: i.axisExpandWindow
        });
      }
      this._mouseDownPoint = null;
    },
    mousemove: function(r) {
      if (!(this._mouseDownPoint || !Ny(this, "mousemove"))) {
        var e = this._model, t = e.coordinateSystem.getSlidedAxisExpandWindow([
          r.offsetX,
          r.offsetY
        ]), n = t.behavior;
        n === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(n === "none" ? null : {
          axisExpandWindow: t.axisExpandWindow,
          animation: n === "jump" ? null : {
            duration: 0
          }
        });
      }
    }
  };
  function Ny(r, e) {
    var t = r._model;
    return t.get("axisExpandable") && t.get("axisExpandTriggerOn") === e;
  }
  var DJ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      r.prototype.init.apply(this, arguments), this.mergeOption({});
    }, e.prototype.mergeOption = function(t) {
      var n = this.option;
      t && Ee(n, t, true), this._initDimensions();
    }, e.prototype.contains = function(t, n) {
      var i = t.get("parallelIndex");
      return i != null && n.getComponent("parallel", i) === this;
    }, e.prototype.setAxisExpand = function(t) {
      D([
        "axisExpandable",
        "axisExpandCenter",
        "axisExpandCount",
        "axisExpandWidth",
        "axisExpandWindow"
      ], function(n) {
        t.hasOwnProperty(n) && (this.option[n] = t[n]);
      }, this);
    }, e.prototype._initDimensions = function() {
      var t = this.dimensions = [], n = this.parallelAxisIndex = [], i = ct(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      D(i, function(a) {
        t.push("dim" + a.get("dim")), n.push(a.componentIndex);
      });
    }, e.type = "parallel", e.dependencies = [
      "parallelAxis"
    ], e.layoutMode = "box", e.defaultOption = {
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      layout: "horizontal",
      axisExpandable: false,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      axisExpandSlideTriggerArea: [
        -0.15,
        0.05,
        0.4
      ],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, e;
  }(Ke), PJ = function(r) {
    G(e, r);
    function e(t, n, i, a, o) {
      var s = r.call(this, t, n, i) || this;
      return s.type = a || "value", s.axisIndex = o, s;
    }
    return e.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, e;
  }(hi);
  function tl(r, e, t, n, i, a) {
    r = r || 0;
    var o = t[1] - t[0];
    if (i != null && (i = Tl(i, [
      0,
      o
    ])), a != null && (a = Math.max(a, i ?? 0)), n === "all") {
      var s = Math.abs(e[1] - e[0]);
      s = Tl(s, [
        0,
        o
      ]), i = a = Tl(s, [
        i,
        a
      ]), n = 0;
    }
    e[0] = Tl(e[0], t), e[1] = Tl(e[1], t);
    var l = Oy(e, n);
    e[n] += r;
    var u = i || 0, c = t.slice();
    l.sign < 0 ? c[0] += u : c[1] -= u, e[n] = Tl(e[n], c);
    var h;
    return h = Oy(e, n), i != null && (h.sign !== l.sign || h.span < i) && (e[1 - n] = e[n] + l.sign * i), h = Oy(e, n), a != null && h.span > a && (e[1 - n] = e[n] + h.sign * a), e;
  }
  function Oy(r, e) {
    var t = r[e] - r[1 - e];
    return {
      span: Math.abs(t),
      sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1
    };
  }
  function Tl(r, e) {
    return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, r));
  }
  var Fy = D, HO = Math.min, YO = Math.max, II = Math.floor, kJ = Math.ceil, MI = Bt, LJ = Math.PI, RJ = function() {
    function r(e, t, n) {
      this.type = "parallel", this._axesMap = ce(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, t, n);
    }
    return r.prototype._init = function(e, t, n) {
      var i = e.dimensions, a = e.parallelAxisIndex;
      Fy(i, function(o, s) {
        var l = a[s], u = t.getComponent("parallelAxis", l), c = this._axesMap.set(o, new PJ(o, bg(u), [
          0,
          0
        ], u.get("type"), l)), h = c.type === "category";
        c.onBand = h && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, r.prototype.update = function(e, t) {
      this._updateAxesFromSeries(this._model, e);
    }, r.prototype.containPoint = function(e) {
      var t = this._makeLayoutInfo(), n = t.axisBase, i = t.layoutBase, a = t.pixelDimIndex, o = e[1 - a], s = e[a];
      return o >= n && o <= n + t.axisLength && s >= i && s <= i + t.layoutLength;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype._updateAxesFromSeries = function(e, t) {
      t.eachSeries(function(n) {
        if (e.contains(n, t)) {
          var i = n.getData();
          Fy(this.dimensions, function(a) {
            var o = this._axesMap.get(a);
            o.scale.unionExtentFromData(i, i.mapDimension(a)), fu(o.scale, o.model);
          }, this);
        }
      }, this);
    }, r.prototype.resize = function(e, t) {
      this._rect = er(e.getBoxLayoutParams(), {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._layoutAxes();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._makeLayoutInfo = function() {
      var e = this._model, t = this._rect, n = [
        "x",
        "y"
      ], i = [
        "width",
        "height"
      ], a = e.get("layout"), o = a === "horizontal" ? 0 : 1, s = t[i[o]], l = [
        0,
        s
      ], u = this.dimensions.length, c = Pd(e.get("axisExpandWidth"), l), h = Pd(e.get("axisExpandCount") || 0, [
        0,
        u
      ]), f = e.get("axisExpandable") && u > 3 && u > h && h > 1 && c > 0 && s > 0, d = e.get("axisExpandWindow"), p;
      if (d) p = Pd(d[1] - d[0], l), d[1] = d[0] + p;
      else {
        p = Pd(c * (h - 1), l);
        var v = e.get("axisExpandCenter") || II(u / 2);
        d = [
          c * v - p / 2
        ], d[1] = d[0] + p;
      }
      var g = (s - p) / (u - h);
      g < 3 && (g = 0);
      var m = [
        II(MI(d[0] / c, 1)) + 1,
        kJ(MI(d[1] / c, 1)) - 1
      ], y = g / c * d[0];
      return {
        layout: a,
        pixelDimIndex: o,
        layoutBase: t[n[o]],
        layoutLength: s,
        axisBase: t[n[1 - o]],
        axisLength: t[i[1 - o]],
        axisExpandable: f,
        axisExpandWidth: c,
        axisCollapseWidth: g,
        axisExpandWindow: d,
        axisCount: u,
        winInnerIndices: m,
        axisExpandWindow0Pos: y
      };
    }, r.prototype._layoutAxes = function() {
      var e = this._rect, t = this._axesMap, n = this.dimensions, i = this._makeLayoutInfo(), a = i.layout;
      t.each(function(o) {
        var s = [
          0,
          i.axisLength
        ], l = o.inverse ? 1 : 0;
        o.setExtent(s[l], s[1 - l]);
      }), Fy(n, function(o, s) {
        var l = (i.axisExpandable ? NJ : EJ)(s, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: LJ / 2,
          vertical: 0
        }, h = [
          u[a].x + e.x,
          u[a].y + e.y
        ], f = c[a], d = pn();
        qs(d, d, f), Bi(d, d, h), this._axesLayout[o] = {
          position: h,
          rotation: f,
          transform: d,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, r.prototype.getAxis = function(e) {
      return this._axesMap.get(e);
    }, r.prototype.dataToPoint = function(e, t) {
      return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t);
    }, r.prototype.eachActiveState = function(e, t, n, i) {
      n == null && (n = 0), i == null && (i = e.count());
      var a = this._axesMap, o = this.dimensions, s = [], l = [];
      D(o, function(g) {
        s.push(e.mapDimension(g)), l.push(a.get(g).model);
      });
      for (var u = this.hasAxisBrushed(), c = n; c < i; c++) {
        var h = void 0;
        if (!u) h = "normal";
        else {
          h = "active";
          for (var f = e.getValues(s, c), d = 0, p = o.length; d < p; d++) {
            var v = l[d].getActiveState(f[d]);
            if (v === "inactive") {
              h = "inactive";
              break;
            }
          }
        }
        t(h, c);
      }
    }, r.prototype.hasAxisBrushed = function() {
      for (var e = this.dimensions, t = this._axesMap, n = false, i = 0, a = e.length; i < a; i++) t.get(e[i]).model.getActiveState() !== "normal" && (n = true);
      return n;
    }, r.prototype.axisCoordToPoint = function(e, t) {
      var n = this._axesLayout[t];
      return ai([
        e,
        0
      ], n.transform);
    }, r.prototype.getAxisLayout = function(e) {
      return be(this._axesLayout[e]);
    }, r.prototype.getSlidedAxisExpandWindow = function(e) {
      var t = this._makeLayoutInfo(), n = t.pixelDimIndex, i = t.axisExpandWindow.slice(), a = i[1] - i[0], o = [
        0,
        t.axisExpandWidth * (t.axisCount - 1)
      ];
      if (!this.containPoint(e)) return {
        behavior: "none",
        axisExpandWindow: i
      };
      var s = e[n] - t.layoutBase - t.axisExpandWindow0Pos, l, u = "slide", c = t.axisCollapseWidth, h = this._model.get("axisExpandSlideTriggerArea"), f = h[0] != null;
      if (c) f && c && s < a * h[0] ? (u = "jump", l = s - a * h[2]) : f && c && s > a * (1 - h[0]) ? (u = "jump", l = s - a * (1 - h[2])) : (l = s - a * h[1]) >= 0 && (l = s - a * (1 - h[1])) <= 0 && (l = 0), l *= t.axisExpandWidth / c, l ? tl(l, i, o, "all") : u = "none";
      else {
        var d = i[1] - i[0], p = o[1] * s / d;
        i = [
          YO(0, p - d / 2)
        ], i[1] = HO(o[1], i[0] + d), i[0] = i[1] - d;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, r;
  }();
  function Pd(r, e) {
    return HO(YO(r, e[0]), e[1]);
  }
  function EJ(r, e) {
    var t = e.layoutLength / (e.axisCount - 1);
    return {
      position: t * r,
      axisNameAvailableWidth: t,
      axisLabelShow: true
    };
  }
  function NJ(r, e) {
    var t = e.layoutLength, n = e.axisExpandWidth, i = e.axisCount, a = e.axisCollapseWidth, o = e.winInnerIndices, s, l = a, u = false, c;
    return r < o[0] ? (s = r * a, c = a) : r <= o[1] ? (s = e.axisExpandWindow0Pos + r * n - e.axisExpandWindow[0], l = n, u = true) : (s = t - (i - 1 - r) * a, c = a), {
      position: s,
      axisNameAvailableWidth: l,
      axisLabelShow: u,
      nameTruncateMaxWidth: c
    };
  }
  function OJ(r, e) {
    var t = [];
    return r.eachComponent("parallel", function(n, i) {
      var a = new RJ(n, r, e);
      a.name = "parallel_" + i, a.resize(n, e), n.coordinateSystem = a, a.model = n, t.push(a);
    }), r.eachSeries(function(n) {
      if (n.get("coordinateSystem") === "parallel") {
        var i = n.getReferringComponents("parallel", Yt).models[0];
        n.coordinateSystem = i.coordinateSystem;
      }
    }), t;
  }
  var FJ = {
    create: OJ
  }, w_ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.activeIntervals = [], t;
    }
    return e.prototype.getAreaSelectStyle = function() {
      return Vs([
        [
          "fill",
          "color"
        ],
        [
          "lineWidth",
          "borderWidth"
        ],
        [
          "stroke",
          "borderColor"
        ],
        [
          "width",
          "width"
        ],
        [
          "opacity",
          "opacity"
        ]
      ])(this.getModel("areaSelectStyle"));
    }, e.prototype.setActiveIntervals = function(t) {
      var n = this.activeIntervals = be(t);
      if (n) for (var i = n.length - 1; i >= 0; i--) On(n[i]);
    }, e.prototype.getActiveState = function(t) {
      var n = this.activeIntervals;
      if (!n.length) return "normal";
      if (t == null || isNaN(+t)) return "inactive";
      if (n.length === 1) {
        var i = n[0];
        if (i[0] <= t && t <= i[1]) return "active";
      } else for (var a = 0, o = n.length; a < o; a++) if (n[a][0] <= t && t <= n[a][1]) return "active";
      return "inactive";
    }, e;
  }(Ke);
  qt(w_, Tf);
  var Ws = true, Uh = Math.min, vu = Math.max, BJ = Math.pow, zJ = 1e4, VJ = 6, $J = 6, DI = "globalPan", GJ = {
    w: [
      0,
      0
    ],
    e: [
      0,
      1
    ],
    n: [
      1,
      0
    ],
    s: [
      1,
      1
    ]
  }, WJ = {
    w: "ew",
    e: "ew",
    n: "ns",
    s: "ns",
    ne: "nesw",
    sw: "nesw",
    nw: "nwse",
    se: "nwse"
  }, PI = {
    brushStyle: {
      lineWidth: 2,
      stroke: "rgba(210,219,238,0.3)",
      fill: "#D2DBEE"
    },
    transformable: true,
    brushMode: "single",
    removeOnClick: false
  }, UJ = 0, vS = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this) || this;
      return n._track = [], n._covers = [], n._handlers = {}, n._zr = t, n.group = new Ce(), n._uid = "brushController_" + UJ++, D(jJ, function(i, a) {
        this._handlers[a] = ne(i, this);
      }, n), n;
    }
    return e.prototype.enableBrush = function(t) {
      return this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this;
    }, e.prototype._doEnableBrush = function(t) {
      var n = this._zr;
      this._enableGlobalPan || EZ(n, DI, this._uid), D(this._handlers, function(i, a) {
        n.on(a, i);
      }), this._brushType = t.brushType, this._brushOption = Ee(be(PI), t, true);
    }, e.prototype._doDisableBrush = function() {
      var t = this._zr;
      NZ(t, DI, this._uid), D(this._handlers, function(n, i) {
        t.off(i, n);
      }), this._brushType = this._brushOption = null;
    }, e.prototype.setPanels = function(t) {
      if (t && t.length) {
        var n = this._panels = {};
        D(t, function(i) {
          n[i.panelId] = be(i);
        });
      } else this._panels = null;
      return this;
    }, e.prototype.mount = function(t) {
      t = t || {}, this._enableGlobalPan = t.enableGlobalPan;
      var n = this.group;
      return this._zr.add(n), n.attr({
        x: t.x || 0,
        y: t.y || 0,
        rotation: t.rotation || 0,
        scaleX: t.scaleX || 1,
        scaleY: t.scaleY || 1
      }), this._transform = n.getLocalTransform(), this;
    }, e.prototype.updateCovers = function(t) {
      t = K(t, function(f) {
        return Ee(be(PI), f, true);
      });
      var n = "\0-brush-index-", i = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
      return new ya(i, t, u, l).add(c).update(c).remove(h).execute(), this;
      function l(f, d) {
        return (f.id != null ? f.id : n + d) + "-" + f.brushType;
      }
      function u(f, d) {
        return l(f.__brushOption, d);
      }
      function c(f, d) {
        var p = t[f];
        if (d != null && i[d] === s) a[f] = i[d];
        else {
          var v = a[f] = d != null ? (i[d].__brushOption = p, i[d]) : qO(o, XO(o, p));
          gS(o, v);
        }
      }
      function h(f) {
        i[f] !== s && o.group.remove(i[f]);
      }
    }, e.prototype.unmount = function() {
      return this.enableBrush(false), C_(this), this._zr.remove(this.group), this;
    }, e.prototype.dispose = function() {
      this.unmount(), this.off();
    }, e;
  }(Vn);
  function XO(r, e) {
    var t = Ig[e.brushType].createCover(r, e);
    return t.__brushOption = e, ZO(t, e), r.group.add(t), t;
  }
  function qO(r, e) {
    var t = mS(e);
    return t.endCreating && (t.endCreating(r, e), ZO(e, e.__brushOption)), e;
  }
  function KO(r, e) {
    var t = e.__brushOption;
    mS(e).updateCoverShape(r, e, t.range, t);
  }
  function ZO(r, e) {
    var t = e.z;
    t == null && (t = zJ), r.traverse(function(n) {
      n.z = t, n.z2 = t;
    });
  }
  function gS(r, e) {
    mS(e).updateCommon(r, e), KO(r, e);
  }
  function mS(r) {
    return Ig[r.__brushOption.brushType];
  }
  function yS(r, e, t) {
    var n = r._panels;
    if (!n) return Ws;
    var i, a = r._transform;
    return D(n, function(o) {
      o.isTargetByCursor(e, t, a) && (i = o);
    }), i;
  }
  function jO(r, e) {
    var t = r._panels;
    if (!t) return Ws;
    var n = e.__brushOption.panelId;
    return n != null ? t[n] : Ws;
  }
  function C_(r) {
    var e = r._covers, t = e.length;
    return D(e, function(n) {
      r.group.remove(n);
    }, r), e.length = 0, !!t;
  }
  function Us(r, e) {
    var t = K(r._covers, function(n) {
      var i = n.__brushOption, a = be(i.range);
      return {
        brushType: i.brushType,
        panelId: i.panelId,
        range: a
      };
    });
    r.trigger("brush", {
      areas: t,
      isEnd: !!e.isEnd,
      removeOnClick: !!e.removeOnClick
    });
  }
  function HJ(r) {
    var e = r._track;
    if (!e.length) return false;
    var t = e[e.length - 1], n = e[0], i = t[0] - n[0], a = t[1] - n[1], o = BJ(i * i + a * a, 0.5);
    return o > VJ;
  }
  function QO(r) {
    var e = r.length - 1;
    return e < 0 && (e = 0), [
      r[0],
      r[e]
    ];
  }
  function JO(r, e, t, n) {
    var i = new Ce();
    return i.add(new et({
      name: "main",
      style: xS(t),
      silent: true,
      draggable: true,
      cursor: "move",
      drift: Le(kI, r, e, i, [
        "n",
        "s",
        "w",
        "e"
      ]),
      ondragend: Le(Us, e, {
        isEnd: true
      })
    })), D(n, function(a) {
      i.add(new et({
        name: a.join(""),
        style: {
          opacity: 0
        },
        draggable: true,
        silent: true,
        invisible: true,
        drift: Le(kI, r, e, i, a),
        ondragend: Le(Us, e, {
          isEnd: true
        })
      }));
    }), i;
  }
  function eF(r, e, t, n) {
    var i = n.brushStyle.lineWidth || 0, a = vu(i, $J), o = t[0][0], s = t[1][0], l = o - i / 2, u = s - i / 2, c = t[0][1], h = t[1][1], f = c - a + i / 2, d = h - a + i / 2, p = c - o, v = h - s, g = p + i, m = v + i;
    Ki(r, e, "main", o, s, p, v), n.transformable && (Ki(r, e, "w", l, u, a, m), Ki(r, e, "e", f, u, a, m), Ki(r, e, "n", l, u, g, a), Ki(r, e, "s", l, d, g, a), Ki(r, e, "nw", l, u, a, a), Ki(r, e, "ne", f, u, a, a), Ki(r, e, "sw", l, d, a, a), Ki(r, e, "se", f, d, a, a));
  }
  function T_(r, e) {
    var t = e.__brushOption, n = t.transformable, i = e.childAt(0);
    i.useStyle(xS(t)), i.attr({
      silent: !n,
      cursor: n ? "move" : "default"
    }), D([
      [
        "w"
      ],
      [
        "e"
      ],
      [
        "n"
      ],
      [
        "s"
      ],
      [
        "s",
        "e"
      ],
      [
        "s",
        "w"
      ],
      [
        "n",
        "e"
      ],
      [
        "n",
        "w"
      ]
    ], function(a) {
      var o = e.childOfName(a.join("")), s = a.length === 1 ? A_(r, a[0]) : XJ(r, a);
      o && o.attr({
        silent: !n,
        invisible: !n,
        cursor: n ? WJ[s] + "-resize" : null
      });
    });
  }
  function Ki(r, e, t, n, i, a, o) {
    var s = e.childOfName(t);
    s && s.setShape(KJ(_S(r, e, [
      [
        n,
        i
      ],
      [
        n + a,
        i + o
      ]
    ])));
  }
  function xS(r) {
    return ye({
      strokeNoScale: true
    }, r.brushStyle);
  }
  function tF(r, e, t, n) {
    var i = [
      Uh(r, t),
      Uh(e, n)
    ], a = [
      vu(r, t),
      vu(e, n)
    ];
    return [
      [
        i[0],
        a[0]
      ],
      [
        i[1],
        a[1]
      ]
    ];
  }
  function YJ(r) {
    return ks(r.group);
  }
  function A_(r, e) {
    var t = {
      w: "left",
      e: "right",
      n: "top",
      s: "bottom"
    }, n = {
      left: "w",
      right: "e",
      top: "n",
      bottom: "s"
    }, i = ag(t[e], YJ(r));
    return n[i];
  }
  function XJ(r, e) {
    var t = [
      A_(r, e[0]),
      A_(r, e[1])
    ];
    return (t[0] === "e" || t[0] === "w") && t.reverse(), t.join("");
  }
  function kI(r, e, t, n, i, a) {
    var o = t.__brushOption, s = r.toRectRange(o.range), l = rF(e, i, a);
    D(n, function(u) {
      var c = GJ[u];
      s[c[0]][c[1]] += l[c[0]];
    }), o.range = r.fromRectRange(tF(s[0][0], s[1][0], s[0][1], s[1][1])), gS(e, t), Us(e, {
      isEnd: false
    });
  }
  function qJ(r, e, t, n) {
    var i = e.__brushOption.range, a = rF(r, t, n);
    D(i, function(o) {
      o[0] += a[0], o[1] += a[1];
    }), gS(r, e), Us(r, {
      isEnd: false
    });
  }
  function rF(r, e, t) {
    var n = r.group, i = n.transformCoordToLocal(e, t), a = n.transformCoordToLocal(0, 0);
    return [
      i[0] - a[0],
      i[1] - a[1]
    ];
  }
  function _S(r, e, t) {
    var n = jO(r, e);
    return n && n !== Ws ? n.clipPath(t, r._transform) : be(t);
  }
  function KJ(r) {
    var e = Uh(r[0][0], r[1][0]), t = Uh(r[0][1], r[1][1]), n = vu(r[0][0], r[1][0]), i = vu(r[0][1], r[1][1]);
    return {
      x: e,
      y: t,
      width: n - e,
      height: i - t
    };
  }
  function ZJ(r, e, t) {
    if (!(!r._brushType || QJ(r, e.offsetX, e.offsetY))) {
      var n = r._zr, i = r._covers, a = yS(r, e, t);
      if (!r._dragging) for (var o = 0; o < i.length; o++) {
        var s = i[o].__brushOption;
        if (a && (a === Ws || s.panelId === a.panelId) && Ig[s.brushType].contain(i[o], t[0], t[1])) return;
      }
      a && n.setCursorStyle("crosshair");
    }
  }
  function I_(r) {
    var e = r.event;
    e.preventDefault && e.preventDefault();
  }
  function M_(r, e, t) {
    return r.childOfName("main").contain(e, t);
  }
  function nF(r, e, t, n) {
    var i = r._creatingCover, a = r._creatingPanel, o = r._brushOption, s;
    if (r._track.push(t.slice()), HJ(r) || i) {
      if (a && !i) {
        o.brushMode === "single" && C_(r);
        var l = be(o);
        l.brushType = LI(l.brushType, a), l.panelId = a === Ws ? null : a.panelId, i = r._creatingCover = XO(r, l), r._covers.push(i);
      }
      if (i) {
        var u = Ig[LI(r._brushType, a)], c = i.__brushOption;
        c.range = u.getCreatingRange(_S(r, i, r._track)), n && (qO(r, i), u.updateCommon(r, i)), KO(r, i), s = {
          isEnd: n
        };
      }
    } else n && o.brushMode === "single" && o.removeOnClick && yS(r, e, t) && C_(r) && (s = {
      isEnd: n,
      removeOnClick: true
    });
    return s;
  }
  function LI(r, e) {
    return r === "auto" ? e.defaultBrushType : r;
  }
  var jJ = {
    mousedown: function(r) {
      if (this._dragging) RI(this, r);
      else if (!r.target || !r.target.draggable) {
        I_(r);
        var e = this.group.transformCoordToLocal(r.offsetX, r.offsetY);
        this._creatingCover = null;
        var t = this._creatingPanel = yS(this, r, e);
        t && (this._dragging = true, this._track = [
          e.slice()
        ]);
      }
    },
    mousemove: function(r) {
      var e = r.offsetX, t = r.offsetY, n = this.group.transformCoordToLocal(e, t);
      if (ZJ(this, r, n), this._dragging) {
        I_(r);
        var i = nF(this, r, n, false);
        i && Us(this, i);
      }
    },
    mouseup: function(r) {
      RI(this, r);
    }
  };
  function RI(r, e) {
    if (r._dragging) {
      I_(e);
      var t = e.offsetX, n = e.offsetY, i = r.group.transformCoordToLocal(t, n), a = nF(r, e, i, true);
      r._dragging = false, r._track = [], r._creatingCover = null, a && Us(r, a);
    }
  }
  function QJ(r, e, t) {
    var n = r._zr;
    return e < 0 || e > n.getWidth() || t < 0 || t > n.getHeight();
  }
  var Ig = {
    lineX: EI(0),
    lineY: EI(1),
    rect: {
      createCover: function(r, e) {
        function t(n) {
          return n;
        }
        return JO({
          toRectRange: t,
          fromRectRange: t
        }, r, e, [
          [
            "w"
          ],
          [
            "e"
          ],
          [
            "n"
          ],
          [
            "s"
          ],
          [
            "s",
            "e"
          ],
          [
            "s",
            "w"
          ],
          [
            "n",
            "e"
          ],
          [
            "n",
            "w"
          ]
        ]);
      },
      getCreatingRange: function(r) {
        var e = QO(r);
        return tF(e[1][0], e[1][1], e[0][0], e[0][1]);
      },
      updateCoverShape: function(r, e, t, n) {
        eF(r, e, t, n);
      },
      updateCommon: T_,
      contain: M_
    },
    polygon: {
      createCover: function(r, e) {
        var t = new Ce();
        return t.add(new Zr({
          name: "main",
          style: xS(e),
          silent: true
        })), t;
      },
      getCreatingRange: function(r) {
        return r;
      },
      endCreating: function(r, e) {
        e.remove(e.childAt(0)), e.add(new Kr({
          name: "main",
          draggable: true,
          drift: Le(qJ, r, e),
          ondragend: Le(Us, r, {
            isEnd: true
          })
        }));
      },
      updateCoverShape: function(r, e, t, n) {
        e.childAt(0).setShape({
          points: _S(r, e, t)
        });
      },
      updateCommon: T_,
      contain: M_
    }
  };
  function EI(r) {
    return {
      createCover: function(e, t) {
        return JO({
          toRectRange: function(n) {
            var i = [
              n,
              [
                0,
                100
              ]
            ];
            return r && i.reverse(), i;
          },
          fromRectRange: function(n) {
            return n[r];
          }
        }, e, t, [
          [
            [
              "w"
            ],
            [
              "e"
            ]
          ],
          [
            [
              "n"
            ],
            [
              "s"
            ]
          ]
        ][r]);
      },
      getCreatingRange: function(e) {
        var t = QO(e), n = Uh(t[0][r], t[1][r]), i = vu(t[0][r], t[1][r]);
        return [
          n,
          i
        ];
      },
      updateCoverShape: function(e, t, n, i) {
        var a, o = jO(e, t);
        if (o !== Ws && o.getLinearBrushOtherExtent) a = o.getLinearBrushOtherExtent(r);
        else {
          var s = e._zr;
          a = [
            0,
            [
              s.getWidth(),
              s.getHeight()
            ][1 - r]
          ];
        }
        var l = [
          n,
          a
        ];
        r && l.reverse(), eF(e, t, l, i);
      },
      updateCommon: T_,
      contain: M_
    };
  }
  function iF(r) {
    return r = bS(r), function(e) {
      return pE(e, r);
    };
  }
  function aF(r, e) {
    return r = bS(r), function(t) {
      var n = e ?? t, i = n ? r.width : r.height, a = n ? r.x : r.y;
      return [
        a,
        a + (i || 0)
      ];
    };
  }
  function oF(r, e, t) {
    var n = bS(r);
    return function(i, a) {
      return n.contain(a[0], a[1]) && !wg(i, e, t);
    };
  }
  function bS(r) {
    return Oe.create(r);
  }
  var JJ = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], eee = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n) {
      r.prototype.init.apply(this, arguments), (this._brushController = new vS(n.getZr())).on("brush", ne(this._onBrush, this));
    }, e.prototype.render = function(t, n, i, a) {
      if (!tee(t, n, a)) {
        this.axisModel = t, this.api = i, this.group.removeAll();
        var o = this._axisGroup;
        if (this._axisGroup = new Ce(), this.group.add(this._axisGroup), !!t.get("show")) {
          var s = nee(t, n), l = s.coordinateSystem, u = t.getAreaSelectStyle(), c = u.width, h = t.axis.dim, f = l.getAxisLayout(h), d = H({
            strokeContainThreshold: c
          }, f), p = new Ur(t, d);
          D(JJ, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(d, u, t, s, c, i), _f(o, this._axisGroup, t);
        }
      }
    }, e.prototype._refreshBrushController = function(t, n, i, a, o, s) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), h = Oe.create({
        x: l[0],
        y: -o / 2,
        width: u,
        height: o
      });
      h.x -= c, h.width += 2 * c, this._brushController.mount({
        enableGlobalPan: true,
        rotation: t.rotation,
        x: t.position[0],
        y: t.position[1]
      }).setPanels([
        {
          panelId: "pl",
          clipPath: iF(h),
          isTargetByCursor: oF(h, s, a),
          getLinearBrushOtherExtent: aF(h, 0)
        }
      ]).enableBrush({
        brushType: "lineX",
        brushStyle: n,
        removeOnClick: true
      }).updateCovers(ree(i));
    }, e.prototype._onBrush = function(t) {
      var n = t.areas, i = this.axisModel, a = i.axis, o = K(n, function(s) {
        return [
          a.coordToData(s.range[0], true),
          a.coordToData(s.range[1], true)
        ];
      });
      (!i.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: o
      });
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.type = "parallelAxis", e;
  }(Rt);
  function tee(r, e, t) {
    return t && t.type === "axisAreaSelect" && e.findComponents({
      mainType: "parallelAxis",
      query: t
    })[0] === r;
  }
  function ree(r) {
    var e = r.axis;
    return K(r.activeIntervals, function(t) {
      return {
        brushType: "lineX",
        panelId: "pl",
        range: [
          e.dataToCoord(t[0], true),
          e.dataToCoord(t[1], true)
        ]
      };
    });
  }
  function nee(r, e) {
    return e.getComponent("parallel", r.get("parallelIndex"));
  }
  var iee = {
    type: "axisAreaSelect",
    event: "axisAreaSelected"
  };
  function aee(r) {
    r.registerAction(iee, function(e, t) {
      t.eachComponent({
        mainType: "parallelAxis",
        query: e
      }, function(n) {
        n.axis.model.setActiveIntervals(e.intervals);
      });
    }), r.registerAction("parallelAxisExpand", function(e, t) {
      t.eachComponent({
        mainType: "parallel",
        query: e
      }, function(n) {
        n.setAxisExpand(e);
      });
    });
  }
  var oee = {
    type: "value",
    areaSelectStyle: {
      width: 20,
      borderWidth: 1,
      borderColor: "rgba(160,197,232)",
      color: "rgba(160,197,232)",
      opacity: 0.3
    },
    realtime: true,
    z: 10
  };
  function sF(r) {
    r.registerComponentView(IJ), r.registerComponentModel(DJ), r.registerCoordinateSystem("parallel", FJ), r.registerPreprocessor(wJ), r.registerComponentModel(w_), r.registerComponentView(eee), pu(r, "parallel", w_, oee), aee(r);
  }
  function see(r) {
    Ve(sF), r.registerChartView(vJ), r.registerSeriesModel(yJ), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, SJ);
  }
  var lee = /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return r;
  }(), uee = function(r) {
    G(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new lee();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.extent;
      t.moveTo(n.x1, n.y1), t.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (t.lineTo(n.x2 + i, n.y2), t.bezierCurveTo(n.cpx2 + i, n.cpy2, n.cpx1 + i, n.cpy1, n.x1 + i, n.y1)) : (t.lineTo(n.x2, n.y2 + i), t.bezierCurveTo(n.cpx2, n.cpy2 + i, n.cpx1, n.cpy1 + i, n.x1, n.y1 + i)), t.closePath();
    }, e.prototype.highlight = function() {
      ga(this);
    }, e.prototype.downplay = function() {
      ma(this);
    }, e;
  }(Ue), cee = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._focusAdjacencyDisabled = false, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = this, o = t.getGraph(), s = this.group, l = t.layoutInfo, u = l.width, c = l.height, h = t.getData(), f = t.getData("edge"), d = t.get("orient");
      this._model = t, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function(p) {
        var v = new uee(), g = De(v);
        g.dataIndex = p.dataIndex, g.seriesIndex = t.seriesIndex, g.dataType = "edge";
        var m = p.getModel(), y = m.getModel("lineStyle"), x = y.get("curveness"), _ = p.node1.getLayout(), S = p.node1.getModel(), b = S.get("localX"), w = S.get("localY"), C = p.node2.getLayout(), T = p.node2.getModel(), A = T.get("localX"), M = T.get("localY"), E = p.getLayout(), k, R, N, I, L, P, O, F;
        v.shape.extent = Math.max(1, E.dy), v.shape.orient = d, d === "vertical" ? (k = (b != null ? b * u : _.x) + E.sy, R = (w != null ? w * c : _.y) + _.dy, N = (A != null ? A * u : C.x) + E.ty, I = M != null ? M * c : C.y, L = k, P = R * (1 - x) + I * x, O = N, F = R * x + I * (1 - x)) : (k = (b != null ? b * u : _.x) + _.dx, R = (w != null ? w * c : _.y) + E.sy, N = A != null ? A * u : C.x, I = (M != null ? M * c : C.y) + E.ty, L = k * (1 - x) + N * x, P = R, O = k * x + N * (1 - x), F = I), v.setShape({
          x1: k,
          y1: R,
          x2: N,
          y2: I,
          cpx1: L,
          cpy1: P,
          cpx2: O,
          cpy2: F
        }), v.useStyle(y.getItemStyle()), NI(v.style, d, p);
        var B = "" + m.get("value"), V = lr(m, "edgeLabel");
        Sr(v, V, {
          labelFetcher: {
            getFormattedLabel: function(q, me, Me, re, J, le) {
              return t.getFormattedLabel(q, me, "edge", re, Li(J, V.normal && V.normal.get("formatter"), B), le);
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: B
        }), v.setTextConfig({
          position: "inside"
        });
        var U = m.getModel("emphasis");
        br(v, m, "lineStyle", function(q) {
          var me = q.getItemStyle();
          return NI(me, d, p), me;
        }), s.add(v), f.setItemGraphicEl(p.dataIndex, v);
        var Y = U.get("focus");
        Nt(v, Y === "adjacency" ? p.getAdjacentDataIndices() : Y === "trajectory" ? p.getTrajectoryDataIndices() : Y, U.get("blurScope"), U.get("disabled"));
      }), o.eachNode(function(p) {
        var v = p.getLayout(), g = p.getModel(), m = g.get("localX"), y = g.get("localY"), x = g.getModel("emphasis"), _ = g.get([
          "itemStyle",
          "borderRadius"
        ]) || 0, S = new et({
          shape: {
            x: m != null ? m * u : v.x,
            y: y != null ? y * c : v.y,
            width: v.dx,
            height: v.dy,
            r: _
          },
          style: g.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Sr(S, lr(g), {
          labelFetcher: {
            getFormattedLabel: function(w, C) {
              return t.getFormattedLabel(w, C, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), S.disableLabelAnimation = true, S.setStyle("fill", p.getVisual("color")), S.setStyle("decal", p.getVisual("style").decal), br(S, g), s.add(S), h.setItemGraphicEl(p.dataIndex, S), De(S).dataType = "node";
        var b = x.get("focus");
        Nt(S, b === "adjacency" ? p.getAdjacentDataIndices() : b === "trajectory" ? p.getTrajectoryDataIndices() : b, x.get("blurScope"), x.get("disabled"));
      }), h.eachItemGraphicEl(function(p, v) {
        var g = h.getItemModel(v);
        g.get("draggable") && (p.drift = function(m, y) {
          a._focusAdjacencyDisabled = true, this.shape.x += m, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: t.id,
            dataIndex: h.getRawIndex(v),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          a._focusAdjacencyDisabled = false;
        }, p.draggable = true, p.cursor = "move");
      }), !this._data && t.isAnimationEnabled() && s.setClipPath(hee(s.getBoundingRect(), t, function() {
        s.removeClipPath();
      })), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.type = "sankey", e;
  }(yt);
  function NI(r, e, t) {
    switch (r.fill) {
      case "source":
        r.fill = t.node1.getVisual("color"), r.decal = t.node1.getVisual("style").decal;
        break;
      case "target":
        r.fill = t.node2.getVisual("color"), r.decal = t.node2.getVisual("style").decal;
        break;
      case "gradient":
        var n = t.node1.getVisual("color"), i = t.node2.getVisual("color");
        ee(n) && ee(i) && (r.fill = new xf(0, 0, +(e === "horizontal"), +(e === "vertical"), [
          {
            color: n,
            offset: 0
          },
          {
            color: i,
            offset: 1
          }
        ]));
    }
  }
  function hee(r, e, t) {
    var n = new et({
      shape: {
        x: r.x - 10,
        y: r.y - 10,
        width: 0,
        height: r.height + 20
      }
    });
    return kt(n, {
      shape: {
        width: r.width + 20
      }
    }, e, t), n;
  }
  var fee = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      var i = t.edges || t.links || [], a = t.data || t.nodes || [], o = t.levels || [];
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++) o[l].depth != null && o[l].depth >= 0 && (s[o[l].depth] = new ft(o[l], this, n));
      var u = WO(a, i, this, true, c);
      return u.data;
      function c(h, f) {
        h.wrapMethod("getItemModel", function(d, p) {
          var v = d.parentModel, g = v.getData().getItemLayout(p);
          if (g) {
            var m = g.depth, y = v.levelModels[m];
            y && (d.parentModel = y);
          }
          return d;
        }), f.wrapMethod("getItemModel", function(d, p) {
          var v = d.parentModel, g = v.getGraph().getEdgeByIndex(p), m = g.node1.getLayout();
          if (m) {
            var y = m.depth, x = v.levelModels[y];
            x && (d.parentModel = x);
          }
          return d;
        });
      }
    }, e.prototype.setNodePosition = function(t, n) {
      var i = this.option.data || this.option.nodes, a = i[t];
      a.localX = n[0], a.localY = n[1];
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.formatTooltip = function(t, n, i) {
      function a(d) {
        return isNaN(d) || d == null;
      }
      if (i === "edge") {
        var o = this.getDataParams(t, i), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return ur("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(t), h = c.getLayout().value, f = this.getDataParams(t, i).data.name;
        return ur("nameValue", {
          name: f != null ? f + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, e.prototype.optionUpdated = function() {
    }, e.prototype.getDataParams = function(t, n) {
      var i = r.prototype.getDataParams.call(this, t, n);
      if (i.value == null && n === "node") {
        var a = this.getGraph().getNodeByIndex(t), o = a.getLayout().value;
        i.value = o;
      }
      return i;
    }, e.type = "series.sankey", e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: true,
      layoutIterations: 32,
      label: {
        show: true,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: false,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, e;
  }(Tt);
  function dee(r, e) {
    r.eachSeriesByType("sankey", function(t) {
      var n = t.get("nodeWidth"), i = t.get("nodeGap"), a = pee(t, e);
      t.layoutInfo = a;
      var o = a.width, s = a.height, l = t.getGraph(), u = l.nodes, c = l.edges;
      gee(u);
      var h = ct(u, function(v) {
        return v.getLayout().value === 0;
      }), f = h.length !== 0 ? 0 : t.get("layoutIterations"), d = t.get("orient"), p = t.get("nodeAlign");
      vee(u, c, n, i, o, s, f, d, p);
    });
  }
  function pee(r, e) {
    return er(r.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function vee(r, e, t, n, i, a, o, s, l) {
    mee(r, e, t, i, a, s, l), bee(r, e, a, i, n, o, s), Pee(r, s);
  }
  function gee(r) {
    D(r, function(e) {
      var t = io(e.outEdges, vv), n = io(e.inEdges, vv), i = e.getValue() || 0, a = Math.max(t, n, i);
      e.setLayout({
        value: a
      }, true);
    });
  }
  function mee(r, e, t, n, i, a, o) {
    for (var s = [], l = [], u = [], c = [], h = 0, f = 0; f < e.length; f++) s[f] = 1;
    for (var f = 0; f < r.length; f++) l[f] = r[f].inEdges.length, l[f] === 0 && u.push(r[f]);
    for (var d = -1; u.length; ) {
      for (var p = 0; p < u.length; p++) {
        var v = u[p], g = v.hostGraph.data.getRawDataItem(v.dataIndex), m = g.depth != null && g.depth >= 0;
        m && g.depth > d && (d = g.depth), v.setLayout({
          depth: m ? g.depth : h
        }, true), a === "vertical" ? v.setLayout({
          dy: t
        }, true) : v.setLayout({
          dx: t
        }, true);
        for (var y = 0; y < v.outEdges.length; y++) {
          var x = v.outEdges[y], _ = e.indexOf(x);
          s[_] = 0;
          var S = x.node2, b = r.indexOf(S);
          --l[b] === 0 && c.indexOf(S) < 0 && c.push(S);
        }
      }
      ++h, u = c, c = [];
    }
    for (var f = 0; f < s.length; f++) if (s[f] === 1) throw new Error("Sankey is a DAG, the original data has cycle!");
    var w = d > h - 1 ? d : h - 1;
    o && o !== "left" && yee(r, o, a, w);
    var C = a === "vertical" ? (i - t) / w : (n - t) / w;
    _ee(r, C, a);
  }
  function lF(r) {
    var e = r.hostGraph.data.getRawDataItem(r.dataIndex);
    return e.depth != null && e.depth >= 0;
  }
  function yee(r, e, t, n) {
    if (e === "right") {
      for (var i = [], a = r, o = 0; a.length; ) {
        for (var s = 0; s < a.length; s++) {
          var l = a[s];
          l.setLayout({
            skNodeHeight: o
          }, true);
          for (var u = 0; u < l.inEdges.length; u++) {
            var c = l.inEdges[u];
            i.indexOf(c.node1) < 0 && i.push(c.node1);
          }
        }
        a = i, i = [], ++o;
      }
      D(r, function(h) {
        lF(h) || h.setLayout({
          depth: Math.max(0, n - h.getLayout().skNodeHeight)
        }, true);
      });
    } else e === "justify" && xee(r, n);
  }
  function xee(r, e) {
    D(r, function(t) {
      !lF(t) && !t.outEdges.length && t.setLayout({
        depth: e
      }, true);
    });
  }
  function _ee(r, e, t) {
    D(r, function(n) {
      var i = n.getLayout().depth * e;
      t === "vertical" ? n.setLayout({
        y: i
      }, true) : n.setLayout({
        x: i
      }, true);
    });
  }
  function bee(r, e, t, n, i, a, o) {
    var s = See(r, o);
    wee(s, e, t, n, i, o), By(s, i, t, n, o);
    for (var l = 1; a > 0; a--) l *= 0.99, Cee(s, l, o), By(s, i, t, n, o), Dee(s, l, o), By(s, i, t, n, o);
  }
  function See(r, e) {
    var t = [], n = e === "vertical" ? "y" : "x", i = Dx(r, function(a) {
      return a.getLayout()[n];
    });
    return i.keys.sort(function(a, o) {
      return a - o;
    }), D(i.keys, function(a) {
      t.push(i.buckets.get(a));
    }), t;
  }
  function wee(r, e, t, n, i, a) {
    var o = 1 / 0;
    D(r, function(s) {
      var l = s.length, u = 0;
      D(s, function(h) {
        u += h.getLayout().value;
      });
      var c = a === "vertical" ? (n - (l - 1) * i) / u : (t - (l - 1) * i) / u;
      c < o && (o = c);
    }), D(r, function(s) {
      D(s, function(l, u) {
        var c = l.getLayout().value * o;
        a === "vertical" ? (l.setLayout({
          x: u
        }, true), l.setLayout({
          dx: c
        }, true)) : (l.setLayout({
          y: u
        }, true), l.setLayout({
          dy: c
        }, true));
      });
    }), D(e, function(s) {
      var l = +s.getValue() * o;
      s.setLayout({
        dy: l
      }, true);
    });
  }
  function By(r, e, t, n, i) {
    var a = i === "vertical" ? "x" : "y";
    D(r, function(o) {
      o.sort(function(v, g) {
        return v.getLayout()[a] - g.getLayout()[a];
      });
      for (var s, l, u, c = 0, h = o.length, f = i === "vertical" ? "dx" : "dy", d = 0; d < h; d++) l = o[d], u = c - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, i === "vertical" ? l.setLayout({
        x: s
      }, true) : l.setLayout({
        y: s
      }, true)), c = l.getLayout()[a] + l.getLayout()[f] + e;
      var p = i === "vertical" ? n : t;
      if (u = c - e - p, u > 0) {
        s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: s
        }, true) : l.setLayout({
          y: s
        }, true), c = s;
        for (var d = h - 2; d >= 0; --d) l = o[d], u = l.getLayout()[a] + l.getLayout()[f] + e - c, u > 0 && (s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: s
        }, true) : l.setLayout({
          y: s
        }, true)), c = l.getLayout()[a];
      }
    });
  }
  function Cee(r, e, t) {
    D(r.slice().reverse(), function(n) {
      D(n, function(i) {
        if (i.outEdges.length) {
          var a = io(i.outEdges, Tee, t) / io(i.outEdges, vv);
          if (isNaN(a)) {
            var o = i.outEdges.length;
            a = o ? io(i.outEdges, Aee, t) / o : 0;
          }
          if (t === "vertical") {
            var s = i.getLayout().x + (a - fo(i, t)) * e;
            i.setLayout({
              x: s
            }, true);
          } else {
            var l = i.getLayout().y + (a - fo(i, t)) * e;
            i.setLayout({
              y: l
            }, true);
          }
        }
      });
    });
  }
  function Tee(r, e) {
    return fo(r.node2, e) * r.getValue();
  }
  function Aee(r, e) {
    return fo(r.node2, e);
  }
  function Iee(r, e) {
    return fo(r.node1, e) * r.getValue();
  }
  function Mee(r, e) {
    return fo(r.node1, e);
  }
  function fo(r, e) {
    return e === "vertical" ? r.getLayout().x + r.getLayout().dx / 2 : r.getLayout().y + r.getLayout().dy / 2;
  }
  function vv(r) {
    return r.getValue();
  }
  function io(r, e, t) {
    for (var n = 0, i = r.length, a = -1; ++a < i; ) {
      var o = +e(r[a], t);
      isNaN(o) || (n += o);
    }
    return n;
  }
  function Dee(r, e, t) {
    D(r, function(n) {
      D(n, function(i) {
        if (i.inEdges.length) {
          var a = io(i.inEdges, Iee, t) / io(i.inEdges, vv);
          if (isNaN(a)) {
            var o = i.inEdges.length;
            a = o ? io(i.inEdges, Mee, t) / o : 0;
          }
          if (t === "vertical") {
            var s = i.getLayout().x + (a - fo(i, t)) * e;
            i.setLayout({
              x: s
            }, true);
          } else {
            var l = i.getLayout().y + (a - fo(i, t)) * e;
            i.setLayout({
              y: l
            }, true);
          }
        }
      });
    });
  }
  function Pee(r, e) {
    var t = e === "vertical" ? "x" : "y";
    D(r, function(n) {
      n.outEdges.sort(function(i, a) {
        return i.node2.getLayout()[t] - a.node2.getLayout()[t];
      }), n.inEdges.sort(function(i, a) {
        return i.node1.getLayout()[t] - a.node1.getLayout()[t];
      });
    }), D(r, function(n) {
      var i = 0, a = 0;
      D(n.outEdges, function(o) {
        o.setLayout({
          sy: i
        }, true), i += o.getLayout().dy;
      }), D(n.inEdges, function(o) {
        o.setLayout({
          ty: a
        }, true), a += o.getLayout().dy;
      });
    });
  }
  function kee(r) {
    r.eachSeriesByType("sankey", function(e) {
      var t = e.getGraph(), n = t.nodes, i = t.edges;
      if (n.length) {
        var a = 1 / 0, o = -1 / 0;
        D(n, function(s) {
          var l = s.getLayout().value;
          l < a && (a = l), l > o && (o = l);
        }), D(n, function(s) {
          var l = new or({
            type: "color",
            mappingMethod: "linear",
            dataExtent: [
              a,
              o
            ],
            visual: e.get("color")
          }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get([
            "itemStyle",
            "color"
          ]);
          c != null ? (s.setVisual("color", c), s.setVisual("style", {
            fill: c
          })) : (s.setVisual("color", u), s.setVisual("style", {
            fill: u
          }));
        });
      }
      i.length && D(i, function(s) {
        var l = s.getModel().get("lineStyle");
        s.setVisual("style", l);
      });
    });
  }
  function Lee(r) {
    r.registerChartView(cee), r.registerSeriesModel(fee), r.registerLayout(dee), r.registerVisual(kee), r.registerAction({
      type: "dragNode",
      event: "dragnode",
      update: "update"
    }, function(e, t) {
      t.eachComponent({
        mainType: "series",
        subType: "sankey",
        query: e
      }, function(n) {
        n.setNodePosition(e.dataIndex, [
          e.localX,
          e.localY
        ]);
      });
    });
  }
  var uF = function() {
    function r() {
    }
    return r.prototype._hasEncodeRule = function(e) {
      var t = this.getEncode();
      return t && t.get(e) != null;
    }, r.prototype.getInitialData = function(e, t) {
      var n, i = t.getComponent("xAxis", this.get("xAxisIndex")), a = t.getComponent("yAxis", this.get("yAxisIndex")), o = i.get("type"), s = a.get("type"), l;
      o === "category" ? (e.layout = "horizontal", n = i.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : s === "category" ? (e.layout = "vertical", n = a.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : e.layout = e.layout || "horizontal";
      var u = [
        "x",
        "y"
      ], c = e.layout === "horizontal" ? 0 : 1, h = this._baseAxisDim = u[c], f = u[1 - c], d = [
        i,
        a
      ], p = d[c].get("type"), v = d[1 - c].get("type"), g = e.data;
      if (g && l) {
        var m = [];
        D(g, function(_, S) {
          var b;
          X(_) ? (b = _.slice(), _.unshift(S)) : X(_.value) ? (b = H({}, _), b.value = b.value.slice(), _.value.unshift(S)) : b = _, m.push(b);
        }), e.data = m;
      }
      var y = this.defaultValueDimensions, x = [
        {
          name: h,
          type: iv(p),
          ordinalMeta: n,
          otherDims: {
            tooltip: false,
            itemName: 0
          },
          dimsDef: [
            "base"
          ]
        },
        {
          name: f,
          type: iv(v),
          dimsDef: y.slice()
        }
      ];
      return Wu(this, {
        coordDimensions: x,
        dimensionsCount: y.length + 1,
        encodeDefaulter: Le(VE, x, this)
      });
    }, r.prototype.getBaseAxis = function() {
      var e = this._baseAxisDim;
      return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis;
    }, r;
  }(), cF = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [
        {
          name: "min",
          defaultTooltip: true
        },
        {
          name: "Q1",
          defaultTooltip: true
        },
        {
          name: "median",
          defaultTooltip: true
        },
        {
          name: "Q3",
          defaultTooltip: true
        },
        {
          name: "max",
          defaultTooltip: true
        }
      ], t.visualDrawType = "stroke", t;
    }
    return e.type = "series.boxplot", e.dependencies = [
      "xAxis",
      "yAxis",
      "grid"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      boxWidth: [
        7,
        50
      ],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: true,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, e;
  }(Tt);
  qt(cF, uF, true);
  var Ree = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = this.group, s = this._data;
      this._data || o.removeAll();
      var l = t.get("layout") === "horizontal" ? 1 : 0;
      a.diff(s).add(function(u) {
        if (a.hasValue(u)) {
          var c = a.getItemLayout(u), h = OI(c, a, u, l, true);
          a.setItemGraphicEl(u, h), o.add(h);
        }
      }).update(function(u, c) {
        var h = s.getItemGraphicEl(c);
        if (!a.hasValue(u)) {
          o.remove(h);
          return;
        }
        var f = a.getItemLayout(u);
        h ? (li(h), hF(f, h, a, u)) : h = OI(f, a, u, l), o.add(h), a.setItemGraphicEl(u, h);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && o.remove(c);
      }).execute(), this._data = a;
    }, e.prototype.remove = function(t) {
      var n = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(a) {
        a && n.remove(a);
      });
    }, e.type = "boxplot", e;
  }(yt), Eee = /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }(), Nee = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "boxplotBoxPath", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new Eee();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.points, a = 0;
      for (t.moveTo(i[a][0], i[a][1]), a++; a < 4; a++) t.lineTo(i[a][0], i[a][1]);
      for (t.closePath(); a < i.length; a++) t.moveTo(i[a][0], i[a][1]), a++, t.lineTo(i[a][0], i[a][1]);
    }, e;
  }(Ue);
  function OI(r, e, t, n, i) {
    var a = r.ends, o = new Nee({
      shape: {
        points: i ? Oee(a, n, r) : a
      }
    });
    return hF(r, o, e, t, i), o;
  }
  function hF(r, e, t, n, i) {
    var a = t.hostModel, o = Zs[i ? "initProps" : "updateProps"];
    o(e, {
      shape: {
        points: r.ends
      }
    }, a, n), e.useStyle(t.getItemVisual(n, "style")), e.style.strokeNoScale = true, e.z2 = 100;
    var s = t.getItemModel(n), l = s.getModel("emphasis");
    br(e, s), Nt(e, l.get("focus"), l.get("blurScope"), l.get("disabled"));
  }
  function Oee(r, e, t) {
    return K(r, function(n) {
      return n = n.slice(), n[e] = t.initBaseline, n;
    });
  }
  var sh = D;
  function Fee(r) {
    var e = Bee(r);
    sh(e, function(t) {
      var n = t.seriesModels;
      n.length && (zee(t), sh(n, function(i, a) {
        Vee(i, t.boxOffsetList[a], t.boxWidthList[a]);
      }));
    });
  }
  function Bee(r) {
    var e = [], t = [];
    return r.eachSeriesByType("boxplot", function(n) {
      var i = n.getBaseAxis(), a = Be(t, i);
      a < 0 && (a = t.length, t[a] = i, e[a] = {
        axis: i,
        seriesModels: []
      }), e[a].seriesModels.push(n);
    }), e;
  }
  function zee(r) {
    var e = r.axis, t = r.seriesModels, n = t.length, i = r.boxWidthList = [], a = r.boxOffsetList = [], o = [], s;
    if (e.type === "category") s = e.getBandWidth();
    else {
      var l = 0;
      sh(t, function(p) {
        l = Math.max(l, p.getData().count());
      });
      var u = e.getExtent();
      s = Math.abs(u[1] - u[0]) / l;
    }
    sh(t, function(p) {
      var v = p.get("boxWidth");
      X(v) || (v = [
        v,
        v
      ]), o.push([
        Q(v[0], s) || 0,
        Q(v[1], s) || 0
      ]);
    });
    var c = s * 0.8 - 2, h = c / n * 0.3, f = (c - h * (n - 1)) / n, d = f / 2 - c / 2;
    sh(t, function(p, v) {
      a.push(d), d += h + f, i.push(Math.min(Math.max(f, o[v][0]), o[v][1]));
    });
  }
  function Vee(r, e, t) {
    var n = r.coordinateSystem, i = r.getData(), a = t / 2, o = r.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = [
      "x",
      "y"
    ], u = i.mapDimension(l[o]), c = i.mapDimensionsAll(l[s]);
    if (u == null || c.length < 5) return;
    for (var h = 0; h < i.count(); h++) {
      var f = i.get(u, h), d = x(f, c[2], h), p = x(f, c[0], h), v = x(f, c[1], h), g = x(f, c[3], h), m = x(f, c[4], h), y = [];
      _(y, v, false), _(y, g, true), y.push(p, v, m, g), S(y, p), S(y, m), S(y, d), i.setItemLayout(h, {
        initBaseline: d[s],
        ends: y
      });
    }
    function x(b, w, C) {
      var T = i.get(w, C), A = [];
      A[o] = b, A[s] = T;
      var M;
      return isNaN(b) || isNaN(T) ? M = [
        NaN,
        NaN
      ] : (M = n.dataToPoint(A), M[o] += e), M;
    }
    function _(b, w, C) {
      var T = w.slice(), A = w.slice();
      T[o] += a, A[o] -= a, C ? b.push(T, A) : b.push(A, T);
    }
    function S(b, w) {
      var C = w.slice(), T = w.slice();
      C[o] -= a, T[o] += a, b.push(C, T);
    }
  }
  function $ee(r, e) {
    e = e || {};
    for (var t = [], n = [], i = e.boundIQR, a = i === "none" || i === 0, o = 0; o < r.length; o++) {
      var s = On(r[o].slice()), l = dm(s, 0.25), u = dm(s, 0.5), c = dm(s, 0.75), h = s[0], f = s[s.length - 1], d = (i ?? 1.5) * (c - l), p = a ? h : Math.max(h, l - d), v = a ? f : Math.min(f, c + d), g = e.itemNameFormatter, m = ge(g) ? g({
        value: o
      }) : ee(g) ? g.replace("{value}", o + "") : o + "";
      t.push([
        m,
        p,
        l,
        u,
        c,
        v
      ]);
      for (var y = 0; y < s.length; y++) {
        var x = s[y];
        if (x < p || x > v) {
          var _ = [
            m,
            x
          ];
          n.push(_);
        }
      }
    }
    return {
      boxData: t,
      outliers: n
    };
  }
  var Gee = {
    type: "echarts:boxplot",
    transform: function(e) {
      var t = e.upstream;
      if (t.sourceFormat !== Rr) {
        var n = "";
        ut(n);
      }
      var i = $ee(t.getRawData(), e.config);
      return [
        {
          dimensions: [
            "ItemName",
            "Low",
            "Q1",
            "Q2",
            "Q3",
            "High"
          ],
          data: i.boxData
        },
        {
          data: i.outliers
        }
      ];
    }
  };
  function Wee(r) {
    r.registerSeriesModel(cF), r.registerChartView(Ree), r.registerLayout(Fee), r.registerTransform(Gee);
  }
  var Uee = [
    "itemStyle",
    "borderColor"
  ], Hee = [
    "itemStyle",
    "borderColor0"
  ], Yee = [
    "itemStyle",
    "borderColorDoji"
  ], Xee = [
    "itemStyle",
    "color"
  ], qee = [
    "itemStyle",
    "color0"
  ];
  function SS(r, e) {
    return e.get(r > 0 ? Xee : qee);
  }
  function wS(r, e) {
    return e.get(r === 0 ? Yee : r > 0 ? Uee : Hee);
  }
  var Kee = {
    seriesType: "candlestick",
    plan: zu(),
    performRawSeries: true,
    reset: function(r, e) {
      if (!e.isSeriesFiltered(r)) {
        var t = r.pipelineContext.large;
        return !t && {
          progress: function(n, i) {
            for (var a; (a = n.next()) != null; ) {
              var o = i.getItemModel(a), s = i.getItemLayout(a).sign, l = o.getItemStyle();
              l.fill = SS(s, o), l.stroke = wS(s, o) || l.fill;
              var u = i.ensureUniqueItemVisual(a, "style");
              H(u, l);
            }
          }
        };
      }
    }
  }, Zee = [
    "color",
    "borderColor"
  ], jee = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t);
    }, e.prototype.incrementalPrepareRender = function(t, n, i) {
      this._clear(), this._updateDrawMode(t);
    }, e.prototype.incrementalRender = function(t, n, i, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, n) : this._incrementalRenderNormal(t, n);
    }, e.prototype.eachRendered = function(t) {
      mo(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var n = t.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, e.prototype._renderNormal = function(t) {
      var n = t.getData(), i = this._data, a = this.group, o = n.getLayout("isSimpleBox"), s = t.get("clip", true), l = t.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), n.diff(i).add(function(c) {
        if (n.hasValue(c)) {
          var h = n.getItemLayout(c);
          if (s && FI(u, h)) return;
          var f = zy(h, c, true);
          kt(f, {
            shape: {
              points: h.ends
            }
          }, t, c), Vy(f, n, c, o), a.add(f), n.setItemGraphicEl(c, f);
        }
      }).update(function(c, h) {
        var f = i.getItemGraphicEl(h);
        if (!n.hasValue(c)) {
          a.remove(f);
          return;
        }
        var d = n.getItemLayout(c);
        if (s && FI(u, d)) {
          a.remove(f);
          return;
        }
        f ? (it(f, {
          shape: {
            points: d.ends
          }
        }, t, c), li(f)) : f = zy(d), Vy(f, n, c, o), a.add(f), n.setItemGraphicEl(c, f);
      }).remove(function(c) {
        var h = i.getItemGraphicEl(c);
        h && a.remove(h);
      }).execute(), this._data = n;
    }, e.prototype._renderLarge = function(t) {
      this._clear(), BI(t, this.group);
      var n = t.get("clip", true) ? Mf(t.coordinateSystem, false, t) : null;
      n ? this.group.setClipPath(n) : this.group.removeClipPath();
    }, e.prototype._incrementalRenderNormal = function(t, n) {
      for (var i = n.getData(), a = i.getLayout("isSimpleBox"), o; (o = t.next()) != null; ) {
        var s = i.getItemLayout(o), l = zy(s);
        Vy(l, i, o, a), l.incremental = true, this.group.add(l), this._progressiveEls.push(l);
      }
    }, e.prototype._incrementalRenderLarge = function(t, n) {
      BI(n, this.group, this._progressiveEls, true);
    }, e.prototype.remove = function(t) {
      this._clear();
    }, e.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "candlestick", e;
  }(yt), Qee = /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }(), Jee = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "normalCandlestickBox", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new Qee();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.points;
      this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1]));
    }, e;
  }(Ue);
  function zy(r, e, t) {
    var n = r.ends;
    return new Jee({
      shape: {
        points: t ? ete(n, r) : n
      },
      z2: 100
    });
  }
  function FI(r, e) {
    for (var t = true, n = 0; n < e.ends.length; n++) if (r.contain(e.ends[n][0], e.ends[n][1])) {
      t = false;
      break;
    }
    return t;
  }
  function Vy(r, e, t, n) {
    var i = e.getItemModel(t);
    r.useStyle(e.getItemVisual(t, "style")), r.style.strokeNoScale = true, r.__simpleBox = n, br(r, i);
    var a = e.getItemLayout(t).sign;
    D(r.states, function(s, l) {
      var u = i.getModel(l), c = SS(a, u), h = wS(a, u) || c, f = s.style || (s.style = {});
      c && (f.fill = c), h && (f.stroke = h);
    });
    var o = i.getModel("emphasis");
    Nt(r, o.get("focus"), o.get("blurScope"), o.get("disabled"));
  }
  function ete(r, e) {
    return K(r, function(t) {
      return t = t.slice(), t[1] = e.initBaseline, t;
    });
  }
  var tte = /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }(), $y = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.type = "largeCandlestickBox", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new tte();
    }, e.prototype.buildPath = function(t, n) {
      for (var i = n.points, a = 0; a < i.length; ) if (this.__sign === i[a++]) {
        var o = i[a++];
        t.moveTo(o, i[a++]), t.lineTo(o, i[a++]);
      } else a += 3;
    }, e;
  }(Ue);
  function BI(r, e, t, n) {
    var i = r.getData(), a = i.getLayout("largePoints"), o = new $y({
      shape: {
        points: a
      },
      __sign: 1,
      ignoreCoarsePointer: true
    });
    e.add(o);
    var s = new $y({
      shape: {
        points: a
      },
      __sign: -1,
      ignoreCoarsePointer: true
    });
    e.add(s);
    var l = new $y({
      shape: {
        points: a
      },
      __sign: 0,
      ignoreCoarsePointer: true
    });
    e.add(l), Gy(1, o, r), Gy(-1, s, r), Gy(0, l, r), n && (o.incremental = true, s.incremental = true), t && t.push(o, s);
  }
  function Gy(r, e, t, n) {
    var i = wS(r, t) || SS(r, t), a = t.getModel("itemStyle").getItemStyle(Zee);
    e.useStyle(a), e.style.fill = null, e.style.stroke = i;
  }
  var fF = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [
        {
          name: "open",
          defaultTooltip: true
        },
        {
          name: "close",
          defaultTooltip: true
        },
        {
          name: "lowest",
          defaultTooltip: true
        },
        {
          name: "highest",
          defaultTooltip: true
        }
      ], t;
    }
    return e.prototype.getShadowDim = function() {
      return "open";
    }, e.prototype.brushSelector = function(t, n, i) {
      var a = n.getItemLayout(t);
      return a && i.rect(a.brushRect);
    }, e.type = "series.candlestick", e.dependencies = [
      "xAxis",
      "yAxis",
      "grid"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      clip: true,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: true,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, e;
  }(Tt);
  qt(fF, uF, true);
  function rte(r) {
    !r || !X(r.series) || D(r.series, function(e) {
      _e(e) && e.type === "k" && (e.type = "candlestick");
    });
  }
  var nte = {
    seriesType: "candlestick",
    plan: zu(),
    reset: function(r) {
      var e = r.coordinateSystem, t = r.getData(), n = ite(r, t), i = 0, a = 1, o = [
        "x",
        "y"
      ], s = t.getDimensionIndex(t.mapDimension(o[i])), l = K(t.mapDimensionsAll(o[a]), t.getDimensionIndex, t), u = l[0], c = l[1], h = l[2], f = l[3];
      if (t.setLayout({
        candleWidth: n,
        isSimpleBox: n <= 1.3
      }), s < 0 || l.length < 4) return;
      return {
        progress: r.pipelineContext.large ? p : d
      };
      function d(v, g) {
        for (var m, y = g.getStore(); (m = v.next()) != null; ) {
          var x = y.get(s, m), _ = y.get(u, m), S = y.get(c, m), b = y.get(h, m), w = y.get(f, m), C = Math.min(_, S), T = Math.max(_, S), A = L(C, x), M = L(T, x), E = L(b, x), k = L(w, x), R = [];
          P(R, M, 0), P(R, A, 1), R.push(F(k), F(M), F(E), F(A));
          var N = g.getItemModel(m), I = !!N.get([
            "itemStyle",
            "borderColorDoji"
          ]);
          g.setItemLayout(m, {
            sign: zI(y, m, _, S, c, I),
            initBaseline: _ > S ? M[a] : A[a],
            ends: R,
            brushRect: O(b, w, x)
          });
        }
        function L(B, V) {
          var U = [];
          return U[i] = V, U[a] = B, isNaN(V) || isNaN(B) ? [
            NaN,
            NaN
          ] : e.dataToPoint(U);
        }
        function P(B, V, U) {
          var Y = V.slice(), q = V.slice();
          Y[i] = xp(Y[i] + n / 2, 1, false), q[i] = xp(q[i] - n / 2, 1, true), U ? B.push(Y, q) : B.push(q, Y);
        }
        function O(B, V, U) {
          var Y = L(B, U), q = L(V, U);
          return Y[i] -= n / 2, q[i] -= n / 2, {
            x: Y[0],
            y: Y[1],
            width: n,
            height: q[1] - Y[1]
          };
        }
        function F(B) {
          return B[i] = xp(B[i], 1), B;
        }
      }
      function p(v, g) {
        for (var m = Pi(v.count * 4), y = 0, x, _ = [], S = [], b, w = g.getStore(), C = !!r.get([
          "itemStyle",
          "borderColorDoji"
        ]); (b = v.next()) != null; ) {
          var T = w.get(s, b), A = w.get(u, b), M = w.get(c, b), E = w.get(h, b), k = w.get(f, b);
          if (isNaN(T) || isNaN(E) || isNaN(k)) {
            m[y++] = NaN, y += 3;
            continue;
          }
          m[y++] = zI(w, b, A, M, c, C), _[i] = T, _[a] = E, x = e.dataToPoint(_, null, S), m[y++] = x ? x[0] : NaN, m[y++] = x ? x[1] : NaN, _[a] = k, x = e.dataToPoint(_, null, S), m[y++] = x ? x[1] : NaN;
        }
        g.setLayout("largePoints", m);
      }
    }
  };
  function zI(r, e, t, n, i, a) {
    var o;
    return t > n ? o = -1 : t < n ? o = 1 : o = a ? 0 : e > 0 ? r.get(i, e - 1) <= n ? 1 : -1 : 1, o;
  }
  function ite(r, e) {
    var t = r.getBaseAxis(), n, i = t.type === "category" ? t.getBandWidth() : (n = t.getExtent(), Math.abs(n[1] - n[0]) / e.count()), a = Q(Pe(r.get("barMaxWidth"), i), i), o = Q(Pe(r.get("barMinWidth"), 1), i), s = r.get("barWidth");
    return s != null ? Q(s, i) : Math.max(Math.min(i / 2, a), o);
  }
  function ate(r) {
    r.registerChartView(jee), r.registerSeriesModel(fF), r.registerPreprocessor(rte), r.registerVisual(Kee), r.registerLayout(nte);
  }
  function VI(r, e) {
    var t = e.rippleEffectColor || e.color;
    r.eachChild(function(n) {
      n.attr({
        z: e.z,
        zlevel: e.zlevel,
        style: {
          stroke: e.brushType === "stroke" ? t : null,
          fill: e.brushType === "fill" ? t : null
        }
      });
    });
  }
  var ote = function(r) {
    G(e, r);
    function e(t, n) {
      var i = r.call(this) || this, a = new Af(t, n), o = new Ce();
      return i.add(a), i.add(o), i.updateData(t, n), i;
    }
    return e.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, e.prototype.startEffectAnimation = function(t) {
      for (var n = t.symbolType, i = t.color, a = t.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
        var l = Xt(n, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: true
          },
          z2: 99,
          silent: true,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / a * t.period + t.effectOffset;
        l.animate("", true).when(t.period, {
          scaleX: t.rippleScale / 2,
          scaleY: t.rippleScale / 2
        }).delay(u).start(), l.animateStyle(true).when(t.period, {
          opacity: 0
        }).delay(u).start(), o.add(l);
      }
      VI(o, t);
    }, e.prototype.updateEffectAnimation = function(t) {
      for (var n = this._effectCfg, i = this.childAt(1), a = [
        "symbolType",
        "period",
        "rippleScale",
        "rippleNumber"
      ], o = 0; o < a.length; o++) {
        var s = a[o];
        if (n[s] !== t[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(t);
          return;
        }
      }
      VI(i, t);
    }, e.prototype.highlight = function() {
      ga(this);
    }, e.prototype.downplay = function() {
      ma(this);
    }, e.prototype.getSymbolType = function() {
      var t = this.childAt(0);
      return t && t.getSymbolType();
    }, e.prototype.updateData = function(t, n) {
      var i = this, a = t.hostModel;
      this.childAt(0).updateData(t, n);
      var o = this.childAt(1), s = t.getItemModel(n), l = t.getItemVisual(n, "symbol"), u = $u(t.getItemVisual(n, "symbolSize")), c = t.getItemVisual(n, "style"), h = c && c.fill, f = s.getModel("emphasis");
      o.setScale(u), o.traverse(function(g) {
        g.setStyle("fill", h);
      });
      var d = js(t.getItemVisual(n, "symbolOffset"), u);
      d && (o.x = d[0], o.y = d[1]);
      var p = t.getItemVisual(n, "symbolRotate");
      o.rotation = (p || 0) * Math.PI / 180 || 0;
      var v = {};
      v.showEffectOn = a.get("showEffectOn"), v.rippleScale = s.get([
        "rippleEffect",
        "scale"
      ]), v.brushType = s.get([
        "rippleEffect",
        "brushType"
      ]), v.period = s.get([
        "rippleEffect",
        "period"
      ]) * 1e3, v.effectOffset = n / t.count(), v.z = a.getShallow("z") || 0, v.zlevel = a.getShallow("zlevel") || 0, v.symbolType = l, v.color = h, v.rippleEffectColor = s.get([
        "rippleEffect",
        "color"
      ]), v.rippleNumber = s.get([
        "rippleEffect",
        "number"
      ]), v.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(v) : this.startEffectAnimation(v), this._effectCfg = v) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(g) {
        g === "emphasis" ? v.showEffectOn !== "render" && i.startEffectAnimation(v) : g === "normal" && v.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = v, Nt(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
    }, e.prototype.fadeOut = function(t) {
      t && t();
    }, e;
  }(Ce), ste = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._symbolDraw = new If(ote);
    }, e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = this._symbolDraw;
      o.updateData(a, {
        clipShape: this._getClipShape(t)
      }), this.group.add(o.group);
    }, e.prototype._getClipShape = function(t) {
      var n = t.coordinateSystem, i = n && n.getArea && n.getArea();
      return t.get("clip", true) ? i : null;
    }, e.prototype.updateTransform = function(t, n, i) {
      var a = t.getData();
      this.group.dirty();
      var o = Df("").reset(t, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, e.prototype._updateGroupTransform = function(t) {
      var n = t.coordinateSystem;
      n && n.getRoamTransform && (this.group.transform = MU(n.getRoamTransform()), this.group.decomposeTransform());
    }, e.prototype.remove = function(t, n) {
      this._symbolDraw && this._symbolDraw.remove(true);
    }, e.type = "effectScatter", e;
  }(yt), lte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      return Aa(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.brushSelector = function(t, n, i) {
      return i.point(n.getItemLayout(t));
    }, e.type = "series.effectScatter", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      effectType: "ripple",
      progressive: 0,
      showEffectOn: "render",
      clip: true,
      rippleEffect: {
        period: 4,
        scale: 2.5,
        brushType: "fill",
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      symbolSize: 10
    }, e;
  }(Tt);
  function ute(r) {
    r.registerChartView(ste), r.registerSeriesModel(lte), r.registerLayout(Df("effectScatter"));
  }
  var dF = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      return a.add(a.createLine(t, n, i)), a._updateEffectSymbol(t, n), a;
    }
    return e.prototype.createLine = function(t, n, i) {
      return new dS(t, n, i);
    }, e.prototype._updateEffectSymbol = function(t, n) {
      var i = t.getItemModel(n), a = i.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
      X(o) || (o = [
        o,
        o
      ]);
      var l = t.getItemVisual(n, "style"), u = a.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = Xt(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = true, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(a.getItemStyle([
        "color"
      ])), c.scaleX = o[0], c.scaleY = o[1], c.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(t, a, n));
    }, e.prototype._updateEffectAnimation = function(t, n, i) {
      var a = this.childAt(1);
      if (a) {
        var o = t.getItemLayout(i), s = n.get("period") * 1e3, l = n.get("loop"), u = n.get("roundTrip"), c = n.get("constantSpeed"), h = vr(n.get("delay"), function(d) {
          return d / t.count() * s / 3;
        });
        if (a.ignore = true, this._updateAnimationPoints(a, o), c > 0 && (s = this._getLineLength(a) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var f = void 0;
          ge(h) ? f = h(i) : f = h, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, e.prototype._animateSymbol = function(t, n, i, a, o) {
      if (n > 0) {
        t.__t = 0;
        var s = this, l = t.animate("", a).when(o ? n * 2 : n, {
          __t: o ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(t);
        });
        a || l.done(function() {
          s.remove(t);
        }), l.start();
      }
    }, e.prototype._getLineLength = function(t) {
      return Ha(t.__p1, t.__cp1) + Ha(t.__cp1, t.__p2);
    }, e.prototype._updateAnimationPoints = function(t, n) {
      t.__p1 = n[0], t.__p2 = n[1], t.__cp1 = n[2] || [
        (n[0][0] + n[1][0]) / 2,
        (n[0][1] + n[1][1]) / 2
      ];
    }, e.prototype.updateData = function(t, n, i) {
      this.childAt(0).updateData(t, n, i), this._updateEffectSymbol(t, n);
    }, e.prototype._updateSymbolPosition = function(t) {
      var n = t.__p1, i = t.__p2, a = t.__cp1, o = t.__t < 1 ? t.__t : 2 - t.__t, s = [
        t.x,
        t.y
      ], l = s.slice(), u = dr, c = dx;
      s[0] = u(n[0], a[0], i[0], o), s[1] = u(n[1], a[1], i[1], o);
      var h = t.__t < 1 ? c(n[0], a[0], i[0], o) : c(i[0], a[0], n[0], 1 - o), f = t.__t < 1 ? c(n[1], a[1], i[1], o) : c(i[1], a[1], n[1], 1 - o);
      t.rotation = -Math.atan2(f, h) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = Ha(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * Ha(n, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = false, t.x = s[0], t.y = s[1];
    }, e.prototype.updateLayout = function(t, n) {
      this.childAt(0).updateLayout(t, n);
      var i = t.getItemModel(n).getModel("effect");
      this._updateEffectAnimation(t, i, n);
    }, e;
  }(Ce), pF = function(r) {
    G(e, r);
    function e(t, n, i) {
      var a = r.call(this) || this;
      return a._createPolyline(t, n, i), a;
    }
    return e.prototype._createPolyline = function(t, n, i) {
      var a = t.getItemLayout(n), o = new Zr({
        shape: {
          points: a
        }
      });
      this.add(o), this._updateCommonStl(t, n, i);
    }, e.prototype.updateData = function(t, n, i) {
      var a = t.hostModel, o = this.childAt(0), s = {
        shape: {
          points: t.getItemLayout(n)
        }
      };
      it(o, s, a, n), this._updateCommonStl(t, n, i);
    }, e.prototype._updateCommonStl = function(t, n, i) {
      var a = this.childAt(0), o = t.getItemModel(n), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || t.hasItemOption) {
        var h = o.getModel("emphasis");
        s = h.getModel("lineStyle").getLineStyle(), c = h.get("disabled"), l = h.get("focus"), u = h.get("blurScope");
      }
      a.useStyle(t.getItemVisual(n, "style")), a.style.fill = null, a.style.strokeNoScale = true;
      var f = a.ensureState("emphasis");
      f.style = s, Nt(this, l, u, c);
    }, e.prototype.updateLayout = function(t, n) {
      var i = this.childAt(0);
      i.setShape("points", t.getItemLayout(n));
    }, e;
  }(Ce), cte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t._lastFrame = 0, t._lastFramePercent = 0, t;
    }
    return e.prototype.createLine = function(t, n, i) {
      return new pF(t, n, i);
    }, e.prototype._updateAnimationPoints = function(t, n) {
      this._points = n;
      for (var i = [
        0
      ], a = 0, o = 1; o < n.length; o++) {
        var s = n[o - 1], l = n[o];
        a += Ha(s, l), i.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var o = 0; o < i.length; o++) i[o] /= a;
      this._offsets = i, this._length = a;
    }, e.prototype._getLineLength = function() {
      return this._length;
    }, e.prototype._updateSymbolPosition = function(t) {
      var n = t.__t < 1 ? t.__t : 2 - t.__t, i = this._points, a = this._offsets, o = i.length;
      if (a) {
        var s = this._lastFrame, l;
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1);
          for (l = u; l >= 0 && !(a[l] <= n); l--) ;
          l = Math.min(l, o - 2);
        } else {
          for (l = s; l < o && !(a[l] > n); l++) ;
          l = Math.min(l - 1, o - 2);
        }
        var c = (n - a[l]) / (a[l + 1] - a[l]), h = i[l], f = i[l + 1];
        t.x = h[0] * (1 - c) + c * f[0], t.y = h[1] * (1 - c) + c * f[1];
        var d = t.__t < 1 ? f[0] - h[0] : h[0] - f[0], p = t.__t < 1 ? f[1] - h[1] : h[1] - f[1];
        t.rotation = -Math.atan2(p, d) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = n, t.ignore = false;
      }
    }, e;
  }(dF), hte = /* @__PURE__ */ function() {
    function r() {
      this.polyline = false, this.curveness = 0, this.segs = [];
    }
    return r;
  }(), fte = function(r) {
    G(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return e.prototype.reset = function() {
      this.notClear = false, this._off = 0;
    }, e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new hte();
    }, e.prototype.buildPath = function(t, n) {
      var i = n.segs, a = n.curveness, o;
      if (n.polyline) for (o = this._off; o < i.length; ) {
        var s = i[o++];
        if (s > 0) {
          t.moveTo(i[o++], i[o++]);
          for (var l = 1; l < s; l++) t.lineTo(i[o++], i[o++]);
        }
      }
      else for (o = this._off; o < i.length; ) {
        var u = i[o++], c = i[o++], h = i[o++], f = i[o++];
        if (t.moveTo(u, c), a > 0) {
          var d = (u + h) / 2 - (c - f) * a, p = (c + f) / 2 - (h - u) * a;
          t.quadraticCurveTo(d, p, h, f);
        } else t.lineTo(h, f);
      }
      this.incremental && (this._off = o, this.notClear = true);
    }, e.prototype.findDataIndex = function(t, n) {
      var i = this.shape, a = i.segs, o = i.curveness, s = this.style.lineWidth;
      if (i.polyline) for (var l = 0, u = 0; u < a.length; ) {
        var c = a[u++];
        if (c > 0) for (var h = a[u++], f = a[u++], d = 1; d < c; d++) {
          var p = a[u++], v = a[u++];
          if (Ga(h, f, p, v, s, t, n)) return l;
        }
        l++;
      }
      else for (var l = 0, u = 0; u < a.length; ) {
        var h = a[u++], f = a[u++], p = a[u++], v = a[u++];
        if (o > 0) {
          var g = (h + p) / 2 - (f - v) * o, m = (f + v) / 2 - (p - h) * o;
          if (VR(h, f, g, m, p, v, s, t, n)) return l;
        } else if (Ga(h, f, p, v, s, t, n)) return l;
        l++;
      }
      return -1;
    }, e.prototype.contain = function(t, n) {
      var i = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
      if (t = i[0], n = i[1], a.contain(t, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, false;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var n = this.shape, i = n.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], h = i[u++];
          a = Math.min(c, a), s = Math.max(c, s), o = Math.min(h, o), l = Math.max(h, l);
        }
        t = this._rect = new Oe(a, o, s, l);
      }
      return t;
    }, e;
  }(Ue), dte = function() {
    function r() {
      this.group = new Ce();
    }
    return r.prototype.updateData = function(e) {
      this._clear();
      var t = this._create();
      t.setShape({
        segs: e.getLayout("linesPoints")
      }), this._setCommon(t, e);
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this.group.removeAll(), this._clear();
    }, r.prototype.incrementalUpdate = function(e, t) {
      var n = this._newAdded[0], i = t.getLayout("linesPoints"), a = n && n.shape.segs;
      if (a && a.length < 2e4) {
        var o = a.length, s = new Float32Array(o + i.length);
        s.set(a), s.set(i, o), n.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = true, l.setShape({
          segs: i
        }), this._setCommon(l, t), l.__startIndex = e.start;
      }
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, r.prototype._create = function() {
      var e = new fte({
        cursor: "default",
        ignoreCoarsePointer: true
      });
      return this._newAdded.push(e), this.group.add(e), e;
    }, r.prototype._setCommon = function(e, t, n) {
      var i = t.hostModel;
      e.setShape({
        polyline: i.get("polyline"),
        curveness: i.get([
          "lineStyle",
          "curveness"
        ])
      }), e.useStyle(i.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = true;
      var a = t.getVisual("style");
      a && a.stroke && e.setStyle("stroke", a.stroke), e.setStyle("fill", null);
      var o = De(e);
      o.seriesIndex = i.seriesIndex, e.on("mousemove", function(s) {
        o.dataIndex = null;
        var l = e.hoverDataIdx;
        l > 0 && (o.dataIndex = l + e.__startIndex);
      });
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }(), vF = {
    seriesType: "lines",
    plan: zu(),
    reset: function(r) {
      var e = r.coordinateSystem;
      if (e) {
        var t = r.get("polyline"), n = r.pipelineContext.large;
        return {
          progress: function(i, a) {
            var o = [];
            if (n) {
              var s = void 0, l = i.end - i.start;
              if (t) {
                for (var u = 0, c = i.start; c < i.end; c++) u += r.getLineCoordsCount(c);
                s = new Float32Array(l + u * 2);
              } else s = new Float32Array(l * 4);
              for (var h = 0, f = [], c = i.start; c < i.end; c++) {
                var d = r.getLineCoords(c, o);
                t && (s[h++] = d);
                for (var p = 0; p < d; p++) f = e.dataToPoint(o[p], false, f), s[h++] = f[0], s[h++] = f[1];
              }
              a.setLayout("linesPoints", s);
            } else for (var c = i.start; c < i.end; c++) {
              var v = a.getItemModel(c), d = r.getLineCoords(c, o), g = [];
              if (t) for (var m = 0; m < d; m++) g.push(e.dataToPoint(o[m]));
              else {
                g[0] = e.dataToPoint(o[0]), g[1] = e.dataToPoint(o[1]);
                var y = v.get([
                  "lineStyle",
                  "curveness"
                ]);
                +y && (g[2] = [
                  (g[0][0] + g[1][0]) / 2 - (g[0][1] - g[1][1]) * y,
                  (g[0][1] + g[1][1]) / 2 - (g[1][0] - g[0][0]) * y
                ]);
              }
              a.setItemLayout(c, g);
            }
          }
        };
      }
    }
  }, pte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = this._updateLineDraw(a, t), s = t.get("zlevel"), l = t.get([
        "effect",
        "trailLength"
      ]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(true), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: false
      }), this._showEffect(t) && l > 0 && (c || u.configLayer(s, {
        motionBlur: true,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), o.updateData(a);
      var h = t.get("clip", true) && Mf(t.coordinateSystem, false, t);
      h ? this.group.setClipPath(h) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = true;
    }, e.prototype.incrementalPrepareRender = function(t, n, i) {
      var a = t.getData(), o = this._updateLineDraw(a, t);
      o.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = false;
    }, e.prototype.incrementalRender = function(t, n, i) {
      this._lineDraw.incrementalUpdate(t, n.getData()), this._finished = t.end === n.getData().count();
    }, e.prototype.eachRendered = function(t) {
      this._lineDraw && this._lineDraw.eachRendered(t);
    }, e.prototype.updateTransform = function(t, n, i) {
      var a = t.getData(), o = t.pipelineContext;
      if (!this._finished || o.large || o.progressiveRender) return {
        update: true
      };
      var s = vF.reset(t, n, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, e.prototype._updateLineDraw = function(t, n) {
      var i = this._lineDraw, a = this._showEffect(n), o = !!n.get("polyline"), s = n.pipelineContext, l = s.large;
      return (!i || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new dte() : new pS(o ? a ? cte : pF : a ? dF : dS), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(i.group), i;
    }, e.prototype._showEffect = function(t) {
      return !!t.get([
        "effect",
        "show"
      ]);
    }, e.prototype._clearLayer = function(t) {
      var n = t.getZr(), i = n.painter.getType() === "svg";
      !i && this._lastZlevel != null && n.painter.getLayer(this._lastZlevel).clear(true);
    }, e.prototype.remove = function(t, n) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(n);
    }, e.prototype.dispose = function(t, n) {
      this.remove(t, n);
    }, e.type = "lines", e;
  }(yt), vte = typeof Uint32Array > "u" ? Array : Uint32Array, gte = typeof Float64Array > "u" ? Array : Float64Array;
  function $I(r) {
    var e = r.data;
    e && e[0] && e[0][0] && e[0][0].coord && (r.data = K(e, function(t) {
      var n = [
        t[0].coord,
        t[1].coord
      ], i = {
        coords: n
      };
      return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), Xb([
        i,
        t[0],
        t[1]
      ]);
    }));
  }
  var mte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.init = function(t) {
      t.data = t.data || [], $I(t);
      var n = this._processFlatCoordsArray(t.data);
      this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (t.data = new Float32Array(n.count)), r.prototype.init.apply(this, arguments);
    }, e.prototype.mergeOption = function(t) {
      if ($I(t), t.data) {
        var n = this._processFlatCoordsArray(t.data);
        this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (t.data = new Float32Array(n.count));
      }
      r.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.appendData = function(t) {
      var n = this._processFlatCoordsArray(t.data);
      n.flatCoords && (this._flatCoords ? (this._flatCoords = _h(this._flatCoords, n.flatCoords), this._flatCoordsOffset = _h(this._flatCoordsOffset, n.flatCoordsOffset)) : (this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset), t.data = new Float32Array(n.count)), this.getRawData().appendData(t.data);
    }, e.prototype._getCoordsFromItemModel = function(t) {
      var n = this.getData().getItemModel(t), i = n.option instanceof Array ? n.option : n.getShallow("coords");
      return i;
    }, e.prototype.getLineCoordsCount = function(t) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length;
    }, e.prototype.getLineCoords = function(t, n) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[t * 2], a = this._flatCoordsOffset[t * 2 + 1], o = 0; o < a; o++) n[o] = n[o] || [], n[o][0] = this._flatCoords[i + o * 2], n[o][1] = this._flatCoords[i + o * 2 + 1];
        return a;
      } else {
        for (var s = this._getCoordsFromItemModel(t), o = 0; o < s.length; o++) n[o] = n[o] || [], n[o][0] = s[o][0], n[o][1] = s[o][1];
        return s.length;
      }
    }, e.prototype._processFlatCoordsArray = function(t) {
      var n = 0;
      if (this._flatCoords && (n = this._flatCoords.length), nt(t[0])) {
        for (var i = t.length, a = new vte(i), o = new gte(i), s = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var h = t[c++];
          a[l++] = s + n, a[l++] = h;
          for (var f = 0; f < h; f++) {
            var d = t[c++], p = t[c++];
            o[s++] = d, o[s++] = p;
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: t.length
      };
    }, e.prototype.getInitialData = function(t, n) {
      var i = new Wr([
        "value"
      ], this);
      return i.hasItemOption = false, i.initData(t.data, [], function(a, o, s, l) {
        if (a instanceof Array) return NaN;
        i.hasItemOption = true;
        var u = a.value;
        if (u != null) return u instanceof Array ? u[l] : u;
      }), i;
    }, e.prototype.formatTooltip = function(t, n, i) {
      var a = this.getData(), o = a.getItemModel(t), s = o.get("name");
      if (s) return s;
      var l = o.get("fromName"), u = o.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), ur("nameValue", {
        name: c.join(" > ")
      });
    }, e.prototype.preventIncremental = function() {
      return !!this.get([
        "effect",
        "show"
      ]);
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, e.prototype.getZLevelKey = function() {
      var t = this.getModel("effect"), n = t.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && n > 0 ? n + "" : "";
    }, e.type = "series.lines", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "geo",
      z: 2,
      legendHoverLink: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: [
        "none",
        "none"
      ],
      symbolSize: [
        10,
        10
      ],
      geoIndex: 0,
      effect: {
        show: false,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: true,
        trailLength: 0.2
      },
      large: false,
      largeThreshold: 2e3,
      polyline: false,
      clip: true,
      label: {
        show: false,
        position: "end"
      },
      lineStyle: {
        opacity: 0.5
      }
    }, e;
  }(Tt);
  function kd(r) {
    return r instanceof Array || (r = [
      r,
      r
    ]), r;
  }
  var yte = {
    seriesType: "lines",
    reset: function(r) {
      var e = kd(r.get("symbol")), t = kd(r.get("symbolSize")), n = r.getData();
      n.setVisual("fromSymbol", e && e[0]), n.setVisual("toSymbol", e && e[1]), n.setVisual("fromSymbolSize", t && t[0]), n.setVisual("toSymbolSize", t && t[1]);
      function i(a, o) {
        var s = a.getItemModel(o), l = kd(s.getShallow("symbol", true)), u = kd(s.getShallow("symbolSize", true));
        l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
      }
      return {
        dataEach: n.hasItemOption ? i : null
      };
    }
  };
  function xte(r) {
    r.registerChartView(pte), r.registerSeriesModel(mte), r.registerLayout(vF), r.registerVisual(yte);
  }
  var _te = 256, bte = function() {
    function r() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var e = so.createCanvas();
      this.canvas = e;
    }
    return r.prototype.update = function(e, t, n, i, a, o) {
      var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), c = this.pointSize + this.blurSize, h = this.canvas, f = h.getContext("2d"), d = e.length;
      h.width = t, h.height = n;
      for (var p = 0; p < d; ++p) {
        var v = e[p], g = v[0], m = v[1], y = v[2], x = i(y);
        f.globalAlpha = x, f.drawImage(s, g - c, m - c);
      }
      if (!h.width || !h.height) return h;
      for (var _ = f.getImageData(0, 0, h.width, h.height), S = _.data, b = 0, w = S.length, C = this.minOpacity, T = this.maxOpacity, A = T - C; b < w; ) {
        var x = S[b + 3] / 256, M = Math.floor(x * (_te - 1)) * 4;
        if (x > 0) {
          var E = o(x) ? l : u;
          x > 0 && (x = x * A + C), S[b++] = E[M], S[b++] = E[M + 1], S[b++] = E[M + 2], S[b++] = E[M + 3] * x * 256;
        } else b += 4;
      }
      return f.putImageData(_, 0, 0), h;
    }, r.prototype._getBrush = function() {
      var e = this._brushCanvas || (this._brushCanvas = so.createCanvas()), t = this.pointSize + this.blurSize, n = t * 2;
      e.width = n, e.height = n;
      var i = e.getContext("2d");
      return i.clearRect(0, 0, n, n), i.shadowOffsetX = n, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-t, t, this.pointSize, 0, Math.PI * 2, true), i.closePath(), i.fill(), e;
    }, r.prototype._getGradient = function(e, t) {
      for (var n = this._gradientPixels, i = n[t] || (n[t] = new Uint8ClampedArray(256 * 4)), a = [
        0,
        0,
        0,
        0
      ], o = 0, s = 0; s < 256; s++) e[t](s / 255, true, a), i[o++] = a[0], i[o++] = a[1], i[o++] = a[2], i[o++] = a[3];
      return i;
    }, r;
  }();
  function Ste(r, e, t) {
    var n = r[1] - r[0];
    e = K(e, function(o) {
      return {
        interval: [
          (o.interval[0] - r[0]) / n,
          (o.interval[1] - r[0]) / n
        ]
      };
    });
    var i = e.length, a = 0;
    return function(o) {
      var s;
      for (s = a; s < i; s++) {
        var l = e[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
      if (s === i) for (s = a - 1; s >= 0; s--) {
        var l = e[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
      return s >= 0 && s < i && t[s];
    };
  }
  function wte(r, e) {
    var t = r[1] - r[0];
    return e = [
      (e[0] - r[0]) / t,
      (e[1] - r[0]) / t
    ], function(n) {
      return n >= e[0] && n <= e[1];
    };
  }
  function GI(r) {
    var e = r.dimensions;
    return e[0] === "lng" && e[1] === "lat";
  }
  var Cte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a;
      n.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === t && (a = s);
        });
      }), this._progressiveEls = null, this.group.removeAll();
      var o = t.coordinateSystem;
      o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(t, i, 0, t.getData().count()) : GI(o) && this._renderOnGeo(o, t, a, i);
    }, e.prototype.incrementalPrepareRender = function(t, n, i) {
      this.group.removeAll();
    }, e.prototype.incrementalRender = function(t, n, i, a) {
      var o = n.coordinateSystem;
      o && (GI(o) ? this.render(n, i, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(n, a, t.start, t.end, true)));
    }, e.prototype.eachRendered = function(t) {
      mo(this._progressiveEls || this.group, t);
    }, e.prototype._renderOnCartesianAndCalendar = function(t, n, i, a, o) {
      var s = t.coordinateSystem, l = Js(s, "cartesian2d"), u, c, h, f;
      if (l) {
        var d = s.getAxis("x"), p = s.getAxis("y");
        u = d.getBandWidth() + 0.5, c = p.getBandWidth() + 0.5, h = d.scale.getExtent(), f = p.scale.getExtent();
      }
      for (var v = this.group, g = t.getData(), m = t.getModel([
        "emphasis",
        "itemStyle"
      ]).getItemStyle(), y = t.getModel([
        "blur",
        "itemStyle"
      ]).getItemStyle(), x = t.getModel([
        "select",
        "itemStyle"
      ]).getItemStyle(), _ = t.get([
        "itemStyle",
        "borderRadius"
      ]), S = lr(t), b = t.getModel("emphasis"), w = b.get("focus"), C = b.get("blurScope"), T = b.get("disabled"), A = l ? [
        g.mapDimension("x"),
        g.mapDimension("y"),
        g.mapDimension("value")
      ] : [
        g.mapDimension("time"),
        g.mapDimension("value")
      ], M = i; M < a; M++) {
        var E = void 0, k = g.getItemVisual(M, "style");
        if (l) {
          var R = g.get(A[0], M), N = g.get(A[1], M);
          if (isNaN(g.get(A[2], M)) || isNaN(R) || isNaN(N) || R < h[0] || R > h[1] || N < f[0] || N > f[1]) continue;
          var I = s.dataToPoint([
            R,
            N
          ]);
          E = new et({
            shape: {
              x: I[0] - u / 2,
              y: I[1] - c / 2,
              width: u,
              height: c
            },
            style: k
          });
        } else {
          if (isNaN(g.get(A[1], M))) continue;
          E = new et({
            z2: 1,
            shape: s.dataToRect([
              g.get(A[0], M)
            ]).contentShape,
            style: k
          });
        }
        if (g.hasItemOption) {
          var L = g.getItemModel(M), P = L.getModel("emphasis");
          m = P.getModel("itemStyle").getItemStyle(), y = L.getModel([
            "blur",
            "itemStyle"
          ]).getItemStyle(), x = L.getModel([
            "select",
            "itemStyle"
          ]).getItemStyle(), _ = L.get([
            "itemStyle",
            "borderRadius"
          ]), w = P.get("focus"), C = P.get("blurScope"), T = P.get("disabled"), S = lr(L);
        }
        E.shape.r = _;
        var O = t.getRawValue(M), F = "-";
        O && O[2] != null && (F = O[2] + ""), Sr(E, S, {
          labelFetcher: t,
          labelDataIndex: M,
          defaultOpacity: k.opacity,
          defaultText: F
        }), E.ensureState("emphasis").style = m, E.ensureState("blur").style = y, E.ensureState("select").style = x, Nt(E, w, C, T), E.incremental = o, o && (E.states.emphasis.hoverLayer = true), v.add(E), g.setItemGraphicEl(M, E), this._progressiveEls && this._progressiveEls.push(E);
      }
    }, e.prototype._renderOnGeo = function(t, n, i, a) {
      var o = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = n.getData(), u = this._hmLayer || this._hmLayer || new bte();
      u.blurSize = n.get("blurSize"), u.pointSize = n.get("pointSize"), u.minOpacity = n.get("minOpacity"), u.maxOpacity = n.get("maxOpacity");
      var c = t.getViewRect().clone(), h = t.getRoamTransform();
      c.applyTransform(h);
      var f = Math.max(c.x, 0), d = Math.max(c.y, 0), p = Math.min(c.width + c.x, a.getWidth()), v = Math.min(c.height + c.y, a.getHeight()), g = p - f, m = v - d, y = [
        l.mapDimension("lng"),
        l.mapDimension("lat"),
        l.mapDimension("value")
      ], x = l.mapArray(y, function(w, C, T) {
        var A = t.dataToPoint([
          w,
          C
        ]);
        return A[0] -= f, A[1] -= d, A.push(T), A;
      }), _ = i.getExtent(), S = i.type === "visualMap.continuous" ? wte(_, i.option.range) : Ste(_, i.getPieceList(), i.option.selected);
      u.update(x, g, m, o.color.getNormalizer(), {
        inRange: o.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, S);
      var b = new mr({
        style: {
          width: g,
          height: m,
          x: f,
          y: d,
          image: u.canvas
        },
        silent: true
      });
      this.group.add(b);
    }, e.type = "heatmap", e;
  }(yt), Tte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      return Aa(null, this, {
        generateCoord: "value"
      });
    }, e.prototype.preventIncremental = function() {
      var t = Sf.get(this.get("coordinateSystem"));
      if (t && t.dimensions) return t.dimensions[0] === "lng" && t.dimensions[1] === "lat";
    }, e.type = "series.heatmap", e.dependencies = [
      "grid",
      "geo",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Tt);
  function Ate(r) {
    r.registerChartView(Cte), r.registerSeriesModel(Tte);
  }
  var Ite = [
    "itemStyle",
    "borderWidth"
  ], WI = [
    {
      xy: "x",
      wh: "width",
      index: 0,
      posDesc: [
        "left",
        "right"
      ]
    },
    {
      xy: "y",
      wh: "height",
      index: 1,
      posDesc: [
        "top",
        "bottom"
      ]
    }
  ], Wy = new Ta(), Mte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = this.group, o = t.getData(), s = this._data, l = t.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), h = l.master.getRect(), f = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: t,
        coordSys: l,
        coordSysExtent: [
          [
            h.x,
            h.x + h.width
          ],
          [
            h.y,
            h.y + h.height
          ]
        ],
        isHorizontal: c,
        valueDim: WI[+c],
        categoryDim: WI[1 - +c]
      };
      o.diff(s).add(function(p) {
        if (o.hasValue(p)) {
          var v = HI(o, p), g = UI(o, p, v, f), m = YI(o, f, g);
          o.setItemGraphicEl(p, m), a.add(m), qI(m, f, g);
        }
      }).update(function(p, v) {
        var g = s.getItemGraphicEl(v);
        if (!o.hasValue(p)) {
          a.remove(g);
          return;
        }
        var m = HI(o, p), y = UI(o, p, m, f), x = bF(o, y);
        g && x !== g.__pictorialShapeStr && (a.remove(g), o.setItemGraphicEl(p, null), g = null), g ? Nte(g, f, y) : g = YI(o, f, y, true), o.setItemGraphicEl(p, g), g.__pictorialSymbolMeta = y, a.add(g), qI(g, f, y);
      }).remove(function(p) {
        var v = s.getItemGraphicEl(p);
        v && XI(s, p, v.__pictorialSymbolMeta.animationModel, v);
      }).execute();
      var d = t.get("clip", true) ? Mf(t.coordinateSystem, false, t) : null;
      return d ? a.setClipPath(d) : a.removeClipPath(), this._data = o, this.group;
    }, e.prototype.remove = function(t, n) {
      var i = this.group, a = this._data;
      t.get("animation") ? a && a.eachItemGraphicEl(function(o) {
        XI(a, De(o).dataIndex, t, o);
      }) : i.removeAll();
    }, e.type = "pictorialBar", e;
  }(yt);
  function UI(r, e, t, n) {
    var i = r.getItemLayout(e), a = t.get("symbolRepeat"), o = t.get("symbolClip"), s = t.get("symbolPosition") || "start", l = t.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = t.get("symbolPatternSize") || 2, h = t.isAnimationEnabled(), f = {
      dataIndex: e,
      layout: i,
      itemModel: t,
      symbolType: r.getItemVisual(e, "symbol") || "circle",
      style: r.getItemVisual(e, "style"),
      symbolClip: o,
      symbolRepeat: a,
      symbolRepeatDirection: t.get("symbolRepeatDirection"),
      symbolPatternSize: c,
      rotation: u,
      animationModel: h ? t : null,
      hoverScale: h && t.get([
        "emphasis",
        "scale"
      ]),
      z2: t.getShallow("z", true) || 0
    };
    Dte(t, a, i, n, f), Pte(r, e, i, a, o, f.boundingLength, f.pxSign, c, n, f), kte(t, f.symbolScale, u, n, f);
    var d = f.symbolSize, p = js(t.get("symbolOffset"), d);
    return Lte(t, d, i, a, o, p, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, n, f), f;
  }
  function Dte(r, e, t, n, i) {
    var a = n.valueDim, o = r.get("symbolBoundingData"), s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(t[a.wh] <= 0), c;
    if (X(o)) {
      var h = [
        Uy(s, o[0]) - l,
        Uy(s, o[1]) - l
      ];
      h[1] < h[0] && h.reverse(), c = h[u];
    } else o != null ? c = Uy(s, o) - l : e ? c = n.coordSysExtent[a.index][u] - l : c = t[a.wh];
    i.boundingLength = c, e && (i.repeatCutLength = t[a.wh]);
    var f = a.xy === "x", d = s.inverse;
    i.pxSign = f && !d || !f && d ? c >= 0 ? 1 : -1 : c > 0 ? 1 : -1;
  }
  function Uy(r, e) {
    return r.toGlobalCoord(r.dataToCoord(r.scale.parse(e)));
  }
  function Pte(r, e, t, n, i, a, o, s, l, u) {
    var c = l.valueDim, h = l.categoryDim, f = Math.abs(t[h.wh]), d = r.getItemVisual(e, "symbolSize"), p;
    X(d) ? p = d.slice() : d == null ? p = [
      "100%",
      "100%"
    ] : p = [
      d,
      d
    ], p[h.index] = Q(p[h.index], f), p[c.index] = Q(p[c.index], n ? f : Math.abs(a)), u.symbolSize = p;
    var v = u.symbolScale = [
      p[0] / s,
      p[1] / s
    ];
    v[c.index] *= (l.isHorizontal ? -1 : 1) * o;
  }
  function kte(r, e, t, n, i) {
    var a = r.get(Ite) || 0;
    a && (Wy.attr({
      scaleX: e[0],
      scaleY: e[1],
      rotation: t
    }), Wy.updateTransform(), a /= Wy.getLineScale(), a *= e[n.valueDim.index]), i.valueLineWidth = a || 0;
  }
  function Lte(r, e, t, n, i, a, o, s, l, u, c, h) {
    var f = c.categoryDim, d = c.valueDim, p = h.pxSign, v = Math.max(e[d.index] + s, 0), g = v;
    if (n) {
      var m = Math.abs(l), y = vr(r.get("symbolMargin"), "15%") + "", x = false;
      y.lastIndexOf("!") === y.length - 1 && (x = true, y = y.slice(0, y.length - 1));
      var _ = Q(y, e[d.index]), S = Math.max(v + _ * 2, 0), b = x ? 0 : _ * 2, w = AR(n), C = w ? n : KI((m + b) / S), T = m - C * v;
      _ = T / 2 / (x ? C : Math.max(C - 1, 1)), S = v + _ * 2, b = x ? 0 : _ * 2, !w && n !== "fixed" && (C = u ? KI((Math.abs(u) + b) / S) : 0), g = C * S - b, h.repeatTimes = C, h.symbolMargin = _;
    }
    var A = p * (g / 2), M = h.pathPosition = [];
    M[f.index] = t[f.wh] / 2, M[d.index] = o === "start" ? A : o === "end" ? l - A : l / 2, a && (M[0] += a[0], M[1] += a[1]);
    var E = h.bundlePosition = [];
    E[f.index] = t[f.xy], E[d.index] = t[d.xy];
    var k = h.barRectShape = H({}, t);
    k[d.wh] = p * Math.max(Math.abs(t[d.wh]), Math.abs(M[d.index] + A)), k[f.wh] = t[f.wh];
    var R = h.clipShape = {};
    R[f.xy] = -t[f.xy], R[f.wh] = c.ecSize[f.wh], R[d.xy] = 0, R[d.wh] = t[d.wh];
  }
  function gF(r) {
    var e = r.symbolPatternSize, t = Xt(r.symbolType, -e / 2, -e / 2, e, e);
    return t.attr({
      culling: true
    }), t.type !== "image" && t.setStyle({
      strokeNoScale: true
    }), t;
  }
  function mF(r, e, t, n) {
    var i = r.__pictorialBundle, a = t.symbolSize, o = t.valueLineWidth, s = t.pathPosition, l = e.valueDim, u = t.repeatTimes || 0, c = 0, h = a[e.valueDim.index] + o + t.symbolMargin * 2;
    for (CS(r, function(v) {
      v.__pictorialAnimationIndex = c, v.__pictorialRepeatTimes = u, c < u ? iu(v, null, p(c), t, n) : iu(v, null, {
        scaleX: 0,
        scaleY: 0
      }, t, n, function() {
        i.remove(v);
      }), c++;
    }); c < u; c++) {
      var f = gF(t);
      f.__pictorialAnimationIndex = c, f.__pictorialRepeatTimes = u, i.add(f);
      var d = p(c);
      iu(f, {
        x: d.x,
        y: d.y,
        scaleX: 0,
        scaleY: 0
      }, {
        scaleX: d.scaleX,
        scaleY: d.scaleY,
        rotation: d.rotation
      }, t, n);
    }
    function p(v) {
      var g = s.slice(), m = t.pxSign, y = v;
      return (t.symbolRepeatDirection === "start" ? m > 0 : m < 0) && (y = u - 1 - v), g[l.index] = h * (y - u / 2 + 0.5) + s[l.index], {
        x: g[0],
        y: g[1],
        scaleX: t.symbolScale[0],
        scaleY: t.symbolScale[1],
        rotation: t.rotation
      };
    }
  }
  function yF(r, e, t, n) {
    var i = r.__pictorialBundle, a = r.__pictorialMainPath;
    a ? iu(a, null, {
      x: t.pathPosition[0],
      y: t.pathPosition[1],
      scaleX: t.symbolScale[0],
      scaleY: t.symbolScale[1],
      rotation: t.rotation
    }, t, n) : (a = r.__pictorialMainPath = gF(t), i.add(a), iu(a, {
      x: t.pathPosition[0],
      y: t.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: t.rotation
    }, {
      scaleX: t.symbolScale[0],
      scaleY: t.symbolScale[1]
    }, t, n));
  }
  function xF(r, e, t) {
    var n = H({}, e.barRectShape), i = r.__pictorialBarRect;
    i ? iu(i, null, {
      shape: n
    }, e, t) : (i = r.__pictorialBarRect = new et({
      z2: 2,
      shape: n,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    }), i.disableMorphing = true, r.add(i));
  }
  function _F(r, e, t, n) {
    if (t.symbolClip) {
      var i = r.__pictorialClipPath, a = H({}, t.clipShape), o = e.valueDim, s = t.animationModel, l = t.dataIndex;
      if (i) it(i, {
        shape: a
      }, s, l);
      else {
        a[o.wh] = 0, i = new et({
          shape: a
        }), r.__pictorialBundle.setClipPath(i), r.__pictorialClipPath = i;
        var u = {};
        u[o.wh] = t.clipShape[o.wh], Zs[n ? "updateProps" : "initProps"](i, {
          shape: u
        }, s, l);
      }
    }
  }
  function HI(r, e) {
    var t = r.getItemModel(e);
    return t.getAnimationDelayParams = Rte, t.isAnimationEnabled = Ete, t;
  }
  function Rte(r) {
    return {
      index: r.__pictorialAnimationIndex,
      count: r.__pictorialRepeatTimes
    };
  }
  function Ete() {
    return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
  }
  function YI(r, e, t, n) {
    var i = new Ce(), a = new Ce();
    return i.add(a), i.__pictorialBundle = a, a.x = t.bundlePosition[0], a.y = t.bundlePosition[1], t.symbolRepeat ? mF(i, e, t) : yF(i, e, t), xF(i, t, n), _F(i, e, t, n), i.__pictorialShapeStr = bF(r, t), i.__pictorialSymbolMeta = t, i;
  }
  function Nte(r, e, t) {
    var n = t.animationModel, i = t.dataIndex, a = r.__pictorialBundle;
    it(a, {
      x: t.bundlePosition[0],
      y: t.bundlePosition[1]
    }, n, i), t.symbolRepeat ? mF(r, e, t, true) : yF(r, e, t, true), xF(r, t, true), _F(r, e, t, true);
  }
  function XI(r, e, t, n) {
    var i = n.__pictorialBarRect;
    i && i.removeTextContent();
    var a = [];
    CS(n, function(o) {
      a.push(o);
    }), n.__pictorialMainPath && a.push(n.__pictorialMainPath), n.__pictorialClipPath && (t = null), D(a, function(o) {
      uo(o, {
        scaleX: 0,
        scaleY: 0
      }, t, e, function() {
        n.parent && n.parent.remove(n);
      });
    }), r.setItemGraphicEl(e, null);
  }
  function bF(r, e) {
    return [
      r.getItemVisual(e.dataIndex, "symbol") || "none",
      !!e.symbolRepeat,
      !!e.symbolClip
    ].join(":");
  }
  function CS(r, e, t) {
    D(r.__pictorialBundle.children(), function(n) {
      n !== r.__pictorialBarRect && e.call(t, n);
    });
  }
  function iu(r, e, t, n, i, a) {
    e && r.attr(e), n.symbolClip && !i ? t && r.attr(t) : t && Zs[i ? "updateProps" : "initProps"](r, t, n.animationModel, n.dataIndex, a);
  }
  function qI(r, e, t) {
    var n = t.dataIndex, i = t.itemModel, a = i.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = i.getModel([
      "blur",
      "itemStyle"
    ]).getItemStyle(), l = i.getModel([
      "select",
      "itemStyle"
    ]).getItemStyle(), u = i.getShallow("cursor"), c = a.get("focus"), h = a.get("blurScope"), f = a.get("scale");
    CS(r, function(v) {
      if (v instanceof mr) {
        var g = v.style;
        v.useStyle(H({
          image: g.image,
          x: g.x,
          y: g.y,
          width: g.width,
          height: g.height
        }, t.style));
      } else v.useStyle(t.style);
      var m = v.ensureState("emphasis");
      m.style = o, f && (m.scaleX = v.scaleX * 1.1, m.scaleY = v.scaleY * 1.1), v.ensureState("blur").style = s, v.ensureState("select").style = l, u && (v.cursor = u), v.z2 = t.z2;
    });
    var d = e.valueDim.posDesc[+(t.boundingLength > 0)], p = r.__pictorialBarRect;
    p.ignoreClip = true, Sr(p, lr(i), {
      labelFetcher: e.seriesModel,
      labelDataIndex: n,
      defaultText: du(e.seriesModel.getData(), n),
      inheritColor: t.style.fill,
      defaultOpacity: t.style.opacity,
      defaultOutsidePosition: d
    }), Nt(r, c, h, a.get("disabled"));
  }
  function KI(r) {
    var e = Math.round(r);
    return Math.abs(r - e) < 1e-4 ? e : Math.ceil(r);
  }
  var Ote = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t.defaultSymbol = "roundRect", t;
    }
    return e.prototype.getInitialData = function(t) {
      return t.stack = null, r.prototype.getInitialData.apply(this, arguments);
    }, e.type = "series.pictorialBar", e.dependencies = [
      "grid"
    ], e.defaultOption = yo(Bh.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: false,
      symbolRepeatDirection: "end",
      symbolClip: false,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      clip: false,
      progressive: 0,
      emphasis: {
        scale: false
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), e;
  }(Bh);
  function Fte(r) {
    r.registerChartView(Mte), r.registerSeriesModel(Ote), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Le(iN, "pictorialBar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, aN("pictorialBar"));
  }
  var Bte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._layers = [], t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = t.getData(), o = this, s = this.group, l = t.getLayerSeries(), u = a.getLayout("layoutInfo"), c = u.rect, h = u.boundaryGap;
      s.x = 0, s.y = c.y + h[0];
      function f(g) {
        return g.name;
      }
      var d = new ya(this._layersSeries || [], l, f, f), p = [];
      d.add(ne(v, this, "add")).update(ne(v, this, "update")).remove(ne(v, this, "remove")).execute();
      function v(g, m, y) {
        var x = o._layers;
        if (g === "remove") {
          s.remove(x[m]);
          return;
        }
        for (var _ = [], S = [], b, w = l[m].indices, C = 0; C < w.length; C++) {
          var T = a.getItemLayout(w[C]), A = T.x, M = T.y0, E = T.y;
          _.push(A, M), S.push(A, M + E), b = a.getItemVisual(w[C], "style");
        }
        var k, R = a.getItemLayout(w[0]), N = t.getModel("label"), I = N.get("margin"), L = t.getModel("emphasis");
        if (g === "add") {
          var P = p[m] = new Ce();
          k = new XN({
            shape: {
              points: _,
              stackedOnPoints: S,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: false
            },
            z2: 0
          }), P.add(k), s.add(P), t.isAnimationEnabled() && k.setClipPath(zte(k.getBoundingRect(), t, function() {
            k.removeClipPath();
          }));
        } else {
          var P = x[y];
          k = P.childAt(0), s.add(P), p[m] = P, it(k, {
            shape: {
              points: _,
              stackedOnPoints: S
            }
          }, t), li(k);
        }
        Sr(k, lr(t), {
          labelDataIndex: w[C - 1],
          defaultText: a.getName(w[C - 1]),
          inheritColor: b.fill
        }, {
          normal: {
            verticalAlign: "middle"
          }
        }), k.setTextConfig({
          position: null,
          local: true
        });
        var O = k.getTextContent();
        O && (O.x = R.x - I, O.y = R.y0 + R.y / 2), k.useStyle(b), a.setItemGraphicEl(m, k), br(k, t), Nt(k, L.get("focus"), L.get("blurScope"), L.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, e.type = "themeRiver", e;
  }(yt);
  function zte(r, e, t) {
    var n = new et({
      shape: {
        x: r.x - 10,
        y: r.y - 10,
        width: 0,
        height: r.height + 20
      }
    });
    return kt(n, {
      shape: {
        x: r.x - 50,
        width: r.width + 100,
        height: r.height + 20
      }
    }, e, t), n;
  }
  var Hy = 2, Vte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new kf(ne(this.getData, this), ne(this.getRawData, this));
    }, e.prototype.fixData = function(t) {
      var n = t.length, i = {}, a = Dx(t, function(f) {
        return i.hasOwnProperty(f[0] + "") || (i[f[0] + ""] = -1), f[2];
      }), o = [];
      a.buckets.each(function(f, d) {
        o.push({
          name: d,
          dataList: f
        });
      });
      for (var s = o.length, l = 0; l < s; ++l) {
        for (var u = o[l].name, c = 0; c < o[l].dataList.length; ++c) {
          var h = o[l].dataList[c][0] + "";
          i[h] = l;
        }
        for (var h in i) i.hasOwnProperty(h) && i[h] !== l && (i[h] = l, t[n] = [
          h,
          0,
          u
        ], n++);
      }
      return t;
    }, e.prototype.getInitialData = function(t, n) {
      for (var i = this.getReferringComponents("singleAxis", Yt).models[0], a = i.get("type"), o = ct(t.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(o || []), l = [], u = this.nameMap = ce(), c = 0, h = 0; h < s.length; ++h) l.push(s[h][Hy]), u.get(s[h][Hy]) || (u.set(s[h][Hy], c), c++);
      var f = Cf(s, {
        coordDimensions: [
          "single"
        ],
        dimensionsDefine: [
          {
            name: "time",
            type: iv(a)
          },
          {
            name: "value",
            type: "float"
          },
          {
            name: "name",
            type: "ordinal"
          }
        ],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, d = new Wr(f, this);
      return d.initData(s), d;
    }, e.prototype.getLayerSeries = function() {
      for (var t = this.getData(), n = t.count(), i = [], a = 0; a < n; ++a) i[a] = a;
      var o = t.mapDimension("single"), s = Dx(i, function(u) {
        return t.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(h, f) {
          return t.get(o, h) - t.get(o, f);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, e.prototype.getAxisTooltipData = function(t, n, i) {
      X(t) || (t = t ? [
        t
      ] : []);
      for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, c = 0; c < l; ++c) {
        for (var h = Number.MAX_VALUE, f = -1, d = o[c].indices.length, p = 0; p < d; ++p) {
          var v = a.get(t[0], o[c].indices[p]), g = Math.abs(v - n);
          g <= h && (u = v, h = g, f = o[c].indices[p]);
        }
        s.push(f);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, e.prototype.formatTooltip = function(t, n, i) {
      var a = this.getData(), o = a.getName(t), s = a.get(a.mapDimension("value"), t);
      return ur("nameValue", {
        name: o,
        value: s
      });
    }, e.type = "series.themeRiver", e.dependencies = [
      "singleAxis"
    ], e.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      boundaryGap: [
        "10%",
        "10%"
      ],
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: true,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }, e;
  }(Tt);
  function $te(r, e) {
    r.eachSeriesByType("themeRiver", function(t) {
      var n = t.getData(), i = t.coordinateSystem, a = {}, o = i.getRect();
      a.rect = o;
      var s = t.get("boundaryGap"), l = i.getAxis();
      if (a.boundaryGap = s, l.orient === "horizontal") {
        s[0] = Q(s[0], o.height), s[1] = Q(s[1], o.height);
        var u = o.height - s[0] - s[1];
        ZI(n, t, u);
      } else {
        s[0] = Q(s[0], o.width), s[1] = Q(s[1], o.width);
        var c = o.width - s[0] - s[1];
        ZI(n, t, c);
      }
      n.setLayout("layoutInfo", a);
    });
  }
  function ZI(r, e, t) {
    if (r.count()) for (var n = e.coordinateSystem, i = e.getLayerSeries(), a = r.mapDimension("single"), o = r.mapDimension("value"), s = K(i, function(g) {
      return K(g.indices, function(m) {
        var y = n.dataToPoint(r.get(a, m));
        return y[1] = r.get(o, m), y;
      });
    }), l = Gte(s), u = l.y0, c = t / l.max, h = i.length, f = i[0].indices.length, d, p = 0; p < f; ++p) {
      d = u[p] * c, r.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: d,
        y: s[0][p][1] * c
      });
      for (var v = 1; v < h; ++v) d += s[v - 1][p][1] * c, r.setItemLayout(i[v].indices[p], {
        layerIndex: v,
        x: s[v][p][0],
        y0: d,
        y: s[v][p][1] * c
      });
    }
  }
  function Gte(r) {
    for (var e = r.length, t = r[0].length, n = [], i = [], a = 0, o = 0; o < t; ++o) {
      for (var s = 0, l = 0; l < e; ++l) s += r[l][o][1];
      s > a && (a = s), n.push(s);
    }
    for (var u = 0; u < t; ++u) i[u] = (a - n[u]) / 2;
    a = 0;
    for (var c = 0; c < t; ++c) {
      var h = n[c] + i[c];
      h > a && (a = h);
    }
    return {
      y0: i,
      max: a
    };
  }
  function Wte(r) {
    r.registerChartView(Bte), r.registerSeriesModel(Vte), r.registerLayout($te), r.registerProcessor(Pf("themeRiver"));
  }
  var Ute = 2, Hte = 4, jI = function(r) {
    G(e, r);
    function e(t, n, i, a) {
      var o = r.call(this) || this;
      o.z2 = Ute, o.textConfig = {
        inside: true
      }, De(o).seriesIndex = n.seriesIndex;
      var s = new rt({
        z2: Hte,
        silent: t.getModel().get([
          "label",
          "silent"
        ])
      });
      return o.setTextContent(s), o.updateData(true, t, n, i, a), o;
    }
    return e.prototype.updateData = function(t, n, i, a, o) {
      this.node = n, n.piece = this, i = i || this._seriesModel, a = a || this._ecModel;
      var s = this;
      De(s).dataIndex = n.dataIndex;
      var l = n.getModel(), u = l.getModel("emphasis"), c = n.getLayout(), h = H({}, c);
      h.label = null;
      var f = n.getVisual("style");
      f.lineJoin = "bevel";
      var d = n.getVisual("decal");
      d && (f.decal = hu(d, o));
      var p = Ss(l.getModel("itemStyle"), h, true);
      H(h, p), D(Xr, function(y) {
        var x = s.ensureState(y), _ = l.getModel([
          y,
          "itemStyle"
        ]);
        x.style = _.getItemStyle();
        var S = Ss(_, h);
        S && (x.shape = S);
      }), t ? (s.setShape(h), s.shape.r = c.r0, kt(s, {
        shape: {
          r: c.r
        }
      }, i, n.dataIndex)) : (it(s, {
        shape: h
      }, i), li(s)), s.useStyle(f), this._updateLabel(i);
      var v = l.getShallow("cursor");
      v && s.attr("cursor", v), this._seriesModel = i || this._seriesModel, this._ecModel = a || this._ecModel;
      var g = u.get("focus"), m = g === "relative" ? _h(n.getAncestorsIndices(), n.getDescendantIndices()) : g === "ancestor" ? n.getAncestorsIndices() : g === "descendant" ? n.getDescendantIndices() : g;
      Nt(this, m, u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t) {
      var n = this, i = this.node.getModel(), a = i.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), h = this, f = h.getTextContent(), d = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, v = a.get("show") && !(p != null && Math.abs(s) < p);
      f.ignore = !v, D(Ah, function(m) {
        var y = m === "normal" ? i.getModel("label") : i.getModel([
          m,
          "label"
        ]), x = m === "normal", _ = x ? f : f.ensureState(m), S = t.getFormattedLabel(d, m);
        x && (S = S || n.node.name), _.style = wt(y, {}, null, m !== "normal", true), S && (_.style.text = S);
        var b = y.get("show");
        b != null && !x && (_.ignore = !b);
        var w = g(y, "position"), C = x ? h : h.states[m], T = C.style.fill;
        C.textConfig = {
          outsideFill: y.get("color") === "inherit" ? T : null,
          inside: w !== "outside"
        };
        var A, M = g(y, "distance") || 0, E = g(y, "align"), k = g(y, "rotate"), R = Math.PI * 0.5, N = Math.PI * 1.5, I = dn(k === "tangential" ? Math.PI / 2 - l : l), L = I > R && !Ch(I - R) && I < N;
        w === "outside" ? (A = o.r + M, E = L ? "right" : "left") : !E || E === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? A = 0 : A = (o.r + o.r0) / 2, E = "center") : E === "left" ? (A = o.r0 + M, E = L ? "right" : "left") : E === "right" && (A = o.r - M, E = L ? "left" : "right"), _.style.align = E, _.style.verticalAlign = g(y, "verticalAlign") || "middle", _.x = A * u + o.cx, _.y = A * c + o.cy;
        var P = 0;
        k === "radial" ? P = dn(-l) + (L ? Math.PI : 0) : k === "tangential" ? P = dn(Math.PI / 2 - l) + (L ? Math.PI : 0) : nt(k) && (P = k * Math.PI / 180), _.rotation = dn(P);
      });
      function g(m, y) {
        var x = m.get(y);
        return x ?? a.get(y);
      }
      f.dirtyStyle();
    }, e;
  }(qr), D_ = "sunburstRootToNode", QI = "sunburstHighlight", Yte = "sunburstUnhighlight";
  function Xte(r) {
    r.registerAction({
      type: D_,
      update: "updateView"
    }, function(e, t) {
      t.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: e
      }, n);
      function n(i, a) {
        var o = Vh(e, [
          D_
        ], i);
        if (o) {
          var s = i.getViewRoot();
          s && (e.direction = lS(s, o.node) ? "rollUp" : "drillDown"), i.resetViewRoot(o.node);
        }
      }
    }), r.registerAction({
      type: QI,
      update: "none"
    }, function(e, t, n) {
      e = H({}, e), t.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: e
      }, i);
      function i(a) {
        var o = Vh(e, [
          QI
        ], a);
        o && (e.dataIndex = o.node.dataIndex);
      }
      n.dispatchAction(H(e, {
        type: "highlight"
      }));
    }), r.registerAction({
      type: Yte,
      update: "updateView"
    }, function(e, t, n) {
      e = H({}, e), n.dispatchAction(H(e, {
        type: "downplay"
      }));
    });
  }
  var qte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      var o = this;
      this.seriesModel = t, this.api = i, this.ecModel = n;
      var s = t.getData(), l = s.tree.root, u = t.getViewRoot(), c = this.group, h = t.get("renderLabelForZeroData"), f = [];
      u.eachNode(function(y) {
        f.push(y);
      });
      var d = this._oldChildren || [];
      p(f, d), m(l, u), this._initEvents(), this._oldChildren = f;
      function p(y, x) {
        if (y.length === 0 && x.length === 0) return;
        new ya(x, y, _, _).add(S).update(S).remove(Le(S, null)).execute();
        function _(b) {
          return b.getId();
        }
        function S(b, w) {
          var C = b == null ? null : y[b], T = w == null ? null : x[w];
          v(C, T);
        }
      }
      function v(y, x) {
        if (!h && y && !y.getValue() && (y = null), y !== l && x !== l) {
          if (x && x.piece) y ? (x.piece.updateData(false, y, t, n, i), s.setItemGraphicEl(y.dataIndex, x.piece)) : g(x);
          else if (y) {
            var _ = new jI(y, t, n, i);
            c.add(_), s.setItemGraphicEl(y.dataIndex, _);
          }
        }
      }
      function g(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function m(y, x) {
        x.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(false, y, t, n, i) : (o.virtualPiece = new jI(y, t, n, i), c.add(o.virtualPiece)), x.piece.off("click"), o.virtualPiece.on("click", function(_) {
          o._rootToNode(x.parentNode);
        })) : o.virtualPiece && (c.remove(o.virtualPiece), o.virtualPiece = null);
      }
    }, e.prototype._initEvents = function() {
      var t = this;
      this.group.off("click"), this.group.on("click", function(n) {
        var i = false, a = t.seriesModel.getViewRoot();
        a.eachNode(function(o) {
          if (!i && o.piece && o.piece === n.target) {
            var s = o.getModel().get("nodeClick");
            if (s === "rootToNode") t._rootToNode(o);
            else if (s === "link") {
              var l = o.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", true) || "_blank";
                Zp(u, c);
              }
            }
            i = true;
          }
        });
      });
    }, e.prototype._rootToNode = function(t) {
      t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: D_,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t
      });
    }, e.prototype.containPoint = function(t, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "sunburst", e;
  }(yt), Kte = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreStyleOnData = true, t;
    }
    return e.prototype.getInitialData = function(t, n) {
      var i = {
        name: t.name,
        children: t.data
      };
      SF(i);
      var a = this._levelModels = K(t.levels || [], function(l) {
        return new ft(l, this, n);
      }, this), o = sS.createTree(i, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var h = o.getNodeByDataIndex(c), f = a[h.depth];
          return f && (u.parentModel = f), u;
        });
      }
      return o.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.getDataParams = function(t) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return n.treePathInfo = Tg(i, this), n;
    }, e.prototype.getLevelModel = function(t) {
      return this._levelModels && this._levelModels[t.depth];
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!t || t !== n && !n.contains(t)) && (this._viewRoot = n);
    }, e.prototype.enableAriaDecal = function() {
      IO(this);
    }, e.type = "series.sunburst", e.defaultOption = {
      z: 2,
      center: [
        "50%",
        "50%"
      ],
      radius: [
        0,
        "75%"
      ],
      clockwise: true,
      startAngle: 90,
      minAngle: 0,
      stillShowZeroSum: true,
      nodeClick: "rootToNode",
      renderLabelForZeroData: false,
      label: {
        rotate: "radial",
        show: true,
        opacity: 1,
        align: "center",
        position: "inside",
        distance: 5,
        silent: true
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      sort: "desc"
    }, e;
  }(Tt);
  function SF(r) {
    var e = 0;
    D(r.children, function(n) {
      SF(n);
      var i = n.value;
      X(i) && (i = i[0]), e += i;
    });
    var t = r.value;
    X(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), X(r.value) ? r.value[0] = t : r.value = t;
  }
  var JI = Math.PI / 180;
  function Zte(r, e, t) {
    e.eachSeriesByType(r, function(n) {
      var i = n.get("center"), a = n.get("radius");
      X(a) || (a = [
        0,
        a
      ]), X(i) || (i = [
        i,
        i
      ]);
      var o = t.getWidth(), s = t.getHeight(), l = Math.min(o, s), u = Q(i[0], o), c = Q(i[1], s), h = Q(a[0], l / 2), f = Q(a[1], l / 2), d = -n.get("startAngle") * JI, p = n.get("minAngle") * JI, v = n.getData().tree.root, g = n.getViewRoot(), m = g.depth, y = n.get("sort");
      y != null && wF(g, y);
      var x = 0;
      D(g.children, function(I) {
        !isNaN(I.getValue()) && x++;
      });
      var _ = g.getValue(), S = Math.PI / (_ || x) * 2, b = g.depth > 0, w = g.height - (b ? -1 : 1), C = (f - h) / (w || 1), T = n.get("clockwise"), A = n.get("stillShowZeroSum"), M = T ? 1 : -1, E = function(I, L) {
        if (I) {
          var P = L;
          if (I !== v) {
            var O = I.getValue(), F = _ === 0 && A ? S : O * S;
            F < p && (F = p), P = L + M * F;
            var B = I.depth - m - (b ? -1 : 1), V = h + C * B, U = h + C * (B + 1), Y = n.getLevelModel(I);
            if (Y) {
              var q = Y.get("r0", true), me = Y.get("r", true), Me = Y.get("radius", true);
              Me != null && (q = Me[0], me = Me[1]), q != null && (V = Q(q, l / 2)), me != null && (U = Q(me, l / 2));
            }
            I.setLayout({
              angle: F,
              startAngle: L,
              endAngle: P,
              clockwise: T,
              cx: u,
              cy: c,
              r0: V,
              r: U
            });
          }
          if (I.children && I.children.length) {
            var re = 0;
            D(I.children, function(J) {
              re += E(J, L + re);
            });
          }
          return P - L;
        }
      };
      if (b) {
        var k = h, R = h + C, N = Math.PI * 2;
        v.setLayout({
          angle: N,
          startAngle: d,
          endAngle: d + N,
          clockwise: T,
          cx: u,
          cy: c,
          r0: k,
          r: R
        });
      }
      E(g, d);
    });
  }
  function wF(r, e) {
    var t = r.children || [];
    r.children = jte(t, e), t.length && D(r.children, function(n) {
      wF(n, e);
    });
  }
  function jte(r, e) {
    if (ge(e)) {
      var t = K(r, function(i, a) {
        var o = i.getValue();
        return {
          params: {
            depth: i.depth,
            height: i.height,
            dataIndex: i.dataIndex,
            getValue: function() {
              return o;
            }
          },
          index: a
        };
      });
      return t.sort(function(i, a) {
        return e(i.params, a.params);
      }), K(t, function(i) {
        return r[i.index];
      });
    } else {
      var n = e === "asc";
      return r.sort(function(i, a) {
        var o = (i.getValue() - a.getValue()) * (n ? 1 : -1);
        return o === 0 ? (i.dataIndex - a.dataIndex) * (n ? -1 : 1) : o;
      });
    }
  }
  function Qte(r) {
    var e = {};
    function t(n, i, a) {
      for (var o = n; o && o.depth > 1; ) o = o.parentNode;
      var s = i.getColorFromPalette(o.name || o.dataIndex + "", e);
      return n.depth > 1 && ee(s) && (s = gx(s, (n.depth - 1) / (a - 1) * 0.5)), s;
    }
    r.eachSeriesByType("sunburst", function(n) {
      var i = n.getData(), a = i.tree;
      a.eachNode(function(o) {
        var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
        l.fill || (l.fill = t(o, n, a.root.height));
        var u = i.ensureUniqueItemVisual(o.dataIndex, "style");
        H(u, l);
      });
    });
  }
  function Jte(r) {
    r.registerChartView(qte), r.registerSeriesModel(Kte), r.registerLayout(Le(Zte, "sunburst")), r.registerProcessor(Le(Pf, "sunburst")), r.registerVisual(Qte), Xte(r);
  }
  var eM = {
    color: "fill",
    borderColor: "stroke"
  }, ere = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1
  }, ua = tt(), tre = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", true), this.currentZ = this.get("z", true);
    }, e.prototype.getInitialData = function(t, n) {
      return Aa(null, this);
    }, e.prototype.getDataParams = function(t, n, i) {
      var a = r.prototype.getDataParams.call(this, t, n);
      return i && (a.info = ua(i).info), a;
    }, e.type = "series.custom", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      clip: false
    }, e;
  }(Tt);
  function rre(r, e) {
    return e = e || [
      0,
      0
    ], K([
      "x",
      "y"
    ], function(t, n) {
      var i = this.getAxis(t), a = e[n], o = r[n] / 2;
      return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(a - o) - i.dataToCoord(a + o));
    }, this);
  }
  function nre(r) {
    var e = r.master.getRect();
    return {
      coordSys: {
        type: "cartesian2d",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      api: {
        coord: function(t) {
          return r.dataToPoint(t);
        },
        size: ne(rre, r)
      }
    };
  }
  function ire(r, e) {
    return e = e || [
      0,
      0
    ], K([
      0,
      1
    ], function(t) {
      var n = e[t], i = r[t] / 2, a = [], o = [];
      return a[t] = n - i, o[t] = n + i, a[1 - t] = o[1 - t] = e[1 - t], Math.abs(this.dataToPoint(a)[t] - this.dataToPoint(o)[t]);
    }, this);
  }
  function are(r) {
    var e = r.getBoundingRect();
    return {
      coordSys: {
        type: "geo",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height,
        zoom: r.getZoom()
      },
      api: {
        coord: function(t) {
          return r.dataToPoint(t);
        },
        size: ne(ire, r)
      }
    };
  }
  function ore(r, e) {
    var t = this.getAxis(), n = e instanceof Array ? e[0] : e, i = (r instanceof Array ? r[0] : r) / 2;
    return t.type === "category" ? t.getBandWidth() : Math.abs(t.dataToCoord(n - i) - t.dataToCoord(n + i));
  }
  function sre(r) {
    var e = r.getRect();
    return {
      coordSys: {
        type: "singleAxis",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      api: {
        coord: function(t) {
          return r.dataToPoint(t);
        },
        size: ne(ore, r)
      }
    };
  }
  function lre(r, e) {
    return e = e || [
      0,
      0
    ], K([
      "Radius",
      "Angle"
    ], function(t, n) {
      var i = "get" + t + "Axis", a = this[i](), o = e[n], s = r[n] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
      return t === "Angle" && (l = l * Math.PI / 180), l;
    }, this);
  }
  function ure(r) {
    var e = r.getRadiusAxis(), t = r.getAngleAxis(), n = e.getExtent();
    return n[0] > n[1] && n.reverse(), {
      coordSys: {
        type: "polar",
        cx: r.cx,
        cy: r.cy,
        r: n[1],
        r0: n[0]
      },
      api: {
        coord: function(i) {
          var a = e.dataToRadius(i[0]), o = t.dataToAngle(i[1]), s = r.coordToPoint([
            a,
            o
          ]);
          return s.push(a, o * Math.PI / 180), s;
        },
        size: ne(lre, r)
      }
    };
  }
  function cre(r) {
    var e = r.getRect(), t = r.getRangeInfo();
    return {
      coordSys: {
        type: "calendar",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height,
        cellWidth: r.getCellWidth(),
        cellHeight: r.getCellHeight(),
        rangeInfo: {
          start: t.start,
          end: t.end,
          weeks: t.weeks,
          dayCount: t.allDay
        }
      },
      api: {
        coord: function(n, i) {
          return r.dataToPoint(n, i);
        }
      }
    };
  }
  function CF(r, e, t, n) {
    return r && (r.legacy || r.legacy !== false && !t && !n && e !== "tspan" && (e === "text" || oe(r, "text")));
  }
  function TF(r, e, t) {
    var n = r, i, a, o;
    if (e === "text") o = n;
    else {
      o = {}, oe(n, "text") && (o.text = n.text), oe(n, "rich") && (o.rich = n.rich), oe(n, "textFill") && (o.fill = n.textFill), oe(n, "textStroke") && (o.stroke = n.textStroke), oe(n, "fontFamily") && (o.fontFamily = n.fontFamily), oe(n, "fontSize") && (o.fontSize = n.fontSize), oe(n, "fontStyle") && (o.fontStyle = n.fontStyle), oe(n, "fontWeight") && (o.fontWeight = n.fontWeight), a = {
        type: "text",
        style: o,
        silent: true
      }, i = {};
      var s = oe(n, "textPosition");
      t ? i.position = s ? n.textPosition : "inside" : s && (i.position = n.textPosition), oe(n, "textPosition") && (i.position = n.textPosition), oe(n, "textOffset") && (i.offset = n.textOffset), oe(n, "textRotation") && (i.rotation = n.textRotation), oe(n, "textDistance") && (i.distance = n.textDistance);
    }
    return tM(o, r), D(o.rich, function(l) {
      tM(l, l);
    }), {
      textConfig: i,
      textContent: a
    };
  }
  function tM(r, e) {
    e && (e.font = e.textFont || e.font, oe(e, "textStrokeWidth") && (r.lineWidth = e.textStrokeWidth), oe(e, "textAlign") && (r.align = e.textAlign), oe(e, "textVerticalAlign") && (r.verticalAlign = e.textVerticalAlign), oe(e, "textLineHeight") && (r.lineHeight = e.textLineHeight), oe(e, "textWidth") && (r.width = e.textWidth), oe(e, "textHeight") && (r.height = e.textHeight), oe(e, "textBackgroundColor") && (r.backgroundColor = e.textBackgroundColor), oe(e, "textPadding") && (r.padding = e.textPadding), oe(e, "textBorderColor") && (r.borderColor = e.textBorderColor), oe(e, "textBorderWidth") && (r.borderWidth = e.textBorderWidth), oe(e, "textBorderRadius") && (r.borderRadius = e.textBorderRadius), oe(e, "textBoxShadowColor") && (r.shadowColor = e.textBoxShadowColor), oe(e, "textBoxShadowBlur") && (r.shadowBlur = e.textBoxShadowBlur), oe(e, "textBoxShadowOffsetX") && (r.shadowOffsetX = e.textBoxShadowOffsetX), oe(e, "textBoxShadowOffsetY") && (r.shadowOffsetY = e.textBoxShadowOffsetY));
  }
  function rM(r, e, t) {
    var n = r;
    n.textPosition = n.textPosition || t.position || "inside", t.offset != null && (n.textOffset = t.offset), t.rotation != null && (n.textRotation = t.rotation), t.distance != null && (n.textDistance = t.distance);
    var i = n.textPosition.indexOf("inside") >= 0, a = r.fill || "#000";
    nM(n, e);
    var o = n.textFill == null;
    return i ? o && (n.textFill = t.insideFill || "#fff", !n.textStroke && t.insideStroke && (n.textStroke = t.insideStroke), !n.textStroke && (n.textStroke = a), n.textStrokeWidth == null && (n.textStrokeWidth = 2)) : (o && (n.textFill = r.fill || t.outsideFill || "#000"), !n.textStroke && t.outsideStroke && (n.textStroke = t.outsideStroke)), n.text = e.text, n.rich = e.rich, D(e.rich, function(s) {
      nM(s, s);
    }), n;
  }
  function nM(r, e) {
    e && (oe(e, "fill") && (r.textFill = e.fill), oe(e, "stroke") && (r.textStroke = e.fill), oe(e, "lineWidth") && (r.textStrokeWidth = e.lineWidth), oe(e, "font") && (r.font = e.font), oe(e, "fontStyle") && (r.fontStyle = e.fontStyle), oe(e, "fontWeight") && (r.fontWeight = e.fontWeight), oe(e, "fontSize") && (r.fontSize = e.fontSize), oe(e, "fontFamily") && (r.fontFamily = e.fontFamily), oe(e, "align") && (r.textAlign = e.align), oe(e, "verticalAlign") && (r.textVerticalAlign = e.verticalAlign), oe(e, "lineHeight") && (r.textLineHeight = e.lineHeight), oe(e, "width") && (r.textWidth = e.width), oe(e, "height") && (r.textHeight = e.height), oe(e, "backgroundColor") && (r.textBackgroundColor = e.backgroundColor), oe(e, "padding") && (r.textPadding = e.padding), oe(e, "borderColor") && (r.textBorderColor = e.borderColor), oe(e, "borderWidth") && (r.textBorderWidth = e.borderWidth), oe(e, "borderRadius") && (r.textBorderRadius = e.borderRadius), oe(e, "shadowColor") && (r.textBoxShadowColor = e.shadowColor), oe(e, "shadowBlur") && (r.textBoxShadowBlur = e.shadowBlur), oe(e, "shadowOffsetX") && (r.textBoxShadowOffsetX = e.shadowOffsetX), oe(e, "shadowOffsetY") && (r.textBoxShadowOffsetY = e.shadowOffsetY), oe(e, "textShadowColor") && (r.textShadowColor = e.textShadowColor), oe(e, "textShadowBlur") && (r.textShadowBlur = e.textShadowBlur), oe(e, "textShadowOffsetX") && (r.textShadowOffsetX = e.textShadowOffsetX), oe(e, "textShadowOffsetY") && (r.textShadowOffsetY = e.textShadowOffsetY));
  }
  var AF = {
    position: [
      "x",
      "y"
    ],
    scale: [
      "scaleX",
      "scaleY"
    ],
    origin: [
      "originX",
      "originY"
    ]
  }, iM = je(AF);
  Fi(zi, function(r, e) {
    return r[e] = 1, r;
  }, {});
  zi.join(", ");
  var gv = [
    "",
    "style",
    "shape",
    "extra"
  ], gu = tt();
  function TS(r, e, t, n, i) {
    var a = r + "Animation", o = Ru(r, n, i) || {}, s = gu(e).userDuring;
    return o.duration > 0 && (o.during = s ? ne(vre, {
      el: e,
      userDuring: s
    }) : null, o.setToFinal = true, o.scope = r), H(o, t[a]), o;
  }
  function Tp(r, e, t, n) {
    n = n || {};
    var i = n.dataIndex, a = n.isInit, o = n.clearStyle, s = t.isAnimationEnabled(), l = gu(r), u = e.style;
    l.userDuring = e.during;
    var c = {}, h = {};
    if (mre(r, e, h), oM("shape", e, h), oM("extra", e, h), !a && s && (gre(r, e, c), aM("shape", r, e, c), aM("extra", r, e, c), yre(r, e, u, c)), h.style = u, hre(r, h, o), dre(r, e), s) if (a) {
      var f = {};
      D(gv, function(p) {
        var v = p ? e[p] : e;
        v && v.enterFrom && (p && (f[p] = f[p] || {}), H(p ? f[p] : f, v.enterFrom));
      });
      var d = TS("enter", r, e, t, i);
      d.duration > 0 && r.animateFrom(f, d);
    } else fre(r, e, i || 0, t, c);
    IF(r, e), u ? r.dirty() : r.markRedraw();
  }
  function IF(r, e) {
    for (var t = gu(r).leaveToProps, n = 0; n < gv.length; n++) {
      var i = gv[n], a = i ? e[i] : e;
      a && a.leaveTo && (t || (t = gu(r).leaveToProps = {}), i && (t[i] = t[i] || {}), H(i ? t[i] : t, a.leaveTo));
    }
  }
  function Mg(r, e, t, n) {
    if (r) {
      var i = r.parent, a = gu(r).leaveToProps;
      if (a) {
        var o = TS("update", r, e, t, 0);
        o.done = function() {
          i.remove(r);
        }, r.animateTo(a, o);
      } else i.remove(r);
    }
  }
  function Es(r) {
    return r === "all";
  }
  function hre(r, e, t) {
    var n = e.style;
    if (!r.isGroup && n) {
      if (t) {
        r.useStyle({});
        for (var i = r.animators, a = 0; a < i.length; a++) {
          var o = i[a];
          o.targetName === "style" && o.changeTarget(r.style);
        }
      }
      r.setStyle(n);
    }
    e && (e.style = null, e && r.attr(e), e.style = n);
  }
  function fre(r, e, t, n, i) {
    if (i) {
      var a = TS("update", r, e, n, t);
      a.duration > 0 && r.animateFrom(i, a);
    }
  }
  function dre(r, e) {
    oe(e, "silent") && (r.silent = e.silent), oe(e, "ignore") && (r.ignore = e.ignore), r instanceof zn && oe(e, "invisible") && (r.invisible = e.invisible), r instanceof Ue && oe(e, "autoBatch") && (r.autoBatch = e.autoBatch);
  }
  var _i = {}, pre = {
    setTransform: function(r, e) {
      return _i.el[r] = e, this;
    },
    getTransform: function(r) {
      return _i.el[r];
    },
    setShape: function(r, e) {
      var t = _i.el, n = t.shape || (t.shape = {});
      return n[r] = e, t.dirtyShape && t.dirtyShape(), this;
    },
    getShape: function(r) {
      var e = _i.el.shape;
      if (e) return e[r];
    },
    setStyle: function(r, e) {
      var t = _i.el, n = t.style;
      return n && (n[r] = e, t.dirtyStyle && t.dirtyStyle()), this;
    },
    getStyle: function(r) {
      var e = _i.el.style;
      if (e) return e[r];
    },
    setExtra: function(r, e) {
      var t = _i.el.extra || (_i.el.extra = {});
      return t[r] = e, this;
    },
    getExtra: function(r) {
      var e = _i.el.extra;
      if (e) return e[r];
    }
  };
  function vre() {
    var r = this, e = r.el;
    if (e) {
      var t = gu(e).userDuring, n = r.userDuring;
      if (t !== n) {
        r.el = r.userDuring = null;
        return;
      }
      _i.el = e, n(pre);
    }
  }
  function aM(r, e, t, n) {
    var i = t[r];
    if (i) {
      var a = e[r], o;
      if (a) {
        var s = t.transition, l = i.transition;
        if (l) if (!o && (o = n[r] = {}), Es(l)) H(o, a);
        else for (var u = gt(l), c = 0; c < u.length; c++) {
          var h = u[c], f = a[h];
          o[h] = f;
        }
        else if (Es(s) || Be(s, r) >= 0) {
          !o && (o = n[r] = {});
          for (var d = je(a), c = 0; c < d.length; c++) {
            var h = d[c], f = a[h];
            xre(i[h], f) && (o[h] = f);
          }
        }
      }
    }
  }
  function oM(r, e, t) {
    var n = e[r];
    if (n) for (var i = t[r] = {}, a = je(n), o = 0; o < a.length; o++) {
      var s = a[o];
      i[s] = Zc(n[s]);
    }
  }
  function gre(r, e, t) {
    for (var n = e.transition, i = Es(n) ? zi : gt(n || []), a = 0; a < i.length; a++) {
      var o = i[a];
      if (!(o === "style" || o === "shape" || o === "extra")) {
        var s = r[o];
        t[o] = s;
      }
    }
  }
  function mre(r, e, t) {
    for (var n = 0; n < iM.length; n++) {
      var i = iM[n], a = AF[i], o = e[i];
      o && (t[a[0]] = o[0], t[a[1]] = o[1]);
    }
    for (var n = 0; n < zi.length; n++) {
      var s = zi[n];
      e[s] != null && (t[s] = e[s]);
    }
  }
  function yre(r, e, t, n) {
    if (t) {
      var i = r.style, a;
      if (i) {
        var o = t.transition, s = e.transition;
        if (o && !Es(o)) {
          var l = gt(o);
          !a && (a = n.style = {});
          for (var u = 0; u < l.length; u++) {
            var c = l[u], h = i[c];
            a[c] = h;
          }
        } else if (r.getAnimationStyleProps && (Es(s) || Es(o) || Be(s, "style") >= 0)) {
          var f = r.getAnimationStyleProps(), d = f ? f.style : null;
          if (d) {
            !a && (a = n.style = {});
            for (var p = je(t), u = 0; u < p.length; u++) {
              var c = p[u];
              if (d[c]) {
                var h = i[c];
                a[c] = h;
              }
            }
          }
        }
      }
    }
  }
  function xre(r, e) {
    return Lr(r) ? r !== e : r != null && isFinite(r);
  }
  var MF = tt(), _re = [
    "percent",
    "easing",
    "shape",
    "style",
    "extra"
  ];
  function DF(r) {
    r.stopAnimation("keyframe"), r.attr(MF(r));
  }
  function mv(r, e, t) {
    if (!(!t.isAnimationEnabled() || !e)) {
      if (X(e)) {
        D(e, function(s) {
          mv(r, s, t);
        });
        return;
      }
      var n = e.keyframes, i = e.duration;
      if (t && i == null) {
        var a = Ru("enter", t, 0);
        i = a && a.duration;
      }
      if (!(!n || !i)) {
        var o = MF(r);
        D(gv, function(s) {
          if (!(s && !r[s])) {
            var l;
            n.sort(function(u, c) {
              return u.percent - c.percent;
            }), D(n, function(u) {
              var c = r.animators, h = s ? u[s] : u;
              if (h) {
                var f = je(h);
                if (s || (f = ct(f, function(v) {
                  return Be(_re, v) < 0;
                })), !!f.length) {
                  l || (l = r.animate(s, e.loop, true), l.scope = "keyframe");
                  for (var d = 0; d < c.length; d++) c[d] !== l && c[d].targetName === l.targetName && c[d].stopTracks(f);
                  s && (o[s] = o[s] || {});
                  var p = s ? o[s] : o;
                  D(f, function(v) {
                    p[v] = ((s ? r[s] : r) || {})[v];
                  }), l.whenWithKeys(i * u.percent, h, f, u.easing);
                }
              }
            }), l && l.delay(e.delay || 0).duration(i).start(e.easing);
          }
        });
      }
    }
  }
  var ca = "emphasis", Qa = "normal", AS = "blur", IS = "select", po = [
    Qa,
    ca,
    AS,
    IS
  ], Yy = {
    normal: [
      "itemStyle"
    ],
    emphasis: [
      ca,
      "itemStyle"
    ],
    blur: [
      AS,
      "itemStyle"
    ],
    select: [
      IS,
      "itemStyle"
    ]
  }, Xy = {
    normal: [
      "label"
    ],
    emphasis: [
      ca,
      "label"
    ],
    blur: [
      AS,
      "label"
    ],
    select: [
      IS,
      "label"
    ]
  }, bre = [
    "x",
    "y"
  ], Sre = "e\0\0", Tn = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {}
  }, wre = {
    cartesian2d: nre,
    geo: are,
    single: sre,
    polar: ure,
    calendar: cre
  };
  function P_(r) {
    return r instanceof Ue;
  }
  function k_(r) {
    return r instanceof zn;
  }
  function Cre(r, e) {
    e.copyTransform(r), k_(e) && k_(r) && (e.setStyle(r.style), e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel, e.invisible = r.invisible, e.ignore = r.ignore, P_(e) && P_(r) && e.setShape(r.shape));
  }
  var Tre = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this._progressiveEls = null;
      var o = this._data, s = t.getData(), l = this.group, u = sM(t, s, n, i);
      o || l.removeAll(), s.diff(o).add(function(h) {
        qy(i, null, h, u(h, a), t, l, s);
      }).remove(function(h) {
        var f = o.getItemGraphicEl(h);
        f && Mg(f, ua(f).option, t);
      }).update(function(h, f) {
        var d = o.getItemGraphicEl(f);
        qy(i, d, h, u(h, a), t, l, s);
      }).execute();
      var c = t.get("clip", true) ? Mf(t.coordinateSystem, false, t) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, n, i) {
      this.group.removeAll(), this._data = null;
    }, e.prototype.incrementalRender = function(t, n, i, a, o) {
      var s = n.getData(), l = sM(n, s, i, a), u = this._progressiveEls = [];
      function c(d) {
        d.isGroup || (d.incremental = true, d.ensureState("emphasis").hoverLayer = true);
      }
      for (var h = t.start; h < t.end; h++) {
        var f = qy(null, null, h, l(h, o), n, this.group, s);
        f && (f.traverse(c), u.push(f));
      }
    }, e.prototype.eachRendered = function(t) {
      mo(this._progressiveEls || this.group, t);
    }, e.prototype.filterForExposedEvent = function(t, n, i, a) {
      var o = n.element;
      if (o == null || i.name === o) return true;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; ) if (i.name === o) return true;
      return false;
    }, e.type = "custom", e;
  }(yt);
  function MS(r) {
    var e = r.type, t;
    if (e === "path") {
      var n = r.shape, i = n.width != null && n.height != null ? {
        x: n.x || 0,
        y: n.y || 0,
        width: n.width,
        height: n.height
      } : null, a = LF(n);
      t = ig(a, null, i, n.layout || "center"), ua(t).customPathData = a;
    } else if (e === "image") t = new mr({}), ua(t).customImagePath = r.style.image;
    else if (e === "text") t = new rt({});
    else if (e === "group") t = new Ce();
    else {
      if (e === "compoundPath") throw new Error('"compoundPath" is not supported yet.');
      var o = g1(e);
      if (!o) {
        var s = "";
        ut(s);
      }
      t = new o();
    }
    return ua(t).customGraphicType = e, t.name = r.name, t.z2EmphasisLift = 1, t.z2SelectLift = 1, t;
  }
  function DS(r, e, t, n, i, a, o) {
    DF(e);
    var s = i && i.normal.cfg;
    s && e.setTextConfig(s), n && n.transition == null && (n.transition = bre);
    var l = n && n.style;
    if (l) {
      if (e.type === "text") {
        var u = l;
        oe(u, "textFill") && (u.fill = u.textFill), oe(u, "textStroke") && (u.stroke = u.textStroke);
      }
      var c = void 0, h = P_(e) ? l.decal : null;
      r && h && (h.dirty = true, c = hu(h, r)), l.__decalPattern = c;
    }
    if (k_(e) && l) {
      var c = l.__decalPattern;
      c && (l.decal = c);
    }
    Tp(e, n, a, {
      dataIndex: t,
      isInit: o,
      clearStyle: true
    }), mv(e, n.keyframeAnimation, a);
  }
  function PF(r, e, t, n, i) {
    var a = e.isGroup ? null : e, o = i && i[r].cfg;
    if (a) {
      var s = a.ensureState(r);
      if (n === false) {
        var l = a.getState(r);
        l && (l.style = null);
      } else s.style = n || null;
      o && (s.textConfig = o), $s(a);
    }
  }
  function Are(r, e, t) {
    if (!r.isGroup) {
      var n = r, i = t.currentZ, a = t.currentZLevel;
      n.z = i, n.zlevel = a;
      var o = e.z2;
      o != null && (n.z2 = o || 0);
      for (var s = 0; s < po.length; s++) Ire(n, e, po[s]);
    }
  }
  function Ire(r, e, t) {
    var n = t === Qa, i = n ? e : yv(e, t), a = i ? i.z2 : null, o;
    a != null && (o = n ? r : r.ensureState(t), o.z2 = a || 0);
  }
  function sM(r, e, t, n) {
    var i = r.get("renderItem"), a = r.coordinateSystem, o = {};
    a && (o = a.prepareCustoms ? a.prepareCustoms(a) : wre[a.type](a));
    for (var s = ye({
      getWidth: n.getWidth,
      getHeight: n.getHeight,
      getZr: n.getZr,
      getDevicePixelRatio: n.getDevicePixelRatio,
      value: _,
      style: b,
      ordinalRawValue: S,
      styleEmphasis: w,
      visual: A,
      barLayout: M,
      currentSeriesIndices: E,
      font: k
    }, o.api || {}), l = {
      context: {},
      seriesId: r.id,
      seriesName: r.name,
      seriesIndex: r.seriesIndex,
      coordSys: o.coordSys,
      dataInsideLength: e.count(),
      encode: Mre(r.getData())
    }, u, c, h = {}, f = {}, d = {}, p = {}, v = 0; v < po.length; v++) {
      var g = po[v];
      d[g] = r.getModel(Yy[g]), p[g] = r.getModel(Xy[g]);
    }
    function m(R) {
      return R === u ? c || (c = e.getItemModel(R)) : e.getItemModel(R);
    }
    function y(R, N) {
      return e.hasItemOption ? R === u ? h[N] || (h[N] = m(R).getModel(Yy[N])) : m(R).getModel(Yy[N]) : d[N];
    }
    function x(R, N) {
      return e.hasItemOption ? R === u ? f[N] || (f[N] = m(R).getModel(Xy[N])) : m(R).getModel(Xy[N]) : p[N];
    }
    return function(R, N) {
      return u = R, c = null, h = {}, f = {}, i && i(ye({
        dataIndexInside: R,
        dataIndex: e.getRawIndex(R),
        actionType: N ? N.type : null
      }, l), s);
    };
    function _(R, N) {
      return N == null && (N = u), e.getStore().get(e.getDimensionIndex(R || 0), N);
    }
    function S(R, N) {
      N == null && (N = u), R = R || 0;
      var I = e.getDimensionInfo(R);
      if (!I) {
        var L = e.getDimensionIndex(R);
        return L >= 0 ? e.getStore().get(L, N) : void 0;
      }
      var P = e.get(I.name, N), O = I && I.ordinalMeta;
      return O ? O.categories[P] : P;
    }
    function b(R, N) {
      N == null && (N = u);
      var I = e.getItemVisual(N, "style"), L = I && I.fill, P = I && I.opacity, O = y(N, Qa).getItemStyle();
      L != null && (O.fill = L), P != null && (O.opacity = P);
      var F = {
        inheritColor: ee(L) ? L : "#000"
      }, B = x(N, Qa), V = wt(B, null, F, false, true);
      V.text = B.getShallow("show") ? Pe(r.getFormattedLabel(N, Qa), du(e, N)) : null;
      var U = qp(B, F, false);
      return T(R, O), O = rM(O, V, U), R && C(O, R), O.legacy = true, O;
    }
    function w(R, N) {
      N == null && (N = u);
      var I = y(N, ca).getItemStyle(), L = x(N, ca), P = wt(L, null, null, true, true);
      P.text = L.getShallow("show") ? Li(r.getFormattedLabel(N, ca), r.getFormattedLabel(N, Qa), du(e, N)) : null;
      var O = qp(L, null, true);
      return T(R, I), I = rM(I, P, O), R && C(I, R), I.legacy = true, I;
    }
    function C(R, N) {
      for (var I in N) oe(N, I) && (R[I] = N[I]);
    }
    function T(R, N) {
      R && (R.textFill && (N.textFill = R.textFill), R.textPosition && (N.textPosition = R.textPosition));
    }
    function A(R, N) {
      if (N == null && (N = u), oe(eM, R)) {
        var I = e.getItemVisual(N, "style");
        return I ? I[eM[R]] : null;
      }
      if (oe(ere, R)) return e.getItemVisual(N, R);
    }
    function M(R) {
      if (a.type === "cartesian2d") {
        var N = a.getBaseAxis();
        return m7(ye({
          axis: N
        }, R));
      }
    }
    function E() {
      return t.getCurrentSeriesIndices();
    }
    function k(R) {
      return m1(R, t);
    }
  }
  function Mre(r) {
    var e = {};
    return D(r.dimensions, function(t) {
      var n = r.getDimensionInfo(t);
      if (!n.isExtraCoord) {
        var i = n.coordDim, a = e[i] = e[i] || [];
        a[n.coordDimIndex] = r.getDimensionIndex(t);
      }
    }), e;
  }
  function qy(r, e, t, n, i, a, o) {
    if (!n) {
      a.remove(e);
      return;
    }
    var s = PS(r, e, t, n, i, a);
    return s && o.setItemGraphicEl(t, s), s && Nt(s, n.focus, n.blurScope, n.emphasisDisabled), s;
  }
  function PS(r, e, t, n, i, a) {
    var o = -1, s = e;
    e && kF(e, n, i) && (o = Be(a.childrenRef(), e), e = null);
    var l = !e, u = e;
    u ? u.clearStates() : (u = MS(n), s && Cre(s, u)), n.morph === false ? u.disableMorphing = true : u.disableMorphing && (u.disableMorphing = false), Tn.normal.cfg = Tn.normal.conOpt = Tn.emphasis.cfg = Tn.emphasis.conOpt = Tn.blur.cfg = Tn.blur.conOpt = Tn.select.cfg = Tn.select.conOpt = null, Tn.isLegacy = false, Pre(u, t, n, i, l, Tn), Dre(u, t, n, i, l), DS(r, u, t, n, Tn, i, l), oe(n, "info") && (ua(u).info = n.info);
    for (var c = 0; c < po.length; c++) {
      var h = po[c];
      if (h !== Qa) {
        var f = yv(n, h), d = kS(n, f, h);
        PF(h, u, f, d, Tn);
      }
    }
    return Are(u, n, i), n.type === "group" && kre(r, u, t, n, i), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
  }
  function kF(r, e, t) {
    var n = ua(r), i = e.type, a = e.shape, o = e.style;
    return t.isUniversalTransitionEnabled() || i != null && i !== n.customGraphicType || i === "path" && Nre(a) && LF(a) !== n.customPathData || i === "image" && oe(o, "image") && o.image !== n.customImagePath;
  }
  function Dre(r, e, t, n, i) {
    var a = t.clipPath;
    if (a === false) r && r.getClipPath() && r.removeClipPath();
    else if (a) {
      var o = r.getClipPath();
      o && kF(o, a, n) && (o = null), o || (o = MS(a), r.setClipPath(o)), DS(null, o, e, a, null, n, i);
    }
  }
  function Pre(r, e, t, n, i, a) {
    if (!r.isGroup) {
      lM(t, null, a), lM(t, ca, a);
      var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
      if (o != null || s != null || u != null || l != null) {
        var c = r.getTextContent();
        if (o === false) c && r.removeTextContent();
        else {
          o = a.normal.conOpt = o || {
            type: "text"
          }, c ? c.clearStates() : (c = MS(o), r.setTextContent(c)), DS(null, c, e, o, null, n, i);
          for (var h = o && o.style, f = 0; f < po.length; f++) {
            var d = po[f];
            if (d !== Qa) {
              var p = a[d].conOpt;
              PF(d, c, p, kS(o, p, d), null);
            }
          }
          h ? c.dirty() : c.markRedraw();
        }
      }
    }
  }
  function lM(r, e, t) {
    var n = e ? yv(r, e) : r, i = e ? kS(r, n, ca) : r.style, a = r.type, o = n ? n.textConfig : null, s = r.textContent, l = s ? e ? yv(s, e) : s : null;
    if (i && (t.isLegacy || CF(i, a, !!o, !!l))) {
      t.isLegacy = true;
      var u = TF(i, a, !e);
      !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
    }
    if (!e && l) {
      var c = l;
      !c.type && (c.type = "text");
    }
    var h = e ? t[e] : t.normal;
    h.cfg = o, h.conOpt = l;
  }
  function yv(r, e) {
    return e ? r ? r[e] : null : r;
  }
  function kS(r, e, t) {
    var n = e && e.style;
    return n == null && t === ca && r && (n = r.styleEmphasis), n;
  }
  function kre(r, e, t, n, i) {
    var a = n.children, o = a ? a.length : 0, s = n.$mergeChildren, l = s === "byName" || n.diffChildrenByName, u = s === false;
    if (!(!o && !l && !u)) {
      if (l) {
        Rre({
          api: r,
          oldChildren: e.children() || [],
          newChildren: a || [],
          dataIndex: t,
          seriesModel: i,
          group: e
        });
        return;
      }
      u && e.removeAll();
      for (var c = 0; c < o; c++) {
        var h = a[c], f = e.childAt(c);
        h ? (h.ignore == null && (h.ignore = false), PS(r, f, t, h, i, e)) : f.ignore = true;
      }
      for (var d = e.childCount() - 1; d >= c; d--) {
        var p = e.childAt(d);
        Lre(e, p, i);
      }
    }
  }
  function Lre(r, e, t) {
    e && Mg(e, ua(r).option, t);
  }
  function Rre(r) {
    new ya(r.oldChildren, r.newChildren, uM, uM, r).add(cM).update(cM).remove(Ere).execute();
  }
  function uM(r, e) {
    var t = r && r.name;
    return t ?? Sre + e;
  }
  function cM(r, e) {
    var t = this.context, n = r != null ? t.newChildren[r] : null, i = e != null ? t.oldChildren[e] : null;
    PS(t.api, i, t.dataIndex, n, t.seriesModel, t.group);
  }
  function Ere(r) {
    var e = this.context, t = e.oldChildren[r];
    t && Mg(t, ua(t).option, e.seriesModel);
  }
  function LF(r) {
    return r && (r.pathData || r.d);
  }
  function Nre(r) {
    return r && (oe(r, "pathData") || oe(r, "d"));
  }
  function Ore(r) {
    r.registerChartView(Tre), r.registerSeriesModel(tre);
  }
  var fs = tt(), hM = be, Ky = ne, LS = function() {
    function r() {
      this._dragging = false, this.animationThreshold = 15;
    }
    return r.prototype.render = function(e, t, n, i) {
      var a = t.get("value"), o = t.get("status");
      if (this._axisModel = e, this._axisPointerModel = t, this._api = n, !(!i && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, e, t, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(e, t);
        if (!s) s = this._group = new Ce(), this.createPointerEl(s, u, e, t), this.createLabelEl(s, u, e, t), n.getZr().add(s);
        else {
          var f = Le(fM, t, h);
          this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, t);
        }
        pM(s, t, true), this._renderHandle(a);
      }
    }, r.prototype.remove = function(e) {
      this.clear(e);
    }, r.prototype.dispose = function(e) {
      this.clear(e);
    }, r.prototype.determineAnimation = function(e, t) {
      var n = t.get("animation"), i = e.axis, a = i.type === "category", o = t.get("snap");
      if (!o && !a) return false;
      if (n === "auto" || n == null) {
        var s = this.animationThreshold;
        if (a && i.getBandWidth() > s) return true;
        if (o) {
          var l = eS(e).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return false;
      }
      return n === true;
    }, r.prototype.makeElOption = function(e, t, n, i, a) {
    }, r.prototype.createPointerEl = function(e, t, n, i) {
      var a = t.pointer;
      if (a) {
        var o = fs(e).pointerEl = new Zs[a.type](hM(t.pointer));
        e.add(o);
      }
    }, r.prototype.createLabelEl = function(e, t, n, i) {
      if (t.label) {
        var a = fs(e).labelEl = new rt(hM(t.label));
        e.add(a), dM(a, i);
      }
    }, r.prototype.updatePointerEl = function(e, t, n) {
      var i = fs(e).pointerEl;
      i && t.pointer && (i.setStyle(t.pointer.style), n(i, {
        shape: t.pointer.shape
      }));
    }, r.prototype.updateLabelEl = function(e, t, n, i) {
      var a = fs(e).labelEl;
      a && (a.setStyle(t.label.style), n(a, {
        x: t.label.x,
        y: t.label.y
      }), dM(a, i));
    }, r.prototype._renderHandle = function(e) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var t = this._axisPointerModel, n = this._api.getZr(), i = this._handle, a = t.getModel("handle"), o = t.get("status");
        if (!a.get("show") || !o || o === "hide") {
          i && n.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = true, i = this._handle = bf(a.get("icon"), {
          cursor: "move",
          draggable: true,
          onmousemove: function(u) {
            pa(u.event);
          },
          onmousedown: Ky(this._onHandleDragMove, this, 0, 0),
          drift: Ky(this._onHandleDragMove, this),
          ondragend: Ky(this._onHandleDragEnd, this)
        }), n.add(i)), pM(i, t, false), i.setStyle(a.getItemStyle(null, [
          "color",
          "borderColor",
          "borderWidth",
          "opacity",
          "shadowColor",
          "shadowBlur",
          "shadowOffsetX",
          "shadowOffsetY"
        ]));
        var l = a.get("size");
        X(l) || (l = [
          l,
          l
        ]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, Vu(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s);
      }
    }, r.prototype._moveHandleToValue = function(e, t) {
      fM(this._axisPointerModel, !t && this._moveAnimation, this._handle, Zy(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)));
    }, r.prototype._onHandleDragMove = function(e, t) {
      var n = this._handle;
      if (n) {
        this._dragging = true;
        var i = this.updateHandleTransform(Zy(n), [
          e,
          t
        ], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, n.stopAnimation(), n.attr(Zy(i)), fs(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, r.prototype._doDispatchAxisPointer = function() {
      var e = this._handle;
      if (e) {
        var t = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: t.cursorPoint[0],
          y: t.cursorPoint[1],
          tooltipOption: t.tooltipOption,
          axesInfo: [
            {
              axisDim: n.axis.dim,
              axisIndex: n.componentIndex
            }
          ]
        });
      }
    }, r.prototype._onHandleDragEnd = function() {
      this._dragging = false;
      var e = this._handle;
      if (e) {
        var t = this._axisPointerModel.get("value");
        this._moveHandleToValue(t), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, r.prototype.clear = function(e) {
      this._lastValue = null, this._lastStatus = null;
      var t = e.getZr(), n = this._group, i = this._handle;
      t && n && (this._lastGraphicKey = null, n && t.remove(n), i && t.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), Lh(this, "_doDispatchAxisPointer");
    }, r.prototype.doClear = function() {
    }, r.prototype.buildLabel = function(e, t, n) {
      return n = n || 0, {
        x: e[n],
        y: e[1 - n],
        width: t[n],
        height: t[1 - n]
      };
    }, r;
  }();
  function fM(r, e, t, n) {
    RF(fs(t).lastProp, n) || (fs(t).lastProp = n, e ? it(t, n, r) : (t.stopAnimation(), t.attr(n)));
  }
  function RF(r, e) {
    if (_e(r) && _e(e)) {
      var t = true;
      return D(e, function(n, i) {
        t = t && RF(r[i], n);
      }), !!t;
    } else return r === e;
  }
  function dM(r, e) {
    r[e.get([
      "label",
      "show"
    ]) ? "show" : "hide"]();
  }
  function Zy(r) {
    return {
      x: r.x || 0,
      y: r.y || 0,
      rotation: r.rotation || 0
    };
  }
  function pM(r, e, t) {
    var n = e.get("z"), i = e.get("zlevel");
    r && r.traverse(function(a) {
      a.type !== "group" && (n != null && (a.z = n), i != null && (a.zlevel = i), a.silent = t);
    });
  }
  function RS(r) {
    var e = r.get("type"), t = r.getModel(e + "Style"), n;
    return e === "line" ? (n = t.getLineStyle(), n.fill = null) : e === "shadow" && (n = t.getAreaStyle(), n.stroke = null), n;
  }
  function EF(r, e, t, n, i) {
    var a = t.get("value"), o = NF(a, e.axis, e.ecModel, t.get("seriesDataIndices"), {
      precision: t.get([
        "label",
        "precision"
      ]),
      formatter: t.get([
        "label",
        "formatter"
      ])
    }), s = t.getModel("label"), l = Ou(s.get("padding") || 0), u = s.getFont(), c = pf(o, u), h = i.position, f = c.width + l[1] + l[3], d = c.height + l[0] + l[2], p = i.align;
    p === "right" && (h[0] -= f), p === "center" && (h[0] -= f / 2);
    var v = i.verticalAlign;
    v === "bottom" && (h[1] -= d), v === "middle" && (h[1] -= d / 2), Fre(h, f, d, n);
    var g = s.get("backgroundColor");
    (!g || g === "auto") && (g = e.get([
      "axisLine",
      "lineStyle",
      "color"
    ])), r.label = {
      x: h[0],
      y: h[1],
      style: wt(s, {
        text: o,
        font: u,
        fill: s.getTextColor(),
        padding: l,
        backgroundColor: g
      }),
      z2: 10
    };
  }
  function Fre(r, e, t, n) {
    var i = n.getWidth(), a = n.getHeight();
    r[0] = Math.min(r[0] + e, i) - e, r[1] = Math.min(r[1] + t, a) - t, r[0] = Math.max(r[0], 0), r[1] = Math.max(r[1], 0);
  }
  function NF(r, e, t, n, i) {
    r = e.scale.parse(r);
    var a = e.scale.getLabel({
      value: r
    }, {
      precision: i.precision
    }), o = i.formatter;
    if (o) {
      var s = {
        value: W1(e, {
          value: r
        }),
        axisDimension: e.dim,
        axisIndex: e.index,
        seriesData: []
      };
      D(n, function(l) {
        var u = t.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
        h && s.seriesData.push(h);
      }), ee(o) ? a = o.replace("{value}", a) : ge(o) && (a = o(s));
    }
    return a;
  }
  function ES(r, e, t) {
    var n = pn();
    return qs(n, n, t.rotation), Bi(n, n, t.position), ai([
      r.dataToCoord(e),
      (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)
    ], n);
  }
  function OF(r, e, t, n, i, a) {
    var o = Ur.innerTextLayout(t.rotation, 0, t.labelDirection);
    t.labelMargin = i.get([
      "label",
      "margin"
    ]), EF(e, n, i, a, {
      position: ES(n.axis, r, t),
      align: o.textAlign,
      verticalAlign: o.textVerticalAlign
    });
  }
  function NS(r, e, t) {
    return t = t || 0, {
      x1: r[t],
      y1: r[1 - t],
      x2: e[t],
      y2: e[1 - t]
    };
  }
  function FF(r, e, t) {
    return t = t || 0, {
      x: r[t],
      y: r[1 - t],
      width: e[t],
      height: e[1 - t]
    };
  }
  function vM(r, e, t, n, i, a) {
    return {
      cx: r,
      cy: e,
      r0: t,
      r: n,
      startAngle: i,
      endAngle: a,
      clockwise: true
    };
  }
  var Bre = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, n, i, a, o) {
      var s = i.axis, l = s.grid, u = a.get("type"), c = gM(l, s).getOtherAxis(s).getGlobalExtent(), h = s.toGlobalCoord(s.dataToCoord(n, true));
      if (u && u !== "none") {
        var f = RS(a), d = zre[u](s, h, c);
        d.style = f, t.graphicKey = d.type, t.pointer = d;
      }
      var p = h_(l.model, i);
      OF(n, t, p, i, a, o);
    }, e.prototype.getHandleTransform = function(t, n, i) {
      var a = h_(n.axis.grid.model, n, {
        labelInside: false
      });
      a.labelMargin = i.get([
        "handle",
        "margin"
      ]);
      var o = ES(n.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, n, i, a) {
      var o = i.axis, s = o.grid, l = o.getGlobalExtent(true), u = gM(s, o).getOtherAxis(o).getGlobalExtent(), c = o.dim === "x" ? 0 : 1, h = [
        t.x,
        t.y
      ];
      h[c] += n[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var f = (u[1] + u[0]) / 2, d = [
        f,
        f
      ];
      d[c] = h[c];
      var p = [
        {
          verticalAlign: "middle"
        },
        {
          align: "center"
        }
      ];
      return {
        x: h[0],
        y: h[1],
        rotation: t.rotation,
        cursorPoint: d,
        tooltipOption: p[c]
      };
    }, e;
  }(LS);
  function gM(r, e) {
    var t = {};
    return t[e.dim + "AxisIndex"] = e.index, r.getCartesian(t);
  }
  var zre = {
    line: function(r, e, t) {
      var n = NS([
        e,
        t[0]
      ], [
        e,
        t[1]
      ], mM(r));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: n
      };
    },
    shadow: function(r, e, t) {
      var n = Math.max(1, r.getBandWidth()), i = t[1] - t[0];
      return {
        type: "Rect",
        shape: FF([
          e - n / 2,
          t[0]
        ], [
          n,
          i
        ], mM(r))
      };
    }
  };
  function mM(r) {
    return r.dim === "x" ? 0 : 1;
  }
  var Vre = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "axisPointer", e.defaultOption = {
      show: "auto",
      z: 50,
      type: "line",
      snap: false,
      triggerTooltip: true,
      triggerEmphasis: true,
      value: null,
      status: null,
      link: [],
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: true,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [
          5,
          7,
          5,
          7
        ],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: false,
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        margin: 50,
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        throttle: 40
      }
    }, e;
  }(Ke), ra = tt(), $re = D;
  function BF(r, e, t) {
    if (!He.node) {
      var n = e.getZr();
      ra(n).records || (ra(n).records = {}), Gre(n, e);
      var i = ra(n).records[r] || (ra(n).records[r] = {});
      i.handler = t;
    }
  }
  function Gre(r, e) {
    if (ra(r).initialized) return;
    ra(r).initialized = true, t("click", Le(yM, "click")), t("mousemove", Le(yM, "mousemove")), t("globalout", Ure);
    function t(n, i) {
      r.on(n, function(a) {
        var o = Hre(e);
        $re(ra(r).records, function(s) {
          s && i(s, a, o.dispatchAction);
        }), Wre(o.pendings, e);
      });
    }
  }
  function Wre(r, e) {
    var t = r.showTip.length, n = r.hideTip.length, i;
    t ? i = r.showTip[t - 1] : n && (i = r.hideTip[n - 1]), i && (i.dispatchAction = null, e.dispatchAction(i));
  }
  function Ure(r, e, t) {
    r.handler("leave", null, t);
  }
  function yM(r, e, t, n) {
    e.handler(r, t, n);
  }
  function Hre(r) {
    var e = {
      showTip: [],
      hideTip: []
    }, t = function(n) {
      var i = e[n.type];
      i ? i.push(n) : (n.dispatchAction = t, r.dispatchAction(n));
    };
    return {
      dispatchAction: t,
      pendings: e
    };
  }
  function L_(r, e) {
    if (!He.node) {
      var t = e.getZr(), n = (ra(t).records || {})[r];
      n && (ra(t).records[r] = null);
    }
  }
  var Yre = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = n.getComponent("tooltip"), o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      BF("axisPointer", i, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, e.prototype.remove = function(t, n) {
      L_("axisPointer", n);
    }, e.prototype.dispose = function(t, n) {
      L_("axisPointer", n);
    }, e.type = "axisPointer", e;
  }(Rt);
  function zF(r, e) {
    var t = [], n = r.seriesIndex, i;
    if (n == null || !(i = e.getSeriesByIndex(n))) return {
      point: []
    };
    var a = i.getData(), o = zs(a, r);
    if (o == null || o < 0 || X(o)) return {
      point: []
    };
    var s = a.getItemGraphicEl(o), l = i.coordinateSystem;
    if (i.getTooltipPosition) t = i.getTooltipPosition(o) || [];
    else if (l && l.dataToPoint) if (r.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, f = u.dim, d = h === "x" || h === "radius" ? 1 : 0, p = a.mapDimension(f), v = [];
      v[d] = a.get(p, o), v[1 - d] = a.get(a.getCalculationInfo("stackResultDimension"), o), t = l.dataToPoint(v) || [];
    } else t = l.dataToPoint(a.getValues(K(l.dimensions, function(m) {
      return a.mapDimension(m);
    }), o)) || [];
    else if (s) {
      var g = s.getBoundingRect().clone();
      g.applyTransform(s.transform), t = [
        g.x + g.width / 2,
        g.y + g.height / 2
      ];
    }
    return {
      point: t,
      el: s
    };
  }
  var xM = tt();
  function Xre(r, e, t) {
    var n = r.currTrigger, i = [
      r.x,
      r.y
    ], a = r, o = r.dispatchAction || ne(t.dispatchAction, t), s = e.getComponent("axisPointer").coordSysAxesInfo;
    if (s) {
      Ap(i) && (i = zF({
        seriesIndex: a.seriesIndex,
        dataIndex: a.dataIndex
      }, e).point);
      var l = Ap(i), u = a.axesInfo, c = s.axesInfo, h = n === "leave" || Ap(i), f = {}, d = {}, p = {
        list: [],
        map: {}
      }, v = {
        showPointer: Le(Kre, d),
        showTooltip: Le(Zre, p)
      };
      D(s.coordSysMap, function(m, y) {
        var x = l || m.containPoint(i);
        D(s.coordSysAxesInfo[y], function(_, S) {
          var b = _.axis, w = ene(u, _);
          if (!h && x && (!u || w)) {
            var C = w && w.value;
            C == null && !l && (C = b.pointToData(i)), C != null && _M(_, C, v, false, f);
          }
        });
      });
      var g = {};
      return D(c, function(m, y) {
        var x = m.linkGroup;
        x && !d[y] && D(x.axesInfo, function(_, S) {
          var b = d[S];
          if (_ !== m && b) {
            var w = b.value;
            x.mapper && (w = m.axis.scale.parse(x.mapper(w, bM(_), bM(m)))), g[m.key] = w;
          }
        });
      }), D(g, function(m, y) {
        _M(c[y], m, v, true, f);
      }), jre(d, c, f), Qre(p, i, r, o), Jre(c, o, t), f;
    }
  }
  function _M(r, e, t, n, i) {
    var a = r.axis;
    if (!(a.scale.isBlank() || !a.containData(e))) {
      if (!r.involveSeries) {
        t.showPointer(r, e);
        return;
      }
      var o = qre(e, r), s = o.payloadBatch, l = o.snapToValue;
      s[0] && i.seriesIndex == null && H(i, s[0]), !n && r.snap && a.containData(l) && l != null && (e = l), t.showPointer(r, e, s), t.showTooltip(r, o, l);
    }
  }
  function qre(r, e) {
    var t = e.axis, n = t.dim, i = r, a = [], o = Number.MAX_VALUE, s = -1;
    return D(e.seriesModels, function(l, u) {
      var c = l.getData().mapDimensionsAll(n), h, f;
      if (l.getAxisTooltipData) {
        var d = l.getAxisTooltipData(c, r, t);
        f = d.dataIndices, h = d.nestestValue;
      } else {
        if (f = l.getData().indicesOfNearest(c[0], r, t.type === "category" ? 0.5 : null), !f.length) return;
        h = l.getData().get(c[0], f[0]);
      }
      if (!(h == null || !isFinite(h))) {
        var p = r - h, v = Math.abs(p);
        v <= o && ((v < o || p >= 0 && s < 0) && (o = v, s = p, i = h, a.length = 0), D(f, function(g) {
          a.push({
            seriesIndex: l.seriesIndex,
            dataIndexInside: g,
            dataIndex: l.getData().getRawIndex(g)
          });
        }));
      }
    }), {
      payloadBatch: a,
      snapToValue: i
    };
  }
  function Kre(r, e, t, n) {
    r[e.key] = {
      value: t,
      payloadBatch: n
    };
  }
  function Zre(r, e, t, n) {
    var i = t.payloadBatch, a = e.axis, o = a.model, s = e.axisPointerModel;
    if (!(!e.triggerTooltip || !i.length)) {
      var l = e.coordSys.model, u = zh(l), c = r.map[u];
      c || (c = r.map[u] = {
        coordSysId: l.id,
        coordSysIndex: l.componentIndex,
        coordSysType: l.type,
        coordSysMainType: l.mainType,
        dataByAxis: []
      }, r.list.push(c)), c.dataByAxis.push({
        axisDim: a.dim,
        axisIndex: o.componentIndex,
        axisType: o.type,
        axisId: o.id,
        value: n,
        valueLabelOpt: {
          precision: s.get([
            "label",
            "precision"
          ]),
          formatter: s.get([
            "label",
            "formatter"
          ])
        },
        seriesDataIndices: i.slice()
      });
    }
  }
  function jre(r, e, t) {
    var n = t.axesInfo = [];
    D(e, function(i, a) {
      var o = i.axisPointerModel.option, s = r[a];
      s ? (!i.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (o.status = "hide"), o.status === "show" && n.push({
        axisDim: i.axis.dim,
        axisIndex: i.axis.model.componentIndex,
        value: o.value
      });
    });
  }
  function Qre(r, e, t, n) {
    if (Ap(e) || !r.list.length) {
      n({
        type: "hideTip"
      });
      return;
    }
    var i = ((r.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    n({
      type: "showTip",
      escapeConnect: true,
      x: e[0],
      y: e[1],
      tooltipOption: t.tooltipOption,
      position: t.position,
      dataIndexInside: i.dataIndexInside,
      dataIndex: i.dataIndex,
      seriesIndex: i.seriesIndex,
      dataByCoordSys: r.list
    });
  }
  function Jre(r, e, t) {
    var n = t.getZr(), i = "axisPointerLastHighlights", a = xM(n)[i] || {}, o = xM(n)[i] = {};
    D(r, function(u, c) {
      var h = u.axisPointerModel.option;
      h.status === "show" && u.triggerEmphasis && D(h.seriesDataIndices, function(f) {
        var d = f.seriesIndex + " | " + f.dataIndex;
        o[d] = f;
      });
    });
    var s = [], l = [];
    D(a, function(u, c) {
      !o[c] && l.push(u);
    }), D(o, function(u, c) {
      !a[c] && s.push(u);
    }), l.length && t.dispatchAction({
      type: "downplay",
      escapeConnect: true,
      notBlur: true,
      batch: l
    }), s.length && t.dispatchAction({
      type: "highlight",
      escapeConnect: true,
      notBlur: true,
      batch: s
    });
  }
  function ene(r, e) {
    for (var t = 0; t < (r || []).length; t++) {
      var n = r[t];
      if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n;
    }
  }
  function bM(r) {
    var e = r.axis.model, t = {}, n = t.axisDim = r.axis.dim;
    return t.axisIndex = t[n + "AxisIndex"] = e.componentIndex, t.axisName = t[n + "AxisName"] = e.name, t.axisId = t[n + "AxisId"] = e.id, t;
  }
  function Ap(r) {
    return !r || r[0] == null || isNaN(r[0]) || r[1] == null || isNaN(r[1]);
  }
  function Ef(r) {
    el.registerAxisPointerClass("CartesianAxisPointer", Bre), r.registerComponentModel(Vre), r.registerComponentView(Yre), r.registerPreprocessor(function(e) {
      if (e) {
        (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
        var t = e.axisPointer.link;
        t && !X(t) && (e.axisPointer.link = [
          t
        ]);
      }
    }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, function(e, t) {
      e.getComponent("axisPointer").coordSysAxesInfo = cZ(e, t);
    }), r.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, Xre);
  }
  function tne(r) {
    Ve(dO), Ve(Ef);
  }
  var rne = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, n, i, a, o) {
      var s = i.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), h = s.dataToCoord(n), f = a.get("type");
      if (f && f !== "none") {
        var d = RS(a), p = ine[f](s, l, h, c);
        p.style = d, t.graphicKey = p.type, t.pointer = p;
      }
      var v = a.get([
        "label",
        "margin"
      ]), g = nne(n, i, a, l, v);
      EF(t, i, a, o, g);
    }, e;
  }(LS);
  function nne(r, e, t, n, i) {
    var a = e.axis, o = a.dataToCoord(r), s = n.getAngleAxis().getExtent()[0];
    s = s / 180 * Math.PI;
    var l = n.getRadiusAxis().getExtent(), u, c, h;
    if (a.dim === "radius") {
      var f = pn();
      qs(f, f, s), Bi(f, f, [
        n.cx,
        n.cy
      ]), u = ai([
        o,
        -i
      ], f);
      var d = e.getModel("axisLabel").get("rotate") || 0, p = Ur.innerTextLayout(s, d * Math.PI / 180, -1);
      c = p.textAlign, h = p.textVerticalAlign;
    } else {
      var v = l[1];
      u = n.coordToPoint([
        v + i,
        o
      ]);
      var g = n.cx, m = n.cy;
      c = Math.abs(u[0] - g) / v < 0.3 ? "center" : u[0] > g ? "left" : "right", h = Math.abs(u[1] - m) / v < 0.3 ? "middle" : u[1] > m ? "top" : "bottom";
    }
    return {
      position: u,
      align: c,
      verticalAlign: h
    };
  }
  var ine = {
    line: function(r, e, t, n) {
      return r.dim === "angle" ? {
        type: "Line",
        shape: NS(e.coordToPoint([
          n[0],
          t
        ]), e.coordToPoint([
          n[1],
          t
        ]))
      } : {
        type: "Circle",
        shape: {
          cx: e.cx,
          cy: e.cy,
          r: t
        }
      };
    },
    shadow: function(r, e, t, n) {
      var i = Math.max(1, r.getBandWidth()), a = Math.PI / 180;
      return r.dim === "angle" ? {
        type: "Sector",
        shape: vM(e.cx, e.cy, n[0], n[1], (-t - i / 2) * a, (-t + i / 2) * a)
      } : {
        type: "Sector",
        shape: vM(e.cx, e.cy, t - i / 2, t + i / 2, 0, Math.PI * 2)
      };
    }
  }, ane = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.findAxisModel = function(t) {
      var n, i = this.ecModel;
      return i.eachComponent(t, function(a) {
        a.getCoordSysModel() === this && (n = a);
      }, this), n;
    }, e.type = "polar", e.dependencies = [
      "radiusAxis",
      "angleAxis"
    ], e.defaultOption = {
      z: 0,
      center: [
        "50%",
        "50%"
      ],
      radius: "80%"
    }, e;
  }(Ke), OS = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", Yt).models[0];
    }, e.type = "polarAxis", e;
  }(Ke);
  qt(OS, Tf);
  var one = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "angleAxis", e;
  }(OS), sne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "radiusAxis", e;
  }(OS), FS = function(r) {
    G(e, r);
    function e(t, n) {
      return r.call(this, "radius", t, n) || this;
    }
    return e.prototype.pointToData = function(t, n) {
      return this.polar.pointToData(t, n)[this.dim === "radius" ? 0 : 1];
    }, e;
  }(hi);
  FS.prototype.dataToRadius = hi.prototype.dataToCoord;
  FS.prototype.radiusToData = hi.prototype.coordToData;
  var lne = tt(), BS = function(r) {
    G(e, r);
    function e(t, n) {
      return r.call(this, "angle", t, n || [
        0,
        360
      ]) || this;
    }
    return e.prototype.pointToData = function(t, n) {
      return this.polar.pointToData(t, n)[this.dim === "radius" ? 0 : 1];
    }, e.prototype.calculateCategoryInterval = function() {
      var t = this, n = t.getLabelModel(), i = t.scale, a = i.getExtent(), o = i.count();
      if (a[1] - a[0] < 1) return 0;
      var s = a[0], l = t.dataToCoord(s + 1) - t.dataToCoord(s), u = Math.abs(l), c = pf(s == null ? "" : s + "", n.getFont(), "center", "top"), h = Math.max(c.height, 7), f = h / u;
      isNaN(f) && (f = 1 / 0);
      var d = Math.max(0, Math.floor(f)), p = lne(t.model), v = p.lastAutoInterval, g = p.lastTickCount;
      return v != null && g != null && Math.abs(v - d) <= 1 && Math.abs(g - o) <= 1 && v > d ? d = v : (p.lastTickCount = o, p.lastAutoInterval = d), d;
    }, e;
  }(hi);
  BS.prototype.dataToAngle = hi.prototype.dataToCoord;
  BS.prototype.angleToData = hi.prototype.coordToData;
  var VF = [
    "radius",
    "angle"
  ], une = function() {
    function r(e) {
      this.dimensions = VF, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new FS(), this._angleAxis = new BS(), this.axisPointerEnabled = true, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return r.prototype.containPoint = function(e) {
      var t = this.pointToCoord(e);
      return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1]);
    }, r.prototype.containData = function(e) {
      return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]);
    }, r.prototype.getAxis = function(e) {
      var t = "_" + e + "Axis";
      return this[t];
    }, r.prototype.getAxes = function() {
      return [
        this._radiusAxis,
        this._angleAxis
      ];
    }, r.prototype.getAxesByScale = function(e) {
      var t = [], n = this._angleAxis, i = this._radiusAxis;
      return n.scale.type === e && t.push(n), i.scale.type === e && t.push(i), t;
    }, r.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, r.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, r.prototype.getOtherAxis = function(e) {
      var t = this._angleAxis;
      return e === t ? this._radiusAxis : t;
    }, r.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, r.prototype.getTooltipAxes = function(e) {
      var t = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis();
      return {
        baseAxes: [
          t
        ],
        otherAxes: [
          this.getOtherAxis(t)
        ]
      };
    }, r.prototype.dataToPoint = function(e, t) {
      return this.coordToPoint([
        this._radiusAxis.dataToRadius(e[0], t),
        this._angleAxis.dataToAngle(e[1], t)
      ]);
    }, r.prototype.pointToData = function(e, t) {
      var n = this.pointToCoord(e);
      return [
        this._radiusAxis.radiusToData(n[0], t),
        this._angleAxis.angleToData(n[1], t)
      ];
    }, r.prototype.pointToCoord = function(e) {
      var t = e[0] - this.cx, n = e[1] - this.cy, i = this.getAngleAxis(), a = i.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
      i.inverse ? o = s - 360 : s = o + 360;
      var l = Math.sqrt(t * t + n * n);
      t /= l, n /= l;
      for (var u = Math.atan2(-n, t) / Math.PI * 180, c = u < o ? 1 : -1; u < o || u > s; ) u += c * 360;
      return [
        l,
        u
      ];
    }, r.prototype.coordToPoint = function(e) {
      var t = e[0], n = e[1] / 180 * Math.PI, i = Math.cos(n) * t + this.cx, a = -Math.sin(n) * t + this.cy;
      return [
        i,
        a
      ];
    }, r.prototype.getArea = function() {
      var e = this.getAngleAxis(), t = this.getRadiusAxis(), n = t.getExtent().slice();
      n[0] > n[1] && n.reverse();
      var i = e.getExtent(), a = Math.PI / 180, o = 1e-4;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: n[0],
        r: n[1],
        startAngle: -i[0] * a,
        endAngle: -i[1] * a,
        clockwise: e.inverse,
        contain: function(s, l) {
          var u = s - this.cx, c = l - this.cy, h = u * u + c * c, f = this.r, d = this.r0;
          return f !== d && h - o <= f * f && h + o >= d * d;
        }
      };
    }, r.prototype.convertToPixel = function(e, t, n) {
      var i = SM(t);
      return i === this ? this.dataToPoint(n) : null;
    }, r.prototype.convertFromPixel = function(e, t, n) {
      var i = SM(t);
      return i === this ? this.pointToData(n) : null;
    }, r;
  }();
  function SM(r) {
    var e = r.seriesModel, t = r.polarModel;
    return t && t.coordinateSystem || e && e.coordinateSystem;
  }
  function cne(r, e, t) {
    var n = e.get("center"), i = t.getWidth(), a = t.getHeight();
    r.cx = Q(n[0], i), r.cy = Q(n[1], a);
    var o = r.getRadiusAxis(), s = Math.min(i, a) / 2, l = e.get("radius");
    l == null ? l = [
      0,
      "100%"
    ] : X(l) || (l = [
      0,
      l
    ]);
    var u = [
      Q(l[0], s),
      Q(l[1], s)
    ];
    o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1]);
  }
  function hne(r, e) {
    var t = this, n = t.getAngleAxis(), i = t.getRadiusAxis();
    if (n.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), r.eachSeries(function(s) {
      if (s.coordinateSystem === t) {
        var l = s.getData();
        D(av(l, "radius"), function(u) {
          i.scale.unionExtentFromData(l, u);
        }), D(av(l, "angle"), function(u) {
          n.scale.unionExtentFromData(l, u);
        });
      }
    }), fu(n.scale, n.model), fu(i.scale, i.model), n.type === "category" && !n.onBand) {
      var a = n.getExtent(), o = 360 / n.scale.count();
      n.inverse ? a[1] += o : a[1] -= o, n.setExtent(a[0], a[1]);
    }
  }
  function fne(r) {
    return r.mainType === "angleAxis";
  }
  function wM(r, e) {
    var t;
    if (r.type = e.get("type"), r.scale = bg(e), r.onBand = e.get("boundaryGap") && r.type === "category", r.inverse = e.get("inverse"), fne(e)) {
      r.inverse = r.inverse !== e.get("clockwise");
      var n = e.get("startAngle"), i = (t = e.get("endAngle")) !== null && t !== void 0 ? t : n + (r.inverse ? -360 : 360);
      r.setExtent(n, i);
    }
    e.axis = r, r.model = e;
  }
  var dne = {
    dimensions: VF,
    create: function(r, e) {
      var t = [];
      return r.eachComponent("polar", function(n, i) {
        var a = new une(i + "");
        a.update = hne;
        var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = n.findAxisModel("radiusAxis"), u = n.findAxisModel("angleAxis");
        wM(o, l), wM(s, u), cne(a, n, e), t.push(a), n.coordinateSystem = a, a.model = n;
      }), r.eachSeries(function(n) {
        if (n.get("coordinateSystem") === "polar") {
          var i = n.getReferringComponents("polar", Yt).models[0];
          n.coordinateSystem = i.coordinateSystem;
        }
      }), t;
    }
  }, pne = [
    "axisLine",
    "axisLabel",
    "axisTick",
    "minorTick",
    "splitLine",
    "minorSplitLine",
    "splitArea"
  ];
  function Ld(r, e, t) {
    e[1] > e[0] && (e = e.slice().reverse());
    var n = r.coordToPoint([
      e[0],
      t
    ]), i = r.coordToPoint([
      e[1],
      t
    ]);
    return {
      x1: n[0],
      y1: n[1],
      x2: i[0],
      y2: i[1]
    };
  }
  function Rd(r) {
    var e = r.getRadiusAxis();
    return e.inverse ? 0 : 1;
  }
  function CM(r) {
    var e = r[0], t = r[r.length - 1];
    e && t && Math.abs(Math.abs(e.coord - t.coord) - 360) < 1e-4 && r.pop();
  }
  var vne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, n) {
      if (this.group.removeAll(), !!t.get("show")) {
        var i = t.axis, a = i.polar, o = a.getRadiusAxis().getExtent(), s = i.getTicksCoords(), l = i.getMinorTicksCoords(), u = K(i.getViewLabels(), function(c) {
          c = be(c);
          var h = i.scale, f = h.type === "ordinal" ? h.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(f), c;
        });
        CM(u), CM(s), D(pne, function(c) {
          t.get([
            c,
            "show"
          ]) && (!i.scale.isBlank() || c === "axisLine") && gne[c](this.group, t, a, s, l, o, u);
        }, this);
      }
    }, e.type = "angleAxis", e;
  }(el), gne = {
    axisLine: function(r, e, t, n, i, a) {
      var o = e.getModel([
        "axisLine",
        "lineStyle"
      ]), s = t.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), c = Rd(t), h = c ? 0 : 1, f, d = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
      a[h] === 0 ? f = new Zs[d]({
        shape: {
          cx: t.cx,
          cy: t.cy,
          r: a[c],
          startAngle: -u[0] * l,
          endAngle: -u[1] * l,
          clockwise: s.inverse
        },
        style: o.getLineStyle(),
        z2: 1,
        silent: true
      }) : f = new mf({
        shape: {
          cx: t.cx,
          cy: t.cy,
          r: a[c],
          r0: a[h]
        },
        style: o.getLineStyle(),
        z2: 1,
        silent: true
      }), f.style.fill = null, r.add(f);
    },
    axisTick: function(r, e, t, n, i, a) {
      var o = e.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[Rd(t)], u = K(n, function(c) {
        return new ir({
          shape: Ld(t, [
            l,
            l + s
          ], c.coord)
        });
      });
      r.add(En(u, {
        style: ye(o.getModel("lineStyle").getLineStyle(), {
          stroke: e.get([
            "axisLine",
            "lineStyle",
            "color"
          ])
        })
      }));
    },
    minorTick: function(r, e, t, n, i, a) {
      if (i.length) {
        for (var o = e.getModel("axisTick"), s = e.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[Rd(t)], c = [], h = 0; h < i.length; h++) for (var f = 0; f < i[h].length; f++) c.push(new ir({
          shape: Ld(t, [
            u,
            u + l
          ], i[h][f].coord)
        }));
        r.add(En(c, {
          style: ye(s.getModel("lineStyle").getLineStyle(), ye(o.getLineStyle(), {
            stroke: e.get([
              "axisLine",
              "lineStyle",
              "color"
            ])
          }))
        }));
      }
    },
    axisLabel: function(r, e, t, n, i, a, o) {
      var s = e.getCategories(true), l = e.getModel("axisLabel"), u = l.get("margin"), c = e.get("triggerEvent");
      D(o, function(h, f) {
        var d = l, p = h.tickValue, v = a[Rd(t)], g = t.coordToPoint([
          v + u,
          h.coord
        ]), m = t.cx, y = t.cy, x = Math.abs(g[0] - m) / v < 0.3 ? "center" : g[0] > m ? "left" : "right", _ = Math.abs(g[1] - y) / v < 0.3 ? "middle" : g[1] > y ? "top" : "bottom";
        if (s && s[p]) {
          var S = s[p];
          _e(S) && S.textStyle && (d = new ft(S.textStyle, l, l.ecModel));
        }
        var b = new rt({
          silent: Ur.isLabelSilent(e),
          style: wt(d, {
            x: g[0],
            y: g[1],
            fill: d.getTextColor() || e.get([
              "axisLine",
              "lineStyle",
              "color"
            ]),
            text: h.formattedLabel,
            align: x,
            verticalAlign: _
          })
        });
        if (r.add(b), c) {
          var w = Ur.makeAxisEventDataBase(e);
          w.targetType = "axisLabel", w.value = h.rawLabel, De(b).eventData = w;
        }
      }, this);
    },
    splitLine: function(r, e, t, n, i, a) {
      var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [
        l
      ];
      for (var c = [], h = 0; h < n.length; h++) {
        var f = u++ % l.length;
        c[f] = c[f] || [], c[f].push(new ir({
          shape: Ld(t, a, n[h].coord)
        }));
      }
      for (var h = 0; h < c.length; h++) r.add(En(c[h], {
        style: ye({
          stroke: l[h % l.length]
        }, s.getLineStyle()),
        silent: true,
        z: e.get("z")
      }));
    },
    minorSplitLine: function(r, e, t, n, i, a) {
      if (i.length) {
        for (var o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < i.length; u++) for (var c = 0; c < i[u].length; c++) l.push(new ir({
          shape: Ld(t, a, i[u][c].coord)
        }));
        r.add(En(l, {
          style: s.getLineStyle(),
          silent: true,
          z: e.get("z")
        }));
      }
    },
    splitArea: function(r, e, t, n, i, a) {
      if (n.length) {
        var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
        l = l instanceof Array ? l : [
          l
        ];
        for (var c = [], h = Math.PI / 180, f = -n[0].coord * h, d = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), v = e.get("clockwise"), g = 1, m = n.length; g <= m; g++) {
          var y = g === m ? n[0].coord : n[g].coord, x = u++ % l.length;
          c[x] = c[x] || [], c[x].push(new qr({
            shape: {
              cx: t.cx,
              cy: t.cy,
              r0: d,
              r: p,
              startAngle: f,
              endAngle: -y * h,
              clockwise: v
            },
            silent: true
          })), f = -y * h;
        }
        for (var g = 0; g < c.length; g++) r.add(En(c[g], {
          style: ye({
            fill: l[g % l.length]
          }, s.getAreaStyle()),
          silent: true
        }));
      }
    }
  }, mne = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], yne = [
    "splitLine",
    "splitArea",
    "minorSplitLine"
  ], xne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, n) {
      if (this.group.removeAll(), !!t.get("show")) {
        var i = this._axisGroup, a = this._axisGroup = new Ce();
        this.group.add(a);
        var o = t.axis, s = o.polar, l = s.getAngleAxis(), u = o.getTicksCoords(), c = o.getMinorTicksCoords(), h = l.getExtent()[0], f = o.getExtent(), d = bne(s, t, h), p = new Ur(t, d);
        D(mne, p.add, p), a.add(p.getGroup()), _f(i, a, t), D(yne, function(v) {
          t.get([
            v,
            "show"
          ]) && !o.scale.isBlank() && _ne[v](this.group, t, s, h, f, u, c);
        }, this);
      }
    }, e.type = "radiusAxis", e;
  }(el), _ne = {
    splitLine: function(r, e, t, n, i, a) {
      var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0, c = t.getAngleAxis(), h = Math.PI / 180, f = c.getExtent(), d = Math.abs(f[1] - f[0]) === 360 ? "Circle" : "Arc";
      l = l instanceof Array ? l : [
        l
      ];
      for (var p = [], v = 0; v < a.length; v++) {
        var g = u++ % l.length;
        p[g] = p[g] || [], p[g].push(new Zs[d]({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r: Math.max(a[v].coord, 0),
            startAngle: -f[0] * h,
            endAngle: -f[1] * h,
            clockwise: c.inverse
          }
        }));
      }
      for (var v = 0; v < p.length; v++) r.add(En(p[v], {
        style: ye({
          stroke: l[v % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: true
      }));
    },
    minorSplitLine: function(r, e, t, n, i, a, o) {
      if (o.length) {
        for (var s = e.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < o.length; c++) for (var h = 0; h < o[c].length; h++) u.push(new Ta({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r: o[c][h].coord
          }
        }));
        r.add(En(u, {
          style: ye({
            fill: null
          }, l.getLineStyle()),
          silent: true
        }));
      }
    },
    splitArea: function(r, e, t, n, i, a) {
      if (a.length) {
        var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
        l = l instanceof Array ? l : [
          l
        ];
        for (var c = [], h = a[0].coord, f = 1; f < a.length; f++) {
          var d = u++ % l.length;
          c[d] = c[d] || [], c[d].push(new qr({
            shape: {
              cx: t.cx,
              cy: t.cy,
              r0: h,
              r: a[f].coord,
              startAngle: 0,
              endAngle: Math.PI * 2
            },
            silent: true
          })), h = a[f].coord;
        }
        for (var f = 0; f < c.length; f++) r.add(En(c[f], {
          style: ye({
            fill: l[f % l.length]
          }, s.getAreaStyle()),
          silent: true
        }));
      }
    }
  };
  function bne(r, e, t) {
    return {
      position: [
        r.cx,
        r.cy
      ],
      rotation: t / 180 * Math.PI,
      labelDirection: -1,
      tickDirection: -1,
      nameDirection: 1,
      labelRotate: e.getModel("axisLabel").get("rotate"),
      z2: 1
    };
  }
  function $F(r) {
    return r.get("stack") || "__ec_stack_" + r.seriesIndex;
  }
  function GF(r, e) {
    return e.dim + r.model.componentIndex;
  }
  function Sne(r, e, t) {
    var n = {}, i = wne(ct(e.getSeriesByType(r), function(a) {
      return !e.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
    }));
    e.eachSeriesByType(r, function(a) {
      if (a.coordinateSystem.type === "polar") {
        var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = GF(s, l), c = $F(a), h = i[u][c], f = h.offset, d = h.width, p = s.getOtherAxis(l), v = a.coordinateSystem.cx, g = a.coordinateSystem.cy, m = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
        n[c] = n[c] || [];
        for (var x = o.mapDimension(p.dim), _ = o.mapDimension(l.dim), S = ho(o, x), b = l.dim !== "radius" || !a.get("roundCap", true), w = p.model, C = w.get("startValue"), T = p.dataToCoord(C || 0), A = 0, M = o.count(); A < M; A++) {
          var E = o.get(x, A), k = o.get(_, A), R = E >= 0 ? "p" : "n", N = T;
          S && (n[c][k] || (n[c][k] = {
            p: T,
            n: T
          }), N = n[c][k][R]);
          var I = void 0, L = void 0, P = void 0, O = void 0;
          if (p.dim === "radius") {
            var F = p.dataToCoord(E) - T, B = l.dataToCoord(k);
            Math.abs(F) < m && (F = (F < 0 ? -1 : 1) * m), I = N, L = N + F, P = B - f, O = P - d, S && (n[c][k][R] = L);
          } else {
            var V = p.dataToCoord(E, b) - T, U = l.dataToCoord(k);
            Math.abs(V) < y && (V = (V < 0 ? -1 : 1) * y), I = U + f, L = I + d, P = N, O = N + V, S && (n[c][k][R] = O);
          }
          o.setItemLayout(A, {
            cx: v,
            cy: g,
            r0: I,
            r: L,
            startAngle: -P * Math.PI / 180,
            endAngle: -O * Math.PI / 180,
            clockwise: P >= O
          });
        }
      }
    });
  }
  function wne(r) {
    var e = {};
    D(r, function(n, i) {
      var a = n.getData(), o = n.coordinateSystem, s = o.getBaseAxis(), l = GF(o, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), h = e[l] || {
        bandWidth: c,
        remainedWidth: c,
        autoWidthCount: 0,
        categoryGap: "20%",
        gap: "30%",
        stacks: {}
      }, f = h.stacks;
      e[l] = h;
      var d = $F(n);
      f[d] || h.autoWidthCount++, f[d] = f[d] || {
        width: 0,
        maxWidth: 0
      };
      var p = Q(n.get("barWidth"), c), v = Q(n.get("barMaxWidth"), c), g = n.get("barGap"), m = n.get("barCategoryGap");
      p && !f[d].width && (p = Math.min(h.remainedWidth, p), f[d].width = p, h.remainedWidth -= p), v && (f[d].maxWidth = v), g != null && (h.gap = g), m != null && (h.categoryGap = m);
    });
    var t = {};
    return D(e, function(n, i) {
      t[i] = {};
      var a = n.stacks, o = n.bandWidth, s = Q(n.categoryGap, o), l = Q(n.gap, 1), u = n.remainedWidth, c = n.autoWidthCount, h = (u - s) / (c + (c - 1) * l);
      h = Math.max(h, 0), D(a, function(v, g) {
        var m = v.maxWidth;
        m && m < h && (m = Math.min(m, u), v.width && (m = Math.min(m, v.width)), u -= m, v.width = m, c--);
      }), h = (u - s) / (c + (c - 1) * l), h = Math.max(h, 0);
      var f = 0, d;
      D(a, function(v, g) {
        v.width || (v.width = h), d = v, f += v.width * (1 + l);
      }), d && (f -= d.width * l);
      var p = -f / 2;
      D(a, function(v, g) {
        t[i][g] = t[i][g] || {
          offset: p,
          width: v.width
        }, p += v.width * (1 + l);
      });
    }), t;
  }
  var Cne = {
    startAngle: 90,
    clockwise: true,
    splitNumber: 12,
    axisLabel: {
      rotate: 0
    }
  }, Tne = {
    splitNumber: 5
  }, Ane = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "polar", e;
  }(Rt);
  function Ine(r) {
    Ve(Ef), el.registerAxisPointerClass("PolarAxisPointer", rne), r.registerCoordinateSystem("polar", dne), r.registerComponentModel(ane), r.registerComponentView(Ane), pu(r, "angle", one, Cne), pu(r, "radius", sne, Tne), r.registerComponentView(vne), r.registerComponentView(xne), r.registerLayout(Le(Sne, "bar"));
  }
  function R_(r, e) {
    e = e || {};
    var t = r.coordinateSystem, n = r.axis, i = {}, a = n.position, o = n.orient, s = t.getRect(), l = [
      s.x,
      s.x + s.width,
      s.y,
      s.y + s.height
    ], u = {
      horizontal: {
        top: l[2],
        bottom: l[3]
      },
      vertical: {
        left: l[0],
        right: l[1]
      }
    };
    i.position = [
      o === "vertical" ? u.vertical[a] : l[0],
      o === "horizontal" ? u.horizontal[a] : l[3]
    ];
    var c = {
      horizontal: 0,
      vertical: 1
    };
    i.rotation = Math.PI / 2 * c[o];
    var h = {
      top: -1,
      bottom: 1,
      right: 1,
      left: -1
    };
    i.labelDirection = i.tickDirection = i.nameDirection = h[a], r.get([
      "axisTick",
      "inside"
    ]) && (i.tickDirection = -i.tickDirection), vr(e.labelInside, r.get([
      "axisLabel",
      "inside"
    ])) && (i.labelDirection = -i.labelDirection);
    var f = e.rotate;
    return f == null && (f = r.get([
      "axisLabel",
      "rotate"
    ])), i.labelRotation = a === "top" ? -f : f, i.z2 = 1, i;
  }
  var Mne = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], Dne = [
    "splitArea",
    "splitLine"
  ], Pne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "SingleAxisPointer", t;
    }
    return e.prototype.render = function(t, n, i, a) {
      var o = this.group;
      o.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new Ce();
      var l = R_(t), u = new Ur(t, l);
      D(Mne, u.add, u), o.add(this._axisGroup), o.add(u.getGroup()), D(Dne, function(c) {
        t.get([
          c,
          "show"
        ]) && kne[c](this, this.group, this._axisGroup, t);
      }, this), _f(s, this._axisGroup, t), r.prototype.render.call(this, t, n, i, a);
    }, e.prototype.remove = function() {
      cO(this);
    }, e.type = "singleAxis", e;
  }(el), kne = {
    splitLine: function(r, e, t, n) {
      var i = n.axis;
      if (!i.scale.isBlank()) {
        var a = n.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
        s = s instanceof Array ? s : [
          s
        ];
        for (var l = o.get("width"), u = n.coordinateSystem.getRect(), c = i.isHorizontal(), h = [], f = 0, d = i.getTicksCoords({
          tickModel: a
        }), p = [], v = [], g = 0; g < d.length; ++g) {
          var m = i.toGlobalCoord(d[g].coord);
          c ? (p[0] = m, p[1] = u.y, v[0] = m, v[1] = u.y + u.height) : (p[0] = u.x, p[1] = m, v[0] = u.x + u.width, v[1] = m);
          var y = new ir({
            shape: {
              x1: p[0],
              y1: p[1],
              x2: v[0],
              y2: v[1]
            },
            silent: true
          });
          uu(y.shape, l);
          var x = f++ % s.length;
          h[x] = h[x] || [], h[x].push(y);
        }
        for (var _ = o.getLineStyle([
          "color"
        ]), g = 0; g < h.length; ++g) e.add(En(h[g], {
          style: ye({
            stroke: s[g % s.length]
          }, _),
          silent: true
        }));
      }
    },
    splitArea: function(r, e, t, n) {
      uO(r, t, n, n);
    }
  }, Ip = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getCoordSysModel = function() {
      return this;
    }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: true,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      tooltip: {
        show: true
      },
      axisTick: {
        show: true,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        interval: "auto"
      },
      splitLine: {
        show: true,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, e;
  }(Ke);
  qt(Ip, Tf.prototype);
  var Lne = function(r) {
    G(e, r);
    function e(t, n, i, a, o) {
      var s = r.call(this, t, n, i) || this;
      return s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.pointToData = function(t, n) {
      return this.coordinateSystem.pointToData(t)[0];
    }, e;
  }(hi), WF = [
    "single"
  ], Rne = function() {
    function r(e, t, n) {
      this.type = "single", this.dimension = "single", this.dimensions = WF, this.axisPointerEnabled = true, this.model = e, this._init(e, t, n);
    }
    return r.prototype._init = function(e, t, n) {
      var i = this.dimension, a = new Lne(i, bg(e), [
        0,
        0
      ], e.get("type"), e.get("position")), o = a.type === "category";
      a.onBand = o && e.get("boundaryGap"), a.inverse = e.get("inverse"), a.orient = e.get("orient"), e.axis = a, a.model = e, a.coordinateSystem = this, this._axis = a;
    }, r.prototype.update = function(e, t) {
      e.eachSeries(function(n) {
        if (n.coordinateSystem === this) {
          var i = n.getData();
          D(i.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(i, a);
          }, this), fu(this._axis.scale, this._axis.model);
        }
      }, this);
    }, r.prototype.resize = function(e, t) {
      this._rect = er({
        left: e.get("left"),
        top: e.get("top"),
        right: e.get("right"),
        bottom: e.get("bottom"),
        width: e.get("width"),
        height: e.get("height")
      }, {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._adjustAxis();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._adjustAxis = function() {
      var e = this._rect, t = this._axis, n = t.isHorizontal(), i = n ? [
        0,
        e.width
      ] : [
        0,
        e.height
      ], a = t.inverse ? 1 : 0;
      t.setExtent(i[a], i[1 - a]), this._updateAxisTransform(t, n ? e.x : e.y);
    }, r.prototype._updateAxisTransform = function(e, t) {
      var n = e.getExtent(), i = n[0] + n[1], a = e.isHorizontal();
      e.toGlobalCoord = a ? function(o) {
        return o + t;
      } : function(o) {
        return i - o + t;
      }, e.toLocalCoord = a ? function(o) {
        return o - t;
      } : function(o) {
        return i - o + t;
      };
    }, r.prototype.getAxis = function() {
      return this._axis;
    }, r.prototype.getBaseAxis = function() {
      return this._axis;
    }, r.prototype.getAxes = function() {
      return [
        this._axis
      ];
    }, r.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [
          this.getAxis()
        ],
        otherAxes: []
      };
    }, r.prototype.containPoint = function(e) {
      var t = this.getRect(), n = this.getAxis(), i = n.orient;
      return i === "horizontal" ? n.contain(n.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height : n.contain(n.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height;
    }, r.prototype.pointToData = function(e) {
      var t = this.getAxis();
      return [
        t.coordToData(t.toLocalCoord(e[t.orient === "horizontal" ? 0 : 1]))
      ];
    }, r.prototype.dataToPoint = function(e) {
      var t = this.getAxis(), n = this.getRect(), i = [], a = t.orient === "horizontal" ? 0 : 1;
      return e instanceof Array && (e = e[0]), i[a] = t.toGlobalCoord(t.dataToCoord(+e)), i[1 - a] = a === 0 ? n.y + n.height / 2 : n.x + n.width / 2, i;
    }, r.prototype.convertToPixel = function(e, t, n) {
      var i = TM(t);
      return i === this ? this.dataToPoint(n) : null;
    }, r.prototype.convertFromPixel = function(e, t, n) {
      var i = TM(t);
      return i === this ? this.pointToData(n) : null;
    }, r;
  }();
  function TM(r) {
    var e = r.seriesModel, t = r.singleAxisModel;
    return t && t.coordinateSystem || e && e.coordinateSystem;
  }
  function Ene(r, e) {
    var t = [];
    return r.eachComponent("singleAxis", function(n, i) {
      var a = new Rne(n, r, e);
      a.name = "single_" + i, a.resize(n, e), n.coordinateSystem = a, t.push(a);
    }), r.eachSeries(function(n) {
      if (n.get("coordinateSystem") === "singleAxis") {
        var i = n.getReferringComponents("singleAxis", Yt).models[0];
        n.coordinateSystem = i && i.coordinateSystem;
      }
    }), t;
  }
  var Nne = {
    create: Ene,
    dimensions: WF
  }, AM = [
    "x",
    "y"
  ], One = [
    "width",
    "height"
  ], Fne = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, n, i, a, o) {
      var s = i.axis, l = s.coordinateSystem, u = jy(l, 1 - xv(s)), c = l.dataToPoint(n)[0], h = a.get("type");
      if (h && h !== "none") {
        var f = RS(a), d = Bne[h](s, c, u);
        d.style = f, t.graphicKey = d.type, t.pointer = d;
      }
      var p = R_(i);
      OF(n, t, p, i, a, o);
    }, e.prototype.getHandleTransform = function(t, n, i) {
      var a = R_(n, {
        labelInside: false
      });
      a.labelMargin = i.get([
        "handle",
        "margin"
      ]);
      var o = ES(n.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, n, i, a) {
      var o = i.axis, s = o.coordinateSystem, l = xv(o), u = jy(s, l), c = [
        t.x,
        t.y
      ];
      c[l] += n[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var h = jy(s, 1 - l), f = (h[1] + h[0]) / 2, d = [
        f,
        f
      ];
      return d[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: t.rotation,
        cursorPoint: d,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, e;
  }(LS), Bne = {
    line: function(r, e, t) {
      var n = NS([
        e,
        t[0]
      ], [
        e,
        t[1]
      ], xv(r));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: n
      };
    },
    shadow: function(r, e, t) {
      var n = r.getBandWidth(), i = t[1] - t[0];
      return {
        type: "Rect",
        shape: FF([
          e - n / 2,
          t[0]
        ], [
          n,
          i
        ], xv(r))
      };
    }
  };
  function xv(r) {
    return r.isHorizontal() ? 0 : 1;
  }
  function jy(r, e) {
    var t = r.getRect();
    return [
      t[AM[e]],
      t[AM[e]] + t[One[e]]
    ];
  }
  var zne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "single", e;
  }(Rt);
  function Vne(r) {
    Ve(Ef), el.registerAxisPointerClass("SingleAxisPointer", Fne), r.registerComponentView(zne), r.registerComponentView(Pne), r.registerComponentModel(Ip), pu(r, "single", Ip, Ip.defaultOption), r.registerCoordinateSystem("single", Nne);
  }
  var $ne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n, i) {
      var a = Fu(t);
      r.prototype.init.apply(this, arguments), IM(t, a);
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), IM(this.option, t);
    }, e.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, e.type = "calendar", e.defaultOption = {
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: "horizontal",
      splitLine: {
        show: true,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      dayLabel: {
        show: true,
        firstDay: 0,
        position: "start",
        margin: "50%",
        color: "#000"
      },
      monthLabel: {
        show: true,
        position: "start",
        margin: 5,
        align: "center",
        formatter: null,
        color: "#000"
      },
      yearLabel: {
        show: true,
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, e;
  }(Ke);
  function IM(r, e) {
    var t = r.cellSize, n;
    X(t) ? n = t : n = r.cellSize = [
      t,
      t
    ], n.length === 1 && (n[1] = n[0]);
    var i = K([
      0,
      1
    ], function(a) {
      return sY(e, a) && (n[a] = "auto"), n[a] != null && n[a] !== "auto";
    });
    co(r, e, {
      type: "box",
      ignoreSize: i
    });
  }
  var Gne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      var a = this.group;
      a.removeAll();
      var o = t.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = n.getLocaleModel();
      this._renderDayRect(t, s, a), this._renderLines(t, s, l, a), this._renderYearText(t, s, l, a), this._renderMonthText(t, u, l, a), this._renderWeekText(t, u, s, l, a);
    }, e.prototype._renderDayRect = function(t, n, i) {
      for (var a = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = n.start.time; u <= n.end.time; u = a.getNextNDay(u, 1).time) {
        var c = a.dataToRect([
          u
        ], false).tl, h = new et({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: o
        });
        i.add(h);
      }
    }, e.prototype._renderLines = function(t, n, i, a) {
      var o = this, s = t.coordinateSystem, l = t.getModel([
        "splitLine",
        "lineStyle"
      ]).getLineStyle(), u = t.get([
        "splitLine",
        "show"
      ]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var h = n.start, f = 0; h.time <= n.end.time; f++) {
        p(h.formatedDate), f === 0 && (h = s.getDateInfo(n.start.y + "-" + n.start.m));
        var d = h.date;
        d.setMonth(d.getMonth() + 1), h = s.getDateInfo(d);
      }
      p(s.getNextNDay(n.end.time, 1).formatedDate);
      function p(v) {
        o._firstDayOfMonth.push(s.getDateInfo(v)), o._firstDayPoints.push(s.dataToRect([
          v
        ], false).tl);
        var g = o._getLinePointsOfOneWeek(t, v, i);
        o._tlpoints.push(g[0]), o._blpoints.push(g[g.length - 1]), u && o._drawSplitline(g, l, a);
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, c, i), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, c, i), l, a);
    }, e.prototype._getEdgesPoints = function(t, n, i) {
      var a = [
        t[0].slice(),
        t[t.length - 1].slice()
      ], o = i === "horizontal" ? 0 : 1;
      return a[0][o] = a[0][o] - n / 2, a[1][o] = a[1][o] + n / 2, a;
    }, e.prototype._drawSplitline = function(t, n, i) {
      var a = new Zr({
        z2: 20,
        shape: {
          points: t
        },
        style: n
      });
      i.add(a);
    }, e.prototype._getLinePointsOfOneWeek = function(t, n, i) {
      for (var a = t.coordinateSystem, o = a.getDateInfo(n), s = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(o.time, l), c = a.dataToRect([
          u.time
        ], false);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, e.prototype._formatterLabel = function(t, n) {
      return ee(t) && t ? iY(t, n) : ge(t) ? t(n) : n.nameMap;
    }, e.prototype._yearTextPositionControl = function(t, n, i, a, o) {
      var s = n[0], l = n[1], u = [
        "center",
        "bottom"
      ];
      a === "bottom" ? (l += o, u = [
        "center",
        "top"
      ]) : a === "left" ? s -= o : a === "right" ? (s += o, u = [
        "center",
        "top"
      ]) : l -= o;
      var c = 0;
      return (a === "left" || a === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, e.prototype._renderYearText = function(t, n, i, a) {
      var o = t.getModel("yearLabel");
      if (o.get("show")) {
        var s = o.get("margin"), l = o.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [
          this._tlpoints[this._tlpoints.length - 1],
          this._blpoints[0]
        ], c = (u[0][0] + u[1][0]) / 2, h = (u[0][1] + u[1][1]) / 2, f = i === "horizontal" ? 0 : 1, d = {
          top: [
            c,
            u[f][1]
          ],
          bottom: [
            c,
            u[1 - f][1]
          ],
          left: [
            u[1 - f][0],
            h
          ],
          right: [
            u[f][0],
            h
          ]
        }, p = n.start.y;
        +n.end.y > +n.start.y && (p = p + "-" + n.end.y);
        var v = o.get("formatter"), g = {
          start: n.start.y,
          end: n.end.y,
          nameMap: p
        }, m = this._formatterLabel(v, g), y = new rt({
          z2: 30,
          style: wt(o, {
            text: m
          }),
          silent: o.get("silent")
        });
        y.attr(this._yearTextPositionControl(y, d[l], i, l, s)), a.add(y);
      }
    }, e.prototype._monthTextPositionControl = function(t, n, i, a, o) {
      var s = "left", l = "top", u = t[0], c = t[1];
      return i === "horizontal" ? (c = c + o, n && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, n && (l = "middle"), a === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderMonthText = function(t, n, i, a) {
      var o = t.getModel("monthLabel");
      if (o.get("show")) {
        var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), c = o.get("align"), h = [
          this._tlpoints,
          this._blpoints
        ];
        (!s || ee(s)) && (s && (n = $x(s) || n), s = n.get([
          "time",
          "monthAbbr"
        ]) || []);
        var f = u === "start" ? 0 : 1, d = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", v = o.get("silent"), g = 0; g < h[f].length - 1; g++) {
          var m = h[f][g].slice(), y = this._firstDayOfMonth[g];
          if (p) {
            var x = this._firstDayPoints[g];
            m[d] = (x[d] + h[0][g + 1][d]) / 2;
          }
          var _ = o.get("formatter"), S = s[+y.m - 1], b = {
            yyyy: y.y,
            yy: (y.y + "").slice(2),
            MM: y.m,
            M: +y.m,
            nameMap: S
          }, w = this._formatterLabel(_, b), C = new rt({
            z2: 30,
            style: H(wt(o, {
              text: w
            }), this._monthTextPositionControl(m, p, i, u, l)),
            silent: v
          });
          a.add(C);
        }
      }
    }, e.prototype._weekTextPositionControl = function(t, n, i, a, o) {
      var s = "center", l = "middle", u = t[0], c = t[1], h = i === "start";
      return n === "horizontal" ? (u = u + a + (h ? 1 : -1) * o[0] / 2, s = h ? "right" : "left") : (c = c + a + (h ? 1 : -1) * o[1] / 2, l = h ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderWeekText = function(t, n, i, a, o) {
      var s = t.getModel("dayLabel");
      if (s.get("show")) {
        var l = t.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), h = s.get("margin"), f = l.getFirstDayOfWeek();
        if (!c || ee(c)) {
          c && (n = $x(c) || n);
          var d = n.get([
            "time",
            "dayOfWeekShort"
          ]);
          c = d || K(n.get([
            "time",
            "dayOfWeekAbbr"
          ]), function(b) {
            return b[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, v = [
          l.getCellWidth(),
          l.getCellHeight()
        ];
        h = Q(h, Math.min(v[1], v[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, h = -h);
        for (var g = s.get("silent"), m = 0; m < 7; m++) {
          var y = l.getNextNDay(p, m), x = l.dataToRect([
            y.time
          ], false).center, _ = m;
          _ = Math.abs((m + f) % 7);
          var S = new rt({
            z2: 30,
            style: H(wt(s, {
              text: c[_]
            }), this._weekTextPositionControl(x, a, u, h, v)),
            silent: g
          });
          o.add(S);
        }
      }
    }, e.type = "calendar", e;
  }(Rt), Qy = 864e5, Wne = function() {
    function r(e, t, n) {
      this.type = "calendar", this.dimensions = r.dimensions, this.getDimensionsInfo = r.getDimensionsInfo, this._model = e;
    }
    return r.getDimensionsInfo = function() {
      return [
        {
          name: "time",
          type: "time"
        },
        "value"
      ];
    }, r.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.getCellWidth = function() {
      return this._sw;
    }, r.prototype.getCellHeight = function() {
      return this._sh;
    }, r.prototype.getOrient = function() {
      return this._orient;
    }, r.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, r.prototype.getDateInfo = function(e) {
      e = Vi(e);
      var t = e.getFullYear(), n = e.getMonth() + 1, i = n < 10 ? "0" + n : "" + n, a = e.getDate(), o = a < 10 ? "0" + a : "" + a, s = e.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: t + "",
        m: i,
        d: o,
        day: s,
        time: e.getTime(),
        formatedDate: t + "-" + i + "-" + o,
        date: e
      };
    }, r.prototype.getNextNDay = function(e, t) {
      return t = t || 0, t === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + t), this.getDateInfo(e));
    }, r.prototype.update = function(e, t) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var n = this._rangeInfo.weeks || 1, i = [
        "width",
        "height"
      ], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [
        n,
        7
      ] : [
        7,
        n
      ];
      D([
        0,
        1
      ], function(h) {
        c(a, h) && (o[i[h]] = a[h] * s[h]);
      });
      var l = {
        width: t.getWidth(),
        height: t.getHeight()
      }, u = this._rect = er(o, l);
      D([
        0,
        1
      ], function(h) {
        c(a, h) || (a[h] = u[i[h]] / s[h]);
      });
      function c(h, f) {
        return h[f] != null && h[f] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, r.prototype.dataToPoint = function(e, t) {
      X(e) && (e = e[0]), t == null && (t = true);
      var n = this.getDateInfo(e), i = this._rangeInfo, a = n.formatedDate;
      if (t && !(n.time >= i.start.time && n.time < i.end.time + Qy)) return [
        NaN,
        NaN
      ];
      var o = n.day, s = this._getRangeInfo([
        i.start.time,
        a
      ]).nthWeek;
      return this._orient === "vertical" ? [
        this._rect.x + o * this._sw + this._sw / 2,
        this._rect.y + s * this._sh + this._sh / 2
      ] : [
        this._rect.x + s * this._sw + this._sw / 2,
        this._rect.y + o * this._sh + this._sh / 2
      ];
    }, r.prototype.pointToData = function(e) {
      var t = this.pointToDate(e);
      return t && t.time;
    }, r.prototype.dataToRect = function(e, t) {
      var n = this.dataToPoint(e, t);
      return {
        contentShape: {
          x: n[0] - (this._sw - this._lineWidth) / 2,
          y: n[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: n,
        tl: [
          n[0] - this._sw / 2,
          n[1] - this._sh / 2
        ],
        tr: [
          n[0] + this._sw / 2,
          n[1] - this._sh / 2
        ],
        br: [
          n[0] + this._sw / 2,
          n[1] + this._sh / 2
        ],
        bl: [
          n[0] - this._sw / 2,
          n[1] + this._sh / 2
        ]
      };
    }, r.prototype.pointToDate = function(e) {
      var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1, n = Math.floor((e[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(n, t - 1, i) : this._getDateByWeeksAndDay(t, n - 1, i);
    }, r.prototype.convertToPixel = function(e, t, n) {
      var i = MM(t);
      return i === this ? i.dataToPoint(n) : null;
    }, r.prototype.convertFromPixel = function(e, t, n) {
      var i = MM(t);
      return i === this ? i.pointToData(n) : null;
    }, r.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), false;
    }, r.prototype._initRangeOption = function() {
      var e = this._model.get("range"), t;
      if (X(e) && e.length === 1 && (e = e[0]), X(e)) t = e;
      else {
        var n = e.toString();
        if (/^\d{4}$/.test(n) && (t = [
          n + "-01-01",
          n + "-12-31"
        ]), /^\d{4}[\/|-]\d{1,2}$/.test(n)) {
          var i = this.getDateInfo(n), a = i.date;
          a.setMonth(a.getMonth() + 1);
          var o = this.getNextNDay(a, -1);
          t = [
            i.formatedDate,
            o.formatedDate
          ];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (t = [
          n,
          n
        ]);
      }
      if (!t) return e;
      var s = this._getRangeInfo(t);
      return s.start.time > s.end.time && t.reverse(), t;
    }, r.prototype._getRangeInfo = function(e) {
      var t = [
        this.getDateInfo(e[0]),
        this.getDateInfo(e[1])
      ], n;
      t[0].time > t[1].time && (n = true, t.reverse());
      var i = Math.floor(t[1].time / Qy) - Math.floor(t[0].time / Qy) + 1, a = new Date(t[0].time), o = a.getDate(), s = t[1].date.getDate();
      a.setDate(o + i - 1);
      var l = a.getDate();
      if (l !== s) for (var u = a.getTime() - t[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - t[1].time) * u > 0; ) i -= u, a.setDate(l - u);
      var c = Math.floor((i + t[0].day + 6) / 7), h = n ? -c + 1 : c - 1;
      return n && t.reverse(), {
        range: [
          t[0].formatedDate,
          t[1].formatedDate
        ],
        start: t[0],
        end: t[1],
        allDay: i,
        weeks: c,
        nthWeek: h,
        fweek: t[0].day,
        lweek: t[1].day
      };
    }, r.prototype._getDateByWeeksAndDay = function(e, t, n) {
      var i = this._getRangeInfo(n);
      if (e > i.weeks || e === 0 && t < i.fweek || e === i.weeks && t > i.lweek) return null;
      var a = (e - 1) * 7 - i.fweek + t, o = new Date(i.start.time);
      return o.setDate(+i.start.d + a), this.getDateInfo(o);
    }, r.create = function(e, t) {
      var n = [];
      return e.eachComponent("calendar", function(i) {
        var a = new r(i);
        n.push(a), i.coordinateSystem = a;
      }), e.eachSeries(function(i) {
        i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = n[i.get("calendarIndex") || 0]);
      }), n;
    }, r.dimensions = [
      "time",
      "value"
    ], r;
  }();
  function MM(r) {
    var e = r.calendarModel, t = r.seriesModel, n = e ? e.coordinateSystem : t ? t.coordinateSystem : null;
    return n;
  }
  function Une(r) {
    r.registerComponentModel($ne), r.registerComponentView(Gne), r.registerCoordinateSystem("calendar", Wne);
  }
  function Hne(r, e) {
    var t = r.existing;
    if (e.id = r.keyInfo.id, !e.type && t && (e.type = t.type), e.parentId == null) {
      var n = e.parentOption;
      n ? e.parentId = n.id : t && (e.parentId = t.parentId);
    }
    e.parentOption = null;
  }
  function DM(r, e) {
    var t;
    return D(e, function(n) {
      r[n] != null && r[n] !== "auto" && (t = true);
    }), t;
  }
  function Yne(r, e, t) {
    var n = H({}, t), i = r[e], a = t.$action || "merge";
    a === "merge" ? i ? (Ee(i, n, true), co(i, n, {
      ignoreSize: true
    }), NE(t, i), Ed(t, i), Ed(t, i, "shape"), Ed(t, i, "style"), Ed(t, i, "extra"), t.clipPath = i.clipPath) : r[e] = n : a === "replace" ? r[e] = n : a === "remove" && i && (r[e] = null);
  }
  var UF = [
    "transition",
    "enterFrom",
    "leaveTo"
  ], Xne = UF.concat([
    "enterAnimation",
    "updateAnimation",
    "leaveAnimation"
  ]);
  function Ed(r, e, t) {
    if (t && (!r[t] && e[t] && (r[t] = {}), r = r[t], e = e[t]), !(!r || !e)) for (var n = t ? UF : Xne, i = 0; i < n.length; i++) {
      var a = n[i];
      r[a] == null && e[a] != null && (r[a] = e[a]);
    }
  }
  function qne(r, e) {
    if (r && (r.hv = e.hv = [
      DM(e, [
        "left",
        "right"
      ]),
      DM(e, [
        "top",
        "bottom"
      ])
    ], r.type === "group")) {
      var t = r, n = e;
      t.width == null && (t.width = n.width = 0), t.height == null && (t.height = n.height = 0);
    }
  }
  var Kne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.preventAutoZ = true, t;
    }
    return e.prototype.mergeOption = function(t, n) {
      var i = this.option.elements;
      this.option.elements = null, r.prototype.mergeOption.call(this, t, n), this.option.elements = i;
    }, e.prototype.optionUpdated = function(t, n) {
      var i = this.option, a = (n ? i : t).elements, o = i.elements = n ? [] : i.elements, s = [];
      this._flatten(a, s, null);
      var l = kR(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      D(l, function(c, h) {
        var f = c.newOption;
        f && (u.push(f), Hne(c, f), Yne(o, h, f), qne(o[h], f));
      }, this), i.elements = ct(o, function(c) {
        return c && delete c.$action, c != null;
      });
    }, e.prototype._flatten = function(t, n, i) {
      D(t, function(a) {
        if (a) {
          i && (a.parentOption = i), n.push(a);
          var o = a.children;
          o && o.length && this._flatten(o, n, a), delete a.children;
        }
      }, this);
    }, e.prototype.useElOptionsToUpdate = function() {
      var t = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, t;
    }, e.type = "graphic", e.defaultOption = {
      elements: []
    }, e;
  }(Ke), PM = {
    path: null,
    compoundPath: null,
    group: Ce,
    image: mr,
    text: rt
  }, Pn = tt(), Zne = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._elMap = ce();
    }, e.prototype.render = function(t, n, i) {
      t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i);
    }, e.prototype._updateElements = function(t) {
      var n = t.useElOptionsToUpdate();
      if (n) {
        var i = this._elMap, a = this.group, o = t.get("z"), s = t.get("zlevel");
        D(n, function(l) {
          var u = jt(l.id, null), c = u != null ? i.get(u) : null, h = jt(l.parentId, null), f = h != null ? i.get(h) : a, d = l.type, p = l.style;
          d === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var v = l.textContent, g = l.textConfig;
          if (p && CF(p, d, !!g, !!v)) {
            var m = TF(p, d, true);
            !g && m.textConfig && (g = l.textConfig = m.textConfig), !v && m.textContent && (v = m.textContent);
          }
          var y = jne(l), x = l.$action || "merge", _ = x === "merge", S = x === "replace";
          if (_) {
            var b = !c, w = c;
            b ? w = kM(u, f, l.type, i) : (w && (Pn(w).isNew = false), DF(w)), w && (Tp(w, y, t, {
              isInit: b
            }), LM(w, l, o, s));
          } else if (S) {
            Mp(c, l, i, t);
            var C = kM(u, f, l.type, i);
            C && (Tp(C, y, t, {
              isInit: true
            }), LM(C, l, o, s));
          } else x === "remove" && (IF(c, l), Mp(c, l, i, t));
          var T = i.get(u);
          if (T && v) if (_) {
            var A = T.getTextContent();
            A ? A.attr(v) : T.setTextContent(new rt(v));
          } else S && T.setTextContent(new rt(v));
          if (T) {
            var M = l.clipPath;
            if (M) {
              var E = M.type, k = void 0, b = false;
              if (_) {
                var R = T.getClipPath();
                b = !R || Pn(R).type !== E, k = b ? E_(E) : R;
              } else S && (b = true, k = E_(E));
              T.setClipPath(k), Tp(k, M, t, {
                isInit: b
              }), mv(k, M.keyframeAnimation, t);
            }
            var N = Pn(T);
            T.setTextConfig(g), N.option = l, Qne(T, t, l), Ks({
              el: T,
              componentModel: t,
              itemName: T.name,
              itemTooltipOption: l.tooltip
            }), mv(T, l.keyframeAnimation, t);
          }
        });
      }
    }, e.prototype._relocate = function(t, n) {
      for (var i = t.option.elements, a = this.group, o = this._elMap, s = n.getWidth(), l = n.getHeight(), u = [
        "x",
        "y"
      ], c = 0; c < i.length; c++) {
        var h = i[c], f = jt(h.id, null), d = f != null ? o.get(f) : null;
        if (!(!d || !d.isGroup)) {
          var p = d.parent, v = p === a, g = Pn(d), m = Pn(p);
          g.width = Q(g.option.width, v ? s : m.width) || 0, g.height = Q(g.option.height, v ? l : m.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var h = i[c], f = jt(h.id, null), d = f != null ? o.get(f) : null;
        if (d) {
          var p = d.parent, m = Pn(p), y = p === a ? {
            width: s,
            height: l
          } : {
            width: m.width,
            height: m.height
          }, x = {}, _ = fg(d, h, y, null, {
            hv: h.hv,
            boundingMode: h.bounding
          }, x);
          if (!Pn(d).isNew && _) {
            for (var S = h.transition, b = {}, w = 0; w < u.length; w++) {
              var C = u[w], T = x[C];
              S && (Es(S) || Be(S, C) >= 0) ? b[C] = T : d[C] = T;
            }
            it(d, b, t, 0);
          } else d.attr(x);
        }
      }
    }, e.prototype._clear = function() {
      var t = this, n = this._elMap;
      n.each(function(i) {
        Mp(i, Pn(i).option, n, t._lastGraphicModel);
      }), this._elMap = ce();
    }, e.prototype.dispose = function() {
      this._clear();
    }, e.type = "graphic", e;
  }(Rt);
  function E_(r) {
    var e = oe(PM, r) ? PM[r] : g1(r), t = new e({});
    return Pn(t).type = r, t;
  }
  function kM(r, e, t, n) {
    var i = E_(t);
    return e.add(i), n.set(r, i), Pn(i).id = r, Pn(i).isNew = true, i;
  }
  function Mp(r, e, t, n) {
    var i = r && r.parent;
    i && (r.type === "group" && r.traverse(function(a) {
      Mp(a, e, t, n);
    }), Mg(r, e, n), t.removeKey(Pn(r).id));
  }
  function LM(r, e, t, n) {
    r.isGroup || D([
      [
        "cursor",
        zn.prototype.cursor
      ],
      [
        "zlevel",
        n || 0
      ],
      [
        "z",
        t || 0
      ],
      [
        "z2",
        0
      ]
    ], function(i) {
      var a = i[0];
      oe(e, a) ? r[a] = Pe(e[a], i[1]) : r[a] == null && (r[a] = i[1]);
    }), D(je(e), function(i) {
      if (i.indexOf("on") === 0) {
        var a = e[i];
        r[i] = ge(a) ? a : null;
      }
    }), oe(e, "draggable") && (r.draggable = e.draggable), e.name != null && (r.name = e.name), e.id != null && (r.id = e.id);
  }
  function jne(r) {
    return r = H({}, r), D([
      "id",
      "parentId",
      "$action",
      "hv",
      "bounding",
      "textContent",
      "clipPath"
    ].concat(EE), function(e) {
      delete r[e];
    }), r;
  }
  function Qne(r, e, t) {
    var n = De(r).eventData;
    !r.silent && !r.ignore && !n && (n = De(r).eventData = {
      componentType: "graphic",
      componentIndex: e.componentIndex,
      name: r.name
    }), n && (n.info = t.info);
  }
  function Jne(r) {
    r.registerComponentModel(Kne), r.registerComponentView(Zne), r.registerPreprocessor(function(e) {
      var t = e.graphic;
      X(t) ? !t[0] || !t[0].elements ? e.graphic = [
        {
          elements: t
        }
      ] : e.graphic = [
        e.graphic[0]
      ] : t && !t.elements && (e.graphic = [
        {
          elements: [
            t
          ]
        }
      ]);
    });
  }
  var RM = [
    "x",
    "y",
    "radius",
    "angle",
    "single"
  ], eie = [
    "cartesian2d",
    "polar",
    "singleAxis"
  ];
  function tie(r) {
    var e = r.get("coordinateSystem");
    return Be(eie, e) >= 0;
  }
  function Ja(r) {
    return r + "Axis";
  }
  function rie(r, e) {
    var t = ce(), n = [], i = ce();
    r.eachComponent({
      mainType: "dataZoom",
      query: e
    }, function(c) {
      i.get(c.uid) || s(c);
    });
    var a;
    do
      a = false, r.eachComponent("dataZoom", o);
    while (a);
    function o(c) {
      !i.get(c.uid) && l(c) && (s(c), a = true);
    }
    function s(c) {
      i.set(c.uid, true), n.push(c), u(c);
    }
    function l(c) {
      var h = false;
      return c.eachTargetAxis(function(f, d) {
        var p = t.get(f);
        p && p[d] && (h = true);
      }), h;
    }
    function u(c) {
      c.eachTargetAxis(function(h, f) {
        (t.get(h) || t.set(h, []))[f] = true;
      });
    }
    return n;
  }
  function HF(r) {
    var e = r.ecModel, t = {
      infoList: [],
      infoMap: ce()
    };
    return r.eachTargetAxis(function(n, i) {
      var a = e.getComponent(Ja(n), i);
      if (a) {
        var o = a.getCoordSysModel();
        if (o) {
          var s = o.uid, l = t.infoMap.get(s);
          l || (l = {
            model: o,
            axisModels: []
          }, t.infoList.push(l), t.infoMap.set(s, l)), l.axisModels.push(a);
        }
      }
    }), t;
  }
  var Jy = function() {
    function r() {
      this.indexList = [], this.indexMap = [];
    }
    return r.prototype.add = function(e) {
      this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = true);
    }, r;
  }(), Hh = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._autoThrottle = true, t._noTarget = true, t._rangePropMode = [
        "percent",
        "percent"
      ], t;
    }
    return e.prototype.init = function(t, n, i) {
      var a = EM(t);
      this.settledOption = a, this.mergeDefaultAndTheme(t, i), this._doInit(a);
    }, e.prototype.mergeOption = function(t) {
      var n = EM(t);
      Ee(this.option, t, true), Ee(this.settledOption, n, true), this._doInit(n);
    }, e.prototype._doInit = function(t) {
      var n = this.option;
      this._setDefaultThrottle(t), this._updateRangeUse(t);
      var i = this.settledOption;
      D([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a, o) {
        this._rangePropMode[o] === "value" && (n[a[0]] = i[a[0]] = null);
      }, this), this._resetTarget();
    }, e.prototype._resetTarget = function() {
      var t = this.get("orient", true), n = this._targetAxisInfoMap = ce(), i = this._fillSpecifiedTargetAxis(n);
      i ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(n, this._orient)), this._noTarget = true, n.each(function(a) {
        a.indexList.length && (this._noTarget = false);
      }, this);
    }, e.prototype._fillSpecifiedTargetAxis = function(t) {
      var n = false;
      return D(RM, function(i) {
        var a = this.getReferringComponents(Ja(i), XH);
        if (a.specified) {
          n = true;
          var o = new Jy();
          D(a.models, function(s) {
            o.add(s.componentIndex);
          }), t.set(i, o);
        }
      }, this), n;
    }, e.prototype._fillAutoTargetAxisByOrient = function(t, n) {
      var i = this.ecModel, a = true;
      if (a) {
        var o = n === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: o + "Axis"
        });
        l(s, o);
      }
      if (a) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", true) === n;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var h = u[0];
        if (h) {
          var f = new Jy();
          if (f.add(h.componentIndex), t.set(c, f), a = false, c === "x" || c === "y") {
            var d = h.getReferringComponents("grid", Yt).models[0];
            d && D(u, function(p) {
              h.componentIndex !== p.componentIndex && d === p.getReferringComponents("grid", Yt).models[0] && f.add(p.componentIndex);
            });
          }
        }
      }
      a && D(RM, function(u) {
        if (a) {
          var c = i.findComponents({
            mainType: Ja(u),
            filter: function(f) {
              return f.get("type", true) === "category";
            }
          });
          if (c[0]) {
            var h = new Jy();
            h.add(c[0].componentIndex), t.set(u, h), a = false;
          }
        }
      }, this);
    }, e.prototype._makeAutoOrientByTargetAxis = function() {
      var t;
      return this.eachTargetAxis(function(n) {
        !t && (t = n);
      }, this), t === "y" ? "vertical" : "horizontal";
    }, e.prototype._setDefaultThrottle = function(t) {
      if (t.hasOwnProperty("throttle") && (this._autoThrottle = false), this._autoThrottle) {
        var n = this.ecModel.option;
        this.option.throttle = n.animation && n.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, e.prototype._updateRangeUse = function(t) {
      var n = this._rangePropMode, i = this.get("rangeMode");
      D([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a, o) {
        var s = t[a[0]] != null, l = t[a[1]] != null;
        s && !l ? n[o] = "percent" : !s && l ? n[o] = "value" : i ? n[o] = i[o] : s && (n[o] = "percent");
      });
    }, e.prototype.noTarget = function() {
      return this._noTarget;
    }, e.prototype.getFirstTargetAxisModel = function() {
      var t;
      return this.eachTargetAxis(function(n, i) {
        t == null && (t = this.ecModel.getComponent(Ja(n), i));
      }, this), t;
    }, e.prototype.eachTargetAxis = function(t, n) {
      this._targetAxisInfoMap.each(function(i, a) {
        D(i.indexList, function(o) {
          t.call(n, a, o);
        });
      });
    }, e.prototype.getAxisProxy = function(t, n) {
      var i = this.getAxisModel(t, n);
      if (i) return i.__dzAxisProxy;
    }, e.prototype.getAxisModel = function(t, n) {
      var i = this._targetAxisInfoMap.get(t);
      if (i && i.indexMap[n]) return this.ecModel.getComponent(Ja(t), n);
    }, e.prototype.setRawRange = function(t) {
      var n = this.option, i = this.settledOption;
      D([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a) {
        (t[a[0]] != null || t[a[1]] != null) && (n[a[0]] = i[a[0]] = t[a[0]], n[a[1]] = i[a[1]] = t[a[1]]);
      }, this), this._updateRangeUse(t);
    }, e.prototype.setCalculatedRange = function(t) {
      var n = this.option;
      D([
        "start",
        "startValue",
        "end",
        "endValue"
      ], function(i) {
        n[i] = t[i];
      });
    }, e.prototype.getPercentRange = function() {
      var t = this.findRepresentativeAxisProxy();
      if (t) return t.getDataPercentWindow();
    }, e.prototype.getValueRange = function(t, n) {
      if (t == null && n == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i) return i.getDataValueWindow();
      } else return this.getAxisProxy(t, n).getDataValueWindow();
    }, e.prototype.findRepresentativeAxisProxy = function(t) {
      if (t) return t.__dzAxisProxy;
      for (var n, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++) for (var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
        var u = this.getAxisProxy(o, s.indexList[l]);
        if (u.hostedBy(this)) return u;
        n || (n = u);
      }
      return n;
    }, e.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, e.prototype.getOrient = function() {
      return this._orient;
    }, e.type = "dataZoom", e.dependencies = [
      "xAxis",
      "yAxis",
      "radiusAxis",
      "angleAxis",
      "singleAxis",
      "series",
      "toolbox"
    ], e.defaultOption = {
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, e;
  }(Ke);
  function EM(r) {
    var e = {};
    return D([
      "start",
      "end",
      "startValue",
      "endValue",
      "throttle"
    ], function(t) {
      r.hasOwnProperty(t) && (e[t] = r[t]);
    }), e;
  }
  var nie = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(Hh), zS = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i, a) {
      this.dataZoomModel = t, this.ecModel = n, this.api = i;
    }, e.type = "dataZoom", e;
  }(Rt), iie = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(zS), Vl = D, NM = On, aie = function() {
    function r(e, t, n, i) {
      this._dimName = e, this._axisIndex = t, this.ecModel = i, this._dataZoomModel = n;
    }
    return r.prototype.hostedBy = function(e) {
      return this._dataZoomModel === e;
    }, r.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, r.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, r.prototype.getTargetSeriesModels = function() {
      var e = [];
      return this.ecModel.eachSeries(function(t) {
        if (tie(t)) {
          var n = Ja(this._dimName), i = t.getReferringComponents(n, Yt).models[0];
          i && this._axisIndex === i.componentIndex && e.push(t);
        }
      }, this), e;
    }, r.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, r.prototype.getMinMaxSpan = function() {
      return be(this._minMaxSpan);
    }, r.prototype.calculateDataWindow = function(e) {
      var t = this._dataExtent, n = this.getAxisModel(), i = n.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [
        0,
        100
      ], s = [], l = [], u;
      Vl([
        "start",
        "end"
      ], function(f, d) {
        var p = e[f], v = e[f + "Value"];
        a[d] === "percent" ? (p == null && (p = o[d]), v = i.parse(ht(p, o, t))) : (u = true, v = v == null ? t[d] : i.parse(v), p = ht(v, t, o)), l[d] = v == null || isNaN(v) ? t[d] : v, s[d] = p == null || isNaN(p) ? o[d] : p;
      }), NM(l), NM(s);
      var c = this._minMaxSpan;
      u ? h(l, s, t, o, false) : h(s, l, o, t, true);
      function h(f, d, p, v, g) {
        var m = g ? "Span" : "ValueSpan";
        tl(0, f, p, "all", c["min" + m], c["max" + m]);
        for (var y = 0; y < 2; y++) d[y] = ht(f[y], p, v, true), g && (d[y] = i.parse(d[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, r.prototype.reset = function(e) {
      if (e === this._dataZoomModel) {
        var t = this.getTargetSeriesModels();
        this._dataExtent = oie(this, this._dimName, t), this._updateMinMaxSpan();
        var n = this.calculateDataWindow(e.settledOption);
        this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, this._setAxisModel();
      }
    }, r.prototype.filterData = function(e, t) {
      if (e !== this._dataZoomModel) return;
      var n = this._dimName, i = this.getTargetSeriesModels(), a = e.get("filterMode"), o = this._valueWindow;
      if (a === "none") return;
      Vl(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(n);
        if (c.length) {
          if (a === "weakFilter") {
            var h = u.getStore(), f = K(c, function(d) {
              return u.getDimensionIndex(d);
            }, u);
            u.filterSelf(function(d) {
              for (var p, v, g, m = 0; m < c.length; m++) {
                var y = h.get(f[m], d), x = !isNaN(y), _ = y < o[0], S = y > o[1];
                if (x && !_ && !S) return true;
                x && (g = true), _ && (p = true), S && (v = true);
              }
              return g && p && v;
            });
          } else Vl(c, function(d) {
            if (a === "empty") l.setData(u = u.map(d, function(v) {
              return s(v) ? v : NaN;
            }));
            else {
              var p = {};
              p[d] = o, u.selectRange(p);
            }
          });
          Vl(c, function(d) {
            u.setApproximateExtent(o, d);
          });
        }
      });
      function s(l) {
        return l >= o[0] && l <= o[1];
      }
    }, r.prototype._updateMinMaxSpan = function() {
      var e = this._minMaxSpan = {}, t = this._dataZoomModel, n = this._dataExtent;
      Vl([
        "min",
        "max"
      ], function(i) {
        var a = t.get(i + "Span"), o = t.get(i + "ValueSpan");
        o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = ht(n[0] + o, n, [
          0,
          100
        ], true) : a != null && (o = ht(a, [
          0,
          100
        ], n, true) - n[0]), e[i + "Span"] = a, e[i + "ValueSpan"] = o;
      }, this);
    }, r.prototype._setAxisModel = function() {
      var e = this.getAxisModel(), t = this._percentWindow, n = this._valueWindow;
      if (t) {
        var i = wR(n, [
          0,
          500
        ]);
        i = Math.min(i, 20);
        var a = e.axis.scale.rawExtentInfo;
        t[0] !== 0 && a.setDeterminedMinMax("min", +n[0].toFixed(i)), t[1] !== 100 && a.setDeterminedMinMax("max", +n[1].toFixed(i)), a.freeze();
      }
    }, r;
  }();
  function oie(r, e, t) {
    var n = [
      1 / 0,
      -1 / 0
    ];
    Vl(t, function(o) {
      z7(n, o.getData(), e);
    });
    var i = r.getAxisModel(), a = uN(i.axis.scale, i, n).calculate();
    return [
      a.min,
      a.max
    ];
  }
  var sie = {
    getTargetSeries: function(r) {
      function e(i) {
        r.eachComponent("dataZoom", function(a) {
          a.eachTargetAxis(function(o, s) {
            var l = r.getComponent(Ja(o), s);
            i(o, s, l, a);
          });
        });
      }
      e(function(i, a, o, s) {
        o.__dzAxisProxy = null;
      });
      var t = [];
      e(function(i, a, o, s) {
        o.__dzAxisProxy || (o.__dzAxisProxy = new aie(i, a, s, r), t.push(o.__dzAxisProxy));
      });
      var n = ce();
      return D(t, function(i) {
        D(i.getTargetSeriesModels(), function(a) {
          n.set(a.uid, a);
        });
      }), n;
    },
    overallReset: function(r, e) {
      r.eachComponent("dataZoom", function(t) {
        t.eachTargetAxis(function(n, i) {
          t.getAxisProxy(n, i).reset(t);
        }), t.eachTargetAxis(function(n, i) {
          t.getAxisProxy(n, i).filterData(t, e);
        });
      }), r.eachComponent("dataZoom", function(t) {
        var n = t.findRepresentativeAxisProxy();
        if (n) {
          var i = n.getDataPercentWindow(), a = n.getDataValueWindow();
          t.setCalculatedRange({
            start: i[0],
            end: i[1],
            startValue: a[0],
            endValue: a[1]
          });
        }
      });
    }
  };
  function lie(r) {
    r.registerAction("dataZoom", function(e, t) {
      var n = rie(t, e);
      D(n, function(i) {
        i.setRawRange({
          start: e.start,
          end: e.end,
          startValue: e.startValue,
          endValue: e.endValue
        });
      });
    });
  }
  var OM = false;
  function VS(r) {
    OM || (OM = true, r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, sie), lie(r), r.registerSubTypeDefaulter("dataZoom", function() {
      return "slider";
    }));
  }
  function uie(r) {
    r.registerComponentModel(nie), r.registerComponentView(iie), VS(r);
  }
  var Ln = /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }(), YF = {};
  function $l(r, e) {
    YF[r] = e;
  }
  function XF(r) {
    return YF[r];
  }
  var cie = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      r.prototype.optionUpdated.apply(this, arguments);
      var t = this.ecModel;
      D(this.option.feature, function(n, i) {
        var a = XF(i);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(t)), Ee(n, a.defaultOption));
      });
    }, e.type = "toolbox", e.layoutMode = {
      type: "box",
      ignoreSize: true
    }, e.defaultOption = {
      show: true,
      z: 6,
      orient: "horizontal",
      left: "right",
      top: "top",
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: true,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      tooltip: {
        show: false,
        position: "bottom"
      }
    }, e;
  }(Ke);
  function hie(r, e, t) {
    var n = e.getBoxLayoutParams(), i = e.get("padding"), a = {
      width: t.getWidth(),
      height: t.getHeight()
    }, o = er(n, a, i);
    Ls(e.get("orient"), r, e.get("itemGap"), o.width, o.height), fg(r, n, a, i);
  }
  function qF(r, e) {
    var t = Ou(e.get("padding")), n = e.getItemStyle([
      "color",
      "opacity"
    ]);
    return n.fill = e.get("backgroundColor"), r = new et({
      shape: {
        x: r.x - t[3],
        y: r.y - t[0],
        width: r.width + t[1] + t[3],
        height: r.height + t[0] + t[2],
        r: e.get("borderRadius")
      },
      style: n,
      silent: true,
      z2: -1
    }), r;
  }
  var fie = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, n, i, a) {
      var o = this.group;
      if (o.removeAll(), !t.get("show")) return;
      var s = +t.get("itemSize"), l = t.get("orient") === "vertical", u = t.get("feature") || {}, c = this._features || (this._features = {}), h = [];
      D(u, function(p, v) {
        h.push(v);
      }), new ya(this._featureNames || [], h).add(f).update(f).remove(Le(f, null)).execute(), this._featureNames = h;
      function f(p, v) {
        var g = h[p], m = h[v], y = u[g], x = new ft(y, t, t.ecModel), _;
        if (a && a.newTitle != null && a.featureName === g && (y.title = a.newTitle), g && !m) {
          if (die(g)) _ = {
            onclick: x.option.onclick,
            featureName: g
          };
          else {
            var S = XF(g);
            if (!S) return;
            _ = new S();
          }
          c[g] = _;
        } else if (_ = c[m], !_) return;
        _.uid = Nu("toolbox-feature"), _.model = x, _.ecModel = n, _.api = i;
        var b = _ instanceof Ln;
        if (!g && m) {
          b && _.dispose && _.dispose(n, i);
          return;
        }
        if (!x.get("show") || b && _.unusable) {
          b && _.remove && _.remove(n, i);
          return;
        }
        d(x, _, g), x.setIconStatus = function(w, C) {
          var T = this.option, A = this.iconPaths;
          T.iconStatus = T.iconStatus || {}, T.iconStatus[w] = C, A[w] && (C === "emphasis" ? ga : ma)(A[w]);
        }, _ instanceof Ln && _.render && _.render(x, n, i, a);
      }
      function d(p, v, g) {
        var m = p.getModel("iconStyle"), y = p.getModel([
          "emphasis",
          "iconStyle"
        ]), x = v instanceof Ln && v.getIcons ? v.getIcons() : p.get("icon"), _ = p.get("title") || {}, S, b;
        ee(x) ? (S = {}, S[g] = x) : S = x, ee(_) ? (b = {}, b[g] = _) : b = _;
        var w = p.iconPaths = {};
        D(S, function(C, T) {
          var A = bf(C, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          A.setStyle(m.getItemStyle());
          var M = A.ensureState("emphasis");
          M.style = y.getItemStyle();
          var E = new rt({
            style: {
              text: b[T],
              align: y.get("textAlign"),
              borderRadius: y.get("textBorderRadius"),
              padding: y.get("textPadding"),
              fill: null,
              font: m1({
                fontStyle: y.get("textFontStyle"),
                fontFamily: y.get("textFontFamily"),
                fontSize: y.get("textFontSize"),
                fontWeight: y.get("textFontWeight")
              }, n)
            },
            ignore: true
          });
          A.setTextContent(E), Ks({
            el: A,
            componentModel: t,
            itemName: T,
            formatterParamsExtra: {
              title: b[T]
            }
          }), A.__title = b[T], A.on("mouseover", function() {
            var k = y.getItemStyle(), R = l ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top";
            E.setStyle({
              fill: y.get("textFill") || k.fill || k.stroke || "#000",
              backgroundColor: y.get("textBackgroundColor")
            }), A.setTextConfig({
              position: y.get("textPosition") || R
            }), E.ignore = !t.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get([
              "iconStatus",
              T
            ]) !== "emphasis" && i.leaveEmphasis(this), E.hide();
          }), (p.get([
            "iconStatus",
            T
          ]) === "emphasis" ? ga : ma)(A), o.add(A), A.on("click", ne(v.onclick, v, n, i, T)), w[T] = A;
        });
      }
      hie(o, t, i), o.add(qF(o.getBoundingRect(), t)), l || o.eachChild(function(p) {
        var v = p.__title, g = p.ensureState("emphasis"), m = g.textConfig || (g.textConfig = {}), y = p.getTextContent(), x = y && y.ensureState("emphasis");
        if (x && !ge(x) && v) {
          var _ = x.style || (x.style = {}), S = pf(v, rt.makeFont(_)), b = p.x + o.x, w = p.y + o.y + s, C = false;
          w + S.height > i.getHeight() && (m.position = "top", C = true);
          var T = C ? -5 - S.height : s + 10;
          b + S.width / 2 > i.getWidth() ? (m.position = [
            "100%",
            T
          ], _.align = "right") : b - S.width / 2 < 0 && (m.position = [
            0,
            T
          ], _.align = "left");
        }
      });
    }, e.prototype.updateView = function(t, n, i, a) {
      D(this._features, function(o) {
        o instanceof Ln && o.updateView && o.updateView(o.model, n, i, a);
      });
    }, e.prototype.remove = function(t, n) {
      D(this._features, function(i) {
        i instanceof Ln && i.remove && i.remove(t, n);
      }), this.group.removeAll();
    }, e.prototype.dispose = function(t, n) {
      D(this._features, function(i) {
        i instanceof Ln && i.dispose && i.dispose(t, n);
      });
    }, e.type = "toolbox", e;
  }(Rt);
  function die(r) {
    return r.indexOf("my") === 0;
  }
  var pie = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, n) {
      var i = this.model, a = i.get("name") || t.get("title.0.text") || "echarts", o = n.getZr().painter.getType() === "svg", s = o ? "svg" : i.get("type", true) || "png", l = n.getConnectedDataURL({
        type: s,
        backgroundColor: i.get("backgroundColor", true) || t.get("backgroundColor") || "#fff",
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = He.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = a + "." + s, c.target = "_blank", c.href = l;
        var h = new MouseEvent("click", {
          view: document.defaultView,
          bubbles: true,
          cancelable: false
        });
        c.dispatchEvent(h);
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var f = l.split(","), d = f[0].indexOf("base64") > -1, p = o ? decodeURIComponent(f[1]) : f[1];
        d && (p = window.atob(p));
        var v = a + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var g = p.length, m = new Uint8Array(g); g--; ) m[g] = p.charCodeAt(g);
          var y = new Blob([
            m
          ]);
          window.navigator.msSaveOrOpenBlob(y, v);
        } else {
          var x = document.createElement("iframe");
          document.body.appendChild(x);
          var _ = x.contentWindow, S = _.document;
          S.open("image/svg+xml", "replace"), S.write(p), S.close(), _.focus(), S.execCommand("SaveAs", true, v), document.body.removeChild(x);
        }
      } else {
        var b = i.get("lang"), w = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (b && b[0] || "") + '" /></body>', C = window.open();
        C.document.write(w), C.document.title = a;
      }
    }, e.getDefaultOption = function(t) {
      var n = {
        show: true,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: t.getLocaleModel().get([
          "toolbox",
          "saveAsImage",
          "title"
        ]),
        type: "png",
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: [
          "toolbox"
        ],
        lang: t.getLocaleModel().get([
          "toolbox",
          "saveAsImage",
          "lang"
        ])
      };
      return n;
    }, e;
  }(Ln), FM = "__ec_magicType_stack__", vie = [
    [
      "line",
      "bar"
    ],
    [
      "stack"
    ]
  ], gie = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getIcons = function() {
      var t = this.model, n = t.get("icon"), i = {};
      return D(t.get("type"), function(a) {
        n[a] && (i[a] = n[a]);
      }), i;
    }, e.getDefaultOption = function(t) {
      var n = {
        show: true,
        type: [],
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
        },
        title: t.getLocaleModel().get([
          "toolbox",
          "magicType",
          "title"
        ]),
        option: {},
        seriesIndex: {}
      };
      return n;
    }, e.prototype.onclick = function(t, n, i) {
      var a = this.model, o = a.get([
        "seriesIndex",
        i
      ]);
      if (BM[i]) {
        var s = {
          series: []
        }, l = function(h) {
          var f = h.subType, d = h.id, p = BM[i](f, d, h, a);
          p && (ye(p, h.option), s.series.push(p));
          var v = h.coordinateSystem;
          if (v && v.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var g = v.getAxesByScale("ordinal")[0];
            if (g) {
              var m = g.dim, y = m + "Axis", x = h.getReferringComponents(y, Yt).models[0], _ = x.componentIndex;
              s[y] = s[y] || [];
              for (var S = 0; S <= _; S++) s[y][_] = s[y][_] || {};
              s[y][_].boundaryGap = i === "bar";
            }
          }
        };
        D(vie, function(h) {
          Be(h, i) >= 0 && D(h, function(f) {
            a.setIconStatus(f, "normal");
          });
        }), a.setIconStatus(i, "emphasis"), t.eachComponent({
          mainType: "series",
          query: o == null ? null : {
            seriesIndex: o
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = Ee({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get([
          "iconStatus",
          i
        ]) !== "emphasis" && (c = "tiled")), n.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, e;
  }(Ln), BM = {
    line: function(r, e, t, n) {
      if (r === "bar") return Ee({
        id: e,
        type: "line",
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, n.get([
        "option",
        "line"
      ]) || {}, true);
    },
    bar: function(r, e, t, n) {
      if (r === "line") return Ee({
        id: e,
        type: "bar",
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, n.get([
        "option",
        "bar"
      ]) || {}, true);
    },
    stack: function(r, e, t, n) {
      var i = t.get("stack") === FM;
      if (r === "line" || r === "bar") return n.setIconStatus("stack", i ? "normal" : "emphasis"), Ee({
        id: e,
        stack: i ? "" : FM
      }, n.get([
        "option",
        "stack"
      ]) || {}, true);
    }
  };
  Ui({
    type: "changeMagicType",
    event: "magicTypeChanged",
    update: "prepareAndUpdate"
  }, function(r, e) {
    e.mergeOption(r.newOption);
  });
  var Dg = new Array(60).join("-"), mu = "	";
  function mie(r) {
    var e = {}, t = [], n = [];
    return r.eachRawSeries(function(i) {
      var a = i.coordinateSystem;
      if (a && (a.type === "cartesian2d" || a.type === "polar")) {
        var o = a.getBaseAxis();
        if (o.type === "category") {
          var s = o.dim + "_" + o.index;
          e[s] || (e[s] = {
            categoryAxis: o,
            valueAxis: a.getOtherAxis(o),
            series: []
          }, n.push({
            axisDim: o.dim,
            axisIndex: o.index
          })), e[s].series.push(i);
        } else t.push(i);
      } else t.push(i);
    }), {
      seriesGroupByCategoryAxis: e,
      other: t,
      meta: n
    };
  }
  function yie(r) {
    var e = [];
    return D(r, function(t, n) {
      var i = t.categoryAxis, a = t.valueAxis, o = a.dim, s = [
        " "
      ].concat(K(t.series, function(d) {
        return d.name;
      })), l = [
        i.model.getCategories()
      ];
      D(t.series, function(d) {
        var p = d.getRawData();
        l.push(d.getRawData().mapArray(p.mapDimension(o), function(v) {
          return v;
        }));
      });
      for (var u = [
        s.join(mu)
      ], c = 0; c < l[0].length; c++) {
        for (var h = [], f = 0; f < l.length; f++) h.push(l[f][c]);
        u.push(h.join(mu));
      }
      e.push(u.join(`
`));
    }), e.join(`

` + Dg + `

`);
  }
  function xie(r) {
    return K(r, function(e) {
      var t = e.getRawData(), n = [
        e.name
      ], i = [];
      return t.each(t.dimensions, function() {
        for (var a = arguments.length, o = arguments[a - 1], s = t.getName(o), l = 0; l < a - 1; l++) i[l] = arguments[l];
        n.push((s ? s + mu : "") + i.join(mu));
      }), n.join(`
`);
    }).join(`

` + Dg + `

`);
  }
  function _ie(r) {
    var e = mie(r);
    return {
      value: ct([
        yie(e.seriesGroupByCategoryAxis),
        xie(e.other)
      ], function(t) {
        return !!t.replace(/[\n\t\s]/g, "");
      }).join(`

` + Dg + `

`),
      meta: e.meta
    };
  }
  function _v(r) {
    return r.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function bie(r) {
    var e = r.slice(0, r.indexOf(`
`));
    if (e.indexOf(mu) >= 0) return true;
  }
  var N_ = new RegExp("[" + mu + "]+", "g");
  function Sie(r) {
    for (var e = r.split(/\n+/g), t = _v(e.shift()).split(N_), n = [], i = K(t, function(l) {
      return {
        name: l,
        data: []
      };
    }), a = 0; a < e.length; a++) {
      var o = _v(e[a]).split(N_);
      n.push(o.shift());
      for (var s = 0; s < o.length; s++) i[s] && (i[s].data[a] = o[s]);
    }
    return {
      series: i,
      categories: n
    };
  }
  function wie(r) {
    for (var e = r.split(/\n+/g), t = _v(e.shift()), n = [], i = 0; i < e.length; i++) {
      var a = _v(e[i]);
      if (a) {
        var o = a.split(N_), s = "", l = void 0, u = false;
        isNaN(o[0]) ? (u = true, s = o[0], o = o.slice(1), n[i] = {
          name: s,
          value: []
        }, l = n[i].value) : l = n[i] = [];
        for (var c = 0; c < o.length; c++) l.push(+o[c]);
        l.length === 1 && (u ? n[i].value = l[0] : n[i] = l[0]);
      }
    }
    return {
      name: t,
      data: n
    };
  }
  function Cie(r, e) {
    var t = r.split(new RegExp(`
*` + Dg + `
*`, "g")), n = {
      series: []
    };
    return D(t, function(i, a) {
      if (bie(i)) {
        var o = Sie(i), s = e[a], l = s.axisDim + "Axis";
        s && (n[l] = n[l] || [], n[l][s.axisIndex] = {
          data: o.categories
        }, n.series = n.series.concat(o.series));
      } else {
        var o = wie(i);
        n.series.push(o);
      }
    }), n;
  }
  var Tie = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, n) {
      setTimeout(function() {
        n.dispatchAction({
          type: "hideTip"
        });
      });
      var i = n.getDom(), a = this.model;
      this._dom && i.removeChild(this._dom);
      var o = document.createElement("div");
      o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
      var s = document.createElement("h4"), l = a.get("lang") || [];
      s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var h = a.get("optionToContent"), f = a.get("contentToOption"), d = _ie(t);
      if (ge(h)) {
        var p = h(n.getOption());
        ee(p) ? u.innerHTML = p : su(p) && u.appendChild(p);
      } else {
        c.readOnly = a.get("readOnly");
        var v = c.style;
        v.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", v.color = a.get("textColor"), v.borderColor = a.get("textareaBorderColor"), v.backgroundColor = a.get("textareaColor"), c.value = d.value, u.appendChild(c);
      }
      var g = d.meta, m = document.createElement("div");
      m.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", x = document.createElement("div"), _ = document.createElement("div");
      y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
      var S = this;
      function b() {
        i.removeChild(o), S._dom = null;
      }
      fx(x, "click", b), fx(_, "click", function() {
        if (f == null && h != null || f != null && h == null) {
          b();
          return;
        }
        var w;
        try {
          ge(f) ? w = f(u, n.getOption()) : w = Cie(c.value, g);
        } catch (C) {
          throw b(), new Error("Data view format error " + C);
        }
        w && n.dispatchAction({
          type: "changeDataView",
          newOption: w
        }), b();
      }), x.innerHTML = l[1], _.innerHTML = l[2], _.style.cssText = x.style.cssText = y, !a.get("readOnly") && m.appendChild(_), m.appendChild(x), o.appendChild(s), o.appendChild(u), o.appendChild(m), u.style.height = i.clientHeight - 80 + "px", i.appendChild(o), this._dom = o;
    }, e.prototype.remove = function(t, n) {
      this._dom && n.getDom().removeChild(this._dom);
    }, e.prototype.dispose = function(t, n) {
      this.remove(t, n);
    }, e.getDefaultOption = function(t) {
      var n = {
        show: true,
        readOnly: false,
        optionToContent: null,
        contentToOption: null,
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: t.getLocaleModel().get([
          "toolbox",
          "dataView",
          "title"
        ]),
        lang: t.getLocaleModel().get([
          "toolbox",
          "dataView",
          "lang"
        ]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return n;
    }, e;
  }(Ln);
  function Aie(r, e) {
    return K(r, function(t, n) {
      var i = e && e[n];
      if (_e(i) && !X(i)) {
        var a = _e(t) && !X(t);
        a || (t = {
          value: t
        });
        var o = i.name != null && t.name == null;
        return t = ye(t, i), o && delete t.name, t;
      } else return t;
    });
  }
  Ui({
    type: "changeDataView",
    event: "dataViewChanged",
    update: "prepareAndUpdate"
  }, function(r, e) {
    var t = [];
    D(r.newOption.series, function(n) {
      var i = e.getSeriesByName(n.name)[0];
      if (!i) t.push(H({
        type: "scatter"
      }, n));
      else {
        var a = i.get("data");
        t.push({
          name: n.name,
          data: Aie(n.data, a)
        });
      }
    }), e.mergeOption(ye({
      series: t
    }, r.newOption));
  });
  var KF = D, ZF = tt();
  function Iie(r, e) {
    var t = $S(r);
    KF(e, function(n, i) {
      for (var a = t.length - 1; a >= 0; a--) {
        var o = t[a];
        if (o[i]) break;
      }
      if (a < 0) {
        var s = r.queryComponents({
          mainType: "dataZoom",
          subType: "select",
          id: i
        })[0];
        if (s) {
          var l = s.getPercentRange();
          t[0][i] = {
            dataZoomId: i,
            start: l[0],
            end: l[1]
          };
        }
      }
    }), t.push(e);
  }
  function Mie(r) {
    var e = $S(r), t = e[e.length - 1];
    e.length > 1 && e.pop();
    var n = {};
    return KF(t, function(i, a) {
      for (var o = e.length - 1; o >= 0; o--) if (i = e[o][a], i) {
        n[a] = i;
        break;
      }
    }), n;
  }
  function Die(r) {
    ZF(r).snapshots = null;
  }
  function Pie(r) {
    return $S(r).length;
  }
  function $S(r) {
    var e = ZF(r);
    return e.snapshots || (e.snapshots = [
      {}
    ]), e.snapshots;
  }
  var kie = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, n) {
      Die(t), n.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, e.getDefaultOption = function(t) {
      var n = {
        show: true,
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: t.getLocaleModel().get([
          "toolbox",
          "restore",
          "title"
        ])
      };
      return n;
    }, e;
  }(Ln);
  Ui({
    type: "restore",
    event: "restore",
    update: "prepareAndUpdate"
  }, function(r, e) {
    e.resetOption("recreate");
  });
  var Lie = [
    "grid",
    "xAxis",
    "yAxis",
    "geo",
    "graph",
    "polar",
    "radiusAxis",
    "angleAxis",
    "bmap"
  ], GS = function() {
    function r(e, t, n) {
      var i = this;
      this._targetInfoList = [];
      var a = zM(t, e);
      D(Rie, function(o, s) {
        (!n || !n.include || Be(n.include, s) >= 0) && o(a, i._targetInfoList);
      });
    }
    return r.prototype.setOutputRanges = function(e, t) {
      return this.matchOutputRanges(e, t, function(n, i, a) {
        if ((n.coordRanges || (n.coordRanges = [])).push(i), !n.coordRange) {
          n.coordRange = i;
          var o = e0[n.brushType](0, a, i);
          n.__rangeOffset = {
            offset: WM[n.brushType](o.values, n.range, [
              1,
              1
            ]),
            xyMinMax: o.xyMinMax
          };
        }
      }), e;
    }, r.prototype.matchOutputRanges = function(e, t, n) {
      D(e, function(i) {
        var a = this.findTargetInfo(i, t);
        a && a !== true && D(a.coordSyses, function(o) {
          var s = e0[i.brushType](1, o, i.range, true);
          n(i, s.values, o, t);
        });
      }, this);
    }, r.prototype.setInputRanges = function(e, t) {
      D(e, function(n) {
        var i = this.findTargetInfo(n, t);
        if (n.range = n.range || [], i && i !== true) {
          n.panelId = i.panelId;
          var a = e0[n.brushType](0, i.coordSys, n.coordRange), o = n.__rangeOffset;
          n.range = o ? WM[n.brushType](a.values, o.offset, Eie(a.xyMinMax, o.xyMinMax)) : a.values;
        }
      }, this);
    }, r.prototype.makePanelOpts = function(e, t) {
      return K(this._targetInfoList, function(n) {
        var i = n.getPanelRect();
        return {
          panelId: n.panelId,
          defaultBrushType: t ? t(n) : null,
          clipPath: iF(i),
          isTargetByCursor: oF(i, e, n.coordSysModel),
          getLinearBrushOtherExtent: aF(i)
        };
      });
    }, r.prototype.controlSeries = function(e, t, n) {
      var i = this.findTargetInfo(e, n);
      return i === true || i && Be(i.coordSyses, t.coordinateSystem) >= 0;
    }, r.prototype.findTargetInfo = function(e, t) {
      for (var n = this._targetInfoList, i = zM(t, e), a = 0; a < n.length; a++) {
        var o = n[a], s = e.panelId;
        if (s) {
          if (o.panelId === s) return o;
        } else for (var l = 0; l < VM.length; l++) if (VM[l](i, o)) return o;
      }
      return true;
    }, r;
  }();
  function O_(r) {
    return r[0] > r[1] && r.reverse(), r;
  }
  function zM(r, e) {
    return Qc(r, e, {
      includeMainTypes: Lie
    });
  }
  var Rie = {
    grid: function(r, e) {
      var t = r.xAxisModels, n = r.yAxisModels, i = r.gridModels, a = ce(), o = {}, s = {};
      !t && !n && !i || (D(t, function(l) {
        var u = l.axis.grid.model;
        a.set(u.id, u), o[u.id] = true;
      }), D(n, function(l) {
        var u = l.axis.grid.model;
        a.set(u.id, u), s[u.id] = true;
      }), D(i, function(l) {
        a.set(l.id, l), o[l.id] = true, s[l.id] = true;
      }), a.each(function(l) {
        var u = l.coordinateSystem, c = [];
        D(u.getCartesians(), function(h, f) {
          (Be(t, h.getAxis("x").model) >= 0 || Be(n, h.getAxis("y").model) >= 0) && c.push(h);
        }), e.push({
          panelId: "grid--" + l.id,
          gridModel: l,
          coordSysModel: l,
          coordSys: c[0],
          coordSyses: c,
          getPanelRect: $M.grid,
          xAxisDeclared: o[l.id],
          yAxisDeclared: s[l.id]
        });
      }));
    },
    geo: function(r, e) {
      D(r.geoModels, function(t) {
        var n = t.coordinateSystem;
        e.push({
          panelId: "geo--" + t.id,
          geoModel: t,
          coordSysModel: t,
          coordSys: n,
          coordSyses: [
            n
          ],
          getPanelRect: $M.geo
        });
      });
    }
  }, VM = [
    function(r, e) {
      var t = r.xAxisModel, n = r.yAxisModel, i = r.gridModel;
      return !i && t && (i = t.axis.grid.model), !i && n && (i = n.axis.grid.model), i && i === e.gridModel;
    },
    function(r, e) {
      var t = r.geoModel;
      return t && t === e.geoModel;
    }
  ], $M = {
    grid: function() {
      return this.coordSys.master.getRect().clone();
    },
    geo: function() {
      var r = this.coordSys, e = r.getBoundingRect().clone();
      return e.applyTransform(ks(r)), e;
    }
  }, e0 = {
    lineX: Le(GM, 0),
    lineY: Le(GM, 1),
    rect: function(r, e, t, n) {
      var i = r ? e.pointToData([
        t[0][0],
        t[1][0]
      ], n) : e.dataToPoint([
        t[0][0],
        t[1][0]
      ], n), a = r ? e.pointToData([
        t[0][1],
        t[1][1]
      ], n) : e.dataToPoint([
        t[0][1],
        t[1][1]
      ], n), o = [
        O_([
          i[0],
          a[0]
        ]),
        O_([
          i[1],
          a[1]
        ])
      ];
      return {
        values: o,
        xyMinMax: o
      };
    },
    polygon: function(r, e, t, n) {
      var i = [
        [
          1 / 0,
          -1 / 0
        ],
        [
          1 / 0,
          -1 / 0
        ]
      ], a = K(t, function(o) {
        var s = r ? e.pointToData(o, n) : e.dataToPoint(o, n);
        return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s;
      });
      return {
        values: a,
        xyMinMax: i
      };
    }
  };
  function GM(r, e, t, n) {
    var i = t.getAxis([
      "x",
      "y"
    ][r]), a = O_(K([
      0,
      1
    ], function(s) {
      return e ? i.coordToData(i.toLocalCoord(n[s]), true) : i.toGlobalCoord(i.dataToCoord(n[s]));
    })), o = [];
    return o[r] = a, o[1 - r] = [
      NaN,
      NaN
    ], {
      values: a,
      xyMinMax: o
    };
  }
  var WM = {
    lineX: Le(UM, 0),
    lineY: Le(UM, 1),
    rect: function(r, e, t) {
      return [
        [
          r[0][0] - t[0] * e[0][0],
          r[0][1] - t[0] * e[0][1]
        ],
        [
          r[1][0] - t[1] * e[1][0],
          r[1][1] - t[1] * e[1][1]
        ]
      ];
    },
    polygon: function(r, e, t) {
      return K(r, function(n, i) {
        return [
          n[0] - t[0] * e[i][0],
          n[1] - t[1] * e[i][1]
        ];
      });
    }
  };
  function UM(r, e, t, n) {
    return [
      e[0] - n[r] * t[0],
      e[1] - n[r] * t[1]
    ];
  }
  function Eie(r, e) {
    var t = HM(r), n = HM(e), i = [
      t[0] / n[0],
      t[1] / n[1]
    ];
    return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
  }
  function HM(r) {
    return r ? [
      r[0][1] - r[0][0],
      r[1][1] - r[1][0]
    ] : [
      NaN,
      NaN
    ];
  }
  var F_ = D, Nie = GH("toolbox-dataZoom_"), Oie = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, n, i, a) {
      this._brushController || (this._brushController = new vS(i.getZr()), this._brushController.on("brush", ne(this._onBrush, this)).mount()), zie(t, n, this, a, i), Bie(t, n);
    }, e.prototype.onclick = function(t, n, i) {
      Fie[i].call(this);
    }, e.prototype.remove = function(t, n) {
      this._brushController && this._brushController.unmount();
    }, e.prototype.dispose = function(t, n) {
      this._brushController && this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var n = t.areas;
      if (!t.isEnd || !n.length) return;
      var i = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var o = new GS(WS(this.model), a, {
        include: [
          "grid"
        ]
      });
      o.matchOutputRanges(n, a, function(u, c, h) {
        if (h.type === "cartesian2d") {
          var f = u.brushType;
          f === "rect" ? (s("x", h, c[0]), s("y", h, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[f], h, c);
        }
      }), Iie(a, i), this._dispatchZoomAction(i);
      function s(u, c, h) {
        var f = c.getAxis(u), d = f.model, p = l(u, d, a), v = p.findRepresentativeAxisProxy(d).getMinMaxSpan();
        (v.minValueSpan != null || v.maxValueSpan != null) && (h = tl(0, h.slice(), f.scale.getExtent(), 0, v.minValueSpan, v.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: h[0],
          endValue: h[1]
        });
      }
      function l(u, c, h) {
        var f;
        return h.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(d) {
          var p = d.getAxisModel(u, c.componentIndex);
          p && (f = d);
        }), f;
      }
    }, e.prototype._dispatchZoomAction = function(t) {
      var n = [];
      F_(t, function(i, a) {
        n.push(be(i));
      }), n.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: n
      });
    }, e.getDefaultOption = function(t) {
      var n = {
        show: true,
        filterMode: "filter",
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        title: t.getLocaleModel().get([
          "toolbox",
          "dataZoom",
          "title"
        ]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return n;
    }, e;
  }(Ln), Fie = {
    zoom: function() {
      var r = !this._isZoomActive;
      this.api.dispatchAction({
        type: "takeGlobalCursor",
        key: "dataZoomSelect",
        dataZoomSelectActive: r
      });
    },
    back: function() {
      this._dispatchZoomAction(Mie(this.ecModel));
    }
  };
  function WS(r) {
    var e = {
      xAxisIndex: r.get("xAxisIndex", true),
      yAxisIndex: r.get("yAxisIndex", true),
      xAxisId: r.get("xAxisId", true),
      yAxisId: r.get("yAxisId", true)
    };
    return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e;
  }
  function Bie(r, e) {
    r.setIconStatus("back", Pie(e) > 1 ? "emphasis" : "normal");
  }
  function zie(r, e, t, n, i) {
    var a = t._isZoomActive;
    n && n.type === "takeGlobalCursor" && (a = n.key === "dataZoomSelect" ? n.dataZoomSelectActive : false), t._isZoomActive = a, r.setIconStatus("zoom", a ? "emphasis" : "normal");
    var o = new GS(WS(r), e, {
      include: [
        "grid"
      ]
    }), s = o.makePanelOpts(i, function(l) {
      return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
    });
    t._brushController.setPanels(s).enableBrush(a && s.length ? {
      brushType: "auto",
      brushStyle: r.getModel("brushStyle").getItemStyle()
    } : false);
  }
  dY("dataZoom", function(r) {
    var e = r.getComponent("toolbox", 0), t = [
      "feature",
      "dataZoom"
    ];
    if (!e || e.get(t) == null) return;
    var n = e.getModel(t), i = [], a = WS(n), o = Qc(r, a);
    F_(o.xAxisModels, function(l) {
      return s(l, "xAxis", "xAxisIndex");
    }), F_(o.yAxisModels, function(l) {
      return s(l, "yAxis", "yAxisIndex");
    });
    function s(l, u, c) {
      var h = l.componentIndex, f = {
        type: "select",
        $fromToolbox: true,
        filterMode: n.get("filterMode", true) || "filter",
        id: Nie + u + h
      };
      f[c] = h, i.push(f);
    }
    return i;
  });
  function Vie(r) {
    r.registerComponentModel(cie), r.registerComponentView(fie), $l("saveAsImage", pie), $l("magicType", gie), $l("dataView", Tie), $l("dataZoom", Oie), $l("restore", kie), Ve(uie);
  }
  var $ie = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "tooltip", e.dependencies = [
      "axisPointer"
    ], e.defaultOption = {
      z: 60,
      show: true,
      showContent: true,
      trigger: "item",
      triggerOn: "mousemove|click",
      alwaysShowContent: false,
      displayMode: "single",
      renderMode: "auto",
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: false,
      backgroundColor: "#fff",
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      borderRadius: 4,
      borderWidth: 1,
      padding: null,
      extraCssText: "",
      axisPointer: {
        type: "line",
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          textStyle: {}
        }
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, e;
  }(Ke);
  function jF(r) {
    var e = r.get("confine");
    return e != null ? !!e : r.get("renderMode") === "richText";
  }
  function QF(r) {
    if (He.domSupported) {
      for (var e = document.documentElement.style, t = 0, n = r.length; t < n; t++) if (r[t] in e) return r[t];
    }
  }
  var JF = QF([
    "transform",
    "webkitTransform",
    "OTransform",
    "MozTransform",
    "msTransform"
  ]), Gie = QF([
    "webkitTransition",
    "transition",
    "OTransition",
    "MozTransition",
    "msTransition"
  ]);
  function eB(r, e) {
    if (!r) return e;
    e = LE(e, true);
    var t = r.indexOf(e);
    return r = t === -1 ? e : "-" + r.slice(0, t) + "-" + e, r.toLowerCase();
  }
  function Wie(r, e) {
    var t = r.currentStyle || document.defaultView && document.defaultView.getComputedStyle(r);
    return t ? t[e] : null;
  }
  var Uie = eB(Gie, "transition"), US = eB(JF, "transform"), Hie = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (He.transform3dSupported ? "will-change:transform;" : "");
  function Yie(r) {
    return r = r === "left" ? "right" : r === "right" ? "left" : r === "top" ? "bottom" : "top", r;
  }
  function Xie(r, e, t) {
    if (!ee(t) || t === "inside") return "";
    var n = r.get("backgroundColor"), i = r.get("borderWidth");
    e = Gs(e);
    var a = Yie(t), o = Math.max(Math.round(i) * 1.5, 6), s = "", l = US + ":", u;
    Be([
      "left",
      "right"
    ], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
    var c = u * Math.PI / 180, h = o + i, f = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), d = Math.round(((f - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (f - h) / 2) * 100) / 100;
    s += ";" + a + ":-" + d + "px";
    var p = e + " solid " + i + "px;", v = [
      "position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;",
      s + ";" + l + ";",
      "border-bottom:" + p,
      "border-right:" + p,
      "background-color:" + n + ";"
    ];
    return '<div style="' + v.join("") + '"></div>';
  }
  function qie(r, e) {
    var t = "cubic-bezier(0.23,1,0.32,1)", n = " " + r / 2 + "s " + t, i = "opacity" + n + ",visibility" + n;
    return e || (n = " " + r + "s " + t, i += He.transformSupported ? "," + US + n : ",left" + n + ",top" + n), Uie + ":" + i;
  }
  function YM(r, e, t) {
    var n = r.toFixed(0) + "px", i = e.toFixed(0) + "px";
    if (!He.transformSupported) return t ? "top:" + i + ";left:" + n + ";" : [
      [
        "top",
        i
      ],
      [
        "left",
        n
      ]
    ];
    var a = He.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + n + "," + i + (a ? ",0" : "") + ")";
    return t ? "top:0;left:0;" + US + ":" + o + ";" : [
      [
        "top",
        0
      ],
      [
        "left",
        0
      ],
      [
        JF,
        o
      ]
    ];
  }
  function Kie(r) {
    var e = [], t = r.get("fontSize"), n = r.getTextColor();
    n && e.push("color:" + n), e.push("font:" + r.getFont());
    var i = Pe(r.get("lineHeight"), Math.round(t * 3 / 2));
    t && e.push("line-height:" + i + "px");
    var a = r.get("textShadowColor"), o = r.get("textShadowBlur") || 0, s = r.get("textShadowOffsetX") || 0, l = r.get("textShadowOffsetY") || 0;
    return a && o && e.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), D([
      "decoration",
      "align"
    ], function(u) {
      var c = r.get(u);
      c && e.push("text-" + u + ":" + c);
    }), e.join(";");
  }
  function Zie(r, e, t) {
    var n = [], i = r.get("transitionDuration"), a = r.get("backgroundColor"), o = r.get("shadowBlur"), s = r.get("shadowColor"), l = r.get("shadowOffsetX"), u = r.get("shadowOffsetY"), c = r.getModel("textStyle"), h = f3(r, "html"), f = l + "px " + u + "px " + o + "px " + s;
    return n.push("box-shadow:" + f), e && i && n.push(qie(i, t)), a && n.push("background-color:" + a), D([
      "width",
      "color",
      "radius"
    ], function(d) {
      var p = "border-" + d, v = LE(p), g = r.get(v);
      g != null && n.push(p + ":" + g + (d === "color" ? "" : "px"));
    }), n.push(Kie(c)), h != null && n.push("padding:" + Ou(h).join("px ") + "px"), n.join(";") + ";";
  }
  function XM(r, e, t, n, i) {
    var a = e && e.painter;
    if (t) {
      var o = a && a.getViewportRoot();
      o && mU(r, o, t, n, i);
    } else {
      r[0] = n, r[1] = i;
      var s = a && a.getViewportRootOffset();
      s && (r[0] += s.offsetLeft, r[1] += s.offsetTop);
    }
    r[2] = r[0] / e.getWidth(), r[3] = r[1] / e.getHeight();
  }
  var jie = function() {
    function r(e, t) {
      if (this._show = false, this._styleCoord = [
        0,
        0,
        0,
        0
      ], this._enterable = true, this._alwaysShowContent = false, this._firstShow = true, this._longHide = true, He.wxa) return null;
      var n = document.createElement("div");
      n.domBelongToZr = true, this.el = n;
      var i = this._zr = e.getZr(), a = t.appendTo, o = a && (ee(a) ? document.querySelector(a) : su(a) ? a : ge(a) && a(e.getDom()));
      XM(this._styleCoord, i, o, e.getWidth() / 2, e.getHeight() / 2), (o || e.getDom()).appendChild(n), this._api = e, this._container = o;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = true), s._inContent = true;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          In(c, l, true), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = false, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return r.prototype.update = function(e) {
      if (!this._container) {
        var t = this._api.getDom(), n = Wie(t, "position"), i = t.style;
        i.position !== "absolute" && n !== "absolute" && (i.position = "relative");
      }
      var a = e.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = e.get("className") || "";
    }, r.prototype.show = function(e, t) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, i = n.style, a = this._styleCoord;
      n.innerHTML ? i.cssText = Hie + Zie(e, !this._firstShow, this._longHide) + YM(a[0], a[1], true) + ("border-color:" + Gs(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = true, this._firstShow = false, this._longHide = false;
    }, r.prototype.setContent = function(e, t, n, i, a) {
      var o = this.el;
      if (e == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (ee(a) && n.get("trigger") === "item" && !jF(n) && (s = Xie(n, i, a)), ee(e)) o.innerHTML = e + s;
      else if (e) {
        o.innerHTML = "", X(e) || (e = [
          e
        ]);
        for (var l = 0; l < e.length; l++) su(e[l]) && e[l].parentNode !== o && o.appendChild(e[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, r.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, r.prototype.getSize = function() {
      var e = this.el;
      return e ? [
        e.offsetWidth,
        e.offsetHeight
      ] : [
        0,
        0
      ];
    }, r.prototype.moveTo = function(e, t) {
      if (this.el) {
        var n = this._styleCoord;
        if (XM(n, this._zr, this._container, e, t), n[0] != null && n[1] != null) {
          var i = this.el.style, a = YM(n[0], n[1]);
          D(a, function(o) {
            i[o[0]] = o[1];
          });
        }
      }
    }, r.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, r.prototype.hide = function() {
      var e = this, t = this.el.style;
      t.visibility = "hidden", t.opacity = "0", He.transform3dSupported && (t.willChange = ""), this._show = false, this._longHideTimeout = setTimeout(function() {
        return e._longHide = true;
      }, 500);
    }, r.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = false, this._hideTimeout = setTimeout(ne(this.hide, this), e)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var e = this.el.parentNode;
      e && e.removeChild(this.el), this.el = this._container = null;
    }, r;
  }(), Qie = function() {
    function r(e) {
      this._show = false, this._styleCoord = [
        0,
        0,
        0,
        0
      ], this._alwaysShowContent = false, this._enterable = true, this._zr = e.getZr(), KM(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2);
    }
    return r.prototype.update = function(e) {
      var t = e.get("alwaysShowContent");
      t && this._moveIfResized(), this._alwaysShowContent = t;
    }, r.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = true;
    }, r.prototype.setContent = function(e, t, n, i, a) {
      var o = this;
      _e(e) && ut(""), this.el && this._zr.remove(this.el);
      var s = n.getModel("textStyle");
      this.el = new rt({
        style: {
          rich: t.richTextStyles,
          text: e,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: n.get([
            "textStyle",
            "color"
          ]),
          padding: f3(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), D([
        "backgroundColor",
        "borderRadius",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY"
      ], function(u) {
        o.el.style[u] = n.get(u);
      }), D([
        "textShadowBlur",
        "textShadowOffsetX",
        "textShadowOffsetY"
      ], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = true), l._inContent = true;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = false;
      });
    }, r.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, r.prototype.getSize = function() {
      var e = this.el, t = this.el.getBoundingRect(), n = qM(e.style);
      return [
        t.width + n.left + n.right,
        t.height + n.top + n.bottom
      ];
    }, r.prototype.moveTo = function(e, t) {
      var n = this.el;
      if (n) {
        var i = this._styleCoord;
        KM(i, this._zr, e, t), e = i[0], t = i[1];
        var a = n.style, o = Va(a.borderWidth || 0), s = qM(a);
        n.x = e + o + s.left, n.y = t + o + s.top, n.markRedraw();
      }
    }, r.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, r.prototype.hide = function() {
      this.el && this.el.hide(), this._show = false;
    }, r.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = false, this._hideTimeout = setTimeout(ne(this.hide, this), e)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, r;
  }();
  function Va(r) {
    return Math.max(0, r);
  }
  function qM(r) {
    var e = Va(r.shadowBlur || 0), t = Va(r.shadowOffsetX || 0), n = Va(r.shadowOffsetY || 0);
    return {
      left: Va(e - t),
      right: Va(e + t),
      top: Va(e - n),
      bottom: Va(e + n)
    };
  }
  function KM(r, e, t, n) {
    r[0] = t, r[1] = n, r[2] = r[0] / e.getWidth(), r[3] = r[1] / e.getHeight();
  }
  var Jie = new et({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  }), eae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n) {
      if (!(He.node || !n.getDom())) {
        var i = t.getComponent("tooltip"), a = this._renderMode = KH(i.get("renderMode"));
        this._tooltipContent = a === "richText" ? new Qie(n) : new jie(n, {
          appendTo: i.get("appendToBody", true) ? "body" : i.get("appendTo", true)
        });
      }
    }, e.prototype.render = function(t, n, i) {
      if (!(He.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = t, this._ecModel = n, this._api = i;
        var a = this._tooltipContent;
        a.update(t), a.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? Vu(this, "_updatePosition", 50, "fixRate") : Lh(this, "_updatePosition");
      }
    }, e.prototype._initGlobalListener = function() {
      var t = this._tooltipModel, n = t.get("triggerOn");
      BF("itemTooltip", this._api, ne(function(i, a, o) {
        n !== "none" && (n.indexOf(i) >= 0 ? this._tryShow(a, o) : i === "leave" && this._hide(o));
      }, this));
    }, e.prototype._keepShow = function() {
      var t = this._tooltipModel, n = this._ecModel, i = this._api, a = t.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && o.manuallyShowTip(t, n, i, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, e.prototype.manuallyShowTip = function(t, n, i, a) {
      if (!(a.from === this.uid || He.node || !i.getDom())) {
        var o = ZM(a, i);
        this._ticket = "";
        var s = a.dataByCoordSys, l = iae(a, n, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = Jie;
          c.x = a.x, c.y = a.y, c.update(), De(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, o);
        } else if (s) this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          dataByCoordSys: s,
          tooltipOption: a.tooltipOption
        }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(t, n, i, a)) return;
          var h = zF(a, n), f = h.point[0], d = h.point[1];
          f != null && d != null && this._tryShow({
            offsetX: f,
            offsetY: d,
            target: h.el,
            position: a.position,
            positionDefault: "bottom"
          }, o);
        } else a.x != null && a.y != null && (i.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: i.getZr().findHover(a.x, a.y).target
        }, o));
      }
    }, e.prototype.manuallyHideTip = function(t, n, i, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(ZM(a, i));
    }, e.prototype._manuallyAxisShowTip = function(t, n, i, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = n.getSeriesByIndex(o);
        if (u) {
          var c = u.getData(), h = yc([
            c.getItemModel(s),
            u,
            (u.coordinateSystem || {}).model
          ], this._tooltipModel);
          if (h.get("trigger") === "axis") return i.dispatchAction({
            type: "updateAxisPointer",
            seriesIndex: o,
            dataIndex: s,
            position: a.position
          }), true;
        }
      }
    }, e.prototype._tryShow = function(t, n) {
      var i = t.target, a = this._tooltipModel;
      if (a) {
        this._lastX = t.offsetX, this._lastY = t.offsetY;
        var o = t.dataByCoordSys;
        if (o && o.length) this._showAxisTooltip(o, t);
        else if (i) {
          var s = De(i);
          if (s.ssrType === "legend") return;
          this._lastDataByCoordSys = null;
          var l, u;
          xs(i, function(c) {
            if (De(c).dataIndex != null) return l = c, true;
            if (De(c).tooltipConfig != null) return u = c, true;
          }, true), l ? this._showSeriesItemTooltip(t, l, n) : u ? this._showComponentItemTooltip(t, u, n) : this._hide(n);
        } else this._lastDataByCoordSys = null, this._hide(n);
      }
    }, e.prototype._showOrMove = function(t, n) {
      var i = t.get("showDelay");
      n = ne(n, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(n, i) : n();
    }, e.prototype._showAxisTooltip = function(t, n) {
      var i = this._ecModel, a = this._tooltipModel, o = [
        n.offsetX,
        n.offsetY
      ], s = yc([
        n.tooltipOption
      ], a), l = this._renderMode, u = [], c = ur("section", {
        blocks: [],
        noHeader: true
      }), h = [], f = new zm();
      D(t, function(y) {
        D(y.dataByAxis, function(x) {
          var _ = i.getComponent(x.axisDim + "Axis", x.axisIndex), S = x.value;
          if (!(!_ || S == null)) {
            var b = NF(S, _.axis, i, x.seriesDataIndices, x.valueLabelOpt), w = ur("section", {
              header: b,
              noHeader: !ei(b),
              sortBlocks: true,
              blocks: []
            });
            c.blocks.push(w), D(x.seriesDataIndices, function(C) {
              var T = i.getSeriesByIndex(C.seriesIndex), A = C.dataIndexInside, M = T.getDataParams(A);
              if (!(M.dataIndex < 0)) {
                M.axisDim = x.axisDim, M.axisIndex = x.axisIndex, M.axisType = x.axisType, M.axisId = x.axisId, M.axisValue = W1(_.axis, {
                  value: S
                }), M.axisValueLabel = b, M.marker = f.makeTooltipMarker("item", Gs(M.color), l);
                var E = O2(T.formatTooltip(A, true, null)), k = E.frag;
                if (k) {
                  var R = yc([
                    T
                  ], a).get("valueFormatter");
                  w.blocks.push(R ? H({
                    valueFormatter: R
                  }, k) : k);
                }
                E.text && h.push(E.text), u.push(M);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var d = n.position, p = s.get("order"), v = G2(c, f, l, p, i.get("useUTC"), s.get("textStyle"));
      v && h.unshift(v);
      var g = l === "richText" ? `

` : "<br/>", m = h.join(g);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(t, u) ? this._updatePosition(s, d, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, m, u, Math.random() + "", o[0], o[1], d, null, f);
      });
    }, e.prototype._showSeriesItemTooltip = function(t, n, i) {
      var a = this._ecModel, o = De(n), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, c = o.dataIndex, h = o.dataType, f = u.getData(h), d = this._renderMode, p = t.positionDefault, v = yc([
        f.getItemModel(c),
        u,
        l && (l.coordinateSystem || {}).model
      ], this._tooltipModel, p ? {
        position: p
      } : null), g = v.get("trigger");
      if (!(g != null && g !== "item")) {
        var m = u.getDataParams(c, h), y = new zm();
        m.marker = y.makeTooltipMarker("item", Gs(m.color), d);
        var x = O2(u.formatTooltip(c, false, h)), _ = v.get("order"), S = v.get("valueFormatter"), b = x.frag, w = b ? G2(S ? H({
          valueFormatter: S
        }, b) : b, y, d, _, a.get("useUTC"), v.get("textStyle")) : x.text, C = "item_" + u.name + "_" + c;
        this._showOrMove(v, function() {
          this._showTooltipContent(v, w, m, C, t.offsetX, t.offsetY, t.position, t.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: f.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, e.prototype._showComponentItemTooltip = function(t, n, i) {
      var a = this._renderMode === "html", o = De(n), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (ee(l)) {
        var c = l;
        l = {
          content: c,
          formatter: c
        }, u = true;
      }
      u && a && l.content && (l = be(l), l.content = Vr(l.content));
      var h = [
        l
      ], f = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
      f && h.push(f), h.push({
        formatter: l.content
      });
      var d = t.positionDefault, p = yc(h, this._tooltipModel, d ? {
        position: d
      } : null), v = p.get("content"), g = Math.random() + "", m = new zm();
      this._showOrMove(p, function() {
        var y = be(p.get("formatterParams") || {});
        this._showTooltipContent(p, v, y, g, t.offsetX, t.offsetY, t.position, n, m);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, e.prototype._showTooltipContent = function(t, n, i, a, o, s, l, u, c) {
      if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(t.get("enterable"));
        var f = t.get("formatter");
        l = l || t.get("position");
        var d = n, p = this._getNearestPoint([
          o,
          s
        ], i, t.get("trigger"), t.get("borderColor")), v = p.color;
        if (f) if (ee(f)) {
          var g = t.ecModel.get("useUTC"), m = X(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
          d = f, y && (d = sg(m.axisValue, d, g)), d = RE(d, i, true);
        } else if (ge(f)) {
          var x = ne(function(_, S) {
            _ === this._ticket && (h.setContent(S, c, t, v, l), this._updatePosition(t, l, o, s, h, i, u));
          }, this);
          this._ticket = a, d = f(i, a, x);
        } else d = f;
        h.setContent(d, c, t, v, l), h.show(t, v), this._updatePosition(t, l, o, s, h, i, u);
      }
    }, e.prototype._getNearestPoint = function(t, n, i, a) {
      if (i === "axis" || X(n)) return {
        color: a || (this._renderMode === "html" ? "#fff" : "none")
      };
      if (!X(n)) return {
        color: a || n.color || n.borderColor
      };
    }, e.prototype._updatePosition = function(t, n, i, a, o, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || t.get("position");
      var h = o.getSize(), f = t.get("align"), d = t.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), ge(n) && (n = n([
        i,
        a
      ], s, o.el, p, {
        viewSize: [
          u,
          c
        ],
        contentSize: h.slice()
      })), X(n)) i = Q(n[0], u), a = Q(n[1], c);
      else if (_e(n)) {
        var v = n;
        v.width = h[0], v.height = h[1];
        var g = er(v, {
          width: u,
          height: c
        });
        i = g.x, a = g.y, f = null, d = null;
      } else if (ee(n) && l) {
        var m = nae(n, p, h, t.get("borderWidth"));
        i = m[0], a = m[1];
      } else {
        var m = tae(i, a, o, u, c, f ? null : 20, d ? null : 20);
        i = m[0], a = m[1];
      }
      if (f && (i -= jM(f) ? h[0] / 2 : f === "right" ? h[0] : 0), d && (a -= jM(d) ? h[1] / 2 : d === "bottom" ? h[1] : 0), jF(t)) {
        var m = rae(i, a, o, u, c);
        i = m[0], a = m[1];
      }
      o.moveTo(i, a);
    }, e.prototype._updateContentNotChangedOnAxis = function(t, n) {
      var i = this._lastDataByCoordSys, a = this._cbParamsList, o = !!i && i.length === t.length;
      return o && D(i, function(s, l) {
        var u = s.dataByAxis || [], c = t[l] || {}, h = c.dataByAxis || [];
        o = o && u.length === h.length, o && D(u, function(f, d) {
          var p = h[d] || {}, v = f.seriesDataIndices || [], g = p.seriesDataIndices || [];
          o = o && f.value === p.value && f.axisType === p.axisType && f.axisId === p.axisId && v.length === g.length, o && D(v, function(m, y) {
            var x = g[y];
            o = o && m.seriesIndex === x.seriesIndex && m.dataIndex === x.dataIndex;
          }), a && D(f.seriesDataIndices, function(m) {
            var y = m.seriesIndex, x = n[y], _ = a[y];
            x && _ && _.data !== x.data && (o = false);
          });
        });
      }), this._lastDataByCoordSys = t, this._cbParamsList = n, !!o;
    }, e.prototype._hide = function(t) {
      this._lastDataByCoordSys = null, t({
        type: "hideTip",
        from: this.uid
      });
    }, e.prototype.dispose = function(t, n) {
      He.node || !n.getDom() || (Lh(this, "_updatePosition"), this._tooltipContent.dispose(), L_("itemTooltip", n));
    }, e.type = "tooltip", e;
  }(Rt);
  function yc(r, e, t) {
    var n = e.ecModel, i;
    t ? (i = new ft(t, n, n), i = new ft(e.option, i, n)) : i = e;
    for (var a = r.length - 1; a >= 0; a--) {
      var o = r[a];
      o && (o instanceof ft && (o = o.get("tooltip", true)), ee(o) && (o = {
        formatter: o
      }), o && (i = new ft(o, i, n)));
    }
    return i;
  }
  function ZM(r, e) {
    return r.dispatchAction || ne(e.dispatchAction, e);
  }
  function tae(r, e, t, n, i, a, o) {
    var s = t.getSize(), l = s[0], u = s[1];
    return a != null && (r + l + a + 2 > n ? r -= l + a : r += a), o != null && (e + u + o > i ? e -= u + o : e += o), [
      r,
      e
    ];
  }
  function rae(r, e, t, n, i) {
    var a = t.getSize(), o = a[0], s = a[1];
    return r = Math.min(r + o, n) - o, e = Math.min(e + s, i) - s, r = Math.max(r, 0), e = Math.max(e, 0), [
      r,
      e
    ];
  }
  function nae(r, e, t, n) {
    var i = t[0], a = t[1], o = Math.ceil(Math.SQRT2 * n) + 8, s = 0, l = 0, u = e.width, c = e.height;
    switch (r) {
      case "inside":
        s = e.x + u / 2 - i / 2, l = e.y + c / 2 - a / 2;
        break;
      case "top":
        s = e.x + u / 2 - i / 2, l = e.y - a - o;
        break;
      case "bottom":
        s = e.x + u / 2 - i / 2, l = e.y + c + o;
        break;
      case "left":
        s = e.x - i - o, l = e.y + c / 2 - a / 2;
        break;
      case "right":
        s = e.x + u + o, l = e.y + c / 2 - a / 2;
    }
    return [
      s,
      l
    ];
  }
  function jM(r) {
    return r === "center" || r === "middle";
  }
  function iae(r, e, t) {
    var n = i1(r).queryOptionMap, i = n.keys()[0];
    if (!(!i || i === "series")) {
      var a = vf(e, i, n.get(i), {
        useDefault: false,
        enableAll: false,
        enableNone: false
      }), o = a.models[0];
      if (o) {
        var s = t.getViewOfComponentModel(o), l;
        if (s.group.traverse(function(u) {
          var c = De(u).tooltipConfig;
          if (c && c.name === r.name) return l = u, true;
        }), l) return {
          componentMainType: i,
          componentIndex: o.componentIndex,
          el: l
        };
      }
    }
  }
  function aae(r) {
    Ve(Ef), r.registerComponentModel($ie), r.registerComponentView(eae), r.registerAction({
      type: "showTip",
      event: "showTip",
      update: "tooltip:manuallyShowTip"
    }, Wt), r.registerAction({
      type: "hideTip",
      event: "hideTip",
      update: "tooltip:manuallyHideTip"
    }, Wt);
  }
  var oae = [
    "rect",
    "polygon",
    "keep",
    "clear"
  ];
  function sae(r, e) {
    var t = gt(r ? r.brush : []);
    if (t.length) {
      var n = [];
      D(t, function(l) {
        var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
        u instanceof Array && (n = n.concat(u));
      });
      var i = r && r.toolbox;
      X(i) && (i = i[0]), i || (i = {
        feature: {}
      }, r.toolbox = [
        i
      ]);
      var a = i.feature || (i.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
      s.push.apply(s, n), lae(s), e && !s.length && s.push.apply(s, oae);
    }
  }
  function lae(r) {
    var e = {};
    D(r, function(t) {
      e[t] = 1;
    }), r.length = 0, D(e, function(t, n) {
      r.push(n);
    });
  }
  var QM = D;
  function JM(r) {
    if (r) {
      for (var e in r) if (r.hasOwnProperty(e)) return true;
    }
  }
  function B_(r, e, t) {
    var n = {};
    return QM(e, function(a) {
      var o = n[a] = i();
      QM(r[a], function(s, l) {
        if (or.isValidType(l)) {
          var u = {
            type: l,
            visual: s
          };
          t && t(u, a), o[l] = new or(u), l === "opacity" && (u = be(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new or(u));
        }
      });
    }), n;
    function i() {
      var a = function() {
      };
      a.prototype.__hidden = a.prototype;
      var o = new a();
      return o;
    }
  }
  function tB(r, e, t) {
    var n;
    D(t, function(i) {
      e.hasOwnProperty(i) && JM(e[i]) && (n = true);
    }), n && D(t, function(i) {
      e.hasOwnProperty(i) && JM(e[i]) ? r[i] = be(e[i]) : delete r[i];
    });
  }
  function uae(r, e, t, n, i, a) {
    var o = {};
    D(r, function(h) {
      var f = or.prepareVisualTypes(e[h]);
      o[h] = f;
    });
    var s;
    function l(h) {
      return R1(t, s, h);
    }
    function u(h, f) {
      S3(t, s, h, f);
    }
    t.each(c);
    function c(h, f) {
      s = h;
      var d = t.getRawDataItem(s);
      if (!(d && d.visualMap === false)) for (var p = n.call(i, h), v = e[p], g = o[p], m = 0, y = g.length; m < y; m++) {
        var x = g[m];
        v[x] && v[x].applyVisual(h, l, u);
      }
    }
  }
  function cae(r, e, t, n) {
    var i = {};
    return D(r, function(a) {
      var o = or.prepareVisualTypes(e[a]);
      i[a] = o;
    }), {
      progress: function(o, s) {
        var l;
        n != null && (l = s.getDimensionIndex(n));
        function u(S) {
          return R1(s, h, S);
        }
        function c(S, b) {
          S3(s, h, S, b);
        }
        for (var h, f = s.getStore(); (h = o.next()) != null; ) {
          var d = s.getRawDataItem(h);
          if (!(d && d.visualMap === false)) for (var p = n != null ? f.get(l, h) : h, v = t(p), g = e[v], m = i[v], y = 0, x = m.length; y < x; y++) {
            var _ = m[y];
            g[_] && g[_].applyVisual(p, u, c);
          }
        }
      }
    };
  }
  function hae(r) {
    var e = r.brushType, t = {
      point: function(n) {
        return eD[e].point(n, t, r);
      },
      rect: function(n) {
        return eD[e].rect(n, t, r);
      }
    };
    return t;
  }
  var eD = {
    lineX: tD(0),
    lineY: tD(1),
    rect: {
      point: function(r, e, t) {
        return r && t.boundingRect.contain(r[0], r[1]);
      },
      rect: function(r, e, t) {
        return r && t.boundingRect.intersect(r);
      }
    },
    polygon: {
      point: function(r, e, t) {
        return r && t.boundingRect.contain(r[0], r[1]) && cs(t.range, r[0], r[1]);
      },
      rect: function(r, e, t) {
        var n = t.range;
        if (!r || n.length <= 1) return false;
        var i = r.x, a = r.y, o = r.width, s = r.height, l = n[0];
        if (cs(n, i, a) || cs(n, i + o, a) || cs(n, i, a + s) || cs(n, i + o, a + s) || Oe.create(r).contain(l[0], l[1]) || Rc(i, a, i + o, a, n) || Rc(i, a, i, a + s, n) || Rc(i + o, a, i + o, a + s, n) || Rc(i, a + s, i + o, a + s, n)) return true;
      }
    }
  };
  function tD(r) {
    var e = [
      "x",
      "y"
    ], t = [
      "width",
      "height"
    ];
    return {
      point: function(n, i, a) {
        if (n) {
          var o = a.range, s = n[r];
          return xc(s, o);
        }
      },
      rect: function(n, i, a) {
        if (n) {
          var o = a.range, s = [
            n[e[r]],
            n[e[r]] + n[t[r]]
          ];
          return s[1] < s[0] && s.reverse(), xc(s[0], o) || xc(s[1], o) || xc(o[0], s) || xc(o[1], s);
        }
      }
    };
  }
  function xc(r, e) {
    return e[0] <= r && r <= e[1];
  }
  var rD = [
    "inBrush",
    "outOfBrush"
  ], t0 = "__ecBrushSelect", z_ = "__ecInBrushSelectEvent";
  function rB(r) {
    r.eachComponent({
      mainType: "brush"
    }, function(e) {
      var t = e.brushTargetManager = new GS(e.option, r);
      t.setInputRanges(e.areas, r);
    });
  }
  function fae(r, e, t) {
    var n = [], i, a;
    r.eachComponent({
      mainType: "brush"
    }, function(o) {
      t && t.type === "takeGlobalCursor" && o.setBrushOption(t.key === "brush" ? t.brushOption : {
        brushType: false
      });
    }), rB(r), r.eachComponent({
      mainType: "brush"
    }, function(o, s) {
      var l = {
        brushId: o.id,
        brushIndex: s,
        brushName: o.name,
        areas: be(o.areas),
        selected: []
      };
      n.push(l);
      var u = o.option, c = u.brushLink, h = [], f = [], d = [], p = false;
      s || (i = u.throttleType, a = u.throttleDelay);
      var v = K(o.areas, function(S) {
        var b = gae[S.brushType], w = ye({
          boundingRect: b ? b(S) : void 0
        }, S);
        return w.selectors = hae(w), w;
      }), g = B_(o.option, rD, function(S) {
        S.mappingMethod = "fixed";
      });
      X(c) && D(c, function(S) {
        h[S] = 1;
      });
      function m(S) {
        return c === "all" || !!h[S];
      }
      function y(S) {
        return !!S.length;
      }
      r.eachSeries(function(S, b) {
        var w = d[b] = [];
        S.subType === "parallel" ? x(S, b) : _(S, b, w);
      });
      function x(S, b) {
        var w = S.coordinateSystem;
        p = p || w.hasAxisBrushed(), m(b) && w.eachActiveState(S.getData(), function(C, T) {
          C === "active" && (f[T] = 1);
        });
      }
      function _(S, b, w) {
        if (!(!S.brushSelector || vae(o, b)) && (D(v, function(T) {
          o.brushTargetManager.controlSeries(T, S, r) && w.push(T), p = p || y(w);
        }), m(b) && y(w))) {
          var C = S.getData();
          C.each(function(T) {
            nD(S, w, C, T) && (f[T] = 1);
          });
        }
      }
      r.eachSeries(function(S, b) {
        var w = {
          seriesId: S.id,
          seriesIndex: b,
          seriesName: S.name,
          dataIndex: []
        };
        l.selected.push(w);
        var C = d[b], T = S.getData(), A = m(b) ? function(M) {
          return f[M] ? (w.dataIndex.push(T.getRawIndex(M)), "inBrush") : "outOfBrush";
        } : function(M) {
          return nD(S, C, T, M) ? (w.dataIndex.push(T.getRawIndex(M)), "inBrush") : "outOfBrush";
        };
        (m(b) ? p : y(C)) && uae(rD, g, T, A);
      });
    }), dae(e, i, a, n, t);
  }
  function dae(r, e, t, n, i) {
    if (i) {
      var a = r.getZr();
      if (!a[z_]) {
        a[t0] || (a[t0] = pae);
        var o = Vu(a, t0, t, e);
        o(r, n);
      }
    }
  }
  function pae(r, e) {
    if (!r.isDisposed()) {
      var t = r.getZr();
      t[z_] = true, r.dispatchAction({
        type: "brushSelect",
        batch: e
      }), t[z_] = false;
    }
  }
  function nD(r, e, t, n) {
    for (var i = 0, a = e.length; i < a; i++) {
      var o = e[i];
      if (r.brushSelector(n, t, o.selectors, o)) return true;
    }
  }
  function vae(r, e) {
    var t = r.option.seriesIndex;
    return t != null && t !== "all" && (X(t) ? Be(t, e) < 0 : e !== t);
  }
  var gae = {
    rect: function(r) {
      return iD(r.range);
    },
    polygon: function(r) {
      for (var e, t = r.range, n = 0, i = t.length; n < i; n++) {
        e = e || [
          [
            1 / 0,
            -1 / 0
          ],
          [
            1 / 0,
            -1 / 0
          ]
        ];
        var a = t[n];
        a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]);
      }
      return e && iD(e);
    }
  };
  function iD(r) {
    return new Oe(r[0][0], r[1][0], r[0][1] - r[0][0], r[1][1] - r[1][0]);
  }
  var mae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n) {
      this.ecModel = t, this.api = n, this.model, (this._brushController = new vS(n.getZr())).on("brush", ne(this._onBrush, this)).mount();
    }, e.prototype.render = function(t, n, i, a) {
      this.model = t, this._updateController(t, n, i, a);
    }, e.prototype.updateTransform = function(t, n, i, a) {
      rB(n), this._updateController(t, n, i, a);
    }, e.prototype.updateVisual = function(t, n, i, a) {
      this.updateTransform(t, n, i, a);
    }, e.prototype.updateView = function(t, n, i, a) {
      this._updateController(t, n, i, a);
    }, e.prototype._updateController = function(t, n, i, a) {
      (!a || a.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var n = this.model.id, i = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel);
      (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: n,
        areas: be(i),
        $from: n
      }), t.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: n,
        areas: be(i),
        $from: n
      });
    }, e.type = "brush", e;
  }(Rt), yae = "#ddd", xae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.areas = [], t.brushOption = {}, t;
    }
    return e.prototype.optionUpdated = function(t, n) {
      var i = this.option;
      !n && tB(i, t, [
        "inBrush",
        "outOfBrush"
      ]);
      var a = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: yae
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, e.prototype.setAreas = function(t) {
      t && (this.areas = K(t, function(n) {
        return aD(this.option, n);
      }, this));
    }, e.prototype.setBrushOption = function(t) {
      this.brushOption = aD(this.option, t), this.brushType = this.brushOption.brushType;
    }, e.type = "brush", e.dependencies = [
      "geo",
      "grid",
      "xAxis",
      "yAxis",
      "parallel",
      "series"
    ], e.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: true,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: true,
      z: 1e4
    }, e;
  }(Ke);
  function aD(r, e) {
    return Ee({
      brushType: r.brushType,
      brushMode: r.brushMode,
      transformable: r.transformable,
      brushStyle: new ft(r.brushStyle).getItemStyle(),
      removeOnClick: r.removeOnClick,
      z: r.z
    }, e, true);
  }
  var _ae = [
    "rect",
    "polygon",
    "lineX",
    "lineY",
    "keep",
    "clear"
  ], bae = function(r) {
    G(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, n, i) {
      var a, o, s;
      n.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = a, this._brushMode = o, D(t.get("type", true), function(l) {
        t.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
      });
    }, e.prototype.updateView = function(t, n, i) {
      this.render(t, n, i);
    }, e.prototype.getIcons = function() {
      var t = this.model, n = t.get("icon", true), i = {};
      return D(t.get("type", true), function(a) {
        n[a] && (i[a] = n[a]);
      }), i;
    }, e.prototype.onclick = function(t, n, i) {
      var a = this._brushType, o = this._brushMode;
      i === "clear" ? (n.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), n.dispatchAction({
        type: "brush",
        command: "clear",
        areas: []
      })) : n.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? a : a === i ? false : i,
          brushMode: i === "keep" ? o === "multiple" ? "single" : "multiple" : o
        }
      });
    }, e.getDefaultOption = function(t) {
      var n = {
        show: true,
        type: _ae.slice(),
        icon: {
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        },
        title: t.getLocaleModel().get([
          "toolbox",
          "brush",
          "title"
        ])
      };
      return n;
    }, e;
  }(Ln);
  function Sae(r) {
    r.registerComponentView(mae), r.registerComponentModel(xae), r.registerPreprocessor(sae), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, fae), r.registerAction({
      type: "brush",
      event: "brush",
      update: "updateVisual"
    }, function(e, t) {
      t.eachComponent({
        mainType: "brush",
        query: e
      }, function(n) {
        n.setAreas(e.areas);
      });
    }), r.registerAction({
      type: "brushSelect",
      event: "brushSelected",
      update: "none"
    }, Wt), r.registerAction({
      type: "brushEnd",
      event: "brushEnd",
      update: "none"
    }, Wt), $l("brush", bae);
  }
  var wae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: true
      }, t;
    }
    return e.type = "title", e.defaultOption = {
      z: 6,
      show: true,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, e;
  }(Ke), Cae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, n, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var a = this.group, o = t.getModel("textStyle"), s = t.getModel("subtextStyle"), l = t.get("textAlign"), u = Pe(t.get("textBaseline"), t.get("textVerticalAlign")), c = new rt({
          style: wt(o, {
            text: t.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        }), h = c.getBoundingRect(), f = t.get("subtext"), d = new rt({
          style: wt(s, {
            text: f,
            fill: s.getTextColor(),
            y: h.height + t.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: true
          }),
          z2: 10
        }), p = t.get("link"), v = t.get("sublink"), g = t.get("triggerEvent", true);
        c.silent = !p && !g, d.silent = !v && !g, p && c.on("click", function() {
          Zp(p, "_" + t.get("target"));
        }), v && d.on("click", function() {
          Zp(v, "_" + t.get("subtarget"));
        }), De(c).eventData = De(d).eventData = g ? {
          componentType: "title",
          componentIndex: t.componentIndex
        } : null, a.add(c), f && a.add(d);
        var m = a.getBoundingRect(), y = t.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var x = er(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, t.get("padding"));
        l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? x.x += x.width : l === "center" && (x.x += x.width / 2)), u || (u = t.get("top") || t.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? x.y += x.height : u === "middle" && (x.y += x.height / 2), u = u || "top"), a.x = x.x, a.y = x.y, a.markRedraw();
        var _ = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(_), d.setStyle(_), m = a.getBoundingRect();
        var S = x.margin, b = t.getItemStyle([
          "color",
          "opacity"
        ]);
        b.fill = t.get("backgroundColor");
        var w = new et({
          shape: {
            x: m.x - S[3],
            y: m.y - S[0],
            width: m.width + S[1] + S[3],
            height: m.height + S[0] + S[2],
            r: t.get("borderRadius")
          },
          style: b,
          subPixelOptimize: true,
          silent: true
        });
        a.add(w);
      }
    }, e.type = "title", e;
  }(Rt);
  function Tae(r) {
    r.registerComponentModel(wae), r.registerComponentView(Cae);
  }
  var oD = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = "box", t;
    }
    return e.prototype.init = function(t, n, i) {
      this.mergeDefaultAndTheme(t, i), this._initData();
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), this._initData();
    }, e.prototype.setCurrentIndex = function(t) {
      t == null && (t = this.option.currentIndex);
      var n = this._data.count();
      this.option.loop ? t = (t % n + n) % n : (t >= n && (t = n - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
    }, e.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, e.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, e.prototype.setPlayState = function(t) {
      this.option.autoPlay = !!t;
    }, e.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, e.prototype._initData = function() {
      var t = this.option, n = t.data || [], i = t.axisType, a = this._names = [], o;
      i === "category" ? (o = [], D(n, function(u, c) {
        var h = jt(ku(u), ""), f;
        _e(u) ? (f = be(u), f.value = c) : f = c, o.push(f), a.push(h);
      })) : o = n;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new Wr([
        {
          name: "value",
          type: s
        }
      ], this);
      l.initData(o, a);
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.getCategories = function() {
      if (this.get("axisType") === "category") return this._names.slice();
    }, e.type = "timeline", e.defaultOption = {
      z: 4,
      show: true,
      axisType: "time",
      realtime: true,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: false,
      rewind: false,
      loop: true,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, e;
  }(Ke), nB = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline.slider", e.defaultOption = yo(oD.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: false,
      tooltip: {
        trigger: "item"
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: true,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        show: true,
        interval: "auto",
        rotate: 0,
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        animation: true,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: true,
        showPlayBtn: true,
        showPrevBtn: true,
        showNextBtn: true,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true,
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), e;
  }(oD);
  qt(nB, pg.prototype);
  var Aae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline", e;
  }(Rt), Iae = function(r) {
    G(e, r);
    function e(t, n, i, a) {
      var o = r.call(this, t, n, i) || this;
      return o.type = a || "value", o;
    }
    return e.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, e.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, e;
  }(hi), r0 = Math.PI, sD = tt(), Mae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, n) {
      this.api = n;
    }, e.prototype.render = function(t, n, i) {
      if (this.model = t, this.api = i, this.ecModel = n, this.group.removeAll(), t.get("show", true)) {
        var a = this._layout(t, i), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, t);
        t.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return ur("nameValue", {
            noName: true,
            value: c
          });
        }, D([
          "AxisLine",
          "AxisTick",
          "Control",
          "CurrentPointer"
        ], function(u) {
          this["_render" + u](a, o, l, t);
        }, this), this._renderAxisLabel(a, s, l, t), this._position(a, t);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, e.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._clearTimer();
    }, e.prototype._layout = function(t, n) {
      var i = t.get([
        "label",
        "position"
      ]), a = t.get("orient"), o = Pae(t, n), s;
      i == null || i === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < n.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < n.getWidth() / 2 ? "+" : "-" : ee(i) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][i] : s = i;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: r0 / 2
      }, h = a === "vertical" ? o.height : o.width, f = t.getModel("controlStyle"), d = f.get("show", true), p = d ? f.get("itemSize") : 0, v = d ? f.get("itemGap") : 0, g = p + v, m = t.get([
        "label",
        "rotate"
      ]) || 0;
      m = m * r0 / 180;
      var y, x, _, S = f.get("position", true), b = d && f.get("showPlayBtn", true), w = d && f.get("showPrevBtn", true), C = d && f.get("showNextBtn", true), T = 0, A = h;
      S === "left" || S === "bottom" ? (b && (y = [
        0,
        0
      ], T += g), w && (x = [
        T,
        0
      ], T += g), C && (_ = [
        A - p,
        0
      ], A -= g)) : (b && (y = [
        A - p,
        0
      ], A -= g), w && (x = [
        0,
        0
      ], T += g), C && (_ = [
        A - p,
        0
      ], A -= g));
      var M = [
        T,
        A
      ];
      return t.get("inverse") && M.reverse(), {
        viewRect: o,
        mainLength: h,
        orient: a,
        rotation: c[a],
        labelRotation: m,
        labelPosOpt: s,
        labelAlign: t.get([
          "label",
          "align"
        ]) || l[a],
        labelBaseline: t.get([
          "label",
          "verticalAlign"
        ]) || t.get([
          "label",
          "baseline"
        ]) || u[a],
        playPosition: y,
        prevBtnPosition: x,
        nextBtnPosition: _,
        axisExtent: M,
        controlSize: p,
        controlGap: v
      };
    }, e.prototype._position = function(t, n) {
      var i = this._mainGroup, a = this._labelGroup, o = t.viewRect;
      if (t.orient === "vertical") {
        var s = pn(), l = o.x, u = o.y + o.height;
        Bi(s, s, [
          -l,
          -u
        ]), qs(s, s, -r0 / 2), Bi(s, s, [
          l,
          u
        ]), o = o.clone(), o.applyTransform(s);
      }
      var c = y(o), h = y(i.getBoundingRect()), f = y(a.getBoundingRect()), d = [
        i.x,
        i.y
      ], p = [
        a.x,
        a.y
      ];
      p[0] = d[0] = c[0][0];
      var v = t.labelPosOpt;
      if (v == null || ee(v)) {
        var g = v === "+" ? 0 : 1;
        x(d, h, c, 1, g), x(p, f, c, 1, 1 - g);
      } else {
        var g = v >= 0 ? 0 : 1;
        x(d, h, c, 1, g), p[1] = d[1] + v;
      }
      i.setPosition(d), a.setPosition(p), i.rotation = a.rotation = t.rotation, m(i), m(a);
      function m(_) {
        _.originX = c[0][0] - _.x, _.originY = c[1][0] - _.y;
      }
      function y(_) {
        return [
          [
            _.x,
            _.x + _.width
          ],
          [
            _.y,
            _.y + _.height
          ]
        ];
      }
      function x(_, S, b, w, C) {
        _[w] += b[w][C] - S[w][C];
      }
    }, e.prototype._createAxis = function(t, n) {
      var i = n.getData(), a = n.get("axisType"), o = Dae(n, a);
      o.getTicks = function() {
        return i.mapArray([
          "value"
        ], function(u) {
          return {
            value: u
          };
        });
      };
      var s = i.getDataExtent("value");
      o.setExtent(s[0], s[1]), o.calcNiceTicks();
      var l = new Iae("value", o, t.axisExtent, a);
      return l.model = n, l;
    }, e.prototype._createGroup = function(t) {
      var n = this[t] = new Ce();
      return this.group.add(n), n;
    }, e.prototype._renderAxisLine = function(t, n, i, a) {
      var o = i.getExtent();
      if (a.get([
        "lineStyle",
        "show"
      ])) {
        var s = new ir({
          shape: {
            x1: o[0],
            y1: 0,
            x2: o[1],
            y2: 0
          },
          style: H({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: true,
          z2: 1
        });
        n.add(s);
        var l = this._progressLine = new ir({
          shape: {
            x1: o[0],
            x2: this._currentPointer ? this._currentPointer.x : o[0],
            y1: 0,
            y2: 0
          },
          style: ye({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, a.getModel([
            "progress",
            "lineStyle"
          ]).getLineStyle()),
          silent: true,
          z2: 1
        });
        n.add(l);
      }
    }, e.prototype._renderAxisTick = function(t, n, i, a) {
      var o = this, s = a.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], D(l, function(u) {
        var c = i.dataToCoord(u.value), h = s.getItemModel(u.value), f = h.getModel("itemStyle"), d = h.getModel([
          "emphasis",
          "itemStyle"
        ]), p = h.getModel([
          "progress",
          "itemStyle"
        ]), v = {
          x: c,
          y: 0,
          onclick: ne(o._changeTimeline, o, u.value)
        }, g = lD(h, f, n, v);
        g.ensureState("emphasis").style = d.getItemStyle(), g.ensureState("progress").style = p.getItemStyle(), Ps(g);
        var m = De(g);
        h.get("tooltip") ? (m.dataIndex = u.value, m.dataModel = a) : m.dataIndex = m.dataModel = null, o._tickSymbols.push(g);
      });
    }, e.prototype._renderAxisLabel = function(t, n, i, a) {
      var o = this, s = i.getLabelModel();
      if (s.get("show")) {
        var l = a.getData(), u = i.getViewLabels();
        this._tickLabels = [], D(u, function(c) {
          var h = c.tickValue, f = l.getItemModel(h), d = f.getModel("label"), p = f.getModel([
            "emphasis",
            "label"
          ]), v = f.getModel([
            "progress",
            "label"
          ]), g = i.dataToCoord(c.tickValue), m = new rt({
            x: g,
            y: 0,
            rotation: t.labelRotation - t.rotation,
            onclick: ne(o._changeTimeline, o, h),
            silent: false,
            style: wt(d, {
              text: c.formattedLabel,
              align: t.labelAlign,
              verticalAlign: t.labelBaseline
            })
          });
          m.ensureState("emphasis").style = wt(p), m.ensureState("progress").style = wt(v), n.add(m), Ps(m), sD(m).dataIndex = h, o._tickLabels.push(m);
        });
      }
    }, e.prototype._renderControl = function(t, n, i, a) {
      var o = t.controlSize, s = t.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel([
        "emphasis",
        "controlStyle"
      ]).getItemStyle(), c = a.getPlayState(), h = a.get("inverse", true);
      f(t.nextBtnPosition, "next", ne(this._changeTimeline, this, h ? "-" : "+")), f(t.prevBtnPosition, "prev", ne(this._changeTimeline, this, h ? "+" : "-")), f(t.playPosition, c ? "stop" : "play", ne(this._handlePlayClick, this, !c), true);
      function f(d, p, v, g) {
        if (d) {
          var m = si(Pe(a.get([
            "controlStyle",
            p + "BtnSize"
          ]), o), o), y = [
            0,
            -m / 2,
            m,
            m
          ], x = kae(a, p + "Icon", y, {
            x: d[0],
            y: d[1],
            originX: o / 2,
            originY: 0,
            rotation: g ? -s : 0,
            rectHover: true,
            style: l,
            onclick: v
          });
          x.ensureState("emphasis").style = u, n.add(x), Ps(x);
        }
      }
    }, e.prototype._renderCurrentPointer = function(t, n, i, a) {
      var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(h) {
          h.draggable = true, h.drift = ne(u._handlePointerDrag, u), h.ondragend = ne(u._handlePointerDragend, u), uD(h, u._progressLine, s, i, a, true);
        },
        onUpdate: function(h) {
          uD(h, u._progressLine, s, i, a);
        }
      };
      this._currentPointer = lD(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, e.prototype._handlePlayClick = function(t) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: t,
        from: this.uid
      });
    }, e.prototype._handlePointerDrag = function(t, n, i) {
      this._clearTimer(), this._pointerChangeTimeline([
        i.offsetX,
        i.offsetY
      ]);
    }, e.prototype._handlePointerDragend = function(t) {
      this._pointerChangeTimeline([
        t.offsetX,
        t.offsetY
      ], true);
    }, e.prototype._pointerChangeTimeline = function(t, n) {
      var i = this._toAxisCoord(t)[0], a = this._axis, o = On(a.getExtent().slice());
      i > o[1] && (i = o[1]), i < o[0] && (i = o[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = i, s.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (n || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, e.prototype._doPlayStop = function() {
      var t = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var n = t.model;
        t._changeTimeline(n.getCurrentIndex() + (n.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, e.prototype._toAxisCoord = function(t) {
      var n = this._mainGroup.getLocalTransform();
      return ai(t, n, true);
    }, e.prototype._findNearestTick = function(t) {
      var n = this.model.getData(), i = 1 / 0, a, o = this._axis;
      return n.each([
        "value"
      ], function(s, l) {
        var u = o.dataToCoord(s), c = Math.abs(u - t);
        c < i && (i = c, a = l);
      }), a;
    }, e.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, e.prototype._changeTimeline = function(t) {
      var n = this.model.getCurrentIndex();
      t === "+" ? t = n + 1 : t === "-" && (t = n - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: t,
        from: this.uid
      });
    }, e.prototype._updateTicksStatus = function() {
      var t = this.model.getCurrentIndex(), n = this._tickSymbols, i = this._tickLabels;
      if (n) for (var a = 0; a < n.length; a++) n && n[a] && n[a].toggleState("progress", a < t);
      if (i) for (var a = 0; a < i.length; a++) i && i[a] && i[a].toggleState("progress", sD(i[a]).dataIndex <= t);
    }, e.type = "timeline.slider", e;
  }(Aae);
  function Dae(r, e) {
    if (e = e || r.get("type"), e) switch (e) {
      case "category":
        return new _g({
          ordinalMeta: r.getCategories(),
          extent: [
            1 / 0,
            -1 / 0
          ]
        });
      case "time":
        return new $1({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new xa();
    }
  }
  function Pae(r, e) {
    return er(r.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    }, r.get("padding"));
  }
  function kae(r, e, t, n) {
    var i = n.style, a = bf(r.get([
      "controlStyle",
      e
    ]), n || {}, new Oe(t[0], t[1], t[2], t[3]));
    return i && a.setStyle(i), a;
  }
  function lD(r, e, t, n, i, a) {
    var o = e.get("color");
    if (i) i.setColor(o), t.add(i), a && a.onUpdate(i);
    else {
      var s = r.get("symbol");
      i = Xt(s, -1, -1, 2, 2, o), i.setStyle("strokeNoScale", true), t.add(i), a && a.onCreate(i);
    }
    var l = e.getItemStyle([
      "color"
    ]);
    i.setStyle(l), n = Ee({
      rectHover: true,
      z2: 100
    }, n, true);
    var u = $u(r.get("symbolSize"));
    n.scaleX = u[0] / 2, n.scaleY = u[1] / 2;
    var c = js(r.get("symbolOffset"), u);
    c && (n.x = (n.x || 0) + c[0], n.y = (n.y || 0) + c[1]);
    var h = r.get("symbolRotate");
    return n.rotation = (h || 0) * Math.PI / 180 || 0, i.attr(n), i.updateTransform(), i;
  }
  function uD(r, e, t, n, i, a) {
    if (!r.dragging) {
      var o = i.getModel("checkpointStyle"), s = n.dataToCoord(i.getData().get("value", t));
      if (a || !o.get("animation", true)) r.attr({
        x: s,
        y: 0
      }), e && e.attr({
        shape: {
          x2: s
        }
      });
      else {
        var l = {
          duration: o.get("animationDuration", true),
          easing: o.get("animationEasing", true)
        };
        r.stopAnimation(null, true), r.animateTo({
          x: s,
          y: 0
        }, l), e && e.animateTo({
          shape: {
            x2: s
          }
        }, l);
      }
    }
  }
  function Lae(r) {
    r.registerAction({
      type: "timelineChange",
      event: "timelineChanged",
      update: "prepareAndUpdate"
    }, function(e, t, n) {
      var i = t.getComponent("timeline");
      return i && e.currentIndex != null && (i.setCurrentIndex(e.currentIndex), !i.get("loop", true) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(false), n.dispatchAction({
        type: "timelinePlayChange",
        playState: false,
        from: e.from
      }))), t.resetOption("timeline", {
        replaceMerge: i.get("replaceMerge", true)
      }), ye({
        currentIndex: i.option.currentIndex
      }, e);
    }), r.registerAction({
      type: "timelinePlayChange",
      event: "timelinePlayChanged",
      update: "update"
    }, function(e, t) {
      var n = t.getComponent("timeline");
      n && e.playState != null && n.setPlayState(e.playState);
    });
  }
  function Rae(r) {
    var e = r && r.timeline;
    X(e) || (e = e ? [
      e
    ] : []), D(e, function(t) {
      t && Eae(t);
    });
  }
  function Eae(r) {
    var e = r.type, t = {
      number: "value",
      time: "time"
    };
    if (t[e] && (r.axisType = t[e], delete r.type), cD(r), ds(r, "controlPosition")) {
      var n = r.controlStyle || (r.controlStyle = {});
      ds(n, "position") || (n.position = r.controlPosition), n.position === "none" && !ds(n, "show") && (n.show = false, delete n.position), delete r.controlPosition;
    }
    D(r.data || [], function(i) {
      _e(i) && !X(i) && (!ds(i, "value") && ds(i, "name") && (i.value = i.name), cD(i));
    });
  }
  function cD(r) {
    var e = r.itemStyle || (r.itemStyle = {}), t = e.emphasis || (e.emphasis = {}), n = r.label || r.label || {}, i = n.normal || (n.normal = {}), a = {
      normal: 1,
      emphasis: 1
    };
    D(n, function(o, s) {
      !a[s] && !ds(i, s) && (i[s] = o);
    }), t.label && !ds(n, "emphasis") && (n.emphasis = t.label, delete t.label);
  }
  function ds(r, e) {
    return r.hasOwnProperty(e);
  }
  function Nae(r) {
    r.registerComponentModel(nB), r.registerComponentView(Mae), r.registerSubTypeDefaulter("timeline", function() {
      return "slider";
    }), Lae(r), r.registerPreprocessor(Rae);
  }
  function HS(r, e) {
    if (!r) return false;
    for (var t = X(r) ? r : [
      r
    ], n = 0; n < t.length; n++) if (t[n] && t[n][e]) return true;
    return false;
  }
  function Nd(r) {
    Bs(r, "label", [
      "show"
    ]);
  }
  var Od = tt(), ba = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.createdBySelf = false, t;
    }
    return e.prototype.init = function(t, n, i) {
      this.mergeDefaultAndTheme(t, i), this._mergeOption(t, i, false, true);
    }, e.prototype.isAnimationEnabled = function() {
      if (He.node) return false;
      var t = this.__hostSeries;
      return this.getShallow("animation") && t && t.isAnimationEnabled();
    }, e.prototype.mergeOption = function(t, n) {
      this._mergeOption(t, n, false, false);
    }, e.prototype._mergeOption = function(t, n, i, a) {
      var o = this.mainType;
      i || n.eachSeries(function(s) {
        var l = s.get(this.mainType, true), u = Od(s)[o];
        if (!l || !l.data) {
          Od(s)[o] = null;
          return;
        }
        u ? u._mergeOption(l, n, true) : (a && Nd(l), D(l.data, function(c) {
          c instanceof Array ? (Nd(c[0]), Nd(c[1])) : Nd(c);
        }), u = this.createMarkerModelFromSeries(l, this, n), H(u, {
          mainType: this.mainType,
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: true
        }), u.__hostSeries = s), Od(s)[o] = u;
      }, this);
    }, e.prototype.formatTooltip = function(t, n, i) {
      var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
      return ur("section", {
        header: this.name,
        blocks: [
          ur("nameValue", {
            name: s,
            value: o,
            noName: !s,
            noValue: o == null
          })
        ]
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.setData = function(t) {
      this._data = t;
    }, e.prototype.getDataParams = function(t, n) {
      var i = pg.prototype.getDataParams.call(this, t, n), a = this.__hostSeries;
      return a && (i.seriesId = a.id, i.seriesName = a.name, i.seriesType = a.subType), i;
    }, e.getMarkerModelFromSeries = function(t, n) {
      return Od(t)[n];
    }, e.type = "marker", e.dependencies = [
      "series",
      "grid",
      "polar",
      "geo"
    ], e;
  }(Ke);
  qt(ba, pg.prototype);
  var Oae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, n, i) {
      return new e(t, n, i);
    }, e.type = "markPoint", e.defaultOption = {
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }, e;
  }(ba);
  function V_(r) {
    return !(isNaN(parseFloat(r.x)) && isNaN(parseFloat(r.y)));
  }
  function Fae(r) {
    return !isNaN(parseFloat(r.x)) && !isNaN(parseFloat(r.y));
  }
  function Fd(r, e, t, n, i, a) {
    var o = [], s = ho(e, n), l = s ? e.getCalculationInfo("stackResultDimension") : n, u = YS(e, l, r), c = e.indicesOfNearest(l, u)[0];
    o[i] = e.get(t, c), o[a] = e.get(l, c);
    var h = e.get(n, c), f = Mi(e.get(n, c));
    return f = Math.min(f, 20), f >= 0 && (o[a] = +o[a].toFixed(f)), [
      o,
      h
    ];
  }
  var n0 = {
    min: Le(Fd, "min"),
    max: Le(Fd, "max"),
    average: Le(Fd, "average"),
    median: Le(Fd, "median")
  };
  function Yh(r, e) {
    if (e) {
      var t = r.getData(), n = r.coordinateSystem, i = n && n.dimensions;
      if (!Fae(e) && !X(e.coord) && X(i)) {
        var a = iB(e, t, n, r);
        if (e = be(e), e.type && n0[e.type] && a.baseAxis && a.valueAxis) {
          var o = Be(i, a.baseAxis.dim), s = Be(i, a.valueAxis.dim), l = n0[e.type](t, a.baseDataDim, a.valueDataDim, o, s);
          e.coord = l[0], e.value = l[1];
        } else e.coord = [
          e.xAxis != null ? e.xAxis : e.radiusAxis,
          e.yAxis != null ? e.yAxis : e.angleAxis
        ];
      }
      if (e.coord == null || !X(i)) e.coord = [];
      else for (var u = e.coord, c = 0; c < 2; c++) n0[u[c]] && (u[c] = YS(t, t.mapDimension(i[c]), u[c]));
      return e;
    }
  }
  function iB(r, e, t, n) {
    var i = {};
    return r.valueIndex != null || r.valueDim != null ? (i.valueDataDim = r.valueIndex != null ? e.getDimension(r.valueIndex) : r.valueDim, i.valueAxis = t.getAxis(Bae(n, i.valueDataDim)), i.baseAxis = t.getOtherAxis(i.valueAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim)) : (i.baseAxis = n.getBaseAxis(), i.valueAxis = t.getOtherAxis(i.baseAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim), i.valueDataDim = e.mapDimension(i.valueAxis.dim)), i;
  }
  function Bae(r, e) {
    var t = r.getData().getDimensionInfo(e);
    return t && t.coordDim;
  }
  function Xh(r, e) {
    return r && r.containData && e.coord && !V_(e) ? r.containData(e.coord) : true;
  }
  function zae(r, e, t) {
    return r && r.containZone && e.coord && t.coord && !V_(e) && !V_(t) ? r.containZone(e.coord, t.coord) : true;
  }
  function aB(r, e) {
    return r ? function(t, n, i, a) {
      var o = a < 2 ? t.coord && t.coord[a] : t.value;
      return no(o, e[a]);
    } : function(t, n, i, a) {
      return no(t.value, e[a]);
    };
  }
  function YS(r, e, t) {
    if (t === "average") {
      var n = 0, i = 0;
      return r.each(e, function(a, o) {
        isNaN(a) || (n += a, i++);
      }), n / i;
    } else return t === "median" ? r.getMedian(e) : r.getDataExtent(e)[t === "max" ? 1 : 0];
  }
  var i0 = tt(), XS = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this.markerGroupMap = ce();
    }, e.prototype.render = function(t, n, i) {
      var a = this, o = this.markerGroupMap;
      o.each(function(s) {
        i0(s).keep = false;
      }), n.eachSeries(function(s) {
        var l = ba.getMarkerModelFromSeries(s, a.type);
        l && a.renderSeries(s, l, n, i);
      }), o.each(function(s) {
        !i0(s).keep && a.group.remove(s.group);
      });
    }, e.prototype.markKeep = function(t) {
      i0(t).keep = true;
    }, e.prototype.toggleBlurSeries = function(t, n) {
      var i = this;
      D(t, function(a) {
        var o = ba.getMarkerModelFromSeries(a, i.type);
        if (o) {
          var s = o.getData();
          s.eachItemGraphicEl(function(l) {
            l && (n ? ZR(l) : h1(l));
          });
        }
      });
    }, e.type = "marker", e;
  }(Rt);
  function hD(r, e, t) {
    var n = e.coordinateSystem;
    r.each(function(i) {
      var a = r.getItemModel(i), o, s = Q(a.get("x"), t.getWidth()), l = Q(a.get("y"), t.getHeight());
      if (!isNaN(s) && !isNaN(l)) o = [
        s,
        l
      ];
      else if (e.getMarkerPosition) o = e.getMarkerPosition(r.getValues(r.dimensions, i));
      else if (n) {
        var u = r.get(n.dimensions[0], i), c = r.get(n.dimensions[1], i);
        o = n.dataToPoint([
          u,
          c
        ]);
      }
      isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), r.setItemLayout(i, o);
    });
  }
  var Vae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, n, i) {
      n.eachSeries(function(a) {
        var o = ba.getMarkerModelFromSeries(a, "markPoint");
        o && (hD(o.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, e.prototype.renderSeries = function(t, n, i, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new If()), h = $ae(o, t, n);
      n.setData(h), hD(n.getData(), t, a), h.each(function(f) {
        var d = h.getItemModel(f), p = d.getShallow("symbol"), v = d.getShallow("symbolSize"), g = d.getShallow("symbolRotate"), m = d.getShallow("symbolOffset"), y = d.getShallow("symbolKeepAspect");
        if (ge(p) || ge(v) || ge(g) || ge(m)) {
          var x = n.getRawValue(f), _ = n.getDataParams(f);
          ge(p) && (p = p(x, _)), ge(v) && (v = v(x, _)), ge(g) && (g = g(x, _)), ge(m) && (m = m(x, _));
        }
        var S = d.getModel("itemStyle").getItemStyle(), b = wf(l, "color");
        S.fill || (S.fill = b), h.setItemVisual(f, {
          symbol: p,
          symbolSize: v,
          symbolRotate: g,
          symbolOffset: m,
          symbolKeepAspect: y,
          style: S
        });
      }), c.updateData(h), this.group.add(c.group), h.eachItemGraphicEl(function(f) {
        f.traverse(function(d) {
          De(d).dataModel = n;
        });
      }), this.markKeep(c), c.group.silent = n.get("silent") || t.get("silent");
    }, e.type = "markPoint", e;
  }(XS);
  function $ae(r, e, t) {
    var n;
    r ? n = K(r && r.dimensions, function(s) {
      var l = e.getData().getDimensionInfo(e.getData().mapDimension(s)) || {};
      return H(H({}, l), {
        name: s,
        ordinalMeta: null
      });
    }) : n = [
      {
        name: "value",
        type: "float"
      }
    ];
    var i = new Wr(n, t), a = K(t.get("data"), Le(Yh, e));
    r && (a = ct(a, Le(Xh, r)));
    var o = aB(!!r, n);
    return i.initData(a, null, o), i;
  }
  function Gae(r) {
    r.registerComponentModel(Oae), r.registerComponentView(Vae), r.registerPreprocessor(function(e) {
      HS(e.series, "markPoint") && (e.markPoint = e.markPoint || {});
    });
  }
  var Wae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, n, i) {
      return new e(t, n, i);
    }, e.type = "markLine", e.defaultOption = {
      z: 5,
      symbol: [
        "circle",
        "arrow"
      ],
      symbolSize: [
        8,
        16
      ],
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, e;
  }(ba), Bd = tt(), Uae = function(r, e, t, n) {
    var i = r.getData(), a;
    if (X(n)) a = n;
    else {
      var o = n.type;
      if (o === "min" || o === "max" || o === "average" || o === "median" || n.xAxis != null || n.yAxis != null) {
        var s = void 0, l = void 0;
        if (n.yAxis != null || n.xAxis != null) s = e.getAxis(n.yAxis != null ? "y" : "x"), l = vr(n.yAxis, n.xAxis);
        else {
          var u = iB(n, i, e, r);
          s = u.valueAxis;
          var c = j3(i, u.valueDataDim);
          l = YS(i, c, o);
        }
        var h = s.dim === "x" ? 0 : 1, f = 1 - h, d = be(n), p = {
          coord: []
        };
        d.type = null, d.coord = [], d.coord[f] = -1 / 0, p.coord[f] = 1 / 0;
        var v = t.get("precision");
        v >= 0 && nt(l) && (l = +l.toFixed(Math.min(v, 20))), d.coord[h] = p.coord[h] = l, a = [
          d,
          p,
          {
            type: o,
            valueIndex: n.valueIndex,
            value: l
          }
        ];
      } else a = [];
    }
    var g = [
      Yh(r, a[0]),
      Yh(r, a[1]),
      H({}, a[2])
    ];
    return g[2].type = g[2].type || null, Ee(g[2], g[0]), Ee(g[2], g[1]), g;
  };
  function bv(r) {
    return !isNaN(r) && !isFinite(r);
  }
  function fD(r, e, t, n) {
    var i = 1 - r, a = n.dimensions[r];
    return bv(e[i]) && bv(t[i]) && e[r] === t[r] && n.getAxis(a).containData(e[r]);
  }
  function Hae(r, e) {
    if (r.type === "cartesian2d") {
      var t = e[0].coord, n = e[1].coord;
      if (t && n && (fD(1, t, n, r) || fD(0, t, n, r))) return true;
    }
    return Xh(r, e[0]) && Xh(r, e[1]);
  }
  function a0(r, e, t, n, i) {
    var a = n.coordinateSystem, o = r.getItemModel(e), s, l = Q(o.get("x"), i.getWidth()), u = Q(o.get("y"), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) s = [
      l,
      u
    ];
    else {
      if (n.getMarkerPosition) s = n.getMarkerPosition(r.getValues(r.dimensions, e));
      else {
        var c = a.dimensions, h = r.get(c[0], e), f = r.get(c[1], e);
        s = a.dataToPoint([
          h,
          f
        ]);
      }
      if (Js(a, "cartesian2d")) {
        var d = a.getAxis("x"), p = a.getAxis("y"), c = a.dimensions;
        bv(r.get(c[0], e)) ? s[0] = d.toGlobalCoord(d.getExtent()[t ? 0 : 1]) : bv(r.get(c[1], e)) && (s[1] = p.toGlobalCoord(p.getExtent()[t ? 0 : 1]));
      }
      isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
    }
    r.setItemLayout(e, s);
  }
  var Yae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, n, i) {
      n.eachSeries(function(a) {
        var o = ba.getMarkerModelFromSeries(a, "markLine");
        if (o) {
          var s = o.getData(), l = Bd(o).from, u = Bd(o).to;
          l.each(function(c) {
            a0(l, c, true, a, i), a0(u, c, false, a, i);
          }), s.each(function(c) {
            s.setItemLayout(c, [
              l.getItemLayout(c),
              u.getItemLayout(c)
            ]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, e.prototype.renderSeries = function(t, n, i, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new pS());
      this.group.add(c.group);
      var h = Xae(o, t, n), f = h.from, d = h.to, p = h.line;
      Bd(n).from = f, Bd(n).to = d, n.setData(p);
      var v = n.get("symbol"), g = n.get("symbolSize"), m = n.get("symbolRotate"), y = n.get("symbolOffset");
      X(v) || (v = [
        v,
        v
      ]), X(g) || (g = [
        g,
        g
      ]), X(m) || (m = [
        m,
        m
      ]), X(y) || (y = [
        y,
        y
      ]), h.from.each(function(_) {
        x(f, _, true), x(d, _, false);
      }), p.each(function(_) {
        var S = p.getItemModel(_).getModel("lineStyle").getLineStyle();
        p.setItemLayout(_, [
          f.getItemLayout(_),
          d.getItemLayout(_)
        ]), S.stroke == null && (S.stroke = f.getItemVisual(_, "style").fill), p.setItemVisual(_, {
          fromSymbolKeepAspect: f.getItemVisual(_, "symbolKeepAspect"),
          fromSymbolOffset: f.getItemVisual(_, "symbolOffset"),
          fromSymbolRotate: f.getItemVisual(_, "symbolRotate"),
          fromSymbolSize: f.getItemVisual(_, "symbolSize"),
          fromSymbol: f.getItemVisual(_, "symbol"),
          toSymbolKeepAspect: d.getItemVisual(_, "symbolKeepAspect"),
          toSymbolOffset: d.getItemVisual(_, "symbolOffset"),
          toSymbolRotate: d.getItemVisual(_, "symbolRotate"),
          toSymbolSize: d.getItemVisual(_, "symbolSize"),
          toSymbol: d.getItemVisual(_, "symbol"),
          style: S
        });
      }), c.updateData(p), h.line.eachItemGraphicEl(function(_) {
        De(_).dataModel = n, _.traverse(function(S) {
          De(S).dataModel = n;
        });
      });
      function x(_, S, b) {
        var w = _.getItemModel(S);
        a0(_, S, b, t, a);
        var C = w.getModel("itemStyle").getItemStyle();
        C.fill == null && (C.fill = wf(l, "color")), _.setItemVisual(S, {
          symbolKeepAspect: w.get("symbolKeepAspect"),
          symbolOffset: Pe(w.get("symbolOffset", true), y[b ? 0 : 1]),
          symbolRotate: Pe(w.get("symbolRotate", true), m[b ? 0 : 1]),
          symbolSize: Pe(w.get("symbolSize"), g[b ? 0 : 1]),
          symbol: Pe(w.get("symbol", true), v[b ? 0 : 1]),
          style: C
        });
      }
      this.markKeep(c), c.group.silent = n.get("silent") || t.get("silent");
    }, e.type = "markLine", e;
  }(XS);
  function Xae(r, e, t) {
    var n;
    r ? n = K(r && r.dimensions, function(u) {
      var c = e.getData().getDimensionInfo(e.getData().mapDimension(u)) || {};
      return H(H({}, c), {
        name: u,
        ordinalMeta: null
      });
    }) : n = [
      {
        name: "value",
        type: "float"
      }
    ];
    var i = new Wr(n, t), a = new Wr(n, t), o = new Wr([], t), s = K(t.get("data"), Le(Uae, e, r, t));
    r && (s = ct(s, Le(Hae, r)));
    var l = aB(!!r, n);
    return i.initData(K(s, function(u) {
      return u[0];
    }), null, l), a.initData(K(s, function(u) {
      return u[1];
    }), null, l), o.initData(K(s, function(u) {
      return u[2];
    })), o.hasItemOption = true, {
      from: i,
      to: a,
      line: o
    };
  }
  function qae(r) {
    r.registerComponentModel(Wae), r.registerComponentView(Yae), r.registerPreprocessor(function(e) {
      HS(e.series, "markLine") && (e.markLine = e.markLine || {});
    });
  }
  var Kae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, n, i) {
      return new e(t, n, i);
    }, e.type = "markArea", e.defaultOption = {
      z: 1,
      tooltip: {
        trigger: "item"
      },
      animation: false,
      label: {
        show: true,
        position: "top"
      },
      itemStyle: {
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: true,
          position: "top"
        }
      }
    }, e;
  }(ba), zd = tt(), Zae = function(r, e, t, n) {
    var i = n[0], a = n[1];
    if (!(!i || !a)) {
      var o = Yh(r, i), s = Yh(r, a), l = o.coord, u = s.coord;
      l[0] = vr(l[0], -1 / 0), l[1] = vr(l[1], -1 / 0), u[0] = vr(u[0], 1 / 0), u[1] = vr(u[1], 1 / 0);
      var c = Xb([
        {},
        o,
        s
      ]);
      return c.coord = [
        o.coord,
        s.coord
      ], c.x0 = o.x, c.y0 = o.y, c.x1 = s.x, c.y1 = s.y, c;
    }
  };
  function Sv(r) {
    return !isNaN(r) && !isFinite(r);
  }
  function dD(r, e, t, n) {
    var i = 1 - r;
    return Sv(e[i]) && Sv(t[i]);
  }
  function jae(r, e) {
    var t = e.coord[0], n = e.coord[1], i = {
      coord: t,
      x: e.x0,
      y: e.y0
    }, a = {
      coord: n,
      x: e.x1,
      y: e.y1
    };
    return Js(r, "cartesian2d") ? t && n && (dD(1, t, n) || dD(0, t, n)) ? true : zae(r, i, a) : Xh(r, i) || Xh(r, a);
  }
  function pD(r, e, t, n, i) {
    var a = n.coordinateSystem, o = r.getItemModel(e), s, l = Q(o.get(t[0]), i.getWidth()), u = Q(o.get(t[1]), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) s = [
      l,
      u
    ];
    else {
      if (n.getMarkerPosition) {
        var c = r.getValues([
          "x0",
          "y0"
        ], e), h = r.getValues([
          "x1",
          "y1"
        ], e), f = a.clampData(c), d = a.clampData(h), p = [];
        t[0] === "x0" ? p[0] = f[0] > d[0] ? h[0] : c[0] : p[0] = f[0] > d[0] ? c[0] : h[0], t[1] === "y0" ? p[1] = f[1] > d[1] ? h[1] : c[1] : p[1] = f[1] > d[1] ? c[1] : h[1], s = n.getMarkerPosition(p, t, true);
      } else {
        var v = r.get(t[0], e), g = r.get(t[1], e), m = [
          v,
          g
        ];
        a.clampData && a.clampData(m, m), s = a.dataToPoint(m, true);
      }
      if (Js(a, "cartesian2d")) {
        var y = a.getAxis("x"), x = a.getAxis("y"), v = r.get(t[0], e), g = r.get(t[1], e);
        Sv(v) ? s[0] = y.toGlobalCoord(y.getExtent()[t[0] === "x0" ? 0 : 1]) : Sv(g) && (s[1] = x.toGlobalCoord(x.getExtent()[t[1] === "y0" ? 0 : 1]));
      }
      isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
    }
    return s;
  }
  var vD = [
    [
      "x0",
      "y0"
    ],
    [
      "x1",
      "y0"
    ],
    [
      "x1",
      "y1"
    ],
    [
      "x0",
      "y1"
    ]
  ], Qae = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, n, i) {
      n.eachSeries(function(a) {
        var o = ba.getMarkerModelFromSeries(a, "markArea");
        if (o) {
          var s = o.getData();
          s.each(function(l) {
            var u = K(vD, function(h) {
              return pD(s, l, h, a, i);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, e.prototype.renderSeries = function(t, n, i, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new Ce()
      });
      this.group.add(c.group), this.markKeep(c);
      var h = Jae(o, t, n);
      n.setData(h), h.each(function(f) {
        var d = K(vD, function(C) {
          return pD(h, f, C, t, a);
        }), p = o.getAxis("x").scale, v = o.getAxis("y").scale, g = p.getExtent(), m = v.getExtent(), y = [
          p.parse(h.get("x0", f)),
          p.parse(h.get("x1", f))
        ], x = [
          v.parse(h.get("y0", f)),
          v.parse(h.get("y1", f))
        ];
        On(y), On(x);
        var _ = !(g[0] > y[1] || g[1] < y[0] || m[0] > x[1] || m[1] < x[0]), S = !_;
        h.setItemLayout(f, {
          points: d,
          allClipped: S
        });
        var b = h.getItemModel(f).getModel("itemStyle").getItemStyle(), w = wf(l, "color");
        b.fill || (b.fill = w, ee(b.fill) && (b.fill = Bp(b.fill, 0.4))), b.stroke || (b.stroke = w), h.setItemVisual(f, "style", b);
      }), h.diff(zd(c).data).add(function(f) {
        var d = h.getItemLayout(f);
        if (!d.allClipped) {
          var p = new Kr({
            shape: {
              points: d.points
            }
          });
          h.setItemGraphicEl(f, p), c.group.add(p);
        }
      }).update(function(f, d) {
        var p = zd(c).data.getItemGraphicEl(d), v = h.getItemLayout(f);
        v.allClipped ? p && c.group.remove(p) : (p ? it(p, {
          shape: {
            points: v.points
          }
        }, n, f) : p = new Kr({
          shape: {
            points: v.points
          }
        }), h.setItemGraphicEl(f, p), c.group.add(p));
      }).remove(function(f) {
        var d = zd(c).data.getItemGraphicEl(f);
        c.group.remove(d);
      }).execute(), h.eachItemGraphicEl(function(f, d) {
        var p = h.getItemModel(d), v = h.getItemVisual(d, "style");
        f.useStyle(h.getItemVisual(d, "style")), Sr(f, lr(p), {
          labelFetcher: n,
          labelDataIndex: d,
          defaultText: h.getName(d) || "",
          inheritColor: ee(v.fill) ? Bp(v.fill, 1) : "#000"
        }), br(f, p), Nt(f, null, null, p.get([
          "emphasis",
          "disabled"
        ])), De(f).dataModel = n;
      }), zd(c).data = h, c.group.silent = n.get("silent") || t.get("silent");
    }, e.type = "markArea", e;
  }(XS);
  function Jae(r, e, t) {
    var n, i, a = [
      "x0",
      "y0",
      "x1",
      "y1"
    ];
    if (r) {
      var o = K(r && r.dimensions, function(u) {
        var c = e.getData(), h = c.getDimensionInfo(c.mapDimension(u)) || {};
        return H(H({}, h), {
          name: u,
          ordinalMeta: null
        });
      });
      i = K(a, function(u, c) {
        return {
          name: u,
          type: o[c % 2].type
        };
      }), n = new Wr(i, t);
    } else i = [
      {
        name: "value",
        type: "float"
      }
    ], n = new Wr(i, t);
    var s = K(t.get("data"), Le(Zae, e, r, t));
    r && (s = ct(s, Le(jae, r)));
    var l = r ? function(u, c, h, f) {
      var d = u.coord[Math.floor(f / 2)][f % 2];
      return no(d, i[f]);
    } : function(u, c, h, f) {
      return no(u.value, i[f]);
    };
    return n.initData(s, null, l), n.hasItemOption = true, n;
  }
  function eoe(r) {
    r.registerComponentModel(Kae), r.registerComponentView(Qae), r.registerPreprocessor(function(e) {
      HS(e.series, "markArea") && (e.markArea = e.markArea || {});
    });
  }
  var toe = function(r, e) {
    if (e === "all") return {
      type: "all",
      title: r.getLocaleModel().get([
        "legend",
        "selector",
        "all"
      ])
    };
    if (e === "inverse") return {
      type: "inverse",
      title: r.getLocaleModel().get([
        "legend",
        "selector",
        "inverse"
      ])
    };
  }, $_ = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: true
      }, t;
    }
    return e.prototype.init = function(t, n, i) {
      this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t);
    }, e.prototype.mergeOption = function(t, n) {
      r.prototype.mergeOption.call(this, t, n), this._updateSelector(t);
    }, e.prototype._updateSelector = function(t) {
      var n = t.selector, i = this.ecModel;
      n === true && (n = t.selector = [
        "all",
        "inverse"
      ]), X(n) && D(n, function(a, o) {
        ee(a) && (a = {
          type: a
        }), n[o] = Ee(a, toe(i, a.type));
      });
    }, e.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var t = this._data;
      if (t[0] && this.get("selectedMode") === "single") {
        for (var n = false, i = 0; i < t.length; i++) {
          var a = t[i].get("name");
          if (this.isSelected(a)) {
            this.select(a), n = true;
            break;
          }
        }
        !n && this.select(t[0].get("name"));
      }
    }, e.prototype._updateData = function(t) {
      var n = [], i = [];
      t.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var h = l.legendVisualProvider, f = h.getAllNames();
          t.isSeriesFiltered(l) || (i = i.concat(f)), f.length ? n = n.concat(f) : c = true;
        } else c = true;
        c && n1(l) && n.push(l.name);
      }), this._availableNames = i;
      var a = this.get("data") || n, o = ce(), s = K(a, function(l) {
        return (ee(l) || nt(l)) && (l = {
          name: l
        }), o.get(l.name) ? null : (o.set(l.name, true), new ft(l, this, this.ecModel));
      }, this);
      this._data = ct(s, function(l) {
        return !!l;
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.select = function(t) {
      var n = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var a = this._data;
        D(a, function(o) {
          n[o.get("name")] = false;
        });
      }
      n[t] = true;
    }, e.prototype.unSelect = function(t) {
      this.get("selectedMode") !== "single" && (this.option.selected[t] = false);
    }, e.prototype.toggleSelected = function(t) {
      var n = this.option.selected;
      n.hasOwnProperty(t) || (n[t] = true), this[n[t] ? "unSelect" : "select"](t);
    }, e.prototype.allSelect = function() {
      var t = this._data, n = this.option.selected;
      D(t, function(i) {
        n[i.get("name", true)] = true;
      });
    }, e.prototype.inverseSelect = function() {
      var t = this._data, n = this.option.selected;
      D(t, function(i) {
        var a = i.get("name", true);
        n.hasOwnProperty(a) || (n[a] = true), n[a] = !n[a];
      });
    }, e.prototype.isSelected = function(t) {
      var n = this.option.selected;
      return !(n.hasOwnProperty(t) && !n[t]) && Be(this._availableNames, t) >= 0;
    }, e.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, e.type = "legend.plain", e.dependencies = [
      "series"
    ], e.defaultOption = {
      z: 4,
      show: true,
      orient: "horizontal",
      left: "center",
      top: 0,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: true,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: true,
      selector: false,
      selectorLabel: {
        show: true,
        borderRadius: 10,
        padding: [
          3,
          5,
          3,
          5
        ],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: true,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: false
      }
    }, e;
  }(Ke), Al = Le, G_ = D, Vd = Ce, oB = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = false, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._contentGroup = new Vd()), this.group.add(this._selectorGroup = new Vd()), this._isFirstRender = true;
    }, e.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, e.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, e.prototype.render = function(t, n, i) {
      var a = this._isFirstRender;
      if (this._isFirstRender = false, this.resetInner(), !!t.get("show", true)) {
        var o = t.get("align"), s = t.get("orient");
        (!o || o === "auto") && (o = t.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = t.get("selector", true), u = t.get("selectorPosition", true);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, t, n, i, l, s, u);
        var c = t.getBoxLayoutParams(), h = {
          width: i.getWidth(),
          height: i.getHeight()
        }, f = t.get("padding"), d = er(c, h, f), p = this.layoutInner(t, o, d, a, l, u), v = er(ye({
          width: p.width,
          height: p.height
        }, c), h, f);
        this.group.x = v.x - p.x, this.group.y = v.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = qF(p, t));
      }
    }, e.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, e.prototype.renderInner = function(t, n, i, a, o, s, l) {
      var u = this.getContentGroup(), c = ce(), h = n.get("selectedMode"), f = [];
      i.eachRawSeries(function(d) {
        !d.get("legendHoverLink") && f.push(d.id);
      }), G_(n.getData(), function(d, p) {
        var v = d.get("name");
        if (!this.newlineDisabled && (v === "" || v === `
`)) {
          var g = new Vd();
          g.newline = true, u.add(g);
          return;
        }
        var m = i.getSeriesByName(v)[0];
        if (!c.get(v)) if (m) {
          var y = m.getData(), x = y.getVisual("legendLineStyle") || {}, _ = y.getVisual("legendIcon"), S = y.getVisual("style"), b = this._createItem(m, v, p, d, n, t, x, S, _, h, a);
          b.on("click", Al(gD, v, null, a, f)).on("mouseover", Al(W_, m.name, null, a, f)).on("mouseout", Al(U_, m.name, null, a, f)), i.ssr && b.eachChild(function(w) {
            var C = De(w);
            C.seriesIndex = m.seriesIndex, C.dataIndex = p, C.ssrType = "legend";
          }), c.set(v, true);
        } else i.eachRawSeries(function(w) {
          if (!c.get(v) && w.legendVisualProvider) {
            var C = w.legendVisualProvider;
            if (!C.containName(v)) return;
            var T = C.indexOfName(v), A = C.getItemVisual(T, "style"), M = C.getItemVisual(T, "legendIcon"), E = vn(A.fill);
            E && E[3] === 0 && (E[3] = 0.2, A = H(H({}, A), {
              fill: la(E, "rgba")
            }));
            var k = this._createItem(w, v, p, d, n, t, {}, A, M, h, a);
            k.on("click", Al(gD, null, v, a, f)).on("mouseover", Al(W_, null, v, a, f)).on("mouseout", Al(U_, null, v, a, f)), i.ssr && k.eachChild(function(R) {
              var N = De(R);
              N.seriesIndex = w.seriesIndex, N.dataIndex = p, N.ssrType = "legend";
            }), c.set(v, true);
          }
        }, this);
      }, this), o && this._createSelector(o, n, a, s, l);
    }, e.prototype._createSelector = function(t, n, i, a, o) {
      var s = this.getSelectorGroup();
      G_(t, function(u) {
        var c = u.type, h = new rt({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect",
              legendId: n.id
            });
          }
        });
        s.add(h);
        var f = n.getModel("selectorLabel"), d = n.getModel([
          "emphasis",
          "selectorLabel"
        ]);
        Sr(h, {
          normal: f,
          emphasis: d
        }, {
          defaultText: u.title
        }), Ps(h);
      });
    }, e.prototype._createItem = function(t, n, i, a, o, s, l, u, c, h, f) {
      var d = t.visualDrawType, p = o.get("itemWidth"), v = o.get("itemHeight"), g = o.isSelected(n), m = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), x = a.get("icon");
      c = x || c || "roundRect";
      var _ = roe(c, a, l, u, d, g, f), S = new Vd(), b = a.getModel("textStyle");
      if (ge(t.getLegendIcon) && (!x || x === "inherit")) S.add(t.getLegendIcon({
        itemWidth: p,
        itemHeight: v,
        icon: c,
        iconRotate: m,
        itemStyle: _.itemStyle,
        lineStyle: _.lineStyle,
        symbolKeepAspect: y
      }));
      else {
        var w = x === "inherit" && t.getData().getVisual("symbol") ? m === "inherit" ? t.getData().getVisual("symbolRotate") : m : 0;
        S.add(noe({
          itemWidth: p,
          itemHeight: v,
          icon: c,
          iconRotate: w,
          itemStyle: _.itemStyle,
          symbolKeepAspect: y
        }));
      }
      var C = s === "left" ? p + 5 : -5, T = s, A = o.get("formatter"), M = n;
      ee(A) && A ? M = A.replace("{name}", n ?? "") : ge(A) && (M = A(n));
      var E = g ? b.getTextColor() : a.get("inactiveColor");
      S.add(new rt({
        style: wt(b, {
          text: M,
          x: C,
          y: v / 2,
          fill: E,
          align: T,
          verticalAlign: "middle"
        }, {
          inheritColor: E
        })
      }));
      var k = new et({
        shape: S.getBoundingRect(),
        style: {
          fill: "transparent"
        }
      }), R = a.getModel("tooltip");
      return R.get("show") && Ks({
        el: k,
        componentModel: o,
        itemName: n,
        itemTooltipOption: R.option
      }), S.add(k), S.eachChild(function(N) {
        N.silent = true;
      }), k.silent = !h, this.getContentGroup().add(S), Ps(S), S.__legendDataIndex = i, S;
    }, e.prototype.layoutInner = function(t, n, i, a, o, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      Ls(t.get("orient"), l, t.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), h = [
        -c.x,
        -c.y
      ];
      if (u.markRedraw(), l.markRedraw(), o) {
        Ls("horizontal", u, t.get("selectorItemGap", true));
        var f = u.getBoundingRect(), d = [
          -f.x,
          -f.y
        ], p = t.get("selectorButtonGap", true), v = t.getOrient().index, g = v === 0 ? "width" : "height", m = v === 0 ? "height" : "width", y = v === 0 ? "y" : "x";
        s === "end" ? d[v] += c[g] + p : h[v] += f[g] + p, d[1 - v] += c[m] / 2 - f[m] / 2, u.x = d[0], u.y = d[1], l.x = h[0], l.y = h[1];
        var x = {
          x: 0,
          y: 0
        };
        return x[g] = c[g] + p + f[g], x[m] = Math.max(c[m], f[m]), x[y] = Math.min(0, f[y] + d[1 - v]), x;
      } else return l.x = h[0], l.y = h[1], this.group.getBoundingRect();
    }, e.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = true;
    }, e.type = "legend.plain", e;
  }(Rt);
  function roe(r, e, t, n, i, a, o) {
    function s(g, m) {
      g.lineWidth === "auto" && (g.lineWidth = m.lineWidth > 0 ? 2 : 0), G_(g, function(y, x) {
        g[x] === "inherit" && (g[x] = m[x]);
      });
    }
    var l = e.getModel("itemStyle"), u = l.getItemStyle(), c = r.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", h = l.getShallow("decal");
    u.decal = !h || h === "inherit" ? n.decal : hu(h, o), u.fill === "inherit" && (u.fill = n[i]), u.stroke === "inherit" && (u.stroke = n[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? n : t).opacity), s(u, n);
    var f = e.getModel("lineStyle"), d = f.getLineStyle();
    if (s(d, t), u.fill === "auto" && (u.fill = n.fill), u.stroke === "auto" && (u.stroke = n.fill), d.stroke === "auto" && (d.stroke = n.fill), !a) {
      var p = e.get("inactiveBorderWidth"), v = u[c];
      u.lineWidth = p === "auto" ? n.lineWidth > 0 && v ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), d.stroke = f.get("inactiveColor"), d.lineWidth = f.get("inactiveWidth");
    }
    return {
      itemStyle: u,
      lineStyle: d
    };
  }
  function noe(r) {
    var e = r.icon || "roundRect", t = Xt(e, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill, r.symbolKeepAspect);
    return t.setStyle(r.itemStyle), t.rotation = (r.iconRotate || 0) * Math.PI / 180, t.setOrigin([
      r.itemWidth / 2,
      r.itemHeight / 2
    ]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t;
  }
  function gD(r, e, t, n) {
    U_(r, e, t, n), t.dispatchAction({
      type: "legendToggleSelect",
      name: r ?? e
    }), W_(r, e, t, n);
  }
  function sB(r) {
    for (var e = r.getZr().storage.getDisplayList(), t, n = 0, i = e.length; n < i && !(t = e[n].states.emphasis); ) n++;
    return t && t.hoverLayer;
  }
  function W_(r, e, t, n) {
    sB(t) || t.dispatchAction({
      type: "highlight",
      seriesName: r,
      name: e,
      excludeSeriesId: n
    });
  }
  function U_(r, e, t, n) {
    sB(t) || t.dispatchAction({
      type: "downplay",
      seriesName: r,
      name: e,
      excludeSeriesId: n
    });
  }
  function ioe(r) {
    var e = r.findComponents({
      mainType: "legend"
    });
    e && e.length && r.filterSeries(function(t) {
      for (var n = 0; n < e.length; n++) if (!e[n].isSelected(t.name)) return false;
      return true;
    });
  }
  function _c(r, e, t) {
    var n = r === "allSelect" || r === "inverseSelect", i = {}, a = [];
    t.eachComponent({
      mainType: "legend",
      query: e
    }, function(s) {
      n ? s[r]() : s[r](e.name), mD(s, i), a.push(s.componentIndex);
    });
    var o = {};
    return t.eachComponent("legend", function(s) {
      D(i, function(l, u) {
        s[l ? "select" : "unSelect"](u);
      }), mD(s, o);
    }), n ? {
      selected: o,
      legendIndex: a
    } : {
      name: e.name,
      selected: o
    };
  }
  function mD(r, e) {
    var t = e || {};
    return D(r.getData(), function(n) {
      var i = n.get("name");
      if (!(i === `
` || i === "")) {
        var a = r.isSelected(i);
        oe(t, i) ? t[i] = t[i] && a : t[i] = a;
      }
    }), t;
  }
  function aoe(r) {
    r.registerAction("legendToggleSelect", "legendselectchanged", Le(_c, "toggleSelected")), r.registerAction("legendAllSelect", "legendselectall", Le(_c, "allSelect")), r.registerAction("legendInverseSelect", "legendinverseselect", Le(_c, "inverseSelect")), r.registerAction("legendSelect", "legendselected", Le(_c, "select")), r.registerAction("legendUnSelect", "legendunselected", Le(_c, "unSelect"));
  }
  function lB(r) {
    r.registerComponentModel($_), r.registerComponentView(oB), r.registerProcessor(r.PRIORITY.PROCESSOR.SERIES_FILTER, ioe), r.registerSubTypeDefaulter("legend", function() {
      return "plain";
    }), aoe(r);
  }
  var ooe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.setScrollDataIndex = function(t) {
      this.option.scrollDataIndex = t;
    }, e.prototype.init = function(t, n, i) {
      var a = Fu(t);
      r.prototype.init.call(this, t, n, i), yD(this, t, a);
    }, e.prototype.mergeOption = function(t, n) {
      r.prototype.mergeOption.call(this, t, n), yD(this, this.option, t);
    }, e.type = "legend.scroll", e.defaultOption = yo($_.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: [
          "M0,0L12,-10L12,10z",
          "M0,0L-12,-10L-12,10z"
        ],
        vertical: [
          "M0,0L20,0L10,-20z",
          "M0,0L20,0L10,20z"
        ]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), e;
  }($_);
  function yD(r, e, t) {
    var n = r.getOrient(), i = [
      1,
      1
    ];
    i[n.index] = 0, co(e, t, {
      type: "box",
      ignoreSize: !!i
    });
  }
  var xD = Ce, o0 = [
    "width",
    "height"
  ], s0 = [
    "x",
    "y"
  ], soe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = true, t._currentIndex = 0, t;
    }
    return e.prototype.init = function() {
      r.prototype.init.call(this), this.group.add(this._containerGroup = new xD()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new xD());
    }, e.prototype.resetInner = function() {
      r.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, e.prototype.renderInner = function(t, n, i, a, o, s, l) {
      var u = this;
      r.prototype.renderInner.call(this, t, n, i, a, o, s, l);
      var c = this._controllerGroup, h = n.get("pageIconSize", true), f = X(h) ? h : [
        h,
        h
      ];
      p("pagePrev", 0);
      var d = n.getModel("pageTextStyle");
      c.add(new rt({
        name: "pageText",
        style: {
          text: "xx/xx",
          fill: d.getTextColor(),
          font: d.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: true
      })), p("pageNext", 1);
      function p(v, g) {
        var m = v + "DataIndex", y = bf(n.get("pageIcons", true)[n.getOrient().name][g], {
          onclick: ne(u._pageGo, u, m, n, a)
        }, {
          x: -f[0] / 2,
          y: -f[1] / 2,
          width: f[0],
          height: f[1]
        });
        y.name = v, c.add(y);
      }
    }, e.prototype.layoutInner = function(t, n, i, a, o, s) {
      var l = this.getSelectorGroup(), u = t.getOrient().index, c = o0[u], h = s0[u], f = o0[1 - u], d = s0[1 - u];
      o && Ls("horizontal", l, t.get("selectorItemGap", true));
      var p = t.get("selectorButtonGap", true), v = l.getBoundingRect(), g = [
        -v.x,
        -v.y
      ], m = be(i);
      o && (m[c] = i[c] - v[c] - p);
      var y = this._layoutContentAndController(t, a, m, u, c, f, d, h);
      if (o) {
        if (s === "end") g[u] += y[c] + p;
        else {
          var x = v[c] + p;
          g[u] -= x, y[h] -= x;
        }
        y[c] += v[c] + p, g[1 - u] += y[d] + y[f] / 2 - v[f] / 2, y[f] = Math.max(y[f], v[f]), y[d] = Math.min(y[d], v[d] + g[1 - u]), l.x = g[0], l.y = g[1], l.markRedraw();
      }
      return y;
    }, e.prototype._layoutContentAndController = function(t, n, i, a, o, s, l, u) {
      var c = this.getContentGroup(), h = this._containerGroup, f = this._controllerGroup;
      Ls(t.get("orient"), c, t.get("itemGap"), a ? i.width : null, a ? null : i.height), Ls("horizontal", f, t.get("pageButtonItemGap", true));
      var d = c.getBoundingRect(), p = f.getBoundingRect(), v = this._showController = d[o] > i[o], g = [
        -d.x,
        -d.y
      ];
      n || (g[a] = c[u]);
      var m = [
        0,
        0
      ], y = [
        -p.x,
        -p.y
      ], x = Pe(t.get("pageButtonGap", true), t.get("itemGap", true));
      if (v) {
        var _ = t.get("pageButtonPosition", true);
        _ === "end" ? y[a] += i[o] - p[o] : m[a] += p[o] + x;
      }
      y[1 - a] += d[s] / 2 - p[s] / 2, c.setPosition(g), h.setPosition(m), f.setPosition(y);
      var S = {
        x: 0,
        y: 0
      };
      if (S[o] = v ? i[o] : d[o], S[s] = Math.max(d[s], p[s]), S[l] = Math.min(0, p[l] + y[1 - a]), h.__rectSize = i[o], v) {
        var b = {
          x: 0,
          y: 0
        };
        b[o] = Math.max(i[o] - p[o] - x, 0), b[s] = S[s], h.setClipPath(new et({
          shape: b
        })), h.__rectSize = b[o];
      } else f.eachChild(function(C) {
        C.attr({
          invisible: true,
          silent: true
        });
      });
      var w = this._getPageInfo(t);
      return w.pageIndex != null && it(c, {
        x: w.contentPosition[0],
        y: w.contentPosition[1]
      }, v ? t : null), this._updatePageInfoView(t, w), S;
    }, e.prototype._pageGo = function(t, n, i) {
      var a = this._getPageInfo(n)[t];
      a != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: n.id
      });
    }, e.prototype._updatePageInfoView = function(t, n) {
      var i = this._controllerGroup;
      D([
        "pagePrev",
        "pageNext"
      ], function(c) {
        var h = c + "DataIndex", f = n[h] != null, d = i.childOfName(c);
        d && (d.setStyle("fill", f ? t.get("pageIconColor", true) : t.get("pageIconInactiveColor", true)), d.cursor = f ? "pointer" : "default");
      });
      var a = i.childOfName("pageText"), o = t.get("pageFormatter"), s = n.pageIndex, l = s != null ? s + 1 : 0, u = n.pageCount;
      a && o && a.setStyle("text", ee(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
        current: l,
        total: u
      }));
    }, e.prototype._getPageInfo = function(t) {
      var n = t.get("scrollDataIndex", true), i = this.getContentGroup(), a = this._containerGroup.__rectSize, o = t.getOrient().index, s = o0[o], l = s0[o], u = this._findTargetItemIndex(n), c = i.children(), h = c[u], f = c.length, d = f ? 1 : 0, p = {
        contentPosition: [
          i.x,
          i.y
        ],
        pageCount: d,
        pageIndex: d - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!h) return p;
      var v = _(h);
      p.contentPosition[o] = -v.s;
      for (var g = u + 1, m = v, y = v, x = null; g <= f; ++g) x = _(c[g]), (!x && y.e > m.s + a || x && !S(x, m.s)) && (y.i > m.i ? m = y : m = x, m && (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = x;
      for (var g = u - 1, m = v, y = v, x = null; g >= -1; --g) x = _(c[g]), (!x || !S(y, x.s)) && m.i < y.i && (y = m, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = x;
      return p;
      function _(b) {
        if (b) {
          var w = b.getBoundingRect(), C = w[l] + b[l];
          return {
            s: C,
            e: C + w[s],
            i: b.__legendDataIndex
          };
        }
      }
      function S(b, w) {
        return b.e >= w && b.s <= w + a;
      }
    }, e.prototype._findTargetItemIndex = function(t) {
      if (!this._showController) return 0;
      var n, i = this.getContentGroup(), a;
      return i.eachChild(function(o, s) {
        var l = o.__legendDataIndex;
        a == null && l != null && (a = s), l === t && (n = s);
      }), n ?? a;
    }, e.type = "legend.scroll", e;
  }(oB);
  function loe(r) {
    r.registerAction("legendScroll", "legendscroll", function(e, t) {
      var n = e.scrollDataIndex;
      n != null && t.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: e
      }, function(i) {
        i.setScrollDataIndex(n);
      });
    });
  }
  function uoe(r) {
    Ve(lB), r.registerComponentModel(ooe), r.registerComponentView(soe), loe(r);
  }
  function coe(r) {
    Ve(lB), Ve(uoe);
  }
  var hoe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.inside", e.defaultOption = yo(Hh.defaultOption, {
      disabled: false,
      zoomLock: false,
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: false,
      preventDefaultMouseMove: true
    }), e;
  }(Hh), qS = tt();
  function foe(r, e, t) {
    qS(r).coordSysRecordMap.each(function(n) {
      var i = n.dataZoomInfoMap.get(e.uid);
      i && (i.getRange = t);
    });
  }
  function doe(r, e) {
    for (var t = qS(r).coordSysRecordMap, n = t.keys(), i = 0; i < n.length; i++) {
      var a = n[i], o = t.get(a), s = o.dataZoomInfoMap;
      if (s) {
        var l = e.uid, u = s.get(l);
        u && (s.removeKey(l), s.keys().length || uB(t, o));
      }
    }
  }
  function uB(r, e) {
    if (e) {
      r.removeKey(e.model.uid);
      var t = e.controller;
      t && t.dispose();
    }
  }
  function poe(r, e) {
    var t = {
      model: e,
      containsPoint: Le(goe, e),
      dispatchAction: Le(voe, r),
      dataZoomInfoMap: null,
      controller: null
    }, n = t.controller = new Lf(r.getZr());
    return D([
      "pan",
      "zoom",
      "scrollMove"
    ], function(i) {
      n.on(i, function(a) {
        var o = [];
        t.dataZoomInfoMap.each(function(s) {
          if (a.isAvailableBehavior(s.model.option)) {
            var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, t.model.mainType, t.controller, a);
            !s.model.get("disabled", true) && u && o.push({
              dataZoomId: s.model.id,
              start: u[0],
              end: u[1]
            });
          }
        }), o.length && t.dispatchAction(o);
      });
    }), t;
  }
  function voe(r, e) {
    r.isDisposed() || r.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch: e
    });
  }
  function goe(r, e, t, n) {
    return r.coordinateSystem.containPoint([
      t,
      n
    ]);
  }
  function moe(r) {
    var e, t = "type_", n = {
      type_true: 2,
      type_move: 1,
      type_false: 0,
      type_undefined: -1
    }, i = true;
    return r.each(function(a) {
      var o = a.model, s = o.get("disabled", true) ? false : o.get("zoomLock", true) ? "move" : true;
      n[t + s] > n[t + e] && (e = s), i = i && o.get("preventDefaultMouseMove", true);
    }), {
      controlType: e,
      opt: {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: true,
        preventDefaultMouseMove: !!i
      }
    };
  }
  function yoe(r) {
    r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, function(e, t) {
      var n = qS(t), i = n.coordSysRecordMap || (n.coordSysRecordMap = ce());
      i.each(function(a) {
        a.dataZoomInfoMap = null;
      }), e.eachComponent({
        mainType: "dataZoom",
        subType: "inside"
      }, function(a) {
        var o = HF(a);
        D(o.infoList, function(s) {
          var l = s.model.uid, u = i.get(l) || i.set(l, poe(t, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = ce());
          c.set(a.uid, {
            dzReferCoordSysInfo: s,
            model: a,
            getRange: null
          });
        });
      }), i.each(function(a) {
        var o = a.controller, s, l = a.dataZoomInfoMap;
        if (l) {
          var u = l.keys()[0];
          u != null && (s = l.get(u));
        }
        if (!s) {
          uB(i, a);
          return;
        }
        var c = moe(l);
        o.enable(c.controlType, c.opt), o.setPointerChecker(a.containsPoint), Vu(a, "dispatchAction", s.model.get("throttle", true), "fixRate");
      });
    });
  }
  var xoe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataZoom.inside", t;
    }
    return e.prototype.render = function(t, n, i) {
      if (r.prototype.render.apply(this, arguments), t.noTarget()) {
        this._clear();
        return;
      }
      this.range = t.getPercentRange(), foe(i, t, {
        pan: ne(l0.pan, this),
        zoom: ne(l0.zoom, this),
        scrollMove: ne(l0.scrollMove, this)
      });
    }, e.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      doe(this.api, this.dataZoomModel), this.range = null;
    }, e.type = "dataZoom.inside", e;
  }(zS), l0 = {
    zoom: function(r, e, t, n) {
      var i = this.range, a = i.slice(), o = r.axisModels[0];
      if (o) {
        var s = u0[e](null, [
          n.originX,
          n.originY
        ], o, t, r), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / n.scale, 0);
        a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
        var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        if (tl(0, a, [
          0,
          100
        ], 0, c.minSpan, c.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1]) return a;
      }
    },
    pan: _D(function(r, e, t, n, i, a) {
      var o = u0[n]([
        a.oldX,
        a.oldY
      ], [
        a.newX,
        a.newY
      ], e, i, t);
      return o.signal * (r[1] - r[0]) * o.pixel / o.pixelLength;
    }),
    scrollMove: _D(function(r, e, t, n, i, a) {
      var o = u0[n]([
        0,
        0
      ], [
        a.scrollDelta,
        a.scrollDelta
      ], e, i, t);
      return o.signal * (r[1] - r[0]) * a.scrollDelta;
    })
  };
  function _D(r) {
    return function(e, t, n, i) {
      var a = this.range, o = a.slice(), s = e.axisModels[0];
      if (s) {
        var l = r(o, s, e, t, n, i);
        if (tl(l, o, [
          0,
          100
        ], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1]) return o;
      }
    };
  }
  var u0 = {
    grid: function(r, e, t, n, i) {
      var a = t.axis, o = {}, s = i.model.coordinateSystem.getRect();
      return r = r || [
        0,
        0
      ], a.dim === "x" ? (o.pixel = e[0] - r[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - r[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
    },
    polar: function(r, e, t, n, i) {
      var a = t.axis, o = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
      return r = r ? s.pointToCoord(r) : [
        0,
        0
      ], e = s.pointToCoord(e), t.mainType === "radiusAxis" ? (o.pixel = e[0] - r[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - r[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
    },
    singleAxis: function(r, e, t, n, i) {
      var a = t.axis, o = i.model.coordinateSystem.getRect(), s = {};
      return r = r || [
        0,
        0
      ], a.orient === "horizontal" ? (s.pixel = e[0] - r[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - r[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
    }
  };
  function cB(r) {
    VS(r), r.registerComponentModel(hoe), r.registerComponentView(xoe), yoe(r);
  }
  var _oe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = yo(Hh.defaultOption, {
      show: true,
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: true,
      showDataShadow: "auto",
      realtime: true,
      zoomLock: false,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: true,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleLabel: {
          show: true
        },
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), e;
  }(Hh), bc = et, bD = 7, boe = 1, c0 = 30, Soe = 7, Sc = "horizontal", SD = "vertical", woe = 5, Coe = [
    "line",
    "bar",
    "candlestick",
    "scatter"
  ], Toe = {
    easing: "cubicOut",
    duration: 100,
    delay: 0
  }, Aoe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._displayables = {}, t;
    }
    return e.prototype.init = function(t, n) {
      this.api = n, this._onBrush = ne(this._onBrush, this), this._onBrushEnd = ne(this._onBrushEnd, this);
    }, e.prototype.render = function(t, n, i, a) {
      if (r.prototype.render.apply(this, arguments), Vu(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === false) {
        this.group.removeAll();
        return;
      }
      if (t.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, e.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      Lh(this, "_dispatchZoomAction");
      var t = this.api.getZr();
      t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd);
    }, e.prototype._buildView = function() {
      var t = this.group;
      t.removeAll(), this._brushing = false, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var n = this._displayables.sliderGroup = new Ce();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(n), this._positionGroup();
    }, e.prototype._resetLocation = function() {
      var t = this.dataZoomModel, n = this.api, i = t.get("brushSelect"), a = i ? Soe : 0, o = this._findCoordRect(), s = {
        width: n.getWidth(),
        height: n.getHeight()
      }, l = this._orient === Sc ? {
        right: s.width - o.x - o.width,
        top: s.height - c0 - bD - a,
        width: o.width,
        height: c0
      } : {
        right: bD,
        top: o.y,
        width: c0,
        height: o.height
      }, u = Fu(t.option);
      D([
        "right",
        "top",
        "width",
        "height"
      ], function(h) {
        u[h] === "ph" && (u[h] = l[h]);
      });
      var c = er(u, s);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [
        c.width,
        c.height
      ], this._orient === SD && this._size.reverse();
    }, e.prototype._positionGroup = function() {
      var t = this.group, n = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === Sc && !o ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === Sc && o ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === SD && !o ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = t.getBoundingRect([
        s
      ]);
      t.x = n.x - u.x, t.y = n.y - u.y, t.markRedraw();
    }, e.prototype._getViewExtent = function() {
      return [
        0,
        this._size[0]
      ];
    }, e.prototype._renderBackground = function() {
      var t = this.dataZoomModel, n = this._size, i = this._displayables.sliderGroup, a = t.get("brushSelect");
      i.add(new bc({
        silent: true,
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: t.get("backgroundColor")
        },
        z2: -40
      }));
      var o = new bc({
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: ne(this._onClickPanel, this)
      }), s = this.api.getZr();
      a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(o);
    }, e.prototype._renderDataShadow = function() {
      var t = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !t) return;
      var n = this._size, i = this._shadowSize || [], a = t.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : t.otherDim;
      if (l == null) return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (o !== this._shadowData || l !== this._shadowDim || n[0] !== i[0] || n[1] !== i[1]) {
        var h = o.getDataExtent(l), f = (h[1] - h[0]) * 0.3;
        h = [
          h[0] - f,
          h[1] + f
        ];
        var d = [
          0,
          n[1]
        ], p = [
          0,
          n[0]
        ], v = [
          [
            n[0],
            0
          ],
          [
            0,
            0
          ]
        ], g = [], m = p[1] / (o.count() - 1), y = 0, x = Math.round(o.count() / n[0]), _;
        o.each([
          l
        ], function(T, A) {
          if (x > 0 && A % x) {
            y += m;
            return;
          }
          var M = T == null || isNaN(T) || T === "", E = M ? 0 : ht(T, h, d, true);
          M && !_ && A ? (v.push([
            v[v.length - 1][0],
            0
          ]), g.push([
            g[g.length - 1][0],
            0
          ])) : !M && _ && (v.push([
            y,
            0
          ]), g.push([
            y,
            0
          ])), v.push([
            y,
            E
          ]), g.push([
            y,
            E
          ]), y += m, _ = M;
        }), u = this._shadowPolygonPts = v, c = this._shadowPolylinePts = g;
      }
      this._shadowData = o, this._shadowDim = l, this._shadowSize = [
        n[0],
        n[1]
      ];
      var S = this.dataZoomModel;
      function b(T) {
        var A = S.getModel(T ? "selectedDataBackground" : "dataBackground"), M = new Ce(), E = new Kr({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: A.getModel("areaStyle").getAreaStyle(),
          silent: true,
          z2: -20
        }), k = new Zr({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: A.getModel("lineStyle").getLineStyle(),
          silent: true,
          z2: -19
        });
        return M.add(E), M.add(k), M;
      }
      for (var w = 0; w < 3; w++) {
        var C = b(w === 1);
        this._displayables.sliderGroup.add(C), this._displayables.dataShadowSegs.push(C);
      }
    }, e.prototype._prepareDataShadowInfo = function() {
      var t = this.dataZoomModel, n = t.get("showDataShadow");
      if (n !== false) {
        var i, a = this.ecModel;
        return t.eachTargetAxis(function(o, s) {
          var l = t.getAxisProxy(o, s).getTargetSeriesModels();
          D(l, function(u) {
            if (!i && !(n !== true && Be(Coe, u.get("type")) < 0)) {
              var c = a.getComponent(Ja(o), s).axis, h = Ioe(o), f, d = u.coordinateSystem;
              h != null && d.getOtherAxis && (f = d.getOtherAxis(c).inverse), h = u.getData().mapDimension(h), i = {
                thisAxis: c,
                series: u,
                thisDim: o,
                otherDim: h,
                otherAxisInverse: f
              };
            }
          }, this);
        }, this), i;
      }
    }, e.prototype._renderHandle = function() {
      var t = this.group, n = this._displayables, i = n.handles = [
        null,
        null
      ], a = n.handleLabels = [
        null,
        null
      ], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, h = l.get("brushSelect"), f = n.filler = new bc({
        silent: h,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      o.add(f), o.add(new bc({
        silent: true,
        subPixelOptimize: true,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: boe,
          fill: "rgba(0,0,0,0)"
        }
      })), D([
        0,
        1
      ], function(x) {
        var _ = l.get("handleIcon");
        !Jp[_] && _.indexOf("path://") < 0 && _.indexOf("image://") < 0 && (_ = "path://" + _);
        var S = Xt(_, -1, 0, 2, 2, null, true);
        S.attr({
          cursor: wD(this._orient),
          draggable: true,
          drift: ne(this._onDragMove, this, x),
          ondragend: ne(this._onDragEnd, this),
          onmouseover: ne(this._showDataInfo, this, true),
          onmouseout: ne(this._showDataInfo, this, false),
          z2: 5
        });
        var b = S.getBoundingRect(), w = l.get("handleSize");
        this._handleHeight = Q(w, this._size[1]), this._handleWidth = b.width / b.height * this._handleHeight, S.setStyle(l.getModel("handleStyle").getItemStyle()), S.style.strokeNoScale = true, S.rectHover = true, S.ensureState("emphasis").style = l.getModel([
          "emphasis",
          "handleStyle"
        ]).getItemStyle(), Ps(S);
        var C = l.get("handleColor");
        C != null && (S.style.fill = C), o.add(i[x] = S);
        var T = l.getModel("textStyle"), A = l.get("handleLabel") || {}, M = A.show || false;
        t.add(a[x] = new rt({
          silent: true,
          invisible: !M,
          style: wt(T, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: T.getTextColor(),
            font: T.getFont()
          }),
          z2: 10
        }));
      }, this);
      var d = f;
      if (h) {
        var p = Q(l.get("moveHandleSize"), s[1]), v = n.moveHandle = new et({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: true,
          shape: {
            r: [
              0,
              0,
              2,
              2
            ],
            y: s[1] - 0.5,
            height: p
          }
        }), g = p * 0.8, m = n.moveHandleIcon = Xt(l.get("moveHandleIcon"), -g / 2, -g / 2, g, g, "#fff", true);
        m.silent = true, m.y = s[1] + p / 2 - 0.5, v.ensureState("emphasis").style = l.getModel([
          "emphasis",
          "moveHandleStyle"
        ]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(p, 10));
        d = n.moveZone = new et({
          invisible: true,
          shape: {
            y: s[1] - y,
            height: p + y
          }
        }), d.on("mouseover", function() {
          u.enterEmphasis(v);
        }).on("mouseout", function() {
          u.leaveEmphasis(v);
        }), o.add(v), o.add(m), o.add(d);
      }
      d.attr({
        draggable: true,
        cursor: wD(this._orient),
        drift: ne(this._onDragMove, this, "all"),
        ondragstart: ne(this._showDataInfo, this, true),
        ondragend: ne(this._onDragEnd, this),
        onmouseover: ne(this._showDataInfo, this, true),
        onmouseout: ne(this._showDataInfo, this, false)
      });
    }, e.prototype._resetInterval = function() {
      var t = this._range = this.dataZoomModel.getPercentRange(), n = this._getViewExtent();
      this._handleEnds = [
        ht(t[0], [
          0,
          100
        ], n, true),
        ht(t[1], [
          0,
          100
        ], n, true)
      ];
    }, e.prototype._updateInterval = function(t, n) {
      var i = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [
        0,
        100
      ];
      tl(n, a, o, i.get("zoomLock") ? "all" : t, s.minSpan != null ? ht(s.minSpan, l, o, true) : null, s.maxSpan != null ? ht(s.maxSpan, l, o, true) : null);
      var u = this._range, c = this._range = On([
        ht(a[0], o, l, true),
        ht(a[1], o, l, true)
      ]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, e.prototype._updateView = function(t) {
      var n = this._displayables, i = this._handleEnds, a = On(i.slice()), o = this._size;
      D([
        0,
        1
      ], function(d) {
        var p = n.handles[d], v = this._handleHeight;
        p.attr({
          scaleX: v / 2,
          scaleY: v / 2,
          x: i[d] + (d ? -1 : 1),
          y: o[1] / 2 - v / 2
        });
      }, this), n.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: o[1]
      });
      var s = {
        x: a[0],
        width: a[1] - a[0]
      };
      n.moveHandle && (n.moveHandle.setShape(s), n.moveZone.setShape(s), n.moveZone.getBoundingRect(), n.moveHandleIcon && n.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = n.dataShadowSegs, u = [
        0,
        a[0],
        a[1],
        o[0]
      ], c = 0; c < l.length; c++) {
        var h = l[c], f = h.getClipPath();
        f || (f = new et(), h.setClipPath(f)), f.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: o[1]
        });
      }
      this._updateDataInfo(t);
    }, e.prototype._updateDataInfo = function(t) {
      var n = this.dataZoomModel, i = this._displayables, a = i.handleLabels, o = this._orient, s = [
        "",
        ""
      ];
      if (n.get("showDetail")) {
        var l = n.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, h = t ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [
            this._formatLabel(h[0], u),
            this._formatLabel(h[1], u)
          ];
        }
      }
      var f = On(this._handleEnds.slice());
      d.call(this, 0), d.call(this, 1);
      function d(p) {
        var v = ks(i.handles[p].parent, this.group), g = ag(p === 0 ? "right" : "left", v), m = this._handleWidth / 2 + woe, y = ai([
          f[p] + (p === 0 ? -m : m),
          this._size[1] / 2
        ], v);
        a[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: o === Sc ? "middle" : g,
          align: o === Sc ? g : "center",
          text: s[p]
        });
      }
    }, e.prototype._formatLabel = function(t, n) {
      var i = this.dataZoomModel, a = i.get("labelFormatter"), o = i.get("labelPrecision");
      (o == null || o === "auto") && (o = n.getPixelPrecision());
      var s = t == null || isNaN(t) ? "" : n.type === "category" || n.type === "time" ? n.scale.getLabel({
        value: Math.round(t)
      }) : t.toFixed(Math.min(o, 20));
      return ge(a) ? a(t, s) : ee(a) ? a.replace("{value}", s) : s;
    }, e.prototype._showDataInfo = function(t) {
      var n = this.dataZoomModel.get("handleLabel") || {}, i = n.show || false, a = this.dataZoomModel.getModel([
        "emphasis",
        "handleLabel"
      ]), o = a.get("show") || false, s = t || this._dragging ? o : i, l = this._displayables, u = l.handleLabels;
      u[0].attr("invisible", !s), u[1].attr("invisible", !s), l.moveHandle && this.api[s ? "enterEmphasis" : "leaveEmphasis"](l.moveHandle, 1);
    }, e.prototype._onDragMove = function(t, n, i, a) {
      this._dragging = true, pa(a.event);
      var o = this._displayables.sliderGroup.getLocalTransform(), s = ai([
        n,
        i
      ], o, true), l = this._updateInterval(t, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(true);
    }, e.prototype._onDragEnd = function() {
      this._dragging = false, this._showDataInfo(false);
      var t = this.dataZoomModel.get("realtime");
      !t && this._dispatchZoomAction(false);
    }, e.prototype._onClickPanel = function(t) {
      var n = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
      if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
        var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", i[0] - o);
        this._updateView(), s && this._dispatchZoomAction(false);
      }
    }, e.prototype._onBrushStart = function(t) {
      var n = t.offsetX, i = t.offsetY;
      this._brushStart = new Ne(n, i), this._brushing = true, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, e.prototype._onBrushEnd = function(t) {
      if (this._brushing) {
        var n = this._displayables.brushRect;
        if (this._brushing = false, !!n) {
          n.attr("ignore", true);
          var i = n.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var o = this._getViewExtent(), s = [
              0,
              100
            ];
            this._range = On([
              ht(i.x, o, s, true),
              ht(i.x + i.width, o, s, true)
            ]), this._handleEnds = [
              i.x,
              i.x + i.width
            ], this._updateView(), this._dispatchZoomAction(false);
          }
        }
      }
    }, e.prototype._onBrush = function(t) {
      this._brushing && (pa(t.event), this._updateBrushRect(t.offsetX, t.offsetY));
    }, e.prototype._updateBrushRect = function(t, n) {
      var i = this._displayables, a = this.dataZoomModel, o = i.brushRect;
      o || (o = i.brushRect = new bc({
        silent: true,
        style: a.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(o)), o.attr("ignore", false);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(t, n), c = l.transformCoordToLocal(s.x, s.y), h = this._size;
      u[0] = Math.max(Math.min(h[0], u[0]), 0), o.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: h[1]
      });
    }, e.prototype._dispatchZoomAction = function(t) {
      var n = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: t ? Toe : null,
        start: n[0],
        end: n[1]
      });
    }, e.prototype._findCoordRect = function() {
      var t, n = HF(this.dataZoomModel).infoList;
      if (!t && n.length) {
        var i = n[0].model.coordinateSystem;
        t = i.getRect && i.getRect();
      }
      if (!t) {
        var a = this.api.getWidth(), o = this.api.getHeight();
        t = {
          x: a * 0.2,
          y: o * 0.2,
          width: a * 0.6,
          height: o * 0.6
        };
      }
      return t;
    }, e.type = "dataZoom.slider", e;
  }(zS);
  function Ioe(r) {
    var e = {
      x: "y",
      y: "x",
      radius: "angle",
      angle: "radius"
    };
    return e[r];
  }
  function wD(r) {
    return r === "vertical" ? "ns-resize" : "ew-resize";
  }
  function hB(r) {
    r.registerComponentModel(_oe), r.registerComponentView(Aoe), VS(r);
  }
  function Moe(r) {
    Ve(cB), Ve(hB);
  }
  var fB = {
    get: function(r, e, t) {
      var n = be((Doe[r] || {})[e]);
      return t && X(n) ? n[n.length - 1] : n;
    }
  }, Doe = {
    color: {
      active: [
        "#006edd",
        "#e0ffff"
      ],
      inactive: [
        "rgba(0,0,0,0)"
      ]
    },
    colorHue: {
      active: [
        0,
        360
      ],
      inactive: [
        0,
        0
      ]
    },
    colorSaturation: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    colorLightness: {
      active: [
        0.9,
        0.5
      ],
      inactive: [
        0,
        0
      ]
    },
    colorAlpha: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    opacity: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    symbol: {
      active: [
        "circle",
        "roundRect",
        "diamond"
      ],
      inactive: [
        "none"
      ]
    },
    symbolSize: {
      active: [
        10,
        50
      ],
      inactive: [
        0,
        0
      ]
    }
  }, CD = or.mapVisual, Poe = or.eachVisual, koe = X, TD = D, Loe = On, Roe = ht, wv = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.stateList = [
        "inRange",
        "outOfRange"
      ], t.replacableOptionKeys = [
        "inRange",
        "outOfRange",
        "target",
        "controller",
        "color"
      ], t.layoutMode = {
        type: "box",
        ignoreSize: true
      }, t.dataBound = [
        -1 / 0,
        1 / 0
      ], t.targetVisuals = {}, t.controllerVisuals = {}, t;
    }
    return e.prototype.init = function(t, n, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.optionUpdated = function(t, n) {
      var i = this.option;
      !n && tB(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, e.prototype.resetVisual = function(t) {
      var n = this.stateList;
      t = ne(t, this), this.controllerVisuals = B_(this.option.controller, n, t), this.targetVisuals = B_(this.option.target, n, t);
    }, e.prototype.getItemSymbol = function() {
      return null;
    }, e.prototype.getTargetSeriesIndices = function() {
      var t = this.option.seriesIndex, n = [];
      return t == null || t === "all" ? this.ecModel.eachSeries(function(i, a) {
        n.push(a);
      }) : n = gt(t), n;
    }, e.prototype.eachTargetSeries = function(t, n) {
      D(this.getTargetSeriesIndices(), function(i) {
        var a = this.ecModel.getSeriesByIndex(i);
        a && t.call(n, a);
      }, this);
    }, e.prototype.isTargetSeries = function(t) {
      var n = false;
      return this.eachTargetSeries(function(i) {
        i === t && (n = true);
      }), n;
    }, e.prototype.formatValueText = function(t, n, i) {
      var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
      i = i || [
        "<",
        ">"
      ], X(t) && (t = t.slice(), u = true);
      var c = n ? t : u ? [
        h(t[0]),
        h(t[1])
      ] : h(t);
      if (ee(l)) return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (ge(l)) return u ? l(t[0], t[1]) : l(t);
      if (u) return t[0] === s[0] ? i[0] + " " + c[1] : t[1] === s[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function h(f) {
        return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(o, 20));
      }
    }, e.prototype.resetExtent = function() {
      var t = this.option, n = Loe([
        t.min,
        t.max
      ]);
      this._dataExtent = n;
    }, e.prototype.getDataDimensionIndex = function(t) {
      var n = this.option.dimension;
      if (n != null) return t.getDimensionIndex(n);
      for (var i = t.dimensions, a = i.length - 1; a >= 0; a--) {
        var o = i[a], s = t.getDimensionInfo(o);
        if (!s.isCalculationCoord) return s.storeDimIndex;
      }
    }, e.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, e.prototype.completeVisualOption = function() {
      var t = this.ecModel, n = this.option, i = {
        inRange: n.inRange,
        outOfRange: n.outOfRange
      }, a = n.target || (n.target = {}), o = n.controller || (n.controller = {});
      Ee(a, i), Ee(o, i);
      var s = this.isCategory();
      l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), c.call(this, o);
      function l(h) {
        koe(n.color) && !h.inRange && (h.inRange = {
          color: n.color.slice().reverse()
        }), h.inRange = h.inRange || {
          color: t.get("gradientColor")
        };
      }
      function u(h, f, d) {
        var p = h[f], v = h[d];
        p && !v && (v = h[d] = {}, TD(p, function(g, m) {
          if (or.isValidType(m)) {
            var y = fB.get(m, "inactive", s);
            y != null && (v[m] = y, m === "color" && !v.hasOwnProperty("opacity") && !v.hasOwnProperty("colorAlpha") && (v.opacity = [
              0,
              0
            ]));
          }
        }));
      }
      function c(h) {
        var f = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol, d = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), v = this.getItemSymbol(), g = v || "roundRect";
        TD(this.stateList, function(m) {
          var y = this.itemSize, x = h[m];
          x || (x = h[m] = {
            color: s ? p : [
              p
            ]
          }), x.symbol == null && (x.symbol = f && be(f) || (s ? g : [
            g
          ])), x.symbolSize == null && (x.symbolSize = d && be(d) || (s ? y[0] : [
            y[0],
            y[0]
          ])), x.symbol = CD(x.symbol, function(b) {
            return b === "none" ? g : b;
          });
          var _ = x.symbolSize;
          if (_ != null) {
            var S = -1 / 0;
            Poe(_, function(b) {
              b > S && (S = b);
            }), x.symbolSize = CD(_, function(b) {
              return Roe(b, [
                0,
                S
              ], [
                0,
                y[0]
              ], true);
            });
          }
        }, this);
      }
    }, e.prototype.resetItemSize = function() {
      this.itemSize = [
        parseFloat(this.get("itemWidth")),
        parseFloat(this.get("itemHeight"))
      ];
    }, e.prototype.isCategory = function() {
      return !!this.option.categories;
    }, e.prototype.setSelected = function(t) {
    }, e.prototype.getSelected = function() {
      return null;
    }, e.prototype.getValueState = function(t) {
      return null;
    }, e.prototype.getVisualMeta = function(t) {
      return null;
    }, e.type = "visualMap", e.dependencies = [
      "series"
    ], e.defaultOption = {
      show: true,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: false,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
      }
    }, e;
  }(Ke), AD = [
    20,
    140
  ], Eoe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function(t, n) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, e.prototype.resetItemSize = function() {
      r.prototype.resetItemSize.apply(this, arguments);
      var t = this.itemSize;
      (t[0] == null || isNaN(t[0])) && (t[0] = AD[0]), (t[1] == null || isNaN(t[1])) && (t[1] = AD[1]);
    }, e.prototype._resetRange = function() {
      var t = this.getExtent(), n = this.option.range;
      !n || n.auto ? (t.auto = 1, this.option.range = t) : X(n) && (n[0] > n[1] && n.reverse(), n[0] = Math.max(n[0], t[0]), n[1] = Math.min(n[1], t[1]));
    }, e.prototype.completeVisualOption = function() {
      r.prototype.completeVisualOption.apply(this, arguments), D(this.stateList, function(t) {
        var n = this.option.controller[t].symbolSize;
        n && n[0] !== n[1] && (n[0] = n[1] / 3);
      }, this);
    }, e.prototype.setSelected = function(t) {
      this.option.range = t.slice(), this._resetRange();
    }, e.prototype.getSelected = function() {
      var t = this.getExtent(), n = On((this.get("range") || []).slice());
      return n[0] > t[1] && (n[0] = t[1]), n[1] > t[1] && (n[1] = t[1]), n[0] < t[0] && (n[0] = t[0]), n[1] < t[0] && (n[1] = t[0]), n;
    }, e.prototype.getValueState = function(t) {
      var n = this.option.range, i = this.getExtent();
      return (n[0] <= i[0] || n[0] <= t) && (n[1] >= i[1] || t <= n[1]) ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var n = [];
      return this.eachTargetSeries(function(i) {
        var a = [], o = i.getData();
        o.each(this.getDataDimensionIndex(o), function(s, l) {
          t[0] <= s && s <= t[1] && a.push(l);
        }, this), n.push({
          seriesId: i.id,
          dataIndex: a
        });
      }, this), n;
    }, e.prototype.getVisualMeta = function(t) {
      var n = ID(this, "outOfRange", this.getExtent()), i = ID(this, "inRange", this.option.range.slice()), a = [];
      function o(d, p) {
        a.push({
          value: d,
          color: t(d, p)
        });
      }
      for (var s = 0, l = 0, u = i.length, c = n.length; l < c && (!i.length || n[l] <= i[0]); l++) n[l] < i[s] && o(n[l], "outOfRange");
      for (var h = 1; s < u; s++, h = 0) h && a.length && o(i[s], "outOfRange"), o(i[s], "inRange");
      for (var h = 1; l < c; l++) (!i.length || i[i.length - 1] < n[l]) && (h && (a.length && o(a[a.length - 1].value, "outOfRange"), h = 0), o(n[l], "outOfRange"));
      var f = a.length;
      return {
        stops: a,
        outerColors: [
          f ? a[0].color : "transparent",
          f ? a[f - 1].color : "transparent"
        ]
      };
    }, e.type = "visualMap.continuous", e.defaultOption = yo(wv.defaultOption, {
      align: "auto",
      calculable: false,
      hoverLink: true,
      realtime: true,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
    }), e;
  }(wv);
  function ID(r, e, t) {
    if (t[0] === t[1]) return t.slice();
    for (var n = 200, i = (t[1] - t[0]) / n, a = t[0], o = [], s = 0; s <= n && a < t[1]; s++) o.push(a), a += i;
    return o.push(t[1]), o;
  }
  var dB = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, t;
    }
    return e.prototype.init = function(t, n) {
      this.ecModel = t, this.api = n;
    }, e.prototype.render = function(t, n, i, a) {
      if (this.visualMapModel = t, t.get("show") === false) {
        this.group.removeAll();
        return;
      }
      this.doRender(t, n, i, a);
    }, e.prototype.renderBackground = function(t) {
      var n = this.visualMapModel, i = Ou(n.get("padding") || 0), a = t.getBoundingRect();
      t.add(new et({
        z2: -1,
        silent: true,
        shape: {
          x: a.x - i[3],
          y: a.y - i[0],
          width: a.width + i[3] + i[1],
          height: a.height + i[0] + i[2]
        },
        style: {
          fill: n.get("backgroundColor"),
          stroke: n.get("borderColor"),
          lineWidth: n.get("borderWidth")
        }
      }));
    }, e.prototype.getControllerVisual = function(t, n, i) {
      i = i || {};
      var a = i.forceState, o = this.visualMapModel, s = {};
      if (n === "color") {
        var l = o.get("contentColor");
        s.color = l;
      }
      function u(d) {
        return s[d];
      }
      function c(d, p) {
        s[d] = p;
      }
      var h = o.controllerVisuals[a || o.getValueState(t)], f = or.prepareVisualTypes(h);
      return D(f, function(d) {
        var p = h[d];
        i.convertOpacityToAlpha && d === "opacity" && (d = "colorAlpha", p = h.__alphaForOpacity), or.dependsOn(d, n) && p && p.applyVisual(t, u, c);
      }), s[n];
    }, e.prototype.positionGroup = function(t) {
      var n = this.visualMapModel, i = this.api;
      fg(t, n.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, e.prototype.doRender = function(t, n, i, a) {
    }, e.type = "visualMap", e;
  }(Rt), MD = [
    [
      "left",
      "right",
      "width"
    ],
    [
      "top",
      "bottom",
      "height"
    ]
  ];
  function pB(r, e, t) {
    var n = r.option, i = n.align;
    if (i != null && i !== "auto") return i;
    for (var a = {
      width: e.getWidth(),
      height: e.getHeight()
    }, o = n.orient === "horizontal" ? 1 : 0, s = MD[o], l = [
      0,
      null,
      10
    ], u = {}, c = 0; c < 3; c++) u[MD[1 - o][c]] = l[c], u[s[c]] = c === 2 ? t[0] : n[s[c]];
    var h = [
      [
        "x",
        "width",
        3
      ],
      [
        "y",
        "height",
        0
      ]
    ][o], f = er(u, a, n.padding);
    return s[(f.margin[h[2]] || 0) + f[h[0]] + f[h[1]] * 0.5 < a[h[1]] * 0.5 ? 0 : 1];
  }
  function Dp(r, e) {
    return D(r || [], function(t) {
      t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "");
    }), r;
  }
  var bi = ht, Noe = D, DD = Math.min, h0 = Math.max, Ooe = 12, Foe = 6, Boe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t;
    }
    return e.prototype.init = function(t, n) {
      r.prototype.init.call(this, t, n), this._hoverLinkFromSeriesMouseOver = ne(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = ne(this._hideIndicator, this);
    }, e.prototype.doRender = function(t, n, i, a) {
      (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, e.prototype._buildView = function() {
      this.group.removeAll();
      var t = this.visualMapModel, n = this.group;
      this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(n);
      var i = t.get("text");
      this._renderEndsText(n, i, 0), this._renderEndsText(n, i, 1), this._updateView(true), this.renderBackground(n), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(n);
    }, e.prototype._renderEndsText = function(t, n, i) {
      if (n) {
        var a = n[1 - i];
        a = a != null ? a + "" : "";
        var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([
          l[0] / 2,
          i === 0 ? -s : l[1] + s
        ], u), h = this._applyTransform(i === 0 ? "bottom" : "top", u), f = this._orient, d = this.visualMapModel.textStyleModel;
        this.group.add(new rt({
          style: wt(d, {
            x: c[0],
            y: c[1],
            verticalAlign: f === "horizontal" ? "middle" : h,
            align: f === "horizontal" ? h : "center",
            text: a
          })
        }));
      }
    }, e.prototype._renderBar = function(t) {
      var n = this.visualMapModel, i = this._shapes, a = n.itemSize, o = this._orient, s = this._useHandle, l = pB(n, this.api, a), u = i.mainGroup = this._createBarGroup(l), c = new Ce();
      u.add(c), c.add(i.outOfRange = PD()), c.add(i.inRange = PD(null, s ? LD(this._orient) : null, ne(this._dragHandle, this, "all", false), ne(this._dragHandle, this, "all", true))), c.setClipPath(new et({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var h = n.textStyleModel.getTextRect("\u56FD"), f = h0(h.width, h.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(n, u, 0, a, f, o), this._createHandle(n, u, 1, a, f, o)), this._createIndicator(n, u, a, f, o), t.add(u);
    }, e.prototype._createHandle = function(t, n, i, a, o, s) {
      var l = ne(this._dragHandle, this, i, false), u = ne(this._dragHandle, this, i, true), c = si(t.get("handleSize"), a[0]), h = Xt(t.get("handleIcon"), -c / 2, -c / 2, c, c, null, true), f = LD(this._orient);
      h.attr({
        cursor: f,
        draggable: true,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          pa(m.event);
        }
      }), h.x = a[0] / 2, h.useStyle(t.getModel("handleStyle").getItemStyle()), h.setStyle({
        strokeNoScale: true,
        strokeFirst: true
      }), h.style.lineWidth *= 2, h.ensureState("emphasis").style = t.getModel([
        "emphasis",
        "handleStyle"
      ]).getItemStyle(), ms(h, true), n.add(h);
      var d = this.visualMapModel.textStyleModel, p = new rt({
        cursor: f,
        draggable: true,
        drift: l,
        onmousemove: function(m) {
          pa(m.event);
        },
        ondragend: u,
        style: wt(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var v = [
        c,
        0
      ], g = this._shapes;
      g.handleThumbs[i] = h, g.handleLabelPoints[i] = v, g.handleLabels[i] = p;
    }, e.prototype._createIndicator = function(t, n, i, a, o) {
      var s = si(t.get("indicatorSize"), i[0]), l = Xt(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, true);
      l.attr({
        cursor: "move",
        invisible: true,
        silent: true,
        x: i[0] / 2
      });
      var u = t.getModel("indicatorStyle").getItemStyle();
      if (l instanceof mr) {
        var c = l.style;
        l.useStyle(H({
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else l.useStyle(u);
      n.add(l);
      var h = this.visualMapModel.textStyleModel, f = new rt({
        silent: true,
        invisible: true,
        style: wt(h, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(f);
      var d = [
        (o === "horizontal" ? a / 2 : Foe) + i[0] / 2,
        0
      ], p = this._shapes;
      p.indicator = l, p.indicatorLabel = f, p.indicatorLabelPoint = d, this._firstShowIndicator = true;
    }, e.prototype._dragHandle = function(t, n, i, a) {
      if (this._useHandle) {
        if (this._dragging = !n, !n) {
          var o = this._applyTransform([
            i,
            a
          ], this._shapes.mainGroup, true);
          this._updateInterval(t, o[1]), this._hideIndicator(), this._updateView();
        }
        n === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), n ? !this._hovering && this._clearHoverLinkToSeries() : kD(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], false);
      }
    }, e.prototype._resetInterval = function() {
      var t = this.visualMapModel, n = this._dataInterval = t.getSelected(), i = t.getExtent(), a = [
        0,
        t.itemSize[1]
      ];
      this._handleEnds = [
        bi(n[0], i, a, true),
        bi(n[1], i, a, true)
      ];
    }, e.prototype._updateInterval = function(t, n) {
      n = n || 0;
      var i = this.visualMapModel, a = this._handleEnds, o = [
        0,
        i.itemSize[1]
      ];
      tl(n, a, o, t, 0);
      var s = i.getExtent();
      this._dataInterval = [
        bi(a[0], o, s, true),
        bi(a[1], o, s, true)
      ];
    }, e.prototype._updateView = function(t) {
      var n = this.visualMapModel, i = n.getExtent(), a = this._shapes, o = [
        0,
        n.itemSize[1]
      ], s = t ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, o, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, e.prototype._createBarVisual = function(t, n, i, a) {
      var o = {
        forceState: a,
        convertOpacityToAlpha: true
      }, s = this._makeColorGradient(t, o), l = [
        this.getControllerVisual(t[0], "symbolSize", o),
        this.getControllerVisual(t[1], "symbolSize", o)
      ], u = this._createBarPoints(i, l);
      return {
        barColor: new xf(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [
          s[0].color,
          s[s.length - 1].color
        ]
      };
    }, e.prototype._makeColorGradient = function(t, n) {
      var i = 100, a = [], o = (t[1] - t[0]) / i;
      a.push({
        color: this.getControllerVisual(t[0], "color", n),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = t[0] + o * s;
        if (l > t[1]) break;
        a.push({
          color: this.getControllerVisual(l, "color", n),
          offset: s / i
        });
      }
      return a.push({
        color: this.getControllerVisual(t[1], "color", n),
        offset: 1
      }), a;
    }, e.prototype._createBarPoints = function(t, n) {
      var i = this.visualMapModel.itemSize;
      return [
        [
          i[0] - n[0],
          t[0]
        ],
        [
          i[0],
          t[0]
        ],
        [
          i[0],
          t[1]
        ],
        [
          i[0] - n[1],
          t[1]
        ]
      ];
    }, e.prototype._createBarGroup = function(t) {
      var n = this._orient, i = this.visualMapModel.get("inverse");
      return new Ce(n === "horizontal" && !i ? {
        scaleX: t === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : n === "horizontal" && i ? {
        scaleX: t === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : n === "vertical" && !i ? {
        scaleX: t === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: t === "left" ? 1 : -1
      });
    }, e.prototype._updateHandle = function(t, n) {
      if (this._useHandle) {
        var i = this._shapes, a = this.visualMapModel, o = i.handleThumbs, s = i.handleLabels, l = a.itemSize, u = a.getExtent(), c = this._applyTransform("left", i.mainGroup);
        Noe([
          0,
          1
        ], function(h) {
          var f = o[h];
          f.setStyle("fill", n.handlesColor[h]), f.y = t[h];
          var d = bi(t[h], [
            0,
            l[1]
          ], u, true), p = this.getControllerVisual(d, "symbolSize");
          f.scaleX = f.scaleY = p / l[0], f.x = l[0] - p / 2;
          var v = ai(i.handleLabelPoints[h], ks(f, this.group));
          if (this._orient === "horizontal") {
            var g = c === "left" || c === "top" ? (l[0] - p) / 2 : (l[0] - p) / -2;
            v[1] += g;
          }
          s[h].setStyle({
            x: v[0],
            y: v[1],
            text: a.formatValueText(this._dataInterval[h]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, e.prototype._showIndicator = function(t, n, i, a) {
      var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [
        0,
        l[1]
      ], c = this._shapes, h = c.indicator;
      if (h) {
        h.attr("invisible", false);
        var f = {
          convertOpacityToAlpha: true
        }, d = this.getControllerVisual(t, "color", f), p = this.getControllerVisual(t, "symbolSize"), v = bi(t, s, u, true), g = l[0] - p / 2, m = {
          x: h.x,
          y: h.y
        };
        h.y = v, h.x = g;
        var y = ai(c.indicatorLabelPoint, ks(h, this.group)), x = c.indicatorLabel;
        x.attr("invisible", false);
        var _ = this._applyTransform("left", c.mainGroup), S = this._orient, b = S === "horizontal";
        x.setStyle({
          text: (i || "") + o.formatValueText(n),
          verticalAlign: b ? _ : "middle",
          align: b ? "center" : _
        });
        var w = {
          x: g,
          y: v,
          style: {
            fill: d
          }
        }, C = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var T = {
            duration: 100,
            easing: "cubicInOut",
            additive: true
          };
          h.x = m.x, h.y = m.y, h.animateTo(w, T), x.animateTo(C, T);
        } else h.attr(w), x.attr(C);
        this._firstShowIndicator = false;
        var A = this._shapes.handleLabels;
        if (A) for (var M = 0; M < A.length; M++) this.api.enterBlur(A[M]);
      }
    }, e.prototype._enableHoverLinkToSeries = function() {
      var t = this;
      this._shapes.mainGroup.on("mousemove", function(n) {
        if (t._hovering = true, !t._dragging) {
          var i = t.visualMapModel.itemSize, a = t._applyTransform([
            n.offsetX,
            n.offsetY
          ], t._shapes.mainGroup, true, true);
          a[1] = DD(h0(0, a[1]), i[1]), t._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]);
        }
      }).on("mouseout", function() {
        t._hovering = false, !t._dragging && t._clearHoverLinkToSeries();
      });
    }, e.prototype._enableHoverLinkFromSeries = function() {
      var t = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, e.prototype._doHoverLinkToSeries = function(t, n) {
      var i = this.visualMapModel, a = i.itemSize;
      if (i.option.hoverLink) {
        var o = [
          0,
          a[1]
        ], s = i.getExtent();
        t = DD(h0(o[0], t), o[1]);
        var l = zoe(i, s, o), u = [
          t - l,
          t + l
        ], c = bi(t, o, s, true), h = [
          bi(u[0], o, s, true),
          bi(u[1], o, s, true)
        ];
        u[0] < o[0] && (h[0] = -1 / 0), u[1] > o[1] && (h[1] = 1 / 0), n && (h[0] === -1 / 0 ? this._showIndicator(c, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, "\u2248 ", l));
        var f = this._hoverLinkDataIndices, d = [];
        (n || kD(i)) && (d = this._hoverLinkDataIndices = i.findTargetDataIndices(h));
        var p = HH(f, d);
        this._dispatchHighDown("downplay", Dp(p[0], i)), this._dispatchHighDown("highlight", Dp(p[1], i));
      }
    }, e.prototype._hoverLinkFromSeriesMouseOver = function(t) {
      var n;
      if (xs(t.target, function(l) {
        var u = De(l);
        if (u.dataIndex != null) return n = u, true;
      }, true), !!n) {
        var i = this.ecModel.getSeriesByIndex(n.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(i)) {
          var o = i.getData(n.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), n.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, e.prototype._hideIndicator = function() {
      var t = this._shapes;
      t.indicator && t.indicator.attr("invisible", true), t.indicatorLabel && t.indicatorLabel.attr("invisible", true);
      var n = this._shapes.handleLabels;
      if (n) for (var i = 0; i < n.length; i++) this.api.leaveBlur(n[i]);
    }, e.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var t = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", Dp(t, this.visualMapModel)), t.length = 0;
    }, e.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var t = this.api.getZr();
      t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
    }, e.prototype._applyTransform = function(t, n, i, a) {
      var o = ks(n, a ? null : this.group);
      return X(t) ? ai(t, o, i) : ag(t, o, i);
    }, e.prototype._dispatchHighDown = function(t, n) {
      n && n.length && this.api.dispatchAction({
        type: t,
        batch: n
      });
    }, e.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.type = "visualMap.continuous", e;
  }(dB);
  function PD(r, e, t, n) {
    return new Kr({
      shape: {
        points: r
      },
      draggable: !!t,
      cursor: e,
      drift: t,
      onmousemove: function(i) {
        pa(i.event);
      },
      ondragend: n
    });
  }
  function zoe(r, e, t) {
    var n = Ooe / 2, i = r.get("hoverLinkDataSize");
    return i && (n = bi(i, e, t, true) / 2), n;
  }
  function kD(r) {
    var e = r.get("hoverLinkOnHandle");
    return !!(e ?? r.get("realtime"));
  }
  function LD(r) {
    return r === "vertical" ? "ns-resize" : "ew-resize";
  }
  var Voe = {
    type: "selectDataRange",
    event: "dataRangeSelected",
    update: "update"
  }, $oe = function(r, e) {
    e.eachComponent({
      mainType: "visualMap",
      query: r
    }, function(t) {
      t.setSelected(r.selected);
    });
  }, Goe = [
    {
      createOnAllSeries: true,
      reset: function(r, e) {
        var t = [];
        return e.eachComponent("visualMap", function(n) {
          var i = r.pipelineContext;
          !n.isTargetSeries(r) || i && i.large || t.push(cae(n.stateList, n.targetVisuals, ne(n.getValueState, n), n.getDataDimensionIndex(r.getData())));
        }), t;
      }
    },
    {
      createOnAllSeries: true,
      reset: function(r, e) {
        var t = r.getData(), n = [];
        e.eachComponent("visualMap", function(i) {
          if (i.isTargetSeries(r)) {
            var a = i.getVisualMeta(ne(Woe, null, r, i)) || {
              stops: [],
              outerColors: []
            }, o = i.getDataDimensionIndex(t);
            o >= 0 && (a.dimension = o, n.push(a));
          }
        }), r.getData().setVisual("visualMeta", n);
      }
    }
  ];
  function Woe(r, e, t, n) {
    for (var i = e.targetVisuals[n], a = or.prepareVisualTypes(i), o = {
      color: wf(r.getData(), "color")
    }, s = 0, l = a.length; s < l; s++) {
      var u = a[s], c = i[u === "opacity" ? "__alphaForOpacity" : u];
      c && c.applyVisual(t, h, f);
    }
    return o.color;
    function h(d) {
      return o[d];
    }
    function f(d, p) {
      o[d] = p;
    }
  }
  var RD = D;
  function Uoe(r) {
    var e = r && r.visualMap;
    X(e) || (e = e ? [
      e
    ] : []), RD(e, function(t) {
      if (t) {
        Il(t, "splitList") && !Il(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
        var n = t.pieces;
        n && X(n) && RD(n, function(i) {
          _e(i) && (Il(i, "start") && !Il(i, "min") && (i.min = i.start), Il(i, "end") && !Il(i, "max") && (i.max = i.end));
        });
      }
    });
  }
  function Il(r, e) {
    return r && r.hasOwnProperty && r.hasOwnProperty(e);
  }
  var ED = false;
  function vB(r) {
    ED || (ED = true, r.registerSubTypeDefaulter("visualMap", function(e) {
      return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise";
    }), r.registerAction(Voe, $oe), D(Goe, function(e) {
      r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, e);
    }), r.registerPreprocessor(Uoe));
  }
  function gB(r) {
    r.registerComponentModel(Eoe), r.registerComponentView(Boe), vB(r);
  }
  var Hoe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._pieceList = [], t;
    }
    return e.prototype.optionUpdated = function(t, n) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], Yoe[this._mode].call(this, this._pieceList), this._resetSelected(t, n);
      var a = this.option.categories;
      this.resetVisual(function(o, s) {
        i === "categories" ? (o.mappingMethod = "category", o.categories = be(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = K(this._pieceList, function(l) {
          return l = be(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, e.prototype.completeVisualOption = function() {
      var t = this.option, n = {}, i = or.listVisualTypes(), a = this.isCategory();
      D(t.pieces, function(s) {
        D(i, function(l) {
          s.hasOwnProperty(l) && (n[l] = 1);
        });
      }), D(n, function(s, l) {
        var u = false;
        D(this.stateList, function(c) {
          u = u || o(t, c, l) || o(t.target, c, l);
        }, this), !u && D(this.stateList, function(c) {
          (t[c] || (t[c] = {}))[l] = fB.get(l, c === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function o(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      r.prototype.completeVisualOption.apply(this, arguments);
    }, e.prototype._resetSelected = function(t, n) {
      var i = this.option, a = this._pieceList, o = (n ? i : t).selected || {};
      if (i.selected = o, D(a, function(l, u) {
        var c = this.getSelectedMapKey(l);
        o.hasOwnProperty(c) || (o[c] = true);
      }, this), i.selectedMode === "single") {
        var s = false;
        D(a, function(l, u) {
          var c = this.getSelectedMapKey(l);
          o[c] && (s ? o[c] = false : s = true);
        }, this);
      }
    }, e.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, e.prototype.getSelectedMapKey = function(t) {
      return this._mode === "categories" ? t.value + "" : t.index + "";
    }, e.prototype.getPieceList = function() {
      return this._pieceList;
    }, e.prototype._determineMode = function() {
      var t = this.option;
      return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, e.prototype.setSelected = function(t) {
      this.option.selected = be(t);
    }, e.prototype.getValueState = function(t) {
      var n = or.findPieceIndex(t, this._pieceList);
      return n != null && this.option.selected[this.getSelectedMapKey(this._pieceList[n])] ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var n = [], i = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var o = [], s = a.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = or.findPieceIndex(l, i);
          c === t && o.push(u);
        }, this), n.push({
          seriesId: a.id,
          dataIndex: o
        });
      }, this), n;
    }, e.prototype.getRepresentValue = function(t) {
      var n;
      if (this.isCategory()) n = t.value;
      else if (t.value != null) n = t.value;
      else {
        var i = t.interval || [];
        n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return n;
    }, e.prototype.getVisualMeta = function(t) {
      if (this.isCategory()) return;
      var n = [], i = [
        "",
        ""
      ], a = this;
      function o(c, h) {
        var f = a.getRepresentValue({
          interval: c
        });
        h || (h = a.getValueState(f));
        var d = t(f, h);
        c[0] === -1 / 0 ? i[0] = d : c[1] === 1 / 0 ? i[1] = d : n.push({
          value: c[0],
          color: d
        }, {
          value: c[1],
          color: d
        });
      }
      var s = this._pieceList.slice();
      if (!s.length) s.push({
        interval: [
          -1 / 0,
          1 / 0
        ]
      });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [
            -1 / 0,
            l
          ]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [
            l,
            1 / 0
          ]
        });
      }
      var u = -1 / 0;
      return D(s, function(c) {
        var h = c.interval;
        h && (h[0] > u && o([
          u,
          h[0]
        ], "outOfRange"), o(h.slice()), u = h[1]);
      }, this), {
        stops: n,
        outerColors: i
      };
    }, e.type = "visualMap.piecewise", e.defaultOption = yo(wv.defaultOption, {
      selected: null,
      minOpen: false,
      maxOpen: false,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: true
    }), e;
  }(wv), Yoe = {
    splitNumber: function(r) {
      var e = this.option, t = Math.min(e.precision, 20), n = this.getExtent(), i = e.splitNumber;
      i = Math.max(parseInt(i, 10), 1), e.splitNumber = i;
      for (var a = (n[1] - n[0]) / i; +a.toFixed(t) !== a && t < 5; ) t++;
      e.precision = t, a = +a.toFixed(t), e.minOpen && r.push({
        interval: [
          -1 / 0,
          n[0]
        ],
        close: [
          0,
          0
        ]
      });
      for (var o = 0, s = n[0]; o < i; s += a, o++) {
        var l = o === i - 1 ? n[1] : s + a;
        r.push({
          interval: [
            s,
            l
          ],
          close: [
            1,
            1
          ]
        });
      }
      e.maxOpen && r.push({
        interval: [
          n[1],
          1 / 0
        ],
        close: [
          0,
          0
        ]
      }), MC(r), D(r, function(u, c) {
        u.index = c, u.text = this.formatValueText(u.interval);
      }, this);
    },
    categories: function(r) {
      var e = this.option;
      D(e.categories, function(t) {
        r.push({
          text: this.formatValueText(t, true),
          value: t
        });
      }, this), ND(e, r);
    },
    pieces: function(r) {
      var e = this.option;
      D(e.pieces, function(t, n) {
        _e(t) || (t = {
          value: t
        });
        var i = {
          text: "",
          index: n
        };
        if (t.label != null && (i.text = t.label), t.hasOwnProperty("value")) {
          var a = i.value = t.value;
          i.interval = [
            a,
            a
          ], i.close = [
            1,
            1
          ];
        } else {
          for (var o = i.interval = [], s = i.close = [
            0,
            0
          ], l = [
            1,
            0,
            1
          ], u = [
            -1 / 0,
            1 / 0
          ], c = [], h = 0; h < 2; h++) {
            for (var f = [
              [
                "gte",
                "gt",
                "min"
              ],
              [
                "lte",
                "lt",
                "max"
              ]
            ][h], d = 0; d < 3 && o[h] == null; d++) o[h] = t[f[d]], s[h] = l[d], c[h] = d === 2;
            o[h] == null && (o[h] = u[h]);
          }
          c[0] && o[1] === 1 / 0 && (s[0] = 0), c[1] && o[0] === -1 / 0 && (s[1] = 0), o[0] === o[1] && s[0] && s[1] && (i.value = o[0]);
        }
        i.visual = or.retrieveVisuals(t), r.push(i);
      }, this), ND(e, r), MC(r), D(r, function(t) {
        var n = t.close, i = [
          [
            "<",
            "\u2264"
          ][n[1]],
          [
            ">",
            "\u2265"
          ][n[0]]
        ];
        t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, false, i);
      }, this);
    }
  };
  function ND(r, e) {
    var t = r.inverse;
    (r.orient === "vertical" ? !t : t) && e.reverse();
  }
  var Xoe = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.doRender = function() {
      var t = this.group;
      t.removeAll();
      var n = this.visualMapModel, i = n.get("textGap"), a = n.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), u = n.itemSize, c = this._getViewData(), h = c.endsText, f = vr(n.get("showLabel", true), !h), d = !n.get("selectedMode");
      h && this._renderEndsText(t, h[0], u, f, l), D(c.viewPieceList, function(p) {
        var v = p.piece, g = new Ce();
        g.onclick = ne(this._onItemClick, this, v), this._enableHoverLink(g, p.indexInModelPieceList);
        var m = n.getRepresentValue(v);
        if (this._createItemSymbol(g, m, [
          0,
          0,
          u[0],
          u[1]
        ], d), f) {
          var y = this.visualMapModel.getValueState(m);
          g.add(new rt({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: v.text,
              verticalAlign: "middle",
              align: l,
              font: o,
              fill: s,
              opacity: y === "outOfRange" ? 0.5 : 1
            },
            silent: d
          }));
        }
        t.add(g);
      }, this), h && this._renderEndsText(t, h[1], u, f, l), Ls(n.get("orient"), t, n.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
    }, e.prototype._enableHoverLink = function(t, n) {
      var i = this;
      t.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(o) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: o,
          batch: Dp(s.findTargetDataIndices(n), s)
        });
      };
    }, e.prototype._getItemAlign = function() {
      var t = this.visualMapModel, n = t.option;
      if (n.orient === "vertical") return pB(t, this.api, t.itemSize);
      var i = n.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, e.prototype._renderEndsText = function(t, n, i, a, o) {
      if (n) {
        var s = new Ce(), l = this.visualMapModel.textStyleModel;
        s.add(new rt({
          style: wt(l, {
            x: a ? o === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: a ? o : "center",
            text: n
          })
        })), t.add(s);
      }
    }, e.prototype._getViewData = function() {
      var t = this.visualMapModel, n = K(t.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = t.get("text"), a = t.get("orient"), o = t.get("inverse");
      return (a === "horizontal" ? o : !o) ? n.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: n,
        endsText: i
      };
    }, e.prototype._createItemSymbol = function(t, n, i, a) {
      var o = Xt(this.getControllerVisual(n, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(n, "color"));
      o.silent = a, t.add(o);
    }, e.prototype._onItemClick = function(t) {
      var n = this.visualMapModel, i = n.option, a = i.selectedMode;
      if (a) {
        var o = be(i.selected), s = n.getSelectedMapKey(t);
        a === "single" || a === true ? (o[s] = true, D(o, function(l, u) {
          o[u] = u === s;
        })) : o[s] = !o[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: o
        });
      }
    }, e.type = "visualMap.piecewise", e;
  }(dB);
  function mB(r) {
    r.registerComponentModel(Hoe), r.registerComponentView(Xoe), vB(r);
  }
  function qoe(r) {
    Ve(gB), Ve(mB);
  }
  var Koe = {
    label: {
      enabled: true
    },
    decal: {
      show: false
    }
  }, OD = tt(), Zoe = {};
  function joe(r, e) {
    var t = r.getModel("aria");
    if (!t.get("enabled")) return;
    var n = be(Koe);
    Ee(n.label, r.getLocaleModel().get("aria"), false), Ee(t.option, n, false), i(), a();
    function i() {
      var u = t.getModel("decal"), c = u.get("show");
      if (c) {
        var h = ce();
        r.eachSeries(function(f) {
          if (!f.isColorBySeries()) {
            var d = h.get(f.type);
            d || (d = {}, h.set(f.type, d)), OD(f).scope = d;
          }
        }), r.eachRawSeries(function(f) {
          if (r.isSeriesFiltered(f)) return;
          if (ge(f.enableAriaDecal)) {
            f.enableAriaDecal();
            return;
          }
          var d = f.getData();
          if (f.isColorBySeries()) {
            var y = Ux(f.ecModel, f.name, Zoe, r.getSeriesCount()), x = d.getVisual("decal");
            d.setVisual("decal", _(x, y));
          } else {
            var p = f.getRawData(), v = {}, g = OD(f).scope;
            d.each(function(S) {
              var b = d.getRawIndex(S);
              v[b] = S;
            });
            var m = p.count();
            p.each(function(S) {
              var b = v[S], w = p.getName(S) || S + "", C = Ux(f.ecModel, w, g, m), T = d.getItemVisual(b, "decal");
              d.setItemVisual(b, "decal", _(T, C));
            });
          }
          function _(S, b) {
            var w = S ? H(H({}, b), S) : b;
            return w.dirty = true, w;
          }
        });
      }
    }
    function a() {
      var u = e.getZr().dom;
      if (u) {
        var c = r.getLocaleModel().get("aria"), h = t.getModel("label");
        if (h.option = ye(h.option, c), !!h.get("enabled")) {
          if (u.setAttribute("role", "img"), h.get("description")) {
            u.setAttribute("aria-label", h.get("description"));
            return;
          }
          var f = r.getSeriesCount(), d = h.get([
            "data",
            "maxCount"
          ]) || 10, p = h.get([
            "series",
            "maxCount"
          ]) || 10, v = Math.min(f, p), g;
          if (!(f < 1)) {
            var m = s();
            if (m) {
              var y = h.get([
                "general",
                "withTitle"
              ]);
              g = o(y, {
                title: m
              });
            } else g = h.get([
              "general",
              "withoutTitle"
            ]);
            var x = [], _ = f > 1 ? h.get([
              "series",
              "multiple",
              "prefix"
            ]) : h.get([
              "series",
              "single",
              "prefix"
            ]);
            g += o(_, {
              seriesCount: f
            }), r.eachSeries(function(C, T) {
              if (T < v) {
                var A = void 0, M = C.get("name"), E = M ? "withName" : "withoutName";
                A = f > 1 ? h.get([
                  "series",
                  "multiple",
                  E
                ]) : h.get([
                  "series",
                  "single",
                  E
                ]), A = o(A, {
                  seriesId: C.seriesIndex,
                  seriesName: C.get("name"),
                  seriesType: l(C.subType)
                });
                var k = C.getData();
                if (k.count() > d) {
                  var R = h.get([
                    "data",
                    "partialData"
                  ]);
                  A += o(R, {
                    displayCnt: d
                  });
                } else A += h.get([
                  "data",
                  "allData"
                ]);
                for (var N = h.get([
                  "data",
                  "separator",
                  "middle"
                ]), I = h.get([
                  "data",
                  "separator",
                  "end"
                ]), L = h.get([
                  "data",
                  "excludeDimensionId"
                ]), P = [], O = 0; O < k.count(); O++) if (O < d) {
                  var F = k.getName(O), B = L ? ct(k.getValues(O), function(U, Y) {
                    return Be(L, Y) === -1;
                  }) : k.getValues(O), V = h.get([
                    "data",
                    F ? "withName" : "withoutName"
                  ]);
                  P.push(o(V, {
                    name: F,
                    value: B.join(N)
                  }));
                }
                A += P.join(N) + I, x.push(A);
              }
            });
            var S = h.getModel([
              "series",
              "multiple",
              "separator"
            ]), b = S.get("middle"), w = S.get("end");
            g += x.join(b) + w, u.setAttribute("aria-label", g);
          }
        }
      }
    }
    function o(u, c) {
      if (!ee(u)) return u;
      var h = u;
      return D(c, function(f, d) {
        h = h.replace(new RegExp("\\{\\s*" + d + "\\s*\\}", "g"), f);
      }), h;
    }
    function s() {
      var u = r.get("title");
      return u && u.length && (u = u[0]), u && u.text;
    }
    function l(u) {
      var c = r.getLocaleModel().get([
        "series",
        "typeNames"
      ]);
      return c[u] || c.chart;
    }
  }
  function Qoe(r) {
    if (!(!r || !r.aria)) {
      var e = r.aria;
      e.show != null && (e.enabled = e.show), e.label = e.label || {}, D([
        "description",
        "general",
        "series",
        "data"
      ], function(t) {
        e[t] != null && (e.label[t] = e[t]);
      });
    }
  }
  function Joe(r) {
    r.registerPreprocessor(Qoe), r.registerVisual(r.PRIORITY.VISUAL.ARIA, joe);
  }
  var FD = {
    value: "eq",
    "<": "lt",
    "<=": "lte",
    ">": "gt",
    ">=": "gte",
    "=": "eq",
    "!=": "ne",
    "<>": "ne"
  }, ese = function() {
    function r(e) {
      var t = this._condVal = ee(e) ? new RegExp(e) : lU(e) ? e : null;
      if (t == null) {
        var n = "";
        ut(n);
      }
    }
    return r.prototype.evaluate = function(e) {
      var t = typeof e;
      return ee(t) ? this._condVal.test(e) : nt(t) ? this._condVal.test(e + "") : false;
    }, r;
  }(), tse = function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return this.value;
    }, r;
  }(), rse = function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++) if (!e[t].evaluate()) return false;
      return true;
    }, r;
  }(), nse = function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++) if (e[t].evaluate()) return true;
      return false;
    }, r;
  }(), ise = function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, r;
  }(), ase = function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = !!this.valueParser, t = this.getValue, n = t(this.valueGetterParam), i = e ? this.valueParser(n) : null, a = 0; a < this.subCondList.length; a++) if (!this.subCondList[a].evaluate(e ? i : n)) return false;
      return true;
    }, r;
  }();
  function KS(r, e) {
    if (r === true || r === false) {
      var t = new tse();
      return t.value = r, t;
    }
    var n = "";
    return yB(r) || ut(n), r.and ? BD("and", r, e) : r.or ? BD("or", r, e) : r.not ? ose(r, e) : sse(r, e);
  }
  function BD(r, e, t) {
    var n = e[r], i = "";
    X(n) || ut(i), n.length || ut(i);
    var a = r === "and" ? new rse() : new nse();
    return a.children = K(n, function(o) {
      return KS(o, t);
    }), a.children.length || ut(i), a;
  }
  function ose(r, e) {
    var t = r.not, n = "";
    yB(t) || ut(n);
    var i = new ise();
    return i.child = KS(t, e), i.child || ut(n), i;
  }
  function sse(r, e) {
    for (var t = "", n = e.prepareGetValue(r), i = [], a = je(r), o = r.parser, s = o ? JE(o) : null, l = 0; l < a.length; l++) {
      var u = a[l];
      if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
        var c = oe(FD, u) ? FD[u] : u, h = r[u], f = s ? s(h) : h, d = qY(c, f) || c === "reg" && new ese(f);
        d || ut(t), i.push(d);
      }
    }
    i.length || ut(t);
    var p = new ase();
    return p.valueGetterParam = n, p.valueParser = s, p.getValue = e.getValue, p.subCondList = i, p;
  }
  function yB(r) {
    return _e(r) && !Lr(r);
  }
  var lse = function() {
    function r(e, t) {
      this._cond = KS(e, t);
    }
    return r.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, r;
  }();
  function use(r, e) {
    return new lse(r, e);
  }
  var cse = {
    type: "echarts:filter",
    transform: function(r) {
      for (var e = r.upstream, t, n = use(r.config, {
        valueGetterAttrMap: ce({
          dimension: true
        }),
        prepareGetValue: function(s) {
          var l = "", u = s.dimension;
          oe(s, "dimension") || ut(l);
          var c = e.getDimensionInfo(u);
          return c || ut(l), {
            dimIdx: c.index
          };
        },
        getValue: function(s) {
          return e.retrieveValueFromItem(t, s.dimIdx);
        }
      }), i = [], a = 0, o = e.count(); a < o; a++) t = e.getRawDataItem(a), n.evaluate() && i.push(t);
      return {
        data: i
      };
    }
  }, hse = {
    type: "echarts:sort",
    transform: function(r) {
      var e = r.upstream, t = r.config, n = "", i = gt(t);
      i.length || ut(n);
      var a = [];
      D(i, function(c) {
        var h = c.dimension, f = c.order, d = c.parser, p = c.incomparable;
        if (h == null && ut(n), f !== "asc" && f !== "desc" && ut(n), p && p !== "min" && p !== "max") {
          var v = "";
          ut(v);
        }
        if (f !== "asc" && f !== "desc") {
          var g = "";
          ut(g);
        }
        var m = e.getDimensionInfo(h);
        m || ut(n);
        var y = d ? JE(d) : null;
        d && !y && ut(n), a.push({
          dimIdx: m.index,
          parser: y,
          comparator: new t3(f, p)
        });
      });
      var o = e.sourceFormat;
      o !== Rr && o !== Gn && ut(n);
      for (var s = [], l = 0, u = e.count(); l < u; l++) s.push(e.getRawDataItem(l));
      return s.sort(function(c, h) {
        for (var f = 0; f < a.length; f++) {
          var d = a[f], p = e.retrieveValueFromItem(c, d.dimIdx), v = e.retrieveValueFromItem(h, d.dimIdx);
          d.parser && (p = d.parser(p), v = d.parser(v));
          var g = d.comparator.evaluate(p, v);
          if (g !== 0) return g;
        }
        return 0;
      }), {
        data: s
      };
    }
  };
  function fse(r) {
    r.registerTransform(cse), r.registerTransform(hse);
  }
  var dse = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.prototype.init = function(t, n, i) {
      r.prototype.init.call(this, t, n, i), this._sourceManager = new a3(this), V2(this);
    }, e.prototype.mergeOption = function(t, n) {
      r.prototype.mergeOption.call(this, t, n), V2(this);
    }, e.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, e.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, e.type = "dataset", e.defaultOption = {
      seriesLayoutBy: Ei
    }, e;
  }(Ke), pse = function(r) {
    G(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.type = "dataset", e;
  }(Rt);
  function vse(r) {
    r.registerComponentModel(dse), r.registerComponentView(pse);
  }
  var yi = $i.CMD;
  function Zl(r, e) {
    return Math.abs(r - e) < 1e-5;
  }
  function H_(r) {
    var e = r.data, t = r.len(), n = [], i, a = 0, o = 0, s = 0, l = 0;
    function u(k, R) {
      i && i.length > 2 && n.push(i), i = [
        k,
        R
      ];
    }
    function c(k, R, N, I) {
      Zl(k, N) && Zl(R, I) || i.push(k, R, N, I, N, I);
    }
    function h(k, R, N, I, L, P) {
      var O = Math.abs(R - k), F = Math.tan(O / 4) * 4 / 3, B = R < k ? -1 : 1, V = Math.cos(k), U = Math.sin(k), Y = Math.cos(R), q = Math.sin(R), me = V * L + N, Me = U * P + I, re = Y * L + N, J = q * P + I, le = L * F * B, te = P * F * B;
      i.push(me - le * U, Me + te * V, re + le * q, J - te * Y, re, J);
    }
    for (var f, d, p, v, g = 0; g < t; ) {
      var m = e[g++], y = g === 1;
      switch (y && (a = e[g], o = e[g + 1], s = a, l = o, (m === yi.L || m === yi.C || m === yi.Q) && (i = [
        s,
        l
      ])), m) {
        case yi.M:
          a = s = e[g++], o = l = e[g++], u(s, l);
          break;
        case yi.L:
          f = e[g++], d = e[g++], c(a, o, f, d), a = f, o = d;
          break;
        case yi.C:
          i.push(e[g++], e[g++], e[g++], e[g++], a = e[g++], o = e[g++]);
          break;
        case yi.Q:
          f = e[g++], d = e[g++], p = e[g++], v = e[g++], i.push(a + 2 / 3 * (f - a), o + 2 / 3 * (d - o), p + 2 / 3 * (f - p), v + 2 / 3 * (d - v), p, v), a = p, o = v;
          break;
        case yi.A:
          var x = e[g++], _ = e[g++], S = e[g++], b = e[g++], w = e[g++], C = e[g++] + w;
          g += 1;
          var T = !e[g++];
          f = Math.cos(w) * S + x, d = Math.sin(w) * b + _, y ? (s = f, l = d, u(s, l)) : c(a, o, f, d), a = Math.cos(C) * S + x, o = Math.sin(C) * b + _;
          for (var A = (T ? -1 : 1) * Math.PI / 2, M = w; T ? M > C : M < C; M += A) {
            var E = T ? Math.max(M + A, C) : Math.min(M + A, C);
            h(M, E, x, _, S, b);
          }
          break;
        case yi.R:
          s = a = e[g++], l = o = e[g++], f = s + e[g++], d = l + e[g++], u(f, l), c(f, l, f, d), c(f, d, s, d), c(s, d, s, l), c(s, l, f, l);
          break;
        case yi.Z:
          i && c(a, o, s, l), a = s, o = l;
          break;
      }
    }
    return i && i.length > 2 && n.push(i), n;
  }
  function Y_(r, e, t, n, i, a, o, s, l, u) {
    if (Zl(r, t) && Zl(e, n) && Zl(i, o) && Zl(a, s)) {
      l.push(o, s);
      return;
    }
    var c = 2 / u, h = c * c, f = o - r, d = s - e, p = Math.sqrt(f * f + d * d);
    f /= p, d /= p;
    var v = t - r, g = n - e, m = i - o, y = a - s, x = v * v + g * g, _ = m * m + y * y;
    if (x < h && _ < h) {
      l.push(o, s);
      return;
    }
    var S = f * v + d * g, b = -f * m - d * y, w = x - S * S, C = _ - b * b;
    if (w < h && S >= 0 && C < h && b >= 0) {
      l.push(o, s);
      return;
    }
    var T = [], A = [];
    lo(r, t, i, o, 0.5, T), lo(e, n, a, s, 0.5, A), Y_(T[0], A[0], T[1], A[1], T[2], A[2], T[3], A[3], l, u), Y_(T[4], A[4], T[5], A[5], T[6], A[6], T[7], A[7], l, u);
  }
  function gse(r, e) {
    var t = H_(r), n = [];
    e = e || 1;
    for (var i = 0; i < t.length; i++) {
      var a = t[i], o = [], s = a[0], l = a[1];
      o.push(s, l);
      for (var u = 2; u < a.length; ) {
        var c = a[u++], h = a[u++], f = a[u++], d = a[u++], p = a[u++], v = a[u++];
        Y_(s, l, c, h, f, d, p, v, o, e), s = p, l = v;
      }
      n.push(o);
    }
    return n;
  }
  function xB(r, e, t) {
    var n = r[e], i = r[1 - e], a = Math.abs(n / i), o = Math.ceil(Math.sqrt(a * t)), s = Math.floor(t / o);
    s === 0 && (s = 1, o = t);
    for (var l = [], u = 0; u < o; u++) l.push(s);
    var c = o * s, h = t - c;
    if (h > 0) for (var u = 0; u < h; u++) l[u % o] += 1;
    return l;
  }
  function zD(r, e, t) {
    for (var n = r.r0, i = r.r, a = r.startAngle, o = r.endAngle, s = Math.abs(o - a), l = s * i, u = i - n, c = l > Math.abs(u), h = xB([
      l,
      u
    ], c ? 0 : 1, e), f = (c ? s : u) / h.length, d = 0; d < h.length; d++) for (var p = (c ? u : s) / h[d], v = 0; v < h[d]; v++) {
      var g = {};
      c ? (g.startAngle = a + f * d, g.endAngle = a + f * (d + 1), g.r0 = n + p * v, g.r = n + p * (v + 1)) : (g.startAngle = a + p * v, g.endAngle = a + p * (v + 1), g.r0 = n + f * d, g.r = n + f * (d + 1)), g.clockwise = r.clockwise, g.cx = r.cx, g.cy = r.cy, t.push(g);
    }
  }
  function mse(r, e, t) {
    for (var n = r.width, i = r.height, a = n > i, o = xB([
      n,
      i
    ], a ? 0 : 1, e), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", c = a ? "y" : "x", h = r[s] / o.length, f = 0; f < o.length; f++) for (var d = r[l] / o[f], p = 0; p < o[f]; p++) {
      var v = {};
      v[u] = f * h, v[c] = p * d, v[s] = h, v[l] = d, v.x += r.x, v.y += r.y, t.push(v);
    }
  }
  function VD(r, e, t, n) {
    return r * n - t * e;
  }
  function yse(r, e, t, n, i, a, o, s) {
    var l = t - r, u = n - e, c = o - i, h = s - a, f = VD(c, h, l, u);
    if (Math.abs(f) < 1e-6) return null;
    var d = r - i, p = e - a, v = VD(d, p, c, h) / f;
    return v < 0 || v > 1 ? null : new Ne(v * l + r, v * u + e);
  }
  function xse(r, e, t) {
    var n = new Ne();
    Ne.sub(n, t, e), n.normalize();
    var i = new Ne();
    Ne.sub(i, r, e);
    var a = i.dot(n);
    return a;
  }
  function Ml(r, e) {
    var t = r[r.length - 1];
    t && t[0] === e[0] && t[1] === e[1] || r.push(e);
  }
  function _se(r, e, t) {
    for (var n = r.length, i = [], a = 0; a < n; a++) {
      var o = r[a], s = r[(a + 1) % n], l = yse(o[0], o[1], s[0], s[1], e.x, e.y, t.x, t.y);
      l && i.push({
        projPt: xse(l, e, t),
        pt: l,
        idx: a
      });
    }
    if (i.length < 2) return [
      {
        points: r
      },
      {
        points: r
      }
    ];
    i.sort(function(g, m) {
      return g.projPt - m.projPt;
    });
    var u = i[0], c = i[i.length - 1];
    if (c.idx < u.idx) {
      var h = u;
      u = c, c = h;
    }
    for (var f = [
      u.pt.x,
      u.pt.y
    ], d = [
      c.pt.x,
      c.pt.y
    ], p = [
      f
    ], v = [
      d
    ], a = u.idx + 1; a <= c.idx; a++) Ml(p, r[a].slice());
    Ml(p, d), Ml(p, f);
    for (var a = c.idx + 1; a <= u.idx + n; a++) Ml(v, r[a % n].slice());
    return Ml(v, f), Ml(v, d), [
      {
        points: p
      },
      {
        points: v
      }
    ];
  }
  function $D(r) {
    var e = r.points, t = [], n = [];
    Jv(e, t, n);
    var i = new Oe(t[0], t[1], n[0] - t[0], n[1] - t[1]), a = i.width, o = i.height, s = i.x, l = i.y, u = new Ne(), c = new Ne();
    return a > o ? (u.x = c.x = s + a / 2, u.y = l, c.y = l + o) : (u.y = c.y = l + o / 2, u.x = s, c.x = s + a), _se(e, u, c);
  }
  function Cv(r, e, t, n) {
    if (t === 1) n.push(e);
    else {
      var i = Math.floor(t / 2), a = r(e);
      Cv(r, a[0], i, n), Cv(r, a[1], t - i, n);
    }
    return n;
  }
  function bse(r, e) {
    for (var t = [], n = 0; n < e; n++) t.push(d1(r));
    return t;
  }
  function Sse(r, e) {
    e.setStyle(r.style), e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel;
  }
  function wse(r) {
    for (var e = [], t = 0; t < r.length; ) e.push([
      r[t++],
      r[t++]
    ]);
    return e;
  }
  function Cse(r, e) {
    var t = [], n = r.shape, i;
    switch (r.type) {
      case "rect":
        mse(n, e, t), i = et;
        break;
      case "sector":
        zD(n, e, t), i = qr;
        break;
      case "circle":
        zD({
          r0: 0,
          r: n.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: n.cx,
          cy: n.cy
        }, e, t), i = qr;
        break;
      default:
        var a = r.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = K(gse(r.getUpdatedPathProxy(), o), function(m) {
          return wse(m);
        }), l = s.length;
        if (l === 0) Cv($D, {
          points: s[0]
        }, e, t);
        else if (l === e) for (var u = 0; u < l; u++) t.push({
          points: s[u]
        });
        else {
          var c = 0, h = K(s, function(m) {
            var y = [], x = [];
            Jv(m, y, x);
            var _ = (x[1] - y[1]) * (x[0] - y[0]);
            return c += _, {
              poly: m,
              area: _
            };
          });
          h.sort(function(m, y) {
            return y.area - m.area;
          });
          for (var f = e, u = 0; u < l; u++) {
            var d = h[u];
            if (f <= 0) break;
            var p = u === l - 1 ? f : Math.ceil(d.area / c * e);
            p < 0 || (Cv($D, {
              points: d.poly
            }, p, t), f -= p);
          }
        }
        i = Kr;
        break;
    }
    if (!i) return bse(r, e);
    for (var v = [], u = 0; u < t.length; u++) {
      var g = new i();
      g.setShape(t[u]), Sse(r, g), v.push(g);
    }
    return v;
  }
  function Tse(r, e) {
    var t = r.length, n = e.length;
    if (t === n) return [
      r,
      e
    ];
    for (var i = [], a = [], o = t < n ? r : e, s = Math.min(t, n), l = Math.abs(n - t) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, h = [
      o[0],
      o[1]
    ], f = l, d = 2; d < s; ) {
      var p = o[d - 2], v = o[d - 1], g = o[d++], m = o[d++], y = o[d++], x = o[d++], _ = o[d++], S = o[d++];
      if (f <= 0) {
        h.push(g, m, y, x, _, S);
        continue;
      }
      for (var b = Math.min(f, c - 1) + 1, w = 1; w <= b; w++) {
        var C = w / b;
        lo(p, g, y, _, C, i), lo(v, m, x, S, C, a), p = i[3], v = a[3], h.push(i[1], a[1], i[2], a[2], p, v), g = i[5], m = a[5], y = i[6], x = a[6];
      }
      f -= b - 1;
    }
    return o === r ? [
      h,
      e
    ] : [
      r,
      h
    ];
  }
  function GD(r, e) {
    for (var t = r.length, n = r[t - 2], i = r[t - 1], a = [], o = 0; o < e.length; ) a[o++] = n, a[o++] = i;
    return a;
  }
  function Ase(r, e) {
    for (var t, n, i, a = [], o = [], s = 0; s < Math.max(r.length, e.length); s++) {
      var l = r[s], u = e[s], c = void 0, h = void 0;
      l ? u ? (t = Tse(l, u), c = t[0], h = t[1], n = c, i = h) : (h = GD(i || l, l), c = l) : (c = GD(n || u, u), h = u), a.push(c), o.push(h);
    }
    return [
      a,
      o
    ];
  }
  function WD(r) {
    for (var e = 0, t = 0, n = 0, i = r.length, a = 0, o = i - 2; a < i; o = a, a += 2) {
      var s = r[o], l = r[o + 1], u = r[a], c = r[a + 1], h = s * c - u * l;
      e += h, t += (s + u) * h, n += (l + c) * h;
    }
    return e === 0 ? [
      r[0] || 0,
      r[1] || 0
    ] : [
      t / e / 3,
      n / e / 3,
      e
    ];
  }
  function Ise(r, e, t, n) {
    for (var i = (r.length - 2) / 6, a = 1 / 0, o = 0, s = r.length, l = s - 2, u = 0; u < i; u++) {
      for (var c = u * 6, h = 0, f = 0; f < s; f += 2) {
        var d = f === 0 ? c : (c + f - 2) % l + 2, p = r[d] - t[0], v = r[d + 1] - t[1], g = e[f] - n[0], m = e[f + 1] - n[1], y = g - p, x = m - v;
        h += y * y + x * x;
      }
      h < a && (a = h, o = u);
    }
    return o;
  }
  function Mse(r) {
    for (var e = [], t = r.length, n = 0; n < t; n += 2) e[n] = r[t - n - 2], e[n + 1] = r[t - n - 1];
    return e;
  }
  function Dse(r, e, t, n) {
    for (var i = [], a, o = 0; o < r.length; o++) {
      var s = r[o], l = e[o], u = WD(s), c = WD(l);
      a == null && (a = u[2] < 0 != c[2] < 0);
      var h = [], f = [], d = 0, p = 1 / 0, v = [], g = s.length;
      a && (s = Mse(s));
      for (var m = Ise(s, l, u, c) * 6, y = g - 2, x = 0; x < y; x += 2) {
        var _ = (m + x) % y + 2;
        h[x + 2] = s[_] - u[0], h[x + 3] = s[_ + 1] - u[1];
      }
      h[0] = s[m] - u[0], h[1] = s[m + 1] - u[1];
      for (var S = n / t, b = -n / 2; b <= n / 2; b += S) {
        for (var w = Math.sin(b), C = Math.cos(b), T = 0, x = 0; x < s.length; x += 2) {
          var A = h[x], M = h[x + 1], E = l[x] - c[0], k = l[x + 1] - c[1], R = E * C - k * w, N = E * w + k * C;
          v[x] = R, v[x + 1] = N;
          var I = R - A, L = N - M;
          T += I * I + L * L;
        }
        if (T < p) {
          p = T, d = b;
          for (var P = 0; P < v.length; P++) f[P] = v[P];
        }
      }
      i.push({
        from: h,
        to: f,
        fromCp: u,
        toCp: c,
        rotation: -d
      });
    }
    return i;
  }
  function Tv(r) {
    return r.__isCombineMorphing;
  }
  var _B = "__mOriginal_";
  function Av(r, e, t) {
    var n = _B + e, i = r[n] || r[e];
    r[n] || (r[n] = r[e]);
    var a = t.replace, o = t.after, s = t.before;
    r[e] = function() {
      var l = arguments, u;
      return s && s.apply(this, l), a ? u = a.apply(this, l) : u = i.apply(this, l), o && o.apply(this, l), u;
    };
  }
  function lh(r, e) {
    var t = _B + e;
    r[t] && (r[e] = r[t], r[t] = null);
  }
  function UD(r, e) {
    for (var t = 0; t < r.length; t++) for (var n = r[t], i = 0; i < n.length; ) {
      var a = n[i], o = n[i + 1];
      n[i++] = e[0] * a + e[2] * o + e[4], n[i++] = e[1] * a + e[3] * o + e[5];
    }
  }
  function bB(r, e) {
    var t = r.getUpdatedPathProxy(), n = e.getUpdatedPathProxy(), i = Ase(H_(t), H_(n)), a = i[0], o = i[1], s = r.getComputedTransform(), l = e.getComputedTransform();
    function u() {
      this.transform = null;
    }
    s && UD(a, s), l && UD(o, l), Av(e, "updateTransform", {
      replace: u
    }), e.transform = null;
    var c = Dse(a, o, 10, Math.PI), h = [];
    Av(e, "buildPath", {
      replace: function(f) {
        for (var d = e.__morphT, p = 1 - d, v = [], g = 0; g < c.length; g++) {
          var m = c[g], y = m.from, x = m.to, _ = m.rotation * d, S = m.fromCp, b = m.toCp, w = Math.sin(_), C = Math.cos(_);
          cp(v, S, b, d);
          for (var T = 0; T < y.length; T += 2) {
            var A = y[T], M = y[T + 1], E = x[T], k = x[T + 1], R = A * p + E * d, N = M * p + k * d;
            h[T] = R * C - N * w + v[0], h[T + 1] = R * w + N * C + v[1];
          }
          var I = h[0], L = h[1];
          f.moveTo(I, L);
          for (var T = 2; T < y.length; ) {
            var E = h[T++], k = h[T++], P = h[T++], O = h[T++], F = h[T++], B = h[T++];
            I === E && L === k && P === F && O === B ? f.lineTo(F, B) : f.bezierCurveTo(E, k, P, O, F, B), I = F, L = B;
          }
        }
      }
    });
  }
  function ZS(r, e, t) {
    if (!r || !e) return e;
    var n = t.done, i = t.during;
    bB(r, e), e.__morphT = 0;
    function a() {
      lh(e, "buildPath"), lh(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape();
    }
    return e.animateTo({
      __morphT: 1
    }, ye({
      during: function(o) {
        e.dirtyShape(), i && i(o);
      },
      done: function() {
        a(), n && n();
      }
    }, t)), e;
  }
  function Pse(r, e, t, n, i, a) {
    var o = 16;
    r = i === t ? 0 : Math.round(32767 * (r - t) / (i - t)), e = a === n ? 0 : Math.round(32767 * (e - n) / (a - n));
    for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
      var c = 0, h = 0;
      (r & u) > 0 && (c = 1), (e & u) > 0 && (h = 1), s += u * u * (3 * c ^ h), h === 0 && (c === 1 && (r = u - 1 - r, e = u - 1 - e), l = r, r = e, e = l);
    }
    return s;
  }
  function Iv(r) {
    var e = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0, a = K(r, function(s) {
      var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), h = l.y + l.height / 2 + (u ? u[5] : 0);
      return e = Math.min(c, e), t = Math.min(h, t), n = Math.max(c, n), i = Math.max(h, i), [
        c,
        h
      ];
    }), o = K(a, function(s, l) {
      return {
        cp: s,
        z: Pse(s[0], s[1], e, t, n, i),
        path: r[l]
      };
    });
    return o.sort(function(s, l) {
      return s.z - l.z;
    }).map(function(s) {
      return s.path;
    });
  }
  function SB(r) {
    return Cse(r.path, r.count);
  }
  function X_() {
    return {
      fromIndividuals: [],
      toIndividuals: [],
      count: 0
    };
  }
  function kse(r, e, t) {
    var n = [];
    function i(S) {
      for (var b = 0; b < S.length; b++) {
        var w = S[b];
        Tv(w) ? i(w.childrenRef()) : w instanceof Ue && n.push(w);
      }
    }
    i(r);
    var a = n.length;
    if (!a) return X_();
    var o = t.dividePath || SB, s = o({
      path: e,
      count: a
    });
    if (s.length !== a) return console.error("Invalid morphing: unmatched splitted path"), X_();
    n = Iv(n), s = Iv(s);
    for (var l = t.done, u = t.during, c = t.individualDelay, h = new ta(), f = 0; f < a; f++) {
      var d = n[f], p = s[f];
      p.parent = e, p.copyTransform(h), c || bB(d, p);
    }
    e.__isCombineMorphing = true, e.childrenRef = function() {
      return s;
    };
    function v(S) {
      for (var b = 0; b < s.length; b++) s[b].addSelfToZr(S);
    }
    Av(e, "addSelfToZr", {
      after: function(S) {
        v(S);
      }
    }), Av(e, "removeSelfFromZr", {
      after: function(S) {
        for (var b = 0; b < s.length; b++) s[b].removeSelfFromZr(S);
      }
    });
    function g() {
      e.__isCombineMorphing = false, e.__morphT = -1, e.childrenRef = null, lh(e, "addSelfToZr"), lh(e, "removeSelfFromZr");
    }
    var m = s.length;
    if (c) for (var y = m, x = function() {
      y--, y === 0 && (g(), l && l());
    }, f = 0; f < m; f++) {
      var _ = c ? ye({
        delay: (t.delay || 0) + c(f, m, n[f], s[f]),
        done: x
      }, t) : t;
      ZS(n[f], s[f], _);
    }
    else e.__morphT = 0, e.animateTo({
      __morphT: 1
    }, ye({
      during: function(S) {
        for (var b = 0; b < m; b++) {
          var w = s[b];
          w.__morphT = e.__morphT, w.dirtyShape();
        }
        u && u(S);
      },
      done: function() {
        g();
        for (var S = 0; S < r.length; S++) lh(r[S], "updateTransform");
        l && l();
      }
    }, t));
    return e.__zr && v(e.__zr), {
      fromIndividuals: n,
      toIndividuals: s,
      count: m
    };
  }
  function Lse(r, e, t) {
    var n = e.length, i = [], a = t.dividePath || SB;
    function o(d) {
      for (var p = 0; p < d.length; p++) {
        var v = d[p];
        Tv(v) ? o(v.childrenRef()) : v instanceof Ue && i.push(v);
      }
    }
    if (Tv(r)) {
      o(r.childrenRef());
      var s = i.length;
      if (s < n) for (var l = 0, u = s; u < n; u++) i.push(d1(i[l++ % s]));
      i.length = n;
    } else {
      i = a({
        path: r,
        count: n
      });
      for (var c = r.getComputedTransform(), u = 0; u < i.length; u++) i[u].setLocalTransform(c);
      if (i.length !== n) return console.error("Invalid morphing: unmatched splitted path"), X_();
    }
    i = Iv(i), e = Iv(e);
    for (var h = t.individualDelay, u = 0; u < n; u++) {
      var f = h ? ye({
        delay: (t.delay || 0) + h(u, n, i[u], e[u])
      }, t) : t;
      ZS(i[u], e[u], f);
    }
    return {
      fromIndividuals: i,
      toIndividuals: e,
      count: e.length
    };
  }
  function HD(r) {
    return X(r[0]);
  }
  function YD(r, e) {
    for (var t = [], n = r.length, i = 0; i < n; i++) t.push({
      one: r[i],
      many: []
    });
    for (var i = 0; i < e.length; i++) {
      var a = e[i].length, o = void 0;
      for (o = 0; o < a; o++) t[o % n].many.push(e[i][o]);
    }
    for (var s = 0, i = n - 1; i >= 0; i--) if (!t[i].many.length) {
      var l = t[s].many;
      if (l.length <= 1) if (s) s = 0;
      else return t;
      var a = l.length, u = Math.ceil(a / 2);
      t[i].many = l.slice(u, a), t[s].many = l.slice(0, u), s++;
    }
    return t;
  }
  var Rse = {
    clone: function(r) {
      for (var e = [], t = 1 - Math.pow(1 - r.path.style.opacity, 1 / r.count), n = 0; n < r.count; n++) {
        var i = d1(r.path);
        i.setStyle("opacity", t), e.push(i);
      }
      return e;
    },
    split: null
  };
  function f0(r, e, t, n, i, a) {
    if (!r.length || !e.length) return;
    var o = Ru("update", n, i);
    if (!(o && o.duration > 0)) return;
    var s = n.getModel("universalTransition").get("delay"), l = Object.assign({
      setToFinal: true
    }, o), u, c;
    HD(r) && (u = r, c = e), HD(e) && (u = e, c = r);
    function h(m, y, x, _, S) {
      var b = m.many, w = m.one;
      if (b.length === 1 && !S) {
        var C = y ? b[0] : w, T = y ? w : b[0];
        if (Tv(C)) h({
          many: [
            C
          ],
          one: T
        }, true, x, _, true);
        else {
          var A = s ? ye({
            delay: s(x, _)
          }, l) : l;
          ZS(C, T, A), a(C, T, C, T, A);
        }
      } else for (var M = ye({
        dividePath: Rse[t],
        individualDelay: s && function(L, P, O, F) {
          return s(L + x, _);
        }
      }, l), E = y ? kse(b, w, M) : Lse(w, b, M), k = E.fromIndividuals, R = E.toIndividuals, N = k.length, I = 0; I < N; I++) {
        var A = s ? ye({
          delay: s(I, N)
        }, l) : l;
        a(k[I], R[I], y ? b[I] : m.one, y ? m.one : b[I], A);
      }
    }
    for (var f = u ? u === r : r.length > e.length, d = u ? YD(c, u) : YD(f ? e : r, [
      f ? r : e
    ]), p = 0, v = 0; v < d.length; v++) p += d[v].many.length;
    for (var g = 0, v = 0; v < d.length; v++) h(d[v], f, g, p), g += d[v].many.length;
  }
  function is(r) {
    if (!r) return [];
    if (X(r)) {
      for (var e = [], t = 0; t < r.length; t++) e.push(is(r[t]));
      return e;
    }
    var n = [];
    return r.traverse(function(i) {
      i instanceof Ue && !i.disableMorphing && !i.invisible && !i.ignore && n.push(i);
    }), n;
  }
  var wB = 1e4, Ese = 0, XD = 1, qD = 2, Nse = tt();
  function Ose(r, e) {
    for (var t = r.dimensions, n = 0; n < t.length; n++) {
      var i = r.getDimensionInfo(t[n]);
      if (i && i.otherDims[e] === 0) return t[n];
    }
  }
  function Fse(r, e, t) {
    var n = r.getDimensionInfo(t), i = n && n.ordinalMeta;
    if (n) {
      var a = r.get(n.name, e);
      return i && i.categories[a] || a + "";
    }
  }
  function KD(r, e, t, n) {
    var i = n ? "itemChildGroupId" : "itemGroupId", a = Ose(r, i);
    if (a) {
      var o = Fse(r, e, a);
      return o;
    }
    var s = r.getRawDataItem(e), l = n ? "childGroupId" : "groupId";
    if (s && s[l]) return s[l] + "";
    if (!n) return t || r.getId(e);
  }
  function ZD(r) {
    var e = [];
    return D(r, function(t) {
      var n = t.data, i = t.dataGroupId;
      if (!(n.count() > wB)) for (var a = n.getIndices(), o = 0; o < a.length; o++) e.push({
        data: n,
        groupId: KD(n, o, i, false),
        childGroupId: KD(n, o, i, true),
        divide: t.divide,
        dataIndex: o
      });
    }), e;
  }
  function d0(r, e, t) {
    r.traverse(function(n) {
      n instanceof Ue && kt(n, {
        style: {
          opacity: 0
        }
      }, e, {
        dataIndex: t,
        isFrom: true
      });
    });
  }
  function p0(r) {
    if (r.parent) {
      var e = r.getComputedTransform();
      r.setLocalTransform(e), r.parent.remove(r);
    }
  }
  function Dl(r) {
    r.stopAnimation(), r.isGroup && r.traverse(function(e) {
      e.stopAnimation();
    });
  }
  function Bse(r, e, t) {
    var n = Ru("update", t, e);
    n && r.traverse(function(i) {
      if (i instanceof zn) {
        var a = k8(i);
        a && i.animateFrom({
          style: a
        }, n);
      }
    });
  }
  function zse(r, e) {
    var t = r.length;
    if (t !== e.length) return false;
    for (var n = 0; n < t; n++) {
      var i = r[n], a = e[n];
      if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex)) return false;
    }
    return true;
  }
  function CB(r, e, t) {
    var n = ZD(r), i = ZD(e);
    function a(x, _, S, b, w) {
      (S || x) && _.animateFrom({
        style: S && S !== x ? H(H({}, S.style), x.style) : x.style
      }, w);
    }
    var o = false, s = Ese, l = ce(), u = ce();
    n.forEach(function(x) {
      x.groupId && l.set(x.groupId, true), x.childGroupId && u.set(x.childGroupId, true);
    });
    for (var c = 0; c < i.length; c++) {
      var h = i[c].groupId;
      if (u.get(h)) {
        s = XD;
        break;
      }
      var f = i[c].childGroupId;
      if (f && l.get(f)) {
        s = qD;
        break;
      }
    }
    function d(x, _) {
      return function(S) {
        var b = S.data, w = S.dataIndex;
        return _ ? b.getId(w) : x ? s === XD ? S.childGroupId : S.groupId : s === qD ? S.childGroupId : S.groupId;
      };
    }
    var p = zse(n, i), v = {};
    if (!p) for (var c = 0; c < i.length; c++) {
      var g = i[c], m = g.data.getItemGraphicEl(g.dataIndex);
      m && (v[m.id] = true);
    }
    function y(x, _) {
      var S = n[_], b = i[x], w = b.data.hostModel, C = S.data.getItemGraphicEl(S.dataIndex), T = b.data.getItemGraphicEl(b.dataIndex);
      if (C === T) {
        T && Bse(T, b.dataIndex, w);
        return;
      }
      C && v[C.id] || T && (Dl(T), C ? (Dl(C), p0(C), o = true, f0(is(C), is(T), b.divide, w, x, a)) : d0(T, w, x));
    }
    new ya(n, i, d(true, p), d(false, p), null, "multiple").update(y).updateManyToOne(function(x, _) {
      var S = i[x], b = S.data, w = b.hostModel, C = b.getItemGraphicEl(S.dataIndex), T = ct(K(_, function(A) {
        return n[A].data.getItemGraphicEl(n[A].dataIndex);
      }), function(A) {
        return A && A !== C && !v[A.id];
      });
      C && (Dl(C), T.length ? (D(T, function(A) {
        Dl(A), p0(A);
      }), o = true, f0(is(T), is(C), S.divide, w, x, a)) : d0(C, w, S.dataIndex));
    }).updateOneToMany(function(x, _) {
      var S = n[_], b = S.data.getItemGraphicEl(S.dataIndex);
      if (!(b && v[b.id])) {
        var w = ct(K(x, function(T) {
          return i[T].data.getItemGraphicEl(i[T].dataIndex);
        }), function(T) {
          return T && T !== b;
        }), C = i[x[0]].data.hostModel;
        w.length && (D(w, function(T) {
          return Dl(T);
        }), b ? (Dl(b), p0(b), o = true, f0(is(b), is(w), S.divide, C, x[0], a)) : D(w, function(T) {
          return d0(T, C, x[0]);
        }));
      }
    }).updateManyToMany(function(x, _) {
      new ya(_, x, function(S) {
        return n[S].data.getId(n[S].dataIndex);
      }, function(S) {
        return i[S].data.getId(i[S].dataIndex);
      }).update(function(S, b) {
        y(x[S], _[b]);
      }).execute();
    }).execute(), o && D(e, function(x) {
      var _ = x.data, S = _.hostModel, b = S && t.getViewOfSeriesModel(S), w = Ru("update", S, 0);
      b && S.isAnimationEnabled() && w && w.duration > 0 && b.group.traverse(function(C) {
        C instanceof Ue && !C.animators.length && C.animateFrom({
          style: {
            opacity: 0
          }
        }, w);
      });
    });
  }
  function jD(r) {
    var e = r.getModel("universalTransition").get("seriesKey");
    return e || r.id;
  }
  function QD(r) {
    return X(r) ? r.sort().join(",") : r;
  }
  function Wa(r) {
    if (r.hostModel) return r.hostModel.getModel("universalTransition").get("divideShape");
  }
  function Vse(r, e) {
    var t = ce(), n = ce(), i = ce();
    return D(r.oldSeries, function(a, o) {
      var s = r.oldDataGroupIds[o], l = r.oldData[o], u = jD(a), c = QD(u);
      n.set(c, {
        dataGroupId: s,
        data: l
      }), X(u) && D(u, function(h) {
        i.set(h, {
          key: c,
          dataGroupId: s,
          data: l
        });
      });
    }), D(e.updatedSeries, function(a) {
      if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
        var o = a.get("dataGroupId"), s = a.getData(), l = jD(a), u = QD(l), c = n.get(u);
        if (c) t.set(u, {
          oldSeries: [
            {
              dataGroupId: c.dataGroupId,
              divide: Wa(c.data),
              data: c.data
            }
          ],
          newSeries: [
            {
              dataGroupId: o,
              divide: Wa(s),
              data: s
            }
          ]
        });
        else if (X(l)) {
          var h = [];
          D(l, function(p) {
            var v = n.get(p);
            v.data && h.push({
              dataGroupId: v.dataGroupId,
              divide: Wa(v.data),
              data: v.data
            });
          }), h.length && t.set(u, {
            oldSeries: h,
            newSeries: [
              {
                dataGroupId: o,
                data: s,
                divide: Wa(s)
              }
            ]
          });
        } else {
          var f = i.get(l);
          if (f) {
            var d = t.get(f.key);
            d || (d = {
              oldSeries: [
                {
                  dataGroupId: f.dataGroupId,
                  data: f.data,
                  divide: Wa(f.data)
                }
              ],
              newSeries: []
            }, t.set(f.key, d)), d.newSeries.push({
              dataGroupId: o,
              data: s,
              divide: Wa(s)
            });
          }
        }
      }
    }), t;
  }
  function JD(r, e) {
    for (var t = 0; t < r.length; t++) {
      var n = e.seriesIndex != null && e.seriesIndex === r[t].seriesIndex || e.seriesId != null && e.seriesId === r[t].id;
      if (n) return t;
    }
  }
  function $se(r, e, t, n) {
    var i = [], a = [];
    D(gt(r.from), function(o) {
      var s = JD(e.oldSeries, o);
      s >= 0 && i.push({
        dataGroupId: e.oldDataGroupIds[s],
        data: e.oldData[s],
        divide: Wa(e.oldData[s]),
        groupIdDim: o.dimension
      });
    }), D(gt(r.to), function(o) {
      var s = JD(t.updatedSeries, o);
      if (s >= 0) {
        var l = t.updatedSeries[s].getData();
        a.push({
          dataGroupId: e.oldDataGroupIds[s],
          data: l,
          divide: Wa(l),
          groupIdDim: o.dimension
        });
      }
    }), i.length > 0 && a.length > 0 && CB(i, a, n);
  }
  function Gse(r) {
    r.registerUpdateLifecycle("series:beforeupdate", function(e, t, n) {
      D(gt(n.seriesTransition), function(i) {
        D(gt(i.to), function(a) {
          for (var o = n.updatedSeries, s = 0; s < o.length; s++) (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][Sp] = true);
        });
      });
    }), r.registerUpdateLifecycle("series:transition", function(e, t, n) {
      var i = Nse(t);
      if (i.oldSeries && n.updatedSeries && n.optionChanged) {
        var a = n.seriesTransition;
        if (a) D(gt(a), function(d) {
          $se(d, i, n, t);
        });
        else {
          var o = Vse(i, n);
          D(o.keys(), function(d) {
            var p = o.get(d);
            CB(p.oldSeries, p.newSeries, t);
          });
        }
        D(n.updatedSeries, function(d) {
          d[Sp] && (d[Sp] = false);
        });
      }
      for (var s = e.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], h = 0; h < s.length; h++) {
        var f = s[h].getData();
        f.count() < wB && (l.push(s[h]), u.push(s[h].get("dataGroupId")), c.push(f));
      }
    });
  }
  Ve([
    Qq
  ]);
  Ve([
    Xq
  ]);
  Ve([
    yK,
    RK,
    WK,
    SZ,
    RZ,
    xj,
    Xj,
    PQ,
    QQ,
    iJ,
    dJ,
    see,
    Lee,
    Wee,
    ate,
    ute,
    xte,
    Ate,
    Fte,
    Wte,
    Jte,
    Ore
  ]);
  Ve(tne);
  Ve(Ine);
  Ve(SO);
  Ve(Vne);
  Ve(sF);
  Ve(Une);
  Ve(Jne);
  Ve(Vie);
  Ve(aae);
  Ve(Ef);
  Ve(Sae);
  Ve(Tae);
  Ve(Nae);
  Ve(Gae);
  Ve(qae);
  Ve(eoe);
  Ve(coe);
  Ve(Moe);
  Ve(cB);
  Ve(hB);
  Ve(qoe);
  Ve(gB);
  Ve(mB);
  Ve(Joe);
  Ve(fse);
  Ve(vse);
  Ve(Gse);
  Ve(dq);
  const Wse = (r) => r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var $d = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };
  const Use = ({ size: r, strokeWidth: e = 2, absoluteStrokeWidth: t, color: n, iconNode: i, name: a, class: o, ...s }, { slots: l }) => ni("svg", {
    ...$d,
    width: r || $d.width,
    height: r || $d.height,
    stroke: n || $d.stroke,
    "stroke-width": t ? Number(e) * 24 / Number(r) : e,
    class: [
      "lucide",
      `lucide-${Wse(a ?? "icon")}`
    ],
    ...s
  }, [
    ...i.map((u) => ni(...u)),
    ...l.default ? [
      l.default()
    ] : []
  ]);
  const jS = (r, e) => (t, { slots: n }) => ni(Use, {
    ...t,
    iconNode: e,
    name: r
  }, n);
  const Hse = jS("LoaderIcon", [
    [
      "path",
      {
        d: "M12 2v4",
        key: "3427ic"
      }
    ],
    [
      "path",
      {
        d: "m16.2 7.8 2.9-2.9",
        key: "r700ao"
      }
    ],
    [
      "path",
      {
        d: "M18 12h4",
        key: "wj9ykh"
      }
    ],
    [
      "path",
      {
        d: "m16.2 16.2 2.9 2.9",
        key: "1bxg5t"
      }
    ],
    [
      "path",
      {
        d: "M12 18v4",
        key: "jadmvz"
      }
    ],
    [
      "path",
      {
        d: "m4.9 19.1 2.9-2.9",
        key: "bwix9q"
      }
    ],
    [
      "path",
      {
        d: "M2 12h4",
        key: "j09sii"
      }
    ],
    [
      "path",
      {
        d: "m4.9 4.9 2.9 2.9",
        key: "giyufr"
      }
    ]
  ]);
  const Yse = jS("UploadIcon", [
    [
      "path",
      {
        d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
        key: "ih7n3h"
      }
    ],
    [
      "polyline",
      {
        points: "17 8 12 3 7 8",
        key: "t8dd8p"
      }
    ],
    [
      "line",
      {
        x1: "12",
        x2: "12",
        y1: "3",
        y2: "15",
        key: "widbto"
      }
    ]
  ]);
  const Xse = jS("XIcon", [
    [
      "path",
      {
        d: "M18 6 6 18",
        key: "1bl5f8"
      }
    ],
    [
      "path",
      {
        d: "m6 6 12 12",
        key: "d8bk6v"
      }
    ]
  ]);
  V$();
  function TB(r) {
    return typeof r > "u" || r === null;
  }
  function qse(r) {
    return typeof r == "object" && r !== null;
  }
  function Kse(r) {
    return Array.isArray(r) ? r : TB(r) ? [] : [
      r
    ];
  }
  function Zse(r, e) {
    var t, n, i, a;
    if (e) for (a = Object.keys(e), t = 0, n = a.length; t < n; t += 1) i = a[t], r[i] = e[i];
    return r;
  }
  function jse(r, e) {
    var t = "", n;
    for (n = 0; n < e; n += 1) t += r;
    return t;
  }
  function Qse(r) {
    return r === 0 && Number.NEGATIVE_INFINITY === 1 / r;
  }
  var Jse = TB, ele = qse, tle = Kse, rle = jse, nle = Qse, ile = Zse, nr = {
    isNothing: Jse,
    isObject: ele,
    toArray: tle,
    repeat: rle,
    isNegativeZero: nle,
    extend: ile
  };
  function AB(r, e) {
    var t = "", n = r.reason || "(unknown reason)";
    return r.mark ? (r.mark.name && (t += 'in "' + r.mark.name + '" '), t += "(" + (r.mark.line + 1) + ":" + (r.mark.column + 1) + ")", !e && r.mark.snippet && (t += `

` + r.mark.snippet), n + " " + t) : n;
  }
  function qh(r, e) {
    Error.call(this), this.name = "YAMLException", this.reason = r, this.mark = e, this.message = AB(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  qh.prototype = Object.create(Error.prototype);
  qh.prototype.constructor = qh;
  qh.prototype.toString = function(e) {
    return this.name + ": " + AB(this, e);
  };
  var $r = qh;
  function v0(r, e, t, n, i) {
    var a = "", o = "", s = Math.floor(i / 2) - 1;
    return n - e > s && (a = " ... ", e = n - s + a.length), t - n > s && (o = " ...", t = n + s - o.length), {
      str: a + r.slice(e, t).replace(/\t/g, "\u2192") + o,
      pos: n - e + a.length
    };
  }
  function g0(r, e) {
    return nr.repeat(" ", e - r.length) + r;
  }
  function ale(r, e) {
    if (e = Object.create(e || null), !r.buffer) return null;
    e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
    for (var t = /\r?\n|\r|\0/g, n = [
      0
    ], i = [], a, o = -1; a = t.exec(r.buffer); ) i.push(a.index), n.push(a.index + a[0].length), r.position <= a.index && o < 0 && (o = n.length - 2);
    o < 0 && (o = n.length - 1);
    var s = "", l, u, c = Math.min(r.line + e.linesAfter, i.length).toString().length, h = e.maxLength - (e.indent + c + 3);
    for (l = 1; l <= e.linesBefore && !(o - l < 0); l++) u = v0(r.buffer, n[o - l], i[o - l], r.position - (n[o] - n[o - l]), h), s = nr.repeat(" ", e.indent) + g0((r.line - l + 1).toString(), c) + " | " + u.str + `
` + s;
    for (u = v0(r.buffer, n[o], i[o], r.position, h), s += nr.repeat(" ", e.indent) + g0((r.line + 1).toString(), c) + " | " + u.str + `
`, s += nr.repeat("-", e.indent + c + 3 + u.pos) + `^
`, l = 1; l <= e.linesAfter && !(o + l >= i.length); l++) u = v0(r.buffer, n[o + l], i[o + l], r.position - (n[o] - n[o + l]), h), s += nr.repeat(" ", e.indent) + g0((r.line + l + 1).toString(), c) + " | " + u.str + `
`;
    return s.replace(/\n$/, "");
  }
  var ole = ale, sle = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], lle = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function ule(r) {
    var e = {};
    return r !== null && Object.keys(r).forEach(function(t) {
      r[t].forEach(function(n) {
        e[String(n)] = t;
      });
    }), e;
  }
  function cle(r, e) {
    if (e = e || {}, Object.keys(e).forEach(function(t) {
      if (sle.indexOf(t) === -1) throw new $r('Unknown option "' + t + '" is met in definition of "' + r + '" YAML type.');
    }), this.options = e, this.tag = r, this.kind = e.kind || null, this.resolve = e.resolve || function() {
      return true;
    }, this.construct = e.construct || function(t) {
      return t;
    }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || false, this.styleAliases = ule(e.styleAliases || null), lle.indexOf(this.kind) === -1) throw new $r('Unknown kind "' + this.kind + '" is specified for "' + r + '" YAML type.');
  }
  var _r = cle;
  function eP(r, e) {
    var t = [];
    return r[e].forEach(function(n) {
      var i = t.length;
      t.forEach(function(a, o) {
        a.tag === n.tag && a.kind === n.kind && a.multi === n.multi && (i = o);
      }), t[i] = n;
    }), t;
  }
  function hle() {
    var r = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, e, t;
    function n(i) {
      i.multi ? (r.multi[i.kind].push(i), r.multi.fallback.push(i)) : r[i.kind][i.tag] = r.fallback[i.tag] = i;
    }
    for (e = 0, t = arguments.length; e < t; e += 1) arguments[e].forEach(n);
    return r;
  }
  function q_(r) {
    return this.extend(r);
  }
  q_.prototype.extend = function(e) {
    var t = [], n = [];
    if (e instanceof _r) n.push(e);
    else if (Array.isArray(e)) n = n.concat(e);
    else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit))) e.implicit && (t = t.concat(e.implicit)), e.explicit && (n = n.concat(e.explicit));
    else throw new $r("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    t.forEach(function(a) {
      if (!(a instanceof _r)) throw new $r("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (a.loadKind && a.loadKind !== "scalar") throw new $r("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (a.multi) throw new $r("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), n.forEach(function(a) {
      if (!(a instanceof _r)) throw new $r("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var i = Object.create(q_.prototype);
    return i.implicit = (this.implicit || []).concat(t), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = eP(i, "implicit"), i.compiledExplicit = eP(i, "explicit"), i.compiledTypeMap = hle(i.compiledImplicit, i.compiledExplicit), i;
  };
  var IB = q_, MB = new _r("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(r) {
      return r !== null ? r : "";
    }
  }), DB = new _r("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(r) {
      return r !== null ? r : [];
    }
  }), PB = new _r("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(r) {
      return r !== null ? r : {};
    }
  }), kB = new IB({
    explicit: [
      MB,
      DB,
      PB
    ]
  });
  function fle(r) {
    if (r === null) return true;
    var e = r.length;
    return e === 1 && r === "~" || e === 4 && (r === "null" || r === "Null" || r === "NULL");
  }
  function dle() {
    return null;
  }
  function ple(r) {
    return r === null;
  }
  var LB = new _r("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: fle,
    construct: dle,
    predicate: ple,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function vle(r) {
    if (r === null) return false;
    var e = r.length;
    return e === 4 && (r === "true" || r === "True" || r === "TRUE") || e === 5 && (r === "false" || r === "False" || r === "FALSE");
  }
  function gle(r) {
    return r === "true" || r === "True" || r === "TRUE";
  }
  function mle(r) {
    return Object.prototype.toString.call(r) === "[object Boolean]";
  }
  var RB = new _r("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: vle,
    construct: gle,
    predicate: mle,
    represent: {
      lowercase: function(r) {
        return r ? "true" : "false";
      },
      uppercase: function(r) {
        return r ? "TRUE" : "FALSE";
      },
      camelcase: function(r) {
        return r ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function yle(r) {
    return 48 <= r && r <= 57 || 65 <= r && r <= 70 || 97 <= r && r <= 102;
  }
  function xle(r) {
    return 48 <= r && r <= 55;
  }
  function _le(r) {
    return 48 <= r && r <= 57;
  }
  function ble(r) {
    if (r === null) return false;
    var e = r.length, t = 0, n = false, i;
    if (!e) return false;
    if (i = r[t], (i === "-" || i === "+") && (i = r[++t]), i === "0") {
      if (t + 1 === e) return true;
      if (i = r[++t], i === "b") {
        for (t++; t < e; t++) if (i = r[t], i !== "_") {
          if (i !== "0" && i !== "1") return false;
          n = true;
        }
        return n && i !== "_";
      }
      if (i === "x") {
        for (t++; t < e; t++) if (i = r[t], i !== "_") {
          if (!yle(r.charCodeAt(t))) return false;
          n = true;
        }
        return n && i !== "_";
      }
      if (i === "o") {
        for (t++; t < e; t++) if (i = r[t], i !== "_") {
          if (!xle(r.charCodeAt(t))) return false;
          n = true;
        }
        return n && i !== "_";
      }
    }
    if (i === "_") return false;
    for (; t < e; t++) if (i = r[t], i !== "_") {
      if (!_le(r.charCodeAt(t))) return false;
      n = true;
    }
    return !(!n || i === "_");
  }
  function Sle(r) {
    var e = r, t = 1, n;
    if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (t = -1), e = e.slice(1), n = e[0]), e === "0") return 0;
    if (n === "0") {
      if (e[1] === "b") return t * parseInt(e.slice(2), 2);
      if (e[1] === "x") return t * parseInt(e.slice(2), 16);
      if (e[1] === "o") return t * parseInt(e.slice(2), 8);
    }
    return t * parseInt(e, 10);
  }
  function wle(r) {
    return Object.prototype.toString.call(r) === "[object Number]" && r % 1 === 0 && !nr.isNegativeZero(r);
  }
  var EB = new _r("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: ble,
    construct: Sle,
    predicate: wle,
    represent: {
      binary: function(r) {
        return r >= 0 ? "0b" + r.toString(2) : "-0b" + r.toString(2).slice(1);
      },
      octal: function(r) {
        return r >= 0 ? "0o" + r.toString(8) : "-0o" + r.toString(8).slice(1);
      },
      decimal: function(r) {
        return r.toString(10);
      },
      hexadecimal: function(r) {
        return r >= 0 ? "0x" + r.toString(16).toUpperCase() : "-0x" + r.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [
        2,
        "bin"
      ],
      octal: [
        8,
        "oct"
      ],
      decimal: [
        10,
        "dec"
      ],
      hexadecimal: [
        16,
        "hex"
      ]
    }
  }), Cle = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
  function Tle(r) {
    return !(r === null || !Cle.test(r) || r[r.length - 1] === "_");
  }
  function Ale(r) {
    var e, t;
    return e = r.replace(/_/g, "").toLowerCase(), t = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? t === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : t * parseFloat(e, 10);
  }
  var Ile = /^[-+]?[0-9]+e/;
  function Mle(r, e) {
    var t;
    if (isNaN(r)) switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
    else if (Number.POSITIVE_INFINITY === r) switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
    else if (Number.NEGATIVE_INFINITY === r) switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
    else if (nr.isNegativeZero(r)) return "-0.0";
    return t = r.toString(10), Ile.test(t) ? t.replace("e", ".e") : t;
  }
  function Dle(r) {
    return Object.prototype.toString.call(r) === "[object Number]" && (r % 1 !== 0 || nr.isNegativeZero(r));
  }
  var NB = new _r("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: Tle,
    construct: Ale,
    predicate: Dle,
    represent: Mle,
    defaultStyle: "lowercase"
  }), OB = kB.extend({
    implicit: [
      LB,
      RB,
      EB,
      NB
    ]
  }), FB = OB, BB = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), zB = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
  function Ple(r) {
    return r === null ? false : BB.exec(r) !== null || zB.exec(r) !== null;
  }
  function kle(r) {
    var e, t, n, i, a, o, s, l = 0, u = null, c, h, f;
    if (e = BB.exec(r), e === null && (e = zB.exec(r)), e === null) throw new Error("Date resolve error");
    if (t = +e[1], n = +e[2] - 1, i = +e[3], !e[4]) return new Date(Date.UTC(t, n, i));
    if (a = +e[4], o = +e[5], s = +e[6], e[7]) {
      for (l = e[7].slice(0, 3); l.length < 3; ) l += "0";
      l = +l;
    }
    return e[9] && (c = +e[10], h = +(e[11] || 0), u = (c * 60 + h) * 6e4, e[9] === "-" && (u = -u)), f = new Date(Date.UTC(t, n, i, a, o, s, l)), u && f.setTime(f.getTime() - u), f;
  }
  function Lle(r) {
    return r.toISOString();
  }
  var VB = new _r("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: Ple,
    construct: kle,
    instanceOf: Date,
    represent: Lle
  });
  function Rle(r) {
    return r === "<<" || r === null;
  }
  var $B = new _r("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: Rle
  }), QS = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function Ele(r) {
    if (r === null) return false;
    var e, t, n = 0, i = r.length, a = QS;
    for (t = 0; t < i; t++) if (e = a.indexOf(r.charAt(t)), !(e > 64)) {
      if (e < 0) return false;
      n += 6;
    }
    return n % 8 === 0;
  }
  function Nle(r) {
    var e, t, n = r.replace(/[\r\n=]/g, ""), i = n.length, a = QS, o = 0, s = [];
    for (e = 0; e < i; e++) e % 4 === 0 && e && (s.push(o >> 16 & 255), s.push(o >> 8 & 255), s.push(o & 255)), o = o << 6 | a.indexOf(n.charAt(e));
    return t = i % 4 * 6, t === 0 ? (s.push(o >> 16 & 255), s.push(o >> 8 & 255), s.push(o & 255)) : t === 18 ? (s.push(o >> 10 & 255), s.push(o >> 2 & 255)) : t === 12 && s.push(o >> 4 & 255), new Uint8Array(s);
  }
  function Ole(r) {
    var e = "", t = 0, n, i, a = r.length, o = QS;
    for (n = 0; n < a; n++) n % 3 === 0 && n && (e += o[t >> 18 & 63], e += o[t >> 12 & 63], e += o[t >> 6 & 63], e += o[t & 63]), t = (t << 8) + r[n];
    return i = a % 3, i === 0 ? (e += o[t >> 18 & 63], e += o[t >> 12 & 63], e += o[t >> 6 & 63], e += o[t & 63]) : i === 2 ? (e += o[t >> 10 & 63], e += o[t >> 4 & 63], e += o[t << 2 & 63], e += o[64]) : i === 1 && (e += o[t >> 2 & 63], e += o[t << 4 & 63], e += o[64], e += o[64]), e;
  }
  function Fle(r) {
    return Object.prototype.toString.call(r) === "[object Uint8Array]";
  }
  var GB = new _r("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: Ele,
    construct: Nle,
    predicate: Fle,
    represent: Ole
  }), Ble = Object.prototype.hasOwnProperty, zle = Object.prototype.toString;
  function Vle(r) {
    if (r === null) return true;
    var e = [], t, n, i, a, o, s = r;
    for (t = 0, n = s.length; t < n; t += 1) {
      if (i = s[t], o = false, zle.call(i) !== "[object Object]") return false;
      for (a in i) if (Ble.call(i, a)) if (!o) o = true;
      else return false;
      if (!o) return false;
      if (e.indexOf(a) === -1) e.push(a);
      else return false;
    }
    return true;
  }
  function $le(r) {
    return r !== null ? r : [];
  }
  var WB = new _r("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: Vle,
    construct: $le
  }), Gle = Object.prototype.toString;
  function Wle(r) {
    if (r === null) return true;
    var e, t, n, i, a, o = r;
    for (a = new Array(o.length), e = 0, t = o.length; e < t; e += 1) {
      if (n = o[e], Gle.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1)) return false;
      a[e] = [
        i[0],
        n[i[0]]
      ];
    }
    return true;
  }
  function Ule(r) {
    if (r === null) return [];
    var e, t, n, i, a, o = r;
    for (a = new Array(o.length), e = 0, t = o.length; e < t; e += 1) n = o[e], i = Object.keys(n), a[e] = [
      i[0],
      n[i[0]]
    ];
    return a;
  }
  var UB = new _r("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: Wle,
    construct: Ule
  }), Hle = Object.prototype.hasOwnProperty;
  function Yle(r) {
    if (r === null) return true;
    var e, t = r;
    for (e in t) if (Hle.call(t, e) && t[e] !== null) return false;
    return true;
  }
  function Xle(r) {
    return r !== null ? r : {};
  }
  var HB = new _r("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: Yle,
    construct: Xle
  }), JS = FB.extend({
    implicit: [
      VB,
      $B
    ],
    explicit: [
      GB,
      WB,
      UB,
      HB
    ]
  }), vo = Object.prototype.hasOwnProperty, Mv = 1, YB = 2, XB = 3, Dv = 4, m0 = 1, qle = 2, tP = 3, Kle = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Zle = /[\x85\u2028\u2029]/, jle = /[,\[\]\{\}]/, qB = /^(?:!|!!|![a-z\-]+!)$/i, KB = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function rP(r) {
    return Object.prototype.toString.call(r);
  }
  function Ni(r) {
    return r === 10 || r === 13;
  }
  function Ns(r) {
    return r === 9 || r === 32;
  }
  function an(r) {
    return r === 9 || r === 32 || r === 10 || r === 13;
  }
  function jl(r) {
    return r === 44 || r === 91 || r === 93 || r === 123 || r === 125;
  }
  function Qle(r) {
    var e;
    return 48 <= r && r <= 57 ? r - 48 : (e = r | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
  }
  function Jle(r) {
    return r === 120 ? 2 : r === 117 ? 4 : r === 85 ? 8 : 0;
  }
  function eue(r) {
    return 48 <= r && r <= 57 ? r - 48 : -1;
  }
  function nP(r) {
    return r === 48 ? "\0" : r === 97 ? "\x07" : r === 98 ? "\b" : r === 116 || r === 9 ? "	" : r === 110 ? `
` : r === 118 ? "\v" : r === 102 ? "\f" : r === 114 ? "\r" : r === 101 ? "\x1B" : r === 32 ? " " : r === 34 ? '"' : r === 47 ? "/" : r === 92 ? "\\" : r === 78 ? "\x85" : r === 95 ? "\xA0" : r === 76 ? "\u2028" : r === 80 ? "\u2029" : "";
  }
  function tue(r) {
    return r <= 65535 ? String.fromCharCode(r) : String.fromCharCode((r - 65536 >> 10) + 55296, (r - 65536 & 1023) + 56320);
  }
  var ZB = new Array(256), jB = new Array(256);
  for (var Pl = 0; Pl < 256; Pl++) ZB[Pl] = nP(Pl) ? 1 : 0, jB[Pl] = nP(Pl);
  function rue(r, e) {
    this.input = r, this.filename = e.filename || null, this.schema = e.schema || JS, this.onWarning = e.onWarning || null, this.legacy = e.legacy || false, this.json = e.json || false, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = r.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function QB(r, e) {
    var t = {
      name: r.filename,
      buffer: r.input.slice(0, -1),
      position: r.position,
      line: r.line,
      column: r.position - r.lineStart
    };
    return t.snippet = ole(t), new $r(e, t);
  }
  function Re(r, e) {
    throw QB(r, e);
  }
  function Pv(r, e) {
    r.onWarning && r.onWarning.call(null, QB(r, e));
  }
  var iP = {
    YAML: function(e, t, n) {
      var i, a, o;
      e.version !== null && Re(e, "duplication of %YAML directive"), n.length !== 1 && Re(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && Re(e, "ill-formed argument of the YAML directive"), a = parseInt(i[1], 10), o = parseInt(i[2], 10), a !== 1 && Re(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = o < 2, o !== 1 && o !== 2 && Pv(e, "unsupported YAML version of the document");
    },
    TAG: function(e, t, n) {
      var i, a;
      n.length !== 2 && Re(e, "TAG directive accepts exactly two arguments"), i = n[0], a = n[1], qB.test(i) || Re(e, "ill-formed tag handle (first argument) of the TAG directive"), vo.call(e.tagMap, i) && Re(e, 'there is a previously declared suffix for "' + i + '" tag handle'), KB.test(a) || Re(e, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        a = decodeURIComponent(a);
      } catch {
        Re(e, "tag prefix is malformed: " + a);
      }
      e.tagMap[i] = a;
    }
  };
  function ao(r, e, t, n) {
    var i, a, o, s;
    if (e < t) {
      if (s = r.input.slice(e, t), n) for (i = 0, a = s.length; i < a; i += 1) o = s.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || Re(r, "expected valid JSON character");
      else Kle.test(s) && Re(r, "the stream contains non-printable characters");
      r.result += s;
    }
  }
  function aP(r, e, t, n) {
    var i, a, o, s;
    for (nr.isObject(t) || Re(r, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(t), o = 0, s = i.length; o < s; o += 1) a = i[o], vo.call(e, a) || (e[a] = t[a], n[a] = true);
  }
  function Ql(r, e, t, n, i, a, o, s, l) {
    var u, c;
    if (Array.isArray(i)) for (i = Array.prototype.slice.call(i), u = 0, c = i.length; u < c; u += 1) Array.isArray(i[u]) && Re(r, "nested arrays are not supported inside keys"), typeof i == "object" && rP(i[u]) === "[object Object]" && (i[u] = "[object Object]");
    if (typeof i == "object" && rP(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), n === "tag:yaml.org,2002:merge") if (Array.isArray(a)) for (u = 0, c = a.length; u < c; u += 1) aP(r, e, a[u], t);
    else aP(r, e, a, t);
    else !r.json && !vo.call(t, i) && vo.call(e, i) && (r.line = o || r.line, r.lineStart = s || r.lineStart, r.position = l || r.position, Re(r, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: a
    }) : e[i] = a, delete t[i];
    return e;
  }
  function ew(r) {
    var e;
    e = r.input.charCodeAt(r.position), e === 10 ? r.position++ : e === 13 ? (r.position++, r.input.charCodeAt(r.position) === 10 && r.position++) : Re(r, "a line break is expected"), r.line += 1, r.lineStart = r.position, r.firstTabInLine = -1;
  }
  function Kt(r, e, t) {
    for (var n = 0, i = r.input.charCodeAt(r.position); i !== 0; ) {
      for (; Ns(i); ) i === 9 && r.firstTabInLine === -1 && (r.firstTabInLine = r.position), i = r.input.charCodeAt(++r.position);
      if (e && i === 35) do
        i = r.input.charCodeAt(++r.position);
      while (i !== 10 && i !== 13 && i !== 0);
      if (Ni(i)) for (ew(r), i = r.input.charCodeAt(r.position), n++, r.lineIndent = 0; i === 32; ) r.lineIndent++, i = r.input.charCodeAt(++r.position);
      else break;
    }
    return t !== -1 && n !== 0 && r.lineIndent < t && Pv(r, "deficient indentation"), n;
  }
  function Pg(r) {
    var e = r.position, t;
    return t = r.input.charCodeAt(e), !!((t === 45 || t === 46) && t === r.input.charCodeAt(e + 1) && t === r.input.charCodeAt(e + 2) && (e += 3, t = r.input.charCodeAt(e), t === 0 || an(t)));
  }
  function tw(r, e) {
    e === 1 ? r.result += " " : e > 1 && (r.result += nr.repeat(`
`, e - 1));
  }
  function nue(r, e, t) {
    var n, i, a, o, s, l, u, c, h = r.kind, f = r.result, d;
    if (d = r.input.charCodeAt(r.position), an(d) || jl(d) || d === 35 || d === 38 || d === 42 || d === 33 || d === 124 || d === 62 || d === 39 || d === 34 || d === 37 || d === 64 || d === 96 || (d === 63 || d === 45) && (i = r.input.charCodeAt(r.position + 1), an(i) || t && jl(i))) return false;
    for (r.kind = "scalar", r.result = "", a = o = r.position, s = false; d !== 0; ) {
      if (d === 58) {
        if (i = r.input.charCodeAt(r.position + 1), an(i) || t && jl(i)) break;
      } else if (d === 35) {
        if (n = r.input.charCodeAt(r.position - 1), an(n)) break;
      } else {
        if (r.position === r.lineStart && Pg(r) || t && jl(d)) break;
        if (Ni(d)) if (l = r.line, u = r.lineStart, c = r.lineIndent, Kt(r, false, -1), r.lineIndent >= e) {
          s = true, d = r.input.charCodeAt(r.position);
          continue;
        } else {
          r.position = o, r.line = l, r.lineStart = u, r.lineIndent = c;
          break;
        }
      }
      s && (ao(r, a, o, false), tw(r, r.line - l), a = o = r.position, s = false), Ns(d) || (o = r.position + 1), d = r.input.charCodeAt(++r.position);
    }
    return ao(r, a, o, false), r.result ? true : (r.kind = h, r.result = f, false);
  }
  function iue(r, e) {
    var t, n, i;
    if (t = r.input.charCodeAt(r.position), t !== 39) return false;
    for (r.kind = "scalar", r.result = "", r.position++, n = i = r.position; (t = r.input.charCodeAt(r.position)) !== 0; ) if (t === 39) if (ao(r, n, r.position, true), t = r.input.charCodeAt(++r.position), t === 39) n = r.position, r.position++, i = r.position;
    else return true;
    else Ni(t) ? (ao(r, n, i, true), tw(r, Kt(r, false, e)), n = i = r.position) : r.position === r.lineStart && Pg(r) ? Re(r, "unexpected end of the document within a single quoted scalar") : (r.position++, i = r.position);
    Re(r, "unexpected end of the stream within a single quoted scalar");
  }
  function aue(r, e) {
    var t, n, i, a, o, s;
    if (s = r.input.charCodeAt(r.position), s !== 34) return false;
    for (r.kind = "scalar", r.result = "", r.position++, t = n = r.position; (s = r.input.charCodeAt(r.position)) !== 0; ) {
      if (s === 34) return ao(r, t, r.position, true), r.position++, true;
      if (s === 92) {
        if (ao(r, t, r.position, true), s = r.input.charCodeAt(++r.position), Ni(s)) Kt(r, false, e);
        else if (s < 256 && ZB[s]) r.result += jB[s], r.position++;
        else if ((o = Jle(s)) > 0) {
          for (i = o, a = 0; i > 0; i--) s = r.input.charCodeAt(++r.position), (o = Qle(s)) >= 0 ? a = (a << 4) + o : Re(r, "expected hexadecimal character");
          r.result += tue(a), r.position++;
        } else Re(r, "unknown escape sequence");
        t = n = r.position;
      } else Ni(s) ? (ao(r, t, n, true), tw(r, Kt(r, false, e)), t = n = r.position) : r.position === r.lineStart && Pg(r) ? Re(r, "unexpected end of the document within a double quoted scalar") : (r.position++, n = r.position);
    }
    Re(r, "unexpected end of the stream within a double quoted scalar");
  }
  function oue(r, e) {
    var t = true, n, i, a, o = r.tag, s, l = r.anchor, u, c, h, f, d, p = /* @__PURE__ */ Object.create(null), v, g, m, y;
    if (y = r.input.charCodeAt(r.position), y === 91) c = 93, d = false, s = [];
    else if (y === 123) c = 125, d = true, s = {};
    else return false;
    for (r.anchor !== null && (r.anchorMap[r.anchor] = s), y = r.input.charCodeAt(++r.position); y !== 0; ) {
      if (Kt(r, true, e), y = r.input.charCodeAt(r.position), y === c) return r.position++, r.tag = o, r.anchor = l, r.kind = d ? "mapping" : "sequence", r.result = s, true;
      t ? y === 44 && Re(r, "expected the node content, but found ','") : Re(r, "missed comma between flow collection entries"), g = v = m = null, h = f = false, y === 63 && (u = r.input.charCodeAt(r.position + 1), an(u) && (h = f = true, r.position++, Kt(r, true, e))), n = r.line, i = r.lineStart, a = r.position, yu(r, e, Mv, false, true), g = r.tag, v = r.result, Kt(r, true, e), y = r.input.charCodeAt(r.position), (f || r.line === n) && y === 58 && (h = true, y = r.input.charCodeAt(++r.position), Kt(r, true, e), yu(r, e, Mv, false, true), m = r.result), d ? Ql(r, s, p, g, v, m, n, i, a) : h ? s.push(Ql(r, null, p, g, v, m, n, i, a)) : s.push(v), Kt(r, true, e), y = r.input.charCodeAt(r.position), y === 44 ? (t = true, y = r.input.charCodeAt(++r.position)) : t = false;
    }
    Re(r, "unexpected end of the stream within a flow collection");
  }
  function sue(r, e) {
    var t, n, i = m0, a = false, o = false, s = e, l = 0, u = false, c, h;
    if (h = r.input.charCodeAt(r.position), h === 124) n = false;
    else if (h === 62) n = true;
    else return false;
    for (r.kind = "scalar", r.result = ""; h !== 0; ) if (h = r.input.charCodeAt(++r.position), h === 43 || h === 45) m0 === i ? i = h === 43 ? tP : qle : Re(r, "repeat of a chomping mode identifier");
    else if ((c = eue(h)) >= 0) c === 0 ? Re(r, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? Re(r, "repeat of an indentation width identifier") : (s = e + c - 1, o = true);
    else break;
    if (Ns(h)) {
      do
        h = r.input.charCodeAt(++r.position);
      while (Ns(h));
      if (h === 35) do
        h = r.input.charCodeAt(++r.position);
      while (!Ni(h) && h !== 0);
    }
    for (; h !== 0; ) {
      for (ew(r), r.lineIndent = 0, h = r.input.charCodeAt(r.position); (!o || r.lineIndent < s) && h === 32; ) r.lineIndent++, h = r.input.charCodeAt(++r.position);
      if (!o && r.lineIndent > s && (s = r.lineIndent), Ni(h)) {
        l++;
        continue;
      }
      if (r.lineIndent < s) {
        i === tP ? r.result += nr.repeat(`
`, a ? 1 + l : l) : i === m0 && a && (r.result += `
`);
        break;
      }
      for (n ? Ns(h) ? (u = true, r.result += nr.repeat(`
`, a ? 1 + l : l)) : u ? (u = false, r.result += nr.repeat(`
`, l + 1)) : l === 0 ? a && (r.result += " ") : r.result += nr.repeat(`
`, l) : r.result += nr.repeat(`
`, a ? 1 + l : l), a = true, o = true, l = 0, t = r.position; !Ni(h) && h !== 0; ) h = r.input.charCodeAt(++r.position);
      ao(r, t, r.position, false);
    }
    return true;
  }
  function oP(r, e) {
    var t, n = r.tag, i = r.anchor, a = [], o, s = false, l;
    if (r.firstTabInLine !== -1) return false;
    for (r.anchor !== null && (r.anchorMap[r.anchor] = a), l = r.input.charCodeAt(r.position); l !== 0 && (r.firstTabInLine !== -1 && (r.position = r.firstTabInLine, Re(r, "tab characters must not be used in indentation")), !(l !== 45 || (o = r.input.charCodeAt(r.position + 1), !an(o)))); ) {
      if (s = true, r.position++, Kt(r, true, -1) && r.lineIndent <= e) {
        a.push(null), l = r.input.charCodeAt(r.position);
        continue;
      }
      if (t = r.line, yu(r, e, XB, false, true), a.push(r.result), Kt(r, true, -1), l = r.input.charCodeAt(r.position), (r.line === t || r.lineIndent > e) && l !== 0) Re(r, "bad indentation of a sequence entry");
      else if (r.lineIndent < e) break;
    }
    return s ? (r.tag = n, r.anchor = i, r.kind = "sequence", r.result = a, true) : false;
  }
  function lue(r, e, t) {
    var n, i, a, o, s, l, u = r.tag, c = r.anchor, h = {}, f = /* @__PURE__ */ Object.create(null), d = null, p = null, v = null, g = false, m = false, y;
    if (r.firstTabInLine !== -1) return false;
    for (r.anchor !== null && (r.anchorMap[r.anchor] = h), y = r.input.charCodeAt(r.position); y !== 0; ) {
      if (!g && r.firstTabInLine !== -1 && (r.position = r.firstTabInLine, Re(r, "tab characters must not be used in indentation")), n = r.input.charCodeAt(r.position + 1), a = r.line, (y === 63 || y === 58) && an(n)) y === 63 ? (g && (Ql(r, h, f, d, p, null, o, s, l), d = p = v = null), m = true, g = true, i = true) : g ? (g = false, i = true) : Re(r, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), r.position += 1, y = n;
      else {
        if (o = r.line, s = r.lineStart, l = r.position, !yu(r, t, YB, false, true)) break;
        if (r.line === a) {
          for (y = r.input.charCodeAt(r.position); Ns(y); ) y = r.input.charCodeAt(++r.position);
          if (y === 58) y = r.input.charCodeAt(++r.position), an(y) || Re(r, "a whitespace character is expected after the key-value separator within a block mapping"), g && (Ql(r, h, f, d, p, null, o, s, l), d = p = v = null), m = true, g = false, i = false, d = r.tag, p = r.result;
          else if (m) Re(r, "can not read an implicit mapping pair; a colon is missed");
          else return r.tag = u, r.anchor = c, true;
        } else if (m) Re(r, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else return r.tag = u, r.anchor = c, true;
      }
      if ((r.line === a || r.lineIndent > e) && (g && (o = r.line, s = r.lineStart, l = r.position), yu(r, e, Dv, true, i) && (g ? p = r.result : v = r.result), g || (Ql(r, h, f, d, p, v, o, s, l), d = p = v = null), Kt(r, true, -1), y = r.input.charCodeAt(r.position)), (r.line === a || r.lineIndent > e) && y !== 0) Re(r, "bad indentation of a mapping entry");
      else if (r.lineIndent < e) break;
    }
    return g && Ql(r, h, f, d, p, null, o, s, l), m && (r.tag = u, r.anchor = c, r.kind = "mapping", r.result = h), m;
  }
  function uue(r) {
    var e, t = false, n = false, i, a, o;
    if (o = r.input.charCodeAt(r.position), o !== 33) return false;
    if (r.tag !== null && Re(r, "duplication of a tag property"), o = r.input.charCodeAt(++r.position), o === 60 ? (t = true, o = r.input.charCodeAt(++r.position)) : o === 33 ? (n = true, i = "!!", o = r.input.charCodeAt(++r.position)) : i = "!", e = r.position, t) {
      do
        o = r.input.charCodeAt(++r.position);
      while (o !== 0 && o !== 62);
      r.position < r.length ? (a = r.input.slice(e, r.position), o = r.input.charCodeAt(++r.position)) : Re(r, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; o !== 0 && !an(o); ) o === 33 && (n ? Re(r, "tag suffix cannot contain exclamation marks") : (i = r.input.slice(e - 1, r.position + 1), qB.test(i) || Re(r, "named tag handle cannot contain such characters"), n = true, e = r.position + 1)), o = r.input.charCodeAt(++r.position);
      a = r.input.slice(e, r.position), jle.test(a) && Re(r, "tag suffix cannot contain flow indicator characters");
    }
    a && !KB.test(a) && Re(r, "tag name cannot contain such characters: " + a);
    try {
      a = decodeURIComponent(a);
    } catch {
      Re(r, "tag name is malformed: " + a);
    }
    return t ? r.tag = a : vo.call(r.tagMap, i) ? r.tag = r.tagMap[i] + a : i === "!" ? r.tag = "!" + a : i === "!!" ? r.tag = "tag:yaml.org,2002:" + a : Re(r, 'undeclared tag handle "' + i + '"'), true;
  }
  function cue(r) {
    var e, t;
    if (t = r.input.charCodeAt(r.position), t !== 38) return false;
    for (r.anchor !== null && Re(r, "duplication of an anchor property"), t = r.input.charCodeAt(++r.position), e = r.position; t !== 0 && !an(t) && !jl(t); ) t = r.input.charCodeAt(++r.position);
    return r.position === e && Re(r, "name of an anchor node must contain at least one character"), r.anchor = r.input.slice(e, r.position), true;
  }
  function hue(r) {
    var e, t, n;
    if (n = r.input.charCodeAt(r.position), n !== 42) return false;
    for (n = r.input.charCodeAt(++r.position), e = r.position; n !== 0 && !an(n) && !jl(n); ) n = r.input.charCodeAt(++r.position);
    return r.position === e && Re(r, "name of an alias node must contain at least one character"), t = r.input.slice(e, r.position), vo.call(r.anchorMap, t) || Re(r, 'unidentified alias "' + t + '"'), r.result = r.anchorMap[t], Kt(r, true, -1), true;
  }
  function yu(r, e, t, n, i) {
    var a, o, s, l = 1, u = false, c = false, h, f, d, p, v, g;
    if (r.listener !== null && r.listener("open", r), r.tag = null, r.anchor = null, r.kind = null, r.result = null, a = o = s = Dv === t || XB === t, n && Kt(r, true, -1) && (u = true, r.lineIndent > e ? l = 1 : r.lineIndent === e ? l = 0 : r.lineIndent < e && (l = -1)), l === 1) for (; uue(r) || cue(r); ) Kt(r, true, -1) ? (u = true, s = a, r.lineIndent > e ? l = 1 : r.lineIndent === e ? l = 0 : r.lineIndent < e && (l = -1)) : s = false;
    if (s && (s = u || i), (l === 1 || Dv === t) && (Mv === t || YB === t ? v = e : v = e + 1, g = r.position - r.lineStart, l === 1 ? s && (oP(r, g) || lue(r, g, v)) || oue(r, v) ? c = true : (o && sue(r, v) || iue(r, v) || aue(r, v) ? c = true : hue(r) ? (c = true, (r.tag !== null || r.anchor !== null) && Re(r, "alias node should not have any properties")) : nue(r, v, Mv === t) && (c = true, r.tag === null && (r.tag = "?")), r.anchor !== null && (r.anchorMap[r.anchor] = r.result)) : l === 0 && (c = s && oP(r, g))), r.tag === null) r.anchor !== null && (r.anchorMap[r.anchor] = r.result);
    else if (r.tag === "?") {
      for (r.result !== null && r.kind !== "scalar" && Re(r, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + r.kind + '"'), h = 0, f = r.implicitTypes.length; h < f; h += 1) if (p = r.implicitTypes[h], p.resolve(r.result)) {
        r.result = p.construct(r.result), r.tag = p.tag, r.anchor !== null && (r.anchorMap[r.anchor] = r.result);
        break;
      }
    } else if (r.tag !== "!") {
      if (vo.call(r.typeMap[r.kind || "fallback"], r.tag)) p = r.typeMap[r.kind || "fallback"][r.tag];
      else for (p = null, d = r.typeMap.multi[r.kind || "fallback"], h = 0, f = d.length; h < f; h += 1) if (r.tag.slice(0, d[h].tag.length) === d[h].tag) {
        p = d[h];
        break;
      }
      p || Re(r, "unknown tag !<" + r.tag + ">"), r.result !== null && p.kind !== r.kind && Re(r, "unacceptable node kind for !<" + r.tag + '> tag; it should be "' + p.kind + '", not "' + r.kind + '"'), p.resolve(r.result, r.tag) ? (r.result = p.construct(r.result, r.tag), r.anchor !== null && (r.anchorMap[r.anchor] = r.result)) : Re(r, "cannot resolve a node with !<" + r.tag + "> explicit tag");
    }
    return r.listener !== null && r.listener("close", r), r.tag !== null || r.anchor !== null || c;
  }
  function fue(r) {
    var e = r.position, t, n, i, a = false, o;
    for (r.version = null, r.checkLineBreaks = r.legacy, r.tagMap = /* @__PURE__ */ Object.create(null), r.anchorMap = /* @__PURE__ */ Object.create(null); (o = r.input.charCodeAt(r.position)) !== 0 && (Kt(r, true, -1), o = r.input.charCodeAt(r.position), !(r.lineIndent > 0 || o !== 37)); ) {
      for (a = true, o = r.input.charCodeAt(++r.position), t = r.position; o !== 0 && !an(o); ) o = r.input.charCodeAt(++r.position);
      for (n = r.input.slice(t, r.position), i = [], n.length < 1 && Re(r, "directive name must not be less than one character in length"); o !== 0; ) {
        for (; Ns(o); ) o = r.input.charCodeAt(++r.position);
        if (o === 35) {
          do
            o = r.input.charCodeAt(++r.position);
          while (o !== 0 && !Ni(o));
          break;
        }
        if (Ni(o)) break;
        for (t = r.position; o !== 0 && !an(o); ) o = r.input.charCodeAt(++r.position);
        i.push(r.input.slice(t, r.position));
      }
      o !== 0 && ew(r), vo.call(iP, n) ? iP[n](r, n, i) : Pv(r, 'unknown document directive "' + n + '"');
    }
    if (Kt(r, true, -1), r.lineIndent === 0 && r.input.charCodeAt(r.position) === 45 && r.input.charCodeAt(r.position + 1) === 45 && r.input.charCodeAt(r.position + 2) === 45 ? (r.position += 3, Kt(r, true, -1)) : a && Re(r, "directives end mark is expected"), yu(r, r.lineIndent - 1, Dv, false, true), Kt(r, true, -1), r.checkLineBreaks && Zle.test(r.input.slice(e, r.position)) && Pv(r, "non-ASCII line breaks are interpreted as content"), r.documents.push(r.result), r.position === r.lineStart && Pg(r)) {
      r.input.charCodeAt(r.position) === 46 && (r.position += 3, Kt(r, true, -1));
      return;
    }
    if (r.position < r.length - 1) Re(r, "end of the stream or a document separator is expected");
    else return;
  }
  function JB(r, e) {
    r = String(r), e = e || {}, r.length !== 0 && (r.charCodeAt(r.length - 1) !== 10 && r.charCodeAt(r.length - 1) !== 13 && (r += `
`), r.charCodeAt(0) === 65279 && (r = r.slice(1)));
    var t = new rue(r, e), n = r.indexOf("\0");
    for (n !== -1 && (t.position = n, Re(t, "null byte is not allowed in input")), t.input += "\0"; t.input.charCodeAt(t.position) === 32; ) t.lineIndent += 1, t.position += 1;
    for (; t.position < t.length - 1; ) fue(t);
    return t.documents;
  }
  function due(r, e, t) {
    e !== null && typeof e == "object" && typeof t > "u" && (t = e, e = null);
    var n = JB(r, t);
    if (typeof e != "function") return n;
    for (var i = 0, a = n.length; i < a; i += 1) e(n[i]);
  }
  function pue(r, e) {
    var t = JB(r, e);
    if (t.length !== 0) {
      if (t.length === 1) return t[0];
      throw new $r("expected a single document in the stream, but found more");
    }
  }
  var vue = due, gue = pue, ez = {
    loadAll: vue,
    load: gue
  }, tz = Object.prototype.toString, rz = Object.prototype.hasOwnProperty, rw = 65279, mue = 9, Kh = 10, yue = 13, xue = 32, _ue = 33, bue = 34, K_ = 35, Sue = 37, wue = 38, Cue = 39, Tue = 42, nz = 44, Aue = 45, kv = 58, Iue = 61, Mue = 62, Due = 63, Pue = 64, iz = 91, az = 93, kue = 96, oz = 123, Lue = 124, sz = 125, Er = {};
  Er[0] = "\\0";
  Er[7] = "\\a";
  Er[8] = "\\b";
  Er[9] = "\\t";
  Er[10] = "\\n";
  Er[11] = "\\v";
  Er[12] = "\\f";
  Er[13] = "\\r";
  Er[27] = "\\e";
  Er[34] = '\\"';
  Er[92] = "\\\\";
  Er[133] = "\\N";
  Er[160] = "\\_";
  Er[8232] = "\\L";
  Er[8233] = "\\P";
  var Rue = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], Eue = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function Nue(r, e) {
    var t, n, i, a, o, s, l;
    if (e === null) return {};
    for (t = {}, n = Object.keys(e), i = 0, a = n.length; i < a; i += 1) o = n[i], s = String(e[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), l = r.compiledTypeMap.fallback[o], l && rz.call(l.styleAliases, s) && (s = l.styleAliases[s]), t[o] = s;
    return t;
  }
  function Oue(r) {
    var e, t, n;
    if (e = r.toString(16).toUpperCase(), r <= 255) t = "x", n = 2;
    else if (r <= 65535) t = "u", n = 4;
    else if (r <= 4294967295) t = "U", n = 8;
    else throw new $r("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + t + nr.repeat("0", n - e.length) + e;
  }
  var Fue = 1, Zh = 2;
  function Bue(r) {
    this.schema = r.schema || JS, this.indent = Math.max(1, r.indent || 2), this.noArrayIndent = r.noArrayIndent || false, this.skipInvalid = r.skipInvalid || false, this.flowLevel = nr.isNothing(r.flowLevel) ? -1 : r.flowLevel, this.styleMap = Nue(this.schema, r.styles || null), this.sortKeys = r.sortKeys || false, this.lineWidth = r.lineWidth || 80, this.noRefs = r.noRefs || false, this.noCompatMode = r.noCompatMode || false, this.condenseFlow = r.condenseFlow || false, this.quotingType = r.quotingType === '"' ? Zh : Fue, this.forceQuotes = r.forceQuotes || false, this.replacer = typeof r.replacer == "function" ? r.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function sP(r, e) {
    for (var t = nr.repeat(" ", e), n = 0, i = -1, a = "", o, s = r.length; n < s; ) i = r.indexOf(`
`, n), i === -1 ? (o = r.slice(n), n = s) : (o = r.slice(n, i + 1), n = i + 1), o.length && o !== `
` && (a += t), a += o;
    return a;
  }
  function Z_(r, e) {
    return `
` + nr.repeat(" ", r.indent * e);
  }
  function zue(r, e) {
    var t, n, i;
    for (t = 0, n = r.implicitTypes.length; t < n; t += 1) if (i = r.implicitTypes[t], i.resolve(e)) return true;
    return false;
  }
  function Lv(r) {
    return r === xue || r === mue;
  }
  function jh(r) {
    return 32 <= r && r <= 126 || 161 <= r && r <= 55295 && r !== 8232 && r !== 8233 || 57344 <= r && r <= 65533 && r !== rw || 65536 <= r && r <= 1114111;
  }
  function lP(r) {
    return jh(r) && r !== rw && r !== yue && r !== Kh;
  }
  function uP(r, e, t) {
    var n = lP(r), i = n && !Lv(r);
    return (t ? n : n && r !== nz && r !== iz && r !== az && r !== oz && r !== sz) && r !== K_ && !(e === kv && !i) || lP(e) && !Lv(e) && r === K_ || e === kv && i;
  }
  function Vue(r) {
    return jh(r) && r !== rw && !Lv(r) && r !== Aue && r !== Due && r !== kv && r !== nz && r !== iz && r !== az && r !== oz && r !== sz && r !== K_ && r !== wue && r !== Tue && r !== _ue && r !== Lue && r !== Iue && r !== Mue && r !== Cue && r !== bue && r !== Sue && r !== Pue && r !== kue;
  }
  function $ue(r) {
    return !Lv(r) && r !== kv;
  }
  function $c(r, e) {
    var t = r.charCodeAt(e), n;
    return t >= 55296 && t <= 56319 && e + 1 < r.length && (n = r.charCodeAt(e + 1), n >= 56320 && n <= 57343) ? (t - 55296) * 1024 + n - 56320 + 65536 : t;
  }
  function lz(r) {
    var e = /^\n* /;
    return e.test(r);
  }
  var uz = 1, j_ = 2, cz = 3, hz = 4, Gl = 5;
  function Gue(r, e, t, n, i, a, o, s) {
    var l, u = 0, c = null, h = false, f = false, d = n !== -1, p = -1, v = Vue($c(r, 0)) && $ue($c(r, r.length - 1));
    if (e || o) for (l = 0; l < r.length; u >= 65536 ? l += 2 : l++) {
      if (u = $c(r, l), !jh(u)) return Gl;
      v = v && uP(u, c, s), c = u;
    }
    else {
      for (l = 0; l < r.length; u >= 65536 ? l += 2 : l++) {
        if (u = $c(r, l), u === Kh) h = true, d && (f = f || l - p - 1 > n && r[p + 1] !== " ", p = l);
        else if (!jh(u)) return Gl;
        v = v && uP(u, c, s), c = u;
      }
      f = f || d && l - p - 1 > n && r[p + 1] !== " ";
    }
    return !h && !f ? v && !o && !i(r) ? uz : a === Zh ? Gl : j_ : t > 9 && lz(r) ? Gl : o ? a === Zh ? Gl : j_ : f ? hz : cz;
  }
  function Wue(r, e, t, n, i) {
    r.dump = function() {
      if (e.length === 0) return r.quotingType === Zh ? '""' : "''";
      if (!r.noCompatMode && (Rue.indexOf(e) !== -1 || Eue.test(e))) return r.quotingType === Zh ? '"' + e + '"' : "'" + e + "'";
      var a = r.indent * Math.max(1, t), o = r.lineWidth === -1 ? -1 : Math.max(Math.min(r.lineWidth, 40), r.lineWidth - a), s = n || r.flowLevel > -1 && t >= r.flowLevel;
      function l(u) {
        return zue(r, u);
      }
      switch (Gue(e, s, r.indent, o, l, r.quotingType, r.forceQuotes && !n, i)) {
        case uz:
          return e;
        case j_:
          return "'" + e.replace(/'/g, "''") + "'";
        case cz:
          return "|" + cP(e, r.indent) + hP(sP(e, a));
        case hz:
          return ">" + cP(e, r.indent) + hP(sP(Uue(e, o), a));
        case Gl:
          return '"' + Hue(e) + '"';
        default:
          throw new $r("impossible error: invalid scalar style");
      }
    }();
  }
  function cP(r, e) {
    var t = lz(r) ? String(e) : "", n = r[r.length - 1] === `
`, i = n && (r[r.length - 2] === `
` || r === `
`), a = i ? "+" : n ? "" : "-";
    return t + a + `
`;
  }
  function hP(r) {
    return r[r.length - 1] === `
` ? r.slice(0, -1) : r;
  }
  function Uue(r, e) {
    for (var t = /(\n+)([^\n]*)/g, n = function() {
      var u = r.indexOf(`
`);
      return u = u !== -1 ? u : r.length, t.lastIndex = u, fP(r.slice(0, u), e);
    }(), i = r[0] === `
` || r[0] === " ", a, o; o = t.exec(r); ) {
      var s = o[1], l = o[2];
      a = l[0] === " ", n += s + (!i && !a && l !== "" ? `
` : "") + fP(l, e), i = a;
    }
    return n;
  }
  function fP(r, e) {
    if (r === "" || r[0] === " ") return r;
    for (var t = / [^ ]/g, n, i = 0, a, o = 0, s = 0, l = ""; n = t.exec(r); ) s = n.index, s - i > e && (a = o > i ? o : s, l += `
` + r.slice(i, a), i = a + 1), o = s;
    return l += `
`, r.length - i > e && o > i ? l += r.slice(i, o) + `
` + r.slice(o + 1) : l += r.slice(i), l.slice(1);
  }
  function Hue(r) {
    for (var e = "", t = 0, n, i = 0; i < r.length; t >= 65536 ? i += 2 : i++) t = $c(r, i), n = Er[t], !n && jh(t) ? (e += r[i], t >= 65536 && (e += r[i + 1])) : e += n || Oue(t);
    return e;
  }
  function Yue(r, e, t) {
    var n = "", i = r.tag, a, o, s;
    for (a = 0, o = t.length; a < o; a += 1) s = t[a], r.replacer && (s = r.replacer.call(t, String(a), s)), (Sa(r, e, s, false, false) || typeof s > "u" && Sa(r, e, null, false, false)) && (n !== "" && (n += "," + (r.condenseFlow ? "" : " ")), n += r.dump);
    r.tag = i, r.dump = "[" + n + "]";
  }
  function dP(r, e, t, n) {
    var i = "", a = r.tag, o, s, l;
    for (o = 0, s = t.length; o < s; o += 1) l = t[o], r.replacer && (l = r.replacer.call(t, String(o), l)), (Sa(r, e + 1, l, true, true, false, true) || typeof l > "u" && Sa(r, e + 1, null, true, true, false, true)) && ((!n || i !== "") && (i += Z_(r, e)), r.dump && Kh === r.dump.charCodeAt(0) ? i += "-" : i += "- ", i += r.dump);
    r.tag = a, r.dump = i || "[]";
  }
  function Xue(r, e, t) {
    var n = "", i = r.tag, a = Object.keys(t), o, s, l, u, c;
    for (o = 0, s = a.length; o < s; o += 1) c = "", n !== "" && (c += ", "), r.condenseFlow && (c += '"'), l = a[o], u = t[l], r.replacer && (u = r.replacer.call(t, l, u)), Sa(r, e, l, false, false) && (r.dump.length > 1024 && (c += "? "), c += r.dump + (r.condenseFlow ? '"' : "") + ":" + (r.condenseFlow ? "" : " "), Sa(r, e, u, false, false) && (c += r.dump, n += c));
    r.tag = i, r.dump = "{" + n + "}";
  }
  function que(r, e, t, n) {
    var i = "", a = r.tag, o = Object.keys(t), s, l, u, c, h, f;
    if (r.sortKeys === true) o.sort();
    else if (typeof r.sortKeys == "function") o.sort(r.sortKeys);
    else if (r.sortKeys) throw new $r("sortKeys must be a boolean or a function");
    for (s = 0, l = o.length; s < l; s += 1) f = "", (!n || i !== "") && (f += Z_(r, e)), u = o[s], c = t[u], r.replacer && (c = r.replacer.call(t, u, c)), Sa(r, e + 1, u, true, true, true) && (h = r.tag !== null && r.tag !== "?" || r.dump && r.dump.length > 1024, h && (r.dump && Kh === r.dump.charCodeAt(0) ? f += "?" : f += "? "), f += r.dump, h && (f += Z_(r, e)), Sa(r, e + 1, c, true, h) && (r.dump && Kh === r.dump.charCodeAt(0) ? f += ":" : f += ": ", f += r.dump, i += f));
    r.tag = a, r.dump = i || "{}";
  }
  function pP(r, e, t) {
    var n, i, a, o, s, l;
    for (i = t ? r.explicitTypes : r.implicitTypes, a = 0, o = i.length; a < o; a += 1) if (s = i[a], (s.instanceOf || s.predicate) && (!s.instanceOf || typeof e == "object" && e instanceof s.instanceOf) && (!s.predicate || s.predicate(e))) {
      if (t ? s.multi && s.representName ? r.tag = s.representName(e) : r.tag = s.tag : r.tag = "?", s.represent) {
        if (l = r.styleMap[s.tag] || s.defaultStyle, tz.call(s.represent) === "[object Function]") n = s.represent(e, l);
        else if (rz.call(s.represent, l)) n = s.represent[l](e, l);
        else throw new $r("!<" + s.tag + '> tag resolver accepts not "' + l + '" style');
        r.dump = n;
      }
      return true;
    }
    return false;
  }
  function Sa(r, e, t, n, i, a, o) {
    r.tag = null, r.dump = t, pP(r, t, false) || pP(r, t, true);
    var s = tz.call(r.dump), l = n, u;
    n && (n = r.flowLevel < 0 || r.flowLevel > e);
    var c = s === "[object Object]" || s === "[object Array]", h, f;
    if (c && (h = r.duplicates.indexOf(t), f = h !== -1), (r.tag !== null && r.tag !== "?" || f || r.indent !== 2 && e > 0) && (i = false), f && r.usedDuplicates[h]) r.dump = "*ref_" + h;
    else {
      if (c && f && !r.usedDuplicates[h] && (r.usedDuplicates[h] = true), s === "[object Object]") n && Object.keys(r.dump).length !== 0 ? (que(r, e, r.dump, i), f && (r.dump = "&ref_" + h + r.dump)) : (Xue(r, e, r.dump), f && (r.dump = "&ref_" + h + " " + r.dump));
      else if (s === "[object Array]") n && r.dump.length !== 0 ? (r.noArrayIndent && !o && e > 0 ? dP(r, e - 1, r.dump, i) : dP(r, e, r.dump, i), f && (r.dump = "&ref_" + h + r.dump)) : (Yue(r, e, r.dump), f && (r.dump = "&ref_" + h + " " + r.dump));
      else if (s === "[object String]") r.tag !== "?" && Wue(r, r.dump, e, a, l);
      else {
        if (s === "[object Undefined]") return false;
        if (r.skipInvalid) return false;
        throw new $r("unacceptable kind of an object to dump " + s);
      }
      r.tag !== null && r.tag !== "?" && (u = encodeURI(r.tag[0] === "!" ? r.tag.slice(1) : r.tag).replace(/!/g, "%21"), r.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", r.dump = u + " " + r.dump);
    }
    return true;
  }
  function Kue(r, e) {
    var t = [], n = [], i, a;
    for (Q_(r, t, n), i = 0, a = n.length; i < a; i += 1) e.duplicates.push(t[n[i]]);
    e.usedDuplicates = new Array(a);
  }
  function Q_(r, e, t) {
    var n, i, a;
    if (r !== null && typeof r == "object") if (i = e.indexOf(r), i !== -1) t.indexOf(i) === -1 && t.push(i);
    else if (e.push(r), Array.isArray(r)) for (i = 0, a = r.length; i < a; i += 1) Q_(r[i], e, t);
    else for (n = Object.keys(r), i = 0, a = n.length; i < a; i += 1) Q_(r[n[i]], e, t);
  }
  function Zue(r, e) {
    e = e || {};
    var t = new Bue(e);
    t.noRefs || Kue(r, t);
    var n = r;
    return t.replacer && (n = t.replacer.call({
      "": n
    }, "", n)), Sa(t, 0, n, true, true) ? t.dump + `
` : "";
  }
  var jue = Zue, Que = {
    dump: jue
  };
  function nw(r, e) {
    return function() {
      throw new Error("Function yaml." + r + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
    };
  }
  var Jue = _r, ece = IB, tce = kB, rce = OB, nce = FB, ice = JS, ace = ez.load, oce = ez.loadAll, sce = Que.dump, lce = $r, uce = {
    binary: GB,
    float: NB,
    map: PB,
    null: LB,
    pairs: UB,
    set: HB,
    timestamp: VB,
    bool: RB,
    int: EB,
    merge: $B,
    omap: WB,
    seq: DB,
    str: MB
  }, cce = nw("safeLoad", "load"), hce = nw("safeLoadAll", "loadAll"), fce = nw("safeDump", "dump"), dce = {
    Type: Jue,
    Schema: ece,
    FAILSAFE_SCHEMA: tce,
    JSON_SCHEMA: rce,
    CORE_SCHEMA: nce,
    DEFAULT_SCHEMA: ice,
    load: ace,
    loadAll: oce,
    dump: sce,
    YAMLException: lce,
    types: uce,
    safeLoad: cce,
    safeLoadAll: hce,
    safeDump: fce
  };
  const bn = rr();
  bn.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", () => 15);
  bn.registerFlag("WEBGPU_CPU_FORWARD", () => true);
  bn.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE", () => -1);
  bn.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE", () => true);
  bn.registerFlag("WEBGPU_USE_LOW_POWER_GPU", () => false);
  bn.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e3);
  bn.registerFlag("WEBGPU_USE_PROFILE_TOOL", () => false);
  bn.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE", () => true);
  bn.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG", () => false);
  bn.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL", () => -1);
  bn.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER", () => false);
  bn.registerFlag("WEBGPU_PRINT_SHADER", () => "");
  bn.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY", () => false);
  class pce {
    constructor(e) {
      e && (this.vendor = e.vendor, this.architecture = e.architecture, this.intelGPUGeneration = this.getIntelGPUGeneration());
    }
    getIntelGPUGeneration() {
      if (this.isIntel()) {
        if (this.architecture.startsWith("gen")) return Number(this.architecture.match(/\d+/));
        if (this.architecture.startsWith("xe")) return 12;
      }
      return 0;
    }
    isIntel() {
      return this.vendor === "intel";
    }
  }
  class vce {
    constructor(e) {
      this.device = e, this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
    acquireBuffer(e, t, n = false, i = true) {
      let a;
      const o = vP(e, t);
      return i ? (this.freeBuffers.has(o) || this.freeBuffers.set(o, []), this.freeBuffers.get(o).length > 0 ? (a = this.freeBuffers.get(o).pop(), this.numFreeBuffers--) : (a = this.device.createBuffer({
        size: e,
        usage: t,
        mappedAtCreation: n
      }), this.numBytesAllocated += e)) : (a = this.device.createBuffer({
        size: e,
        usage: t,
        mappedAtCreation: n
      }), this.numBytesAllocated += e), this.usedBuffers.has(o) || this.usedBuffers.set(o, []), this.usedBuffers.get(o).push(a), this.numUsedBuffers++, this.numBytesUsed += e, a;
    }
    releaseBuffer(e, t = true) {
      if (this.freeBuffers.size === 0) return;
      const n = e.size, i = e.usage, a = vP(n, i), o = this.usedBuffers.get(a), s = o.indexOf(e);
      if (s < 0) throw new Error("Cannot find the buffer in buffer manager");
      o[s] = o[o.length - 1], o.pop(), this.numUsedBuffers--, this.numBytesUsed -= n, t ? (this.freeBuffers.get(a).push(e), this.numFreeBuffers++) : (e.destroy(), this.numBytesAllocated -= n);
    }
    getNumUsedBuffers() {
      return this.numUsedBuffers;
    }
    getNumFreeBuffers() {
      return this.numFreeBuffers;
    }
    dispose() {
      this.freeBuffers.forEach((e, t) => {
        e.forEach((n) => {
          n.destroy();
        });
      }), this.usedBuffers.forEach((e, t) => {
        e.forEach((n) => {
          n.destroy();
        });
      }), this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
  }
  function vP(r, e) {
    return `${r}_${e}`;
  }
  class gce {
    constructor(e) {
      this.device = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
    acquireTexture(e, t, n, i) {
      const a = mP(n), o = e * t * a, s = gP(e, t, n, i);
      if (this.freeTextures.has(s) || this.freeTextures.set(s, []), this.usedTextures.has(s) || this.usedTextures.set(s, []), this.numBytesUsed += o, this.numUsedTextures++, this.freeTextures.get(s).length > 0) {
        this.numFreeTextures--;
        const u = this.freeTextures.get(s).shift();
        return this.usedTextures.get(s).push(u), u;
      }
      this.numBytesAllocated += o;
      const l = this.device.createTexture({
        size: [
          e,
          t
        ],
        format: n,
        usage: i
      });
      return this.usedTextures.get(s).push(l), l;
    }
    releaseTexture(e) {
      if (this.freeTextures.size === 0) return;
      const t = e.width, n = e.height, i = e.format, a = e.usage, o = gP(t, n, i, a);
      this.freeTextures.has(o) || this.freeTextures.set(o, []), this.freeTextures.get(o).push(e), this.numFreeTextures++, this.numUsedTextures--;
      const s = this.usedTextures.get(o), l = s.indexOf(e);
      if (l < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      s.splice(l, 1);
      const u = mP(i), c = t * n * u;
      this.numBytesUsed -= c;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      this.freeTextures.forEach((e, t) => {
        e.forEach((n) => {
          n.destroy();
        });
      }), this.usedTextures.forEach((e, t) => {
        e.forEach((n) => {
          n.destroy();
        });
      }), this.freeTextures = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Map(), this.numUsedTextures = 0, this.numFreeTextures = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
  }
  function gP(r, e, t, n) {
    return `${r}_${e}_${t}_${n}`;
  }
  function mP(r) {
    if (r === "rgba8unorm") return 16;
    throw new Error(`${r} is not supported!`);
  }
  function mce(r, e) {
    if (Math.max(...r) > 5) throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");
    const t = r.length, n = "xyzwuv", i = r.map((o) => `${e}.${n[o]}`), a = new Array(t - 1);
    a[t - 2] = i[t - 1];
    for (let o = t - 3; o >= 0; --o) a[o] = `(${a[o + 1]} * ${i[o + 1]})`;
    return a;
  }
  const xo = (r, e, t) => t === "int32" ? `atomicAdd(${r}, bitcast<i32>(${e}));` : `
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${r}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;
  var xu;
  (function(r) {
    r[r.FROM_PIXELS = 0] = "FROM_PIXELS", r[r.DRAW = 1] = "DRAW";
  })(xu || (xu = {}));
  const yce = (r, e, t, n, i) => {
    const a = {
      dtype: n.dtype,
      shape: n.shape
    }, o = _ce(t, a, e), s = r.createShaderModule({
      code: o,
      label: e.constructor.name
    });
    let l = rr().get("WEBGPU_PRINT_SHADER");
    if (l !== "") {
      l = l.toLowerCase();
      const u = l.split(",");
      (l === "all" || u.some((c) => e.shaderKey.toLowerCase().includes(c))) && (console.group(e.shaderKey), console.debug(o), console.groupEnd());
    }
    return i ? r.createComputePipelineAsync({
      compute: {
        module: s,
        entryPoint: "_start"
      },
      label: e.constructor.name,
      layout: "auto"
    }) : r.createComputePipeline({
      compute: {
        module: s,
        entryPoint: "_start"
      },
      label: e.constructor.name,
      layout: "auto"
    });
  }, Je = (r, e = "f32") => {
    switch (r) {
      case 1:
        return `${e}`;
      case 2:
        return `vec2<${e}>`;
      case 3:
        return `vec3<${e}>`;
      case 4:
        return `vec4<${e}>`;
      default:
        throw new Error(`${r}-component ${e} is not supported.`);
    }
  };
  function Gt(r) {
    if (r <= 1) return "i32";
    if (r === 2) return "vec2<i32>";
    if (r === 3) return "vec3<i32>";
    if (r === 4) return "vec4<i32>";
    if (r === 5) return "vec5";
    if (r === 6) return "vec6";
    throw Error(`GPU for rank ${r} is not yet supported`);
  }
  function ha(r) {
    if (r === 0) return "x";
    if (r === 1) return "y";
    if (r === 2) return "z";
    if (r === 3) return "w";
    if (r === 4) return "u";
    if (r === 5) return "v";
    throw Error(`Index ${r} is not yet supported`);
  }
  function se(...r) {
    let e;
    switch (r.length) {
      case 0:
        e = `
        fn main()
      `;
        break;
      case 1:
        e = `
        fn main(${r[0]} : i32)
      `;
        break;
      default:
        throw Error("Unreachable");
    }
    return e;
  }
  function yP(r, e) {
    let t;
    return t = `
     ${xce(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${r ? "main(getGlobalIndex());" : "main();"};
      }
    `, t;
  }
  function xce(r) {
    return `
  @compute @workgroup_size(${r.workgroupSize[0]}, ${r.workgroupSize[1]}, ${r.workgroupSize[2]})
`;
  }
  function _ce(r, e, t) {
    const n = [], i = t.workgroupSize[0] * t.workgroupSize[1] * t.workgroupSize[2];
    if (t.outputComponent = t.outputComponent ? t.outputComponent : 1, n.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${fz(t) ? "  return i32(globalId.x);" : `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +
                localIndex);
        `}
      }
    `), t.pixelsOpType != null) {
      const p = t.pixelsOpType === xu.FROM_PIXELS ? `@group(0) @binding(0) var<storage, read_write> result: array<${ps(e.dtype, t.outputComponent)}>;` : `@group(0) @binding(1) var<storage, read> inBuf : array<${ps(r[0].dtype, t.outputComponent)}>;`, v = e.shape.length === 3 ? "vec2<i32>" : "i32";
      n.push(`
        struct Uniform {
          outShapeStrides : ${v},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${p}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);
      const g = _P(t);
      return [
        xP,
        n.join(`
`),
        Pp(e.shape),
        t.getUserCode(),
        yP(g, t)
      ].join(`
`);
    }
    let a, o, s = "struct Uniforms { NAN : f32, INFINITY : f32, ";
    t.variableNames.forEach((p, v) => {
      const g = Gt(r[v].shape.length);
      s += `${p.charAt(0).toLowerCase() + p.slice(1)}Shape : ${g}, `, a = r[v].shape.length - 1, o = Gt(a), s += `${p.charAt(0).toLowerCase() + p.slice(1)}ShapeStrides: ${o}, `;
    });
    const l = Gt(e.shape.length);
    s += `outShape : ${l}, `, a = e.shape.length - 1, o = Gt(a), s += `
         outShapeStrides: ${o}, `, t.size && (s += "size : i32, "), t.uniforms && (s += t.uniforms), s += "};", s = Dce(s), n.push(s), t.atomic ? n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `) : n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${ps(e.dtype, t.outputComponent)}>;
    `), t.variableNames.forEach((p, v) => {
      n.push(`
      @group(0) @binding(${1 + v}) var<storage, read> ${p}: array<${t.variableComponents ? ps(r[v].dtype, t.variableComponents[v]) : ps(r[v].dtype, t.outputComponent)}>;
        `);
    }), s !== "" && n.push(`
      @group(0) @binding(${1 + t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);
    const u = Ace(e.shape, t.dispatchLayout), c = [
      xP,
      n.join(`
`) + Sce,
      Pp(e.shape),
      u,
      Ice(e.shape.length)
    ];
    t.atomic || c.push(Mce(e.shape, e.dtype, t.outputComponent)), t.variableNames.forEach((p, v) => {
      c.push(`${Pp(r[v].shape, p)}`);
    });
    const h = r.map((p, v) => Tce(p, e.shape, t.variableComponents ? t.variableComponents[v] : t.outputComponent, t.dispatchLayout.x.length === e.shape.length)).join(`
`);
    c.push(h), c.push(t.getUserCode());
    const f = _P(t);
    return c.push(yP(f, t)), c.join(`
`);
  }
  function bce(r, e, t) {
    let n = r.shaderKey;
    if (r.pixelsOpType != null) return n;
    const i = [], a = [];
    e.forEach((c) => {
      i.push(c.shape), a.push(c.dtype);
    }), i.push(t.shape), a.push(t.dtype);
    const o = e.map((c) => PL(c.shape, t.shape)), s = e.map((c) => Au(c.shape, t.shape)).join("_"), l = o.map((c) => c.join("_")).join(";"), u = fz(r) ? "flatDispatch" : "";
    return n += "_" + (r.workgroupSize ? r.workgroupSize.join(",") : "") + i.map((c) => c.length).join(",") + a.join(",") + r.variableNames.join(",") + l + s + u, n;
  }
  const xP = `
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`, Sce = `
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;
  function Pp(r, e = "") {
    const t = r.length, n = e !== "" ? `get${e.charAt(0).toUpperCase() + e.slice(1)}CoordsFromIndex` : "getCoordsFromIndex", i = e !== "" ? `${e.charAt(0).toLowerCase() + e.slice(1)}ShapeStrides` : "outShapeStrides";
    if (t <= 1) return `fn ${n}(index : i32) -> i32 { return index; }`;
    const a = ph(r), o = Gt(t), s = [];
    for (let u = 0; u < t; u++) s.push(`d${u}`);
    if (a.length === 1) return `    fn ${n}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`;
    let l;
    return l = "var index2 = index;" + a.map((u, c) => {
      const h = `let ${s[c]} = index2 / uniforms.${i}.${ha(c)}`, f = c === a.length - 1 ? `let ${s[c + 1]} = index2 - ${s[c]} * uniforms.${i}.${ha(c)}` : `index2 = index2 - ${s[c]} * uniforms.${i}.${ha(c)}`;
      return `${h}; ${f};`;
    }).join(""), `
    fn ${n}(index : i32) -> ${o} {
      ${l}
      return ${o}(${s.join(",")});
    }
  `;
  }
  function wce(r, e) {
    const t = r.name, n = r.shape.length, i = Gt(n), a = "get" + t.charAt(0).toUpperCase() + t.slice(1), o = [
      "d0",
      "d1",
      "d2",
      "d3",
      "d4",
      "d5"
    ].slice(0, n), s = o.map((c) => `${c} : i32`).join(", ");
    if (n < 1) return `
      fn ${a}() -> ${Je(e)} {
        return ${Je(e)}(${t}[0]);
      }
    `;
    const l = `uniforms.${t.charAt(0).toLowerCase() + t.slice(1)}Shape`;
    let u = `${n}D`;
    return n === 0 && (u = "1D"), `
    fn ${a}(${s}) -> ${Je(e)} {
      return ${Je(e)}(${t}[getIndexFromCoords${u}(${i}(${o.join(",")}),
        ${l})${e === 1 ? "" : ` / ${e}`}]);
    }
   `;
  }
  function Cce(r, e, t, n) {
    const i = r.name, a = i.charAt(0).toUpperCase() + i.slice(1), o = "get" + a + "ByOutput", s = r.shape.length, l = e.length, u = Gt(l);
    if (Au(r.shape, e) && n) return `
    fn ${o}Index(globalIndex : i32) -> ${Je(t)} {
      return ${Je(t)}(${i}[globalIndex]);
    }

    fn ${o}Coords(coords : ${u}) -> ${Je(t)} {
      return ${Je(t)}(${i}[${l > 1 ? "getOutputIndexFromCoords(coords)" : "coords"}${t === 1 ? "" : ` / ${t}`}]);
    }
    `;
    const c = PL(r.shape, e), h = l - s;
    let f = "";
    if (s === 0) return `
    fn ${o}Index(globalIndex : i32) -> ${Je(t)}{
      return get${a}();
    }

    fn ${o}Coords(coords : ${u}) -> ${Je(t)}{
      return get${a}();
    }
  `;
    l < 2 && c.length >= 1 ? f = "coords = 0;" : f = c.map((g) => `coords.${ha(g + h)} = 0;`).join(`
`);
    let d = "";
    if (l < 2 && s > 0) d = "coords";
    else if (l > 1) {
      const g = Gt(s), m = r.shape.map((y, x) => `coords.${ha(x + h)}`).join(", ");
      d = `${g}(${m})`;
    } else d = "coords";
    const p = `uniforms.${i.charAt(0).toLowerCase() + i.slice(1)}Shape`, v = `${s}D`;
    return `
  fn ${o}Index(globalIndex : i32) -> ${Je(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${f}
    return ${Je(t)}(${i}[getIndexFromCoords${v}(${d}, ${p})${t === 1 ? "" : ` / ${t}`}]);
  }

  fn ${o}Coords(coordsIn : ${u}) -> ${Je(t)} {
    var coords = coordsIn;
    ${f}
    return ${Je(t)}(${i}[getIndexFromCoords${v}(${d}, ${p})${t === 1 ? "" : ` / ${t}`}]);
  }
`;
  }
  function Tce(r, e, t, n) {
    let i = wce(r, t);
    return r.shape.length <= e.length && (i += Cce(r, e, t, n)), i;
  }
  function Ace(r, e) {
    const { x: t, y: n = [], z: i = [] } = e, a = r.length, o = t.length + n.length + i.length;
    if (o !== a) return "";
    if (t.length === a) return `fn getOutputCoords() -> ${Gt(a)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;
    let s = "";
    const l = [
      t,
      n,
      i
    ];
    for (let f = 0; f < l.length; f++) {
      const d = l[f];
      if (d.length !== 0) if (d.length === 1) s += `let d${d[0]} = i32(globalId[${f}]);`;
      else {
        const p = mce(d, "uniforms.outShape");
        s += `var index${f} = i32(globalId[${f}]);`;
        for (let v = 0; v < p.length; v++) s += `let d${d[v]} = index${f} / ${p[v]};`, v === p.length - 1 ? s += `let d${d[v + 1]} = index${f} - d${d[v]} * ${p[v]};` : s += `index${f} = index${f} - d${d[v]} * ${p[v]};`;
      }
    }
    const u = [];
    for (let f = 0; f < o; f++) u.push(`d${f}`);
    const c = Gt(o);
    let h = `fn getOutputCoords() -> ${c} {
  ${s}
`;
    return u.length === 0 ? h += `return ${c}(0); }` : h += `return ${c}(${u.join(",")}); }`, h;
  }
  function Ice(r) {
    let e = "";
    switch (r) {
      case 0:
      case 1:
        e += `
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;
        break;
      case 2:
        e += `
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;
        break;
      case 3:
        e += `
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;
        break;
      case 4:
        e += `
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;
        break;
      case 5:
        e += `
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;
        break;
      case 6:
        e += `
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;
        break;
      default:
        Mt(false, () => `Unsupported ${r}D shape`);
        break;
    }
    return e;
  }
  function fz(r) {
    return r.dispatch[1] === 1 && r.dispatch[2] === 1;
  }
  function ps(r, e = 1) {
    if (r === "float32") return Je(e, "f32");
    if (r === "int32" || r === "bool") return Je(e, "i32");
    throw new Error(`type ${r} is not supported.`);
  }
  function Mce(r, e, t) {
    const n = r.length, i = ps(e, t);
    let a = `fn setOutputAtIndex(flatIndex : i32, value : ${Je(t)}) {
      result[flatIndex] = ${i}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Je(t, "i32")}) {
      result[flatIndex] = ${i}(value);
    }
    `;
    if (n >= 2) {
      const o = [
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5"
      ].slice(0, n), s = Gt(n);
      a += `
      fn setOutputAtCoords(${o.map((l) => `${l} : i32`).join(", ")}, value : ${Je(t)}) {
        let flatIndex = getOutputIndexFromCoords(${s}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${t === 1 ? "" : ` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map((l) => `${l} : i32`).join(", ")}, value : ${Je(t, "i32")}) {
        let flatIndex = getOutputIndexFromCoords(${s}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${t === 1 ? "" : ` / ${t}`}, value);
      }
    `;
    }
    return a;
  }
  function Dce(r) {
    const e = /(\w+)\s*:\s*vec(5|6)/g;
    r = r.replace(e, (n) => "@align(16) " + n);
    const t = /vec(5|6)\s*,\s*(\w+)/g;
    return r = r.replace(t, (n, i, a) => `vec${i}, @align(16) ${a}`), r;
  }
  function _P(r) {
    return !(r.dispatchLayout.hasOwnProperty("y") && r.dispatchLayout.y.length !== 0 || r.dispatchLayout.hasOwnProperty("z") && r.dispatchLayout.z.length !== 0);
  }
  const Os = (r) => {
    let e = 1;
    for (let t = 0; t < r.length; t++) e *= r[t];
    return e;
  };
  function ue(r, e, t = [
    1,
    1,
    1
  ], n = [
    1,
    1,
    1
  ]) {
    const [i, a, o] = [
      Math.ceil(Os(r.x.map((s) => e[s])) / (t[0] * n[0])),
      r.y ? Math.ceil(Os(r.y.map((s) => e[s])) / (t[1] * n[1])) : 1,
      r.z ? Math.ceil(Os(r.z.map((s) => e[s])) / (t[2] * n[2])) : 1
    ];
    return [
      i,
      a,
      o
    ];
  }
  function Pce(r, e, t, n = false) {
    const i = [
      8,
      8,
      1
    ], a = [
      4,
      4,
      1
    ];
    return n || (r <= 8 && (a[1] = 1), e <= 16 && t <= 16 && (i[0] = 4)), {
      workgroupSize: i,
      elementsPerThread: a
    };
  }
  function dz(r, e, t = false) {
    if (t) return [
      8,
      8,
      1
    ];
    const n = Os(r.x.map((a) => e[a])), i = Os(r.y.map((a) => e[a]));
    return n <= 4 ? [
      4,
      16,
      1
    ] : i <= 4 ? [
      16,
      4,
      1
    ] : [
      16,
      16,
      1
    ];
  }
  function pz(r, e, t = false) {
    if (t) return [
      4,
      4,
      1
    ];
    const n = Os(r.x.map((a) => e[a])), i = Os(r.y.map((a) => e[a]));
    return n <= 4 ? [
      1,
      2,
      1
    ] : i <= 4 ? [
      2,
      1,
      1
    ] : [
      2,
      2,
      1
    ];
  }
  function de(r) {
    return {
      x: r.map((e, t) => t)
    };
  }
  function bP(r) {
    if (r === "float32" || r === "int32" || r === "bool" || r === "string") return 4;
    if (r === "complex64") return 8;
    throw new Error(`Unknown dtype ${r}`);
  }
  function vz() {
    return !!(typeof globalThis < "u" && globalThis.navigator && globalThis.navigator.gpu);
  }
  function gz(r, e) {
    Array.isArray(r) || (r = [
      r
    ]), r.forEach((t) => {
      t != null && Mt(t.dtype !== "complex64", () => `${e} does not support complex64 tensors in the WebGPU backend.`);
    });
  }
  var Ci;
  (function(r) {
    r[r.MatMulReduceProgram = 0] = "MatMulReduceProgram", r[r.MatMulSplitKProgram = 1] = "MatMulSplitKProgram", r[r.MatMulSmallOutputSizeProgram = 2] = "MatMulSmallOutputSizeProgram", r[r.MatMulPackedProgram = 3] = "MatMulPackedProgram", r[r.MatMulMax = 4] = "MatMulMax";
  })(Ci || (Ci = {}));
  const kce = rr().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"), Lce = (r, e) => {
    const t = r.limits.maxComputeWorkgroupsPerDimension, n = e.dispatchLayout, i = e.dispatch;
    if (i.every((o) => o <= t)) return i;
    Mt(i[0] > t && n.y === void 0 && n.z === void 0, () => "Dispatch size exceeds WebGPU limits in Y or Z dimension.");
    let a = Math.ceil(Math.sqrt(i[0]));
    return a > t ? (a = Math.ceil(Math.cbrt(i[0])), Mt(a <= t, () => "Total dispatch size exceeds WebGPU maximum."), [
      a,
      a,
      a
    ]) : [
      a,
      a,
      1
    ];
  };
  class kg extends $$ {
    nextDataId() {
      return kg.nextDataId++;
    }
    constructor(e, t) {
      if (super(), this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.dispatchCountInPass = 0, this.disposed = false, this.downloadWaitMs = 0, this.tensorDataPendingDisposal = [], this.queryResolveBuffer = null, this.querySet = null, this.querySetCount = 2, this.stagingPendingDisposal = [], this.uniformPendingDisposal = [], this.uploadWaitMs = 0, this.hasReadSyncWarned = false, this.hasTimestampQueryWarned = false, !vz()) throw new Error("WebGPU is not supported on this device");
      this.pipelineCache = {}, this.device = e, this.queue = e.queue, this.commandEncoder = null, this.computePassEncoder = null, this.adapterInfo = new pce(t), this.supportTimestampQuery = this.device.features.has("timestamp-query"), this.thresholdToIncreaseWorkgroups = this.adapterInfo.intelGPUGeneration >= 12 ? 16 : 8, this.bufferManager = new vce(this.device), this.textureManager = new gce(this.device), this.tensorMap = new G$(this, Wg()), rr().getBool("WEBGPU_USE_PROFILE_TOOL") && (this.dummyCanvas = document.createElement("canvas"), this.dummyCanvas.width = 1, this.dummyCanvas.height = 1, this.dummyContext = this.dummyCanvas.getContext("webgpu"), this.dummyContext.configure({
        device: e,
        format: "bgra8unorm"
      }), document.body.appendChild(this.dummyCanvas));
    }
    floatPrecision() {
      return 32;
    }
    disposeData(e, t = false) {
      if (!this.tensorMap.has(e)) return true;
      const n = this.tensorMap.get(e);
      return t ? n.refCount = 0 : n.refCount--, n.refCount > 0 ? false : (n.complexTensorInfos != null && (this.disposeData(n.complexTensorInfos.real.dataId), this.disposeData(n.complexTensorInfos.imag.dataId)), this.commandQueueOwnedIds.has(e) ? (this.tensorDataPendingDisposal.push(e), true) : (this.releaseResource(e), this.tensorMap.delete(e), true));
    }
    memory() {
      return {
        numBytesInGPU: this.bufferManager.numBytesUsed,
        numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated,
        unreliable: false
      };
    }
    releaseResource(e) {
      const t = this.tensorMap.get(e);
      if (!(!t || !t.resource)) {
        if (t.external) {
          t.resource = null;
          return;
        }
        t.resource instanceof GPUBuffer ? this.bufferManager.releaseBuffer(t.resource) : t.resource instanceof GPUTexture && this.textureManager.releaseTexture(t.resource), t.resource = null;
      }
    }
    refCount(e) {
      return this.tensorMap.has(e) ? this.tensorMap.get(e).refCount : 0;
    }
    incRef(e) {
      const t = this.tensorMap.get(e);
      t.refCount++;
    }
    decRef(e) {
      if (this.tensorMap.has(e)) {
        const t = this.tensorMap.get(e);
        t.refCount--;
      }
    }
    write(e, t, n) {
      if (n === "complex64" && e != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      const i = {
        id: this.nextDataId()
      };
      return this.tensorMap.set(i, {
        dtype: n,
        shape: t,
        values: e,
        refCount: 1
      }), i;
    }
    move(e, t, n, i, a) {
      if (i === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.tensorMap.set(e, {
        dtype: i,
        shape: n,
        values: t,
        refCount: a
      });
    }
    submitQueue() {
      this.queue.submit([
        this.commandEncoder.finish()
      ]), this.commandEncoder = null, this.dispatchCountInPass = 0, this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.tensorDataPendingDisposal.forEach((e) => {
        this.releaseResource(e), this.tensorMap.delete(e);
      }), this.uniformPendingDisposal.forEach((e) => this.bufferManager.releaseBuffer(e)), this.stagingPendingDisposal.forEach((e) => this.bufferManager.releaseBuffer(e, false)), this.tensorDataPendingDisposal = [], this.uniformPendingDisposal = [], this.stagingPendingDisposal = [];
    }
    ensureCommandEncoderReady() {
      this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder());
    }
    endComputePassEncoder() {
      this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);
    }
    async checkCompileCompletionAsync() {
      let e;
      try {
        e = await Promise.all(Object.values(this.pipelineCache));
      } catch (t) {
        throw new Error(t.message);
      }
      Object.keys(this.pipelineCache).map((t, n) => {
        this.pipelineCache[t] = e[n];
      });
    }
    async getBufferData(e) {
      if (rr().getBool("WEBGPU_ENGINE_COMPILE_ONLY")) return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"), null;
      const t = e.size, n = this.bufferManager.acquireBuffer(t, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
      this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e, 0, n, 0, t), this.submitQueue(), await n.mapAsync(GPUMapMode.READ);
      const i = n.getMappedRange().slice(0);
      return n.unmap(), n != null && this.bufferManager.releaseBuffer(n), rr().getBool("WEBGPU_USE_PROFILE_TOOL") && (Mt(this.dummyContext !== void 0, () => "Fail to get context for profiling tool"), this.dummyContext.getCurrentTexture()), i;
    }
    convertAndCacheOnCPU(e, t) {
      const n = this.tensorMap.get(e);
      return n.values = t, n.values;
    }
    readSync(e) {
      const t = this.tensorMap.get(e), { values: n, complexTensorInfos: i } = t;
      if (n != null || t.dtype === "string") return n;
      if (t.dtype === "complex64") {
        const v = this.readSync(i.real.dataId), g = this.readSync(i.imag.dataId), m = Ug(Yw(v, g).buffer, "float32");
        return this.convertAndCacheOnCPU(e, m), m;
      }
      this.hasReadSyncWarned || (this.hasReadSyncWarned = true, console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));
      const a = [
        "opaque",
        "premultiplied"
      ], o = t.resource, s = o.size;
      Mt(s % 4 === 0, () => "Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");
      const l = s / 4, u = new ArrayBuffer(s), c = 256, h = 256, f = a.map((v) => new OffscreenCanvas(c, h)), d = new OffscreenCanvas(c, h);
      this.endComputePassEncoder(), f.map((v, g) => {
        const m = v.getContext("webgpu");
        return m.configure({
          device: this.device,
          format: "bgra8unorm",
          usage: GPUTextureUsage.COPY_DST,
          alphaMode: a[g]
        }), m.getCurrentTexture();
      }).map((v, g) => {
        const m = c * 4, y = (C, T, A) => {
          this.ensureCommandEncoderReady(), this.commandEncoder.copyBufferToTexture({
            buffer: o,
            bytesPerRow: m,
            offset: A
          }, {
            texture: v
          }, {
            width: C,
            height: T
          }), this.submitQueue();
          const M = d.getContext("2d", {
            willReadFrequently: true
          });
          M.clearRect(0, 0, C, T), M.drawImage(f[g], 0, 0);
          const E = M.getImageData(0, 0, C, T).data, k = a[g], R = new Uint8ClampedArray(u, A, C * T * 4);
          for (let N = 0; N < R.length; N += 4) if (k === "premultiplied") R[N + 3] = E[N + 3];
          else {
            const I = E[N];
            R[N] = E[N + 2], R[N + 1] = E[N + 1], R[N + 2] = I;
          }
        }, x = Math.floor(l / (c * h));
        let _ = c, S = h, b = 0;
        for (let C = 0; C < x; C++) y(_, S, b), b += c * h * 4;
        const w = l % (c * h);
        S = Math.floor(w / c), S > 0 && (y(_, S, b), b += S * (c * 4)), _ = w % c, _ > 0 && y(_, 1, b);
      });
      const p = Ug(u, t.dtype);
      return this.convertAndCacheOnCPU(e, p), p;
    }
    async read(e) {
      if (!this.tensorMap.has(e)) throw new Error(`Tensor ${e} was not registered!`);
      const t = this.tensorMap.get(e), { values: n } = t;
      if (n != null) return n;
      let i;
      if (t.dtype === "complex64") {
        const a = await Promise.all([
          this.read(t.complexTensorInfos.real.dataId),
          this.read(t.complexTensorInfos.imag.dataId)
        ]), o = a[0], s = a[1];
        i = Yw(o, s);
      } else {
        const a = await this.getBufferData(t.resource);
        i = Ug(a, t.dtype);
      }
      return this.convertAndCacheOnCPU(e, i), i;
    }
    copyBuffer(e) {
      const t = e.size, n = e.usage, i = this.bufferManager.acquireBuffer(t, n);
      return this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e, 0, i, 0, t), this.submitQueue(), i;
    }
    createTensorFromGPUData(e, t, n) {
      let i = e.buffer;
      if (n === "complex64") throw new Error("Cannot write to a complex64 dtype. ");
      const a = {
        id: this.nextDataId()
      };
      this.tensorMap.set(a, {
        dtype: n,
        shape: t,
        values: null,
        refCount: 1,
        external: e.zeroCopy
      });
      const o = this.tensorMap.get(a), s = bP(o.dtype) * Ze(o.shape);
      if (e.buffer.size < s) throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${s})!`);
      if ((e.buffer.usage & (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) !== (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");
      return e.zeroCopy !== true && (i = this.copyBuffer(i)), o.resource = i, Wg().makeTensorFromDataId(a, t, n, this);
    }
    readToGPU(e) {
      const t = this.tensorMap.get(e), { values: n, dtype: i, shape: a, resource: o } = t;
      if (i === "complex64") throw new Error("Does not support reading buffer for complex64 dtype.");
      if (o == null) throw n != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
      const s = o, l = s.size, u = s.usage, c = this.bufferManager.acquireBuffer(l, u);
      this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(o, 0, c, 0, l), this.submitQueue();
      const h = this.makeTensorInfo(a, i), f = Wg().makeTensorFromTensorInfo(h), d = this.tensorMap.get(h.dataId);
      return d.resource = c, {
        tensorRef: f,
        buffer: c
      };
    }
    bufferSync(e) {
      const t = this.readSync(e.dataId);
      if (e.dtype === "string") try {
        const n = t.map((i) => Rb(i));
        return au(e.shape, e.dtype, n);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return au(e.shape, e.dtype, t);
    }
    async time(e) {
      !this.supportTimestampQuery && !this.hasTimestampQueryWarned && (console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."), this.hasTimestampQueryWarned = true);
      const t = this.activeTimers, n = [];
      let i = false;
      this.programTimersStack == null ? (this.programTimersStack = n, i = true) : this.activeTimers.push(n), this.activeTimers = n, e();
      const a = Xw(this.activeTimers.map((u) => u.query)).filter((u) => u != null), o = Xw(this.activeTimers.map((u) => u.name)).filter((u) => u != null);
      this.activeTimers = t, i && (this.programTimersStack = null);
      const s = {
        uploadWaitMs: this.uploadWaitMs,
        downloadWaitMs: this.downloadWaitMs,
        kernelMs: null,
        wallMs: null
      }, l = await Promise.all(a);
      return s.kernelMs = W$(l), s.getExtraProfileInfo = () => l.map((u, c) => ({
        name: o[c],
        ms: u
      })).map((u) => `${u.name}: ${u.ms}`).join(", "), this.uploadWaitMs = 0, this.downloadWaitMs = 0, s;
    }
    makeTensorInfo(e, t, n) {
      return t === "string" && n != null && n.length > 0 && U$(n[0]) && (n = n.map((a) => H$(a))), {
        dataId: this.write(n, e, t),
        shape: e,
        dtype: t
      };
    }
    tensorToBinding(e) {
      if (!e) return null;
      const n = this.tensorMap.get(e.dataId).resource;
      return n instanceof GPUBuffer ? {
        buffer: n
      } : n instanceof GPUTexture ? n.createView() : n;
    }
    uploadToGPU(e) {
      const t = this.tensorMap.get(e);
      if (t.resource != null) return;
      const n = bP(t.dtype) * Ze(t.shape);
      let i;
      const a = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
      if (t.values) {
        if (i = this.bufferManager.acquireBuffer(n, a, true), i.mapState === "unmapped") {
          const o = this.bufferManager.acquireBuffer(n, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, true, false), s = o.getMappedRange();
          t.dtype === "int32" || t.dtype === "bool" ? new Int32Array(s).set(t.values) : new Float32Array(s).set(t.values), o.unmap(), this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(o, 0, i, 0, n), this.stagingPendingDisposal.push(o);
        } else {
          const o = i.getMappedRange();
          t.dtype === "int32" || t.dtype === "bool" ? new Int32Array(o).set(t.values) : new Float32Array(o).set(t.values), i.unmap();
        }
        t.values = null;
      } else i = this.bufferManager.acquireBuffer(n, a);
      t.resource = i;
    }
    makeUniforms(e) {
      let t = 0, n = 0;
      const i = [];
      let a = 1;
      e.forEach((l) => {
        l.data.length === 0 && (l.data = [
          1
        ]);
        let u;
        switch (l.data.length) {
          case 1:
            u = 4;
            break;
          case 2:
            u = 8;
            break;
          case 3:
            u = 16;
            break;
          case 4:
            u = 16;
            break;
          case 5:
            u = 16;
            break;
          case 6:
            u = 16;
            break;
          default:
            Mt(false, () => `Unsupported ${l.data.length}D shape`);
        }
        (n === 5 || n === 6) && (u = 16), u > a && (a = u), t = Math.ceil(t / u) * u, n = l.data.length, i.push(t), t += l.data.length * 4;
      }), t = Math.ceil(t / a) * a;
      const o = new ArrayBuffer(t);
      e.forEach((l, u) => {
        const c = i[u];
        l.type === "int32" ? new Int32Array(o, c, l.data.length).set(l.data) : l.type === "uint32" ? new Uint32Array(o, c, l.data.length).set(l.data) : new Float32Array(o, c, l.data.length).set(l.data);
      });
      const s = this.bufferManager.acquireBuffer(t, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
      return this.queue.writeBuffer(s, 0, o, 0, t), this.uniformPendingDisposal.push(s), {
        offset: 0,
        size: t,
        buffer: s
      };
    }
    runWebGPUProgram(e, t, n, i, a) {
      if (a || (a = this.makeTensorInfo(e.outputShape, n)), Ze(a.shape) === 0) return this.tensorMap.get(a.dataId).values = kL(a.dtype, 0), a;
      this.uploadToGPU(a.dataId), e.dispatch = Lce(this.device, e);
      const o = t.map((l, u) => {
        if (l.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
        return this.uploadToGPU(l.dataId), {
          dtype: this.tensorMap.get(l.dataId).dtype,
          shape: l.shape,
          name: e.variableNames[u]
        };
      });
      e.shaderKey = bce(e, o, a);
      const s = rr().getBool("WEBGPU_ENGINE_COMPILE_ONLY");
      return e.shaderKey in this.pipelineCache || (this.pipelineCache[e.shaderKey] = yce(this.device, e, o, a, s)), e.pipeline = this.pipelineCache[e.shaderKey], s || this.recordAndSubmit(e, a, t, i), a;
    }
    recordAndSubmit(e, t, n, i) {
      if (e.pipeline instanceof Promise) throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");
      let a = [], o = [];
      const s = "int32";
      if (e.pixelsOpType == null) {
        a.push({
          type: "float32",
          data: [
            NaN
          ]
        }, {
          type: "float32",
          data: [
            1 / 0
          ]
        }), o = n.concat(t).map((d) => d.shape);
        const f = "int32";
        o.map((d) => {
          a.push({
            type: f,
            data: d
          });
          const p = ph(d);
          a.push({
            type: f,
            data: p
          });
        });
      } else {
        const f = ph(t.shape);
        a.push({
          type: s,
          data: f
        });
      }
      if (e.size) {
        const f = Ze(e.outputShape);
        a.push({
          type: s,
          data: [
            e.outputComponent ? f / e.outputComponent : f
          ]
        });
      }
      i && (a = [
        ...a,
        ...i
      ]);
      const l = [
        this.tensorToBinding(t),
        ...n.map((f) => this.tensorToBinding(f)),
        this.makeUniforms(a)
      ];
      n.forEach((f) => {
        this.commandQueueOwnedIds.add(f.dataId);
      }), this.commandQueueOwnedIds.add(t.dataId);
      const u = this.device.createBindGroup({
        layout: e.pipeline.getBindGroupLayout(0),
        entries: l.map((f, d) => ({
          binding: d,
          resource: f
        }))
      }), c = this.activeTimers != null;
      this.ensureCommandEncoderReady();
      const h = {};
      c && this.supportTimestampQuery ? (this.endComputePassEncoder(), this.querySet == null && (this.querySet = this.device.createQuerySet({
        type: "timestamp",
        count: this.querySetCount
      })), h.timestampWrites = {
        querySet: this.querySet,
        beginningOfPassWriteIndex: 0,
        endOfPassWriteIndex: 1
      }, this.computePassEncoder = this.commandEncoder.beginComputePass(h)) : this.computePassEncoder || (this.computePassEncoder = this.commandEncoder.beginComputePass(h)), this.computePassEncoder.setPipeline(e.pipeline), this.computePassEncoder.setBindGroup(0, u), this.computePassEncoder.dispatchWorkgroups(e.dispatch[0], e.dispatch[1], e.dispatch[2]), this.dispatchCountInPass++, (c || rr().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE") <= this.dispatchCountInPass || e.pixelsOpType === xu.DRAW) && (this.endComputePassEncoder(), c ? this.activeTimers.push({
        name: e.constructor.name,
        query: this.getQueryTime()
      }) : this.submitQueue());
    }
    async getQueryTime() {
      if (!this.supportTimestampQuery) return 0;
      this.queryResolveBuffer == null && (this.queryResolveBuffer = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.QUERY_RESOLVE)), this.commandEncoder.resolveQuerySet(this.querySet, 0, this.querySetCount, this.queryResolveBuffer, 0);
      const e = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, e, 0, this.querySetCount * 8), this.submitQueue(), await e.mapAsync(GPUMapMode.READ);
      const t = new BigUint64Array(e.getMappedRange()), n = Number(t[1] - t[0]) / 1e6;
      return e.unmap(), this.bufferManager.releaseBuffer(e), n;
    }
    shouldExecuteOnCPU(e, t = kce) {
      return rr().getBool("WEBGPU_CPU_FORWARD") && e.every((n) => this.tensorMap.get(n.dataId).resource == null && Ze(n.shape) < t);
    }
    numDataIds() {
      return this.tensorMap.numDataIds() - this.tensorDataPendingDisposal.length;
    }
    dispose() {
      this.disposed || (this.querySet != null && this.querySet.destroy(), this.bufferManager.dispose(), this.textureManager.dispose(), this.disposed = true);
    }
  }
  kg.nextDataId = 0;
  vz() && Y$("webgpu", async () => {
    const r = {
      powerPreference: rr().get("WEBGPU_USE_LOW_POWER_GPU") ? "low-power" : "high-performance"
    }, e = await navigator.gpu.requestAdapter(r), t = {}, n = [];
    e.features.has("timestamp-query") && n.push("timestamp-query"), e.features.has("bgra8unorm-storage") && n.push([
      "bgra8unorm-storage"
    ]), t.requiredFeatures = n;
    const i = e.limits;
    t.requiredLimits = {
      maxComputeWorkgroupStorageSize: i.maxComputeWorkgroupStorageSize,
      maxComputeWorkgroupsPerDimension: i.maxComputeWorkgroupsPerDimension,
      maxStorageBufferBindingSize: i.maxStorageBufferBindingSize,
      maxBufferSize: i.maxBufferSize,
      maxComputeWorkgroupSizeX: i.maxComputeWorkgroupSizeX,
      maxComputeInvocationsPerWorkgroup: i.maxComputeInvocationsPerWorkgroup
    };
    const a = await e.requestDevice(t), o = await e.requestAdapterInfo();
    return new kg(a, o);
  }, 3);
  var ze;
  (function(r) {
    r[r.ADD = 0] = "ADD", r[r.ATAN2 = 1] = "ATAN2", r[r.COMPLEX_MULTIPLY_IMAG = 2] = "COMPLEX_MULTIPLY_IMAG", r[r.COMPLEX_MULTIPLY_REAL = 3] = "COMPLEX_MULTIPLY_REAL", r[r.DIV = 4] = "DIV", r[r.ELU_DER = 5] = "ELU_DER", r[r.EQUAL = 6] = "EQUAL", r[r.FLOOR_DIV = 7] = "FLOOR_DIV", r[r.GREATER = 8] = "GREATER", r[r.GREATER_EQUAL = 9] = "GREATER_EQUAL", r[r.LESS = 10] = "LESS", r[r.LESS_EQUAL = 11] = "LESS_EQUAL", r[r.LOGICAL_AND = 12] = "LOGICAL_AND", r[r.LOGICAL_OR = 13] = "LOGICAL_OR", r[r.MAX = 14] = "MAX", r[r.MIN = 15] = "MIN", r[r.MOD = 16] = "MOD", r[r.MUL = 17] = "MUL", r[r.NOT_EQUAL = 18] = "NOT_EQUAL", r[r.POW = 19] = "POW", r[r.PRELU = 20] = "PRELU", r[r.SQUARED_DIFFERENCE = 21] = "SQUARED_DIFFERENCE", r[r.SUB = 22] = "SUB";
  })(ze || (ze = {}));
  const Rce = "let resultTemp = a + b;", Ece = "let resultTemp = atan2(a, b);", Nce = "let resultTemp = areal * breal - aimag * bimag;", Oce = "let resultTemp = areal * bimag + aimag * breal;", Fce = "let resultTemp = a / b;", Bce = "let resultTemp = select(a * (b + 1.0), a, b >= b - b);", zce = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`, Vce = `
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`, $ce = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`, Gce = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`, Wce = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`, Uce = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`, Hce = "return f32(a >= 1.0 && b >= 1.0);", Yce = `return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`, Xce = "return f32(a >= 1.0 || b >= 1.0);", qce = `return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`, Kce = "let resultTemp = max(a, b);", Zce = "let resultTemp = min(a, b);", jce = `
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`, Qce = `
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`, Jce = "let resultTemp = a * b;", ehe = `
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`, the = `
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`, rhe = `
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`, nhe = `
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`, ihe = "if (a < 0.0) { return b * a; }  return a;", ahe = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`, ohe = "let resultTemp = (a - b) * (a - b);", she = "let resultTemp = a - b;";
  function iw(r, e) {
    let t;
    do {
      switch (r) {
        case ze.ATAN2:
          t = Ece;
          break;
        case ze.MAX:
          t = Kce;
          break;
        case ze.MIN:
          t = Zce;
          break;
        case ze.MOD:
          t = e ? Qce : jce;
          break;
        case ze.NOT_EQUAL:
          t = e ? the : ehe;
          break;
        case ze.POW:
          t = e ? nhe : rhe;
          break;
        default:
          continue;
      }
      let n, i, a;
      return e ? (n = "isnanVec4", i = "vec4<f32>", a = "vec4<bool>") : (n = "isnan", i = "f32", a = "bool"), `
      let aIsNaN = ${n}(a);
      let aPostLegalization = select(a, ${i}(42), aIsNaN);
      let bIsNaN = ${n}(b);
      let bPostLegalization = select(b, ${i}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${i}(valueForNaN),
            ${a}(isNaN) | aIsNaN | bIsNaN);
      }
    `;
    } while (false);
    switch (r) {
      case ze.ADD:
        t = Rce;
        break;
      case ze.COMPLEX_MULTIPLY_IMAG:
        t = Oce;
        break;
      case ze.COMPLEX_MULTIPLY_REAL:
        t = Nce;
        break;
      case ze.DIV:
        t = Fce;
        break;
      case ze.ELU_DER:
        t = Bce;
        break;
      case ze.EQUAL:
        t = zce;
        break;
      case ze.FLOOR_DIV:
        t = Vce;
        break;
      case ze.GREATER:
        t = $ce;
        break;
      case ze.GREATER_EQUAL:
        t = Gce;
        break;
      case ze.LESS:
        t = Wce;
        break;
      case ze.LESS_EQUAL:
        t = Uce;
        break;
      case ze.LOGICAL_AND:
        return e ? Yce : Hce;
      case ze.LOGICAL_OR:
        return e ? qce : Xce;
      case ze.MUL:
        t = Jce;
        break;
      case ze.PRELU:
        return e ? ahe : ihe;
      case ze.SQUARED_DIFFERENCE:
        t = ohe;
        break;
      case ze.SUB:
        t = she;
        break;
    }
    return `
    ${t}
    return resultTemp;
  `;
  }
  var ie;
  (function(r) {
    r[r.ABS = 0] = "ABS", r[r.ACOS = 1] = "ACOS", r[r.ACOSH = 2] = "ACOSH", r[r.ASIN = 3] = "ASIN", r[r.ASINH = 4] = "ASINH", r[r.ATAN = 5] = "ATAN", r[r.ATANH = 6] = "ATANH", r[r.CEIL = 7] = "CEIL", r[r.COS = 8] = "COS", r[r.COSH = 9] = "COSH", r[r.ELU = 10] = "ELU", r[r.ERF = 11] = "ERF", r[r.EXP = 12] = "EXP", r[r.EXPM1 = 13] = "EXPM1", r[r.FLOOR = 14] = "FLOOR", r[r.IS_FINITE = 15] = "IS_FINITE", r[r.IS_INF = 16] = "IS_INF", r[r.IS_NAN = 17] = "IS_NAN", r[r.LINEAR = 18] = "LINEAR", r[r.LOG = 19] = "LOG", r[r.LOG1P = 20] = "LOG1P", r[r.LOGICAL_NOT = 21] = "LOGICAL_NOT", r[r.NEG = 22] = "NEG", r[r.RELU = 23] = "RELU", r[r.RELU6 = 24] = "RELU6", r[r.LEAKYRELU = 25] = "LEAKYRELU", r[r.RECIPROCAL = 26] = "RECIPROCAL", r[r.ROUND = 27] = "ROUND", r[r.RSQRT = 28] = "RSQRT", r[r.SELU = 29] = "SELU", r[r.SIGMOID = 30] = "SIGMOID", r[r.SIGN = 31] = "SIGN", r[r.SIN = 32] = "SIN", r[r.SINH = 33] = "SINH", r[r.SOFTPLUS = 34] = "SOFTPLUS", r[r.SQRT = 35] = "SQRT", r[r.SQUARE = 36] = "SQUARE", r[r.STEP = 37] = "STEP", r[r.TAN = 38] = "TAN", r[r.TANH = 39] = "TANH", r[r.TO_INT = 40] = "TO_INT";
  })(ie || (ie = {}));
  const lhe = "return abs(a);", uhe = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`, che = `
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`, hhe = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`, fhe = "return asinh(a);", dhe = `
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`, phe = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`, vhe = "return ceil(a);", ghe = "return cos(a);", mhe = `
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`, yhe = "return exp(a) - 1.0;", xhe = "if (a >= 0.0) { return a; }  return (exp(a) - 1.0);", _he = `
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`, bhe = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${K$};
  let a1 = ${Z$};
  let a2 = ${j$};
  let a3 = ${Q$};
  let a4 = ${J$};
  let a5 = ${eG};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`, She = "return exp(a);", whe = "return floor(a);", Che = "return f32(!isnan(a) && !isinf(a));", The = "return f32(isinf(a));", Ahe = "return f32(isnan(a));", Ihe = "return a;", Mhe = `if (a < 0.0) { return uniforms.NAN; }
  return log(a);`, Dhe = `
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`, Phe = "return f32(!(a >= 1.0));", khe = "return -a;", Lhe = "if (a < 0.0) { return uniforms.alpha * a; } return a;", Rhe = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`, Ehe = "return 1.0 / a;", Nhe = "return select(a, 0.0, a < 0.0);", Ohe = "return clamp(a, 0.0, 6.0);", Fhe = "return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));", Bhe = `
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`, zhe = "return round(a);", Vhe = "return inverseSqrt(a);", $he = `
  if (a >= 0.0) {
    return ${X$} * a;
  } else {
    return ${q$} * (exp(a) - 1.0);
  }
`, Ghe = "return 1.0 / (1.0 + exp(-1.0 * a));", Whe = "return sign(a);", Uhe = "return sin(a);", Hhe = `
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`, Yhe = `
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`, Xhe = "return sqrt(a);", qhe = "return a * a;", Khe = `
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`, Zhe = "return tan(a);", jhe = `
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`, Qhe = "return f32(i32((a)));";
  function as(r, e) {
    switch (r) {
      case ie.ABS:
        return lhe;
      case ie.ACOS:
        return uhe;
      case ie.ACOSH:
        return che;
      case ie.ASIN:
        return hhe;
      case ie.ASINH:
        return fhe;
      case ie.ATAN:
        return dhe;
      case ie.ATANH:
        return phe;
      case ie.COS:
        return ghe;
      case ie.COSH:
        return mhe;
      case ie.CEIL:
        return vhe;
      case ie.ELU:
        return e ? _he : xhe;
      case ie.ERF:
        return bhe;
      case ie.EXP:
        return She;
      case ie.EXPM1:
        return yhe;
      case ie.FLOOR:
        return whe;
      case ie.IS_FINITE:
        return Che;
      case ie.IS_INF:
        return The;
      case ie.IS_NAN:
        return Ahe;
      case ie.LINEAR:
        return Ihe;
      case ie.LOG:
        return Mhe;
      case ie.LOG1P:
        return Dhe;
      case ie.LOGICAL_NOT:
        return Phe;
      case ie.NEG:
        return khe;
      case ie.LEAKYRELU:
        return e ? Rhe : Lhe;
      case ie.RECIPROCAL:
        return Ehe;
      case ie.RELU:
        return e ? Bhe : Nhe;
      case ie.RELU6:
        return e ? Fhe : Ohe;
      case ie.ROUND:
        return zhe;
      case ie.RSQRT:
        return Vhe;
      case ie.SELU:
        return $he;
      case ie.SIGMOID:
        return Ghe;
      case ie.SIGN:
        return Whe;
      case ie.SIN:
        return Uhe;
      case ie.SINH:
        return Hhe;
      case ie.SOFTPLUS:
        return Yhe;
      case ie.SQRT:
        return Xhe;
      case ie.SQUARE:
        return qhe;
      case ie.STEP:
        return Khe;
      case ie.TAN:
        return Zhe;
      case ie.TANH:
        return jhe;
      case ie.TO_INT:
        return Qhe;
      default:
        throw new Error(`BinaryType ${r} is not implemented!`);
    }
  }
  function Ia(r, e = false, t = false, n = 3) {
    if (r === null) return "";
    let i = "";
    if (r === "linear") i = as(ie.LINEAR);
    else if (r === "relu") i = as(ie.RELU, t);
    else if (r === "elu") i = as(ie.ELU, t);
    else if (r === "relu6") i = as(ie.RELU6, t);
    else if (r === "prelu") i = iw(ze.PRELU, t);
    else if (r === "sigmoid") i = as(ie.SIGMOID, t);
    else if (r === "leakyrelu") i = as(ie.LEAKYRELU, t);
    else throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`);
    const o = Je(t ? 4 : 1);
    let s = "";
    return e ? s = `
      fn activation(a : ${o}, coords : vec${n}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }` : s = `
      fn activation(a : ${o}, coords : vec${n}<i32>) -> ${o} {
        ${i}
      }`, s;
  }
  function rl(r, e) {
    return `
      ${r ? "value = value + getBiasByOutputCoords(coords);" : ""}
      ${e ? "value = activation(value, coords);" : ""}
      `;
  }
  function mz(r, e, t = false, n = false, i = false, a = 1) {
    Mt(r && a === 1 || !r, () => `transposeA ${r} is not compatible with component size ${a}`);
    const o = `
      ${r ? "value = getA(batch, col, row);" : "value = getA(batch, row, col);"}

    `, s = e ? "value = getB(batch, col, row);" : "value = getB(batch, row, col);";
    return `
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Je(a)} {
    var value = ${Je(a)}(0.0);
    ${t && i ? o : `
    ${r ? "if(row < uniforms.dimAOuter && col < uniforms.dimInner)" : "if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Je(a)} {
    var value = ${Je(a)}(0.0);
    ${s}
    return value;
  }
  `;
  }
  function aw(r, e, t, n, i = false, a = false, o = false, s = 1) {
    return `
  ${mz(t, n, i, a, o, s)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Je(s)}) {
    ${i && a ? "" : "if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${rl(r, e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `;
  }
  const Jhe = (r, e) => r ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `, efe = (r, e, t, n) => {
    if (r) return `
      for (var k = 0; k < ${n}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;
    {
      let i = "", a = "";
      for (let o = 0; o < e; o++) i += `let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`, a += `acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;
      return `
      for (var k = 0; k < ${n / e}; k++) {
        ${i}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${a}
        }
      }`;
    }
  };
  function Lg(r, e, t = false, n = 32, i = false, a = 32, o = false) {
    const s = e[1] * r[1], l = e[0] * r[0], u = t ? s : n, c = t ? n : s, h = u / e[0], f = n / e[1], d = r[1], p = r[0];
    return Mt((t && h === 4 && r[1] === 4 || !t && (h === 3 || h === 4)) && u % e[0] === 0 && n % e[1] === 0 && r[0] === 4, () => `If transposeA ${t} is true, innerElementSize ${h} and workPerThread[1] ${r[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}. tileInner ${n} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${r[0]} must be 4.`), `
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${u / h}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l / r[0]}>, ${n}>;

  ${se()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${d};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${d};
    let globalCol = i32(globalId.x) * ${p};
    let batch = ${i ? "0" : "i32(globalId.z)"};
    let batchA = ${i || !o ? "batch" : "batch % uniforms.aShape[0]"};
    let batchB = ${i || !o ? "batch" : "batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${s};

    let numTiles = ${i ? `${Math.ceil(a / n)}` : `(uniforms.dimInner - 1) / ${n} + 1`};
    var kStart = ${i ? `i32(globalId.z) * ${a}` : "0"};

    var acc: array<vec4<f32>, ${d}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${f};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${Jhe(t, h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${n};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${efe(t, h, d, n)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`;
  }
  const SP = (r) => r ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `, tfe = (r) => r ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
  function Rg(r, e, t = false, n = 32, i = false, a = 32, o = false, s = false) {
    const l = r[1] * e[1], u = r[0] * e[0], c = t ? l : n, h = t ? n : l;
    Mt(h % e[1] === 0 && c % e[0] === 0 && n % e[1] === 0, () => `tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${n} must be divisible by workgroupSize[1]${e[1]}`);
    const f = h / e[1], d = c / e[0], p = n / e[1], v = r[1], g = r[0], m = o ? `
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            ${SP(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${n};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${g}>;
        for (var k = 0; k < ${n}; k++) {
          for (var inner = 0; inner < ${g}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${v}; innerRow++) {
            let ACached = ${t ? `mm_Asub[k][localRow + innerRow * ${e[1]}];` : `mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${g}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${v}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      ` : `
  let tileRow = i32(localId.y) * ${v};
  let tileCol = i32(localId.x) * ${g};

  let globalRow = i32(globalId.y) * ${v};
  let globalCol = i32(globalId.x) * ${g};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${f};
  let tileColA = i32(localId.x) * ${d};
  let tileRowB = i32(localId.y) * ${p};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${d}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${SP(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${n};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${g}>;
    for (var k = 0; k < ${n}; k++) {
      for (var inner = 0; inner < ${g}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${v}; innerRow++) {
        ${tfe(t)}
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${v}; innerRow++) {
    for (var innerCol = 0; innerCol < ${g}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;
    return `
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${n}>;

    ${se()} {
      let batch = ${i ? "0" : "i32(globalId.z)"};
      let batchA = ${i || !s ? "batch" : "batch % uniforms.aShape[0]"};
      let batchB = ${i || !s ? "batch" : "batch % uniforms.bShape[0]"};
      let numTiles = ${i ? `${Math.ceil(a / n)}` : `(uniforms.dimInner - 1) / ${n} + 1`};
      var kStart = ${i ? `i32(globalId.z) * ${a}` : "0"};

      var acc : array<array<f32, ${g}>, ${v}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${v}; innerRow++) {
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${m}
    }
  `;
  }
  const rfe = (r) => r ? `
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  ` : `
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;
  function nfe(r, e = false) {
    Mt(r[1] === 1 && r[2] === 1, () => `A linear work group size is required. But got ${r}.`);
    const t = r[0] * 4;
    return `
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${se()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${rfe(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t / 4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `;
  }
  class ife {
    constructor(e, t, n = false, i = false, a = null, o = null, s = null, l = false) {
      this.variableNames = [
        "A",
        "B"
      ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = t, this.dispatchLayout = {
        x: [
          2
        ],
        y: [
          1
        ],
        z: [
          0
        ]
      };
      const u = n ? e[1] : e[2];
      if (this.isVec4 = (u % 4 === 0 && !n || t[1] % 4 === 0 && n) && t[2] % 4 === 0 && !i, this.outputComponent = this.isVec4 ? 4 : 1, this.isVectorA = t[1] === 1 && !n, !this.isVec4 && this.isVectorA) this.elementsPerThread = [
        1,
        1,
        1
      ], this.workgroupSize = [
        32,
        1,
        1
      ];
      else {
        const f = Pce(t[1], u, t[2], n);
        this.workgroupSize = f.workgroupSize, this.elementsPerThread = f.elementsPerThread;
      }
      this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);
      const c = a != null, h = s != null;
      c && this.variableNames.push("bias"), h && this.variableNames.push("preluActivationWeights"), this.sequentialAccessByThreads = l, this.transposeA = n, this.transposeB = i, this.addBias = c, this.activation = o, this.hasPreluActivationWeights = h, [this.fitAOuter, this.fitBOuter, this.fitInner] = this.getShapeFit(t[1], t[2], u), this.shaderKey = `matMulPacked_${this.elementsPerThread}_${n}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`;
    }
    getShapeFit(e, t, n) {
      const i = this.workgroupSize[1] * this.elementsPerThread[1], a = this.workgroupSize[0] * this.elementsPerThread[0];
      !this.isVec4 && this.isVectorA ? this.tileInner = this.workgroupSize[0] * 4 : this.tileInner = a;
      const o = e % i === 0, s = t % a === 0, l = n % this.tileInner === 0;
      return [
        o,
        s,
        l
      ];
    }
    getUserCode() {
      return `
      ${Ia(this.activation, this.hasPreluActivationWeights, this.isVec4)}
      ${aw(this.addBias, this.activation, false, this.transposeB, this.fitAOuter, this.fitBOuter, this.fitInner, this.isVec4 ? 4 : 1)}
      ${this.isVec4 ? Lg(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, true) : this.isVectorA ? nfe(this.workgroupSize, this.transposeA) : Rg(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, this.sequentialAccessByThreads, true)}
    `;
    }
  }
  function afe(r) {
    return `
    var<workgroup> sumValues : array<f32, ${r}>;
    ${se()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${r}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${r / 2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `;
  }
  class ofe {
    constructor(e, t = false, n = false, i = null, a = null, o = null) {
      this.variableNames = [
        "A",
        "B"
      ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [
        256,
        1,
        1
      ], this.outputShape = e, this.dispatchLayout = {
        x: [],
        y: [
          1,
          2
        ],
        z: [
          0
        ]
      }, this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize);
      const s = i != null, l = o != null;
      s && this.variableNames.push("bias"), l && this.variableNames.push("preluActivationWeights"), this.transposeA = t, this.transposeB = n, this.addBias = s, this.activation = a, this.hasPreluActivationWeights = l, this.shaderKey = `matMulReduce_${this.activation}_${t}_${n}`;
    }
    getUserCode() {
      return `
      ${Ia(this.activation, this.hasPreluActivationWeights)}
      ${aw(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${afe(this.workgroupSize[0])}
    `;
    }
  }
  function sfe(r) {
    const e = r[1], t = r[0], n = e > t ? e : t;
    return `
  var<workgroup> mm_Asub : array<array<f32, ${n}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${n}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${se()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${n};
    globalRowB = globalRowB + ${n};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${n};
      globalRowB = globalRowB + ${n};

      for (var k = 0; k < ${n}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `;
  }
  class lfe {
    constructor(e, t, n, i = false, a = false, o = null, s = null, l = null) {
      this.variableNames = [
        "A",
        "B"
      ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [
        16,
        8,
        1
      ], this.outputShape = n, this.dispatchLayout = {
        x: [
          2
        ],
        y: [
          1
        ],
        z: [
          0
        ]
      }, this.dispatch = [
        Math.ceil(n[2] / this.workgroupSize[0]),
        Math.ceil(n[1] / this.workgroupSize[1]),
        n[0]
      ];
      const u = o != null;
      u && this.variableNames.push("bias");
      const c = l != null;
      c && this.variableNames.push("preluActivationWeights"), this.transposeA = i, this.transposeB = a, this.addBias = u, this.activation = s, this.hasPreluActivationWeights = c, this.shaderKey = `matMulSmallOutputSize_${this.activation}_${i}_${a}`;
    }
    getUserCode() {
      return `
      ${Ia(this.activation, this.hasPreluActivationWeights)}
      ${aw(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${sfe(this.workgroupSize)}
    `;
    }
  }
  class ufe {
    constructor(e, t, n = false, i = false) {
      this.variableNames = [
        "A",
        "B"
      ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [
        8,
        8,
        1
      ], this.atomic = true, this.splitedDimInner = 128, Mt(e[0] === 1, () => "MatMulSplitKProgram only supports batch = 1."), this.outputShape = e, this.dispatchLayout = {
        x: [
          2
        ],
        y: [
          1
        ],
        z: [
          0,
          3
        ]
      };
      const a = (n && this.outputShape[1] % 4 === 0 || !n && t % 4 === 0) && this.outputShape[2] % 4 === 0;
      this.elementsPerThread = [
        4,
        4,
        this.splitedDimInner
      ], this.outputComponent = a ? 4 : 1, a || (this.outputShape[1] < 16 && (this.elementsPerThread[1] = 1), this.outputShape[2] < 16 && (this.elementsPerThread[0] = 1)), this.dispatch = ue(this.dispatchLayout, [
        this.outputShape[0],
        this.outputShape[1],
        this.outputShape[2],
        t
      ], this.workgroupSize, this.elementsPerThread), this.transposeA = n, this.transposeB = i, this.shaderKey = `matMulSplitK_${n}_${i}_${this.elementsPerThread}_${this.outputComponent}`;
    }
    getUserCode() {
      const e = this.outputComponent;
      return `
      ${mz(false, this.transposeB, false, false, false, e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Je(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${xo("&result[flatIndex + i]", `${e > 1 ? "value[i]" : "value"}`, "float32")}
          }
        }
      }
      ${e === 4 ? Lg(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) : Rg(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner)}
    `;
    }
  }
  class cfe {
    constructor(e, t = null, n = null, i = null) {
      this.uniforms = "", this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.addBias = t != null, this.hasPreluActivationWeights = i != null, this.activation = n, this.addBias && this.variableNames.push("bias"), this.hasPreluActivationWeights && this.variableNames.push("preluActivationWeights"), this.shaderKey = `biasActivation_${n}`;
    }
    getUserCode() {
      return `
    ${Ia(this.activation, this.hasPreluActivationWeights)}
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${rl(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
    }
  }
  class hfe {
    constructor(e) {
      this.variableNames = [], this.outputShape = [], this.uniforms = "value : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "fill";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `;
    }
  }
  function Hr(r) {
    const { backend: e, attrs: t } = r, { shape: n, value: i } = t;
    let { dtype: a } = t;
    if (a = a || rG(i), a === "string") {
      const o = nG(a, Ze(n));
      return o.fill(i), e.makeTensorInfo(n, a, o);
    } else {
      const o = new hfe(n), s = [
        {
          type: "float32",
          data: [
            i
          ]
        }
      ];
      return e.runWebGPUProgram(o, [], a, s);
    }
  }
  const ffe = {
    kernelName: tG,
    backendName: "webgpu",
    kernelFunc: Hr
  };
  function we(r) {
    const { inputs: e, attrs: t } = r, { x: n } = e, { shape: i } = t, a = Ze(n.shape), o = aG(i, a), s = Ze(o);
    return Mt(a === s, () => `The new shape (${o}) has ${s} elements and the old shape (${n.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`), r.backend.incRef(n.dataId), {
      dataId: n.dataId,
      shape: o,
      dtype: n.dtype
    };
  }
  const dfe = {
    kernelName: iG,
    backendName: "webgpu",
    kernelFunc: we
  };
  function Eg({ a: r, b: e, transposeA: t, transposeB: n, backend: i, bias: a = null, preluActivationWeights: o = null, leakyreluAlpha: s = 0, activation: l = null }) {
    const u = r.shape.length, c = e.shape.length, h = t ? r.shape[u - 2] : r.shape[u - 1], f = n ? e.shape[c - 1] : e.shape[c - 2], d = t ? r.shape[u - 1] : r.shape[u - 2], p = n ? e.shape[c - 2] : e.shape[c - 1], v = r.shape.slice(0, -2), g = e.shape.slice(0, -2), m = Ze(v), y = Ze(g), _ = Ua(r.shape.slice(0, -2), e.shape.slice(0, -2)).concat([
      d,
      p
    ]);
    Mt(h === f, () => `Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);
    const S = t ? [
      m,
      h,
      d
    ] : [
      m,
      d,
      h
    ], b = n ? [
      y,
      p,
      f
    ] : [
      y,
      f,
      p
    ], w = we({
      inputs: {
        x: r
      },
      backend: i,
      attrs: {
        shape: S
      }
    }), C = we({
      inputs: {
        x: e
      },
      backend: i,
      attrs: {
        shape: b
      }
    }), T = [
      w,
      C
    ], A = Math.max(m, y), M = [
      w,
      C
    ], E = [
      {
        type: "int32",
        data: [
          d
        ]
      },
      {
        type: "int32",
        data: [
          p
        ]
      },
      {
        type: "int32",
        data: [
          h
        ]
      }
    ];
    let k, R;
    const N = [
      A,
      d,
      p
    ];
    let I = rr().get("WEBGPU_MATMUL_PROGRAM_TYPE");
    if (I < 0) {
      const P = rr().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), O = P > 0 ? P : i.thresholdToIncreaseWorkgroups, F = A * Math.ceil(d / 32) * Math.ceil(p / 32);
      F <= O || d <= 8 && F <= O * 2 ? A * d * p <= 128 ? I = Ci.MatMulReduceProgram : A === 1 && f >= 2e3 ? I = Ci.MatMulSplitKProgram : I = Ci.MatMulSmallOutputSizeProgram : I = Ci.MatMulPackedProgram;
    }
    switch (I) {
      case Ci.MatMulReduceProgram:
        k = new ofe(N, t, n, a, l, o);
        break;
      case Ci.MatMulSplitKProgram: {
        if (R = Hr({
          backend: i,
          attrs: {
            shape: N,
            value: 0,
            dtype: r.dtype
          }
        }), k = new ufe(N, f, t, n), a || l) {
          R = i.runWebGPUProgram(k, M, r.dtype, E, R);
          const O = new cfe(R.shape, a, l, o);
          let F = null;
          const B = [
            R
          ];
          a && B.push(a), o && B.push(o), l === "leakyrelu" && (F = [
            {
              type: "float32",
              data: [
                s
              ]
            }
          ], O.uniforms += " alpha : f32,");
          const V = i.runWebGPUProgram(O, B, R.dtype, F);
          T.push(R);
          const U = we({
            inputs: {
              x: V
            },
            backend: i,
            attrs: {
              shape: _
            }
          });
          T.push(V);
          for (const Y of T) i.disposeData(Y.dataId);
          return U;
        }
        break;
      }
      case Ci.MatMulSmallOutputSizeProgram:
        k = new lfe(S, b, N, t, n, a, l, o);
        break;
      case Ci.MatMulPackedProgram:
        const P = i.adapterInfo.isIntel();
        k = new ife(S, N, t, n, a, l, o, P);
        break;
      default:
        throw new Error(`Unsupported MatMulProgramType ${I}.`);
    }
    a && M.push(a), o && M.push(o), l === "leakyrelu" && (E.push({
      type: "float32",
      data: [
        s
      ]
    }), k.uniforms += " alpha : f32,"), R = i.runWebGPUProgram(k, M, r.dtype, E, R);
    const L = we({
      inputs: {
        x: R
      },
      backend: i,
      attrs: {
        shape: _
      }
    });
    T.push(R);
    for (const P of T) i.disposeData(P.dataId);
    return L;
  }
  function pfe(r) {
    const { inputs: e, backend: t, attrs: n } = r, { a: i, b: a, bias: o, preluActivationWeights: s } = e, { transposeA: l, transposeB: u, activation: c, leakyreluAlpha: h } = n;
    return Eg({
      a: i,
      b: a,
      transposeA: l,
      transposeB: u,
      backend: t,
      bias: o,
      preluActivationWeights: s,
      leakyreluAlpha: h,
      activation: c
    });
  }
  const vfe = {
    kernelName: oG,
    backendName: "webgpu",
    kernelFunc: pfe
  };
  class wP {
    constructor(e, t, n) {
      this.variableNames = [
        "AReal",
        "AImag",
        "BReal",
        "BImag"
      ], this.workgroupSize = [
        128,
        1,
        1
      ], this.size = true, this.outputShape = Ua(t, n), this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `binaryOpComplex_${e}`, this.op = e;
    }
    getUserCode() {
      return `
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${iw(this.op, false)}
      }

      ${se("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;
    }
  }
  class Rv {
    constructor(e, t, n) {
      if (this.size = true, this.variableNames = [
        "A",
        "B"
      ], this.outputShape = Ua(t, n), this.dispatchLayout = de(this.outputShape), this.op = e, this.useSharedMemoryWithA = t.length <= 1 && n.length > 1 && t[0] < 128, this.useSharedMemoryWithB = n.length <= 1 && t.length > 1 && n[0] < 128, this.useSharedMemoryWithA || this.useSharedMemoryWithB) this.outputComponent = 1, this.variableComponents = [
        1,
        1
      ], this.lastDimensionSize = this.useSharedMemoryWithB ? n[0] : t[0], this.shaderKey = `binary_${e}_${this.lastDimensionSize}`, this.type = "shared", this.workgroupSize = [
        256,
        1,
        1
      ];
      else {
        const i = t.length > 0 && t[t.length - 1] % 4 === 0, a = n.length > 0 && n[n.length - 1] % 4 === 0;
        i && a ? (this.outputComponent = 4, this.variableComponents = [
          4,
          4
        ]) : i && (qw(n) || n[n.length - 1] === 1) || a && (qw(t) || t[t.length - 1] === 1) ? (this.outputComponent = 4, this.variableComponents = i ? [
          4,
          1
        ] : [
          1,
          4
        ]) : (this.outputComponent = 1, this.variableComponents = [
          1,
          1
        ]), this.type = "nonshared", this.shaderKey = `binary_${e}_${this.variableComponents}`, this.workgroupSize = [
          128,
          1,
          1
        ];
      }
      this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.outputComponent,
        1,
        1
      ]);
    }
    getUserCode() {
      let e;
      const t = this.outputComponent === 4 ? "vec4<f32>" : "f32", n = `
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${iw(this.op, this.outputComponent === 4)}
    };
    `;
      if (this.type === "shared") {
        const i = this.lastDimensionSize > 1 ? `coords[${this.outputShape.length - 1}]` : "0", a = this.useSharedMemoryWithB ? `let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];` : `let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;
        e = `
        ${n}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${se("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? "B" : "A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${a}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `;
      } else e = `
       ${n}
       ${se("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;
      return e;
    }
  }
  function ln(r) {
    const { inputs: e } = r, { x: t } = e;
    return r.backend.incRef(t.dataId), {
      dataId: t.dataId,
      shape: t.shape,
      dtype: t.dtype
    };
  }
  const gfe = {
    kernelName: sG,
    backendName: "webgpu",
    kernelFunc: ln
  };
  function nl(r) {
    const { inputs: e, backend: t } = r, { real: n, imag: i } = e, a = t.makeTensorInfo(n.shape, "complex64"), o = t.tensorMap.get(a.dataId), s = ln({
      inputs: {
        x: n
      },
      backend: t
    }), l = ln({
      inputs: {
        x: i
      },
      backend: t
    });
    return o.complexTensorInfos = {
      real: s,
      imag: l
    }, a;
  }
  const mfe = {
    kernelName: lG,
    backendName: "webgpu",
    kernelFunc: nl
  };
  class Uu {
    constructor(e, t, n = "") {
      this.variableNames = [
        "A"
      ], this.size = true;
      const i = 128;
      this.workgroupSize = [
        i,
        1,
        1
      ], this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.op = t, n !== "" && (this.uniforms = n), this.shaderKey = `unary_${t}`;
    }
    getUserCode() {
      return `
      fn unaryOperation(a : f32) -> f32 {
        ${as(this.op, false)}
      }
      ${se("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `;
    }
  }
  function dt({ opType: r, cpuKernelImpl: e, dtype: t }) {
    return ({ inputs: n, backend: i }) => {
      const { x: a } = n, o = i, s = t || a.dtype;
      if (o.shouldExecuteOnCPU([
        a
      ]) && e != null) {
        const u = o.tensorMap.get(a.dataId), c = e(u.values, s);
        return o.makeTensorInfo(a.shape, s, c);
      }
      const l = new Uu(a.shape, r);
      return o.runWebGPUProgram(l, [
        a
      ], s);
    };
  }
  function cr({ opType: r, cpuKernelImpl: e, supportsComplex: t = false, dtype: n }) {
    return ({ inputs: i, backend: a }) => {
      const { a: o, b: s } = i, l = a;
      if (t && o.dtype === "complex64") {
        const h = l.tensorMap.get(o.dataId), f = l.tensorMap.get(s.dataId);
        let d, p;
        if (r !== ze.MUL) [d, p] = [
          [
            h.complexTensorInfos.real,
            f.complexTensorInfos.real
          ],
          [
            h.complexTensorInfos.imag,
            f.complexTensorInfos.imag
          ]
        ].map((g) => {
          const [m, y] = g, x = {
            dataId: m.dataId,
            dtype: m.dtype,
            shape: o.shape
          }, _ = {
            dataId: y.dataId,
            dtype: y.dtype,
            shape: s.shape
          }, S = new Rv(r, o.shape, s.shape);
          return l.runWebGPUProgram(S, [
            x,
            _
          ], vh(m.dtype, y.dtype));
        });
        else {
          const g = new wP(ze.COMPLEX_MULTIPLY_REAL, o.shape, s.shape), m = new wP(ze.COMPLEX_MULTIPLY_IMAG, o.shape, s.shape), y = [
            {
              dataId: h.complexTensorInfos.real.dataId,
              dtype: h.complexTensorInfos.real.dtype,
              shape: o.shape
            },
            {
              dataId: h.complexTensorInfos.imag.dataId,
              dtype: h.complexTensorInfos.imag.dtype,
              shape: o.shape
            },
            {
              dataId: f.complexTensorInfos.real.dataId,
              dtype: f.complexTensorInfos.real.dtype,
              shape: s.shape
            },
            {
              dataId: f.complexTensorInfos.imag.dataId,
              dtype: f.complexTensorInfos.imag.dtype,
              shape: s.shape
            }
          ];
          d = l.runWebGPUProgram(g, y, "float32"), p = l.runWebGPUProgram(m, y, "float32");
        }
        const v = nl({
          inputs: {
            real: d,
            imag: p
          },
          backend: l
        });
        return l.disposeData(d.dataId), l.disposeData(p.dataId), v;
      }
      const u = n || vh(o.dtype, s.dtype);
      if ((o.dtype === "string" || s.dtype === "string" || l.shouldExecuteOnCPU([
        o,
        s
      ])) && e != null) {
        const h = l.tensorMap.get(o.dataId).values, f = l.tensorMap.get(s.dataId).values, d = o.dtype === "string" ? Kw(h) : h, p = o.dtype === "string" ? Kw(f) : f, [v, g] = e(o.shape, s.shape, d, p, u);
        return l.makeTensorInfo(g, u, v);
      }
      const c = new Rv(r, o.shape, s.shape);
      return l.runWebGPUProgram(c, [
        o,
        s
      ], u);
    };
  }
  const { addImpl: yfe, castImpl: xfe, ceilImpl: _fe, concatImpl: bfe, equalImpl: Sfe, expImpl: wfe, expm1Impl: Cfe, floorImpl: Tfe, floorDivImpl: Afe, gatherNdImpl: Ife, gatherV2Impl: Mfe, greaterEqualImpl: Dfe, greaterImpl: Pfe, lessEqualImpl: kfe, lessImpl: Lfe, logImpl: Rfe, maxImpl: Efe, maximumImpl: Nfe, minimumImpl: Ofe, multiplyImpl: Ffe, negImpl: Bfe, notEqualImpl: zfe, prodImpl: Vfe, rangeImpl: $fe, rsqrtImpl: Gfe, scatterImpl: Wfe, simpleAbsImpl: Ufe, sliceImpl: Hfe, stridedSliceImpl: Yfe, stringNGramsImpl: Xfe, subImpl: qfe, tileImpl: Kfe, topKImpl: Zfe, transposeImpl: jfe } = uG;
  const Qfe = dt({
    opType: ie.ABS,
    cpuKernelImpl: Ufe
  }), Jfe = {
    kernelName: cG,
    backendName: "webgpu",
    kernelFunc: Qfe
  };
  const ede = dt({
    opType: ie.ACOS
  }), tde = {
    kernelName: hG,
    backendName: "webgpu",
    kernelFunc: ede
  };
  const rde = dt({
    opType: ie.ACOSH
  }), nde = {
    kernelName: fG,
    backendName: "webgpu",
    kernelFunc: rde
  };
  const ide = cr({
    opType: ze.ADD,
    cpuKernelImpl: yfe,
    supportsComplex: true
  }), ade = {
    kernelName: dG,
    backendName: "webgpu",
    kernelFunc: ide
  };
  class ode {
    constructor(e) {
      this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e[0], this.variableNames = e.map((t, n) => `T${n}`), this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.shaderKey = "addN";
    }
    getUserCode() {
      const e = [];
      this.variableNames.forEach((i) => {
        e.push(`let v${i} = get${i}ByOutputCoords(coords);`);
      });
      const t = this.variableNames.map((i) => `v${i}`).join(" + ");
      return `
      ${se("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `;
    }
  }
  function sde(r) {
    const { inputs: e, backend: t } = r, n = e;
    if (n.length === 1) return ln({
      inputs: {
        x: n[0]
      },
      backend: t
    });
    const i = n.map((s) => s.dtype).reduce((s, l) => vh(s, l)), a = n.map((s) => s.shape), o = new ode(a);
    return t.runWebGPUProgram(o, n, i);
  }
  const lde = {
    kernelName: pG,
    backendName: "webgpu",
    kernelFunc: sde
  };
  class ude {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.workgroupSize = [
        16,
        16,
        1
      ];
      const n = new Array(e.length);
      for (let i = 0; i < n.length; i++) n[i] = e[t[i]];
      this.outputShape = n, this.dispatchLayout = {
        x: [
          0
        ],
        y: [
          1
        ]
      }, this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        1,
        1,
        1
      ]), this.shaderKey = "transposeShared";
    }
    getUserCode() {
      Mt(this.workgroupSize[0] === this.workgroupSize[1], () => `Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);
      const e = this.workgroupSize[0];
      return `
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0] + 1}>, ${this.workgroupSize[0]}>;
      ${se()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;
    }
  }
  class cde {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true;
      const n = new Array(e.length);
      for (let i = 0; i < n.length; i++) n[i] = e[t[i]];
      this.outputShape = n, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.newDim = t, this.shaderKey = `transpose_${t}`;
    }
    getUserCode() {
      const e = Gt(this.outputShape.length), t = yz(this.newDim);
      return `
      ${se("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `;
    }
  }
  function yz(r) {
    const e = r.length;
    if (e > 6) throw Error(`Transpose for rank ${e} is not yet supported`);
    const t = new Array(e);
    for (let n = 0; n < r.length; n++) t[r[n]] = `coords.${ha(n)}`;
    return t.join();
  }
  function Gi(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { perm: a } = n, o = t, s = i.shape.length, l = new Array(s);
    for (let c = 0; c < l.length; c++) l[c] = i.shape[a[c]];
    if (t.shouldExecuteOnCPU([
      i
    ])) {
      const h = o.tensorMap.get(i.dataId).values, f = jfe(h, i.shape, i.dtype, a, l);
      return t.makeTensorInfo(l, i.dtype, f);
    }
    if (i.shape.length === 2 && Au(a, [
      1,
      0
    ])) {
      const c = new ude(i.shape, a);
      return o.runWebGPUProgram(c, [
        i
      ], i.dtype);
    }
    const u = new cde(i.shape, a);
    return o.runWebGPUProgram(u, [
      i
    ], i.dtype);
  }
  const hde = {
    kernelName: vG,
    backendName: "webgpu",
    kernelFunc: Gi
  };
  class fde {
    constructor(e, t, n) {
      this.variableNames = [
        "x"
      ], this.uniforms = "reduceSize : i32,", this.size = true, this.inputShape = [
        e.batchSize,
        e.inSize
      ];
      const [i] = Eb(this.inputShape, [
        1
      ]);
      this.outputShape = i.length === 0 ? [
        1
      ] : i, e.inSize >= 32768 && n >= 512 ? this.workgroupSize = [
        512,
        1,
        1
      ] : e.inSize >= 4096 ? this.workgroupSize = [
        256,
        1,
        1
      ] : this.workgroupSize = [
        64,
        1,
        1
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, [
        1,
        1,
        1
      ]), this.reduceType = t, this.shaderKey = `reduce_${t}`;
    }
    getUserCode() {
      let e = "", t = "0.0";
      const n = this.workgroupSize[0];
      this.reduceType === "min" || this.reduceType === "max" ? (e = `
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType === "min" ? "<" : ">"} bestValue)
           {  bestValue = candidate; }`, t = "f32(x[offset])") : this.reduceType === "sum" || this.reduceType === "mean" ? e = " bestValue = bestValue + candidate; " : this.reduceType === "prod" ? (e = " bestValue = bestValue * candidate; ", t = "1.0") : this.reduceType === "all" ? (e = " bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ", t = "1.0") : this.reduceType === "any" && (e = " bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ", t = "0.0");
      const i = this.reduceType === "mean" ? "setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));" : "setOutputAtIndex(outputIndex, bestValue);";
      return `
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${n}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length === 1 ? "outputCoords" : "outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${se("index")} {
         let outputIndex = index / ${n};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${n}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${n}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `;
    }
  }
  const dde = {
    mean: "float32",
    all: "bool",
    any: "bool"
  };
  function il(r, e, t, n, i) {
    const a = r.shape.length, o = [], s = Ys(e, r.shape);
    let l = s;
    const u = lf(l, a);
    let c = r;
    u != null && (c = Gi({
      inputs: {
        x: r
      },
      attrs: {
        perm: u
      },
      backend: i
    }), l = uf(l.length, a), o.push(c)), Nb(n, l, a);
    const [h, f] = Eb(c.shape, l);
    let d = h;
    t && (d = gG(h, s));
    let p;
    if ((n === "max" || n === "prod") && i.shouldExecuteOnCPU([
      c
    ])) {
      const v = i.tensorMap.get(c.dataId).values;
      switch (n) {
        case "max":
          const g = Efe(v, Ze(f), d, r.dtype);
          p = i.makeTensorInfo(d, r.dtype, g);
          break;
        case "prod":
          const { outVals: m, outShape: y, outDtype: x } = Vfe(c.shape, c.dtype, v, l);
          p = i.makeTensorInfo(y, x, m);
          break;
        default:
          throw new Error(`${n} CPU implementation is not yet supported.`);
      }
    } else {
      const v = Ze(f), m = Ze(c.shape) / v, y = {
        windowSize: v,
        inSize: v,
        batchSize: m,
        outSize: 1
      }, x = dde[n] || mG(r.dtype), _ = [
        {
          type: "int32",
          data: [
            v
          ]
        }
      ], S = new fde(y, n, i.device.limits.maxComputeWorkgroupSizeX), b = i.runWebGPUProgram(S, [
        c
      ], x, _);
      o.push(b), p = we({
        inputs: {
          x: b
        },
        attrs: {
          shape: d
        },
        backend: i
      });
    }
    return o.forEach((v) => i.disposeData(v.dataId)), p;
  }
  function pde(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { keepDims: a, axis: o } = n;
    return il(i, o, a, "all", t);
  }
  const vde = {
    kernelName: yG,
    backendName: "webgpu",
    kernelFunc: pde
  };
  function gde(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { keepDims: a, axis: o } = n;
    return il(i, o, a, "any", t);
  }
  const mde = {
    kernelName: xG,
    backendName: "webgpu",
    kernelFunc: gde
  };
  class xz {
    constructor(e, t, n) {
      this.workgroupSize = [
        64,
        1,
        1
      ], this.variableNames = [
        "x"
      ], this.uniforms = "infinityValue : f32,", this.size = true;
      const i = [
        t
      ];
      this.op = n === "min" ? "<" : ">";
      const [a, o] = Eb(e, i);
      this.outputShape = a.length === 0 ? [
        1
      ] : a, this.dispatchLayout = de(this.outputShape), Ze(o) < 32 ? (this.type = "plain", this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize)) : (this.type = "shared", this.dispatch = ue(this.dispatchLayout, this.outputShape, [
        1,
        1,
        1
      ])), this.inputShape = e, this.shaderKey = `argMinMax_${this.op}_${this.type}`;
    }
    getUserCode() {
      const e = this.workgroupSize[0], t = () => this.inputShape.length === 1 ? "uniforms.xShape" : `uniforms.xShape.${ha(this.inputShape.length - 1)}`, n = () => {
        let i = "";
        if (this.outputShape.length === 1) this.inputShape.length !== 1 && (i += "outputCoords,");
        else for (let a = 0; a < this.outputShape.length; a++) i += `outputCoords.${ha(a)},`;
        return i;
      };
      return this.type === "shared" ? `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${se("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${n()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    ` : `
      ${se("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${n()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${n()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;
    }
  }
  function yde(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { axis: a } = n;
    let o = Ys(a, i.shape);
    const s = lf(o, i.shape.length);
    let l = i;
    const u = [];
    s != null && (l = Gi({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: s
      }
    }), u.push(l), o = uf(o.length, l.shape.length)), Nb("argMax", [
      o[0]
    ], l.shape.length);
    const c = new xz(l.shape, o[0], "max"), h = [
      {
        type: "float32",
        data: [
          Number.NEGATIVE_INFINITY
        ]
      }
    ], f = t.runWebGPUProgram(c, [
      l
    ], "int32", h);
    return u.forEach((d) => t.disposeData(d.dataId)), f;
  }
  const xde = {
    kernelName: _G,
    backendName: "webgpu",
    kernelFunc: yde
  };
  function _de(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { axis: a } = n;
    let o = Ys(a, i.shape);
    const s = lf(o, i.shape.length);
    let l = i;
    const u = [];
    s != null && (l = Gi({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: s
      }
    }), u.push(l), o = uf(o.length, l.shape.length)), Nb("argMin", [
      o[0]
    ], l.shape.length);
    const c = new xz(l.shape, o[0], "min"), h = [
      {
        type: "float32",
        data: [
          Number.POSITIVE_INFINITY
        ]
      }
    ], f = t.runWebGPUProgram(c, [
      l
    ], "int32", h);
    return u.forEach((d) => t.disposeData(d.dataId)), f;
  }
  const bde = {
    kernelName: bG,
    backendName: "webgpu",
    kernelFunc: _de
  };
  const Sde = dt({
    opType: ie.ASIN
  }), wde = {
    kernelName: SG,
    backendName: "webgpu",
    kernelFunc: Sde
  };
  const Cde = dt({
    opType: ie.ASINH
  }), Tde = {
    kernelName: wG,
    backendName: "webgpu",
    kernelFunc: Cde
  };
  const Ade = dt({
    opType: ie.ATAN
  }), Ide = {
    kernelName: CG,
    backendName: "webgpu",
    kernelFunc: Ade
  };
  const Mde = cr({
    opType: ze.ATAN2
  }), Dde = {
    kernelName: TG,
    backendName: "webgpu",
    kernelFunc: Mde
  };
  const Pde = dt({
    opType: ie.ATANH
  }), kde = {
    kernelName: AG,
    backendName: "webgpu",
    kernelFunc: Pde
  };
  class Lde {
    constructor(e) {
      this.variableNames = [
        "x"
      ], this.uniforms = "strides : vec2<i32>,", this.workgroupSize = [
        256,
        1,
        1
      ], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "poolWithFilterSizeEqualsOne";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `;
    }
  }
  class Qh {
    constructor(e, t, n = false, i = false, a = false) {
      if (this.variableNames = [
        "x"
      ], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,", this.workgroupSize = [
        128,
        1,
        1
      ], this.size = true, t === "avg" && n) throw new Error("Cannot compute positions for average pool.");
      this.outputShape = e.outShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.poolType = t, this.computePositions = n, this.flattenPositions = i, this.includeBatchIndex = a, this.shaderKey = `pool2D_${t}_${n}_${i}_${a}`;
    }
    getUserCode() {
      let e;
      this.poolType === "avg" ? e = "resultValue = resultValue + value; count = count + 1.0;" : this.computePositions ? e = `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "wR * uniforms.filterDims.y + wC"};
      }` : e = "resultValue = max(value, resultValue);";
      let t = "resultValue";
      return this.poolType === "avg" && (t = "resultValue / max(count, 1.0)"), `
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t});`}
        }
      }
    `;
    }
  }
  class ow {
    constructor(e, t, n = false, i = false, a = false) {
      if (this.variableNames = [
        "x"
      ], this.uniforms = "strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,", this.workgroupSize = [
        128,
        1,
        1
      ], this.size = true, t === "avg" && n) throw new Error("Cannot compute positions for average pool.");
      this.outputShape = e.outShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.poolType = t, this.computePositions = n, this.flattenPositions = i, this.includeBatchIndex = a, this.shaderKey = `pool3D_${t}_${n}_${i}_${a}`;
    }
    getUserCode() {
      let e;
      this.poolType === "avg" ? e = "resultValue += value; count += 1.0;" : this.computePositions ? e = `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }` : e = "resultValue = max(value, resultValue);";
      let t = "resultValue";
      return this.poolType === "avg" && (t = "resultValue / max(count, 1.0)"), `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t});`}
        }
      }
    `;
    }
  }
  function _z(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { reductionIndices: a, keepDims: o } = n;
    return il(i, a, o, "max", t);
  }
  const Rde = {
    kernelName: IG,
    backendName: "webgpu",
    kernelFunc: _z
  };
  function bz(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { keepDims: a, axis: o } = n;
    return il(i, o, a, "mean", t);
  }
  const Ede = {
    kernelName: MG,
    backendName: "webgpu",
    kernelFunc: bz
  };
  function Sz(r, e, t, n) {
    if (e.filterWidth === 1 && e.filterHeight === 1 && Au(e.inShape, e.outShape)) return ln({
      inputs: {
        x: r
      },
      backend: n
    });
    if (e.filterWidth === e.inWidth && e.filterHeight === e.inHeight && e.batchSize === 1 && e.padInfo.type === "VALID") {
      const o = r.shape.length, s = we({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          shape: [
            r.shape[o - 3] * r.shape[o - 2],
            r.shape[o - 1]
          ]
        }
      });
      let l;
      t === "avg" ? l = bz({
        inputs: {
          x: s
        },
        backend: n,
        attrs: {
          axis: 0,
          keepDims: false
        }
      }) : (Mt(t === "max", () => `Invalid pool type ${t}`), l = _z({
        inputs: {
          x: s
        },
        backend: n,
        attrs: {
          reductionIndices: 0,
          keepDims: false
        }
      }));
      const u = we({
        inputs: {
          x: l
        },
        backend: n,
        attrs: {
          shape: e.outShape
        }
      });
      return n.disposeData(s.dataId), n.disposeData(l.dataId), u;
    }
    let i;
    const a = [
      {
        type: "int32",
        data: [
          e.strideHeight,
          e.strideWidth
        ]
      }
    ];
    return e.filterHeight === 1 && e.filterWidth === 1 ? i = new Lde(e) : (t === "avg" ? i = new Qh(e, "avg") : (Mt(t === "max", () => `Invalid pool type ${t}`), i = new Qh(e, "max")), a.push({
      type: "int32",
      data: [
        e.padInfo.top,
        e.padInfo.left
      ]
    }, {
      type: "int32",
      data: [
        e.dilationHeight,
        e.dilationWidth
      ]
    }, {
      type: "int32",
      data: [
        e.inHeight,
        e.inWidth
      ]
    }, {
      type: "int32",
      data: [
        e.effectiveFilterHeight,
        e.effectiveFilterWidth
      ]
    })), n.runWebGPUProgram(i, [
      r
    ], r.dtype, a);
  }
  function Nde(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { filterSize: a, strides: o, pad: s, dimRoundingMode: l } = n, c = cf(i.shape, a, o, 1, s, l);
    return Sz(i, c, "avg", t);
  }
  const Ode = {
    kernelName: DG,
    backendName: "webgpu",
    kernelFunc: Nde
  };
  function Fde(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { filterSize: a, strides: o, pad: s, dataFormat: l, dimRoundingMode: u } = n, c = [
      1,
      1,
      1
    ], h = $v(i.shape, a, o, c, s, u, l), f = new ow(h, "avg"), d = [
      {
        type: "int32",
        data: [
          h.strideDepth,
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.padInfo.front,
          h.padInfo.top,
          h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.inDepth,
          h.inHeight,
          h.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.effectiveFilterDepth,
          h.effectiveFilterHeight,
          h.effectiveFilterWidth
        ]
      }
    ];
    return t.runWebGPUProgram(f, [
      i
    ], i.dtype, d);
  }
  const Bde = {
    kernelName: PG,
    backendName: "webgpu",
    kernelFunc: Fde
  };
  class zde {
    constructor(e) {
      this.variableNames = [
        "dy"
      ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "avgPool2DBackprop";
    }
    getUserCode() {
      return `
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  class Vde {
    constructor(e) {
      this.variableNames = [
        "dy"
      ], this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "avgPool3DBackprop";
    }
    getUserCode() {
      return `
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  function $de(r) {
    const { inputs: e, backend: t, attrs: n } = r, { dy: i, input: a } = e, o = a, { filterSize: s, strides: l, pad: u, dimRoundingMode: c } = n, h = $v(o.shape, s, l, 1, u, c), f = new Vde(h), d = 1 / (h.filterDepth * h.filterHeight * h.filterWidth), p = [
      {
        type: "int32",
        data: [
          h.strideDepth,
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.effectiveFilterDepth - 1 - h.padInfo.front,
          h.effectiveFilterHeight - 1 - h.padInfo.top,
          h.effectiveFilterWidth - 1 - h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.effectiveFilterDepth,
          h.effectiveFilterHeight,
          h.effectiveFilterWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.outDepth
        ]
      },
      {
        type: "int32",
        data: [
          h.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          h.outWidth
        ]
      },
      {
        type: "float32",
        data: [
          d
        ]
      }
    ];
    return t.runWebGPUProgram(f, [
      i
    ], o.dtype, p);
  }
  const Gde = {
    kernelName: kG,
    backendName: "webgpu",
    kernelFunc: $de
  };
  function Wde(r) {
    const { inputs: e, backend: t, attrs: n } = r, { dy: i, input: a } = e, o = a;
    gz([
      i,
      a
    ], "avgPoolGrad");
    const { filterSize: s, strides: l, pad: u } = n, c = cf(o.shape, s, l, 1, u), h = new zde(c), f = 1 / (c.filterHeight * c.filterWidth), d = [
      {
        type: "int32",
        data: [
          c.strideHeight,
          c.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.effectiveFilterHeight - 1 - c.padInfo.top,
          c.effectiveFilterWidth - 1 - c.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          c.dilationHeight,
          c.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.effectiveFilterHeight,
          c.effectiveFilterWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          c.outWidth
        ]
      },
      {
        type: "float32",
        data: [
          f
        ]
      }
    ];
    return t.runWebGPUProgram(h, [
      i
    ], o.dtype, d);
  }
  const Ude = {
    kernelName: LG,
    backendName: "webgpu",
    kernelFunc: Wde
  };
  function Hde(r) {
    const { inputs: e, backend: t, attrs: n } = r, { a: i, b: a } = e, { transposeA: o, transposeB: s } = n;
    return Eg({
      a: i,
      b: a,
      transposeA: o,
      transposeB: s,
      backend: t
    });
  }
  const Yde = {
    kernelName: RG,
    backendName: "webgpu",
    kernelFunc: Hde
  };
  class Xde {
    constructor(e, t) {
      this.variableNames = [
        "source"
      ], this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t, this.rank = t.length, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.start = e, this.uniforms = `start : ${Gt(e.length)}, `, this.shaderKey = "slice";
    }
    getUserCode() {
      const e = Gt(this.rank), t = qde(this.rank);
      let n;
      return this.start.length === 1 ? n = this.outputShape.map((a, o) => "sourceLoc = uniforms.start + coords;") : n = this.outputShape.map((a, o) => `sourceLoc.${J_[o]} = uniforms.start.${ha(o)} + coords.${J_[o]};`), `
      ${se("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${n.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `;
    }
  }
  const J_ = [
    "x",
    "y",
    "z",
    "w",
    "u",
    "v"
  ];
  function qde(r) {
    if (r === 1) return "sourceLoc";
    if (r <= 6) return J_.slice(0, r).map((e) => `sourceLoc.${e}`).join(",");
    throw Error(`Slicing for rank ${r} is not yet supported`);
  }
  function Hu(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { begin: a, size: o } = n, [s, l] = NG(i, a, o);
    if (OG(i, s, l), t.shouldExecuteOnCPU([
      i
    ]) || i.dtype === "string") {
      const h = t.tensorMap.get(i.dataId), f = Hfe(h.values, s, l, i.shape, i.dtype);
      return t.makeTensorInfo(l, i.dtype, f);
    }
    if (Ze(l) === 0) return t.makeTensorInfo(l, i.dtype, []);
    const u = new Xde(s, l), c = [
      {
        type: "int32",
        data: s
      }
    ];
    return t.runWebGPUProgram(u, [
      i
    ], i.dtype, c);
  }
  const Kde = {
    kernelName: EG,
    backendName: "webgpu",
    kernelFunc: Hu
  };
  const Zde = (r) => {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { blockShape: a, crops: o } = n;
    Mt(i.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");
    const s = a.reduce((y, x) => y * x), l = LL(i.shape, a, s), u = RL(l.length, a.length), c = EL(i.shape, a, s), h = BG(o, a.length), f = zG(c, o, a.length), d = [], p = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), v = Gi({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), g = we({
      inputs: {
        x: v
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), m = Hu({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        begin: h,
        size: f
      }
    });
    return d.push(p), d.push(v), d.push(g), d.forEach((y) => t.disposeData(y.dataId)), m;
  }, jde = {
    kernelName: FG,
    backendName: "webgpu",
    kernelFunc: Zde
  };
  const Qde = `
  fn bincount_write(index: i32, value: f32) {
    ${xo("&result[index]", "value", "float32")}
  }
`, Jde = `
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;
  class wz {
    constructor(e, t, n = false) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.uniforms = "binCountSize : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.hasWeights = true, this.binaryOutput = false, this.outputShape = e, this.rank = e.length, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.binaryOutput = n, n && (this.atomic = false), this.hasWeights = t, this.hasWeights && this.variableNames.push("w"), this.shaderKey = `bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`;
    }
    getUserCode() {
      return `
    ${this.binaryOutput ? Jde : Qde}
  ${se("index")} {
    ${this.rank === 1 ? `if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(index)" : "1."};
        bincount_write(indexVal, value);
      }
    }` : `let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(coord[0], coord[1])" : "1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `;
    }
  }
  function epe(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, weights: a } = e, { size: o } = n, s = Ze(i.shape), u = Ze(a.shape) > 0, c = [
      o
    ], h = a.dtype, f = Hr({
      backend: t,
      attrs: {
        shape: c,
        value: 0,
        dtype: h
      }
    }), d = new wz([
      s
    ], u), p = [
      {
        type: "int32",
        data: [
          o
        ]
      }
    ], v = u ? [
      i,
      a
    ] : [
      i
    ];
    return t.runWebGPUProgram(d, v, h, p, f);
  }
  const tpe = {
    kernelName: VG,
    backendName: "webgpu",
    kernelFunc: epe
  };
  class rpe {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "s0",
        "s1"
      ], this.uniforms = "s0Size : i32, s1Size : i32, ", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "broadcastArgs";
    }
    getUserCode() {
      return `
  ${se("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `;
    }
  }
  function npe(r) {
    const { inputs: e, backend: t } = r, { s0: n, s1: i } = e;
    if (t.shouldExecuteOnCPU([
      n,
      i
    ])) {
      const c = t.tensorMap.get(n.dataId), h = t.tensorMap.get(i.dataId), f = c.values, d = h.values, p = Ua(Array.from(f), Array.from(d));
      return t.makeTensorInfo([
        p.length
      ], "int32", Int32Array.from(p));
    }
    const a = Ze(n.shape), o = Ze(i.shape), s = Math.max(a, o), l = new rpe(s), u = [
      {
        type: "int32",
        data: [
          a
        ]
      },
      {
        type: "int32",
        data: [
          o
        ]
      }
    ];
    return t.runWebGPUProgram(l, [
      n,
      i
    ], "int32", u);
  }
  const ipe = {
    kernelName: $G,
    backendName: "webgpu",
    kernelFunc: npe
  };
  const Cz = cr({
    opType: ze.NOT_EQUAL,
    dtype: "bool",
    cpuKernelImpl: zfe
  }), ape = {
    kernelName: GG,
    backendName: "webgpu",
    kernelFunc: Cz
  };
  function Nf(r) {
    const { inputs: e, backend: t } = r, { input: n } = e, i = t.tensorMap.get(n.dataId);
    return ln({
      inputs: {
        x: i.complexTensorInfos.real
      },
      backend: t
    });
  }
  const ope = {
    kernelName: WG,
    backendName: "webgpu",
    kernelFunc: Nf
  };
  function spe(r, e) {
    const t = new Uu(r.shape, ie.TO_INT), n = e.runWebGPUProgram(t, [
      r
    ], "int32");
    return {
      dataId: n.dataId,
      shape: n.shape,
      dtype: n.dtype
    };
  }
  function eb(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { dtype: a } = n;
    if (a === "complex64") {
      if (i.dtype === "complex64") return ln({
        inputs: {
          x: i
        },
        backend: t
      });
      const o = HG(i.shape), s = eb({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          dtype: "float32"
        }
      }), l = nl({
        inputs: {
          real: s,
          imag: o
        },
        backend: t
      });
      return o.dispose(), t.disposeData(s.dataId), l;
    }
    if (i.dtype === "complex64") {
      const o = Nf({
        inputs: {
          input: i
        },
        backend: t
      }), s = eb({
        inputs: {
          x: o
        },
        backend: t,
        attrs: {
          dtype: a
        }
      });
      return t.disposeData(o.dataId), s;
    }
    if (!YG(i.dtype, a)) {
      const o = ln({
        inputs: {
          x: i
        },
        backend: t
      });
      return {
        dataId: o.dataId,
        shape: o.shape,
        dtype: a
      };
    }
    if (t.shouldExecuteOnCPU([
      i
    ])) {
      const o = t.tensorMap.get(i.dataId).values, [s, l, u] = xfe(o, i.shape, i.dtype, a);
      return t.makeTensorInfo(s, l, u);
    }
    if (a === "int32") return spe(i, t);
    if (a === "bool") {
      const o = t.makeTensorInfo([], "bool", kL("bool", 1)), l = Cz({
        inputs: {
          a: i,
          b: o
        },
        backend: t
      });
      return t.disposeData(o.dataId), l;
    }
    throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`);
  }
  const lpe = {
    kernelName: UG,
    backendName: "webgpu",
    kernelFunc: eb
  };
  const upe = dt({
    opType: ie.CEIL,
    cpuKernelImpl: _fe
  }), cpe = {
    kernelName: XG,
    backendName: "webgpu",
    kernelFunc: upe
  };
  class hpe {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.uniforms = "minVal : f32, maxVal : f32,", this.workPerThread = 4, this.workgroupSize = [
        64,
        1,
        1
      ], this.outputComponent = 4, this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.shaderKey = "clipVec4";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `;
    }
  }
  class fpe {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.uniforms = "minVal : f32, maxVal : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "clip";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;
    }
  }
  function dpe(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { clipValueMin: a, clipValueMax: o } = n;
    let s;
    const l = [
      {
        type: "float32",
        data: [
          a
        ]
      },
      {
        type: "float32",
        data: [
          o
        ]
      }
    ];
    return Ze(i.shape) % 4 === 0 ? s = new hpe(i.shape) : s = new fpe(i.shape), t.runWebGPUProgram(s, [
      i
    ], i.dtype, l);
  }
  const ppe = {
    kernelName: qG,
    backendName: "webgpu",
    kernelFunc: dpe
  };
  class vpe {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "real",
        "imag"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "complexAbs";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `;
    }
  }
  function CP(r, e) {
    return {
      dataId: e.dataId,
      dtype: e.dtype,
      shape: r.shape
    };
  }
  function gpe(r) {
    const { inputs: e, backend: t } = r, { x: n } = e, i = t.tensorMap.get(n.dataId), a = new vpe(n.shape), o = [
      CP(n, i.complexTensorInfos.real),
      CP(n, i.complexTensorInfos.imag)
    ];
    return t.runWebGPUProgram(a, o, o[0].dtype);
  }
  const mpe = {
    kernelName: KG,
    backendName: "webgpu",
    kernelFunc: gpe
  };
  class ype {
    constructor(e) {
      this.uniforms = "", this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = gh(e, 1), this.variableNames = e.map((t, n) => `T${n}`), this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.offsetLength = e.length - 1;
      for (let t = 0; t < this.offsetLength; t++) this.uniforms += `offset${t} : i32,`;
      this.shaderKey = "concat";
    }
    getUserCode() {
      const e = [];
      if (this.offsetLength > 0) {
        e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");
        for (let a = 1; a < this.offsetLength; a++) e.push(`else if (yC < uniforms.offset${[
          a
        ]}){ setOutputAtCoords(coords.x, coords.y, getT${a}(yR, yC - uniforms.offset${a - 1})); }`);
        const n = this.offsetLength, i = this.offsetLength - 1;
        e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${n}(yR, yC - uniforms.offset${i})); }`);
      } else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");
      return `
      ${se("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `;
    }
  }
  function Ng(r) {
    const { inputs: e, backend: t } = r, { input: n } = e, i = t.tensorMap.get(n.dataId);
    return ln({
      inputs: {
        x: i.complexTensorInfos.imag
      },
      backend: t
    });
  }
  const xpe = {
    kernelName: ZG,
    backendName: "webgpu",
    kernelFunc: Ng
  };
  function Gc(r, e, t) {
    const n = r[0].dtype;
    if (n === "complex64") {
      const p = r.map((x) => Nf({
        inputs: {
          input: x
        },
        backend: t
      })), v = r.map((x) => Ng({
        inputs: {
          input: x
        },
        backend: t
      })), g = Gc(p, e, t), m = Gc(v, e, t), y = nl({
        inputs: {
          real: g,
          imag: m
        },
        backend: t
      });
      return p.forEach((x) => t.disposeData(x.dataId)), v.forEach((x) => t.disposeData(x.dataId)), t.disposeData(g.dataId), t.disposeData(m.dataId), y;
    }
    let i = t.shouldExecuteOnCPU(r);
    if (n === "string" && (i = true), i) {
      const p = r.map((S) => {
        const w = [
          -1,
          Ze(S.shape.slice(e))
        ];
        return we({
          inputs: {
            x: S
          },
          backend: t,
          attrs: {
            shape: w
          }
        });
      }), v = p.map((S) => ({
        vals: t.readSync(S.dataId),
        shape: S.shape
      })), g = gh(p.map((S) => S.shape), 1), m = p[0].shape[0] === 1, y = bfe(v, g, n, m), x = gh(r.map((S) => S.shape), e), _ = t.makeTensorInfo(x, n, y);
      return p.forEach((S) => t.disposeData(S.dataId)), _;
    }
    const a = t.device.limits.maxStorageBuffersPerShaderStage - 1;
    if (r.length > a) {
      const p = [];
      for (let g = 0; g < r.length; g += a) {
        const m = r.slice(g, g + a);
        p.push(Gc(m, e, t));
      }
      const v = Gc(p, e, t);
      for (const g of p) t.disposeData(g.dataId);
      return v;
    }
    const { tensors2D: o, outShape: s } = _pe(r, e, t), l = o.map((p) => p.shape), u = new ype(l), c = [], h = new Array(l.length - 1);
    if (h.length > 0) {
      h[0] = l[0][1], c.push({
        type: "int32",
        data: [
          h[0]
        ]
      });
      for (let p = 1; p < h.length; p++) h[p] = h[p - 1] + l[p][1], c.push({
        type: "int32",
        data: [
          h[p]
        ]
      });
    }
    const f = t.runWebGPUProgram(u, o, o[0].dtype, c);
    o.forEach((p) => t.disposeData(p.dataId));
    const d = we({
      inputs: {
        x: f
      },
      backend: t,
      attrs: {
        shape: s
      }
    });
    return t.disposeData(f.dataId), d;
  }
  function _pe(r, e, t) {
    const n = gh(r.map((a) => a.shape), e);
    return {
      tensors2D: r.map((a) => we({
        inputs: {
          x: a
        },
        backend: t,
        attrs: {
          shape: [
            Ze(a.shape.slice(0, e)),
            Ze(a.shape.slice(e))
          ]
        }
      })),
      outShape: n
    };
  }
  function Tz(r) {
    const { inputs: e, backend: t, attrs: n } = r, { axis: i } = n, a = Ys(i, e[0].shape)[0], o = e.map((u) => u.shape);
    QG(o, a);
    const s = gh(e.map((u) => u.shape), a);
    if (Ze(s) === 0) return t.makeTensorInfo(s, e[0].dtype, []);
    const l = e.filter((u) => Ze(u.shape) > 0);
    return l.length === 1 ? ln({
      inputs: {
        x: l[0]
      },
      backend: t
    }) : Gc(l, a, t);
  }
  const bpe = {
    kernelName: jG,
    backendName: "webgpu",
    kernelFunc: Tz
  };
  function Spe(r, e, t, n, i = false, a = null, o = false, s = 4, l = 4, u = 4) {
    const c = (T) => {
      switch (T) {
        case 1:
          return "resData = f32(x[xIndex]);";
        case 3:
          return "resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";
        case 4:
          return "resData = vec4<f32>(x[xIndex / 4]);";
        default:
          throw new Error(`innerElementSize ${T} is not supported.`);
      }
    }, h = (T) => {
      switch (T) {
        case 1:
          return "return f32(W[row * uniforms.wShape[3] + col]);";
        case 4:
          return "return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";
        default:
          throw new Error(`innerElementSize ${T} is not supported.`);
      }
    }, f = r ? `
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `, d = r ? `
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      ` : `
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `, p = r ? "uniforms.xShape[1]" : "uniforms.xShape[2]", v = r ? "uniforms.xShape[2]" : "uniforms.xShape[3]", g = r ? "row" : "col", m = r ? "col" : "row", y = `
      let inChannels = uniforms.wShape[2];
      let outWidth = ${r ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${m} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${m} % inChannels;
      var resData = ${Je(s)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${v}) {
        ${f}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(s)}
      }
      return resData;`, x = r ? e && n ? `
      ${y}` : `
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${y}
      }
      return ${Je(s)}(0.0);` : n && t ? `
      ${y}` : `
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${y}
      }
      return ${Je(s)}(0.0);`, _ = `${h(l)}`, S = Je(u), b = Je(r ? s : l), w = Je(r ? l : s);
    return `
      ${Ia(a, o, u === 4, 4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${b} {
        ${r ? x : _}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${w} {
        ${r ? _ : x}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${S}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${r ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
        ${d}
        ${rl(i, a)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`;
  }
  class wpe {
    constructor(e, t, n, i, a = false, o = null, s = false, l = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = e.outShape, this.isChannelsLast = e.dataFormat === "channelsLast", this.isVec4 = ((e.inChannels % 4 === 0 || e.inChannels % 3 === 0) && this.isChannelsLast || e.outWidth % 4 === 0 && !this.isChannelsLast) && e.outChannels % 4 === 0, this.dispatchLayout = this.isChannelsLast ? {
        x: [
          3
        ],
        y: [
          1,
          2
        ],
        z: [
          0
        ]
      } : {
        x: [
          2,
          3
        ],
        y: [
          1
        ],
        z: [
          0
        ]
      }, this.workgroupSize = dz(this.dispatchLayout, this.outputShape, this.isVec4), this.elementsPerThread = pz(this.dispatchLayout, this.outputShape, this.isVec4), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), this.isVec4 ? (this.outputComponent = 4, this.isChannelsLast && e.inChannels % 4 !== 0 ? (this.innerElementSize = 3, this.variableComponents = [
        1,
        4
      ]) : (this.innerElementSize = 4, this.variableComponents = [
        4,
        4
      ]), a && (this.variableNames.push("bias"), this.variableComponents.push(4)), s && (this.variableNames.push("preluActivationWeights"), this.variableComponents.push(4))) : (this.innerElementSize = this.elementsPerThread[0], a && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights")), this.sequentialAccessByThreads = l, this.addBias = a, this.activation = o, this.hasPreluActivationWeights = s, this.tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1], this.tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0], this.tileInner = Math.max(this.workgroupSize[0] * this.innerElementSize, this.workgroupSize[1]), this.fitAOuter = t % this.tileAOuter === 0, this.fitBOuter = n % this.tileBOuter === 0, this.fitInner = i % this.tileInner === 0, this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`;
    }
    getUserCode() {
      const e = this.isVec4 ? Lg(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner) : Rg(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner, false, null, this.sequentialAccessByThreads), t = this.isVec4 ? [
        this.innerElementSize,
        4,
        4
      ] : [
        1,
        1,
        1
      ];
      return `
    ${Spe(this.isChannelsLast, this.fitAOuter, this.fitBOuter, this.fitInner, this.addBias, this.activation, this.hasPreluActivationWeights, t[0], t[1], t[2])}
    ${e}
  `;
    }
  }
  class Cpe {
    constructor(e, t = false, n = null, i = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,", this.workgroupSize = [
        4,
        4,
        8
      ], this.outputShape = e.outShape, this.isChannelsLast = e.dataFormat === "channelsLast", this.dispatchLayout = this.isChannelsLast ? {
        x: [
          2
        ],
        y: [
          1
        ],
        z: [
          0,
          3
        ]
      } : {
        x: [
          3
        ],
        y: [
          2
        ],
        z: [
          0,
          1
        ]
      }, this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.addBias = t, this.activation = n, this.hasPreluActivationWeights = i, t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.shaderKey = `conv2dnaive_${this.activation}_${this.isChannelsLast}`;
    }
    getUserCode() {
      return `
       ${Ia(this.activation, this.hasPreluActivationWeights, false, 4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast ? "vec4<i32>(batch, row, col, chan);" : "vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${rl(this.addBias, this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${se("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast ? "coords[3];" : "coords[1];"}
         let outRow = ${this.isChannelsLast ? "coords[1];" : "coords[2];"}
         let outCol = ${this.isChannelsLast ? "coords[2];" : "coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast ? "uniforms.xShape[3];" : "uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast ? "let v = readInp(batch, xRow, xCol, xChannel);" : "let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `;
    }
  }
  class Tpe {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.uniforms = `pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = t, this.shaderKey = `im2col_${this.isChannelsLast}`;
    }
    getUserCode() {
      const e = this.isChannelsLast ? 1 : 2, t = this.isChannelsLast ? 2 : 3, n = this.isChannelsLast ? "coords[1]" : "coords[2]", i = this.isChannelsLast ? "coords[2]" : "coords[1]", a = this.isChannelsLast ? "getX(batch, xRow, xCol, ch)" : "getX(batch, ch, xRow, xCol)";
      return `
    ${se("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${n};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${a};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `;
    }
  }
  function Ev(r, e) {
    const t = r.length;
    return t >= 3 ? e ? [
      ...r.slice(0, -3),
      r[t - 3] * r[t - 2],
      r[t - 1]
    ] : [
      ...r.slice(0, -3),
      r[t - 3],
      r[t - 2] * r[t - 1]
    ] : !e && t === 1 && r[0] > 1 ? [
      r[0],
      1
    ] : null;
  }
  function Ape({ x: r, filter: e, convInfo: t, backend: n, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: o = 0, activation: s = null }) {
    const l = t.dataFormat === "channelsLast", u = !l, c = false, h = l && t.filterHeight === t.inHeight && t.filterWidth === t.inWidth && t.padInfo.type === "VALID", f = [];
    let d, p;
    if (h) {
      const m = t.inHeight * t.inWidth * t.inChannels;
      d = we({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          shape: [
            1,
            t.batchSize,
            m
          ]
        }
      }), p = we({
        inputs: {
          x: e
        },
        backend: n,
        attrs: {
          shape: [
            1,
            m,
            t.outChannels
          ]
        }
      });
    } else d = we({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: l ? [
          t.batchSize,
          t.inHeight * t.inWidth,
          t.inChannels
        ] : [
          t.batchSize,
          t.inChannels,
          t.inHeight * t.inWidth
        ]
      }
    }), p = we({
      inputs: {
        x: e
      },
      backend: n,
      attrs: {
        shape: [
          1,
          t.inChannels,
          t.outChannels
        ]
      }
    });
    if (f.push(d), f.push(p), a != null) {
      const m = Ev(a.shape, l);
      m != null && (a = we({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: m
        }
      }), f.push(a));
    }
    if (i != null) {
      const m = Ev(i.shape, l);
      m != null && (i = we({
        inputs: {
          x: i
        },
        backend: n,
        attrs: {
          shape: m
        }
      }), f.push(i));
    }
    const v = Eg({
      a: l ? d : p,
      b: l ? p : d,
      transposeA: u,
      transposeB: c,
      backend: n,
      bias: i,
      activation: s,
      preluActivationWeights: a,
      leakyreluAlpha: o
    }), g = we({
      inputs: {
        x: v
      },
      backend: n,
      attrs: {
        shape: t.outShape
      }
    });
    f.push(v);
    for (const m of f) n.disposeData(m.dataId);
    return g;
  }
  function Ipe({ x: r, filter: e, convInfo: t, backend: n, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: o = 0, activation: s = null }) {
    const { filterWidth: l, filterHeight: u, inChannels: c, strideWidth: h, strideHeight: f, padInfo: d, outWidth: p, outHeight: v, dilationWidth: g, dilationHeight: m, dataFormat: y } = t, x = y === "channelsLast", _ = l * u * c, S = v * p, b = x ? [
      t.batchSize,
      S,
      _
    ] : [
      t.batchSize,
      _,
      S
    ], w = new Tpe(b, x), C = [
      {
        type: "int32",
        data: [
          d.top,
          d.left
        ]
      },
      {
        type: "int32",
        data: [
          f,
          h
        ]
      },
      {
        type: "int32",
        data: [
          m,
          g
        ]
      },
      {
        type: "int32",
        data: [
          p
        ]
      },
      {
        type: "int32",
        data: [
          c * l
        ]
      },
      {
        type: "int32",
        data: [
          c
        ]
      }
    ], T = n.runWebGPUProgram(w, [
      r
    ], r.dtype, C), A = [];
    A.push(T);
    const M = we({
      inputs: {
        x: e
      },
      backend: n,
      attrs: {
        shape: [
          1,
          _,
          -1
        ]
      }
    });
    if (A.push(M), a != null) {
      const I = Ev(a.shape, x);
      I != null && (a = we({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: I
        }
      }), A.push(a));
    }
    if (i != null) {
      const I = Ev(i.shape, x);
      I != null && (i = we({
        inputs: {
          x: i
        },
        backend: n,
        attrs: {
          shape: I
        }
      }), A.push(i));
    }
    const R = Eg({
      a: x ? T : M,
      b: x ? M : T,
      transposeA: !x,
      transposeB: false,
      backend: n,
      bias: i,
      activation: s,
      preluActivationWeights: a,
      leakyreluAlpha: o
    }), N = we({
      inputs: {
        x: R
      },
      backend: n,
      attrs: {
        shape: t.outShape
      }
    });
    A.push(R);
    for (const I of A) n.disposeData(I.dataId);
    return N;
  }
  function Az({ x: r, filter: e, convInfo: t, backend: n, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: o = 0, activation: s = null }) {
    const l = i != null, u = a != null, c = t.dataFormat === "channelsLast", h = c && t.filterHeight === t.inHeight && t.filterWidth === t.inWidth && t.padInfo.type === "VALID", f = rr().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");
    if (!f && (h || t.filterHeight === 1 && t.filterWidth === 1 && t.dilationHeight === 1 && t.dilationWidth === 1 && t.strideHeight === 1 && t.strideWidth === 1 && (t.padInfo.type === "SAME" || t.padInfo.type === "VALID"))) return Ape({
      x: r,
      filter: e,
      convInfo: t,
      backend: n,
      bias: i,
      activation: s,
      preluActivationWeights: a,
      leakyreluAlpha: o
    });
    const d = rr().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), p = d > -1 ? d : n.thresholdToIncreaseWorkgroups, v = t.batchSize * Math.ceil(t.outHeight * t.outWidth / 32) * Math.ceil(t.outChannels / 32);
    if (rr().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER") || v <= p) return Ipe({
      x: r,
      filter: e,
      convInfo: t,
      backend: n,
      bias: i,
      preluActivationWeights: a,
      leakyreluAlpha: o,
      activation: s
    });
    let g;
    const m = [
      t.padInfo.top,
      t.padInfo.left
    ], y = [
      {
        type: "int32",
        data: [
          t.filterHeight,
          t.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          ...m
        ]
      },
      {
        type: "int32",
        data: [
          t.strideHeight,
          t.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          t.dilationHeight,
          t.dilationWidth
        ]
      }
    ];
    if (f) g = new Cpe(t, l, s, u);
    else {
      const b = c ? t.outHeight * t.outWidth : t.outChannels, w = c ? t.outChannels : t.outHeight * t.outWidth, C = t.filterHeight * t.filterWidth * t.inChannels;
      y.push({
        type: "int32",
        data: [
          b
        ]
      }, {
        type: "int32",
        data: [
          w
        ]
      }, {
        type: "int32",
        data: [
          C
        ]
      });
      const T = n.adapterInfo.isIntel();
      g = new wpe(t, b, w, C, l, s, u, T);
    }
    const x = [], _ = [
      r,
      e
    ];
    l && (!c && i.shape.length === 1 && (i = we({
      inputs: {
        x: i
      },
      backend: n,
      attrs: {
        shape: [
          i.shape[0],
          1,
          1
        ]
      }
    }), x.push(i)), _.push(i)), u && (!c && a.shape.length === 1 && (a = we({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: [
          a.shape[0],
          1,
          1
        ]
      }
    }), x.push(a)), _.push(a)), s === "leakyrelu" && (y.push({
      type: "float32",
      data: [
        o
      ]
    }), g.uniforms += " alpha : f32,");
    const S = n.runWebGPUProgram(g, _, r.dtype, y);
    for (const b of x) n.disposeData(b.dataId);
    return S;
  }
  function Mpe(r) {
    const { inputs: e, attrs: t, backend: n } = r, { x: i, filter: a } = e, { strides: o, pad: s, dataFormat: l, dilations: u, dimRoundingMode: c } = t, h = hf(l), f = go(i.shape, a.shape, o, u, s, c, false, h);
    return Az({
      x: i,
      filter: a,
      convInfo: f,
      backend: n
    });
  }
  const Dpe = {
    kernelName: JG,
    backendName: "webgpu",
    kernelFunc: Mpe
  };
  class Ppe {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = false, this.isVec4 = false, this.workPerThread = 1, this.outputShape = e.inShape, this.isChannelsLast = e.dataFormat === "channelsLast", this.isVec4 = this.isChannelsLast && e.outChannels % 4 === 0 && e.inChannels % 4 === 0, this.isVec4 ? (this.workPerThread = 2, this.outputComponent = 4, this.workgroupSize = [
        4,
        4,
        4
      ], this.dispatchLayout = {
        x: [
          3
        ],
        y: [
          2
        ],
        z: [
          0,
          1
        ]
      }, this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        4,
        this.workPerThread,
        1
      ])) : (this.size = true, this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize)), this.shaderKey = `conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`;
    }
    getUserCode() {
      const e = this.isChannelsLast ? 1 : 2, t = this.isChannelsLast ? 2 : 3, n = this.isChannelsLast ? 3 : 1, i = `
    ${se()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;
      return this.isVec4 ? `
    ${i}
    ` : `
    ${se("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast ? "getDy(batch, idyR, idyC, d2)" : "getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  }
  class kpe {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.uniforms = "pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.filterShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = e.dataFormat === "channelsLast", this.shaderKey = `conv2DDerFilter_${this.isChannelsLast}`;
    }
    getUserCode() {
      return `
    ${se("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  }
  class Lpe {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.uniforms = `pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.filterShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3DDerFilter";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  }
  class Rpe {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.uniforms = `filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3DDerInput";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  }
  function Epe(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, dy: a } = e, { strides: o, pad: s, dataFormat: l, dimRoundingMode: u, filterShape: c } = n, h = hf(l), f = go(i.shape, c, o, 1, s, u, false, h), d = new kpe(f), p = [
      {
        type: "int32",
        data: [
          f.padInfo.top,
          f.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          f.strideHeight,
          f.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.batchSize
        ]
      },
      {
        type: "int32",
        data: [
          f.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          f.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.inHeight
        ]
      },
      {
        type: "int32",
        data: [
          f.inWidth
        ]
      }
    ];
    return t.runWebGPUProgram(d, [
      i,
      a
    ], i.dtype, p);
  }
  const Npe = {
    kernelName: e5,
    backendName: "webgpu",
    kernelFunc: Epe
  };
  function Ope(r = 4) {
    const e = (a) => {
      switch (a) {
        case 1:
          return "return W[getIndexFromCoords4D(coord, uniforms.wShape)];";
        case 4:
          return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;
        default:
          throw new Error(`innerElementSize ${a} is not supported.`);
      }
    }, n = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Je(r)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Je(r)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${r}];`}
      }
      return ${Je(r)}(0.0);`;
    return `
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Je(r)} {
    ${n}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Je(r)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(r)}
    }
    return ${Je(r)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Je(r)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${r}] = value;
    }
  }`;
  }
  class Fpe {
    constructor(e) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = e.inShape, Mt(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), this.isVec4 = e.inChannels % 4 === 0 && e.outChannels % 4 === 0, this.dispatchLayout = {
        x: [
          3
        ],
        y: [
          1,
          2
        ],
        z: [
          0
        ]
      }, this.workgroupSize = dz(this.dispatchLayout, this.outputShape, this.isVec4), this.elementsPerThread = pz(this.dispatchLayout, this.outputShape, this.isVec4), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), this.isVec4 && (this.outputComponent = 4, this.variableComponents = [
        4,
        1
      ]), this.shaderKey = `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;
    }
    getUserCode() {
      const e = this.isVec4 ? Lg(this.elementsPerThread, this.workgroupSize) : Rg(this.elementsPerThread, this.workgroupSize);
      return `
    ${Ope(this.isVec4 ? 4 : 1)}
    ${e}
    `;
    }
  }
  function Bpe(r) {
    const { inputs: e, backend: t, attrs: n } = r, { dy: i, filter: a } = e, { inputShape: o, strides: s, pad: l, dataFormat: u, dimRoundingMode: c } = n, h = hf(u), f = go(o, a.shape, s, 1, l, c, false, h), d = [
      {
        type: "int32",
        data: [
          f.filterHeight,
          f.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.filterHeight - 1 - f.padInfo.top,
          f.filterWidth - 1 - f.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          f.strideHeight,
          f.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.batchSize,
          f.outHeight,
          f.outWidth,
          f.outChannels
        ]
      }
    ];
    let p;
    if (rr().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE") || f.dataFormat !== "channelsLast") p = new Ppe(f);
    else {
      p = new Fpe(f);
      const v = f.inHeight * f.inWidth, g = f.inChannels, m = f.filterHeight * f.filterWidth * f.outChannels;
      d.push({
        type: "uint32",
        data: [
          v
        ]
      }, {
        type: "uint32",
        data: [
          g
        ]
      }, {
        type: "uint32",
        data: [
          m
        ]
      });
    }
    return t.runWebGPUProgram(p, [
      i,
      a
    ], "float32", d);
  }
  const zpe = {
    kernelName: t5,
    backendName: "webgpu",
    kernelFunc: Bpe
  };
  class Vpe {
    constructor(e) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3dnaive";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`;
    }
  }
  function $pe(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, filter: a } = e, { strides: o, pad: s, dilations: l } = n, u = Ob(i.shape, a.shape, o, l, s), c = [
      u.padInfo.front,
      u.padInfo.top,
      u.padInfo.left
    ], h = [
      {
        type: "int32",
        data: [
          u.filterDepth,
          u.filterHeight,
          u.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          ...c
        ]
      },
      {
        type: "int32",
        data: [
          u.strideDepth,
          u.strideHeight,
          u.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.dilationDepth,
          u.dilationHeight,
          u.dilationWidth
        ]
      }
    ], f = new Vpe(u), d = vh(i.dtype, a.dtype);
    return t.runWebGPUProgram(f, [
      i,
      a
    ], d, h);
  }
  const Gpe = {
    kernelName: r5,
    backendName: "webgpu",
    kernelFunc: $pe
  };
  function Wpe(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, dy: a } = e, { strides: o, pad: s, filterShape: l } = n, u = Ob(i.shape, l, o, 1, s), c = new Lpe(u), h = [
      {
        type: "int32",
        data: [
          u.padInfo.front,
          u.padInfo.top,
          u.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          u.strideDepth,
          u.strideHeight,
          u.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.batchSize
        ]
      },
      {
        type: "int32",
        data: [
          u.outDepth
        ]
      },
      {
        type: "int32",
        data: [
          u.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          u.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.inDepth
        ]
      },
      {
        type: "int32",
        data: [
          u.inHeight
        ]
      },
      {
        type: "int32",
        data: [
          u.inWidth
        ]
      }
    ];
    return t.runWebGPUProgram(c, [
      i,
      a
    ], a.dtype, h);
  }
  const Upe = {
    kernelName: n5,
    backendName: "webgpu",
    kernelFunc: Wpe
  };
  function Hpe(r) {
    const { inputs: e, backend: t, attrs: n } = r, { dy: i, filter: a } = e, { strides: o, pad: s, inputShape: l } = n, u = Ob(l, a.shape, o, 1, s), c = new Rpe(u), h = [
      {
        type: "int32",
        data: [
          u.filterDepth,
          u.filterHeight,
          u.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.filterDepth - 1 - u.padInfo.front,
          u.filterHeight - 1 - u.padInfo.top,
          u.filterWidth - 1 - u.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          u.strideDepth,
          u.strideHeight,
          u.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.outDepth
        ]
      },
      {
        type: "int32",
        data: [
          u.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          u.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.outChannels
        ]
      }
    ];
    return t.runWebGPUProgram(c, [
      i,
      a
    ], i.dtype, h);
  }
  const Ype = {
    kernelName: i5,
    backendName: "webgpu",
    kernelFunc: Hpe
  };
  const Xpe = dt({
    opType: ie.COS
  }), qpe = {
    kernelName: a5,
    backendName: "webgpu",
    kernelFunc: Xpe
  };
  const Kpe = dt({
    opType: ie.COSH
  }), Zpe = {
    kernelName: o5,
    backendName: "webgpu",
    kernelFunc: Kpe
  };
  class jpe {
    constructor(e, t, n, i) {
      this.variableNames = [
        "Image",
        "Boxes",
        "BoxInd"
      ], this.uniforms = "extrapolationValue : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true;
      const [a] = t;
      this.outputShape = [
        a,
        n[0],
        n[1],
        e
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.methodId = i === "bilinear" ? 1 : 0, this.cropHeightBiggerThan1 = this.outputShape[1] > 1, this.cropWidthBiggerThan1 = this.outputShape[2] > 1, this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;
    }
    getUserCode() {
      const [e, t] = [
        "f32(uniforms.imageShape[1] - 1)",
        "f32(uniforms.imageShape[2] - 1)"
      ], [n, i, a] = this.cropHeightBiggerThan1 ? [
        `(${e} / f32(uniforms.outShape[1] - 1))`,
        "(y2-y1) * height_ratio",
        `y1*${e} + f32(y)*(height_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (y1+y2) * ${e}`
      ], [o, s, l] = this.cropWidthBiggerThan1 ? [
        `(${t} / f32(uniforms.outShape[2] - 1))`,
        "(x2-x1) * width_ratio",
        `x1*${t} + f32(x)*(width_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (x1+x2) * ${t}`
      ];
      return `
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${s};
        let in_y = ${a};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `;
    }
  }
  const Qpe = (r) => {
    const { inputs: e, backend: t, attrs: n } = r, { image: i, boxes: a, boxInd: o } = e, { cropSize: s, method: l, extrapolationValue: u } = n, c = new jpe(i.shape[3], a.shape, s, l), h = [
      {
        type: "float32",
        data: [
          u
        ]
      }
    ];
    return t.runWebGPUProgram(c, [
      i,
      a,
      o
    ], "float32", h);
  }, Jpe = {
    kernelName: s5,
    backendName: "webgpu",
    kernelFunc: Qpe
  };
  var Jh;
  (function(r) {
    r.Prod = "*", r.Sum = "+";
  })(Jh || (Jh = {}));
  class TP {
    constructor(e, t, n, i) {
      this.variableNames = [
        "x"
      ], this.uniforms = "index : f32,", this.size = true, this.workgroupSize = [
        128,
        1,
        1
      ], this.outputShape = t, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.exclusive = n, this.reverse = i, this.op = e, this.shaderKey = `cum_${this.op}_${this.exclusive}_${this.reverse}`;
    }
    getUserCode() {
      const e = this.outputShape.length, t = this.op === Jh.Prod ? "1.0" : "0.0", n = this.exclusive ? t : `getX(${AP(e, "coords", this.op)})`, i = this.outputShape[this.outputShape.length - 1];
      let a = "", o = "";
      return this.exclusive ? (a = this.reverse ? `end != ${i - 1}` : "end != 0", o = this.reverse ? "end + 1" : "end - 1") : (a = this.reverse ? `end + pow2 < ${i}` : "end >= pow2", o = this.reverse ? "end + pow2" : "end - pow2"), `
      ${se("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${IP(e, "coords", this.op)};
         var val = ${n};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${a}) {
           let idx = ${o};
           ${IP(e, "coords", this.op)} = idx;
           val ${this.op}= getX(${AP(e, "coords", this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `;
    }
  }
  function AP(r, e, t) {
    if (r === 1) return `${e}`;
    if (r === 2) return `${e}.x, ${e}.y`;
    if (r === 3) return `${e}.x, ${e}.y, ${e}.z`;
    if (r === 4) return `${e}.x, ${e}.y, ${e}.z, ${e}.w`;
    throw Error(`Cumulative ${t} for rank ${r} is not yet supported`);
  }
  function IP(r, e, t) {
    if (r === 1) return `${e}`;
    if (r === 2) return `${e}.y`;
    if (r === 3) return `${e}.z`;
    if (r === 4) return `${e}.w`;
    throw Error(`Cumulative ${t} for rank ${r} is not yet supported`);
  }
  function Iz(r, e, t, n, i, a) {
    const o = e.shape.length, s = lf([
      n
    ], o);
    let l = e;
    s != null && (l = Gi({
      inputs: {
        x: e
      },
      backend: t,
      attrs: {
        perm: s
      }
    }));
    const u = uf(1, o)[0];
    if (u !== o - 1) throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length - 1} but got axis=${n}`);
    const c = l.shape[u];
    let h = ln({
      inputs: {
        x: l
      },
      backend: t
    });
    for (let f = 0; f <= Math.ceil(Math.log2(c)) - 1; f++) {
      const d = new TP(r, l.shape, false, a), p = h, v = [
        {
          type: "float32",
          data: [
            f
          ]
        }
      ];
      h = t.runWebGPUProgram(d, [
        h
      ], h.dtype, v), t.disposeData(p.dataId);
    }
    if (i) {
      const f = new TP(r, l.shape, i, a), d = h, p = [
        {
          type: "float32",
          data: [
            0
          ]
        }
      ];
      h = t.runWebGPUProgram(f, [
        h
      ], h.dtype, p), t.disposeData(d.dataId);
    }
    if (s != null) {
      const f = NL(s), d = Gi({
        inputs: {
          x: h
        },
        backend: t,
        attrs: {
          perm: f
        }
      });
      return t.disposeData(h.dataId), t.disposeData(l.dataId), d;
    }
    return h;
  }
  function eve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { axis: a, exclusive: o, reverse: s } = n;
    return Iz(Jh.Prod, i, t, a, o, s);
  }
  const tve = {
    kernelName: l5,
    backendName: "webgpu",
    kernelFunc: eve
  };
  function rve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { axis: a, exclusive: o, reverse: s } = n;
    return Iz(Jh.Sum, i, t, a, o, s);
  }
  const nve = {
    kernelName: u5,
    backendName: "webgpu",
    kernelFunc: rve
  };
  function ive(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, weights: a } = e, { size: o, binaryOutput: s } = n, l = i.shape.length === 1, c = Ze(a.shape) > 0, h = a.dtype, f = l ? [
      i.shape[0]
    ] : [
      i.shape[0],
      i.shape[1]
    ], d = l ? [
      o
    ] : [
      i.shape[0],
      o
    ], p = Hr({
      backend: t,
      attrs: {
        shape: d,
        value: 0,
        dtype: h
      }
    }), v = new wz(f, c, s), g = [
      {
        type: "int32",
        data: [
          o
        ]
      }
    ], m = c ? [
      i,
      a
    ] : [
      i
    ];
    return t.runWebGPUProgram(v, m, h, g, p);
  }
  const ave = {
    kernelName: c5,
    backendName: "webgpu",
    kernelFunc: ive
  };
  class ove {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.uniforms = "blockSize : i32,", this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `depthToSpace_${t}`, this.dataFormat = t;
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`;
    }
    getHeightCoordString() {
      return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
      return this.dataFormat === "NHWC" ? "uniforms.outShape[3]" : "uniforms.outShape[1]";
    }
    getInputSamplingString() {
      return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
  }
  function sve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { blockSize: a, dataFormat: o } = n, s = i.shape[0], l = o === "NHWC" ? i.shape[1] : i.shape[2], u = o === "NHWC" ? i.shape[2] : i.shape[3], c = o === "NHWC" ? i.shape[3] : i.shape[1], h = l * a, f = u * a, d = c / (a * a), p = o === "NHWC" ? [
      s,
      h,
      f,
      d
    ] : [
      s,
      d,
      h,
      f
    ], v = [
      {
        type: "int32",
        data: [
          a
        ]
      }
    ], g = new ove(p, o);
    return t.runWebGPUProgram(g, [
      i
    ], i.dtype, v);
  }
  const lve = {
    kernelName: h5,
    backendName: "webgpu",
    kernelFunc: sve
  };
  class uve {
    constructor(e, t, n, i = false, a = null, o = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>,", this.workgroupSize = [
        16,
        16,
        1
      ], this.outputShape = e, this.dispatchLayout = {
        x: [
          3
        ],
        y: [
          2
        ],
        z: [
          0,
          1
        ]
      }, this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), i && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), this.addBias = i, this.activation = a, this.hasPreluActivation = o, this.filterHeight = t, this.filterWidth = n, this.shaderKey = `depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`;
    }
    getUserCode() {
      const e = this.filterWidth * this.filterHeight, t = this.workgroupSize[0] * this.workgroupSize[1] * this.workgroupSize[2], n = this.workgroupSize[1] + this.filterHeight - 1, i = this.workgroupSize[0] + this.filterWidth - 1;
      return `
      ${Ia(this.activation, this.hasPreluActivation, false, 4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${n}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${se()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e < t ? `if (wIndex < ${e})` : `for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${rl(this.addBias, this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    }
  }
  class Mz {
    constructor(e, t = false, n = null, i = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.workPerThread = 4, this.outputComponent = 4, this.outputShape = e.outShape, this.virtualWidth = Math.ceil(this.outputShape[2] / this.workPerThread) * this.workPerThread;
      const a = [
        this.outputShape[0],
        this.outputShape[1],
        this.virtualWidth,
        this.outputShape[3]
      ];
      this.dispatchLayout = de(a), this.dispatch = ue(this.dispatchLayout, a, this.workgroupSize, [
        this.outputComponent * this.workPerThread,
        1,
        1
      ]), Mt(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.convInfo = e, this.addBias = t, this.activation = n, this.hasPreluActivation = i, this.shaderKey = `depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`;
    }
    getUserCode() {
      const e = (this.workPerThread - 1) * this.convInfo.strideWidth + this.convInfo.filterWidth, t = this.convInfo.strideHeight, n = this.convInfo.strideWidth;
      return `
      ${Ia(this.activation, this.hasPreluActivation, true, 4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${se("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${rl(this.addBias, this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `;
    }
  }
  class Dz {
    constructor(e, t = false, n = null, i = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = `pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`, this.workgroupSize = [
        256,
        1,
        1
      ], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = e.dataFormat === "channelsLast", t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.convInfo = e, this.addBias = t, this.activation = n, this.hasPreluActivation = i, this.shaderKey = `depthwise_${this.activation}_${this.isChannelsLast}`;
    }
    getUserCode() {
      const e = this.isChannelsLast ? "getX(batch, xR, xC, d1);" : "getX(batch, d1, xR, xC);";
      return `
      ${Ia(this.activation, this.hasPreluActivation, false, 4)}

      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast ? "yz" : "zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast ? 3 : 1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${rl(this.addBias, this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    }
  }
  function cve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, filter: a } = e, { strides: o, pad: s, dataFormat: l, dilations: u, dimRoundingMode: c } = n, h = hf(l);
    let f = u;
    f == null && (f = [
      1,
      1
    ]);
    const d = go(i.shape, a.shape, o, f, s, c, true, h), p = [
      {
        type: "int32",
        data: [
          d.padInfo.top,
          d.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          d.inHeight,
          d.inWidth
        ]
      }
    ], v = d.dataFormat === "channelsLast";
    let g;
    return !v && d.inHeight > 16 && d.inWidth > 16 && d.strideHeight === 1 && d.strideWidth === 1 && d.dilationWidth === 1 && d.dilationHeight === 1 && d.inChannels === d.outChannels ? g = new uve(d.outShape, d.filterHeight, d.filterWidth) : v && d.outHeight > 4 && d.outWidth > 4 && d.strideWidth <= 2 && d.inChannels === d.outChannels && d.dilationHeight === 1 && d.dilationWidth === 1 && d.inChannels % 4 === 0 ? (g = new Mz(d), p.push({
      type: "int32",
      data: [
        g.virtualWidth
      ]
    })) : (g = new Dz(d), p.push({
      type: "int32",
      data: [
        d.filterHeight
      ]
    }, {
      type: "int32",
      data: [
        d.filterWidth
      ]
    }, {
      type: "int32",
      data: [
        d.strideHeight,
        d.strideWidth
      ]
    }, {
      type: "int32",
      data: [
        d.dilationHeight,
        d.dilationWidth
      ]
    })), t.runWebGPUProgram(g, [
      i,
      a
    ], i.dtype, p);
  }
  const hve = {
    kernelName: f5,
    backendName: "webgpu",
    kernelFunc: cve
  };
  class fve {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.filterShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthwise_conv2d_backprop_filter";
    }
    getUserCode() {
      return `
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  class dve {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthwise_conv2d_backprop_input";
    }
    getUserCode() {
      return `
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  function pve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, dy: a } = e, { strides: o, dilations: s, pad: l, dimRoundingMode: u, filterShape: c } = n, h = go(i.shape, c, o, s, l, u, true), f = new fve(h), d = [
      {
        type: "int32",
        data: [
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.padInfo.top,
          h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.filterHeight,
          h.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          h.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.inHeight
        ]
      },
      {
        type: "int32",
        data: [
          h.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.batchSize
        ]
      },
      {
        type: "int32",
        data: [
          h.outChannels / h.inChannels
        ]
      }
    ];
    return t.runWebGPUProgram(f, [
      i,
      a
    ], "float32", d);
  }
  const vve = {
    kernelName: d5,
    backendName: "webgpu",
    kernelFunc: pve
  };
  function gve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { dy: i, filter: a } = e, { strides: o, dilations: s, pad: l, dimRoundingMode: u, inputShape: c } = n, h = go(c, a.shape, o, s, l, u, true), f = new dve(h), d = [
      {
        type: "int32",
        data: [
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.filterHeight - 1 - h.padInfo.top,
          h.filterWidth - 1 - h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.filterHeight,
          h.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          h.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.outChannels / h.inChannels
        ]
      }
    ];
    return t.runWebGPUProgram(f, [
      i,
      a
    ], i.dtype, d);
  }
  const mve = {
    kernelName: p5,
    backendName: "webgpu",
    kernelFunc: gve
  };
  class yve {
    constructor(e) {
      this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e,
        e
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "diag";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `;
    }
  }
  function xve(r) {
    const { inputs: e, backend: t } = r, { x: n } = e, i = [
      ...n.shape,
      ...n.shape
    ], a = Ze(n.shape), o = we({
      inputs: {
        x: n
      },
      backend: t,
      attrs: {
        shape: [
          a
        ]
      }
    }), s = new yve(a), l = t.runWebGPUProgram(s, [
      o
    ], o.dtype), u = we({
      inputs: {
        x: l
      },
      backend: t,
      attrs: {
        shape: i
      }
    });
    return t.disposeData(o.dataId), t.disposeData(l.dataId), u;
  }
  const _ve = {
    kernelName: v5,
    backendName: "webgpu",
    kernelFunc: xve
  };
  class bve {
    constructor(e) {
      this.variableNames = [
        "x",
        "w"
      ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "dilation2d";
    }
    getUserCode() {
      return `
       ${se("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `;
    }
  }
  function Sve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, filter: a } = e, { strides: o, pad: s, dilations: l } = n, u = Fb(i.shape, a.shape, o, s, "NHWC", l), c = [
      u.padInfo.top,
      u.padInfo.left
    ], h = [
      {
        type: "int32",
        data: [
          u.filterHeight,
          u.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          ...c
        ]
      },
      {
        type: "int32",
        data: [
          u.strideHeight,
          u.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.dilationHeight,
          u.dilationWidth
        ]
      }
    ], f = new bve(u);
    return t.runWebGPUProgram(f, [
      i,
      a
    ], i.dtype, h);
  }
  const wve = {
    kernelName: g5,
    backendName: "webgpu",
    kernelFunc: Sve
  };
  class Cve {
    constructor(e, t) {
      if (this.variableNames = [
        "x",
        "w",
        "dy"
      ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = e.inShape, this.dispatchLayout = de(e.outShape), this.dispatch = ue(this.dispatchLayout, e.outShape, this.workgroupSize), t !== "float32" && t !== "int32") throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);
      this.type = t, this.shaderKey = "dilation2DBackpropInput";
    }
    getUserCode() {
      return `
       ${se("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${xo("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    }
  }
  class Tve {
    constructor(e, t, n) {
      if (this.variableNames = [
        "x",
        "w",
        "dy"
      ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = e.filterShape, this.dispatchLayout = de(e.outShape), this.dispatch = ue(this.dispatchLayout, e.outShape, this.workgroupSize), n !== "float32" && n !== "int32") throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${n} type.`);
      this.type = n, this.shaderKey = "dilation2DBackpropFilter";
    }
    getUserCode() {
      return `
       ${se("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${xo("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    }
  }
  function Ave(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, filter: a, dy: o } = e, { strides: s, pad: l, dilations: u } = n, c = Fb(i.shape, a.shape, s, l, "NHWC", u), h = a.dtype, f = new Tve(c, a.shape, h), d = [
      {
        type: "int32",
        data: [
          c.filterHeight,
          c.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.padInfo.top,
          c.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          c.strideHeight,
          c.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.dilationHeight,
          c.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          Ze(c.outShape)
        ]
      }
    ], p = Hr({
      backend: t,
      attrs: {
        shape: a.shape,
        value: 0,
        dtype: h
      }
    });
    return t.runWebGPUProgram(f, [
      i,
      a,
      o
    ], h, d, p);
  }
  const Ive = {
    kernelName: m5,
    backendName: "webgpu",
    kernelFunc: Ave
  };
  function Mve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, filter: a, dy: o } = e, { strides: s, pad: l, dilations: u } = n, c = Fb(i.shape, a.shape, s, l, "NHWC", u), h = i.dtype, f = new Cve(c, h), d = [
      {
        type: "int32",
        data: [
          c.filterHeight,
          c.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.padInfo.top,
          c.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          c.strideHeight,
          c.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.dilationHeight,
          c.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          Ze(c.outShape)
        ]
      }
    ], p = Hr({
      backend: t,
      attrs: {
        shape: c.inShape,
        value: 0,
        dtype: h
      }
    });
    return t.runWebGPUProgram(f, [
      i,
      a,
      o
    ], h, d, p);
  }
  const Dve = {
    kernelName: y5,
    backendName: "webgpu",
    kernelFunc: Mve
  };
  class Pve {
    constructor(e, t, n) {
      this.variableNames = [
        "Image"
      ], this.uniforms = "alpha: f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.pixelsOpType = xu.DRAW, this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.type = t, this.textureFormat = n, this.shaderKey = `draw_${t}_${n}`;
    }
    getUserCode() {
      let e;
      const t = this.type === "float32" ? "value" : "value / 255.0";
      return e = `
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`, `
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${se("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `;
    }
  }
  function kve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { image: i } = e, { canvas: a, options: o } = n, [s, l] = i.shape.slice(0, 2), { imageOptions: u } = o || {}, c = (u == null ? void 0 : u.alpha) || 1, h = t.device.features.has("bgra8unorm-storage") ? "bgra8unorm" : "rgba8unorm", f = [
      s,
      l
    ], d = new Pve(f, i.dtype, h);
    a.width = l, a.height = s;
    const p = "webgpu";
    let v = a.getContext(p), g;
    v || (g = new OffscreenCanvas(l, s), v = g.getContext(p));
    const m = i.shape.length === 3 ? i.shape[2] : 1;
    v.configure({
      device: t.device,
      format: h,
      usage: GPUTextureUsage.STORAGE_BINDING,
      alphaMode: "premultiplied"
    });
    const y = "int32", x = t.makeTensorInfo(f, y), _ = t.tensorMap.get(x.dataId);
    _.resource = v.getCurrentTexture(), _.external = true;
    const S = [
      {
        type: "uint32",
        data: [
          m
        ]
      },
      {
        type: "float32",
        data: [
          c
        ]
      }
    ];
    if (t.runWebGPUProgram(d, [
      i
    ], y, S, x), g) {
      const b = a.getContext("2d");
      if (!b) throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");
      b.drawImage(g, 0, 0);
    }
    return t.disposeData(x.dataId), i;
  }
  const Lve = {
    kernelName: x5,
    backendName: "webgpu",
    kernelFunc: kve
  };
  const Pz = cr({
    opType: ze.MUL,
    cpuKernelImpl: Ffe,
    supportsComplex: true
  }), Rve = {
    kernelName: _5,
    backendName: "webgpu",
    kernelFunc: Pz
  };
  function kz(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { axis: a, keepDims: o } = n;
    return il(i, a, o, "sum", t);
  }
  const Eve = {
    kernelName: b5,
    backendName: "webgpu",
    kernelFunc: kz
  };
  function Nve(r) {
    const { inputs: e, backend: t, attrs: n } = r, { equation: i } = n, a = e, { allDims: o, summedDims: s, idDims: l } = w5(i, a.length);
    C5(o.length, l, a);
    const { path: u, steps: c } = T5(s, l), h = c.length;
    let f = null, d = o.length;
    const p = [];
    for (let v = 0; v < h; ++v) {
      for (const g of c[v]) {
        const { permutationIndices: m, expandDims: y } = A5(d, l[g]);
        let x;
        I5(m) ? x = a[g] : (x = Gi({
          inputs: {
            x: a[g]
          },
          backend: t,
          attrs: {
            perm: m
          }
        }), p.push(x));
        const _ = x.shape.slice();
        for (let S = 0; S < y.length; ++S) _.splice(y[S], 0, 1);
        Au(x.shape, _) || (x = we({
          inputs: {
            x
          },
          backend: t,
          attrs: {
            shape: _
          }
        }), p.push(x)), f === null ? f = x : (f = Pz({
          inputs: {
            a: x,
            b: f
          },
          backend: t
        }), p.push(f));
      }
      v < h - 1 && (u[v] >= 0 && (f = kz({
        inputs: {
          x: f
        },
        backend: t,
        attrs: {
          axis: u[v] - (o.length - d),
          keepDims: false
        }
      }), p.push(f)), d--);
    }
    for (const v of p) v !== f && t.disposeData(v.dataId);
    return f;
  }
  const Ove = {
    kernelName: S5,
    backendName: "webgpu",
    kernelFunc: Nve
  };
  const Fve = dt({
    opType: ie.ELU
  }), Bve = {
    kernelName: M5,
    backendName: "webgpu",
    kernelFunc: Fve
  };
  const zve = (r) => {
    const { inputs: e, backend: t } = r, { dy: n, y: i } = e, a = new Rv(ze.ELU_DER, n.shape, i.shape);
    return t.runWebGPUProgram(a, [
      n,
      i
    ], n.dtype);
  }, Vve = {
    kernelName: D5,
    backendName: "webgpu",
    kernelFunc: zve
  };
  const $ve = cr({
    opType: ze.EQUAL,
    dtype: "bool",
    cpuKernelImpl: Sfe
  }), Gve = {
    kernelName: P5,
    backendName: "webgpu",
    kernelFunc: $ve
  };
  const Wve = dt({
    opType: ie.ERF
  }), Uve = {
    kernelName: k5,
    backendName: "webgpu",
    kernelFunc: Wve
  };
  const Hve = dt({
    opType: ie.EXP,
    cpuKernelImpl: wfe,
    dtype: "float32"
  }), Yve = {
    kernelName: L5,
    backendName: "webgpu",
    kernelFunc: Hve
  };
  function tb(r) {
    const { inputs: e, attrs: t, backend: n } = r, { dim: i } = t, { input: a } = e, o = a.shape.length, s = a.shape.slice();
    let l = i;
    return i < 0 && (Mt(-(o + 1) <= i, () => `Axis must be in the interval [${-(o + 1)}, ${o}]`), l = o + i + 1), s.splice(l, 0, 1), we({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: s
      }
    });
  }
  const Xve = {
    kernelName: R5,
    backendName: "webgpu",
    kernelFunc: tb
  };
  const qve = dt({
    opType: ie.EXPM1,
    cpuKernelImpl: Cfe
  }), Kve = {
    kernelName: E5,
    backendName: "webgpu",
    kernelFunc: qve
  };
  class MP {
    constructor(e, t) {
      this.variableNames = [
        "real",
        "imag"
      ], this.outputShape = [], this.uniforms = "exponentMultiplier : f32, denominator: f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.component = e, this.shaderKey = `fft_${e}`;
    }
    getUserCode() {
      return `
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component === "real" ? "return real * expR - imag * expI;" : "return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `;
    }
  }
  function Lz(r, e, t) {
    const n = t.tensorMap.get(r.dataId), i = Ze(r.shape), a = r.shape[r.shape.length - 1], o = i / a, s = [], l = we({
      inputs: {
        x: r
      },
      backend: t,
      attrs: {
        shape: [
          o,
          a
        ]
      }
    });
    s.push(l);
    const u = l.shape, c = new MP("real", u), h = new MP("imag", u), f = [
      {
        dataId: n.complexTensorInfos.real.dataId,
        dtype: n.complexTensorInfos.real.dtype,
        shape: u
      },
      {
        dataId: n.complexTensorInfos.imag.dataId,
        dtype: n.complexTensorInfos.imag.dtype,
        shape: u
      }
    ], d = e ? 2 * Math.PI : -2 * Math.PI, p = e ? u[1] : 1, v = [
      {
        type: "float32",
        data: [
          d
        ]
      },
      {
        type: "float32",
        data: [
          p
        ]
      }
    ], g = t.runWebGPUProgram(c, f, "float32", v);
    s.push(g);
    const m = t.runWebGPUProgram(h, f, "float32", v);
    s.push(m);
    const y = nl({
      inputs: {
        real: g,
        imag: m
      },
      backend: t
    });
    s.push(y);
    const x = we({
      inputs: {
        x: y
      },
      backend: t,
      attrs: {
        shape: r.shape
      }
    });
    return s.forEach((_) => t.disposeData(_.dataId)), x;
  }
  function Zve(r) {
    const { inputs: e, backend: t } = r, { input: n } = e;
    return Lz(n, false, t);
  }
  const jve = {
    kernelName: N5,
    backendName: "webgpu",
    kernelFunc: Zve
  };
  class Qve {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "flipLeftRight";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `;
    }
  }
  const Jve = {
    kernelName: O5,
    backendName: "webgpu",
    kernelFunc: ({ inputs: r, backend: e }) => {
      const { image: t } = r, n = e, i = new Qve(t.shape);
      return n.runWebGPUProgram(i, [
        t
      ], t.dtype);
    }
  };
  const ege = dt({
    opType: ie.FLOOR,
    cpuKernelImpl: Tfe
  }), tge = {
    kernelName: F5,
    backendName: "webgpu",
    kernelFunc: ege
  };
  const rge = cr({
    opType: ze.FLOOR_DIV,
    cpuKernelImpl: Afe,
    dtype: "int32"
  }), nge = {
    kernelName: B5,
    backendName: "webgpu",
    kernelFunc: rge
  };
  class ige {
    constructor(e, t, n = false) {
      this.pixelsOpType = xu.FROM_PIXELS, this.outputShape = [
        0
      ], this.variableNames = [], this.workgroupSize = [
        256,
        1,
        1
      ], this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        t,
        1,
        1
      ]), this.importVideo = n, this.shaderKey = `fromPixels_${this.importVideo}`;
    }
    getUserCode() {
      const e = this.importVideo ? "textureLoad(src, vec2<i32>(coords.yx));" : "textureLoad(src, vec2<i32>(coords.yx), 0)";
      return `
      @binding(1) @group(0) var src: ${this.importVideo ? "texture_external" : "texture_2d<f32>"};
      ${se("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `;
    }
  }
  const age = {
    kernelName: z5,
    backendName: "webgpu",
    kernelFunc: oge
  };
  let kl, y0 = rr().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function oge(r) {
    const { inputs: e, backend: t, attrs: n } = r;
    let { pixels: i } = e;
    const { numChannels: a } = n;
    if (i == null) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    const o = typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement, s = typeof HTMLImageElement < "u" && i instanceof HTMLImageElement, l = typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas, u = typeof ImageBitmap < "u" && i instanceof ImageBitmap, [c, h] = o ? [
      i.videoWidth,
      i.videoHeight
    ] : [
      i.width,
      i.height
    ], f = [
      h,
      c,
      a
    ], d = rr().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE") && o, p = o || s;
    if (u || l || p) {
      let y;
      if (d) y = t.device.importExternalTexture({
        source: i
      });
      else {
        if (p) {
          const k = rr().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
          (kl == null || k !== y0) && (y0 = k, kl = document.createElement("canvas").getContext("2d", {
            willReadFrequently: y0
          })), kl.canvas.width = c, kl.canvas.height = h, kl.drawImage(i, 0, 0, c, h), i = kl.canvas;
        }
        const A = GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, E = t.textureManager.acquireTexture(f[1], f[0], "rgba8unorm", A);
        t.queue.copyExternalImageToTexture({
          source: i
        }, {
          texture: E
        }, [
          f[1],
          f[0]
        ]), y = E;
      }
      const x = Ze(f), _ = ph(f), S = new ige(f, a, d), b = [
        {
          type: "uint32",
          data: [
            x
          ]
        },
        {
          type: "uint32",
          data: [
            a
          ]
        },
        {
          type: "uint32",
          data: [
            ..._
          ]
        }
      ], w = t.makeTensorInfo([
        h,
        c
      ], "int32"), C = t.tensorMap.get(w.dataId);
      C.resource = y;
      const T = t.runWebGPUProgram(S, [
        w
      ], "int32", b);
      return t.disposeData(w.dataId), T;
    }
    const v = i.data;
    let g = v;
    if (a != null && a !== 4) {
      g = new Uint8Array(i.width * i.height * a);
      const y = v.length;
      let x = 0;
      for (let _ = 0; _ < y; _++) _ % 4 < a && (g[x++] = v[_]);
    }
    const m = t.makeTensorInfo(f, "int32", new Int32Array(g));
    return t.uploadToGPU(m.dataId), m;
  }
  class sge {
    constructor(e, t, n, i, a) {
      this.uniforms = "varianceEpsilon : f32,", this.workgroupSize = [
        128,
        1,
        1
      ], this.size = true, this.variableNames = [
        "x",
        "mean",
        "variance"
      ], Ua(e, t), Ua(e, n), this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), i != null && (Ua(e, i), this.variableNames.push("offset")), a != null && (Ua(e, a), this.variableNames.push("scale")), this.offsetShape = i, this.scaleShape = a, this.shaderKey = "batchNorm";
    }
    getUserCode() {
      let e = "0.0";
      this.offsetShape != null && (e = "getOffsetByOutputIndex(index)");
      let t = "1.0";
      return this.scaleShape != null && (t = "getScaleByOutputIndex(index)"), `
      ${se("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `;
    }
  }
  const lge = {
    kernelName: V5,
    backendName: "webgpu",
    kernelFunc: ({ inputs: r, attrs: e, backend: t }) => {
      const { x: n, scale: i, offset: a, mean: o, variance: s } = r, { varianceEpsilon: l } = e, u = t, c = [
        n,
        o,
        s
      ];
      let h = null;
      a != null && (h = a.shape, c.push(a));
      let f = null;
      i != null && (f = i.shape, c.push(i));
      const d = new sge(n.shape, o.shape, s.shape, h, f), p = [
        {
          type: "float32",
          data: [
            l
          ]
        }
      ];
      return u.runWebGPUProgram(d, c, n.dtype, p);
    }
  };
  function uge(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, filter: a, bias: o, preluActivationWeights: s } = e, { strides: l, pad: u, dataFormat: c, dilations: h, dimRoundingMode: f, activation: d, leakyreluAlpha: p } = n, v = hf(c), g = go(i.shape, a.shape, l, h, u, f, false, v);
    return Az({
      x: i,
      filter: a,
      convInfo: g,
      backend: t,
      bias: o,
      preluActivationWeights: s,
      leakyreluAlpha: p,
      activation: d
    });
  }
  const cge = {
    kernelName: $5,
    backendName: "webgpu",
    kernelFunc: uge
  };
  function hge(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, filter: a, bias: o, preluActivationWeights: s } = e, { strides: l, pad: u, dilations: c, dimRoundingMode: h, activation: f, leakyreluAlpha: d } = n;
    let p = c;
    p == null && (p = [
      1,
      1
    ]), Mt(OL(l, p), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${p}'`);
    const v = go(i.shape, a.shape, l, p, u, h, true), g = [
      i,
      a
    ], m = o != null, y = s != null;
    m && g.push(o), y && g.push(s);
    const x = [
      {
        type: "int32",
        data: [
          v.padInfo.top,
          v.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          v.inHeight,
          v.inWidth
        ]
      }
    ];
    let _;
    return v.outHeight > 4 && v.outWidth > 4 && v.strideWidth <= 2 && v.inChannels === v.outChannels && v.dilationHeight === 1 && v.dilationWidth === 1 && v.inChannels % 4 === 0 ? (_ = new Mz(v, m, f, y), x.push({
      type: "int32",
      data: [
        _.virtualWidth
      ]
    })) : (_ = new Dz(v, m, f, y), x.push({
      type: "int32",
      data: [
        v.filterHeight
      ]
    }, {
      type: "int32",
      data: [
        v.filterWidth
      ]
    }, {
      type: "int32",
      data: [
        v.strideHeight,
        v.strideWidth
      ]
    }, {
      type: "int32",
      data: [
        v.dilationHeight,
        v.dilationWidth
      ]
    })), f === "leakyrelu" && (x.push({
      type: "float32",
      data: [
        d
      ]
    }), _.uniforms += " alpha : f32,"), t.runWebGPUProgram(_, g, "float32", x);
  }
  const fge = {
    kernelName: G5,
    backendName: "webgpu",
    kernelFunc: hge
  };
  class dge {
    constructor(e, t) {
      this.variableNames = [
        "A",
        "indices"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `gathernd_${e}`, this.sliceDim = e, this.uniforms = `sliceDim : i32, strides : ${Gt(e)},`;
    }
    getUserCode() {
      let e;
      return this.sliceDim > 1 ? e = "uniforms.strides[j]" : e = "uniforms.strides", `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `;
    }
  }
  function pge(r) {
    const { inputs: e, backend: t } = r, { params: n, indices: i } = e, a = i.shape, o = a[a.length - 1], s = Ze(n.shape), [l, u, c, h] = U5(n, i), f = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u,
          o
        ]
      }
    }), d = we({
      inputs: {
        x: n
      },
      backend: t,
      attrs: {
        shape: [
          Ze(n.shape) / c,
          c
        ]
      }
    });
    if (t.shouldExecuteOnCPU([
      n,
      i
    ]) || n.dtype === "string") {
      const y = t.readSync(i.dataId), x = t.bufferSync(n), _ = Ife(y, x, n.dtype, u, o, c, h, n.shape, s);
      return t.makeTensorInfo(l, n.dtype, _.values);
    }
    const p = new dge(o, [
      u,
      c
    ]), v = [
      {
        type: "int32",
        data: [
          o
        ]
      },
      {
        type: "int32",
        data: h
      }
    ], g = t.runWebGPUProgram(p, [
      d,
      f
    ], d.dtype, v), m = we({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        shape: l
      }
    });
    return t.disposeData(f.dataId), t.disposeData(d.dataId), t.disposeData(g.dataId), m;
  }
  const vge = {
    kernelName: W5,
    backendName: "webgpu",
    kernelFunc: pge
  };
  class gge {
    constructor(e, t) {
      this.variableNames = [
        "A",
        "indices"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.slice(), this.aShape = e, this.outputShape = t, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "gather";
    }
    getUserCode() {
      const e = mge(this.aShape);
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `;
    }
  }
  function mge(r) {
    const e = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w"
    ], t = [];
    for (let n = 0; n < r.length; n++) n === 2 ? t.push("indexZ") : t.push(`${e[n]}`);
    return t.join();
  }
  function Rz(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, indices: a } = e, { axis: o, batchDims: s } = n, l = Ys(o, i.shape)[0], u = Y5(i, a, l, s), c = Ze(a.shape), h = [], f = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u.batchSize,
          u.outerSize,
          u.dimSize,
          u.sliceSize
        ]
      }
    }), d = we({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          u.batchSize,
          c / u.batchSize
        ]
      }
    });
    h.push(f), h.push(d);
    const p = [
      u.batchSize,
      u.outerSize,
      c / u.batchSize,
      u.sliceSize
    ];
    if (t.shouldExecuteOnCPU([
      i,
      a
    ])) {
      const x = t.tensorMap.get(d.dataId).values, _ = au(d.shape, d.dtype, x), b = t.tensorMap.get(f.dataId).values, w = au(f.shape, f.dtype, b), C = Mfe(w, _, p);
      return h.forEach((T) => t.disposeData(T.dataId)), t.makeTensorInfo(u.outputShape, C.dtype, C.values);
    }
    const v = new gge(f.shape, p), g = t.runWebGPUProgram(v, [
      f,
      d
    ], f.dtype);
    h.push(g);
    const m = we({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        shape: u.outputShape
      }
    });
    return h.forEach((y) => t.disposeData(y.dataId)), m;
  }
  const yge = {
    kernelName: H5,
    backendName: "webgpu",
    kernelFunc: Rz
  };
  const xge = cr({
    opType: ze.GREATER,
    cpuKernelImpl: Pfe,
    dtype: "bool"
  }), _ge = {
    kernelName: X5,
    backendName: "webgpu",
    kernelFunc: xge
  };
  const bge = cr({
    opType: ze.GREATER_EQUAL,
    dtype: "bool",
    cpuKernelImpl: Dfe
  }), Sge = {
    kernelName: q5,
    backendName: "webgpu",
    kernelFunc: bge
  };
  function wge(r) {
    const { inputs: e, backend: t } = r, { input: n } = e;
    return Lz(n, true, t);
  }
  const Cge = {
    kernelName: K5,
    backendName: "webgpu",
    kernelFunc: wge
  };
  const Tge = dt({
    opType: ie.IS_FINITE,
    dtype: "bool"
  }), Age = {
    kernelName: Z5,
    backendName: "webgpu",
    kernelFunc: Tge
  };
  const Ige = dt({
    opType: ie.IS_INF,
    dtype: "bool"
  }), Mge = {
    kernelName: j5,
    backendName: "webgpu",
    kernelFunc: Ige
  };
  const Dge = dt({
    opType: ie.IS_NAN,
    dtype: "bool"
  }), Pge = {
    kernelName: Q5,
    backendName: "webgpu",
    kernelFunc: Dge
  };
  function kge(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { alpha: a } = n, o = [
      {
        type: "float32",
        data: [
          a
        ]
      }
    ], s = new Uu(i.shape, ie.LEAKYRELU, "alpha : f32,");
    return t.runWebGPUProgram(s, [
      i
    ], "float32", o);
  }
  const Lge = {
    kernelName: J5,
    backendName: "webgpu",
    kernelFunc: kge
  };
  const Rge = cr({
    opType: ze.LESS,
    dtype: "bool",
    cpuKernelImpl: Lfe
  }), Ege = {
    kernelName: eW,
    backendName: "webgpu",
    kernelFunc: Rge
  };
  const Nge = cr({
    opType: ze.LESS_EQUAL,
    dtype: "bool",
    cpuKernelImpl: kfe
  }), Oge = {
    kernelName: tW,
    backendName: "webgpu",
    kernelFunc: Nge
  };
  class Fge {
    constructor(e) {
      this.variableNames = [], this.outputShape = [], this.uniforms = "start : f32, step : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "linSpace";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `;
    }
  }
  function Bge(r) {
    const { backend: e, attrs: t } = r, { start: n, stop: i, num: a } = t, o = (i - n) / (a - 1), s = new Fge(a), l = [
      {
        type: "float32",
        data: [
          n
        ]
      },
      {
        type: "float32",
        data: [
          o
        ]
      }
    ];
    return e.runWebGPUProgram(s, [], "float32", l);
  }
  const zge = {
    kernelName: rW,
    backendName: "webgpu",
    kernelFunc: Bge
  };
  const Vge = dt({
    opType: ie.LOG,
    cpuKernelImpl: Rfe
  }), $ge = {
    kernelName: nW,
    backendName: "webgpu",
    kernelFunc: Vge
  };
  const Gge = dt({
    opType: ie.LOG1P
  }), Wge = {
    kernelName: iW,
    backendName: "webgpu",
    kernelFunc: Gge
  };
  const Uge = cr({
    opType: ze.LOGICAL_AND,
    dtype: "bool"
  }), Hge = {
    kernelName: aW,
    backendName: "webgpu",
    kernelFunc: Uge
  };
  const Yge = dt({
    opType: ie.LOGICAL_NOT
  }), Xge = {
    kernelName: oW,
    backendName: "webgpu",
    kernelFunc: Yge
  };
  const qge = cr({
    opType: ze.LOGICAL_OR
  }), Kge = {
    kernelName: sW,
    backendName: "webgpu",
    kernelFunc: qge
  };
  const Ez = `
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;
  class Zge {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "lrn";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${Ez}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `;
    }
  }
  class jge {
    constructor(e, t) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [
        256,
        1,
        1
      ], this.maxAllowRadius = 16, Mt(t <= this.maxAllowRadius, () => `Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`), this.outputShape = e, this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius, this.dispatchLayout = {
        x: [
          3
        ],
        y: [
          2
        ],
        z: [
          0,
          1
        ]
      }, this.dispatch = ue(this.dispatchLayout, this.outputShape, [
        this.elementsPerWorkgroup,
        this.workgroupSize[1],
        this.workgroupSize[2]
      ]), this.shaderKey = "lrn_shared";
    }
    getUserCode() {
      return `
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${se()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${Ez}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `;
    }
  }
  function Qge(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { depthRadius: a, bias: o, alpha: s, beta: l } = n;
    let u;
    a > 16 ? u = new Zge(i.shape) : u = new jge(i.shape, a);
    const c = [
      {
        type: "int32",
        data: [
          a
        ]
      },
      {
        type: "float32",
        data: [
          o
        ]
      },
      {
        type: "float32",
        data: [
          s
        ]
      },
      {
        type: "float32",
        data: [
          l
        ]
      }
    ];
    return t.runWebGPUProgram(u, [
      i
    ], i.dtype, c);
  }
  const Jge = {
    kernelName: lW,
    backendName: "webgpu",
    kernelFunc: Qge
  };
  class eme {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "inputImage",
        "outputImage",
        "dy"
      ], this.uniforms = "depthRadius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "lrn_grad";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `;
    }
  }
  function tme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, y: a, dy: o } = e, { depthRadius: s, bias: l, alpha: u, beta: c } = n, h = new eme(i.shape), f = [
      {
        type: "int32",
        data: [
          s
        ]
      },
      {
        type: "float32",
        data: [
          l
        ]
      },
      {
        type: "float32",
        data: [
          u
        ]
      },
      {
        type: "float32",
        data: [
          c
        ]
      }
    ];
    return t.runWebGPUProgram(h, [
      i,
      a,
      o
    ], i.dtype, f);
  }
  const rme = {
    kernelName: uW,
    backendName: "webgpu",
    kernelFunc: tme
  };
  const nme = cr({
    opType: ze.MAX,
    cpuKernelImpl: Nfe
  }), ime = {
    kernelName: cW,
    backendName: "webgpu",
    kernelFunc: nme
  };
  function ame(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { filterSize: a, strides: o, pad: s, dimRoundingMode: l } = n, c = cf(i.shape, a, o, 1, s, l);
    return Sz(i, c, "max", t);
  }
  const ome = {
    kernelName: hW,
    backendName: "webgpu",
    kernelFunc: ame
  };
  function sme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { filterSize: a, strides: o, pad: s, dataFormat: l, dimRoundingMode: u } = n, c = [
      1,
      1,
      1
    ], h = $v(i.shape, a, o, c, s, u, l), f = new ow(h, "max"), d = [
      {
        type: "int32",
        data: [
          h.strideDepth,
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.padInfo.front,
          h.padInfo.top,
          h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.inDepth,
          h.inHeight,
          h.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.effectiveFilterDepth,
          h.effectiveFilterHeight,
          h.effectiveFilterWidth
        ]
      }
    ];
    return t.runWebGPUProgram(f, [
      i
    ], i.dtype, d);
  }
  const lme = {
    kernelName: fW,
    backendName: "webgpu",
    kernelFunc: sme
  };
  class ume {
    constructor(e) {
      this.variableNames = [
        "dy",
        "maxPos"
      ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "maxPool2DBackprop";
    }
    getUserCode() {
      return `
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  class cme {
    constructor(e) {
      this.variableNames = [
        "dy",
        "maxPos"
      ], this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "maxPool3DBackprop";
    }
    getUserCode() {
      return `
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  function hme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { dy: i, input: a } = e, o = a, { filterSize: s, strides: l, pad: u, dimRoundingMode: c } = n, h = [
      1,
      1,
      1
    ], f = $v(o.shape, s, l, h, u, c), d = new ow(f, "max", true);
    let p = [
      {
        type: "int32",
        data: [
          f.strideDepth,
          f.strideHeight,
          f.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.padInfo.front,
          f.padInfo.top,
          f.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          f.inDepth,
          f.inHeight,
          f.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.effectiveFilterDepth,
          f.effectiveFilterHeight,
          f.effectiveFilterWidth
        ]
      }
    ];
    const v = t.runWebGPUProgram(d, [
      o
    ], "int32", p), g = new cme(f);
    p = [
      {
        type: "int32",
        data: [
          f.strideDepth,
          f.strideHeight,
          f.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.effectiveFilterDepth - 1 - f.padInfo.front,
          f.effectiveFilterHeight - 1 - f.padInfo.top,
          f.effectiveFilterWidth - 1 - f.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          f.effectiveFilterDepth,
          f.effectiveFilterHeight,
          f.effectiveFilterWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.outDepth
        ]
      },
      {
        type: "int32",
        data: [
          f.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          f.outWidth
        ]
      }
    ];
    const m = t.runWebGPUProgram(g, [
      i,
      v
    ], o.dtype, p);
    return t.disposeData(v.dataId), m;
  }
  const fme = {
    kernelName: dW,
    backendName: "webgpu",
    kernelFunc: hme
  };
  function dme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { dy: i, input: a, output: o } = e, s = a;
    gz([
      a,
      o
    ], "maxPoolGrad");
    const { filterSize: l, strides: u, pad: c, dimRoundingMode: h } = n, f = cf(s.shape, l, u, 1, c, h), d = new Qh(f, "max", true);
    let p = [
      {
        type: "int32",
        data: [
          f.strideHeight,
          f.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.padInfo.top,
          f.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          f.dilationHeight,
          f.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.inHeight,
          f.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.effectiveFilterHeight,
          f.effectiveFilterWidth
        ]
      }
    ];
    const v = t.runWebGPUProgram(d, [
      s
    ], "int32", p), g = new ume(f);
    p = [
      {
        type: "int32",
        data: [
          f.strideHeight,
          f.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.effectiveFilterHeight - 1 - f.padInfo.top,
          f.effectiveFilterWidth - 1 - f.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          f.dilationHeight,
          f.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.effectiveFilterHeight,
          f.effectiveFilterWidth
        ]
      },
      {
        type: "int32",
        data: [
          f.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          f.outWidth
        ]
      }
    ];
    const m = t.runWebGPUProgram(g, [
      i,
      v
    ], s.dtype, p);
    return t.disposeData(v.dataId), m;
  }
  const pme = {
    kernelName: pW,
    backendName: "webgpu",
    kernelFunc: dme
  };
  function vme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { filterSize: i, strides: a, pad: o, includeBatchInIndex: s } = n, { x: l } = e;
    Mt(l.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);
    const u = [
      1,
      1
    ];
    Mt(OL(a, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
    const c = cf(l.shape, i, a, u, o), h = [
      {
        type: "int32",
        data: [
          c.strideHeight,
          c.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.padInfo.top,
          c.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          c.dilationHeight,
          c.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.inHeight,
          c.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.effectiveFilterHeight,
          c.effectiveFilterWidth
        ]
      }
    ];
    let f = new Qh(c, "max", false);
    const d = t.runWebGPUProgram(f, [
      l
    ], l.dtype, h);
    f = new Qh(c, "max", true, true, s);
    const p = t.runWebGPUProgram(f, [
      l
    ], "int32", h);
    return [
      d,
      p
    ];
  }
  const gme = {
    kernelName: vW,
    backendName: "webgpu",
    kernelFunc: vme
  };
  function mme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { axis: a, keepDims: o } = n;
    return il(i, a, o, "min", t);
  }
  const yme = {
    kernelName: gW,
    backendName: "webgpu",
    kernelFunc: mme
  };
  const xme = cr({
    opType: ze.MIN,
    cpuKernelImpl: Ofe
  }), _me = {
    kernelName: mW,
    backendName: "webgpu",
    kernelFunc: xme
  };
  class bme {
    constructor(e, t, n) {
      this.uniforms = "", this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t.map((i, a) => i[0] + e[a] + i[1]), this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.xShape = e, t.map((i, a) => {
        this.uniforms += ` pad${a} : vec2<i32>,`;
      }), this.offset = n === "reflect" ? 0 : 1, this.shaderKey = `mirrorPad_${n}`;
    }
    getUserCode() {
      const e = this.xShape.length, t = this.xShape.map((u, c) => `uniforms.pad${c}[0]`).join(","), n = this.xShape.map((u, c) => `uniforms.pad${c}[0] + uniforms.xShape${e > 1 ? `[${c}]` : ""}`).join(","), i = e === 1 ? "start" : "start[i]", a = e === 1 ? "end" : "end[i]", o = e === 1 ? "outC" : "outC[i]", s = Gt(e), l = e > 1 ? [
        "coords[0]",
        "coords[1]",
        "coords[2]",
        "coords[3]"
      ].slice(0, e) : "coords";
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let start = ${s}(${t});
          let end = ${s}(${n});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${i}) {
              ${o} = ${i} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${a}) {
              ${o} = (${a} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `;
    }
  }
  const Sme = {
    kernelName: yW,
    backendName: "webgpu",
    kernelFunc: ({ inputs: r, attrs: e, backend: t }) => {
      const { x: n } = r, { paddings: i, mode: a } = e, o = t, s = i.map((c) => ({
        type: "int32",
        data: [
          c[0],
          c[1]
        ]
      })), l = new bme(n.shape, i, a);
      return o.runWebGPUProgram(l, [
        n
      ], n.dtype, s);
    }
  };
  const wme = cr({
    opType: ze.MOD
  }), Cme = {
    kernelName: xW,
    backendName: "webgpu",
    kernelFunc: wme
  };
  class Tme {
    constructor(e, t) {
      this.variableNames = [
        "probs"
      ], this.outputShape = [], this.uniforms = "seed : f32, numOutcomes: i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e,
        t
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "multinomial";
    }
    getUserCode() {
      return `
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `;
    }
  }
  class Ame {
    constructor(e) {
      this.variableNames = [
        "logits"
      ], this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = [
        this.outputShape[0],
        1,
        1
      ], this.outputShape[1] >= 4096 ? this.workgroupSize = [
        256,
        1,
        1
      ] : this.workgroupSize = [
        64,
        1,
        1
      ], this.shaderKey = "softmax";
    }
    getUserCode() {
      return `
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${se("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `;
    }
  }
  function Nz(r) {
    const { inputs: e, backend: t, attrs: n } = r, { logits: i } = e, { dim: a } = n, o = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          Ze(i.shape) / i.shape[a],
          i.shape[a]
        ]
      }
    }), s = new Ame(o.shape), l = t.runWebGPUProgram(s, [
      o
    ], i.dtype), u = we({
      inputs: {
        x: l
      },
      backend: t,
      attrs: {
        shape: i.shape
      }
    });
    return t.disposeData(o.dataId), t.disposeData(l.dataId), u;
  }
  const Ime = {
    kernelName: _W,
    backendName: "webgpu",
    kernelFunc: Nz
  };
  function Mme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { logits: i } = e, { numSamples: a, seed: o, normalized: s } = n, l = s ? i : Nz({
      inputs: {
        logits: i
      },
      backend: t,
      attrs: {
        dim: i.shape.length - 1
      }
    }), u = l.shape[0], c = l.shape[1], h = new Tme(u, a), f = [
      {
        type: "float32",
        data: [
          o
        ]
      },
      {
        type: "int32",
        data: [
          c
        ]
      }
    ], d = t.runWebGPUProgram(h, [
      l
    ], "int32", f);
    return s || t.disposeData(l.dataId), d;
  }
  const Dme = {
    kernelName: bW,
    backendName: "webgpu",
    kernelFunc: Mme
  };
  function Pme(r) {
    const { inputs: e, backend: t } = r, { x: n } = e;
    if (t.shouldExecuteOnCPU([
      n
    ])) {
      const a = t.tensorMap.get(n.dataId), [o, s] = Bfe(a.values, n.shape, n.dtype);
      return t.makeTensorInfo(s, n.dtype, o);
    }
    const i = new Uu(n.shape, ie.NEG);
    return t.runWebGPUProgram(i, [
      n
    ], n.dtype);
  }
  const kme = {
    kernelName: SW,
    backendName: "webgpu",
    kernelFunc: Pme
  };
  function Lme(r) {
    console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: e, backend: t, attrs: n } = r, { boxes: i, scores: a } = e, { maxOutputSize: o, iouThreshold: s, scoreThreshold: l } = n, u = t.readSync(i.dataId), c = t.readSync(a.dataId), { selectedIndices: h } = CW(u, c, o, s, l);
    return t.makeTensorInfo([
      h.length
    ], "int32", new Int32Array(h));
  }
  const Rme = {
    kernelName: wW,
    backendName: "webgpu",
    kernelFunc: Lme
  };
  function Eme(r) {
    console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: e, backend: t, attrs: n } = r, { boxes: i, scores: a } = e, { maxOutputSize: o, iouThreshold: s, scoreThreshold: l, softNmsSigma: u } = n, c = t.readSync(i.dataId), h = t.readSync(a.dataId), f = o, d = s, p = l, v = u, { selectedIndices: g, selectedScores: m } = AW(c, h, f, d, p, v);
    return [
      t.makeTensorInfo([
        g.length
      ], "int32", new Int32Array(g)),
      t.makeTensorInfo([
        m.length
      ], "float32", new Float32Array(m))
    ];
  }
  const Nme = {
    kernelName: TW,
    backendName: "webgpu",
    kernelFunc: Eme
  };
  class Ome {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.uniforms = "onValue : f32, offValue : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e,
        t
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "onehot";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `;
    }
  }
  function Fme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { indices: i } = e, { dtype: a, depth: o, onValue: s, offValue: l } = n, u = Ze(i.shape), c = new Ome(u, o), h = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u
        ]
      }
    }), f = [
      {
        type: "float32",
        data: [
          s
        ]
      },
      {
        type: "float32",
        data: [
          l
        ]
      }
    ], d = t.runWebGPUProgram(c, [
      h
    ], a, f);
    t.disposeData(h.dataId);
    const p = [
      ...i.shape,
      o
    ], v = we({
      inputs: {
        x: d
      },
      backend: t,
      attrs: {
        shape: p
      }
    });
    return t.disposeData(d.dataId), v;
  }
  const Bme = {
    kernelName: IW,
    backendName: "webgpu",
    kernelFunc: Fme
  };
  function Nv(r) {
    const { inputs: e, backend: t } = r, { x: n } = e;
    if (n.dtype === "complex64") {
      const i = Nf({
        inputs: {
          input: n
        },
        backend: t
      }), a = Nv({
        inputs: {
          x: i
        },
        backend: t
      }), o = Ng({
        inputs: {
          input: n
        },
        backend: t
      }), s = Nv({
        inputs: {
          x: o
        },
        backend: t
      }), l = nl({
        inputs: {
          real: a,
          imag: s
        },
        backend: t
      });
      return t.disposeData(i.dataId), t.disposeData(a.dataId), t.disposeData(o.dataId), t.disposeData(s.dataId), l;
    } else return Hr({
      attrs: {
        shape: n.shape,
        dtype: n.dtype,
        value: n.dtype === "string" ? "" : 0
      },
      backend: t
    });
  }
  const zme = {
    kernelName: MW,
    backendName: "webgpu",
    kernelFunc: Nv
  };
  function Oz(r) {
    const { inputs: e, backend: t } = r, { x: n } = e;
    if (n.dtype === "string") throw new Error("onesLike is not supported under string dtype");
    if (n.dtype === "complex64") {
      const i = Nf({
        inputs: {
          input: n
        },
        backend: t
      }), a = Oz({
        inputs: {
          x: i
        },
        backend: t
      }), o = Ng({
        inputs: {
          input: n
        },
        backend: t
      }), s = Nv({
        inputs: {
          x: o
        },
        backend: t
      }), l = nl({
        inputs: {
          real: a,
          imag: s
        },
        backend: t
      });
      return t.disposeData(i.dataId), t.disposeData(a.dataId), t.disposeData(o.dataId), t.disposeData(s.dataId), l;
    } else return Hr({
      attrs: {
        shape: n.shape,
        dtype: n.dtype,
        value: 1
      },
      backend: t
    });
  }
  const Vme = {
    kernelName: DW,
    backendName: "webgpu",
    kernelFunc: Oz
  };
  function $me(r) {
    const { inputs: e, backend: t, attrs: n } = r, { axis: i } = n;
    if (e.length === 1) return tb({
      inputs: {
        input: e[0]
      },
      backend: t,
      attrs: {
        dim: i
      }
    });
    const a = e[0].shape, o = e[0].dtype;
    e.forEach((c) => {
      kW(a, c.shape, "All tensors passed to stack must have matching shapes"), Mt(o === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const s = [], l = e.map((c) => {
      const h = tb({
        inputs: {
          input: c
        },
        backend: t,
        attrs: {
          dim: i
        }
      });
      return s.push(h), h;
    }), u = Tz({
      inputs: l,
      backend: t,
      attrs: {
        axis: i
      }
    });
    return s.forEach((c) => t.disposeData(c.dataId)), u;
  }
  const Gme = {
    kernelName: PW,
    backendName: "webgpu",
    kernelFunc: $me
  };
  function Fz(r, e = false) {
    const t = r.length, n = Gt(t), i = r.map((h, f) => `uniforms.pad${f}[0]`).join(","), a = r.map((h, f) => `uniforms.pad${f}[0] + uniforms.xShape${t > 1 ? `[${f}]` : ""}`).join(","), o = t > 1 ? `${n}(${i})` : `${i}`, s = t > 1 ? `${n}(${a})` : `${a}`, l = t > 1 ? "any(paddedCoords < start)" : "paddedCoords < start", u = t > 1 ? "any(paddedCoords >= end)" : "paddedCoords >= end", c = t > 1 ? [
      "coords[0]",
      "coords[1]",
      "coords[2]",
      "coords[3]"
    ].slice(0, t) : "coords";
    return `
        let start = ${o};
        let end = ${s};
        if (${l} || ${u}) {
          setOutputAtIndex(index, ${e ? 0 : "uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `;
  }
  class Wme {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.uniforms = "constantValue : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t.map((n, i) => n[0] + e[i] + n[1]), this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), t.map((n, i) => {
        this.uniforms += ` pad${i} : vec2<i32>,`;
      }), this.xShape = e, this.shaderKey = "pad";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${Fz(this.xShape)}
        }
      }
    `;
    }
  }
  const Ume = (r) => {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { paddings: a, constantValue: o } = n;
    if (a.every((u) => Au(u, [
      0,
      0
    ]))) return ln({
      inputs: {
        x: i
      },
      backend: t
    });
    if (Ze(i.shape) === 0) {
      const u = a.map((c, h) => c[0] + i.shape[h] + c[1]);
      return Hr({
        backend: t,
        attrs: {
          shape: u,
          value: o,
          dtype: i.dtype
        }
      });
    }
    const s = [
      {
        type: "float32",
        data: [
          o
        ]
      }
    ];
    a.map((u) => s.push({
      type: "int32",
      data: [
        u[0],
        u[1]
      ]
    }));
    const l = new Wme(i.shape, a);
    return t.runWebGPUProgram(l, [
      i
    ], i.dtype, s);
  }, Hme = {
    kernelName: LW,
    backendName: "webgpu",
    kernelFunc: Ume
  };
  const Yme = cr({
    opType: ze.POW
  }), Xme = {
    kernelName: RW,
    backendName: "webgpu",
    kernelFunc: Yme
  };
  function qme(r) {
    const { inputs: e, backend: t } = r, { x: n, alpha: i } = e, a = new Rv(ze.PRELU, n.shape, i.shape);
    return t.runWebGPUProgram(a, [
      n,
      i
    ], "float32");
  }
  const Kme = {
    kernelName: EW,
    backendName: "webgpu",
    kernelFunc: qme
  };
  function Zme(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { axis: a, keepDims: o } = n;
    return il(i, a, o, "prod", t);
  }
  const jme = {
    kernelName: NW,
    backendName: "webgpu",
    kernelFunc: Zme
  };
  const Qme = (r) => {
    const { backend: e, attrs: t } = r, { start: n, stop: i, step: a, dtype: o } = t, s = $fe(n, i, a, o);
    return e.makeTensorInfo([
      s.length
    ], o, s);
  }, Jme = {
    kernelName: OW,
    backendName: "webgpu",
    kernelFunc: Qme
  };
  const eye = cr({
    opType: ze.DIV
  }), tye = {
    kernelName: FW,
    backendName: "webgpu",
    kernelFunc: eye
  };
  const rye = dt({
    opType: ie.RECIPROCAL
  }), nye = {
    kernelName: BW,
    backendName: "webgpu",
    kernelFunc: rye
  };
  const iye = dt({
    opType: ie.RELU
  }), aye = {
    kernelName: zW,
    backendName: "webgpu",
    kernelFunc: iye
  };
  const oye = dt({
    opType: ie.RELU6
  }), sye = {
    kernelName: VW,
    backendName: "webgpu",
    kernelFunc: oye
  };
  class lye {
    constructor(e, t, n) {
      this.variableNames = [
        "x"
      ], this.uniforms = "adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e[0],
        t,
        n,
        e[3]
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "resizeBilinear";
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    }
  }
  function uye(r) {
    const { inputs: e, backend: t, attrs: n } = r, { images: i } = e, { alignCorners: a, size: o, halfPixelCenters: s } = n, [l, u] = o, c = a && l > 1 ? 1 : 0, h = a && u > 1 ? 1 : 0, d = [
      {
        type: "float32",
        data: [
          c,
          h
        ]
      },
      {
        type: "float32",
        data: [
          s ? 0.5 : 0
        ]
      }
    ], p = new lye(i.shape, l, u);
    return t.runWebGPUProgram(p, [
      i
    ], "float32", d);
  }
  const cye = {
    kernelName: $W,
    backendName: "webgpu",
    kernelFunc: uye
  };
  class hye {
    constructor(e, t) {
      this.variableNames = [
        "dy"
      ], this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.alignCorners = t, this.shaderKey = `resizeBilinearBackprop_${t}`;
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    }
  }
  function fye(r) {
    const { inputs: e, backend: t, attrs: n } = r, { images: i, dy: a } = e, { alignCorners: o } = n, [, s, l] = i.shape, [, u, c] = a.shape, h = [
      o && u > 1 ? s - 1 : s,
      o && c > 1 ? l - 1 : l
    ], f = [
      o && u > 1 ? u - 1 : u,
      o && c > 1 ? c - 1 : c
    ], d = h[0] / f[0], p = h[1] / f[1], v = 1 / d, g = 1 / p, m = Math.ceil(v) * 2 + 2, y = Math.ceil(g) * 2 + 2, x = new hye(i.shape, o), _ = [
      {
        type: "int32",
        data: h
      },
      {
        type: "int32",
        data: f
      },
      {
        type: "float32",
        data: [
          d
        ]
      },
      {
        type: "float32",
        data: [
          p
        ]
      },
      {
        type: "float32",
        data: [
          v
        ]
      },
      {
        type: "float32",
        data: [
          g
        ]
      },
      {
        type: "int32",
        data: [
          m
        ]
      },
      {
        type: "int32",
        data: [
          y
        ]
      }
    ];
    return t.runWebGPUProgram(x, [
      a
    ], a.dtype, _);
  }
  const dye = {
    kernelName: GW,
    backendName: "webgpu",
    kernelFunc: fye
  };
  class pye {
    constructor(e, t, n, i) {
      this.variableNames = [
        "x"
      ], this.uniforms = "adjustHeightWidth : vec2<f32>, roundBase : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e[0],
        t,
        n,
        e[3]
      ], this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.halfPixelCenters = i, this.shaderKey = `resizeNearest_${i}`;
    }
    getUserCode() {
      let e;
      return this.halfPixelCenters ? e = "max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))" : e = "vec2<f32>(rc) * effectiveInputOverOutputRatioRC", `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    }
  }
  function vye(r) {
    const { inputs: e, backend: t, attrs: n } = r, { images: i } = e, { alignCorners: a, halfPixelCenters: o, size: s } = n, [l, u] = s, c = a && l > 1 ? 1 : 0, h = a && u > 1 ? 1 : 0, d = [
      {
        type: "float32",
        data: [
          c,
          h
        ]
      },
      {
        type: "float32",
        data: [
          a ? 0.5 : 0
        ]
      }
    ], p = new pye(i.shape, l, u, o);
    return t.runWebGPUProgram(p, [
      i
    ], i.dtype, d);
  }
  const gye = {
    kernelName: WW,
    backendName: "webgpu",
    kernelFunc: vye
  };
  class mye {
    constructor(e, t) {
      this.variableNames = [
        "dy"
      ], this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.alignCorners = t, this.shaderKey = `resizeNearestNeigborBackprop_${t}`;
    }
    getUserCode() {
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners ? "floor(sourceFracRow + 0.5)" : "floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners ? "floor(sourceFracCol + 0.5)" : "floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    }
  }
  function yye(r) {
    const { inputs: e, backend: t, attrs: n } = r, { images: i, dy: a } = e, { alignCorners: o } = n, [, s, l] = i.shape, [, u, c] = a.shape, h = [
      o && u > 1 ? s - 1 : s,
      o && c > 1 ? l - 1 : l
    ], f = [
      o && u > 1 ? u - 1 : u,
      o && c > 1 ? c - 1 : c
    ], d = h[0] / f[0], p = h[1] / f[1], v = 1 / d, g = 1 / p, m = Math.ceil(v) * 2 + 2, y = Math.ceil(g) * 2 + 2, x = new mye(i.shape, o), _ = [
      {
        type: "int32",
        data: h
      },
      {
        type: "int32",
        data: f
      },
      {
        type: "float32",
        data: [
          v
        ]
      },
      {
        type: "float32",
        data: [
          g
        ]
      },
      {
        type: "int32",
        data: [
          m
        ]
      },
      {
        type: "int32",
        data: [
          y
        ]
      }
    ];
    return t.runWebGPUProgram(x, [
      a
    ], a.dtype, _);
  }
  const xye = {
    kernelName: UW,
    backendName: "webgpu",
    kernelFunc: yye
  };
  class _ye {
    constructor(e) {
      this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = " axis : vec4<i32>,", this.shaderKey = "reverse";
    }
    getUserCode() {
      return `
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `;
    }
  }
  function bye(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { dims: a } = n, o = i.shape.length;
    if (o === 0) return ln({
      inputs: {
        x: i
      },
      backend: t
    });
    const s = i.shape, l = [
      1,
      1,
      1,
      1
    ];
    s.forEach((g, m) => {
      const y = m + 4 - o;
      l[y] = g;
    });
    const u = Ys(a, i.shape), c = [
      0,
      0,
      0,
      0
    ];
    u.forEach((g) => {
      const m = g + 4 - o;
      c[m] = 1;
    });
    const h = [
      {
        type: "int32",
        data: c
      }
    ], f = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), d = new _ye(l), p = t.runWebGPUProgram(d, [
      f
    ], f.dtype, h);
    t.disposeData(f.dataId);
    const v = we({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        shape: s
      }
    });
    return t.disposeData(p.dataId), v;
  }
  const Sye = {
    kernelName: HW,
    backendName: "webgpu",
    kernelFunc: bye
  };
  class wye {
    constructor(e, t) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = `centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`, this.shaderKey = "rotate", this.outputShape = e, typeof t == "number" ? (this.uniforms += " fillValue : f32,", this.fillSnippet = "var outputValue = uniforms.fillValue;", this.shaderKey += "_float") : (this.uniforms += " fillValue : vec3<f32>,", this.fillSnippet = "var outputValue = uniforms.fillValue[coords[3]];", this.shaderKey += "_vec3");
    }
    getUserCode() {
      return `
        ${se("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `;
    }
  }
  const Cye = {
    kernelName: YW,
    backendName: "webgpu",
    kernelFunc: ({ inputs: r, attrs: e, backend: t }) => {
      const { image: n } = r, { radians: i, fillValue: a, center: o } = e, s = t, l = new wye(n.shape, a), [u, c] = XW(o, n.shape[1], n.shape[2]), h = [
        {
          type: "float32",
          data: [
            u
          ]
        },
        {
          type: "float32",
          data: [
            c
          ]
        },
        {
          type: "float32",
          data: [
            Math.sin(i)
          ]
        },
        {
          type: "float32",
          data: [
            Math.cos(i)
          ]
        }
      ];
      return typeof a == "number" ? h.push({
        type: "float32",
        data: [
          Number.parseFloat(a.toFixed(2))
        ]
      }) : h.push({
        type: "float32",
        data: a
      }), s.runWebGPUProgram(l, [
        n
      ], n.dtype, h);
    }
  };
  const Tye = dt({
    opType: ie.ROUND
  }), Aye = {
    kernelName: qW,
    backendName: "webgpu",
    kernelFunc: Tye
  };
  const Iye = dt({
    opType: ie.RSQRT,
    cpuKernelImpl: Gfe
  }), Mye = {
    kernelName: KW,
    backendName: "webgpu",
    kernelFunc: Iye
  };
  class uh {
    constructor(e, t, n, i, a, o, s, l = true) {
      this.variableNames = [
        "updates",
        "indices"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = o, this.type = s, this.sumDupeIndices = l, this.dispatchLayout = de(e), this.dispatch = ue(this.dispatchLayout, e, this.workgroupSize), this.sliceDimGreaterThanOne = t > 1, this.shaderKey = `scatter_${n}_${i}_${this.sliceDimGreaterThanOne}_${s}_${l}_${a.length}`;
      const u = Gt(a.length);
      this.uniforms = `sliceDim : i32, strides: ${u}, updatesSize: i32,`, this.updatesRank = i, this.indicesRank = n;
    }
    getUserCode() {
      let e = "";
      this.indicesRank === 1 ? e = "coords[0]" : this.indicesRank === 2 && (e = "coords[0], j");
      const t = `getIndices(${e})`, n = this.sliceDimGreaterThanOne ? "uniforms.strides[j]" : "uniforms.strides";
      let i = "", a = "";
      this.dispatchLayout.x.length === 1 ? (i = "flattenedIndex", a = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `) : this.dispatchLayout.x.length === 2 && (i = "vec2<i32>(flattenedIndex, coords[1])", a = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);
      const s = `getUpdates(${Array.from({
        length: this.updatesRank
      }, (u, c) => `coords[${c}]`).join(", ")})`;
      return `
    ${a}
      ${se("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue =
              ${ps(this.type)}(${s});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices ? xo("&result[flatIndex]", "updateValue", this.type) : "atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`;
    }
  }
  function Dye(r) {
    const { inputs: e, backend: t, attrs: n } = r, { indices: i, updates: a } = e, { shape: o } = n, { sliceRank: s, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Bb(a, i, o), f = [
      h / u,
      u
    ];
    if (h === 0) return t.makeTensorInfo(o, i.dtype);
    const d = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          l,
          s
        ]
      }
    }), p = we({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          l,
          u
        ]
      }
    }), v = p.dtype, g = Hr({
      backend: t,
      attrs: {
        shape: f,
        value: 0,
        dtype: v
      }
    }), m = Ze(p.shape), y = [
      {
        type: "int32",
        data: [
          s
        ]
      },
      {
        type: "int32",
        data: c
      },
      {
        type: "int32",
        data: [
          m
        ]
      }
    ], x = new uh(p.shape, s, d.shape.length, p.shape.length, c, f, v), _ = t.runWebGPUProgram(x, [
      p,
      d
    ], v, y, g), S = we({
      inputs: {
        x: _
      },
      backend: t,
      attrs: {
        shape: o
      }
    });
    return t.disposeData(d.dataId), t.disposeData(p.dataId), t.disposeData(_.dataId), S;
  }
  const Pye = {
    kernelName: ZW,
    backendName: "webgpu",
    kernelFunc: Dye
  };
  class kye {
    constructor(e, t) {
      this.outputShape = [], this.variableNames = [
        "sortedSequence",
        "values"
      ], this.uniforms = "numInputs : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.side = t, this.shaderKey = `search_sorted_${t}`;
    }
    getUserCode() {
      return `
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side === "left" ? "<" : "<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `;
    }
  }
  function Lye(r) {
    const { inputs: e, backend: t, attrs: n } = r, { sortedSequence: i, values: a } = e, { side: o } = n, s = new kye([
      a.shape[0],
      a.shape[1]
    ], o), l = [
      {
        type: "int32",
        data: [
          i.shape[1]
        ]
      }
    ];
    return t.runWebGPUProgram(s, [
      i,
      a
    ], "int32", l);
  }
  const Rye = {
    kernelName: jW,
    backendName: "webgpu",
    kernelFunc: Lye
  };
  class Eye {
    constructor(e, t, n) {
      this.variableNames = [
        "c",
        "a",
        "b"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.cRank = e, this.rank = n, this.shaderKey = "select";
    }
    getUserCode() {
      let e, t;
      if (this.rank > 4) throw Error(`Where for rank ${this.rank} is not yet supported`);
      if (this.rank === 1) t = "resRC", e = "resRC";
      else {
        const i = [
          "resRC.x",
          "resRC.y",
          "resRC.z",
          "resRC.w"
        ], a = [], o = [];
        for (let s = 0; s < this.outputShape.length; s++) o.push(`${i[s]}`), s < this.cRank && a.push(`${i[s]}`);
        e = a.join(), t = o.join();
      }
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `;
    }
  }
  function Nye(r) {
    const { inputs: e, backend: t } = r, { condition: n, t: i, e: a } = e, o = new Eye(n.shape.length, i.shape, i.shape.length);
    return t.runWebGPUProgram(o, [
      n,
      i,
      a
    ], vh(i.dtype, a.dtype));
  }
  const Oye = {
    kernelName: QW,
    backendName: "webgpu",
    kernelFunc: Nye
  };
  const Fye = dt({
    opType: ie.SELU
  }), Bye = {
    kernelName: JW,
    backendName: "webgpu",
    kernelFunc: Fye
  };
  const zye = dt({
    opType: ie.SIGMOID
  }), Vye = {
    kernelName: e4,
    backendName: "webgpu",
    kernelFunc: zye
  };
  const $ye = dt({
    opType: ie.SIGN
  }), Gye = {
    kernelName: t4,
    backendName: "webgpu",
    kernelFunc: $ye
  };
  const Wye = dt({
    opType: ie.SIN
  }), Uye = {
    kernelName: r4,
    backendName: "webgpu",
    kernelFunc: Wye
  };
  const Hye = dt({
    opType: ie.SINH
  }), Yye = {
    kernelName: n4,
    backendName: "webgpu",
    kernelFunc: Hye
  };
  const Xye = dt({
    opType: ie.SOFTPLUS
  }), qye = {
    kernelName: i4,
    backendName: "webgpu",
    kernelFunc: Xye
  };
  class Kye {
    constructor(e, t, n, i, a, o) {
      this.variableNames = [
        "x"
      ], this.outputShape = [], this.uniforms = "", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true;
      const s = new Array(i.length);
      for (let l = 0; l < s.length; l++) s[l] = i[a[l]];
      this.outputShape = s, this.newDim = a, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.xShape = e, this.paddedXShape = t, this.uniforms += `reshapedPaddedXShape : ${Gt(i.length)}, paddedXShapeStrides : ${Gt(o)}, `, n.map((l, u) => {
        this.uniforms += ` pad${u} : vec2<i32>,`;
      }), this.shaderKey = `spaceToBatchND_${a}`;
    }
    getUserCode() {
      const e = Gt(this.outputShape.length), t = yz(this.newDim);
      return `
      ${Pp(this.paddedXShape, "PaddedX")}
      ${se("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${Fz(this.xShape, true)}
        }
      }
    `;
    }
  }
  const Zye = (r) => {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { blockShape: a, paddings: o } = n;
    Mt(i.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");
    const s = a.reduce((y, x) => y * x), l = [
      [
        0,
        0
      ]
    ];
    l.push(...o);
    for (let y = 1 + a.length; y < i.shape.length; ++y) l.push([
      0,
      0
    ]);
    const u = l.map((y, x) => y[0] + i.shape[x] + y[1]), c = LL(u, a, s, false), h = RL(c.length, a.length, false), f = EL(u, a, s, false), d = ph(u), p = new Kye(i.shape, u, l, c, h, d.length), v = [
      {
        type: "int32",
        data: c
      },
      {
        type: "int32",
        data: d
      }
    ];
    l.map((y) => v.push({
      type: "int32",
      data: [
        y[0],
        y[1]
      ]
    }));
    const g = t.runWebGPUProgram(p, [
      i
    ], i.dtype, v), m = we({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        shape: f
      }
    });
    return t.disposeData(g.dataId), m;
  }, jye = {
    kernelName: a4,
    backendName: "webgpu",
    kernelFunc: Zye
  };
  class Qye {
    constructor(e, t, n) {
      this.variableNames = [
        "input",
        "indices",
        "segmentIds"
      ], this.outputShape = [], this.uniforms = "segmentSize : i32, sparseSize : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = e, this.type = n, this.dispatchLayout = de([
        t
      ]), this.dispatch = ue(this.dispatchLayout, [
        t
      ], this.workgroupSize), this.shaderKey = "sparseSegmentSum";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${xo("&result[outIndex]", "value", this.type)}
      }
    }
  `;
    }
  }
  class Jye {
    constructor(e, t) {
      this.variableNames = [
        "segmentIds"
      ], this.outputShape = [], this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = [
        e
      ], this.dispatchLayout = de(t), this.dispatch = ue(this.dispatchLayout, t, this.workgroupSize), this.shaderKey = "sparseSegmentIdCountProgram";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${xo("&result[segmentId]", "1", "int32")}
      }
    }
  `;
    }
  }
  class e0e {
    constructor(e, t) {
      this.variableNames = [
        "segmentSum",
        "sameSegmentIdCount"
      ], this.outputShape = [], this.uniforms = "segmentSize : i32", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.type = t, this.dispatchLayout = de(e), this.dispatch = ue(this.dispatchLayout, e, this.workgroupSize), this.shaderKey = "sparseSegmentMean";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type === "float32" ? "setOutputAtIndex(index, segmentSum[index] / f32(count));" : "setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `;
    }
  }
  function Bz(r, e, t, n = false, i) {
    const o = Ze(r.shape) / r.shape[0], s = r.dtype, l = Ze(e.shape), u = i.readSync(t.dataId), h = l > 0 ? u[l - 1] + 1 : 0;
    let f;
    const d = r.shape.slice();
    d[0] = h;
    const p = l * o, v = Hr({
      backend: i,
      attrs: {
        shape: d,
        value: 0,
        dtype: s
      }
    });
    f = new Qye(d, p, s);
    let g = [
      {
        type: "int32",
        data: [
          o
        ]
      },
      {
        type: "int32",
        data: [
          p
        ]
      }
    ];
    const m = i.runWebGPUProgram(f, [
      r,
      e,
      t
    ], s, g, v);
    if (n) return m;
    const y = Hr({
      backend: i,
      attrs: {
        shape: [
          h
        ],
        value: 0,
        dtype: "int32"
      }
    });
    f = new Jye(h, t.shape);
    const x = i.runWebGPUProgram(f, [
      t
    ], "int32", null, y), _ = Hr({
      backend: i,
      attrs: {
        shape: d,
        value: 0,
        dtype: s
      }
    });
    f = new e0e(d, s), g = [
      {
        type: "int32",
        data: [
          o
        ]
      }
    ];
    const S = i.runWebGPUProgram(f, [
      m,
      x
    ], s, g, _);
    return i.disposeData(m.dataId), i.disposeData(x.dataId), S;
  }
  function t0e(r) {
    const { inputs: e, backend: t } = r, { data: n, indices: i, segmentIds: a } = e;
    return Bz(n, i, a, false, t);
  }
  const r0e = {
    kernelName: o4,
    backendName: "webgpu",
    kernelFunc: t0e
  };
  function n0e(r) {
    const { inputs: e, backend: t } = r, { data: n, indices: i, segmentIds: a } = e;
    return Bz(n, i, a, true, t);
  }
  const i0e = {
    kernelName: s4,
    backendName: "webgpu",
    kernelFunc: n0e
  };
  class a0e {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true;
      const n = new Array(e.length);
      for (let i = 0; i < n.length; i++) n[i] = e[i] * t[i];
      this.outputShape = n, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.rank = this.outputShape.length, this.shaderKey = "tile";
    }
    getUserCode() {
      const e = o0e(this.rank, "uniforms.");
      return `
      ${se("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `;
    }
  }
  function o0e(r, e = "") {
    if (r >= 5) throw Error(`Tile for rank ${r} is not yet supported`);
    if (r === 1) return `(resRC % ${e}aShape)`;
    const t = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w"
    ], n = [];
    for (let i = 0; i < r; i++) n.push(`(${t[i]} % ${e}aShape[${i}])`);
    return n.join();
  }
  function sw(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { reps: a } = n;
    if (t.shouldExecuteOnCPU([
      i
    ]) || i.dtype === "string" || i.shape.length >= 5) {
      const l = t.readSync(i.dataId), u = i.dtype === "string" ? l.map((f) => Rb(f)) : l, c = au(i.shape, i.dtype, u), h = Kfe(c, a);
      return t.makeTensorInfo(h.shape, h.dtype, h.values);
    }
    const o = new a0e(i.shape, a);
    return t.runWebGPUProgram(o, [
      i
    ], i.dtype);
  }
  const s0e = {
    kernelName: l4,
    backendName: "webgpu",
    kernelFunc: sw
  };
  function l0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { sparseIndices: i, sparseValues: a, defaultValue: o } = e, { outputShape: s } = n, { sliceRank: l, numUpdates: u, sliceSize: c, strides: h, outputSize: f } = Bb(a, i, s), d = false;
    if (a.dtype === "string") {
      const C = t.bufferSync(i), T = t.bufferSync(a), A = Rb(t.readSync(o.dataId)[0]), M = Wfe(C, T, s, f, c, u, l, h, A, d);
      return t.makeTensorInfo(s, M.dtype, M.values);
    }
    const p = [
      f / c,
      c
    ], v = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u,
          l
        ]
      }
    }), g = a.shape.length ? we({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          u,
          c
        ]
      }
    }) : ln({
      inputs: {
        x: a
      },
      backend: t
    }), m = g.dtype, y = t.makeTensorInfo([], m, c4(1, m)), x = we({
      inputs: {
        x: o
      },
      backend: t,
      attrs: {
        shape: Array(p.length).fill(1)
      }
    }), _ = sw({
      inputs: {
        x
      },
      backend: t,
      attrs: {
        reps: p
      }
    }), S = Ze([
      u,
      c
    ]), b = [
      {
        type: "int32",
        data: [
          l
        ]
      },
      {
        type: "int32",
        data: h
      },
      {
        type: "int32",
        data: [
          S
        ]
      }
    ];
    switch (u) {
      case 0:
        break;
      case 1:
        {
          const C = new uh([
            u,
            c
          ], l, v.shape.length, g.shape.length, h, p, m, d);
          t.runWebGPUProgram(C, [
            g,
            v
          ], m, b, _);
        }
        break;
      default:
        {
          const C = new uh([
            u,
            c
          ], l, v.shape.length, y.shape.length, h, p, m, d);
          t.runWebGPUProgram(C, [
            y,
            v
          ], m, b, _);
        }
        {
          const C = new uh([
            u,
            c
          ], l, v.shape.length, g.shape.length, h, p, m);
          t.runWebGPUProgram(C, [
            g,
            v
          ], m, b, _);
        }
    }
    const w = we({
      inputs: {
        x: _
      },
      backend: t,
      attrs: {
        shape: s
      }
    });
    return t.disposeData(v.dataId), t.disposeData(g.dataId), t.disposeData(x.dataId), t.disposeData(y.dataId), t.disposeData(_.dataId), w;
  }
  const u0e = {
    kernelName: u4,
    backendName: "webgpu",
    kernelFunc: l0e
  };
  function c0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { numOrSizeSplits: a, axis: o } = n, s = Ys(o, i.shape)[0], l = f4(i, a, s), u = i.shape.length, c = new Array(u).fill(0), h = i.shape.slice();
    return l.map((f) => {
      const d = [
        ...h
      ];
      d[s] = f;
      const p = Hu({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: c,
          size: d
        }
      });
      return c[s] += f, p;
    });
  }
  const h0e = {
    kernelName: h4,
    backendName: "webgpu",
    kernelFunc: c0e
  };
  const f0e = dt({
    opType: ie.SQRT
  }), d0e = {
    kernelName: d4,
    backendName: "webgpu",
    kernelFunc: f0e
  };
  const p0e = {
    kernelName: p4,
    backendName: "webgpu",
    kernelFunc: ({ inputs: r, backend: e }) => {
      const { x: t } = r, n = e, i = new Uu(t.shape, ie.SQUARE);
      return n.runWebGPUProgram(i, [
        t
      ], t.dtype);
    }
  };
  const v0e = cr({
    opType: ze.SQUARED_DIFFERENCE
  }), g0e = {
    kernelName: v4,
    backendName: "webgpu",
    kernelFunc: v0e
  };
  function m0e({ inputs: r, attrs: e, backend: t }) {
    const { x: n } = r, i = new Uu(n.shape, ie.STEP, "stepAlpha : f32,"), a = [
      {
        type: "float32",
        data: [
          e.alpha
        ]
      }
    ];
    return t.runWebGPUProgram(i, [
      n
    ], n.dtype, a);
  }
  const y0e = {
    kernelName: g4,
    backendName: "webgpu",
    kernelFunc: m0e
  };
  class x0e {
    constructor(e) {
      this.variableNames = [
        "x"
      ], this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]);
      const t = Gt(this.outputShape.length);
      this.uniforms = `begin : ${t},  strides : ${t}, `, this.shaderKey = "stridedSlice";
    }
    getUserCode() {
      const e = this.outputShape.length;
      let t = "";
      if (e === 1) t = "coords * uniforms.strides + uniforms.begin";
      else {
        let i = 0;
        t = this.outputShape.map((a, o) => (i++, this.outputShape.length === 1 ? `coords * uniforms.strides[${o}] + uniforms.begin[${o}]` : `coords[${i - 1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",");
      }
      return `
       ${se("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `;
    }
  }
  function _0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { begin: a, end: o, strides: s, beginMask: l, endMask: u, ellipsisMask: c, newAxisMask: h, shrinkAxisMask: f } = n, { finalShapeSparse: d, finalShape: p, isIdentity: v, sliceDim0: g, isSimpleSlice: m, begin: y, end: x, strides: _ } = y4(i.shape, a, o, s, l, u, c, h, f);
    let S;
    if (v) S = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: p
      }
    });
    else if (g || m) {
      Mt(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
      const b = x4(y, x, _), w = Hu({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: y,
          size: b
        }
      });
      S = we({
        inputs: {
          x: w
        },
        backend: t,
        attrs: {
          shape: p
        }
      }), t.disposeData(w.dataId);
    } else if (t.shouldExecuteOnCPU([
      i
    ])) {
      const w = t.readSync(i.dataId), C = au(i.shape, i.dtype, w), T = Yfe(d, C, _, y);
      S = t.makeTensorInfo(p, i.dtype, T.values);
    } else {
      const w = new x0e(d), C = [
        {
          type: "int32",
          data: y
        },
        {
          type: "int32",
          data: _
        }
      ], T = t.runWebGPUProgram(w, [
        i
      ], i.dtype, C);
      S = we({
        inputs: {
          x: T
        },
        backend: t,
        attrs: {
          shape: p
        }
      }), t.disposeData(T.dataId);
    }
    return S;
  }
  const b0e = {
    kernelName: m4,
    backendName: "webgpu",
    kernelFunc: _0e
  };
  function S0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { separator: i, nGramWidths: a, leftPad: o, rightPad: s, padWidth: l, preserveShortSequences: u } = n, { data: c, dataSplits: h } = e, f = t.readSync(c.dataId), d = t.readSync(h.dataId), [p, v] = Xfe(f, d, i, a, o, s, l, u);
    return [
      t.makeTensorInfo([
        p.length
      ], "string", p),
      t.makeTensorInfo(h.shape, "int32", v)
    ];
  }
  const w0e = {
    kernelName: _4,
    backendName: "webgpu",
    kernelFunc: S0e
  };
  const C0e = cr({
    opType: ze.SUB,
    cpuKernelImpl: qfe,
    supportsComplex: true
  }), T0e = {
    kernelName: b4,
    backendName: "webgpu",
    kernelFunc: C0e
  };
  const A0e = dt({
    opType: ie.TAN
  }), I0e = {
    kernelName: S4,
    backendName: "webgpu",
    kernelFunc: A0e
  };
  const M0e = dt({
    opType: ie.TANH
  }), D0e = {
    kernelName: w4,
    backendName: "webgpu",
    kernelFunc: M0e
  };
  function P0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { tensor: i, indices: a, updates: o } = e, { sliceRank: s, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Bb(o, a, i.shape), f = [
      h / u,
      u
    ];
    if (h === 0) return t.makeTensorInfo(i.shape, a.dtype);
    const d = [], p = we({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          l,
          s
        ]
      }
    });
    d.push(p);
    const v = we({
      inputs: {
        x: o
      },
      backend: t,
      attrs: {
        shape: [
          l,
          u
        ]
      }
    });
    d.push(v);
    const g = we({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: f
      }
    });
    d.push(g);
    const m = sw({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        reps: Array(f.length).fill(1)
      }
    }), y = new uh([
      l,
      u
    ], s, p.shape.length, v.shape.length, c, f, i.dtype, false), x = Ze([
      l,
      u
    ]), _ = [
      {
        type: "int32",
        data: [
          s
        ]
      },
      {
        type: "int32",
        data: c
      },
      {
        type: "int32",
        data: [
          x
        ]
      }
    ], S = t.runWebGPUProgram(y, [
      v,
      p
    ], g.dtype, _, m);
    d.push(S);
    const b = we({
      inputs: {
        x: S
      },
      backend: t,
      attrs: {
        shape: i.shape
      }
    });
    return d.forEach((w) => t.disposeData(w.dataId)), b;
  }
  const k0e = {
    kernelName: C4,
    backendName: "webgpu",
    kernelFunc: P0e
  };
  class L0e {
    constructor(e) {
      this.variableNames = [
        "x",
        "indices"
      ], this.workgroupSize = [
        256,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = `inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`, this.shaderKey = "swap";
    }
    getUserCode() {
      return `
        ${se("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    }
  }
  class R0e {
    constructor(e) {
      this.variableNames = [
        "x",
        "indices"
      ], this.workgroupSize = [
        256,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = "inputSize : i32, firstPass : i32, k : i32,", this.shaderKey = "merge";
    }
    getUserCode() {
      return `
        ${se("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    }
  }
  function Ll(r, e) {
    e !== null && r.disposeData(e.dataId);
  }
  function DP(r) {
    let e = 1;
    for (; e < r; ) e *= 2;
    return e;
  }
  function E0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i } = e, { k: a, sorted: o } = n, s = i.shape, l = s[s.length - 1];
    if (t.shouldExecuteOnCPU([
      i
    ])) {
      const S = t.readSync(i.dataId), [b, w] = Zfe(S, s, i.dtype, a, o);
      return [
        t.makeTensorInfo(b.shape, b.dtype, b.values),
        t.makeTensorInfo(w.shape, w.dtype, w.values)
      ];
    }
    if (a === 0) return s[s.length - 1] = 0, [
      t.makeTensorInfo(s, i.dtype, []),
      t.makeTensorInfo(s, "int32", [])
    ];
    if (l === 1) return [
      i,
      Hr({
        attrs: {
          shape: s,
          dtype: "int32",
          value: 0
        },
        backend: t
      })
    ];
    const c = Ze(s) / l, h = we({
      inputs: {
        x: i
      },
      attrs: {
        shape: [
          c,
          l
        ]
      },
      backend: t
    }), f = DP(a), d = DP(l);
    let p = null;
    const v = () => p === null ? [
      h,
      h
    ] : [
      h,
      p
    ], g = (S, b, w) => {
      const C = v(), T = new L0e(w), M = [
        {
          type: "int32",
          data: [
            l
          ]
        },
        {
          type: "int32",
          data: [
            p === null ? 1 : 0
          ]
        },
        {
          type: "float32",
          data: [
            Number.NEGATIVE_INFINITY
          ]
        },
        {
          type: "int32",
          data: [
            S
          ]
        },
        {
          type: "int32",
          data: [
            b
          ]
        }
      ], E = p;
      p = t.runWebGPUProgram(T, C, "int32", M), Ll(t, E);
    };
    for (let S = 1; S < f; S *= 2) {
      const b = S * 2;
      for (let w = S; w >= 1; w /= 2) g(b, w, [
        c,
        d
      ]);
    }
    for (let S = d; S > f; S /= 2) {
      const b = v(), w = new R0e([
        c,
        S / 2
      ]), T = [
        {
          type: "int32",
          data: [
            l
          ]
        },
        {
          type: "int32",
          data: [
            p === null ? 1 : 0
          ]
        },
        {
          type: "int32",
          data: [
            f
          ]
        }
      ], A = p;
      p = t.runWebGPUProgram(w, b, "int32", T), Ll(t, A);
      const M = f / 2, E = M * 2;
      for (let k = M; k >= 1; k /= 2) g(E, k, p.shape);
    }
    let m = p;
    p = Hu({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        begin: 0,
        size: [
          c,
          a
        ]
      }
    }), Ll(t, m);
    let y = Rz({
      inputs: {
        x: h,
        indices: p
      },
      backend: t,
      attrs: {
        axis: 1,
        batchDims: 1
      }
    });
    Ll(t, h);
    const x = s.slice(0, -1);
    x.push(a), m = p, p = we({
      inputs: {
        x: p
      },
      attrs: {
        shape: x
      },
      backend: t
    }), Ll(t, m);
    const _ = y;
    return y = we({
      inputs: {
        x: y
      },
      attrs: {
        shape: x
      },
      backend: t
    }), Ll(t, _), [
      y,
      p
    ];
  }
  const N0e = {
    kernelName: T4,
    backendName: "webgpu",
    kernelFunc: E0e
  };
  class O0e {
    constructor(e) {
      this.variableNames = [
        "Image",
        "Transforms"
      ], this.uniforms = "interpolationModeId : i32, fillModeId : i32, fillValue : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = de(this.outputShape), this.dispatch = ue(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "transform";
    }
    getUserCode() {
      return `
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${se("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `;
    }
  }
  function F0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { image: i, transforms: a } = e, { interpolation: o, fillMode: s, fillValue: l, outputShape: u } = n, [c, h, f, d] = i.shape, [p, v] = u ?? [
      h,
      f
    ], g = [
      c,
      p,
      v,
      d
    ], m = new O0e(g), y = o === "nearest" ? 1 : 2;
    let x;
    switch (s) {
      case "constant":
        x = 1;
        break;
      case "reflect":
        x = 2;
        break;
      case "wrap":
        x = 3;
        break;
      case "nearest":
        x = 4;
        break;
      default:
        x = 1;
        break;
    }
    const _ = [
      {
        type: "int32",
        data: [
          y
        ]
      },
      {
        type: "int32",
        data: [
          x
        ]
      },
      {
        type: "float32",
        data: [
          l
        ]
      }
    ];
    return t.runWebGPUProgram(m, [
      i,
      a
    ], "float32", _);
  }
  const B0e = {
    kernelName: A4,
    backendName: "webgpu",
    kernelFunc: F0e
  };
  function z0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { value: i } = e;
    let { axis: a } = n;
    a < 0 && (a += i.shape.length);
    const o = i, s = o.shape.length, l = i.shape[a], u = new Array(s - 1);
    let c = 0;
    for (let v = 0; v < s; v++) v !== a && (u[c++] = o.shape[v]);
    const h = [], f = new Array(s).fill(0), d = o.shape.slice();
    d[a] = 1;
    const p = new Array(l);
    for (let v = 0; v < p.length; v++) {
      f[a] = v;
      const g = Hu({
        inputs: {
          x: o
        },
        backend: t,
        attrs: {
          begin: f,
          size: d
        }
      }), m = we({
        inputs: {
          x: g
        },
        backend: t,
        attrs: {
          shape: u
        }
      });
      p[v] = m, h.push(g);
    }
    return h.forEach((v) => t.disposeData(v.dataId)), p;
  }
  const V0e = {
    kernelName: I4,
    backendName: "webgpu",
    kernelFunc: z0e
  };
  class $0e {
    constructor(e, t, n) {
      if (this.outputShape = [], this.variableNames = [
        "x",
        "segmentIds"
      ], this.uniforms = "numSegments : i32, xSize: i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = t, this.dispatchLayout = de(e), this.dispatch = ue(this.dispatchLayout, e, this.workgroupSize), n !== "float32" && n !== "int32") throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${n} type.`);
      this.type = n, this.shaderKey = "unsortedSegmentSum";
    }
    getUserCode() {
      return `
    ${se("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${xo("&result[flatIndex]", "value", this.type)}
        }
      }
    }
  `;
    }
  }
  function G0e(r) {
    const { inputs: e, backend: t, attrs: n } = r, { x: i, segmentIds: a } = e, { numSegments: o } = n, s = i.shape.length, l = [];
    let u = 0;
    const c = lf([
      u
    ], s);
    let h = i;
    c != null && (h = Gi({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: c
      }
    }), l.push(h), u = uf(1, s)[0]);
    const f = D4(h.shape, u, o), d = Ze([
      h.shape[u]
    ]), p = we({
      inputs: {
        x: h
      },
      backend: t,
      attrs: {
        shape: [
          -1,
          d
        ]
      }
    });
    l.push(p);
    const v = i.dtype, g = [
      p.shape[0],
      o
    ], m = Hr({
      backend: t,
      attrs: {
        shape: g,
        value: 0,
        dtype: v
      }
    }), y = new $0e(p.shape, g, v), x = [
      {
        type: "int32",
        data: [
          o
        ]
      },
      {
        type: "int32",
        data: [
          Ze(p.shape)
        ]
      }
    ], _ = t.runWebGPUProgram(y, [
      p,
      a
    ], v, x, m), S = we({
      inputs: {
        x: _
      },
      backend: t,
      attrs: {
        shape: f
      }
    });
    l.push(_);
    let b = S;
    if (c != null) {
      l.push(S);
      const w = NL(c);
      b = Gi({
        inputs: {
          x: b
        },
        backend: t,
        attrs: {
          perm: w
        }
      });
    }
    return l.forEach((w) => t.disposeData(w.dataId)), b;
  }
  const W0e = {
    kernelName: M4,
    backendName: "webgpu",
    kernelFunc: G0e
  };
  const U0e = [
    vfe,
    Jfe,
    tde,
    nde,
    ade,
    lde,
    vde,
    mde,
    xde,
    bde,
    wde,
    Tde,
    Ide,
    Dde,
    kde,
    Ode,
    Bde,
    Gde,
    Ude,
    Yde,
    jde,
    tpe,
    ipe,
    lpe,
    cpe,
    ppe,
    mfe,
    mpe,
    bpe,
    Dpe,
    Npe,
    zpe,
    Gpe,
    Upe,
    Ype,
    qpe,
    Zpe,
    Jpe,
    tve,
    nve,
    ave,
    lve,
    vve,
    mve,
    hve,
    _ve,
    wve,
    Ive,
    Dve,
    Lve,
    Ove,
    Bve,
    Vve,
    Gve,
    Uve,
    Yve,
    Xve,
    Kve,
    jve,
    ffe,
    Jve,
    age,
    tge,
    nge,
    lge,
    cge,
    fge,
    vge,
    yge,
    _ge,
    Sge,
    gfe,
    Cge,
    xpe,
    Age,
    Mge,
    Pge,
    Lge,
    Ege,
    Oge,
    zge,
    Wge,
    $ge,
    Hge,
    Xge,
    Kge,
    Jge,
    rme,
    Rde,
    ime,
    ome,
    pme,
    lme,
    fme,
    gme,
    Ede,
    yme,
    _me,
    Sme,
    Cme,
    Dme,
    Rve,
    kme,
    Rme,
    Nme,
    ape,
    Bme,
    Vme,
    Gme,
    Hme,
    Xme,
    Kme,
    jme,
    Jme,
    ope,
    tye,
    nye,
    aye,
    sye,
    dfe,
    cye,
    dye,
    gye,
    xye,
    Sye,
    Cye,
    Aye,
    Mye,
    Pye,
    Rye,
    Oye,
    Bye,
    Vye,
    Gye,
    Uye,
    Yye,
    Kde,
    y0e,
    b0e,
    w0e,
    Ime,
    qye,
    jye,
    r0e,
    i0e,
    u0e,
    h0e,
    d0e,
    p0e,
    g0e,
    T0e,
    Eve,
    I0e,
    D0e,
    k0e,
    s0e,
    N0e,
    B0e,
    hde,
    V0e,
    W0e,
    zme
  ];
  for (const r of U0e) P4(r);
  function H0e(r) {
    return new Worker("/tfjs_model_tester/assets/detect.worker-B05RgSrS.js", {
      name: r == null ? void 0 : r.name
    });
  }
  var Wc = ((r) => (r.detect = "detect", r.stop = "stop", r.loadModel = "loadModel", r.disposeModel = "disposeModel", r.testRun = "testRun", r))(Wc || {});
  class zz {
    constructor(e) {
      __publicField(this, "_canvas");
      __publicField(this, "onSelect");
      this._canvas = e;
    }
  }
  class PP {
    constructor() {
      __publicField(this, "palette");
      __publicField(this, "n");
      __publicField(this, "get", (e) => this.palette[Math.floor(e) % this.n]);
      this.palette = [
        "#FF3838",
        "#FF9D97",
        "#FF701F",
        "#FFB21D",
        "#CFD231",
        "#48F90A",
        "#92CC17",
        "#3DDB86",
        "#1A9334",
        "#00D4BB",
        "#2C99A8",
        "#00C2FF",
        "#344593",
        "#6473FF",
        "#0018EC",
        "#8438FF",
        "#520085",
        "#CB38FF",
        "#FF95C8",
        "#FF37C7"
      ], this.n = this.palette.length;
    }
  }
  __publicField(PP, "hexToRgba", (e, t) => {
    const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return n ? `rgba(${[
      parseInt(n[1], 16),
      parseInt(n[2], 16),
      parseInt(n[3], 16)
    ].join(", ")}, ${t})` : null;
  });
  class Y0e extends zz {
    init() {
      throw new Error("Method not implemented.");
    }
    render(e, t, n, i, a) {
      throw new Error("Method not implemented.");
    }
    clear() {
      throw new Error("Method not implemented.");
    }
    dispose() {
      throw new Error("Method not implemented.");
    }
    capture(e) {
      throw new Error("Method not implemented.");
    }
  }
  Ct = ((r) => (r.Application = "application", r.WebGLPipes = "webgl-pipes", r.WebGLPipesAdaptor = "webgl-pipes-adaptor", r.WebGLSystem = "webgl-system", r.WebGPUPipes = "webgpu-pipes", r.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", r.WebGPUSystem = "webgpu-system", r.CanvasSystem = "canvas-system", r.CanvasPipesAdaptor = "canvas-pipes-adaptor", r.CanvasPipes = "canvas-pipes", r.Asset = "asset", r.LoadParser = "load-parser", r.ResolveParser = "resolve-parser", r.CacheParser = "cache-parser", r.DetectionParser = "detection-parser", r.MaskEffect = "mask-effect", r.BlendMode = "blend-mode", r.TextureSource = "texture-source", r.Environment = "environment", r.ShapeBuilder = "shape-builder", r.Batcher = "batcher", r))(Ct || {});
  let rb, Gd, X0e, q0e;
  rb = (r) => {
    if (typeof r == "function" || typeof r == "object" && r.extension) {
      if (!r.extension) throw new Error("Extension class must have an extension object");
      r = {
        ...typeof r.extension != "object" ? {
          type: r.extension
        } : r.extension,
        ref: r
      };
    }
    if (typeof r == "object") r = {
      ...r
    };
    else throw new Error("Invalid extension type");
    return typeof r.type == "string" && (r.type = [
      r.type
    ]), r;
  };
  Gd = (r, e) => rb(r).priority ?? e;
  Wn = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...r) {
      return r.map(rb).forEach((e) => {
        e.type.forEach((t) => {
          var _a2, _b2;
          return (_b2 = (_a2 = this._removeHandlers)[t]) == null ? void 0 : _b2.call(_a2, e);
        });
      }), this;
    },
    add(...r) {
      return r.map(rb).forEach((e) => {
        e.type.forEach((t) => {
          var _a2, _b2;
          const n = this._addHandlers, i = this._queue;
          n[t] ? (_a2 = n[t]) == null ? void 0 : _a2.call(n, e) : (i[t] = i[t] || [], (_b2 = i[t]) == null ? void 0 : _b2.push(e));
        });
      }), this;
    },
    handle(r, e, t) {
      var _a2;
      const n = this._addHandlers, i = this._removeHandlers;
      if (n[r] || i[r]) throw new Error(`Extension type ${r} already has a handler`);
      n[r] = e, i[r] = t;
      const a = this._queue;
      return a[r] && ((_a2 = a[r]) == null ? void 0 : _a2.forEach((o) => e(o)), delete a[r]), this;
    },
    handleByMap(r, e) {
      return this.handle(r, (t) => {
        t.name && (e[t.name] = t.ref);
      }, (t) => {
        t.name && delete e[t.name];
      });
    },
    handleByNamedList(r, e, t = -1) {
      return this.handle(r, (n) => {
        e.findIndex((a) => a.name === n.name) >= 0 || (e.push({
          name: n.name,
          value: n.ref
        }), e.sort((a, o) => Gd(o.value, t) - Gd(a.value, t)));
      }, (n) => {
        const i = e.findIndex((a) => a.name === n.name);
        i !== -1 && e.splice(i, 1);
      });
    },
    handleByList(r, e, t = -1) {
      return this.handle(r, (n) => {
        e.includes(n.ref) || (e.push(n.ref), e.sort((i, a) => Gd(a, t) - Gd(i, t)));
      }, (n) => {
        const i = e.indexOf(n.ref);
        i !== -1 && e.splice(i, 1);
      });
    },
    mixin(r, ...e) {
      for (const t of e) Object.defineProperties(r.prototype, Object.getOwnPropertyDescriptors(t));
    }
  };
  X0e = {
    extension: {
      type: Ct.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await ou(() => import("./browserAll-BmRNpMLm.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([0,1,2,3,4,5,6]));
    }
  };
  q0e = {
    extension: {
      type: Ct.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await ou(() => import("./webworkerAll-Df24uNNZ.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([1,2,3,4,5,6]));
    }
  };
  class Jr {
    constructor(e, t, n) {
      this._x = t || 0, this._y = n || 0, this._observer = e;
    }
    clone(e) {
      return new Jr(e ?? this._observer, this._x, this._y);
    }
    set(e = 0, t = e) {
      return (this._x !== e || this._y !== t) && (this._x = e, this._y = t, this._observer._onUpdate(this)), this;
    }
    copyFrom(e) {
      return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this;
    }
    copyTo(e) {
      return e.set(this._x, this._y), e;
    }
    equals(e) {
      return e.x === this._x && e.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x !== e && (this._x = e, this._observer._onUpdate(this));
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y !== e && (this._y = e, this._observer._onUpdate(this));
    }
  }
  var x0 = {
    exports: {}
  }, kP;
  function K0e() {
    return kP || (kP = 1, function(r) {
      var e = Object.prototype.hasOwnProperty, t = "~";
      function n() {
      }
      Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (t = false));
      function i(l, u, c) {
        this.fn = l, this.context = u, this.once = c || false;
      }
      function a(l, u, c, h, f) {
        if (typeof c != "function") throw new TypeError("The listener must be a function");
        var d = new i(c, h || l, f), p = t ? t + u : u;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [
          l._events[p],
          d
        ] : l._events[p].push(d) : (l._events[p] = d, l._eventsCount++), l;
      }
      function o(l, u) {
        --l._eventsCount === 0 ? l._events = new n() : delete l._events[u];
      }
      function s() {
        this._events = new n(), this._eventsCount = 0;
      }
      s.prototype.eventNames = function() {
        var u = [], c, h;
        if (this._eventsCount === 0) return u;
        for (h in c = this._events) e.call(c, h) && u.push(t ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u;
      }, s.prototype.listeners = function(u) {
        var c = t ? t + u : u, h = this._events[c];
        if (!h) return [];
        if (h.fn) return [
          h.fn
        ];
        for (var f = 0, d = h.length, p = new Array(d); f < d; f++) p[f] = h[f].fn;
        return p;
      }, s.prototype.listenerCount = function(u) {
        var c = t ? t + u : u, h = this._events[c];
        return h ? h.fn ? 1 : h.length : 0;
      }, s.prototype.emit = function(u, c, h, f, d, p) {
        var v = t ? t + u : u;
        if (!this._events[v]) return false;
        var g = this._events[v], m = arguments.length, y, x;
        if (g.fn) {
          switch (g.once && this.removeListener(u, g.fn, void 0, true), m) {
            case 1:
              return g.fn.call(g.context), true;
            case 2:
              return g.fn.call(g.context, c), true;
            case 3:
              return g.fn.call(g.context, c, h), true;
            case 4:
              return g.fn.call(g.context, c, h, f), true;
            case 5:
              return g.fn.call(g.context, c, h, f, d), true;
            case 6:
              return g.fn.call(g.context, c, h, f, d, p), true;
          }
          for (x = 1, y = new Array(m - 1); x < m; x++) y[x - 1] = arguments[x];
          g.fn.apply(g.context, y);
        } else {
          var _ = g.length, S;
          for (x = 0; x < _; x++) switch (g[x].once && this.removeListener(u, g[x].fn, void 0, true), m) {
            case 1:
              g[x].fn.call(g[x].context);
              break;
            case 2:
              g[x].fn.call(g[x].context, c);
              break;
            case 3:
              g[x].fn.call(g[x].context, c, h);
              break;
            case 4:
              g[x].fn.call(g[x].context, c, h, f);
              break;
            default:
              if (!y) for (S = 1, y = new Array(m - 1); S < m; S++) y[S - 1] = arguments[S];
              g[x].fn.apply(g[x].context, y);
          }
        }
        return true;
      }, s.prototype.on = function(u, c, h) {
        return a(this, u, c, h, false);
      }, s.prototype.once = function(u, c, h) {
        return a(this, u, c, h, true);
      }, s.prototype.removeListener = function(u, c, h, f) {
        var d = t ? t + u : u;
        if (!this._events[d]) return this;
        if (!c) return o(this, d), this;
        var p = this._events[d];
        if (p.fn) p.fn === c && (!f || p.once) && (!h || p.context === h) && o(this, d);
        else {
          for (var v = 0, g = [], m = p.length; v < m; v++) (p[v].fn !== c || f && !p[v].once || h && p[v].context !== h) && g.push(p[v]);
          g.length ? this._events[d] = g.length === 1 ? g[0] : g : o(this, d);
        }
        return this;
      }, s.prototype.removeAllListeners = function(u) {
        var c;
        return u ? (c = t ? t + u : u, this._events[c] && o(this, c)) : (this._events = new n(), this._eventsCount = 0), this;
      }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = t, s.EventEmitter = s, r.exports = s;
    }(x0)), x0.exports;
  }
  var Z0e = K0e();
  let j0e, Q0e, J0e;
  Yi = zb(Z0e);
  j0e = Math.PI * 2;
  Q0e = 180 / Math.PI;
  J0e = Math.PI / 180;
  Dr = class {
    constructor(e = 0, t = 0) {
      this.x = 0, this.y = 0, this.x = e, this.y = t;
    }
    clone() {
      return new Dr(this.x, this.y);
    }
    copyFrom(e) {
      return this.set(e.x, e.y), this;
    }
    copyTo(e) {
      return e.set(this.x, this.y), e;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    set(e = 0, t = e) {
      return this.x = e, this.y = t, this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
      return _0.x = 0, _0.y = 0, _0;
    }
  };
  const _0 = new Dr();
  pt = class {
    constructor(e = 1, t = 0, n = 0, i = 1, a = 0, o = 0) {
      this.array = null, this.a = e, this.b = t, this.c = n, this.d = i, this.tx = a, this.ty = o;
    }
    fromArray(e) {
      this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
    }
    set(e, t, n, i, a, o) {
      return this.a = e, this.b = t, this.c = n, this.d = i, this.tx = a, this.ty = o, this;
    }
    toArray(e, t) {
      this.array || (this.array = new Float32Array(9));
      const n = t || this.array;
      return e ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n;
    }
    apply(e, t) {
      t = t || new Dr();
      const n = e.x, i = e.y;
      return t.x = this.a * n + this.c * i + this.tx, t.y = this.b * n + this.d * i + this.ty, t;
    }
    applyInverse(e, t) {
      t = t || new Dr();
      const n = this.a, i = this.b, a = this.c, o = this.d, s = this.tx, l = this.ty, u = 1 / (n * o + a * -i), c = e.x, h = e.y;
      return t.x = o * u * c + -a * u * h + (l * a - s * o) * u, t.y = n * u * h + -i * u * c + (-l * n + s * i) * u, t;
    }
    translate(e, t) {
      return this.tx += e, this.ty += t, this;
    }
    scale(e, t) {
      return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this;
    }
    rotate(e) {
      const t = Math.cos(e), n = Math.sin(e), i = this.a, a = this.c, o = this.tx;
      return this.a = i * t - this.b * n, this.b = i * n + this.b * t, this.c = a * t - this.d * n, this.d = a * n + this.d * t, this.tx = o * t - this.ty * n, this.ty = o * n + this.ty * t, this;
    }
    append(e) {
      const t = this.a, n = this.b, i = this.c, a = this.d;
      return this.a = e.a * t + e.b * i, this.b = e.a * n + e.b * a, this.c = e.c * t + e.d * i, this.d = e.c * n + e.d * a, this.tx = e.tx * t + e.ty * i + this.tx, this.ty = e.tx * n + e.ty * a + this.ty, this;
    }
    appendFrom(e, t) {
      const n = e.a, i = e.b, a = e.c, o = e.d, s = e.tx, l = e.ty, u = t.a, c = t.b, h = t.c, f = t.d;
      return this.a = n * u + i * h, this.b = n * c + i * f, this.c = a * u + o * h, this.d = a * c + o * f, this.tx = s * u + l * h + t.tx, this.ty = s * c + l * f + t.ty, this;
    }
    setTransform(e, t, n, i, a, o, s, l, u) {
      return this.a = Math.cos(s + u) * a, this.b = Math.sin(s + u) * a, this.c = -Math.sin(s - l) * o, this.d = Math.cos(s - l) * o, this.tx = e - (n * this.a + i * this.c), this.ty = t - (n * this.b + i * this.d), this;
    }
    prepend(e) {
      const t = this.tx;
      if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
        const n = this.a, i = this.c;
        this.a = n * e.a + this.b * e.c, this.b = n * e.b + this.b * e.d, this.c = i * e.a + this.d * e.c, this.d = i * e.b + this.d * e.d;
      }
      return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this;
    }
    decompose(e) {
      const t = this.a, n = this.b, i = this.c, a = this.d, o = e.pivot, s = -Math.atan2(-i, a), l = Math.atan2(n, t), u = Math.abs(s + l);
      return u < 1e-5 || Math.abs(j0e - u) < 1e-5 ? (e.rotation = l, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = s, e.skew.y = l), e.scale.x = Math.sqrt(t * t + n * n), e.scale.y = Math.sqrt(i * i + a * a), e.position.x = this.tx + (o.x * t + o.y * i), e.position.y = this.ty + (o.x * n + o.y * a), e;
    }
    invert() {
      const e = this.a, t = this.b, n = this.c, i = this.d, a = this.tx, o = e * i - t * n;
      return this.a = i / o, this.b = -t / o, this.c = -n / o, this.d = e / o, this.tx = (n * this.ty - i * a) / o, this.ty = -(e * this.ty - t * a) / o, this;
    }
    isIdentity() {
      return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    identity() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }
    clone() {
      const e = new pt();
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }
    copyTo(e) {
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }
    copyFrom(e) {
      return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
    }
    equals(e) {
      return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return txe.identity();
    }
    static get shared() {
      return exe.identity();
    }
  };
  const exe = new pt(), txe = new pt(), os = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1
  ], ss = [
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], ls = [
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], us = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1
  ], nb = [], Vz = [], Wd = Math.sign;
  function rxe() {
    for (let r = 0; r < 16; r++) {
      const e = [];
      nb.push(e);
      for (let t = 0; t < 16; t++) {
        const n = Wd(os[r] * os[t] + ls[r] * ss[t]), i = Wd(ss[r] * os[t] + us[r] * ss[t]), a = Wd(os[r] * ls[t] + ls[r] * us[t]), o = Wd(ss[r] * ls[t] + us[r] * us[t]);
        for (let s = 0; s < 16; s++) if (os[s] === n && ss[s] === i && ls[s] === a && us[s] === o) {
          e.push(s);
          break;
        }
      }
    }
    for (let r = 0; r < 16; r++) {
      const e = new pt();
      e.set(os[r], ss[r], ls[r], us[r], 0, 0), Vz.push(e);
    }
  }
  rxe();
  const Ft = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (r) => os[r],
    uY: (r) => ss[r],
    vX: (r) => ls[r],
    vY: (r) => us[r],
    inv: (r) => r & 8 ? r & 15 : -r & 7,
    add: (r, e) => nb[r][e],
    sub: (r, e) => nb[r][Ft.inv(e)],
    rotate180: (r) => r ^ 4,
    isVertical: (r) => (r & 3) === 2,
    byDirection: (r, e) => Math.abs(r) * 2 <= Math.abs(e) ? e >= 0 ? Ft.S : Ft.N : Math.abs(e) * 2 <= Math.abs(r) ? r > 0 ? Ft.E : Ft.W : e > 0 ? r > 0 ? Ft.SE : Ft.SW : r > 0 ? Ft.NE : Ft.NW,
    matrixAppendRotationInv: (r, e, t = 0, n = 0) => {
      const i = Vz[Ft.inv(e)];
      i.tx = t, i.ty = n, r.append(i);
    }
  }, Ud = [
    new Dr(),
    new Dr(),
    new Dr(),
    new Dr()
  ];
  gr = class {
    constructor(e = 0, t = 0, n = 0, i = 0) {
      this.type = "rectangle", this.x = Number(e), this.y = Number(t), this.width = Number(n), this.height = Number(i);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new gr(0, 0, 0, 0);
    }
    clone() {
      return new gr(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(e) {
      return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    contains(e, t) {
      return this.width <= 0 || this.height <= 0 ? false : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
    }
    strokeContains(e, t, n, i = 0.5) {
      const { width: a, height: o } = this;
      if (a <= 0 || o <= 0) return false;
      const s = this.x, l = this.y, u = n * (1 - i), c = n - u, h = s - u, f = s + a + u, d = l - u, p = l + o + u, v = s + c, g = s + a - c, m = l + c, y = l + o - c;
      return e >= h && e <= f && t >= d && t <= p && !(e > v && e < g && t > m && t < y);
    }
    intersects(e, t) {
      if (!t) {
        const C = this.x < e.x ? e.x : this.x;
        if ((this.right > e.right ? e.right : this.right) <= C) return false;
        const A = this.y < e.y ? e.y : this.y;
        return (this.bottom > e.bottom ? e.bottom : this.bottom) > A;
      }
      const n = this.left, i = this.right, a = this.top, o = this.bottom;
      if (i <= n || o <= a) return false;
      const s = Ud[0].set(e.left, e.top), l = Ud[1].set(e.left, e.bottom), u = Ud[2].set(e.right, e.top), c = Ud[3].set(e.right, e.bottom);
      if (u.x <= s.x || l.y <= s.y) return false;
      const h = Math.sign(t.a * t.d - t.b * t.c);
      if (h === 0 || (t.apply(s, s), t.apply(l, l), t.apply(u, u), t.apply(c, c), Math.max(s.x, l.x, u.x, c.x) <= n || Math.min(s.x, l.x, u.x, c.x) >= i || Math.max(s.y, l.y, u.y, c.y) <= a || Math.min(s.y, l.y, u.y, c.y) >= o)) return false;
      const f = h * (l.y - s.y), d = h * (s.x - l.x), p = f * n + d * a, v = f * i + d * a, g = f * n + d * o, m = f * i + d * o;
      if (Math.max(p, v, g, m) <= f * s.x + d * s.y || Math.min(p, v, g, m) >= f * c.x + d * c.y) return false;
      const y = h * (s.y - u.y), x = h * (u.x - s.x), _ = y * n + x * a, S = y * i + x * a, b = y * n + x * o, w = y * i + x * o;
      return !(Math.max(_, S, b, w) <= y * s.x + x * s.y || Math.min(_, S, b, w) >= y * c.x + x * c.y);
    }
    pad(e = 0, t = e) {
      return this.x -= e, this.y -= t, this.width += e * 2, this.height += t * 2, this;
    }
    fit(e) {
      const t = Math.max(this.x, e.x), n = Math.min(this.x + this.width, e.x + e.width), i = Math.max(this.y, e.y), a = Math.min(this.y + this.height, e.y + e.height);
      return this.x = t, this.width = Math.max(n - t, 0), this.y = i, this.height = Math.max(a - i, 0), this;
    }
    ceil(e = 1, t = 1e-3) {
      const n = Math.ceil((this.x + this.width - t) * e) / e, i = Math.ceil((this.y + this.height - t) * e) / e;
      return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = n - this.x, this.height = i - this.y, this;
    }
    enlarge(e) {
      const t = Math.min(this.x, e.x), n = Math.max(this.x + this.width, e.x + e.width), i = Math.min(this.y, e.y), a = Math.max(this.y + this.height, e.y + e.height);
      return this.x = t, this.width = n - t, this.y = i, this.height = a - i, this;
    }
    getBounds(e) {
      return e || (e = new gr()), e.copyFrom(this), e;
    }
    containsRect(e) {
      if (this.width <= 0 || this.height <= 0) return false;
      const t = e.x, n = e.y, i = e.x + e.width, a = e.y + e.height;
      return t >= this.x && t < this.x + this.width && n >= this.y && n < this.y + this.height && i >= this.x && i < this.x + this.width && a >= this.y && a < this.y + this.height;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };
  const b0 = {
    default: -1
  };
  Qt = function(r = "default") {
    return b0[r] === void 0 && (b0[r] = -1), ++b0[r];
  };
  let LP, nxe;
  LP = {};
  $t = "8.0.0";
  nxe = "8.3.4";
  Pt = function(r, e, t = 3) {
    if (LP[e]) return;
    let n = new Error().stack;
    typeof n > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${r}`) : (n = n.split(`
`).splice(t).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${r}`), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${r}`), console.warn(n))), LP[e] = true;
  };
  const $z = () => {
  };
  RP = function(r) {
    return r += r === 0 ? 1 : 0, --r, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r + 1;
  };
  function EP(r) {
    return !(r & r - 1) && !!r;
  }
  function Gz(r) {
    const e = {};
    for (const t in r) r[t] !== void 0 && (e[t] = r[t]);
    return e;
  }
  const NP = /* @__PURE__ */ Object.create(null);
  function ixe(r) {
    const e = NP[r];
    return e === void 0 && (NP[r] = Qt("resource")), e;
  }
  const Wz = class Uz extends Yi {
    constructor(e = {}) {
      super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = false, e = {
        ...Uz.defaultOptions,
        ...e
      }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ?? this.addressModeU, this.addressModeV = e.addressModeV ?? this.addressModeV, this.addressModeW = e.addressModeW ?? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ?? this.magFilter, this.minFilter = e.minFilter ?? this.minFilter, this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ?? 1;
    }
    set addressMode(e) {
      this.addressModeU = e, this.addressModeV = e, this.addressModeW = e;
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(e) {
      Pt($t, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e;
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(e) {
      this.magFilter = e, this.minFilter = e, this.mipmapFilter = e;
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(e) {
      this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this), this._sharedResourceId = null;
    }
    _generateResourceId() {
      const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      return this._sharedResourceId = ixe(e), this._resourceId;
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
    }
  };
  Wz.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  axe = Wz;
  const Hz = class Yz extends Yi {
    constructor(e = {}) {
      super(), this.options = e, this.uid = Qt("textureSource"), this._resourceType = "textureSource", this._resourceId = Qt("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = false, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = false, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = {
        ...Yz.defaultOptions,
        ...e
      }, this.label = e.label ?? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new axe(Gz(e)), this.destroyed = false, this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(e) {
      var _a2, _b2;
      this.style !== e && ((_a2 = this._style) == null ? void 0 : _a2.off("change", this._onStyleChange, this), this._style = e, (_b2 = this._style) == null ? void 0 : _b2.on("change", this._onStyleChange, this), this._onStyleChange());
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(e) {
      this._style.addressMode = e;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(e) {
      this._style.addressMode = e;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(e) {
      this._style.magFilter = e;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(e) {
      this._style.minFilter = e;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(e) {
      this._style.mipmapFilter = e;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(e) {
      this._style.lodMinClamp = e;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(e) {
      this._style.lodMaxClamp = e;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const e = this._resolution;
        if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return;
      }
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
    }
    unload() {
      this._resourceId = Qt("resource"), this.emit("change", this), this.emit("unload", this);
    }
    get resourceWidth() {
      const { resource: e } = this;
      return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
    }
    get resourceHeight() {
      const { resource: e } = this;
      return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e);
    }
    resize(e, t, n) {
      n || (n = this._resolution), e || (e = this.width), t || (t = this.height);
      const i = Math.round(e * n), a = Math.round(t * n);
      return this.width = i / n, this.height = a / n, this._resolution = n, this.pixelWidth === i && this.pixelHeight === a ? false : (this._refreshPOT(), this.pixelWidth = i, this.pixelHeight = a, this.emit("resize", this), this._resourceId = Qt("resource"), this.emit("change", this), true);
    }
    updateMipmaps() {
      this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
    }
    set wrapMode(e) {
      this._style.wrapMode = e;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(e) {
      this._style.scaleMode = e;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = EP(this.pixelWidth) && EP(this.pixelHeight);
    }
    static test(e) {
      throw new Error("Unimplemented");
    }
  };
  Hz.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
    autoGarbageCollect: false
  };
  fi = Hz;
  class lw extends fi {
    constructor(e) {
      const t = e.resource || new Float32Array(e.width * e.height * 4);
      let n = e.format;
      n || (t instanceof Float32Array ? n = "rgba32float" : t instanceof Int32Array || t instanceof Uint32Array ? n = "rgba32uint" : t instanceof Int16Array || t instanceof Uint16Array ? n = "rgba16uint" : (t instanceof Int8Array, n = "bgra8unorm")), super({
        ...e,
        resource: t,
        format: n
      }), this.uploadMethodId = "buffer";
    }
    static test(e) {
      return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array;
    }
  }
  lw.extension = Ct.TextureSource;
  const OP = new pt();
  oxe = class {
    constructor(e, t) {
      this.mapCoord = new pt(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof t > "u" ? this.clampMargin = e.width < 10 ? 0 : 0.5 : this.clampMargin = t, this.isSimple = false, this.texture = e;
    }
    get texture() {
      return this._texture;
    }
    set texture(e) {
      var _a2;
      this.texture !== e && ((_a2 = this._texture) == null ? void 0 : _a2.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update());
    }
    multiplyUvs(e, t) {
      t === void 0 && (t = e);
      const n = this.mapCoord;
      for (let i = 0; i < e.length; i += 2) {
        const a = e[i], o = e[i + 1];
        t[i] = a * n.a + o * n.c + n.tx, t[i + 1] = a * n.b + o * n.d + n.ty;
      }
      return t;
    }
    update() {
      const e = this._texture;
      this._updateID++;
      const t = e.uvs;
      this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0);
      const n = e.orig, i = e.trim;
      i && (OP.set(n.width / i.width, 0, 0, n.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(OP));
      const a = e.source, o = this.uClampFrame, s = this.clampMargin / a._resolution, l = this.clampOffset / a._resolution;
      return o[0] = (e.frame.x + s + l) / a.width, o[1] = (e.frame.y + s + l) / a.height, o[2] = (e.frame.x + e.frame.width - s + l) / a.width, o[3] = (e.frame.y + e.frame.height - s + l) / a.height, this.uClampOffset[0] = this.clampOffset / a.pixelWidth, this.uClampOffset[1] = this.clampOffset / a.pixelHeight, this.isSimple = e.frame.width === a.width && e.frame.height === a.height && e.rotate === 0, true;
    }
  };
  At = class extends Yi {
    constructor({ source: e, label: t, frame: n, orig: i, trim: a, defaultAnchor: o, defaultBorders: s, rotate: l, dynamic: u } = {}) {
      if (super(), this.uid = Qt("texture"), this.uvs = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        x3: 0,
        y3: 0
      }, this.frame = new gr(), this.noFrame = false, this.dynamic = false, this.isTexture = true, this.label = t, this.source = (e == null ? void 0 : e.source) ?? new fi(), this.noFrame = !n, n) this.frame.copyFrom(n);
      else {
        const { width: c, height: h } = this._source;
        this.frame.width = c, this.frame.height = h;
      }
      this.orig = i || this.frame, this.trim = a, this.rotate = l ?? 0, this.defaultAnchor = o, this.defaultBorders = s, this.destroyed = false, this.dynamic = u || false, this.updateUvs();
    }
    set source(e) {
      this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      return this._textureMatrix || (this._textureMatrix = new oxe(this)), this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const { uvs: e, frame: t } = this, { width: n, height: i } = this._source, a = t.x / n, o = t.y / i, s = t.width / n, l = t.height / i;
      let u = this.rotate;
      if (u) {
        const c = s / 2, h = l / 2, f = a + c, d = o + h;
        u = Ft.add(u, Ft.NW), e.x0 = f + c * Ft.uX(u), e.y0 = d + h * Ft.uY(u), u = Ft.add(u, 2), e.x1 = f + c * Ft.uX(u), e.y1 = d + h * Ft.uY(u), u = Ft.add(u, 2), e.x2 = f + c * Ft.uX(u), e.y2 = d + h * Ft.uY(u), u = Ft.add(u, 2), e.x3 = f + c * Ft.uX(u), e.y3 = d + h * Ft.uY(u);
      } else e.x0 = a, e.y0 = o, e.x1 = a + s, e.y1 = o, e.x2 = a + s, e.y2 = o + l, e.x3 = a, e.y3 = o + l;
    }
    destroy(e = false) {
      this._source && e && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = true, this.emit("destroy", this), this.removeAllListeners();
    }
    update() {
      this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
    }
    get baseTexture() {
      return Pt($t, "Texture.baseTexture is now Texture.source"), this._source;
    }
  };
  At.EMPTY = new At({
    label: "EMPTY",
    source: new fi({
      label: "EMPTY"
    })
  });
  At.EMPTY.destroy = $z;
  At.WHITE = new At({
    source: new lw({
      resource: new Uint8Array([
        255,
        255,
        255,
        255
      ]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  At.WHITE.destroy = $z;
  sxe = function(r, e, t) {
    const { width: n, height: i } = t.orig, a = t.trim;
    if (a) {
      const o = a.width, s = a.height;
      r.minX = a.x - e._x * n, r.maxX = r.minX + o, r.minY = a.y - e._y * i, r.maxY = r.minY + s;
    } else r.minX = -e._x * n, r.maxX = r.minX + n, r.minY = -e._y * i, r.maxY = r.minY + i;
  };
  const FP = new pt();
  ui = class {
    constructor(e = 1 / 0, t = 1 / 0, n = -1 / 0, i = -1 / 0) {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = FP, this.minX = e, this.minY = t, this.maxX = n, this.maxY = i;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      this._rectangle || (this._rectangle = new gr());
      const e = this._rectangle;
      return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e;
    }
    clear() {
      return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = FP, this;
    }
    set(e, t, n, i) {
      this.minX = e, this.minY = t, this.maxX = n, this.maxY = i;
    }
    addFrame(e, t, n, i, a) {
      a || (a = this.matrix);
      const o = a.a, s = a.b, l = a.c, u = a.d, c = a.tx, h = a.ty;
      let f = this.minX, d = this.minY, p = this.maxX, v = this.maxY, g = o * e + l * t + c, m = s * e + u * t + h;
      g < f && (f = g), m < d && (d = m), g > p && (p = g), m > v && (v = m), g = o * n + l * t + c, m = s * n + u * t + h, g < f && (f = g), m < d && (d = m), g > p && (p = g), m > v && (v = m), g = o * e + l * i + c, m = s * e + u * i + h, g < f && (f = g), m < d && (d = m), g > p && (p = g), m > v && (v = m), g = o * n + l * i + c, m = s * n + u * i + h, g < f && (f = g), m < d && (d = m), g > p && (p = g), m > v && (v = m), this.minX = f, this.minY = d, this.maxX = p, this.maxY = v;
    }
    addRect(e, t) {
      this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t);
    }
    addBounds(e, t) {
      this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t);
    }
    addBoundsMask(e) {
      this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY;
    }
    applyMatrix(e) {
      const t = this.minX, n = this.minY, i = this.maxX, a = this.maxY, { a: o, b: s, c: l, d: u, tx: c, ty: h } = e;
      let f = o * t + l * n + c, d = s * t + u * n + h;
      this.minX = f, this.minY = d, this.maxX = f, this.maxY = d, f = o * i + l * n + c, d = s * i + u * n + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, f = o * t + l * a + c, d = s * t + u * a + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, f = o * i + l * a + c, d = s * i + u * a + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY;
    }
    fit(e) {
      return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this;
    }
    fitBounds(e, t, n, i) {
      return this.minX < e && (this.minX = e), this.maxX > t && (this.maxX = t), this.minY < n && (this.minY = n), this.maxY > i && (this.maxY = i), this;
    }
    pad(e, t = e) {
      return this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t, this;
    }
    ceil() {
      return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
    }
    clone() {
      return new ui(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(e, t = e) {
      return this.minX *= e, this.minY *= t, this.maxX *= e, this.maxY *= t, this;
    }
    get x() {
      return this.minX;
    }
    set x(e) {
      const t = this.maxX - this.minX;
      this.minX = e, this.maxX = e + t;
    }
    get y() {
      return this.minY;
    }
    set y(e) {
      const t = this.maxY - this.minY;
      this.minY = e, this.maxY = e + t;
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(e) {
      this.maxX = this.minX + e;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(e) {
      this.maxY = this.minY + e;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== 1 / 0;
    }
    addVertexData(e, t, n, i) {
      let a = this.minX, o = this.minY, s = this.maxX, l = this.maxY;
      i || (i = this.matrix);
      const u = i.a, c = i.b, h = i.c, f = i.d, d = i.tx, p = i.ty;
      for (let v = t; v < n; v += 2) {
        const g = e[v], m = e[v + 1], y = u * g + h * m + d, x = c * g + f * m + p;
        a = y < a ? y : a, o = x < o ? x : o, s = y > s ? y : s, l = x > l ? x : l;
      }
      this.minX = a, this.minY = o, this.maxX = s, this.maxY = l;
    }
    containsPoint(e, t) {
      return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    copyFrom(e) {
      return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this;
    }
  };
  var lxe = {
    grad: 0.9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  }, Zi = function(r) {
    return typeof r == "string" ? r.length > 0 : typeof r == "number";
  }, pr = function(r, e, t) {
    return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * r) / t + 0;
  }, Fn = function(r, e, t) {
    return e === void 0 && (e = 0), t === void 0 && (t = 1), r > t ? t : r > e ? r : e;
  }, Xz = function(r) {
    return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;
  }, BP = function(r) {
    return {
      r: Fn(r.r, 0, 255),
      g: Fn(r.g, 0, 255),
      b: Fn(r.b, 0, 255),
      a: Fn(r.a)
    };
  }, S0 = function(r) {
    return {
      r: pr(r.r),
      g: pr(r.g),
      b: pr(r.b),
      a: pr(r.a, 3)
    };
  }, uxe = /^#([0-9a-f]{3,8})$/i, Hd = function(r) {
    var e = r.toString(16);
    return e.length < 2 ? "0" + e : e;
  }, qz = function(r) {
    var e = r.r, t = r.g, n = r.b, i = r.a, a = Math.max(e, t, n), o = a - Math.min(e, t, n), s = o ? a === e ? (t - n) / o : a === t ? 2 + (n - e) / o : 4 + (e - t) / o : 0;
    return {
      h: 60 * (s < 0 ? s + 6 : s),
      s: a ? o / a * 100 : 0,
      v: a / 255 * 100,
      a: i
    };
  }, Kz = function(r) {
    var e = r.h, t = r.s, n = r.v, i = r.a;
    e = e / 360 * 6, t /= 100, n /= 100;
    var a = Math.floor(e), o = n * (1 - t), s = n * (1 - (e - a) * t), l = n * (1 - (1 - e + a) * t), u = a % 6;
    return {
      r: 255 * [
        n,
        s,
        o,
        o,
        l,
        n
      ][u],
      g: 255 * [
        l,
        n,
        n,
        s,
        o,
        o
      ][u],
      b: 255 * [
        o,
        o,
        l,
        n,
        n,
        s
      ][u],
      a: i
    };
  }, zP = function(r) {
    return {
      h: Xz(r.h),
      s: Fn(r.s, 0, 100),
      l: Fn(r.l, 0, 100),
      a: Fn(r.a)
    };
  }, VP = function(r) {
    return {
      h: pr(r.h),
      s: pr(r.s),
      l: pr(r.l),
      a: pr(r.a, 3)
    };
  }, $P = function(r) {
    return Kz((t = (e = r).s, {
      h: e.h,
      s: (t *= ((n = e.l) < 50 ? n : 100 - n) / 100) > 0 ? 2 * t / (n + t) * 100 : 0,
      v: n + t,
      a: e.a
    }));
    var e, t, n;
  }, ch = function(r) {
    return {
      h: (e = qz(r)).h,
      s: (i = (200 - (t = e.s)) * (n = e.v) / 100) > 0 && i < 200 ? t * n / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
      l: i / 2,
      a: e.a
    };
    var e, t, n, i;
  }, cxe = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, hxe = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, fxe = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, dxe = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, ib = {
    string: [
      [
        function(r) {
          var e = uxe.exec(r);
          return e ? (r = e[1]).length <= 4 ? {
            r: parseInt(r[0] + r[0], 16),
            g: parseInt(r[1] + r[1], 16),
            b: parseInt(r[2] + r[2], 16),
            a: r.length === 4 ? pr(parseInt(r[3] + r[3], 16) / 255, 2) : 1
          } : r.length === 6 || r.length === 8 ? {
            r: parseInt(r.substr(0, 2), 16),
            g: parseInt(r.substr(2, 2), 16),
            b: parseInt(r.substr(4, 2), 16),
            a: r.length === 8 ? pr(parseInt(r.substr(6, 2), 16) / 255, 2) : 1
          } : null : null;
        },
        "hex"
      ],
      [
        function(r) {
          var e = fxe.exec(r) || dxe.exec(r);
          return e ? e[2] !== e[4] || e[4] !== e[6] ? null : BP({
            r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
            g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
            b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
            a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
          }) : null;
        },
        "rgb"
      ],
      [
        function(r) {
          var e = cxe.exec(r) || hxe.exec(r);
          if (!e) return null;
          var t, n, i = zP({
            h: (t = e[1], n = e[2], n === void 0 && (n = "deg"), Number(t) * (lxe[n] || 1)),
            s: Number(e[3]),
            l: Number(e[4]),
            a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
          });
          return $P(i);
        },
        "hsl"
      ]
    ],
    object: [
      [
        function(r) {
          var e = r.r, t = r.g, n = r.b, i = r.a, a = i === void 0 ? 1 : i;
          return Zi(e) && Zi(t) && Zi(n) ? BP({
            r: Number(e),
            g: Number(t),
            b: Number(n),
            a: Number(a)
          }) : null;
        },
        "rgb"
      ],
      [
        function(r) {
          var e = r.h, t = r.s, n = r.l, i = r.a, a = i === void 0 ? 1 : i;
          if (!Zi(e) || !Zi(t) || !Zi(n)) return null;
          var o = zP({
            h: Number(e),
            s: Number(t),
            l: Number(n),
            a: Number(a)
          });
          return $P(o);
        },
        "hsl"
      ],
      [
        function(r) {
          var e = r.h, t = r.s, n = r.v, i = r.a, a = i === void 0 ? 1 : i;
          if (!Zi(e) || !Zi(t) || !Zi(n)) return null;
          var o = function(s) {
            return {
              h: Xz(s.h),
              s: Fn(s.s, 0, 100),
              v: Fn(s.v, 0, 100),
              a: Fn(s.a)
            };
          }({
            h: Number(e),
            s: Number(t),
            v: Number(n),
            a: Number(a)
          });
          return Kz(o);
        },
        "hsv"
      ]
    ]
  }, GP = function(r, e) {
    for (var t = 0; t < e.length; t++) {
      var n = e[t][0](r);
      if (n) return [
        n,
        e[t][1]
      ];
    }
    return [
      null,
      void 0
    ];
  }, pxe = function(r) {
    return typeof r == "string" ? GP(r.trim(), ib.string) : typeof r == "object" && r !== null ? GP(r, ib.object) : [
      null,
      void 0
    ];
  }, w0 = function(r, e) {
    var t = ch(r);
    return {
      h: t.h,
      s: Fn(t.s + 100 * e, 0, 100),
      l: t.l,
      a: t.a
    };
  }, C0 = function(r) {
    return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;
  }, WP = function(r, e) {
    var t = ch(r);
    return {
      h: t.h,
      s: t.s,
      l: Fn(t.l + 100 * e, 0, 100),
      a: t.a
    };
  }, ab = function() {
    function r(e) {
      this.parsed = pxe(e)[0], this.rgba = this.parsed || {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      };
    }
    return r.prototype.isValid = function() {
      return this.parsed !== null;
    }, r.prototype.brightness = function() {
      return pr(C0(this.rgba), 2);
    }, r.prototype.isDark = function() {
      return C0(this.rgba) < 0.5;
    }, r.prototype.isLight = function() {
      return C0(this.rgba) >= 0.5;
    }, r.prototype.toHex = function() {
      return e = S0(this.rgba), t = e.r, n = e.g, i = e.b, o = (a = e.a) < 1 ? Hd(pr(255 * a)) : "", "#" + Hd(t) + Hd(n) + Hd(i) + o;
      var e, t, n, i, a, o;
    }, r.prototype.toRgb = function() {
      return S0(this.rgba);
    }, r.prototype.toRgbString = function() {
      return e = S0(this.rgba), t = e.r, n = e.g, i = e.b, (a = e.a) < 1 ? "rgba(" + t + ", " + n + ", " + i + ", " + a + ")" : "rgb(" + t + ", " + n + ", " + i + ")";
      var e, t, n, i, a;
    }, r.prototype.toHsl = function() {
      return VP(ch(this.rgba));
    }, r.prototype.toHslString = function() {
      return e = VP(ch(this.rgba)), t = e.h, n = e.s, i = e.l, (a = e.a) < 1 ? "hsla(" + t + ", " + n + "%, " + i + "%, " + a + ")" : "hsl(" + t + ", " + n + "%, " + i + "%)";
      var e, t, n, i, a;
    }, r.prototype.toHsv = function() {
      return e = qz(this.rgba), {
        h: pr(e.h),
        s: pr(e.s),
        v: pr(e.v),
        a: pr(e.a, 3)
      };
      var e;
    }, r.prototype.invert = function() {
      return Si({
        r: 255 - (e = this.rgba).r,
        g: 255 - e.g,
        b: 255 - e.b,
        a: e.a
      });
      var e;
    }, r.prototype.saturate = function(e) {
      return e === void 0 && (e = 0.1), Si(w0(this.rgba, e));
    }, r.prototype.desaturate = function(e) {
      return e === void 0 && (e = 0.1), Si(w0(this.rgba, -e));
    }, r.prototype.grayscale = function() {
      return Si(w0(this.rgba, -1));
    }, r.prototype.lighten = function(e) {
      return e === void 0 && (e = 0.1), Si(WP(this.rgba, e));
    }, r.prototype.darken = function(e) {
      return e === void 0 && (e = 0.1), Si(WP(this.rgba, -e));
    }, r.prototype.rotate = function(e) {
      return e === void 0 && (e = 15), this.hue(this.hue() + e);
    }, r.prototype.alpha = function(e) {
      return typeof e == "number" ? Si({
        r: (t = this.rgba).r,
        g: t.g,
        b: t.b,
        a: e
      }) : pr(this.rgba.a, 3);
      var t;
    }, r.prototype.hue = function(e) {
      var t = ch(this.rgba);
      return typeof e == "number" ? Si({
        h: e,
        s: t.s,
        l: t.l,
        a: t.a
      }) : pr(t.h);
    }, r.prototype.isEqual = function(e) {
      return this.toHex() === Si(e).toHex();
    }, r;
  }(), Si = function(r) {
    return r instanceof ab ? r : new ab(r);
  }, UP = [], vxe = function(r) {
    r.forEach(function(e) {
      UP.indexOf(e) < 0 && (e(ab, ib), UP.push(e));
    });
  };
  function gxe(r, e) {
    var t = {
      white: "#ffffff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000"
    }, n = {};
    for (var i in t) n[t[i]] = i;
    var a = {};
    r.prototype.toName = function(o) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var s, l, u = n[this.toHex()];
      if (u) return u;
      if (o == null ? void 0 : o.closest) {
        var c = this.toRgb(), h = 1 / 0, f = "black";
        if (!a.length) for (var d in t) a[d] = new r(t[d]).toRgb();
        for (var p in t) {
          var v = (s = c, l = a[p], Math.pow(s.r - l.r, 2) + Math.pow(s.g - l.g, 2) + Math.pow(s.b - l.b, 2));
          v < h && (h = v, f = p);
        }
        return f;
      }
    }, e.string.push([
      function(o) {
        var s = o.toLowerCase(), l = s === "transparent" ? "#0000" : t[s];
        return l ? new r(l).toRgb() : null;
      },
      "name"
    ]);
  }
  vxe([
    gxe
  ]);
  const _u = class Uc {
    constructor(e = 16777215) {
      this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e;
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(e) {
      return this.value = e, this;
    }
    set value(e) {
      if (e instanceof Uc) this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components);
      else {
        if (e === null) throw new Error("Cannot set Color#value to null");
        (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value));
      }
    }
    get value() {
      return this._value;
    }
    _cloneSource(e) {
      return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? {
        ...e
      } : e;
    }
    _isSourceEqual(e, t) {
      const n = typeof e;
      if (n !== typeof t) return false;
      if (n === "number" || n === "string" || e instanceof Number) return e === t;
      if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) return e.length !== t.length ? false : e.every((a, o) => a === t[o]);
      if (e !== null && t !== null) {
        const a = Object.keys(e), o = Object.keys(t);
        return a.length !== o.length ? false : a.every((s) => e[s] === t[s]);
      }
      return e === t;
    }
    toRgba() {
      const [e, t, n, i] = this._components;
      return {
        r: e,
        g: t,
        b: n,
        a: i
      };
    }
    toRgb() {
      const [e, t, n] = this._components;
      return {
        r: e,
        g: t,
        b: n
      };
    }
    toRgbaString() {
      const [e, t, n] = this.toUint8RgbArray();
      return `rgba(${e},${t},${n},${this.alpha})`;
    }
    toUint8RgbArray(e) {
      const [t, n, i] = this._components;
      return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(t * 255), e[1] = Math.round(n * 255), e[2] = Math.round(i * 255), e;
    }
    toArray(e) {
      this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
      const [t, n, i, a] = this._components;
      return e[0] = t, e[1] = n, e[2] = i, e[3] = a, e;
    }
    toRgbArray(e) {
      this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
      const [t, n, i] = this._components;
      return e[0] = t, e[1] = n, e[2] = i, e;
    }
    toNumber() {
      return this._int;
    }
    toBgrNumber() {
      const [e, t, n] = this.toUint8RgbArray();
      return (n << 16) + (t << 8) + e;
    }
    toLittleEndianNumber() {
      const e = this._int;
      return (e >> 16) + (e & 65280) + ((e & 255) << 16);
    }
    multiply(e) {
      const [t, n, i, a] = Uc._temp.setValue(e)._components;
      return this._components[0] *= t, this._components[1] *= n, this._components[2] *= i, this._components[3] *= a, this._refreshInt(), this._value = null, this;
    }
    premultiply(e, t = true) {
      return t && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this;
    }
    toPremultiplied(e, t = true) {
      if (e === 1) return (255 << 24) + this._int;
      if (e === 0) return t ? 0 : this._int;
      let n = this._int >> 16 & 255, i = this._int >> 8 & 255, a = this._int & 255;
      return t && (n = n * e + 0.5 | 0, i = i * e + 0.5 | 0, a = a * e + 0.5 | 0), (e * 255 << 24) + (n << 16) + (i << 8) + a;
    }
    toHex() {
      const e = this._int.toString(16);
      return `#${"000000".substring(0, 6 - e.length) + e}`;
    }
    toHexa() {
      const t = Math.round(this._components[3] * 255).toString(16);
      return this.toHex() + "00".substring(0, 2 - t.length) + t;
    }
    setAlpha(e) {
      return this._components[3] = this._clamp(e), this;
    }
    _normalize(e) {
      let t, n, i, a;
      if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
        const o = e;
        t = (o >> 16 & 255) / 255, n = (o >> 8 & 255) / 255, i = (o & 255) / 255, a = 1;
      } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [t, n, i, a = 1] = e;
      else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [t, n, i, a = 255] = e, t /= 255, n /= 255, i /= 255, a /= 255;
      else if (typeof e == "string" || typeof e == "object") {
        if (typeof e == "string") {
          const s = Uc.HEX_PATTERN.exec(e);
          s && (e = `#${s[2]}`);
        }
        const o = Si(e);
        o.isValid() && ({ r: t, g: n, b: i, a } = o.rgba, t /= 255, n /= 255, i /= 255);
      }
      if (t !== void 0) this._components[0] = t, this._components[1] = n, this._components[2] = i, this._components[3] = a, this._refreshInt();
      else throw new Error(`Unable to convert color ${e}`);
    }
    _refreshInt() {
      this._clamp(this._components);
      const [e, t, n] = this._components;
      this._int = (e * 255 << 16) + (t * 255 << 8) + (n * 255 | 0);
    }
    _clamp(e, t = 0, n = 1) {
      return typeof e == "number" ? Math.min(Math.max(e, t), n) : (e.forEach((i, a) => {
        e[a] = Math.min(Math.max(i, t), n);
      }), e);
    }
    static isColorLike(e) {
      return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof Uc || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0;
    }
  };
  _u.shared = new _u();
  _u._temp = new _u();
  _u.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  kr = _u;
  const mxe = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
  };
  class uw {
    constructor(e, t) {
      this._pool = [], this._count = 0, this._index = 0, this._classType = e, t && this.prepopulate(t);
    }
    prepopulate(e) {
      for (let t = 0; t < e; t++) this._pool[this._index++] = new this._classType();
      this._count += e;
    }
    get(e) {
      var _a2;
      let t;
      return this._index > 0 ? t = this._pool[--this._index] : t = new this._classType(), (_a2 = t.init) == null ? void 0 : _a2.call(t, e), t;
    }
    return(e) {
      var _a2;
      (_a2 = e.reset) == null ? void 0 : _a2.call(e), this._pool[this._index++] = e;
    }
    get totalSize() {
      return this._count;
    }
    get totalFree() {
      return this._index;
    }
    get totalUsed() {
      return this._count - this._index;
    }
    clear() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class yxe {
    constructor() {
      this._poolsByClass = /* @__PURE__ */ new Map();
    }
    prepopulate(e, t) {
      this.getPool(e).prepopulate(t);
    }
    get(e, t) {
      return this.getPool(e).get(t);
    }
    return(e) {
      this.getPool(e.constructor).return(e);
    }
    getPool(e) {
      return this._poolsByClass.has(e) || this._poolsByClass.set(e, new uw(e)), this._poolsByClass.get(e);
    }
    stats() {
      const e = {};
      return this._poolsByClass.forEach((t) => {
        const n = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name;
        e[n] = {
          free: t.totalFree,
          used: t.totalUsed,
          size: t.totalSize
        };
      }), e;
    }
  }
  let xxe;
  fa = new yxe();
  xxe = {
    get isCachedAsTexture() {
      var _a2;
      return !!((_a2 = this.renderGroup) == null ? void 0 : _a2.isCachedAsTexture);
    },
    cacheAsTexture(r) {
      typeof r == "boolean" && r === false ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(r === true ? {} : r));
    },
    updateCacheTexture() {
      var _a2;
      (_a2 = this.renderGroup) == null ? void 0 : _a2.updateCacheTexture();
    },
    get cacheAsBitmap() {
      return this.isCachedAsTexture;
    },
    set cacheAsBitmap(r) {
      Pt("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(r);
    }
  };
  _xe = function(r, e, t) {
    const n = r.length;
    let i;
    if (e >= n || t === 0) return;
    t = e + t > n ? n - e : t;
    const a = n - t;
    for (i = e; i < a; ++i) r[i] = r[i + t];
    r.length = a;
  };
  const bxe = {
    allowChildren: true,
    removeChildren(r = 0, e) {
      const t = e ?? this.children.length, n = t - r, i = [];
      if (n > 0 && n <= t) {
        for (let o = t - 1; o >= r; o--) {
          const s = this.children[o];
          s && (i.push(s), s.parent = null);
        }
        _xe(this.children, r, t);
        const a = this.renderGroup || this.parentRenderGroup;
        a && a.removeChildren(i);
        for (let o = 0; o < i.length; ++o) this.emit("childRemoved", i[o], this, o), i[o].emit("removed", this);
        return i.length > 0 && this._didViewChangeTick++, i;
      } else if (n === 0 && this.children.length === 0) return i;
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt(r) {
      const e = this.getChildAt(r);
      return this.removeChild(e);
    },
    getChildAt(r) {
      if (r < 0 || r >= this.children.length) throw new Error(`getChildAt: Index (${r}) does not exist.`);
      return this.children[r];
    },
    setChildIndex(r, e) {
      if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
      this.getChildIndex(r), this.addChildAt(r, e);
    },
    getChildIndex(r) {
      const e = this.children.indexOf(r);
      if (e === -1) throw new Error("The supplied Container must be a child of the caller");
      return e;
    },
    addChildAt(r, e) {
      this.allowChildren || Pt($t, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      const { children: t } = this;
      if (e < 0 || e > t.length) throw new Error(`${r}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);
      if (r.parent) {
        const i = r.parent.children.indexOf(r);
        if (r.parent === this && i === e) return r;
        i !== -1 && r.parent.children.splice(i, 1);
      }
      e === t.length ? t.push(r) : t.splice(e, 0, r), r.parent = this, r.didChange = true, r._updateFlags = 15;
      const n = this.renderGroup || this.parentRenderGroup;
      return n && n.addChild(r), this.sortableChildren && (this.sortDirty = true), this.emit("childAdded", r, this, e), r.emit("added", this), r;
    },
    swapChildren(r, e) {
      if (r === e) return;
      const t = this.getChildIndex(r), n = this.getChildIndex(e);
      this.children[t] = e, this.children[n] = r;
      const i = this.renderGroup || this.parentRenderGroup;
      i && (i.structureDidChange = true), this._didContainerChangeTick++;
    },
    removeFromParent() {
      var _a2;
      (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
    },
    reparentChild(...r) {
      return r.length === 1 ? this.reparentChildAt(r[0], this.children.length) : (r.forEach((e) => this.reparentChildAt(e, this.children.length)), r[0]);
    },
    reparentChildAt(r, e) {
      if (r.parent === this) return this.setChildIndex(r, e), r;
      const t = r.worldTransform.clone();
      r.removeFromParent(), this.addChildAt(r, e);
      const n = this.worldTransform.clone();
      return n.invert(), t.prepend(n), r.setFromMatrix(t), r;
    }
  }, Sxe = {
    collectRenderables(r, e, t) {
      this.parentRenderLayer && this.parentRenderLayer !== t || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(r, e, t) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, r) : this.collectRenderablesWithEffects(r, e, t));
    },
    collectRenderablesSimple(r, e, t) {
      const n = this.children, i = n.length;
      for (let a = 0; a < i; a++) n[a].collectRenderables(r, e, t);
    },
    collectRenderablesWithEffects(r, e, t) {
      const { renderPipes: n } = e;
      for (let i = 0; i < this.effects.length; i++) {
        const a = this.effects[i];
        n[a.pipe].push(a, this, r);
      }
      this.collectRenderablesSimple(r, e, t);
      for (let i = this.effects.length - 1; i >= 0; i--) {
        const a = this.effects[i];
        n[a.pipe].pop(a, this, r);
      }
    }
  };
  HP = class {
    constructor() {
      this.pipe = "filter", this.priority = 1;
    }
    destroy() {
      for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy();
      this.filters = null, this.filterArea = null;
    }
  };
  class wxe {
    constructor() {
      this._effectClasses = [], this._tests = [], this._initialized = false;
    }
    init() {
      this._initialized || (this._initialized = true, this._effectClasses.forEach((e) => {
        this.add({
          test: e.test,
          maskClass: e
        });
      }));
    }
    add(e) {
      this._tests.push(e);
    }
    getMaskEffect(e) {
      this._initialized || this.init();
      for (let t = 0; t < this._tests.length; t++) {
        const n = this._tests[t];
        if (n.test(e)) return fa.get(n.maskClass, e);
      }
      return e;
    }
    returnMaskEffect(e) {
      fa.return(e);
    }
  }
  const ob = new wxe();
  Wn.handleByList(Ct.MaskEffect, ob._effectClasses);
  const Cxe = {
    _maskEffect: null,
    _maskOptions: {
      inverse: false
    },
    _filterEffect: null,
    effects: [],
    _markStructureAsChanged() {
      const r = this.renderGroup || this.parentRenderGroup;
      r && (r.structureDidChange = true);
    },
    addEffect(r) {
      this.effects.indexOf(r) === -1 && (this.effects.push(r), this.effects.sort((t, n) => t.priority - n.priority), this._markStructureAsChanged(), this._updateIsSimple());
    },
    removeEffect(r) {
      const e = this.effects.indexOf(r);
      e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple());
    },
    set mask(r) {
      const e = this._maskEffect;
      (e == null ? void 0 : e.mask) !== r && (e && (this.removeEffect(e), ob.returnMaskEffect(e), this._maskEffect = null), r != null && (this._maskEffect = ob.getMaskEffect(r), this.addEffect(this._maskEffect)));
    },
    setMask(r) {
      this._maskOptions = {
        ...this._maskOptions,
        ...r
      }, r.mask && (this.mask = r.mask), this._markStructureAsChanged();
    },
    get mask() {
      var _a2;
      return (_a2 = this._maskEffect) == null ? void 0 : _a2.mask;
    },
    set filters(r) {
      var _a2;
      !Array.isArray(r) && r && (r = [
        r
      ]);
      const e = this._filterEffect || (this._filterEffect = new HP());
      r = r;
      const t = (r == null ? void 0 : r.length) > 0, n = ((_a2 = e.filters) == null ? void 0 : _a2.length) > 0, i = t !== n;
      r = Array.isArray(r) ? r.slice(0) : r, e.filters = Object.freeze(r), i && (t ? this.addEffect(e) : (this.removeEffect(e), e.filters = r ?? null));
    },
    get filters() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filters;
    },
    set filterArea(r) {
      this._filterEffect || (this._filterEffect = new HP()), this._filterEffect.filterArea = r;
    },
    get filterArea() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filterArea;
    }
  }, Txe = {
    label: null,
    get name() {
      return Pt($t, "Container.name property has been removed, use Container.label instead"), this.label;
    },
    set name(r) {
      Pt($t, "Container.name property has been removed, use Container.label instead"), this.label = r;
    },
    getChildByName(r, e = false) {
      return this.getChildByLabel(r, e);
    },
    getChildByLabel(r, e = false) {
      const t = this.children;
      for (let n = 0; n < t.length; n++) {
        const i = t[n];
        if (i.label === r || r instanceof RegExp && r.test(i.label)) return i;
      }
      if (e) for (let n = 0; n < t.length; n++) {
        const a = t[n].getChildByLabel(r, true);
        if (a) return a;
      }
      return null;
    },
    getChildrenByLabel(r, e = false, t = []) {
      const n = this.children;
      for (let i = 0; i < n.length; i++) {
        const a = n[i];
        (a.label === r || r instanceof RegExp && r.test(a.label)) && t.push(a);
      }
      if (e) for (let i = 0; i < n.length; i++) n[i].getChildrenByLabel(r, true, t);
      return t;
    }
  }, Gr = new uw(pt), da = new uw(ui), Axe = new pt(), Ixe = {
    getFastGlobalBounds(r, e) {
      e || (e = new ui()), e.clear(), this._getGlobalBoundsRecursive(!!r, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0);
      const t = this.renderGroup || this.parentRenderGroup;
      return e.applyMatrix(t.worldTransform), e;
    },
    _getGlobalBoundsRecursive(r, e, t) {
      let n = e;
      if (r && this.parentRenderLayer && this.parentRenderLayer !== t || this.localDisplayStatus !== 7 || !this.measurable) return;
      const i = !!this.effects.length;
      if ((this.renderGroup || i) && (n = da.get().clear()), this.boundsArea) e.addRect(this.boundsArea, this.worldTransform);
      else {
        if (this.renderPipeId) {
          const o = this.bounds;
          n.addFrame(o.minX, o.minY, o.maxX, o.maxY, this.groupTransform);
        }
        const a = this.children;
        for (let o = 0; o < a.length; o++) a[o]._getGlobalBoundsRecursive(r, n, t);
      }
      if (i) {
        let a = false;
        const o = this.renderGroup || this.parentRenderGroup;
        for (let s = 0; s < this.effects.length; s++) this.effects[s].addBounds && (a || (a = true, n.applyMatrix(o.worldTransform)), this.effects[s].addBounds(n, true));
        a && (n.applyMatrix(o.worldTransform.copyTo(Axe).invert()), e.addBounds(n, this.relativeGroupTransform)), e.addBounds(n), da.return(n);
      } else this.renderGroup && (e.addBounds(n, this.relativeGroupTransform), da.return(n));
    }
  };
  Zz = function(r, e, t) {
    t.clear();
    let n, i;
    return r.parent ? e ? n = r.parent.worldTransform : (i = Gr.get().identity(), n = cw(r, i)) : n = pt.IDENTITY, jz(r, t, n, e), i && Gr.return(i), t.isValid || t.set(0, 0, 0, 0), t;
  };
  function jz(r, e, t, n) {
    var _a2, _b2;
    if (!r.visible || !r.measurable) return;
    let i;
    n ? i = r.worldTransform : (r.updateLocalTransform(), i = Gr.get(), i.appendFrom(r.localTransform, t));
    const a = e, o = !!r.effects.length;
    if (o && (e = da.get().clear()), r.boundsArea) e.addRect(r.boundsArea, i);
    else {
      r.bounds && (e.matrix = i, e.addBounds(r.bounds));
      for (let s = 0; s < r.children.length; s++) jz(r.children[s], e, i, n);
    }
    if (o) {
      for (let s = 0; s < r.effects.length; s++) (_b2 = (_a2 = r.effects[s]).addBounds) == null ? void 0 : _b2.call(_a2, e);
      a.addBounds(e, pt.IDENTITY), da.return(e);
    }
    n || Gr.return(i);
  }
  function cw(r, e) {
    const t = r.parent;
    return t && (cw(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e;
  }
  function Qz(r, e) {
    if (r === 16777215 || !e) return e;
    if (e === 16777215 || !r) return r;
    const t = r >> 16 & 255, n = r >> 8 & 255, i = r & 255, a = e >> 16 & 255, o = e >> 8 & 255, s = e & 255, l = t * a / 255 | 0, u = n * o / 255 | 0, c = i * s / 255 | 0;
    return (l << 16) + (u << 8) + c;
  }
  const YP = 16777215;
  XP = function(r, e) {
    return r === YP ? e : e === YP ? r : Qz(r, e);
  };
  function kp(r) {
    return ((r & 255) << 16) + (r & 65280) + (r >> 16 & 255);
  }
  const Mxe = {
    getGlobalAlpha(r) {
      if (r) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
      let e = this.alpha, t = this.parent;
      for (; t; ) e *= t.alpha, t = t.parent;
      return e;
    },
    getGlobalTransform(r, e) {
      if (e) return r.copyFrom(this.worldTransform);
      this.updateLocalTransform();
      const t = cw(this, Gr.get().identity());
      return r.appendFrom(this.localTransform, t), Gr.return(t), r;
    },
    getGlobalTint(r) {
      if (r) return this.renderGroup ? kp(this.renderGroup.worldColor) : this.parentRenderGroup ? kp(XP(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
      let e = this.localColor, t = this.parent;
      for (; t; ) e = XP(e, t.localColor), t = t.parent;
      return kp(e);
    }
  };
  let T0 = 0;
  const qP = 500;
  mn = function(...r) {
    T0 !== qP && (T0++, T0 === qP ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...r));
  };
  Jz = function(r, e, t) {
    return e.clear(), t || (t = pt.IDENTITY), eV(r, e, t, r, true), e.isValid || e.set(0, 0, 0, 0), e;
  };
  function eV(r, e, t, n, i) {
    var _a2, _b2;
    let a;
    if (i) a = Gr.get(), a = t.copyTo(a);
    else {
      if (!r.visible || !r.measurable) return;
      r.updateLocalTransform();
      const l = r.localTransform;
      a = Gr.get(), a.appendFrom(l, t);
    }
    const o = e, s = !!r.effects.length;
    if (s && (e = da.get().clear()), r.boundsArea) e.addRect(r.boundsArea, a);
    else {
      r.renderPipeId && (e.matrix = a, e.addBounds(r.bounds));
      const l = r.children;
      for (let u = 0; u < l.length; u++) eV(l[u], e, a, n, false);
    }
    if (s) {
      for (let l = 0; l < r.effects.length; l++) (_b2 = (_a2 = r.effects[l]).addLocalBounds) == null ? void 0 : _b2.call(_a2, e, n);
      o.addBounds(e, pt.IDENTITY), da.return(e);
    }
    Gr.return(a);
  }
  function tV(r, e) {
    const t = r.children;
    for (let n = 0; n < t.length; n++) {
      const i = t[n], a = i.uid, o = (i._didViewChangeTick & 65535) << 16 | i._didContainerChangeTick & 65535, s = e.index;
      (e.data[s] !== a || e.data[s + 1] !== o) && (e.data[e.index] = a, e.data[e.index + 1] = o, e.didChange = true), e.index = s + 2, i.children.length && tV(i, e);
    }
    return e.didChange;
  }
  const Dxe = new pt(), Pxe = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(r, e) {
      const t = Math.sign(this.scale.x) || 1;
      e !== 0 ? this.scale.x = r / e * t : this.scale.x = t;
    },
    _setHeight(r, e) {
      const t = Math.sign(this.scale.y) || 1;
      e !== 0 ? this.scale.y = r / e * t : this.scale.y = t;
    },
    getLocalBounds() {
      this._localBoundsCacheData || (this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new ui()
      });
      const r = this._localBoundsCacheData;
      return r.index = 1, r.didChange = false, r.data[0] !== this._didViewChangeTick && (r.didChange = true, r.data[0] = this._didViewChangeTick), tV(this, r), r.didChange && Jz(this, r.localBounds, Dxe), r.localBounds;
    },
    getBounds(r, e) {
      return Zz(this, r, e || new ui());
    }
  }, kxe = {
    _onRender: null,
    set onRender(r) {
      const e = this.renderGroup || this.parentRenderGroup;
      if (!r) {
        this._onRender && (e == null ? void 0 : e.removeOnRender(this)), this._onRender = null;
        return;
      }
      this._onRender || (e == null ? void 0 : e.addOnRender(this)), this._onRender = r;
    },
    get onRender() {
      return this._onRender;
    }
  }, Lxe = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex() {
      return this._zIndex;
    },
    set zIndex(r) {
      this._zIndex !== r && (this._zIndex = r, this.depthOfChildModified());
    },
    depthOfChildModified() {
      this.parent && (this.parent.sortableChildren = true, this.parent.sortDirty = true), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true);
    },
    sortChildren() {
      this.sortDirty && (this.sortDirty = false, this.children.sort(Rxe));
    }
  };
  function Rxe(r, e) {
    return r._zIndex - e._zIndex;
  }
  const Exe = {
    getGlobalPosition(r = new Dr(), e = false) {
      return this.parent ? this.parent.toGlobal(this._position, r, e) : (r.x = this._position.x, r.y = this._position.y), r;
    },
    toGlobal(r, e, t = false) {
      const n = this.getGlobalTransform(Gr.get(), t);
      return e = n.apply(r, e), Gr.return(n), e;
    },
    toLocal(r, e, t, n) {
      e && (r = e.toGlobal(r, t, n));
      const i = this.getGlobalTransform(Gr.get(), n);
      return t = i.applyInverse(r, t), Gr.return(i), t;
    }
  };
  class rV {
    constructor() {
      this.uid = Qt("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
    }
    reset() {
      this.instructionSize = 0;
    }
    add(e) {
      this.instructions[this.instructionSize++] = e;
    }
    log() {
      this.instructions.length = this.instructionSize, console.table(this.instructions, [
        "type",
        "action"
      ]);
    }
  }
  let Nxe = 0;
  class Oxe {
    constructor(e) {
      this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = false;
    }
    createTexture(e, t, n) {
      const i = new fi({
        ...this.textureOptions,
        width: e,
        height: t,
        resolution: 1,
        antialias: n,
        autoGarbageCollect: false
      });
      return new At({
        source: i,
        label: `texturePool_${Nxe++}`
      });
    }
    getOptimalTexture(e, t, n = 1, i) {
      let a = Math.ceil(e * n - 1e-6), o = Math.ceil(t * n - 1e-6);
      a = RP(a), o = RP(o);
      const s = (a << 17) + (o << 1) + (i ? 1 : 0);
      this._texturePool[s] || (this._texturePool[s] = []);
      let l = this._texturePool[s].pop();
      return l || (l = this.createTexture(a, o, i)), l.source._resolution = n, l.source.width = a / n, l.source.height = o / n, l.source.pixelWidth = a, l.source.pixelHeight = o, l.frame.x = 0, l.frame.y = 0, l.frame.width = e, l.frame.height = t, l.updateUvs(), this._poolKeyHash[l.uid] = s, l;
    }
    getSameSizeTexture(e, t = false) {
      const n = e.source;
      return this.getOptimalTexture(e.width, e.height, n._resolution, t);
    }
    returnTexture(e) {
      const t = this._poolKeyHash[e.uid];
      this._texturePool[t].push(e);
    }
    clear(e) {
      if (e = e !== false, e) for (const t in this._texturePool) {
        const n = this._texturePool[t];
        if (n) for (let i = 0; i < n.length; i++) n[i].destroy(true);
      }
      this._texturePool = {};
    }
  }
  Fxe = new Oxe();
  class Bxe {
    constructor() {
      this.renderPipeId = "renderGroup", this.root = null, this.canBundle = false, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new pt(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
        list: [],
        index: 0
      }, this.structureDidChange = true, this.instructionSet = new rV(), this._onRenderContainers = [], this.textureNeedsUpdate = true, this.isCachedAsTexture = false, this._matrixDirty = 7;
    }
    init(e) {
      this.root = e, e._onRender && this.addOnRender(e), e.didChange = true;
      const t = e.children;
      for (let n = 0; n < t.length; n++) {
        const i = t[n];
        i._updateFlags = 15, this.addChild(i);
      }
    }
    enableCacheAsTexture(e = {}) {
      this.textureOptions = e, this.isCachedAsTexture = true, this.textureNeedsUpdate = true;
    }
    disableCacheAsTexture() {
      this.isCachedAsTexture = false, this.texture && (Fxe.returnTexture(this.texture), this.texture = null);
    }
    updateCacheTexture() {
      this.textureNeedsUpdate = true;
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const e in this.childrenToUpdate) {
        const t = this.childrenToUpdate[e];
        t.list.fill(null), t.index = 0;
      }
      this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = true, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(e) {
      e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e);
    }
    _removeRenderGroupChild(e) {
      const t = this.renderGroupChildren.indexOf(e);
      t > -1 && this.renderGroupChildren.splice(t, 1), e.renderGroupParent = null;
    }
    addChild(e) {
      if (this.structureDidChange = true, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = true, this.onChildUpdate(e), e.renderGroup) {
        this.addRenderGroupChild(e.renderGroup);
        return;
      }
      e._onRender && this.addOnRender(e);
      const t = e.children;
      for (let n = 0; n < t.length; n++) this.addChild(t[n]);
    }
    removeChild(e) {
      if (this.structureDidChange = true, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) {
        this._removeRenderGroupChild(e.renderGroup);
        return;
      }
      const t = e.children;
      for (let n = 0; n < t.length; n++) this.removeChild(t[n]);
    }
    removeChildren(e) {
      for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
    }
    onChildUpdate(e) {
      let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
      t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      }), t.list[t.index++] = e;
    }
    updateRenderable(e) {
      e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = false);
    }
    onChildViewUpdate(e) {
      this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e;
    }
    get isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(e) {
      this._onRenderContainers.push(e);
    }
    removeOnRender(e) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
    }
    runOnRender(e) {
      for (let t = 0; t < this._onRenderContainers.length; t++) this._onRenderContainers[t]._onRender(e);
    }
    destroy() {
      this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
    }
    getChildren(e = []) {
      const t = this.root.children;
      for (let n = 0; n < t.length; n++) this._getChildren(t[n], e);
      return e;
    }
    _getChildren(e, t = []) {
      if (t.push(e), e.renderGroup) return t;
      const n = e.children;
      for (let i = 0; i < n.length; i++) this._getChildren(n[i], t);
      return t;
    }
    invalidateMatrices() {
      this._matrixDirty = 7;
    }
    get inverseWorldTransform() {
      return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new pt()), this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
    }
    get textureOffsetInverseTransform() {
      return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new pt()), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y));
    }
    get inverseParentTextureTransform() {
      if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
      this._matrixDirty &= -5;
      const e = this._parentCacheAsTextureRenderGroup;
      return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new pt()), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform;
    }
    get cacheToLocalTransform() {
      return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
    }
  }
  function zxe(r, e, t = {}) {
    for (const n in e) !t[n] && e[n] !== void 0 && (r[n] = e[n]);
  }
  let A0, I0, M0;
  A0 = new Jr(null);
  I0 = new Jr(null);
  M0 = new Jr(null, 1, 1);
  KP = 1;
  Vxe = 2;
  D0 = 4;
  al = class extends Yi {
    constructor(e = {}) {
      var _a2, _b2;
      super(), this.uid = Qt("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = false, this.didViewUpdate = false, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = true, this.measurable = true, this.isSimple = true, this.updateTick = -1, this.localTransform = new pt(), this.relativeGroupTransform = new pt(), this.groupTransform = this.relativeGroupTransform, this.destroyed = false, this._position = new Jr(this, 0, 0), this._scale = M0, this._pivot = I0, this._skew = A0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], zxe(this, e, {
        children: true,
        parent: true,
        effects: true
      }), (_a2 = e.children) == null ? void 0 : _a2.forEach((t) => this.addChild(t)), (_b2 = e.parent) == null ? void 0 : _b2.addChild(this);
    }
    static mixin(e) {
      Pt("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), Wn.mixin(al, e);
    }
    set _didChangeId(e) {
      this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095;
    }
    get _didChangeId() {
      return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
    }
    addChild(...e) {
      if (this.allowChildren || Pt($t, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) {
        for (let i = 0; i < e.length; i++) this.addChild(e[i]);
        return e[0];
      }
      const t = e[0], n = this.renderGroup || this.parentRenderGroup;
      return t.parent === this ? (this.children.splice(this.children.indexOf(t), 1), this.children.push(t), n && (n.structureDidChange = true), t) : (t.parent && t.parent.removeChild(t), this.children.push(t), this.sortableChildren && (this.sortDirty = true), t.parent = this, t.didChange = true, t._updateFlags = 15, n && n.addChild(t), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this), this._didViewChangeTick++, t._zIndex !== 0 && t.depthOfChildModified(), t);
    }
    removeChild(...e) {
      if (e.length > 1) {
        for (let i = 0; i < e.length; i++) this.removeChild(e[i]);
        return e[0];
      }
      const t = e[0], n = this.children.indexOf(t);
      return n > -1 && (this._didViewChangeTick++, this.children.splice(n, 1), this.renderGroup ? this.renderGroup.removeChild(t) : this.parentRenderGroup && this.parentRenderGroup.removeChild(t), t.parentRenderLayer && t.parentRenderLayer.detach(t), t.parent = null, this.emit("childRemoved", t, this, n), t.emit("removed", this)), t;
    }
    _onUpdate(e) {
      e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = true, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
    }
    set isRenderGroup(e) {
      !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup());
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup) return;
      const e = this.parentRenderGroup;
      e == null ? void 0 : e.removeChild(this), this.renderGroup = fa.get(Bxe, this), this.groupTransform = pt.IDENTITY, e == null ? void 0 : e.addChild(this), this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup) return;
      const e = this.parentRenderGroup;
      e == null ? void 0 : e.removeChild(this), fa.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e == null ? void 0 : e.addChild(this), this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      return this._worldTransform || (this._worldTransform = new pt()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
    }
    get x() {
      return this._position.x;
    }
    set x(e) {
      this._position.x = e;
    }
    get y() {
      return this._position.y;
    }
    set y(e) {
      this._position.y = e;
    }
    get position() {
      return this._position;
    }
    set position(e) {
      this._position.copyFrom(e);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(e) {
      this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew));
    }
    get angle() {
      return this.rotation * Q0e;
    }
    set angle(e) {
      this.rotation = e * J0e;
    }
    get pivot() {
      return this._pivot === I0 && (this._pivot = new Jr(this, 0, 0)), this._pivot;
    }
    set pivot(e) {
      this._pivot === I0 && (this._pivot = new Jr(this, 0, 0)), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e);
    }
    get skew() {
      return this._skew === A0 && (this._skew = new Jr(this, 0, 0)), this._skew;
    }
    set skew(e) {
      this._skew === A0 && (this._skew = new Jr(this, 0, 0)), this._skew.copyFrom(e);
    }
    get scale() {
      return this._scale === M0 && (this._scale = new Jr(this, 1, 1)), this._scale;
    }
    set scale(e) {
      this._scale === M0 && (this._scale = new Jr(this, 0, 0)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(e) {
      const t = this.getLocalBounds().width;
      this._setWidth(e, t);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(e) {
      const t = this.getLocalBounds().height;
      this._setHeight(e, t);
    }
    getSize(e) {
      e || (e = {});
      const t = this.getLocalBounds();
      return e.width = Math.abs(this.scale.x * t.width), e.height = Math.abs(this.scale.y * t.height), e;
    }
    setSize(e, t) {
      const n = this.getLocalBounds();
      typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, n.width), t !== void 0 && this._setHeight(t, n.height);
    }
    _updateSkew() {
      const e = this._rotation, t = this._skew;
      this._cx = Math.cos(e + t._y), this._sx = Math.sin(e + t._y), this._cy = -Math.sin(e - t._x), this._sy = Math.cos(e - t._x);
    }
    updateTransform(e) {
      return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y), this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y), this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y), this;
    }
    setFromMatrix(e) {
      e.decompose(this);
    }
    updateLocalTransform() {
      const e = this._didContainerChangeTick;
      if (this._didLocalTransformChangeId === e) return;
      this._didLocalTransformChangeId = e;
      const t = this.localTransform, n = this._scale, i = this._pivot, a = this._position, o = n._x, s = n._y, l = i._x, u = i._y;
      t.a = this._cx * o, t.b = this._sx * o, t.c = this._cy * s, t.d = this._sy * s, t.tx = a._x - (l * t.a + u * t.c), t.ty = a._y - (l * t.b + u * t.d);
    }
    set alpha(e) {
      e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= KP, this._onUpdate());
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(e) {
      const n = kr.shared.setValue(e ?? 16777215).toBgrNumber();
      n !== this.localColor && (this.localColor = n, this._updateFlags |= KP, this._onUpdate());
    }
    get tint() {
      return kp(this.localColor);
    }
    set blendMode(e) {
      this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= Vxe, this.localBlendMode = e, this._onUpdate());
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(e) {
      const t = e ? 2 : 0;
      (this.localDisplayStatus & 2) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= D0, this.localDisplayStatus ^= 2, this._onUpdate());
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(e) {
      const t = e ? 0 : 4;
      (this.localDisplayStatus & 4) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= D0, this.localDisplayStatus ^= 4, this._onUpdate());
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(e) {
      const t = e ? 1 : 0;
      (this.localDisplayStatus & 1) !== t && (this._updateFlags |= D0, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._onUpdate());
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(e = false) {
      var _a2;
      if (this.destroyed) return;
      this.destroyed = true;
      let t;
      if (this.children.length && (t = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e == null ? void 0 : e.children) && t) for (let i = 0; i < t.length; ++i) t[i].destroy(e);
      (_a2 = this.renderGroup) == null ? void 0 : _a2.destroy(), this.renderGroup = null;
    }
  };
  Wn.mixin(al, bxe, Ixe, Exe, kxe, Pxe, Cxe, Txe, Lxe, mxe, xxe, Mxe, Sxe);
  class hw extends al {
    constructor(e) {
      super(e), this.canBundle = true, this.allowChildren = false, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new ui(0, 1, 0, 0), this._boundsDirty = true;
    }
    get bounds() {
      return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = false, this._bounds) : this._bounds;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(e) {
      this._roundPixels = e ? 1 : 0;
    }
    containsPoint(e) {
      const t = this.bounds, { x: n, y: i } = e;
      return n >= t.minX && n <= t.maxX && i >= t.minY && i <= t.maxY;
    }
    onViewUpdate() {
      if (this._didViewChangeTick++, this._boundsDirty = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const e = this.renderGroup || this.parentRenderGroup;
      e && e.onChildViewUpdate(this);
    }
    destroy(e) {
      super.destroy(e), this._bounds = null;
    }
    collectRenderablesSimple(e, t, n) {
      const { renderPipes: i, renderableGC: a } = t;
      i.blendMode.setBlendMode(this, this.groupBlendMode, e), i[this.renderPipeId].addRenderable(this, e), a.addRenderable(this), this.didViewUpdate = false;
      const s = this.children, l = s.length;
      for (let u = 0; u < l; u++) s[u].collectRenderables(e, t, n);
    }
  }
  bu = class extends hw {
    constructor(e = At.EMPTY) {
      e instanceof At && (e = {
        texture: e
      });
      const { texture: t = At.EMPTY, anchor: n, roundPixels: i, width: a, height: o, ...s } = e;
      super({
        label: "Sprite",
        ...s
      }), this.renderPipeId = "sprite", this.batched = true, this._visualBounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._anchor = new Jr({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), n ? this.anchor = n : t.defaultAnchor && (this.anchor = t.defaultAnchor), this.texture = t, this.allowChildren = false, this.roundPixels = i ?? false, a !== void 0 && (this.width = a), o !== void 0 && (this.height = o);
    }
    static from(e, t = false) {
      return e instanceof At ? new bu(e) : new bu(At.from(e, t));
    }
    set texture(e) {
      e || (e = At.EMPTY);
      const t = this._texture;
      t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get visualBounds() {
      return sxe(this._visualBounds, this._anchor, this._texture), this._visualBounds;
    }
    get sourceBounds() {
      return Pt("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
    }
    updateBounds() {
      const e = this._anchor, t = this._texture, n = this._bounds, { width: i, height: a } = t.orig;
      n.minX = -e._x * i, n.maxX = n.minX + i, n.minY = -e._y * a, n.maxY = n.minY + a;
    }
    destroy(e = false) {
      if (super.destroy(e), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const n = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        this._texture.destroy(n);
      }
      this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(e) {
      this._setWidth(e, this._texture.orig.width), this._width = e;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(e) {
      this._setHeight(e, this._texture.orig.height), this._height = e;
    }
    getSize(e) {
      return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e;
    }
    setSize(e, t) {
      typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), t !== void 0 && this._setHeight(t, this._texture.orig.height);
    }
  };
  const $xe = new ui();
  function nV(r, e, t) {
    const n = $xe;
    r.measurable = true, Zz(r, t, n), e.addBoundsMask(n), r.measurable = false;
  }
  function iV(r, e, t) {
    const n = da.get();
    r.measurable = true;
    const i = Gr.get().identity(), a = aV(r, t, i);
    Jz(r, n, a), r.measurable = false, e.addBoundsMask(n), Gr.return(i), da.return(n);
  }
  function aV(r, e, t) {
    return r ? (r !== e && (aV(r.parent, e, t), r.updateLocalTransform(), t.append(r.localTransform)), t) : (mn("Mask bounds, renderable is not inside the root container"), t);
  }
  class oV {
    constructor(e) {
      this.priority = 0, this.inverse = false, this.pipe = "alphaMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e, this.renderMaskToTexture = !(e instanceof bu), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask = null;
    }
    addBounds(e, t) {
      this.inverse || nV(this.mask, e, t);
    }
    addLocalBounds(e, t) {
      iV(this.mask, e, t);
    }
    containsPoint(e, t) {
      const n = this.mask;
      return t(n, e);
    }
    destroy() {
      this.reset();
    }
    static test(e) {
      return e instanceof bu;
    }
  }
  oV.extension = Ct.MaskEffect;
  class sV {
    constructor(e) {
      this.priority = 0, this.pipe = "colorMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e;
    }
    destroy() {
    }
    static test(e) {
      return typeof e == "number";
    }
  }
  sV.extension = Ct.MaskEffect;
  class lV {
    constructor(e) {
      this.priority = 0, this.pipe = "stencilMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e, this.mask.includeInBuild = false, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask.includeInBuild = true, this.mask = null;
    }
    addBounds(e, t) {
      nV(this.mask, e, t);
    }
    addLocalBounds(e, t) {
      iV(this.mask, e, t);
    }
    containsPoint(e, t) {
      const n = this.mask;
      return t(n, e);
    }
    destroy() {
      this.reset();
    }
    static test(e) {
      return e instanceof al;
    }
  }
  lV.extension = Ct.MaskEffect;
  const Gxe = {
    createCanvas: (r, e) => {
      const t = document.createElement("canvas");
      return t.width = r, t.height = e, t;
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (r, e) => fetch(r, e),
    parseXML: (r) => new DOMParser().parseFromString(r, "text/xml")
  };
  let ZP = Gxe;
  oi = {
    get() {
      return ZP;
    },
    set(r) {
      ZP = r;
    }
  };
  uV = class extends fi {
    constructor(e) {
      e.resource || (e.resource = oi.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent;
    }
    resizeCanvas() {
      this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
    }
    resize(e = this.width, t = this.height, n = this._resolution) {
      const i = super.resize(e, t, n);
      return i && this.resizeCanvas(), i;
    }
    static test(e) {
      return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas;
    }
    get context2D() {
      return this._context2D || (this._context2D = this.resource.getContext("2d"));
    }
  };
  uV.extension = Ct.TextureSource;
  Ov = class extends fi {
    constructor(e) {
      if (e.resource && globalThis.HTMLImageElement && e.resource instanceof HTMLImageElement) {
        const t = oi.get().createCanvas(e.resource.width, e.resource.height);
        t.getContext("2d").drawImage(e.resource, 0, 0, e.resource.width, e.resource.height), e.resource = t, mn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
      }
      super(e), this.uploadMethodId = "image", this.autoGarbageCollect = true;
    }
    static test(e) {
      return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame;
    }
  };
  Ov.extension = Ct.TextureSource;
  sb = ((r) => (r[r.INTERACTION = 50] = "INTERACTION", r[r.HIGH = 25] = "HIGH", r[r.NORMAL = 0] = "NORMAL", r[r.LOW = -25] = "LOW", r[r.UTILITY = -50] = "UTILITY", r))(sb || {});
  class P0 {
    constructor(e, t = null, n = 0, i = false) {
      this.next = null, this.previous = null, this._destroyed = false, this._fn = e, this._context = t, this.priority = n, this._once = i;
    }
    match(e, t = null) {
      return this._fn === e && this._context === t;
    }
    emit(e) {
      this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
      const t = this.next;
      return this._once && this.destroy(true), this._destroyed && (this.next = null), t;
    }
    connect(e) {
      this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
    }
    destroy(e = false) {
      this._destroyed = true, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      const t = this.next;
      return this.next = e ? null : t, this.previous = null, t;
    }
  }
  const cV = class fn {
    constructor() {
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new P0(null, null, 1 / 0), this.deltaMS = 1 / fn.targetFPMS, this.elapsedMS = 1 / fn.targetFPMS, this._tick = (e) => {
        this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
      };
    }
    _requestIfNeeded() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }
    _cancelIfNeeded() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(e, t, n = sb.NORMAL) {
      return this._addListener(new P0(e, t, n));
    }
    addOnce(e, t, n = sb.NORMAL) {
      return this._addListener(new P0(e, t, n, true));
    }
    _addListener(e) {
      let t = this._head.next, n = this._head;
      if (!t) e.connect(n);
      else {
        for (; t; ) {
          if (e.priority > t.priority) {
            e.connect(n);
            break;
          }
          n = t, t = t.next;
        }
        e.previous || e.connect(n);
      }
      return this._startIfPossible(), this;
    }
    remove(e, t) {
      let n = this._head.next;
      for (; n; ) n.match(e, t) ? n = n.destroy() : n = n.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) return 0;
      let e = 0, t = this._head;
      for (; t = t.next; ) e++;
      return e;
    }
    start() {
      this.started || (this.started = true, this._requestIfNeeded());
    }
    stop() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let e = this._head.next;
        for (; e; ) e = e.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }
    update(e = performance.now()) {
      let t;
      if (e > this.lastTime) {
        if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
          const a = e - this._lastFrame | 0;
          if (a < this._minElapsedMS) return;
          this._lastFrame = e - a % this._minElapsedMS;
        }
        this.deltaMS = t, this.deltaTime = this.deltaMS * fn.targetFPMS;
        const n = this._head;
        let i = n.next;
        for (; i; ) i = i.emit(this);
        n.next || this._cancelIfNeeded();
      } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = e;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(e) {
      const t = Math.min(this.maxFPS, e), n = Math.min(Math.max(0, t) / 1e3, fn.targetFPMS);
      this._maxElapsedMS = 1 / n;
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(e) {
      if (e === 0) this._minElapsedMS = 0;
      else {
        const t = Math.max(this.minFPS, e);
        this._minElapsedMS = 1 / (t / 1e3);
      }
    }
    static get shared() {
      if (!fn._shared) {
        const e = fn._shared = new fn();
        e.autoStart = true, e._protected = true;
      }
      return fn._shared;
    }
    static get system() {
      if (!fn._system) {
        const e = fn._system = new fn();
        e.autoStart = true, e._protected = true;
      }
      return fn._system;
    }
  };
  cV.targetFPMS = 0.06;
  let k0;
  Yd = cV;
  async function Wxe() {
    return k0 ?? (k0 = (async () => {
      var _a2;
      const e = document.createElement("canvas").getContext("webgl");
      if (!e) return "premultiply-alpha-on-upload";
      const t = await new Promise((o) => {
        const s = document.createElement("video");
        s.onloadeddata = () => o(s), s.onerror = () => o(null), s.autoplay = false, s.crossOrigin = "anonymous", s.preload = "auto", s.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", s.load();
      });
      if (!t) return "premultiply-alpha-on-upload";
      const n = e.createTexture();
      e.bindTexture(e.TEXTURE_2D, n);
      const i = e.createFramebuffer();
      e.bindFramebuffer(e.FRAMEBUFFER, i), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
      const a = new Uint8Array(4);
      return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, a), e.deleteFramebuffer(i), e.deleteTexture(n), (_a2 = e.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), a[0] <= a[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })()), k0;
  }
  const Og = class hV extends fi {
    constructor(e) {
      super(e), this.isReady = false, this.uploadMethodId = "video", e = {
        ...hV.defaultOptions,
        ...e
      }, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== false, this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== false && this.load();
    }
    updateFrame() {
      if (!this.destroyed) {
        if (this._updateFPS) {
          const e = Yd.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
        }
        (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) return this._load;
      const e = this.resource, t = this.options;
      return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = true), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (t.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, true)), this.alphaMode = await Wxe(), this._load = new Promise((n, i) => {
        this.isValid ? n(this) : (this._resolve = n, this._reject = i, t.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
          this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`));
        })), e.load());
      }), this._load;
    }
    _onError(e) {
      this.resource.removeEventListener("error", this._onError, true), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null);
    }
    _isSourcePlaying() {
      const e = this.resource;
      return !e.paused && !e.ended;
    }
    _isSourceReady() {
      return this.resource.readyState > 2;
    }
    _onPlayStart() {
      this.isValid || this._mediaReady(), this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
    }
    _onCanPlay() {
      this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
    }
    _onCanPlayThrough() {
      this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
    }
    _mediaReady() {
      const e = this.resource;
      this.isValid && (this.isReady = true, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
    }
    destroy() {
      this._configureAutoUpdate();
      const e = this.resource;
      e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, true), e.pause(), e.src = "", e.load()), super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(e) {
      e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Yd.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Yd.shared.add(this.updateFrame, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Yd.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
    }
    static test(e) {
      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
    }
  };
  Og.extension = Ct.TextureSource;
  Og.defaultOptions = {
    ...fi.defaultOptions,
    autoLoad: true,
    autoPlay: true,
    updateFPS: 0,
    crossorigin: true,
    loop: false,
    muted: true,
    playsinline: true,
    preload: false
  };
  Og.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  let Uxe = Og;
  const Wl = (r, e, t = false) => (Array.isArray(r) || (r = [
    r
  ]), e ? r.map((n) => typeof n == "string" || t ? e(n) : n) : r);
  class Hxe {
    constructor() {
      this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear(), this._cache.clear();
    }
    has(e) {
      return this._cache.has(e);
    }
    get(e) {
      const t = this._cache.get(e);
      return t || mn(`[Assets] Asset id ${e} was not found in the Cache`), t;
    }
    set(e, t) {
      const n = Wl(e);
      let i;
      for (let l = 0; l < this.parsers.length; l++) {
        const u = this.parsers[l];
        if (u.test(t)) {
          i = u.getCacheableAssets(n, t);
          break;
        }
      }
      const a = new Map(Object.entries(i || {}));
      i || n.forEach((l) => {
        a.set(l, t);
      });
      const o = [
        ...a.keys()
      ], s = {
        cacheKeys: o,
        keys: n
      };
      n.forEach((l) => {
        this._cacheMap.set(l, s);
      }), o.forEach((l) => {
        const u = i ? i[l] : t;
        this._cache.has(l) && this._cache.get(l) !== u && mn("[Cache] already has key:", l), this._cache.set(l, a.get(l));
      });
    }
    remove(e) {
      if (!this._cacheMap.has(e)) {
        mn(`[Assets] Asset id ${e} was not found in the Cache`);
        return;
      }
      const t = this._cacheMap.get(e);
      t.cacheKeys.forEach((i) => {
        this._cache.delete(i);
      }), t.keys.forEach((i) => {
        this._cacheMap.delete(i);
      });
    }
    get parsers() {
      return this._parsers;
    }
  }
  let lb;
  Ul = new Hxe();
  lb = [];
  Wn.handleByList(Ct.TextureSource, lb);
  function fV(r = {}) {
    const e = r && r.resource, t = e ? r.resource : r, n = e ? r : {
      resource: r
    };
    for (let i = 0; i < lb.length; i++) {
      const a = lb[i];
      if (a.test(t)) return new a(n);
    }
    throw new Error(`Could not find a source type for resource: ${n.resource}`);
  }
  function Yxe(r = {}, e = false) {
    const t = r && r.resource, n = t ? r.resource : r, i = t ? r : {
      resource: r
    };
    if (!e && Ul.has(n)) return Ul.get(n);
    const a = new At({
      source: fV(i)
    });
    return a.on("destroy", () => {
      Ul.has(n) && Ul.remove(n);
    }), e || Ul.set(n, a), a;
  }
  function Xxe(r, e = false) {
    return typeof r == "string" ? Ul.get(r) : r instanceof fi ? new At({
      source: r
    }) : Yxe(r, e);
  }
  At.from = Xxe;
  fi.from = fV;
  Wn.add(oV, sV, lV, Uxe, Ov, uV, lw);
  var dV = ((r) => (r[r.Low = 0] = "Low", r[r.Normal = 1] = "Normal", r[r.High = 2] = "High", r))(dV || {});
  function Xn(r) {
    if (typeof r != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(r)}`);
  }
  function wc(r) {
    return r.split("?")[0].split("#")[0];
  }
  function qxe(r) {
    return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function Kxe(r, e, t) {
    return r.replace(new RegExp(qxe(e), "g"), t);
  }
  function Zxe(r, e) {
    let t = "", n = 0, i = -1, a = 0, o = -1;
    for (let s = 0; s <= r.length; ++s) {
      if (s < r.length) o = r.charCodeAt(s);
      else {
        if (o === 47) break;
        o = 47;
      }
      if (o === 47) {
        if (!(i === s - 1 || a === 1)) if (i !== s - 1 && a === 2) {
          if (t.length < 2 || n !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
            if (t.length > 2) {
              const l = t.lastIndexOf("/");
              if (l !== t.length - 1) {
                l === -1 ? (t = "", n = 0) : (t = t.slice(0, l), n = t.length - 1 - t.lastIndexOf("/")), i = s, a = 0;
                continue;
              }
            } else if (t.length === 2 || t.length === 1) {
              t = "", n = 0, i = s, a = 0;
              continue;
            }
          }
        } else t.length > 0 ? t += `/${r.slice(i + 1, s)}` : t = r.slice(i + 1, s), n = s - i - 1;
        i = s, a = 0;
      } else o === 46 && a !== -1 ? ++a : a = -1;
    }
    return t;
  }
  const ef = {
    toPosix(r) {
      return Kxe(r, "\\", "/");
    },
    isUrl(r) {
      return /^https?:/.test(this.toPosix(r));
    },
    isDataUrl(r) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(r);
    },
    isBlobUrl(r) {
      return r.startsWith("blob:");
    },
    hasProtocol(r) {
      return /^[^/:]+:/.test(this.toPosix(r));
    },
    getProtocol(r) {
      Xn(r), r = this.toPosix(r);
      const e = /^file:\/\/\//.exec(r);
      if (e) return e[0];
      const t = /^[^/:]+:\/{0,2}/.exec(r);
      return t ? t[0] : "";
    },
    toAbsolute(r, e, t) {
      if (Xn(r), this.isDataUrl(r) || this.isBlobUrl(r)) return r;
      const n = wc(this.toPosix(e ?? oi.get().getBaseUrl())), i = wc(this.toPosix(t ?? this.rootname(n)));
      return r = this.toPosix(r), r.startsWith("/") ? ef.join(i, r.slice(1)) : this.isAbsolute(r) ? r : this.join(n, r);
    },
    normalize(r) {
      if (Xn(r), r.length === 0) return ".";
      if (this.isDataUrl(r) || this.isBlobUrl(r)) return r;
      r = this.toPosix(r);
      let e = "";
      const t = r.startsWith("/");
      this.hasProtocol(r) && (e = this.rootname(r), r = r.slice(e.length));
      const n = r.endsWith("/");
      return r = Zxe(r), r.length > 0 && n && (r += "/"), t ? `/${r}` : e + r;
    },
    isAbsolute(r) {
      return Xn(r), r = this.toPosix(r), this.hasProtocol(r) ? true : r.startsWith("/");
    },
    join(...r) {
      if (r.length === 0) return ".";
      let e;
      for (let t = 0; t < r.length; ++t) {
        const n = r[t];
        if (Xn(n), n.length > 0) if (e === void 0) e = n;
        else {
          const i = r[t - 1] ?? "";
          this.joinExtensions.includes(this.extname(i).toLowerCase()) ? e += `/../${n}` : e += `/${n}`;
        }
      }
      return e === void 0 ? "." : this.normalize(e);
    },
    dirname(r) {
      if (Xn(r), r.length === 0) return ".";
      r = this.toPosix(r);
      let e = r.charCodeAt(0);
      const t = e === 47;
      let n = -1, i = true;
      const a = this.getProtocol(r), o = r;
      r = r.slice(a.length);
      for (let s = r.length - 1; s >= 1; --s) if (e = r.charCodeAt(s), e === 47) {
        if (!i) {
          n = s;
          break;
        }
      } else i = false;
      return n === -1 ? t ? "/" : this.isUrl(o) ? a + r : a : t && n === 1 ? "//" : a + r.slice(0, n);
    },
    rootname(r) {
      Xn(r), r = this.toPosix(r);
      let e = "";
      if (r.startsWith("/") ? e = "/" : e = this.getProtocol(r), this.isUrl(r)) {
        const t = r.indexOf("/", e.length);
        t !== -1 ? e = r.slice(0, t) : e = r, e.endsWith("/") || (e += "/");
      }
      return e;
    },
    basename(r, e) {
      Xn(r), e && Xn(e), r = wc(this.toPosix(r));
      let t = 0, n = -1, i = true, a;
      if (e !== void 0 && e.length > 0 && e.length <= r.length) {
        if (e.length === r.length && e === r) return "";
        let o = e.length - 1, s = -1;
        for (a = r.length - 1; a >= 0; --a) {
          const l = r.charCodeAt(a);
          if (l === 47) {
            if (!i) {
              t = a + 1;
              break;
            }
          } else s === -1 && (i = false, s = a + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (n = a) : (o = -1, n = s));
        }
        return t === n ? n = s : n === -1 && (n = r.length), r.slice(t, n);
      }
      for (a = r.length - 1; a >= 0; --a) if (r.charCodeAt(a) === 47) {
        if (!i) {
          t = a + 1;
          break;
        }
      } else n === -1 && (i = false, n = a + 1);
      return n === -1 ? "" : r.slice(t, n);
    },
    extname(r) {
      Xn(r), r = wc(this.toPosix(r));
      let e = -1, t = 0, n = -1, i = true, a = 0;
      for (let o = r.length - 1; o >= 0; --o) {
        const s = r.charCodeAt(o);
        if (s === 47) {
          if (!i) {
            t = o + 1;
            break;
          }
          continue;
        }
        n === -1 && (i = false, n = o + 1), s === 46 ? e === -1 ? e = o : a !== 1 && (a = 1) : e !== -1 && (a = -1);
      }
      return e === -1 || n === -1 || a === 0 || a === 1 && e === n - 1 && e === t + 1 ? "" : r.slice(e, n);
    },
    parse(r) {
      Xn(r);
      const e = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (r.length === 0) return e;
      r = wc(this.toPosix(r));
      let t = r.charCodeAt(0);
      const n = this.isAbsolute(r);
      let i;
      e.root = this.rootname(r), n || this.hasProtocol(r) ? i = 1 : i = 0;
      let a = -1, o = 0, s = -1, l = true, u = r.length - 1, c = 0;
      for (; u >= i; --u) {
        if (t = r.charCodeAt(u), t === 47) {
          if (!l) {
            o = u + 1;
            break;
          }
          continue;
        }
        s === -1 && (l = false, s = u + 1), t === 46 ? a === -1 ? a = u : c !== 1 && (c = 1) : a !== -1 && (c = -1);
      }
      return a === -1 || s === -1 || c === 0 || c === 1 && a === s - 1 && a === o + 1 ? s !== -1 && (o === 0 && n ? e.base = e.name = r.slice(1, s) : e.base = e.name = r.slice(o, s)) : (o === 0 && n ? (e.name = r.slice(1, a), e.base = r.slice(1, s)) : (e.name = r.slice(o, a), e.base = r.slice(o, s)), e.ext = r.slice(a, s)), e.dir = this.dirname(r), e;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [
      ".html"
    ]
  };
  function pV(r, e, t, n, i) {
    const a = e[t];
    for (let o = 0; o < a.length; o++) {
      const s = a[o];
      t < e.length - 1 ? pV(r.replace(n[t], s), e, t + 1, n, i) : i.push(r.replace(n[t], s));
    }
  }
  function jxe(r) {
    const e = /\{(.*?)\}/g, t = r.match(e), n = [];
    if (t) {
      const i = [];
      t.forEach((a) => {
        const o = a.substring(1, a.length - 1).split(",");
        i.push(o);
      }), pV(r, i, 0, t, n);
    } else n.push(r);
    return n;
  }
  const jP = (r) => !Array.isArray(r);
  class vV {
    constructor() {
      this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
        extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, "")
      }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
    }
    setBundleIdentifier(e) {
      if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
    prefer(...e) {
      e.forEach((t) => {
        this._preferredOrder.push(t), t.priority || (t.priority = Object.keys(t.params));
      }), this._resolverHash = {};
    }
    set basePath(e) {
      this._basePath = e;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(e) {
      this._rootPath = e;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
    }
    setDefaultSearchParams(e) {
      if (typeof e == "string") this._defaultSearchParams = e;
      else {
        const t = e;
        this._defaultSearchParams = Object.keys(t).map((n) => `${encodeURIComponent(n)}=${encodeURIComponent(t[n])}`).join("&");
      }
    }
    getAlias(e) {
      const { alias: t, src: n } = e;
      return Wl(t || n, (a) => typeof a == "string" ? a : Array.isArray(a) ? a.map((o) => (o == null ? void 0 : o.src) ?? o) : (a == null ? void 0 : a.src) ? a.src : a, true);
    }
    addManifest(e) {
      this._manifest && mn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach((t) => {
        this.addBundle(t.name, t.assets);
      });
    }
    addBundle(e, t) {
      const n = [];
      let i = t;
      Array.isArray(t) || (i = Object.entries(t).map(([a, o]) => typeof o == "string" || Array.isArray(o) ? {
        alias: a,
        src: o
      } : {
        alias: a,
        ...o
      })), i.forEach((a) => {
        const o = a.src, s = a.alias;
        let l;
        if (typeof s == "string") {
          const u = this._createBundleAssetId(e, s);
          n.push(u), l = [
            s,
            u
          ];
        } else {
          const u = s.map((c) => this._createBundleAssetId(e, c));
          n.push(...u), l = [
            ...s,
            ...u
          ];
        }
        this.add({
          ...a,
          alias: l,
          src: o
        });
      }), this._bundles[e] = n;
    }
    add(e) {
      const t = [];
      Array.isArray(e) ? t.push(...e) : t.push(e);
      let n;
      n = (a) => {
        this.hasKey(a) && mn(`[Resolver] already has key: ${a} overwriting`);
      }, Wl(t).forEach((a) => {
        const { src: o } = a;
        let { data: s, format: l, loadParser: u } = a;
        const c = Wl(o).map((d) => typeof d == "string" ? jxe(d) : Array.isArray(d) ? d : [
          d
        ]), h = this.getAlias(a);
        Array.isArray(h) ? h.forEach(n) : n(h);
        const f = [];
        c.forEach((d) => {
          d.forEach((p) => {
            let v = {};
            if (typeof p != "object") {
              v.src = p;
              for (let g = 0; g < this._parsers.length; g++) {
                const m = this._parsers[g];
                if (m.test(p)) {
                  v = m.parse(p);
                  break;
                }
              }
            } else s = p.data ?? s, l = p.format ?? l, u = p.loadParser ?? u, v = {
              ...v,
              ...p
            };
            if (!h) throw new Error(`[Resolver] alias is undefined for this asset: ${v.src}`);
            v = this._buildResolvedAsset(v, {
              aliases: h,
              data: s,
              format: l,
              loadParser: u
            }), f.push(v);
          });
        }), h.forEach((d) => {
          this._assetMap[d] = f;
        });
      });
    }
    resolveBundle(e) {
      const t = jP(e);
      e = Wl(e);
      const n = {};
      return e.forEach((i) => {
        const a = this._bundles[i];
        if (a) {
          const o = this.resolve(a), s = {};
          for (const l in o) {
            const u = o[l];
            s[this._extractAssetIdFromBundle(i, l)] = u;
          }
          n[i] = s;
        }
      }), t ? n[e[0]] : n;
    }
    resolveUrl(e) {
      const t = this.resolve(e);
      if (typeof e != "string") {
        const n = {};
        for (const i in t) n[i] = t[i].src;
        return n;
      }
      return t.src;
    }
    resolve(e) {
      const t = jP(e);
      e = Wl(e);
      const n = {};
      return e.forEach((i) => {
        if (!this._resolverHash[i]) if (this._assetMap[i]) {
          let a = this._assetMap[i];
          const o = this._getPreferredOrder(a);
          o == null ? void 0 : o.priority.forEach((s) => {
            o.params[s].forEach((l) => {
              const u = a.filter((c) => c[s] ? c[s] === l : false);
              u.length && (a = u);
            });
          }), this._resolverHash[i] = a[0];
        } else this._resolverHash[i] = this._buildResolvedAsset({
          alias: [
            i
          ],
          src: i
        }, {});
        n[i] = this._resolverHash[i];
      }), t ? n[e[0]] : n;
    }
    hasKey(e) {
      return !!this._assetMap[e];
    }
    hasBundle(e) {
      return !!this._bundles[e];
    }
    _getPreferredOrder(e) {
      for (let t = 0; t < e.length; t++) {
        const n = e[t], i = this._preferredOrder.find((a) => a.params.format.includes(n.format));
        if (i) return i;
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(e) {
      if (!this._defaultSearchParams) return e;
      const t = /\?/.test(e) ? "&" : "?";
      return `${e}${t}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(e, t) {
      const { aliases: n, data: i, loadParser: a, format: o } = t;
      return (this._basePath || this._rootPath) && (e.src = ef.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = n ?? e.alias ?? [
        e.src
      ], e.src = this._appendDefaultSearchParams(e.src), e.data = {
        ...i || {},
        ...e.data
      }, e.loadParser = a ?? e.loadParser, e.format = o ?? e.format ?? Qxe(e.src), e;
    }
  }
  vV.RETINA_PREFIX = /@([0-9\.]+)x/;
  function Qxe(r) {
    return r.split(".").pop().split("?").shift().split("#").shift();
  }
  const QP = (r, e) => {
    const t = e.split("?")[1];
    return t && (r += `?${t}`), r;
  }, gV = class Hc {
    constructor(e, t) {
      this.linkedSheets = [], this._texture = e instanceof At ? e : null, this.textureSource = e.source, this.textures = {}, this.animations = {}, this.data = t;
      const n = parseFloat(t.meta.scale);
      n ? (this.resolution = n, e.source.resolution = this.resolution) : this.resolution = e.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    parse() {
      return new Promise((e) => {
        this._callback = e, this._batchIndex = 0, this._frameKeys.length <= Hc.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
      });
    }
    _processFrames(e) {
      let t = e;
      const n = Hc.BATCH_SIZE;
      for (; t - e < n && t < this._frameKeys.length; ) {
        const i = this._frameKeys[t], a = this._frames[i], o = a.frame;
        if (o) {
          let s = null, l = null;
          const u = a.trimmed !== false && a.sourceSize ? a.sourceSize : a.frame, c = new gr(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution);
          a.rotated ? s = new gr(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : s = new gr(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), a.trimmed !== false && a.spriteSourceSize && (l = new gr(Math.floor(a.spriteSourceSize.x) / this.resolution, Math.floor(a.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[i] = new At({
            source: this.textureSource,
            frame: s,
            orig: c,
            trim: l,
            rotate: a.rotated ? 2 : 0,
            defaultAnchor: a.anchor,
            defaultBorders: a.borders,
            label: i.toString()
          });
        }
        t++;
      }
    }
    _processAnimations() {
      const e = this.data.animations || {};
      for (const t in e) {
        this.animations[t] = [];
        for (let n = 0; n < e[t].length; n++) {
          const i = e[t][n];
          this.animations[t].push(this.textures[i]);
        }
      }
    }
    _parseComplete() {
      const e = this._callback;
      this._callback = null, this._batchIndex = 0, e.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * Hc.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
        this._batchIndex * Hc.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(e = false) {
      var _a2;
      for (const t in this.textures) this.textures[t].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((_a2 = this._texture) == null ? void 0 : _a2.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
    }
  };
  gV.BATCH_SIZE = 1e3;
  let JP = gV;
  const Jxe = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
  ];
  function mV(r, e, t) {
    const n = {};
    if (r.forEach((i) => {
      n[i] = e;
    }), Object.keys(e.textures).forEach((i) => {
      n[i] = e.textures[i];
    }), !t) {
      const i = ef.dirname(r[0]);
      e.linkedSheets.forEach((a, o) => {
        const s = mV([
          `${i}/${e.data.meta.related_multi_packs[o]}`
        ], a, true);
        Object.assign(n, s);
      });
    }
    return n;
  }
  const e_e = {
    extension: Ct.Asset,
    cache: {
      test: (r) => r instanceof JP,
      getCacheableAssets: (r, e) => mV(r, e, false)
    },
    resolver: {
      extension: {
        type: Ct.ResolveParser,
        name: "resolveSpritesheet"
      },
      test: (r) => {
        const t = r.split("?")[0].split("."), n = t.pop(), i = t.pop();
        return n === "json" && Jxe.includes(i);
      },
      parse: (r) => {
        var _a2;
        const e = r.split(".");
        return {
          resolution: parseFloat(((_a2 = vV.RETINA_PREFIX.exec(r)) == null ? void 0 : _a2[1]) ?? "1"),
          format: e[e.length - 2],
          src: r
        };
      }
    },
    loader: {
      name: "spritesheetLoader",
      extension: {
        type: Ct.LoadParser,
        priority: dV.Normal,
        name: "spritesheetLoader"
      },
      async testParse(r, e) {
        return ef.extname(e.src).toLowerCase() === ".json" && !!r.frames;
      },
      async parse(r, e, t) {
        var _a2, _b2;
        const { texture: n, imageFilename: i, textureOptions: a } = (e == null ? void 0 : e.data) ?? {};
        let o = ef.dirname(e.src);
        o && o.lastIndexOf("/") !== o.length - 1 && (o += "/");
        let s;
        if (n instanceof At) s = n;
        else {
          const c = QP(o + (i ?? r.meta.image), e.src);
          s = (await t.load([
            {
              src: c,
              data: a
            }
          ]))[c];
        }
        const l = new JP(s.source, r);
        await l.parse();
        const u = (_a2 = r == null ? void 0 : r.meta) == null ? void 0 : _a2.related_multi_packs;
        if (Array.isArray(u)) {
          const c = [];
          for (const f of u) {
            if (typeof f != "string") continue;
            let d = o + f;
            ((_b2 = e.data) == null ? void 0 : _b2.ignoreMultiPack) || (d = QP(d, e.src), c.push(t.load({
              src: d,
              data: {
                textureOptions: a,
                ignoreMultiPack: true
              }
            })));
          }
          const h = await Promise.all(c);
          l.linkedSheets = h, h.forEach((f) => {
            f.linkedSheets = [
              l
            ].concat(l.linkedSheets.filter((d) => d !== f));
          });
        }
        return l;
      },
      async unload(r, e, t) {
        await t.unload(r.textureSource._sourceOrigin), r.destroy(false);
      }
    }
  };
  Wn.add(e_e);
  const L0 = /* @__PURE__ */ Object.create(null), ek = /* @__PURE__ */ Object.create(null);
  fw = function(r, e) {
    let t = ek[r];
    return t === void 0 && (L0[e] === void 0 && (L0[e] = 1), ek[r] = t = L0[e]++), t;
  };
  let Xd;
  function yV() {
    return (!Xd || (Xd == null ? void 0 : Xd.isContextLost())) && (Xd = oi.get().createCanvas().getContext("webgl", {})), Xd;
  }
  let qd;
  function t_e() {
    if (!qd) {
      qd = "mediump";
      const r = yV();
      r && r.getShaderPrecisionFormat && (qd = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision ? "highp" : "mediump");
    }
    return qd;
  }
  function r_e(r, e, t) {
    return e ? r : t ? (r = r.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${r}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${r}
        `;
  }
  function n_e(r, e, t) {
    const n = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
    if (r.substring(0, 9) !== "precision") {
      let i = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
      return i === "highp" && n !== "highp" && (i = "mediump"), `precision ${i} float;
${r}`;
    } else if (n !== "highp" && r.substring(0, 15) === "precision highp") return r.replace("precision highp", "precision mediump");
    return r;
  }
  function i_e(r, e) {
    return e ? `#version 300 es
${r}` : r;
  }
  const a_e = {}, o_e = {};
  function s_e(r, { name: e = "pixi-program" }, t = true) {
    e = e.replace(/\s+/g, "-"), e += t ? "-fragment" : "-vertex";
    const n = t ? a_e : o_e;
    return n[e] ? (n[e]++, e += `-${n[e]}`) : n[e] = 1, r.indexOf("#define SHADER_NAME") !== -1 ? r : `${`#define SHADER_NAME ${e}`}
${r}`;
  }
  function l_e(r, e) {
    return e ? r.replace("#version 300 es", "") : r;
  }
  const R0 = {
    stripVersion: l_e,
    ensurePrecision: n_e,
    addProgramDefines: r_e,
    setProgramName: s_e,
    insertVersion: i_e
  }, E0 = /* @__PURE__ */ Object.create(null), xV = class ub {
    constructor(e) {
      e = {
        ...ub.defaultOptions,
        ...e
      };
      const t = e.fragment.indexOf("#version 300 es") !== -1, n = {
        stripVersion: t,
        ensurePrecision: {
          requestedFragmentPrecision: e.preferredFragmentPrecision,
          requestedVertexPrecision: e.preferredVertexPrecision,
          maxSupportedVertexPrecision: "highp",
          maxSupportedFragmentPrecision: t_e()
        },
        setProgramName: {
          name: e.name
        },
        addProgramDefines: t,
        insertVersion: t
      };
      let i = e.fragment, a = e.vertex;
      Object.keys(R0).forEach((o) => {
        const s = n[o];
        i = R0[o](i, s, true), a = R0[o](a, s, false);
      }), this.fragment = i, this.vertex = a, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = fw(`${this.vertex}:${this.fragment}`, "gl-program");
    }
    destroy() {
      this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
    }
    static from(e) {
      const t = `${e.vertex}:${e.fragment}`;
      return E0[t] || (E0[t] = new ub(e)), E0[t];
    }
  };
  xV.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
  };
  _V = xV;
  const tk = {
    uint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    uint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    sint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    sint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    unorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    unorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    snorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    snorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    uint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    uint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    sint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    sint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    unorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    unorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    snorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    snorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    float16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    float16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    float32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    float32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    float32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    float32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    uint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    uint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    uint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    uint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    sint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    sint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    sint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    sint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    }
  };
  u_e = function(r) {
    return tk[r] ?? tk.float32;
  };
  const c_e = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };
  function h_e({ source: r, entryPoint: e }) {
    const t = {}, n = r.indexOf(`fn ${e}`);
    if (n !== -1) {
      const i = r.indexOf("->", n);
      if (i !== -1) {
        const a = r.substring(n, i), o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let s;
        for (; (s = o.exec(a)) !== null; ) {
          const l = c_e[s[3]] ?? "float32";
          t[s[2]] = {
            location: parseInt(s[1], 10),
            format: l,
            stride: u_e(l).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return t;
  }
  function N0(r) {
    var _a2, _b2;
    const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, t = /@group\((\d+)\)/, n = /@binding\((\d+)\)/, i = /var(<[^>]+>)? (\w+)/, a = /:\s*(\w+)/, o = /struct\s+(\w+)\s*{([^}]+)}/g, s = /(\w+)\s*:\s*([\w\<\>]+)/g, l = /struct\s+(\w+)/, u = (_a2 = r.match(e)) == null ? void 0 : _a2.map((h) => ({
      group: parseInt(h.match(t)[1], 10),
      binding: parseInt(h.match(n)[1], 10),
      name: h.match(i)[2],
      isUniform: h.match(i)[1] === "<uniform>",
      type: h.match(a)[1]
    }));
    if (!u) return {
      groups: [],
      structs: []
    };
    const c = ((_b2 = r.match(o)) == null ? void 0 : _b2.map((h) => {
      const f = h.match(l)[1], d = h.match(s).reduce((p, v) => {
        const [g, m] = v.split(":");
        return p[g.trim()] = m.trim(), p;
      }, {});
      return d ? {
        name: f,
        members: d
      } : null;
    }).filter(({ name: h }) => u.some((f) => f.type === h))) ?? [];
    return {
      groups: u,
      structs: c
    };
  }
  var Yc = ((r) => (r[r.VERTEX = 1] = "VERTEX", r[r.FRAGMENT = 2] = "FRAGMENT", r[r.COMPUTE = 4] = "COMPUTE", r))(Yc || {});
  function f_e({ groups: r }) {
    const e = [];
    for (let t = 0; t < r.length; t++) {
      const n = r[t];
      e[n.group] || (e[n.group] = []), n.isUniform ? e[n.group].push({
        binding: n.binding,
        visibility: Yc.VERTEX | Yc.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      }) : n.type === "sampler" ? e[n.group].push({
        binding: n.binding,
        visibility: Yc.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      }) : n.type === "texture_2d" && e[n.group].push({
        binding: n.binding,
        visibility: Yc.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
    return e;
  }
  function d_e({ groups: r }) {
    const e = [];
    for (let t = 0; t < r.length; t++) {
      const n = r[t];
      e[n.group] || (e[n.group] = {}), e[n.group][n.name] = n.binding;
    }
    return e;
  }
  function p_e(r, e) {
    const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), i = [
      ...r.structs,
      ...e.structs
    ].filter((o) => t.has(o.name) ? false : (t.add(o.name), true)), a = [
      ...r.groups,
      ...e.groups
    ].filter((o) => {
      const s = `${o.name}-${o.binding}`;
      return n.has(s) ? false : (n.add(s), true);
    });
    return {
      structs: i,
      groups: a
    };
  }
  const O0 = /* @__PURE__ */ Object.create(null);
  Fg = class {
    constructor(e) {
      var _a2, _b2;
      this._layoutKey = 0, this._attributeLocationsKey = 0;
      const { fragment: t, vertex: n, layout: i, gpuLayout: a, name: o } = e;
      if (this.name = o, this.fragment = t, this.vertex = n, t.source === n.source) {
        const s = N0(t.source);
        this.structsAndGroups = s;
      } else {
        const s = N0(n.source), l = N0(t.source);
        this.structsAndGroups = p_e(s, l);
      }
      this.layout = i ?? d_e(this.structsAndGroups), this.gpuLayout = a ?? f_e(this.structsAndGroups), this.autoAssignGlobalUniforms = ((_a2 = this.layout[0]) == null ? void 0 : _a2.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((_b2 = this.layout[1]) == null ? void 0 : _b2.localUniforms) !== void 0, this._generateProgramKey();
    }
    _generateProgramKey() {
      const { vertex: e, fragment: t } = this, n = e.source + t.source + e.entryPoint + t.entryPoint;
      this._layoutKey = fw(n, "program");
    }
    get attributeData() {
      return this._attributeData ?? (this._attributeData = h_e(this.vertex)), this._attributeData;
    }
    destroy() {
      this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
    }
    static from(e) {
      const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
      return O0[t] || (O0[t] = new Fg(e)), O0[t];
    }
  };
  const bV = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>",
    "vec2<i32>",
    "vec3<i32>",
    "vec4<i32>"
  ], v_e = bV.reduce((r, e) => (r[e] = true, r), {});
  function g_e(r, e) {
    switch (r) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * e);
      case "vec3<f32>":
        return new Float32Array(3 * e);
      case "vec4<f32>":
        return new Float32Array(4 * e);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  const SV = class wV {
    constructor(e, t) {
      this._touched = 0, this.uid = Qt("uniform"), this._resourceType = "uniformGroup", this._resourceId = Qt("resource"), this.isUniformGroup = true, this._dirtyId = 0, this.destroyed = false, t = {
        ...wV.defaultOptions,
        ...t
      }, this.uniformStructures = e;
      const n = {};
      for (const i in e) {
        const a = e[i];
        if (a.name = i, a.size = a.size ?? 1, !v_e[a.type]) throw new Error(`Uniform type ${a.type} is not supported. Supported uniform types are: ${bV.join(", ")}`);
        a.value ?? (a.value = g_e(a.type, a.size)), n[i] = a.value;
      }
      this.uniforms = n, this._dirtyId = 1, this.ubo = t.ubo, this.isStatic = t.isStatic, this._signature = fw(Object.keys(n).map((i) => `${i}-${e[i].type}`).join("-"), "uniform-group");
    }
    update() {
      this._dirtyId++;
    }
  };
  SV.defaultOptions = {
    ubo: false,
    isStatic: false
  };
  CV = SV;
  Lp = class {
    constructor(e) {
      this.resources = /* @__PURE__ */ Object.create(null), this._dirty = true;
      let t = 0;
      for (const n in e) {
        const i = e[n];
        this.setResource(i, t++);
      }
      this._updateKey();
    }
    _updateKey() {
      if (!this._dirty) return;
      this._dirty = false;
      const e = [];
      let t = 0;
      for (const n in this.resources) e[t++] = this.resources[n]._resourceId;
      this._key = e.join("|");
    }
    setResource(e, t) {
      var _a2, _b2;
      const n = this.resources[t];
      e !== n && (n && ((_a2 = e.off) == null ? void 0 : _a2.call(e, "change", this.onResourceChange, this)), (_b2 = e.on) == null ? void 0 : _b2.call(e, "change", this.onResourceChange, this), this.resources[t] = e, this._dirty = true);
    }
    getResource(e) {
      return this.resources[e];
    }
    _touch(e) {
      const t = this.resources;
      for (const n in t) t[n]._touched = e;
    }
    destroy() {
      var _a2, _b2;
      const e = this.resources;
      for (const t in e) (_b2 = (_a2 = e[t]).off) == null ? void 0 : _b2.call(_a2, "change", this.onResourceChange, this);
      this.resources = null;
    }
    onResourceChange(e) {
      if (this._dirty = true, e.destroyed) {
        const t = this.resources;
        for (const n in t) t[n] === e && (t[n] = null);
      } else this._updateKey();
    }
  };
  cb = ((r) => (r[r.WEBGL = 1] = "WEBGL", r[r.WEBGPU = 2] = "WEBGPU", r[r.BOTH = 3] = "BOTH", r))(cb || {});
  dw = class extends Yi {
    constructor(e) {
      super(), this.uid = Qt("shader"), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
      let { gpuProgram: t, glProgram: n, groups: i, resources: a, compatibleRenderers: o, groupMap: s } = e;
      this.gpuProgram = t, this.glProgram = n, o === void 0 && (o = 0, t && (o |= cb.WEBGPU), n && (o |= cb.WEBGL)), this.compatibleRenderers = o;
      const l = {};
      if (!a && !i && (a = {}), a && i) throw new Error("[Shader] Cannot have both resources and groups");
      if (!t && i && !s) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      if (!t && i && s) for (const u in s) for (const c in s[u]) {
        const h = s[u][c];
        l[h] = {
          group: u,
          binding: c,
          name: h
        };
      }
      else if (t && i && !s) {
        const u = t.structsAndGroups.groups;
        s = {}, u.forEach((c) => {
          s[c.group] = s[c.group] || {}, s[c.group][c.binding] = c.name, l[c.name] = c;
        });
      } else if (a) {
        i = {}, s = {}, t && t.structsAndGroups.groups.forEach((h) => {
          s[h.group] = s[h.group] || {}, s[h.group][h.binding] = h.name, l[h.name] = h;
        });
        let u = 0;
        for (const c in a) l[c] || (i[99] || (i[99] = new Lp(), this._ownedBindGroups.push(i[99])), l[c] = {
          group: 99,
          binding: u,
          name: c
        }, s[99] = s[99] || {}, s[99][u] = c, u++);
        for (const c in a) {
          const h = c;
          let f = a[c];
          !f.source && !f._resourceType && (f = new CV(f));
          const d = l[h];
          d && (i[d.group] || (i[d.group] = new Lp(), this._ownedBindGroups.push(i[d.group])), i[d.group].setResource(f, d.binding));
        }
      }
      this.groups = i, this._uniformBindMap = s, this.resources = this._buildResourceAccessor(i, l);
    }
    addResource(e, t, n) {
      var i, a;
      (i = this._uniformBindMap)[t] || (i[t] = {}), (a = this._uniformBindMap[t])[n] || (a[n] = e), this.groups[t] || (this.groups[t] = new Lp(), this._ownedBindGroups.push(this.groups[t]));
    }
    _buildResourceAccessor(e, t) {
      const n = {};
      for (const i in t) {
        const a = t[i];
        Object.defineProperty(n, a.name, {
          get() {
            return e[a.group].getResource(a.binding);
          },
          set(o) {
            e[a.group].setResource(o, a.binding);
          }
        });
      }
      return n;
    }
    destroy(e = false) {
      var _a2, _b2;
      this.emit("destroy", this), e && ((_a2 = this.gpuProgram) == null ? void 0 : _a2.destroy(), (_b2 = this.glProgram) == null ? void 0 : _b2.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((t) => {
        t.destroy();
      }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
    }
    static from(e) {
      const { gpu: t, gl: n, ...i } = e;
      let a, o;
      return t && (a = Fg.from(t)), n && (o = _V.from(n)), new dw({
        gpuProgram: a,
        glProgram: o,
        ...i
      });
    }
  };
  const hb = [];
  Wn.handleByNamedList(Ct.Environment, hb);
  async function m_e(r) {
    if (!r) for (let e = 0; e < hb.length; e++) {
      const t = hb[e];
      if (t.value.test()) {
        await t.value.load();
        return;
      }
    }
  }
  let Cc;
  y_e = function() {
    if (typeof Cc == "boolean") return Cc;
    try {
      Cc = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
        a: "b"
      }, "a", "b") === true;
    } catch {
      Cc = false;
    }
    return Cc;
  };
  var Kd = {
    exports: {}
  }, rk;
  function x_e() {
    if (rk) return Kd.exports;
    rk = 1, Kd.exports = r, Kd.exports.default = r;
    function r(I, L, P) {
      P = P || 2;
      var O = L && L.length, F = O ? L[0] * P : I.length, B = e(I, 0, F, P, true), V = [];
      if (!B || B.next === B.prev) return V;
      var U, Y, q, me, Me, re, J;
      if (O && (B = l(I, L, B, P)), I.length > 80 * P) {
        U = q = I[0], Y = me = I[1];
        for (var le = P; le < F; le += P) Me = I[le], re = I[le + 1], Me < U && (U = Me), re < Y && (Y = re), Me > q && (q = Me), re > me && (me = re);
        J = Math.max(q - U, me - Y), J = J !== 0 ? 32767 / J : 0;
      }
      return n(B, V, P, U, Y, J, 0), V;
    }
    function e(I, L, P, O, F) {
      var B, V;
      if (F === N(I, L, P, O) > 0) for (B = L; B < P; B += O) V = E(B, I[B], I[B + 1], V);
      else for (B = P - O; B >= L; B -= O) V = E(B, I[B], I[B + 1], V);
      return V && _(V, V.next) && (k(V), V = V.next), V;
    }
    function t(I, L) {
      if (!I) return I;
      L || (L = I);
      var P = I, O;
      do
        if (O = false, !P.steiner && (_(P, P.next) || x(P.prev, P, P.next) === 0)) {
          if (k(P), P = L = P.prev, P === P.next) break;
          O = true;
        } else P = P.next;
      while (O || P !== L);
      return L;
    }
    function n(I, L, P, O, F, B, V) {
      if (I) {
        !V && B && d(I, O, F, B);
        for (var U = I, Y, q; I.prev !== I.next; ) {
          if (Y = I.prev, q = I.next, B ? a(I, O, F, B) : i(I)) {
            L.push(Y.i / P | 0), L.push(I.i / P | 0), L.push(q.i / P | 0), k(I), I = q.next, U = q.next;
            continue;
          }
          if (I = q, I === U) {
            V ? V === 1 ? (I = o(t(I), L, P), n(I, L, P, O, F, B, 2)) : V === 2 && s(I, L, P, O, F, B) : n(t(I), L, P, O, F, B, 1);
            break;
          }
        }
      }
    }
    function i(I) {
      var L = I.prev, P = I, O = I.next;
      if (x(L, P, O) >= 0) return false;
      for (var F = L.x, B = P.x, V = O.x, U = L.y, Y = P.y, q = O.y, me = F < B ? F < V ? F : V : B < V ? B : V, Me = U < Y ? U < q ? U : q : Y < q ? Y : q, re = F > B ? F > V ? F : V : B > V ? B : V, J = U > Y ? U > q ? U : q : Y > q ? Y : q, le = O.next; le !== L; ) {
        if (le.x >= me && le.x <= re && le.y >= Me && le.y <= J && m(F, U, B, Y, V, q, le.x, le.y) && x(le.prev, le, le.next) >= 0) return false;
        le = le.next;
      }
      return true;
    }
    function a(I, L, P, O) {
      var F = I.prev, B = I, V = I.next;
      if (x(F, B, V) >= 0) return false;
      for (var U = F.x, Y = B.x, q = V.x, me = F.y, Me = B.y, re = V.y, J = U < Y ? U < q ? U : q : Y < q ? Y : q, le = me < Me ? me < re ? me : re : Me < re ? Me : re, te = U > Y ? U > q ? U : q : Y > q ? Y : q, he = me > Me ? me > re ? me : re : Me > re ? Me : re, Xe = v(J, le, L, P, O), Fe = v(te, he, L, P, O), fe = I.prevZ, Se = I.nextZ; fe && fe.z >= Xe && Se && Se.z <= Fe; ) {
        if (fe.x >= J && fe.x <= te && fe.y >= le && fe.y <= he && fe !== F && fe !== V && m(U, me, Y, Me, q, re, fe.x, fe.y) && x(fe.prev, fe, fe.next) >= 0 || (fe = fe.prevZ, Se.x >= J && Se.x <= te && Se.y >= le && Se.y <= he && Se !== F && Se !== V && m(U, me, Y, Me, q, re, Se.x, Se.y) && x(Se.prev, Se, Se.next) >= 0)) return false;
        Se = Se.nextZ;
      }
      for (; fe && fe.z >= Xe; ) {
        if (fe.x >= J && fe.x <= te && fe.y >= le && fe.y <= he && fe !== F && fe !== V && m(U, me, Y, Me, q, re, fe.x, fe.y) && x(fe.prev, fe, fe.next) >= 0) return false;
        fe = fe.prevZ;
      }
      for (; Se && Se.z <= Fe; ) {
        if (Se.x >= J && Se.x <= te && Se.y >= le && Se.y <= he && Se !== F && Se !== V && m(U, me, Y, Me, q, re, Se.x, Se.y) && x(Se.prev, Se, Se.next) >= 0) return false;
        Se = Se.nextZ;
      }
      return true;
    }
    function o(I, L, P) {
      var O = I;
      do {
        var F = O.prev, B = O.next.next;
        !_(F, B) && S(F, O, O.next, B) && T(F, B) && T(B, F) && (L.push(F.i / P | 0), L.push(O.i / P | 0), L.push(B.i / P | 0), k(O), k(O.next), O = I = B), O = O.next;
      } while (O !== I);
      return t(O);
    }
    function s(I, L, P, O, F, B) {
      var V = I;
      do {
        for (var U = V.next.next; U !== V.prev; ) {
          if (V.i !== U.i && y(V, U)) {
            var Y = M(V, U);
            V = t(V, V.next), Y = t(Y, Y.next), n(V, L, P, O, F, B, 0), n(Y, L, P, O, F, B, 0);
            return;
          }
          U = U.next;
        }
        V = V.next;
      } while (V !== I);
    }
    function l(I, L, P, O) {
      var F = [], B, V, U, Y, q;
      for (B = 0, V = L.length; B < V; B++) U = L[B] * O, Y = B < V - 1 ? L[B + 1] * O : I.length, q = e(I, U, Y, O, false), q === q.next && (q.steiner = true), F.push(g(q));
      for (F.sort(u), B = 0; B < F.length; B++) P = c(F[B], P);
      return P;
    }
    function u(I, L) {
      return I.x - L.x;
    }
    function c(I, L) {
      var P = h(I, L);
      if (!P) return L;
      var O = M(P, I);
      return t(O, O.next), t(P, P.next);
    }
    function h(I, L) {
      var P = L, O = I.x, F = I.y, B = -1 / 0, V;
      do {
        if (F <= P.y && F >= P.next.y && P.next.y !== P.y) {
          var U = P.x + (F - P.y) * (P.next.x - P.x) / (P.next.y - P.y);
          if (U <= O && U > B && (B = U, V = P.x < P.next.x ? P : P.next, U === O)) return V;
        }
        P = P.next;
      } while (P !== L);
      if (!V) return null;
      var Y = V, q = V.x, me = V.y, Me = 1 / 0, re;
      P = V;
      do
        O >= P.x && P.x >= q && O !== P.x && m(F < me ? O : B, F, q, me, F < me ? B : O, F, P.x, P.y) && (re = Math.abs(F - P.y) / (O - P.x), T(P, I) && (re < Me || re === Me && (P.x > V.x || P.x === V.x && f(V, P))) && (V = P, Me = re)), P = P.next;
      while (P !== Y);
      return V;
    }
    function f(I, L) {
      return x(I.prev, I, L.prev) < 0 && x(L.next, I, I.next) < 0;
    }
    function d(I, L, P, O) {
      var F = I;
      do
        F.z === 0 && (F.z = v(F.x, F.y, L, P, O)), F.prevZ = F.prev, F.nextZ = F.next, F = F.next;
      while (F !== I);
      F.prevZ.nextZ = null, F.prevZ = null, p(F);
    }
    function p(I) {
      var L, P, O, F, B, V, U, Y, q = 1;
      do {
        for (P = I, I = null, B = null, V = 0; P; ) {
          for (V++, O = P, U = 0, L = 0; L < q && (U++, O = O.nextZ, !!O); L++) ;
          for (Y = q; U > 0 || Y > 0 && O; ) U !== 0 && (Y === 0 || !O || P.z <= O.z) ? (F = P, P = P.nextZ, U--) : (F = O, O = O.nextZ, Y--), B ? B.nextZ = F : I = F, F.prevZ = B, B = F;
          P = O;
        }
        B.nextZ = null, q *= 2;
      } while (V > 1);
      return I;
    }
    function v(I, L, P, O, F) {
      return I = (I - P) * F | 0, L = (L - O) * F | 0, I = (I | I << 8) & 16711935, I = (I | I << 4) & 252645135, I = (I | I << 2) & 858993459, I = (I | I << 1) & 1431655765, L = (L | L << 8) & 16711935, L = (L | L << 4) & 252645135, L = (L | L << 2) & 858993459, L = (L | L << 1) & 1431655765, I | L << 1;
    }
    function g(I) {
      var L = I, P = I;
      do
        (L.x < P.x || L.x === P.x && L.y < P.y) && (P = L), L = L.next;
      while (L !== I);
      return P;
    }
    function m(I, L, P, O, F, B, V, U) {
      return (F - V) * (L - U) >= (I - V) * (B - U) && (I - V) * (O - U) >= (P - V) * (L - U) && (P - V) * (B - U) >= (F - V) * (O - U);
    }
    function y(I, L) {
      return I.next.i !== L.i && I.prev.i !== L.i && !C(I, L) && (T(I, L) && T(L, I) && A(I, L) && (x(I.prev, I, L.prev) || x(I, L.prev, L)) || _(I, L) && x(I.prev, I, I.next) > 0 && x(L.prev, L, L.next) > 0);
    }
    function x(I, L, P) {
      return (L.y - I.y) * (P.x - L.x) - (L.x - I.x) * (P.y - L.y);
    }
    function _(I, L) {
      return I.x === L.x && I.y === L.y;
    }
    function S(I, L, P, O) {
      var F = w(x(I, L, P)), B = w(x(I, L, O)), V = w(x(P, O, I)), U = w(x(P, O, L));
      return !!(F !== B && V !== U || F === 0 && b(I, P, L) || B === 0 && b(I, O, L) || V === 0 && b(P, I, O) || U === 0 && b(P, L, O));
    }
    function b(I, L, P) {
      return L.x <= Math.max(I.x, P.x) && L.x >= Math.min(I.x, P.x) && L.y <= Math.max(I.y, P.y) && L.y >= Math.min(I.y, P.y);
    }
    function w(I) {
      return I > 0 ? 1 : I < 0 ? -1 : 0;
    }
    function C(I, L) {
      var P = I;
      do {
        if (P.i !== I.i && P.next.i !== I.i && P.i !== L.i && P.next.i !== L.i && S(P, P.next, I, L)) return true;
        P = P.next;
      } while (P !== I);
      return false;
    }
    function T(I, L) {
      return x(I.prev, I, I.next) < 0 ? x(I, L, I.next) >= 0 && x(I, I.prev, L) >= 0 : x(I, L, I.prev) < 0 || x(I, I.next, L) < 0;
    }
    function A(I, L) {
      var P = I, O = false, F = (I.x + L.x) / 2, B = (I.y + L.y) / 2;
      do
        P.y > B != P.next.y > B && P.next.y !== P.y && F < (P.next.x - P.x) * (B - P.y) / (P.next.y - P.y) + P.x && (O = !O), P = P.next;
      while (P !== I);
      return O;
    }
    function M(I, L) {
      var P = new R(I.i, I.x, I.y), O = new R(L.i, L.x, L.y), F = I.next, B = L.prev;
      return I.next = L, L.prev = I, P.next = F, F.prev = P, O.next = P, P.prev = O, B.next = O, O.prev = B, O;
    }
    function E(I, L, P, O) {
      var F = new R(I, L, P);
      return O ? (F.next = O.next, F.prev = O, O.next.prev = F, O.next = F) : (F.prev = F, F.next = F), F;
    }
    function k(I) {
      I.next.prev = I.prev, I.prev.next = I.next, I.prevZ && (I.prevZ.nextZ = I.nextZ), I.nextZ && (I.nextZ.prevZ = I.prevZ);
    }
    function R(I, L, P) {
      this.i = I, this.x = L, this.y = P, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    r.deviation = function(I, L, P, O) {
      var F = L && L.length, B = F ? L[0] * P : I.length, V = Math.abs(N(I, 0, B, P));
      if (F) for (var U = 0, Y = L.length; U < Y; U++) {
        var q = L[U] * P, me = U < Y - 1 ? L[U + 1] * P : I.length;
        V -= Math.abs(N(I, q, me, P));
      }
      var Me = 0;
      for (U = 0; U < O.length; U += 3) {
        var re = O[U] * P, J = O[U + 1] * P, le = O[U + 2] * P;
        Me += Math.abs((I[re] - I[le]) * (I[J + 1] - I[re + 1]) - (I[re] - I[J]) * (I[le + 1] - I[re + 1]));
      }
      return V === 0 && Me === 0 ? 0 : Math.abs((Me - V) / V);
    };
    function N(I, L, P, O) {
      for (var F = 0, B = L, V = P - O; B < P; B += O) F += (I[V] - I[B]) * (I[B + 1] + I[V + 1]), V = B;
      return F;
    }
    return r.flatten = function(I) {
      for (var L = I[0][0].length, P = {
        vertices: [],
        holes: [],
        dimensions: L
      }, O = 0, F = 0; F < I.length; F++) {
        for (var B = 0; B < I[F].length; B++) for (var V = 0; V < L; V++) P.vertices.push(I[F][B][V]);
        F > 0 && (O += I[F - 1].length, P.holes.push(O));
      }
      return P;
    }, Kd.exports;
  }
  var __e = x_e();
  const b_e = zb(__e);
  TV = ((r) => (r[r.NONE = 0] = "NONE", r[r.COLOR = 16384] = "COLOR", r[r.STENCIL = 1024] = "STENCIL", r[r.DEPTH = 256] = "DEPTH", r[r.COLOR_DEPTH = 16640] = "COLOR_DEPTH", r[r.COLOR_STENCIL = 17408] = "COLOR_STENCIL", r[r.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", r[r.ALL = 17664] = "ALL", r))(TV || {});
  S_e = class {
    constructor(e) {
      this.items = [], this._name = e;
    }
    emit(e, t, n, i, a, o, s, l) {
      const { name: u, items: c } = this;
      for (let h = 0, f = c.length; h < f; h++) c[h][u](e, t, n, i, a, o, s, l);
      return this;
    }
    add(e) {
      return e[this._name] && (this.remove(e), this.items.push(e)), this;
    }
    remove(e) {
      const t = this.items.indexOf(e);
      return t !== -1 && this.items.splice(t, 1), this;
    }
    contains(e) {
      return this.items.indexOf(e) !== -1;
    }
    removeAll() {
      return this.items.length = 0, this;
    }
    destroy() {
      this.removeAll(), this.items = null, this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  };
  const w_e = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "resetState",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender"
  ], AV = class IV extends Yi {
    constructor(e) {
      super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = e.type, this.name = e.name, this.config = e;
      const t = [
        ...w_e,
        ...this.config.runners ?? []
      ];
      this._addRunners(...t), this._unsafeEvalCheck();
    }
    async init(e = {}) {
      const t = e.skipExtensionImports === true ? true : e.manageImports === false;
      await m_e(t), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (const n in this._systemsHash) e = {
        ...this._systemsHash[n].constructor.defaultOptions,
        ...e
      };
      e = {
        ...IV.defaultOptions,
        ...e
      }, this._roundPixels = e.roundPixels ? 1 : 0;
      for (let n = 0; n < this.runners.init.items.length; n++) await this.runners.init.items[n].init(e);
      this._initOptions = e;
    }
    render(e, t) {
      let n = e;
      if (n instanceof al && (n = {
        container: n
      }, t && (Pt($t, "passing a second argument is deprecated, please use render options instead"), n.target = t.renderTexture)), n.target || (n.target = this.view.renderTarget), n.target === this.view.renderTarget && (this._lastObjectRendered = n.container, n.clearColor ?? (n.clearColor = this.background.colorRgba), n.clear ?? (n.clear = this.background.clearBeforeRender)), n.clearColor) {
        const i = Array.isArray(n.clearColor) && n.clearColor.length === 4;
        n.clearColor = i ? n.clearColor : kr.shared.setValue(n.clearColor).toArray();
      }
      n.transform || (n.container.updateLocalTransform(), n.transform = n.container.localTransform), n.container.enableRenderGroup(), this.runners.prerender.emit(n), this.runners.renderStart.emit(n), this.runners.render.emit(n), this.runners.renderEnd.emit(n), this.runners.postrender.emit(n);
    }
    resize(e, t, n) {
      const i = this.view.resolution;
      this.view.resize(e, t, n), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), n !== void 0 && n !== i && this.runners.resolutionChange.emit(n);
    }
    clear(e = {}) {
      const t = this;
      e.target || (e.target = t.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ?? (e.clear = TV.ALL);
      const { clear: n, clearColor: i, target: a } = e;
      kr.shared.setValue(i ?? this.background.colorRgba), t.renderTarget.clear(a, n, kr.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(e) {
      this.view.resolution = e, this.runners.resolutionChange.emit(e);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      return this.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...e) {
      e.forEach((t) => {
        this.runners[t] = new S_e(t);
      });
    }
    _addSystems(e) {
      let t;
      for (t in e) {
        const n = e[t];
        this._addSystem(n.value, n.name);
      }
    }
    _addSystem(e, t) {
      const n = new e(this);
      if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
      this[t] = n, this._systemsHash[t] = n;
      for (const i in this.runners) this.runners[i].add(n);
      return this;
    }
    _addPipes(e, t) {
      const n = t.reduce((i, a) => (i[a.name] = a.value, i), {});
      e.forEach((i) => {
        const a = i.value, o = i.name, s = n[o];
        this.renderPipes[o] = new a(this, s ? new s() : null);
      });
    }
    destroy(e = false) {
      this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), Object.values(this.runners).forEach((t) => {
        t.destroy();
      }), this._systemsHash = null, this.renderPipes = null;
    }
    generateTexture(e) {
      return this.textureGenerator.generateTexture(e);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!y_e()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
    resetState() {
      this.runners.resetState.emit();
    }
  };
  AV.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: false,
    roundPixels: false
  };
  let Zd;
  MV = AV;
  function C_e(r) {
    return Zd !== void 0 || (Zd = (() => {
      var _a2;
      const e = {
        stencil: true,
        failIfMajorPerformanceCaveat: r ?? MV.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!oi.get().getWebGLRenderingContext()) return false;
        let n = oi.get().createCanvas().getContext("webgl", e);
        const i = !!((_a2 = n == null ? void 0 : n.getContextAttributes()) == null ? void 0 : _a2.stencil);
        if (n) {
          const a = n.getExtension("WEBGL_lose_context");
          a && a.loseContext();
        }
        return n = null, i;
      } catch {
        return false;
      }
    })()), Zd;
  }
  let jd;
  async function T_e(r = {}) {
    return jd !== void 0 || (jd = await (async () => {
      const e = oi.get().getNavigator().gpu;
      if (!e) return false;
      try {
        return await (await e.requestAdapter(r)).requestDevice(), true;
      } catch {
        return false;
      }
    })()), jd;
  }
  const nk = [
    "webgl",
    "webgpu",
    "canvas"
  ];
  async function A_e(r) {
    let e = [];
    r.preference ? (e.push(r.preference), nk.forEach((a) => {
      a !== r.preference && e.push(a);
    })) : e = nk.slice();
    let t, n = {};
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      if (o === "webgpu" && await T_e()) {
        const { WebGPURenderer: s } = await ou(async () => {
          const { WebGPURenderer: l } = await import("./WebGPURenderer-BMk906eM.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            WebGPURenderer: l
          };
        }, __vite__mapDeps([7,2,8,3,4,5,6]));
        t = s, n = {
          ...r,
          ...r.webgpu
        };
        break;
      } else if (o === "webgl" && C_e(r.failIfMajorPerformanceCaveat ?? MV.defaultOptions.failIfMajorPerformanceCaveat)) {
        const { WebGLRenderer: s } = await ou(async () => {
          const { WebGLRenderer: l } = await import("./WebGLRenderer-BKxAD3Yx.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            WebGLRenderer: l
          };
        }, __vite__mapDeps([9,2,8,4,5,6]));
        t = s, n = {
          ...r,
          ...r.webgl
        };
        break;
      } else if (o === "canvas") throw n = {
        ...r
      }, new Error("CanvasRenderer is not yet implemented");
    }
    if (delete n.webgpu, delete n.webgl, !t) throw new Error("No available renderer for the current environment");
    const i = new t();
    return await i.init(n), i;
  }
  DV = "8.9.1";
  class PV {
    static init() {
      var _a2;
      (_a2 = globalThis.__PIXI_APP_INIT__) == null ? void 0 : _a2.call(globalThis, this, DV);
    }
    static destroy() {
    }
  }
  PV.extension = Ct.Application;
  I_e = class {
    constructor(e) {
      this._renderer = e;
    }
    init() {
      var _a2;
      (_a2 = globalThis.__PIXI_RENDERER_INIT__) == null ? void 0 : _a2.call(globalThis, this._renderer, DV);
    }
    destroy() {
      this._renderer = null;
    }
  };
  I_e.extension = {
    type: [
      Ct.WebGLSystem,
      Ct.WebGPUSystem
    ],
    name: "initHook",
    priority: -10
  };
  const kV = class fb {
    constructor(...e) {
      this.stage = new al(), e[0] !== void 0 && Pt($t, "Application constructor options are deprecated, please use Application.init() instead.");
    }
    async init(e) {
      e = {
        ...e
      }, this.renderer = await A_e(e), fb._plugins.forEach((t) => {
        t.init.call(this, e);
      });
    }
    render() {
      this.renderer.render({
        container: this.stage
      });
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      return Pt($t, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(e = false, t = false) {
      const n = fb._plugins.slice(0);
      n.reverse(), n.forEach((i) => {
        i.destroy.call(this);
      }), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null;
    }
  };
  kV._plugins = [];
  let LV = kV;
  Wn.handleByList(Ct.Application, LV._plugins);
  Wn.add(PV);
  const ik = [
    {
      offset: 0,
      color: "white"
    },
    {
      offset: 1,
      color: "black"
    }
  ], pw = class db {
    constructor(...e) {
      this.uid = Qt("fillGradient"), this.type = "linear", this.colorStops = [];
      let t = M_e(e);
      t = {
        ...t.type === "radial" ? db.defaultRadialOptions : db.defaultLinearOptions,
        ...Gz(t)
      }, this._textureSize = t.textureSize, t.type === "radial" ? (this.center = t.center, this.outerCenter = t.outerCenter ?? this.center, this.innerRadius = t.innerRadius, this.outerRadius = t.outerRadius, this.scale = t.scale, this.rotation = t.rotation) : (this.start = t.start, this.end = t.end), this.textureSpace = t.textureSpace, this.type = t.type, t.colorStops.forEach((i) => {
        this.addColorStop(i.offset, i.color);
      });
    }
    addColorStop(e, t) {
      return this.colorStops.push({
        offset: e,
        color: kr.shared.setValue(t).toHexa()
      }), this;
    }
    buildLinearGradient() {
      if (this.texture) return;
      const e = this.colorStops.length ? this.colorStops : ik, t = this._textureSize, { canvas: n, context: i } = ok(t, 1), a = i.createLinearGradient(0, 0, this._textureSize, 0);
      ak(a, e), i.fillStyle = a, i.fillRect(0, 0, t, 1), this.texture = new At({
        source: new Ov({
          resource: n
        })
      });
      const { x: o, y: s } = this.start, { x: l, y: u } = this.end, c = new pt(), h = l - o, f = u - s, d = Math.sqrt(h * h + f * f), p = Math.atan2(f, h);
      c.scale(d / t, 1), c.rotate(p), c.translate(o, s), this.textureSpace === "local" && c.scale(t, t), this.transform = c;
    }
    buildGradient() {
      this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
    }
    buildRadialGradient() {
      if (this.texture) return;
      const e = this.colorStops.length ? this.colorStops : ik, t = this._textureSize, { canvas: n, context: i } = ok(t, t), { x: a, y: o } = this.center, { x: s, y: l } = this.outerCenter, u = this.innerRadius, c = this.outerRadius, h = s - c, f = l - c, d = t / (c * 2), p = (a - h) * d, v = (o - f) * d, g = i.createRadialGradient(p, v, u * d, (s - h) * d, (l - f) * d, c * d);
      ak(g, e), i.fillStyle = e[e.length - 1].color, i.fillRect(0, 0, t, t), i.fillStyle = g, i.translate(p, v), i.rotate(this.rotation), i.scale(1, this.scale), i.translate(-p, -v), i.fillRect(0, 0, t, t), this.texture = new At({
        source: new Ov({
          resource: n,
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        })
      });
      const m = new pt();
      m.scale(1 / d, 1 / d), m.translate(h, f), this.textureSpace === "local" && m.scale(t, t), this.transform = m;
    }
    get styleKey() {
      return this.uid;
    }
    destroy() {
      var _a2;
      (_a2 = this.texture) == null ? void 0 : _a2.destroy(true), this.texture = null;
    }
  };
  pw.defaultLinearOptions = {
    start: {
      x: 0,
      y: 0
    },
    end: {
      x: 0,
      y: 1
    },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256
  };
  pw.defaultRadialOptions = {
    center: {
      x: 0.5,
      y: 0.5
    },
    innerRadius: 0,
    outerRadius: 0.5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256
  };
  Hs = pw;
  function ak(r, e) {
    for (let t = 0; t < e.length; t++) {
      const n = e[t];
      r.addColorStop(n.offset, n.color);
    }
  }
  function ok(r, e) {
    const t = oi.get().createCanvas(r, e), n = t.getContext("2d");
    return {
      canvas: t,
      context: n
    };
  }
  function M_e(r) {
    let e = r[0] ?? {};
    return (typeof e == "number" || r[1]) && (Pt("8.5.2", "use options object instead"), e = {
      type: "linear",
      start: {
        x: r[0],
        y: r[1]
      },
      end: {
        x: r[2],
        y: r[3]
      },
      textureSpace: r[4],
      textureSize: r[5] ?? Hs.defaultLinearOptions.textureSize
    }), e;
  }
  const sk = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  vw = class {
    constructor(e, t) {
      this.uid = Qt("fillPattern"), this.transform = new pt(), this._styleKey = null, this.texture = e, this.transform.scale(1 / e.frame.width, 1 / e.frame.height), t && (e.source.style.addressModeU = sk[t].addressModeU, e.source.style.addressModeV = sk[t].addressModeV);
    }
    setTransform(e) {
      const t = this.texture;
      this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(1 / t.frame.width, 1 / t.frame.height), this._styleKey = null;
    }
    get styleKey() {
      return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
    }
  };
  var F0, lk;
  function D_e() {
    if (lk) return F0;
    lk = 1, F0 = t;
    var r = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    }, e = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function t(a) {
      var o = [];
      return a.replace(e, function(s, l, u) {
        var c = l.toLowerCase();
        for (u = i(u), c == "m" && u.length > 2 && (o.push([
          l
        ].concat(u.splice(0, 2))), c = "l", l = l == "m" ? "l" : "L"); ; ) {
          if (u.length == r[c]) return u.unshift(l), o.push(u);
          if (u.length < r[c]) throw new Error("malformed path data");
          o.push([
            l
          ].concat(u.splice(0, r[c])));
        }
      }), o;
    }
    var n = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function i(a) {
      var o = a.match(n);
      return o ? o.map(Number) : [];
    }
    return F0;
  }
  var P_e = D_e();
  const k_e = zb(P_e);
  function L_e(r, e) {
    const t = k_e(r), n = [];
    let i = null, a = 0, o = 0;
    for (let s = 0; s < t.length; s++) {
      const l = t[s], u = l[0], c = l;
      switch (u) {
        case "M":
          a = c[1], o = c[2], e.moveTo(a, o);
          break;
        case "m":
          a += c[1], o += c[2], e.moveTo(a, o);
          break;
        case "H":
          a = c[1], e.lineTo(a, o);
          break;
        case "h":
          a += c[1], e.lineTo(a, o);
          break;
        case "V":
          o = c[1], e.lineTo(a, o);
          break;
        case "v":
          o += c[1], e.lineTo(a, o);
          break;
        case "L":
          a = c[1], o = c[2], e.lineTo(a, o);
          break;
        case "l":
          a += c[1], o += c[2], e.lineTo(a, o);
          break;
        case "C":
          a = c[5], o = c[6], e.bezierCurveTo(c[1], c[2], c[3], c[4], a, o);
          break;
        case "c":
          e.bezierCurveTo(a + c[1], o + c[2], a + c[3], o + c[4], a + c[5], o + c[6]), a += c[5], o += c[6];
          break;
        case "S":
          a = c[3], o = c[4], e.bezierCurveToShort(c[1], c[2], a, o);
          break;
        case "s":
          e.bezierCurveToShort(a + c[1], o + c[2], a + c[3], o + c[4]), a += c[3], o += c[4];
          break;
        case "Q":
          a = c[3], o = c[4], e.quadraticCurveTo(c[1], c[2], a, o);
          break;
        case "q":
          e.quadraticCurveTo(a + c[1], o + c[2], a + c[3], o + c[4]), a += c[3], o += c[4];
          break;
        case "T":
          a = c[1], o = c[2], e.quadraticCurveToShort(a, o);
          break;
        case "t":
          a += c[1], o += c[2], e.quadraticCurveToShort(a, o);
          break;
        case "A":
          a = c[6], o = c[7], e.arcToSvg(c[1], c[2], c[3], c[4], c[5], a, o);
          break;
        case "a":
          a += c[6], o += c[7], e.arcToSvg(c[1], c[2], c[3], c[4], c[5], a, o);
          break;
        case "Z":
        case "z":
          e.closePath(), n.length > 0 && (i = n.pop(), i ? (a = i.startX, o = i.startY) : (a = 0, o = 0)), i = null;
          break;
        default:
          mn(`Unknown SVG path command: ${u}`);
      }
      u !== "Z" && u !== "z" && i === null && (i = {
        startX: a,
        startY: o
      }, n.push(i));
    }
    return e;
  }
  class gw {
    constructor(e = 0, t = 0, n = 0) {
      this.type = "circle", this.x = e, this.y = t, this.radius = n;
    }
    clone() {
      return new gw(this.x, this.y, this.radius);
    }
    contains(e, t) {
      if (this.radius <= 0) return false;
      const n = this.radius * this.radius;
      let i = this.x - e, a = this.y - t;
      return i *= i, a *= a, i + a <= n;
    }
    strokeContains(e, t, n, i = 0.5) {
      if (this.radius === 0) return false;
      const a = this.x - e, o = this.y - t, s = this.radius, l = (1 - i) * n, u = Math.sqrt(a * a + o * o);
      return u <= s + l && u > s - (n - l);
    }
    getBounds(e) {
      return e || (e = new gr()), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.radius = e.radius, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  }
  class mw {
    constructor(e = 0, t = 0, n = 0, i = 0) {
      this.type = "ellipse", this.x = e, this.y = t, this.halfWidth = n, this.halfHeight = i;
    }
    clone() {
      return new mw(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(e, t) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;
      let n = (e - this.x) / this.halfWidth, i = (t - this.y) / this.halfHeight;
      return n *= n, i *= i, n + i <= 1;
    }
    strokeContains(e, t, n, i = 0.5) {
      const { halfWidth: a, halfHeight: o } = this;
      if (a <= 0 || o <= 0) return false;
      const s = n * (1 - i), l = n - s, u = a - l, c = o - l, h = a + s, f = o + s, d = e - this.x, p = t - this.y, v = d * d / (u * u) + p * p / (c * c), g = d * d / (h * h) + p * p / (f * f);
      return v > 1 && g <= 1;
    }
    getBounds(e) {
      return e || (e = new gr()), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  }
  function R_e(r, e, t, n, i, a) {
    const o = r - t, s = e - n, l = i - t, u = a - n, c = o * l + s * u, h = l * l + u * u;
    let f = -1;
    h !== 0 && (f = c / h);
    let d, p;
    f < 0 ? (d = t, p = n) : f > 1 ? (d = i, p = a) : (d = t + f * l, p = n + f * u);
    const v = r - d, g = e - p;
    return v * v + g * g;
  }
  let E_e, N_e;
  class hh {
    constructor(...e) {
      this.type = "polygon";
      let t = Array.isArray(e[0]) ? e[0] : e;
      if (typeof t[0] != "number") {
        const n = [];
        for (let i = 0, a = t.length; i < a; i++) n.push(t[i].x, t[i].y);
        t = n;
      }
      this.points = t, this.closePath = true;
    }
    isClockwise() {
      let e = 0;
      const t = this.points, n = t.length;
      for (let i = 0; i < n; i += 2) {
        const a = t[i], o = t[i + 1], s = t[(i + 2) % n], l = t[(i + 3) % n];
        e += (s - a) * (l + o);
      }
      return e < 0;
    }
    containsPolygon(e) {
      const t = this.getBounds(E_e), n = e.getBounds(N_e);
      if (!t.containsRect(n)) return false;
      const i = e.points;
      for (let a = 0; a < i.length; a += 2) {
        const o = i[a], s = i[a + 1];
        if (!this.contains(o, s)) return false;
      }
      return true;
    }
    clone() {
      const e = this.points.slice(), t = new hh(e);
      return t.closePath = this.closePath, t;
    }
    contains(e, t) {
      let n = false;
      const i = this.points.length / 2;
      for (let a = 0, o = i - 1; a < i; o = a++) {
        const s = this.points[a * 2], l = this.points[a * 2 + 1], u = this.points[o * 2], c = this.points[o * 2 + 1];
        l > t != c > t && e < (u - s) * ((t - l) / (c - l)) + s && (n = !n);
      }
      return n;
    }
    strokeContains(e, t, n, i = 0.5) {
      const a = n * n, o = a * (1 - i), s = a - o, { points: l } = this, u = l.length - (this.closePath ? 0 : 2);
      for (let c = 0; c < u; c += 2) {
        const h = l[c], f = l[c + 1], d = l[(c + 2) % l.length], p = l[(c + 3) % l.length], v = R_e(e, t, h, f, d, p), g = Math.sign((d - h) * (t - f) - (p - f) * (e - h));
        if (v <= (g < 0 ? s : o)) return true;
      }
      return false;
    }
    getBounds(e) {
      e || (e = new gr());
      const t = this.points;
      let n = 1 / 0, i = -1 / 0, a = 1 / 0, o = -1 / 0;
      for (let s = 0, l = t.length; s < l; s += 2) {
        const u = t[s], c = t[s + 1];
        n = u < n ? u : n, i = u > i ? u : i, a = c < a ? c : a, o = c > o ? c : o;
      }
      return e.x = n, e.width = i - n, e.y = a, e.height = o - a, e;
    }
    copyFrom(e) {
      return this.points = e.points.slice(), this.closePath = e.closePath, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, t) => `${e}, ${t}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      return this.points[this.points.length - 2];
    }
    get y() {
      return this.points[this.points.length - 1];
    }
  }
  const Qd = (r, e, t, n, i, a, o) => {
    const s = r - t, l = e - n, u = Math.sqrt(s * s + l * l);
    return u >= i - a && u <= i + o;
  };
  class yw {
    constructor(e = 0, t = 0, n = 0, i = 0, a = 20) {
      this.type = "roundedRectangle", this.x = e, this.y = t, this.width = n, this.height = i, this.radius = a;
    }
    getBounds(e) {
      return e || (e = new gr()), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
    }
    clone() {
      return new yw(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    contains(e, t) {
      if (this.width <= 0 || this.height <= 0) return false;
      if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
        const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (t >= this.y + n && t <= this.y + this.height - n || e >= this.x + n && e <= this.x + this.width - n) return true;
        let i = e - (this.x + n), a = t - (this.y + n);
        const o = n * n;
        if (i * i + a * a <= o || (i = e - (this.x + this.width - n), i * i + a * a <= o) || (a = t - (this.y + this.height - n), i * i + a * a <= o) || (i = e - (this.x + n), i * i + a * a <= o)) return true;
      }
      return false;
    }
    strokeContains(e, t, n, i = 0.5) {
      const { x: a, y: o, width: s, height: l, radius: u } = this, c = n * (1 - i), h = n - c, f = a + u, d = o + u, p = s - u * 2, v = l - u * 2, g = a + s, m = o + l;
      return (e >= a - c && e <= a + h || e >= g - h && e <= g + c) && t >= d && t <= d + v || (t >= o - c && t <= o + h || t >= m - h && t <= m + c) && e >= f && e <= f + p ? true : e < f && t < d && Qd(e, t, f, d, u, h, c) || e > g - u && t < d && Qd(e, t, g - u, d, u, h, c) || e > g - u && t > m - u && Qd(e, t, g - u, m - u, u, h, c) || e < f && t > m - u && Qd(e, t, f, m - u, u, h, c);
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }
  const O_e = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join(`
`);
  function F_e(r) {
    let e = "";
    for (let t = 0; t < r; ++t) t > 0 && (e += `
else `), t < r - 1 && (e += `if(test == ${t}.0){}`);
    return e;
  }
  function B_e(r, e) {
    if (r === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const t = e.createShader(e.FRAGMENT_SHADER);
    try {
      for (; ; ) {
        const n = O_e.replace(/%forloop%/gi, F_e(r));
        if (e.shaderSource(t, n), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS)) r = r / 2 | 0;
        else break;
      }
    } finally {
      e.deleteShader(t);
    }
    return r;
  }
  let Rl = null;
  RV = function() {
    var _a2;
    if (Rl) return Rl;
    const r = yV();
    return Rl = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), Rl = B_e(Rl, r), (_a2 = r.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), Rl;
  };
  const EV = {};
  z_e = function(r, e) {
    let t = 2166136261;
    for (let n = 0; n < e; n++) t ^= r[n].uid, t = Math.imul(t, 16777619), t >>>= 0;
    return EV[t] || V_e(r, e, t);
  };
  let B0 = 0;
  function V_e(r, e, t) {
    const n = {};
    let i = 0;
    B0 || (B0 = RV());
    for (let o = 0; o < B0; o++) {
      const s = o < e ? r[o] : At.EMPTY.source;
      n[i++] = s.source, n[i++] = s.style;
    }
    const a = new Lp(n);
    return EV[t] = a, a;
  }
  uk = class {
    constructor(e) {
      typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
    }
    get int8View() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    }
    get uint8View() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    }
    get int16View() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    }
    get int32View() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    }
    get float64View() {
      return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
    }
    get bigUint64View() {
      return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
    }
    view(e) {
      return this[`${e}View`];
    }
    destroy() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }
    static sizeOf(e) {
      switch (e) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${e} isn't a valid view type`);
      }
    }
  };
  ck = function(r, e) {
    const t = r.byteLength / 8 | 0, n = new Float64Array(r, 0, t);
    new Float64Array(e, 0, t).set(n);
    const a = r.byteLength - t * 8;
    if (a > 0) {
      const o = new Uint8Array(r, t * 8, a);
      new Uint8Array(e, t * 8, a).set(o);
    }
  };
  const $_e = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  G_e = ((r) => (r[r.DISABLED = 0] = "DISABLED", r[r.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", r[r.MASK_ACTIVE = 2] = "MASK_ACTIVE", r[r.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", r[r.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", r[r.NONE = 5] = "NONE", r))(G_e || {});
  hk = function(r, e) {
    return e.alphaMode === "no-premultiply-alpha" && $_e[r] || r;
  };
  class W_e {
    constructor() {
      this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
    }
    clear() {
      for (let e = 0; e < this.count; e++) {
        const t = this.textures[e];
        this.textures[e] = null, this.ids[t.uid] = null;
      }
      this.count = 0;
    }
  }
  class U_e {
    constructor() {
      this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new W_e(), this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = true;
    }
    destroy() {
      this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
    }
  }
  const NV = [];
  let pb = 0;
  function fk() {
    return pb > 0 ? NV[--pb] : new U_e();
  }
  function dk(r) {
    NV[pb++] = r;
  }
  let Tc = 0;
  const OV = class Rp {
    constructor(e = {}) {
      this.uid = Qt("batcher"), this.dirty = true, this.batchIndex = 0, this.batches = [], this._elements = [], Rp.defaultOptions.maxTextures = Rp.defaultOptions.maxTextures ?? RV(), e = {
        ...Rp.defaultOptions,
        ...e
      };
      const { maxTextures: t, attributesInitialSize: n, indicesInitialSize: i } = e;
      this.attributeBuffer = new uk(n * 4), this.indexBuffer = new Uint16Array(i), this.maxTextures = t;
    }
    begin() {
      this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
      for (let e = 0; e < this.batchIndex; e++) dk(this.batches[e]);
      this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = true;
    }
    add(e) {
      this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize;
    }
    checkAndUpdateTexture(e, t) {
      const n = e._batch.textures.ids[t._source.uid];
      return !n && n !== 0 ? false : (e._textureId = n, e.texture = t, true);
    }
    updateElement(e) {
      this.dirty = true;
      const t = this.attributeBuffer;
      e.packAsQuad ? this.packQuadAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId);
    }
    break(e) {
      const t = this._elements;
      if (!t[this.elementStart]) return;
      let n = fk(), i = n.textures;
      i.clear();
      const a = t[this.elementStart];
      let o = hk(a.blendMode, a.texture._source), s = a.topology;
      this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
      const l = this.attributeBuffer.float32View, u = this.attributeBuffer.uint32View, c = this.indexBuffer;
      let h = this._batchIndexSize, f = this._batchIndexStart, d = "startBatch";
      const p = this.maxTextures;
      for (let v = this.elementStart; v < this.elementSize; ++v) {
        const g = t[v];
        t[v] = null;
        const y = g.texture._source, x = hk(g.blendMode, y), _ = o !== x || s !== g.topology;
        if (y._batchTick === Tc && !_) {
          g._textureId = y._textureBindLocation, h += g.indexSize, g.packAsQuad ? (this.packQuadAttributes(g, l, u, g._attributeStart, g._textureId), this.packQuadIndex(c, g._indexStart, g._attributeStart / this.vertexSize)) : (this.packAttributes(g, l, u, g._attributeStart, g._textureId), this.packIndex(g, c, g._indexStart, g._attributeStart / this.vertexSize)), g._batch = n;
          continue;
        }
        y._batchTick = Tc, (i.count >= p || _) && (this._finishBatch(n, f, h - f, i, o, s, e, d), d = "renderBatch", f = h, o = x, s = g.topology, n = fk(), i = n.textures, i.clear(), ++Tc), g._textureId = y._textureBindLocation = i.count, i.ids[y.uid] = i.count, i.textures[i.count++] = y, g._batch = n, h += g.indexSize, g.packAsQuad ? (this.packQuadAttributes(g, l, u, g._attributeStart, g._textureId), this.packQuadIndex(c, g._indexStart, g._attributeStart / this.vertexSize)) : (this.packAttributes(g, l, u, g._attributeStart, g._textureId), this.packIndex(g, c, g._indexStart, g._attributeStart / this.vertexSize));
      }
      i.count > 0 && (this._finishBatch(n, f, h - f, i, o, s, e, d), f = h, ++Tc), this.elementStart = this.elementSize, this._batchIndexStart = f, this._batchIndexSize = h;
    }
    _finishBatch(e, t, n, i, a, o, s, l) {
      e.gpuBindGroup = null, e.bindGroup = null, e.action = l, e.batcher = this, e.textures = i, e.blendMode = a, e.topology = o, e.start = t, e.size = n, ++Tc, this.batches[this.batchIndex++] = e, s.add(e);
    }
    finish(e) {
      this.break(e);
    }
    ensureAttributeBuffer(e) {
      e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4);
    }
    ensureIndexBuffer(e) {
      e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
    }
    _resizeAttributeBuffer(e) {
      const t = Math.max(e, this.attributeBuffer.size * 2), n = new uk(t);
      ck(this.attributeBuffer.rawBinaryData, n.rawBinaryData), this.attributeBuffer = n;
    }
    _resizeIndexBuffer(e) {
      const t = this.indexBuffer;
      let n = Math.max(e, t.length * 1.5);
      n += n % 2;
      const i = n > 65535 ? new Uint32Array(n) : new Uint16Array(n);
      if (i.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT) for (let a = 0; a < t.length; a++) i[a] = t[a];
      else ck(t.buffer, i.buffer);
      this.indexBuffer = i;
    }
    packQuadIndex(e, t, n) {
      e[t] = n + 0, e[t + 1] = n + 1, e[t + 2] = n + 2, e[t + 3] = n + 0, e[t + 4] = n + 2, e[t + 5] = n + 3;
    }
    packIndex(e, t, n, i) {
      const a = e.indices, o = e.indexSize, s = e.indexOffset, l = e.attributeOffset;
      for (let u = 0; u < o; u++) t[n++] = i + a[u + s] - l;
    }
    destroy() {
      for (let e = 0; e < this.batches.length; e++) dk(this.batches[e]);
      this.batches = null;
      for (let e = 0; e < this._elements.length; e++) this._elements[e]._batch = null;
      this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
    }
  };
  OV.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6
  };
  let H_e = OV;
  rn = ((r) => (r[r.MAP_READ = 1] = "MAP_READ", r[r.MAP_WRITE = 2] = "MAP_WRITE", r[r.COPY_SRC = 4] = "COPY_SRC", r[r.COPY_DST = 8] = "COPY_DST", r[r.INDEX = 16] = "INDEX", r[r.VERTEX = 32] = "VERTEX", r[r.UNIFORM = 64] = "UNIFORM", r[r.STORAGE = 128] = "STORAGE", r[r.INDIRECT = 256] = "INDIRECT", r[r.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", r[r.STATIC = 1024] = "STATIC", r))(rn || {});
  tf = class extends Yi {
    constructor(e) {
      let { data: t, size: n } = e;
      const { usage: i, label: a, shrinkToFit: o } = e;
      super(), this.uid = Qt("buffer"), this._resourceType = "buffer", this._resourceId = Qt("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = true, this.destroyed = false, t instanceof Array && (t = new Float32Array(t)), this._data = t, n ?? (n = t == null ? void 0 : t.byteLength);
      const s = !!t;
      this.descriptor = {
        size: n,
        usage: i,
        mappedAtCreation: s,
        label: a
      }, this.shrinkToFit = o ?? true;
    }
    get data() {
      return this._data;
    }
    set data(e) {
      this.setDataWithSize(e, e.length, true);
    }
    get dataInt32() {
      return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
    }
    get static() {
      return !!(this.descriptor.usage & rn.STATIC);
    }
    set static(e) {
      e ? this.descriptor.usage |= rn.STATIC : this.descriptor.usage &= ~rn.STATIC;
    }
    setDataWithSize(e, t, n) {
      if (this._updateID++, this._updateSize = t * e.BYTES_PER_ELEMENT, this._data === e) {
        n && this.emit("update", this);
        return;
      }
      const i = this._data;
      if (this._data = e, this._dataInt32 = null, !i || i.length !== e.length) {
        !this.shrinkToFit && i && e.byteLength < i.byteLength ? n && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = Qt("resource"), this.emit("change", this));
        return;
      }
      n && this.emit("update", this);
    }
    update(e) {
      this._updateSize = e ?? this._updateSize, this._updateID++, this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
    }
  };
  function FV(r, e) {
    if (!(r instanceof tf)) {
      let t = e ? rn.INDEX : rn.VERTEX;
      r instanceof Array && (e ? (r = new Uint32Array(r), t = rn.INDEX | rn.COPY_DST) : (r = new Float32Array(r), t = rn.VERTEX | rn.COPY_DST)), r = new tf({
        data: r,
        label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage: t
      });
    }
    return r;
  }
  function Y_e(r, e, t) {
    const n = r.getAttribute(e);
    if (!n) return t.minX = 0, t.minY = 0, t.maxX = 0, t.maxY = 0, t;
    const i = n.buffer.data;
    let a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0;
    const u = i.BYTES_PER_ELEMENT, c = (n.offset || 0) / u, h = (n.stride || 2 * 4) / u;
    for (let f = c; f < i.length; f += h) {
      const d = i[f], p = i[f + 1];
      d > s && (s = d), p > l && (l = p), d < a && (a = d), p < o && (o = p);
    }
    return t.minX = a, t.minY = o, t.maxX = s, t.maxY = l, t;
  }
  function X_e(r) {
    return (r instanceof tf || Array.isArray(r) || r.BYTES_PER_ELEMENT) && (r = {
      buffer: r
    }), r.buffer = FV(r.buffer, false), r;
  }
  q_e = class extends Yi {
    constructor(e = {}) {
      super(), this.uid = Qt("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new ui(), this._boundsDirty = true;
      const { attributes: t, indexBuffer: n, topology: i } = e;
      if (this.buffers = [], this.attributes = {}, t) for (const a in t) this.addAttribute(a, t[a]);
      this.instanceCount = e.instanceCount ?? 1, n && this.addIndex(n), this.topology = i || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true, this.emit("update", this);
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(e) {
      return this.getAttribute(e).buffer;
    }
    getSize() {
      for (const e in this.attributes) {
        const t = this.attributes[e];
        return t.buffer.data.length / (t.stride / 4 || t.size);
      }
      return 0;
    }
    addAttribute(e, t) {
      const n = X_e(t);
      this.buffers.indexOf(n.buffer) === -1 && (this.buffers.push(n.buffer), n.buffer.on("update", this.onBufferUpdate, this), n.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = n;
    }
    addIndex(e) {
      this.indexBuffer = FV(e, true), this.buffers.push(this.indexBuffer);
    }
    get bounds() {
      return this._boundsDirty ? (this._boundsDirty = false, Y_e(this, "aPosition", this._bounds)) : this._bounds;
    }
    destroy(e = false) {
      this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach((t) => t.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
    }
  };
  const K_e = new Float32Array(1), Z_e = new Uint32Array(1);
  class j_e extends q_e {
    constructor() {
      const t = new tf({
        data: K_e,
        label: "attribute-batch-buffer",
        usage: rn.VERTEX | rn.COPY_DST,
        shrinkToFit: false
      }), n = new tf({
        data: Z_e,
        label: "index-batch-buffer",
        usage: rn.INDEX | rn.COPY_DST,
        shrinkToFit: false
      }), i = 6 * 4;
      super({
        attributes: {
          aPosition: {
            buffer: t,
            format: "float32x2",
            stride: i,
            offset: 0
          },
          aUV: {
            buffer: t,
            format: "float32x2",
            stride: i,
            offset: 2 * 4
          },
          aColor: {
            buffer: t,
            format: "unorm8x4",
            stride: i,
            offset: 4 * 4
          },
          aTextureIdAndRound: {
            buffer: t,
            format: "uint16x2",
            stride: i,
            offset: 5 * 4
          }
        },
        indexBuffer: n
      });
    }
  }
  function pk(r, e, t) {
    if (r) for (const n in r) {
      const i = n.toLocaleLowerCase(), a = e[i];
      if (a) {
        let o = r[n];
        n === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), t && a.push(`//----${t}----//`), a.push(o);
      } else mn(`${n} placement hook does not exist in shader`);
    }
  }
  const Q_e = /\{\{(.*?)\}\}/g;
  function vk(r) {
    var _a2;
    const e = {};
    return (((_a2 = r.match(Q_e)) == null ? void 0 : _a2.map((n) => n.replace(/[{()}]/g, ""))) ?? []).forEach((n) => {
      e[n] = [];
    }), e;
  }
  function gk(r, e) {
    let t;
    const n = /@in\s+([^;]+);/g;
    for (; (t = n.exec(r)) !== null; ) e.push(t[1]);
  }
  function mk(r, e, t = false) {
    const n = [];
    gk(e, n), r.forEach((s) => {
      s.header && gk(s.header, n);
    });
    const i = n;
    t && i.sort();
    const a = i.map((s, l) => `       @location(${l}) ${s},`).join(`
`);
    let o = e.replace(/@in\s+[^;]+;\s*/g, "");
    return o = o.replace("{{in}}", `
${a}
`), o;
  }
  function yk(r, e) {
    let t;
    const n = /@out\s+([^;]+);/g;
    for (; (t = n.exec(r)) !== null; ) e.push(t[1]);
  }
  function J_e(r) {
    const t = /\b(\w+)\s*:/g.exec(r);
    return t ? t[1] : "";
  }
  function ebe(r) {
    const e = /@.*?\s+/g;
    return r.replace(e, "");
  }
  function tbe(r, e) {
    const t = [];
    yk(e, t), r.forEach((l) => {
      l.header && yk(l.header, t);
    });
    let n = 0;
    const i = t.sort().map((l) => l.indexOf("builtin") > -1 ? l : `@location(${n++}) ${l}`).join(`,
`), a = t.sort().map((l) => `       var ${ebe(l)};`).join(`
`), o = `return VSOutput(
            ${t.sort().map((l) => ` ${J_e(l)}`).join(`,
`)});`;
    let s = e.replace(/@out\s+[^;]+;\s*/g, "");
    return s = s.replace("{{struct}}", `
${i}
`), s = s.replace("{{start}}", `
${a}
`), s = s.replace("{{return}}", `
${o}
`), s;
  }
  function xk(r, e) {
    let t = r;
    for (const n in e) {
      const i = e[n];
      i.join(`
`).length ? t = t.replace(`{{${n}}}`, `//-----${n} START-----//
${i.join(`
`)}
//----${n} FINISH----//`) : t = t.replace(`{{${n}}}`, "");
    }
    return t;
  }
  const eo = /* @__PURE__ */ Object.create(null), z0 = /* @__PURE__ */ new Map();
  let rbe = 0;
  function nbe({ template: r, bits: e }) {
    const t = BV(r, e);
    if (eo[t]) return eo[t];
    const { vertex: n, fragment: i } = abe(r, e);
    return eo[t] = zV(n, i, e), eo[t];
  }
  function ibe({ template: r, bits: e }) {
    const t = BV(r, e);
    return eo[t] || (eo[t] = zV(r.vertex, r.fragment, e)), eo[t];
  }
  function abe(r, e) {
    const t = e.map((o) => o.vertex).filter((o) => !!o), n = e.map((o) => o.fragment).filter((o) => !!o);
    let i = mk(t, r.vertex, true);
    i = tbe(t, i);
    const a = mk(n, r.fragment, true);
    return {
      vertex: i,
      fragment: a
    };
  }
  function BV(r, e) {
    return e.map((t) => (z0.has(t) || z0.set(t, rbe++), z0.get(t))).sort((t, n) => t - n).join("-") + r.vertex + r.fragment;
  }
  function zV(r, e, t) {
    const n = vk(r), i = vk(e);
    return t.forEach((a) => {
      pk(a.vertex, n, a.name), pk(a.fragment, i, a.name);
    }), {
      vertex: xk(r, n),
      fragment: xk(e, i)
    };
  }
  const obe = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, sbe = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, lbe = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, ube = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`, cbe = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    }
  }, hbe = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    }
  };
  fbe = function({ bits: r, name: e }) {
    const t = nbe({
      template: {
        fragment: sbe,
        vertex: obe
      },
      bits: [
        cbe,
        ...r
      ]
    });
    return Fg.from({
      name: e,
      vertex: {
        source: t.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: t.fragment,
        entryPoint: "main"
      }
    });
  };
  dbe = function({ bits: r, name: e }) {
    return new _V({
      name: e,
      ...ibe({
        template: {
          vertex: lbe,
          fragment: ube
        },
        bits: [
          hbe,
          ...r
        ]
      })
    });
  };
  let V0;
  pbe = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  vbe = {
    name: "color-bit",
    vertex: {
      header: `
            in vec4 aColor;
        `,
      main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  V0 = {};
  function gbe(r) {
    const e = [];
    if (r === 1) e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
      let t = 0;
      for (let n = 0; n < r; n++) e.push(`@group(1) @binding(${t++}) var textureSource${n + 1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${t++}) var textureSampler${n + 1}: sampler;`);
    }
    return e.join(`
`);
  }
  function mbe(r) {
    const e = [];
    if (r === 1) e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
      e.push("switch vTextureId {");
      for (let t = 0; t < r; t++) t === r - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`), e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`), e.push("      break;}");
      e.push("}");
    }
    return e.join(`
`);
  }
  ybe = function(r) {
    return V0[r] || (V0[r] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${gbe(r)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${mbe(r)}
            `
      }
    }), V0[r];
  };
  const $0 = {};
  function xbe(r) {
    const e = [];
    for (let t = 0; t < r; t++) t > 0 && e.push("else"), t < r - 1 && e.push(`if(vTextureId < ${t}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${t}], vUV);`), e.push("}");
    return e.join(`
`);
  }
  _be = function(r) {
    return $0[r] || ($0[r] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${r}];

            `,
        main: `

                ${xbe(r)}
            `
      }
    }), $0[r];
  };
  let _k;
  bbe = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  Sbe = {
    name: "round-pixels-bit",
    vertex: {
      header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  _k = {};
  wbe = function(r) {
    let e = _k[r];
    if (e) return e;
    const t = new Int32Array(r);
    for (let n = 0; n < r; n++) t[n] = n;
    return e = _k[r] = new CV({
      uTextures: {
        value: t,
        type: "i32",
        size: r
      }
    }, {
      isStatic: true
    }), e;
  };
  class Cbe extends dw {
    constructor(e) {
      const t = dbe({
        name: "batch",
        bits: [
          vbe,
          _be(e),
          Sbe
        ]
      }), n = fbe({
        name: "batch",
        bits: [
          pbe,
          ybe(e),
          bbe
        ]
      });
      super({
        glProgram: t,
        gpuProgram: n,
        resources: {
          batchSamplers: wbe(e)
        }
      });
    }
  }
  let bk = null;
  const VV = class $V extends H_e {
    constructor() {
      super(...arguments), this.geometry = new j_e(), this.shader = bk || (bk = new Cbe(this.maxTextures)), this.name = $V.extension.name, this.vertexSize = 6;
    }
    packAttributes(e, t, n, i, a) {
      const o = a << 16 | e.roundPixels & 65535, s = e.transform, l = s.a, u = s.b, c = s.c, h = s.d, f = s.tx, d = s.ty, { positions: p, uvs: v } = e, g = e.color, m = e.attributeOffset, y = m + e.attributeSize;
      for (let x = m; x < y; x++) {
        const _ = x * 2, S = p[_], b = p[_ + 1];
        t[i++] = l * S + c * b + f, t[i++] = h * b + u * S + d, t[i++] = v[_], t[i++] = v[_ + 1], n[i++] = g, n[i++] = o;
      }
    }
    packQuadAttributes(e, t, n, i, a) {
      const o = e.texture, s = e.transform, l = s.a, u = s.b, c = s.c, h = s.d, f = s.tx, d = s.ty, p = e.bounds, v = p.maxX, g = p.minX, m = p.maxY, y = p.minY, x = o.uvs, _ = e.color, S = a << 16 | e.roundPixels & 65535;
      t[i + 0] = l * g + c * y + f, t[i + 1] = h * y + u * g + d, t[i + 2] = x.x0, t[i + 3] = x.y0, n[i + 4] = _, n[i + 5] = S, t[i + 6] = l * v + c * y + f, t[i + 7] = h * y + u * v + d, t[i + 8] = x.x1, t[i + 9] = x.y1, n[i + 10] = _, n[i + 11] = S, t[i + 12] = l * v + c * m + f, t[i + 13] = h * m + u * v + d, t[i + 14] = x.x2, t[i + 15] = x.y2, n[i + 16] = _, n[i + 17] = S, t[i + 18] = l * g + c * m + f, t[i + 19] = h * m + u * g + d, t[i + 20] = x.x3, t[i + 21] = x.y3, n[i + 22] = _, n[i + 23] = S;
    }
  };
  VV.extension = {
    type: [
      Ct.Batcher
    ],
    name: "default"
  };
  Tbe = VV;
  function Abe(r, e, t, n, i, a, o, s = null) {
    let l = 0;
    t *= e, i *= a;
    const u = s.a, c = s.b, h = s.c, f = s.d, d = s.tx, p = s.ty;
    for (; l < o; ) {
      const v = r[t], g = r[t + 1];
      n[i] = u * v + h * g + d, n[i + 1] = c * v + f * g + p, i += a, t += e, l++;
    }
  }
  function Ibe(r, e, t, n) {
    let i = 0;
    for (e *= t; i < n; ) r[e] = 0, r[e + 1] = 0, e += t, i++;
  }
  function GV(r, e, t, n, i) {
    const a = e.a, o = e.b, s = e.c, l = e.d, u = e.tx, c = e.ty;
    t || (t = 0), n || (n = 2), i || (i = r.length / n - t);
    let h = t * n;
    for (let f = 0; f < i; f++) {
      const d = r[h], p = r[h + 1];
      r[h] = a * d + s * p + u, r[h + 1] = o * d + l * p + c, h += n;
    }
  }
  const Mbe = new pt();
  WV = class {
    constructor() {
      this.packAsQuad = false, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = true, this.roundPixels = 0, this._batcher = null, this._batch = null;
    }
    get uvs() {
      return this.geometryData.uvs;
    }
    get positions() {
      return this.geometryData.vertices;
    }
    get indices() {
      return this.geometryData.indices;
    }
    get blendMode() {
      return this.applyTransform ? this.renderable.groupBlendMode : "normal";
    }
    get color() {
      const e = this.baseColor, t = e >> 16 | e & 65280 | (e & 255) << 16, n = this.renderable;
      return n ? Qz(t, n.groupColor) + (this.alpha * n.groupAlpha * 255 << 24) : t + (this.alpha * 255 << 24);
    }
    get transform() {
      var _a2;
      return ((_a2 = this.renderable) == null ? void 0 : _a2.groupTransform) || Mbe;
    }
    copyTo(e) {
      e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology;
    }
    reset() {
      this.applyTransform = true, this.renderable = null, this.topology = "triangle-list";
    }
  };
  const rf = {
    extension: {
      type: Ct.ShapeBuilder,
      name: "circle"
    },
    build(r, e) {
      let t, n, i, a, o, s;
      if (r.type === "circle") {
        const _ = r;
        t = _.x, n = _.y, o = s = _.radius, i = a = 0;
      } else if (r.type === "ellipse") {
        const _ = r;
        t = _.x, n = _.y, o = _.halfWidth, s = _.halfHeight, i = a = 0;
      } else {
        const _ = r, S = _.width / 2, b = _.height / 2;
        t = _.x + S, n = _.y + b, o = s = Math.max(0, Math.min(_.radius, Math.min(S, b))), i = S - o, a = b - s;
      }
      if (!(o >= 0 && s >= 0 && i >= 0 && a >= 0)) return e;
      const l = Math.ceil(2.3 * Math.sqrt(o + s)), u = l * 8 + (i ? 4 : 0) + (a ? 4 : 0);
      if (u === 0) return e;
      if (l === 0) return e[0] = e[6] = t + i, e[1] = e[3] = n + a, e[2] = e[4] = t - i, e[5] = e[7] = n - a, e;
      let c = 0, h = l * 4 + (i ? 2 : 0) + 2, f = h, d = u, p = i + o, v = a, g = t + p, m = t - p, y = n + v;
      if (e[c++] = g, e[c++] = y, e[--h] = y, e[--h] = m, a) {
        const _ = n - v;
        e[f++] = m, e[f++] = _, e[--d] = _, e[--d] = g;
      }
      for (let _ = 1; _ < l; _++) {
        const S = Math.PI / 2 * (_ / l), b = i + Math.cos(S) * o, w = a + Math.sin(S) * s, C = t + b, T = t - b, A = n + w, M = n - w;
        e[c++] = C, e[c++] = A, e[--h] = A, e[--h] = T, e[f++] = T, e[f++] = M, e[--d] = M, e[--d] = C;
      }
      p = i, v = a + s, g = t + p, m = t - p, y = n + v;
      const x = n - v;
      return e[c++] = g, e[c++] = y, e[--d] = x, e[--d] = g, i && (e[c++] = m, e[c++] = y, e[--d] = x, e[--d] = m), e;
    },
    triangulate(r, e, t, n, i, a) {
      if (r.length === 0) return;
      let o = 0, s = 0;
      for (let c = 0; c < r.length; c += 2) o += r[c], s += r[c + 1];
      o /= r.length / 2, s /= r.length / 2;
      let l = n;
      e[l * t] = o, e[l * t + 1] = s;
      const u = l++;
      for (let c = 0; c < r.length; c += 2) e[l * t] = r[c], e[l * t + 1] = r[c + 1], c > 0 && (i[a++] = l, i[a++] = u, i[a++] = l - 1), l++;
      i[a++] = u + 1, i[a++] = u, i[a++] = l - 1;
    }
  }, Dbe = {
    ...rf,
    extension: {
      ...rf.extension,
      name: "ellipse"
    }
  }, Pbe = {
    ...rf,
    extension: {
      ...rf.extension,
      name: "roundedRectangle"
    }
  }, UV = 1e-4, Sk = 1e-4;
  function kbe(r) {
    const e = r.length;
    if (e < 6) return 1;
    let t = 0;
    for (let n = 0, i = r[e - 2], a = r[e - 1]; n < e; n += 2) {
      const o = r[n], s = r[n + 1];
      t += (o - i) * (s + a), i = o, a = s;
    }
    return t < 0 ? -1 : 1;
  }
  function wk(r, e, t, n, i, a, o, s) {
    const l = r - t * i, u = e - n * i, c = r + t * a, h = e + n * a;
    let f, d;
    o ? (f = n, d = -t) : (f = -n, d = t);
    const p = l + f, v = u + d, g = c + f, m = h + d;
    return s.push(p, v), s.push(g, m), 2;
  }
  function Ko(r, e, t, n, i, a, o, s) {
    const l = t - r, u = n - e;
    let c = Math.atan2(l, u), h = Math.atan2(i - r, a - e);
    s && c < h ? c += Math.PI * 2 : !s && c > h && (h += Math.PI * 2);
    let f = c;
    const d = h - c, p = Math.abs(d), v = Math.sqrt(l * l + u * u), g = (15 * p * Math.sqrt(v) / Math.PI >> 0) + 1, m = d / g;
    if (f += m, s) {
      o.push(r, e), o.push(t, n);
      for (let y = 1, x = f; y < g; y++, x += m) o.push(r, e), o.push(r + Math.sin(x) * v, e + Math.cos(x) * v);
      o.push(r, e), o.push(i, a);
    } else {
      o.push(t, n), o.push(r, e);
      for (let y = 1, x = f; y < g; y++, x += m) o.push(r + Math.sin(x) * v, e + Math.cos(x) * v), o.push(r, e);
      o.push(i, a), o.push(r, e);
    }
    return g * 2;
  }
  function Lbe(r, e, t, n, i, a) {
    const o = UV;
    if (r.length === 0) return;
    const s = e;
    let l = s.alignment;
    if (e.alignment !== 0.5) {
      let O = kbe(r);
      l = (l - 0.5) * O + 0.5;
    }
    const u = new Dr(r[0], r[1]), c = new Dr(r[r.length - 2], r[r.length - 1]), h = n, f = Math.abs(u.x - c.x) < o && Math.abs(u.y - c.y) < o;
    if (h) {
      r = r.slice(), f && (r.pop(), r.pop(), c.set(r[r.length - 2], r[r.length - 1]));
      const O = (u.x + c.x) * 0.5, F = (c.y + u.y) * 0.5;
      r.unshift(O, F), r.push(O, F);
    }
    const d = i, p = r.length / 2;
    let v = r.length;
    const g = d.length / 2, m = s.width / 2, y = m * m, x = s.miterLimit * s.miterLimit;
    let _ = r[0], S = r[1], b = r[2], w = r[3], C = 0, T = 0, A = -(S - w), M = _ - b, E = 0, k = 0, R = Math.sqrt(A * A + M * M);
    A /= R, M /= R, A *= m, M *= m;
    const N = l, I = (1 - N) * 2, L = N * 2;
    h || (s.cap === "round" ? v += Ko(_ - A * (I - L) * 0.5, S - M * (I - L) * 0.5, _ - A * I, S - M * I, _ + A * L, S + M * L, d, true) + 2 : s.cap === "square" && (v += wk(_, S, A, M, I, L, true, d))), d.push(_ - A * I, S - M * I), d.push(_ + A * L, S + M * L);
    for (let O = 1; O < p - 1; ++O) {
      _ = r[(O - 1) * 2], S = r[(O - 1) * 2 + 1], b = r[O * 2], w = r[O * 2 + 1], C = r[(O + 1) * 2], T = r[(O + 1) * 2 + 1], A = -(S - w), M = _ - b, R = Math.sqrt(A * A + M * M), A /= R, M /= R, A *= m, M *= m, E = -(w - T), k = b - C, R = Math.sqrt(E * E + k * k), E /= R, k /= R, E *= m, k *= m;
      const F = b - _, B = S - w, V = b - C, U = T - w, Y = F * V + B * U, q = B * V - U * F, me = q < 0;
      if (Math.abs(q) < 1e-3 * Math.abs(Y)) {
        d.push(b - A * I, w - M * I), d.push(b + A * L, w + M * L), Y >= 0 && (s.join === "round" ? v += Ko(b, w, b - A * I, w - M * I, b - E * I, w - k * I, d, false) + 4 : v += 2, d.push(b - E * L, w - k * L), d.push(b + E * I, w + k * I));
        continue;
      }
      const Me = (-A + _) * (-M + w) - (-A + b) * (-M + S), re = (-E + C) * (-k + w) - (-E + b) * (-k + T), J = (F * re - V * Me) / q, le = (U * Me - B * re) / q, te = (J - b) * (J - b) + (le - w) * (le - w), he = b + (J - b) * I, Xe = w + (le - w) * I, Fe = b - (J - b) * L, fe = w - (le - w) * L, Se = Math.min(F * F + B * B, V * V + U * U), Lt = me ? I : L, z = Se + Lt * Lt * y;
      te <= z ? s.join === "bevel" || te / y > x ? (me ? (d.push(he, Xe), d.push(b + A * L, w + M * L), d.push(he, Xe), d.push(b + E * L, w + k * L)) : (d.push(b - A * I, w - M * I), d.push(Fe, fe), d.push(b - E * I, w - k * I), d.push(Fe, fe)), v += 2) : s.join === "round" ? me ? (d.push(he, Xe), d.push(b + A * L, w + M * L), v += Ko(b, w, b + A * L, w + M * L, b + E * L, w + k * L, d, true) + 4, d.push(he, Xe), d.push(b + E * L, w + k * L)) : (d.push(b - A * I, w - M * I), d.push(Fe, fe), v += Ko(b, w, b - A * I, w - M * I, b - E * I, w - k * I, d, false) + 4, d.push(b - E * I, w - k * I), d.push(Fe, fe)) : (d.push(he, Xe), d.push(Fe, fe)) : (d.push(b - A * I, w - M * I), d.push(b + A * L, w + M * L), s.join === "round" ? me ? v += Ko(b, w, b + A * L, w + M * L, b + E * L, w + k * L, d, true) + 2 : v += Ko(b, w, b - A * I, w - M * I, b - E * I, w - k * I, d, false) + 2 : s.join === "miter" && te / y <= x && (me ? (d.push(Fe, fe), d.push(Fe, fe)) : (d.push(he, Xe), d.push(he, Xe)), v += 2), d.push(b - E * I, w - k * I), d.push(b + E * L, w + k * L), v += 2);
    }
    _ = r[(p - 2) * 2], S = r[(p - 2) * 2 + 1], b = r[(p - 1) * 2], w = r[(p - 1) * 2 + 1], A = -(S - w), M = _ - b, R = Math.sqrt(A * A + M * M), A /= R, M /= R, A *= m, M *= m, d.push(b - A * I, w - M * I), d.push(b + A * L, w + M * L), h || (s.cap === "round" ? v += Ko(b - A * (I - L) * 0.5, w - M * (I - L) * 0.5, b - A * I, w - M * I, b + A * L, w + M * L, d, false) + 2 : s.cap === "square" && (v += wk(b, w, A, M, I, L, false, d)));
    const P = Sk * Sk;
    for (let O = g; O < v + g - 2; ++O) _ = d[O * 2], S = d[O * 2 + 1], b = d[(O + 1) * 2], w = d[(O + 1) * 2 + 1], C = d[(O + 2) * 2], T = d[(O + 2) * 2 + 1], !(Math.abs(_ * (w - T) + b * (T - S) + C * (S - w)) < P) && a.push(O, O + 1, O + 2);
  }
  function Rbe(r, e, t, n) {
    const i = UV;
    if (r.length === 0) return;
    const a = r[0], o = r[1], s = r[r.length - 2], l = r[r.length - 1], u = e || Math.abs(a - s) < i && Math.abs(o - l) < i, c = t, h = r.length / 2, f = c.length / 2;
    for (let d = 0; d < h; d++) c.push(r[d * 2]), c.push(r[d * 2 + 1]);
    for (let d = 0; d < h - 1; d++) n.push(f + d, f + d + 1);
    u && n.push(f + h - 1, f);
  }
  function HV(r, e, t, n, i, a, o) {
    const s = b_e(r, e, 2);
    if (!s) return;
    for (let u = 0; u < s.length; u += 3) a[o++] = s[u] + i, a[o++] = s[u + 1] + i, a[o++] = s[u + 2] + i;
    let l = i * n;
    for (let u = 0; u < r.length; u += 2) t[l] = r[u], t[l + 1] = r[u + 1], l += n;
  }
  const Ebe = [], Nbe = {
    extension: {
      type: Ct.ShapeBuilder,
      name: "polygon"
    },
    build(r, e) {
      for (let t = 0; t < r.points.length; t++) e[t] = r.points[t];
      return e;
    },
    triangulate(r, e, t, n, i, a) {
      HV(r, Ebe, e, t, n, i, a);
    }
  }, Obe = {
    extension: {
      type: Ct.ShapeBuilder,
      name: "rectangle"
    },
    build(r, e) {
      const t = r, n = t.x, i = t.y, a = t.width, o = t.height;
      return a >= 0 && o >= 0 && (e[0] = n, e[1] = i, e[2] = n + a, e[3] = i, e[4] = n + a, e[5] = i + o, e[6] = n, e[7] = i + o), e;
    },
    triangulate(r, e, t, n, i, a) {
      let o = 0;
      n *= t, e[n + o] = r[0], e[n + o + 1] = r[1], o += t, e[n + o] = r[2], e[n + o + 1] = r[3], o += t, e[n + o] = r[6], e[n + o + 1] = r[7], o += t, e[n + o] = r[4], e[n + o + 1] = r[5], o += t;
      const s = n / t;
      i[a++] = s, i[a++] = s + 1, i[a++] = s + 2, i[a++] = s + 1, i[a++] = s + 3, i[a++] = s + 2;
    }
  }, Fbe = {
    extension: {
      type: Ct.ShapeBuilder,
      name: "triangle"
    },
    build(r, e) {
      return e[0] = r.x, e[1] = r.y, e[2] = r.x2, e[3] = r.y2, e[4] = r.x3, e[5] = r.y3, e;
    },
    triangulate(r, e, t, n, i, a) {
      let o = 0;
      n *= t, e[n + o] = r[0], e[n + o + 1] = r[1], o += t, e[n + o] = r[2], e[n + o + 1] = r[3], o += t, e[n + o] = r[4], e[n + o + 1] = r[5];
      const s = n / t;
      i[a++] = s, i[a++] = s + 1, i[a++] = s + 2;
    }
  }, Bbe = new pt(), zbe = new gr();
  function Vbe(r, e, t, n) {
    const i = e.matrix ? r.copyFrom(e.matrix).invert() : r.identity();
    if (e.textureSpace === "local") {
      const a = t.getBounds(zbe);
      i.translate(-a.x, -a.y), i.scale(1 / a.width, 1 / a.height);
    } else {
      i.translate(e.texture.frame.x, e.texture.frame.y), i.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
      const a = e.texture.source.style;
      a.addressMode === "clamp-to-edge" && (a.addressMode = "repeat", a.update());
    }
    return n && i.append(Bbe.copyFrom(n).invert()), i;
  }
  const Bg = {};
  Wn.handleByMap(Ct.ShapeBuilder, Bg);
  Wn.add(Obe, Nbe, Fbe, rf, Dbe, Pbe);
  const $be = new gr(), Gbe = new pt();
  function Wbe(r, e) {
    const { geometryData: t, batches: n } = e;
    n.length = 0, t.indices.length = 0, t.vertices.length = 0, t.uvs.length = 0;
    for (let i = 0; i < r.instructions.length; i++) {
      const a = r.instructions[i];
      if (a.action === "texture") Ube(a.data, n, t);
      else if (a.action === "fill" || a.action === "stroke") {
        const o = a.action === "stroke", s = a.data.path.shapePath, l = a.data.style, u = a.data.hole;
        o && u && Ck(u.shapePath, l, true, n, t), u && (s.shapePrimitives[s.shapePrimitives.length - 1].holes = u.shapePath.shapePrimitives), Ck(s, l, o, n, t);
      }
    }
  }
  function Ube(r, e, t) {
    const { vertices: n, uvs: i, indices: a } = t, o = a.length, s = n.length / 2, l = [], u = Bg.rectangle, c = $be, h = r.image;
    c.x = r.dx, c.y = r.dy, c.width = r.dw, c.height = r.dh;
    const f = r.transform;
    u.build(c, l), f && GV(l, f), u.triangulate(l, n, 2, s, a, o);
    const d = h.uvs;
    i.push(d.x0, d.y0, d.x1, d.y1, d.x3, d.y3, d.x2, d.y2);
    const p = fa.get(WV);
    p.indexOffset = o, p.indexSize = a.length - o, p.attributeOffset = s, p.attributeSize = n.length / 2 - s, p.baseColor = r.style, p.alpha = r.alpha, p.texture = h, p.geometryData = t, e.push(p);
  }
  function Ck(r, e, t, n, i) {
    const { vertices: a, uvs: o, indices: s } = i;
    r.shapePrimitives.forEach(({ shape: l, transform: u, holes: c }) => {
      const h = s.length, f = a.length / 2, d = [], p = Bg[l.type];
      let v = "triangle-list";
      if (p.build(l, d), u && GV(d, u), t) {
        const x = l.closePath ?? true, _ = e;
        _.pixelLine ? (Rbe(d, x, a, s), v = "line-list") : Lbe(d, _, false, x, a, s);
      } else if (c) {
        const x = [], _ = d.slice();
        Hbe(c).forEach((b) => {
          x.push(_.length / 2), _.push(...b);
        }), HV(_, x, a, 2, f, s, h);
      } else p.triangulate(d, a, 2, f, s, h);
      const g = o.length / 2, m = e.texture;
      if (m !== At.WHITE) {
        const x = Vbe(Gbe, e, l, u);
        Abe(a, 2, f, o, g, 2, a.length / 2 - f, x);
      } else Ibe(o, g, 2, a.length / 2 - f);
      const y = fa.get(WV);
      y.indexOffset = h, y.indexSize = s.length - h, y.attributeOffset = f, y.attributeSize = a.length / 2 - f, y.baseColor = e.color, y.alpha = e.alpha, y.texture = m, y.geometryData = i, y.topology = v, n.push(y);
    });
  }
  function Hbe(r) {
    const e = [];
    for (let t = 0; t < r.length; t++) {
      const n = r[t].shape, i = [];
      Bg[n.type].build(n, i), e.push(i);
    }
    return e;
  }
  class Ybe {
    constructor() {
      this.batches = [], this.geometryData = {
        vertices: [],
        uvs: [],
        indices: []
      };
    }
  }
  class Xbe {
    constructor() {
      this.batcher = new Tbe(), this.instructions = new rV();
    }
    init() {
      this.instructions.reset();
    }
    get geometry() {
      return Pt(nxe, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
    }
  }
  const xw = class vb {
    constructor(e) {
      this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
    }
    init(e) {
      vb.defaultOptions.bezierSmoothness = (e == null ? void 0 : e.bezierSmoothness) ?? vb.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(e) {
      return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e);
    }
    updateGpuContext(e) {
      let t = this._gpuContextHash[e.uid] || this._initContext(e);
      if (e.dirty) {
        t ? this._cleanGraphicsContextData(e) : t = this._initContext(e), Wbe(e, t);
        const n = e.batchMode;
        e.customShader || n === "no-batch" ? t.isBatchable = false : n === "auto" && (t.isBatchable = t.geometryData.vertices.length < 400), e.dirty = false;
      }
      return t;
    }
    getGpuContext(e) {
      return this._gpuContextHash[e.uid] || this._initContext(e);
    }
    _initContextRenderData(e) {
      const t = fa.get(Xbe), { batches: n, geometryData: i } = this._gpuContextHash[e.uid], a = i.vertices.length, o = i.indices.length;
      for (let c = 0; c < n.length; c++) n[c].applyTransform = false;
      const s = t.batcher;
      s.ensureAttributeBuffer(a), s.ensureIndexBuffer(o), s.begin();
      for (let c = 0; c < n.length; c++) {
        const h = n[c];
        s.add(h);
      }
      s.finish(t.instructions);
      const l = s.geometry;
      l.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, true), l.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, true);
      const u = s.batches;
      for (let c = 0; c < u.length; c++) {
        const h = u[c];
        h.bindGroup = z_e(h.textures.textures, h.textures.count);
      }
      return this._graphicsDataContextHash[e.uid] = t, t;
    }
    _initContext(e) {
      const t = new Ybe();
      return t.context = e, this._gpuContextHash[e.uid] = t, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid];
    }
    onGraphicsContextDestroy(e) {
      this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null;
    }
    _cleanGraphicsContextData(e) {
      const t = this._gpuContextHash[e.uid];
      t.isBatchable || this._graphicsDataContextHash[e.uid] && (fa.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), t.batches && t.batches.forEach((n) => {
        fa.return(n);
      });
    }
    destroy() {
      for (const e in this._gpuContextHash) this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
    }
  };
  xw.extension = {
    type: [
      Ct.WebGLSystem,
      Ct.WebGPUSystem,
      Ct.CanvasSystem
    ],
    name: "graphicsContext"
  };
  xw.defaultOptions = {
    bezierSmoothness: 0.5
  };
  YV = xw;
  const qbe = 8, Jd = 11920929e-14, Kbe = 1;
  function XV(r, e, t, n, i, a, o, s, l, u) {
    const h = Math.min(0.99, Math.max(0, u ?? YV.defaultOptions.bezierSmoothness));
    let f = (Kbe - h) / 1;
    return f *= f, Zbe(e, t, n, i, a, o, s, l, r, f), r;
  }
  function Zbe(r, e, t, n, i, a, o, s, l, u) {
    gb(r, e, t, n, i, a, o, s, l, u, 0), l.push(o, s);
  }
  function gb(r, e, t, n, i, a, o, s, l, u, c) {
    if (c > qbe) return;
    const h = (r + t) / 2, f = (e + n) / 2, d = (t + i) / 2, p = (n + a) / 2, v = (i + o) / 2, g = (a + s) / 2, m = (h + d) / 2, y = (f + p) / 2, x = (d + v) / 2, _ = (p + g) / 2, S = (m + x) / 2, b = (y + _) / 2;
    if (c > 0) {
      let w = o - r, C = s - e;
      const T = Math.abs((t - o) * C - (n - s) * w), A = Math.abs((i - o) * C - (a - s) * w);
      if (T > Jd && A > Jd) {
        if ((T + A) * (T + A) <= u * (w * w + C * C)) {
          l.push(S, b);
          return;
        }
      } else if (T > Jd) {
        if (T * T <= u * (w * w + C * C)) {
          l.push(S, b);
          return;
        }
      } else if (A > Jd) {
        if (A * A <= u * (w * w + C * C)) {
          l.push(S, b);
          return;
        }
      } else if (w = S - (r + o) / 2, C = b - (e + s) / 2, w * w + C * C <= u) {
        l.push(S, b);
        return;
      }
    }
    gb(r, e, h, f, m, y, S, b, l, u, c + 1), gb(S, b, x, _, v, g, o, s, l, u, c + 1);
  }
  const jbe = 8, Qbe = 11920929e-14, Jbe = 1;
  function e1e(r, e, t, n, i, a, o, s) {
    const u = Math.min(0.99, Math.max(0, s ?? YV.defaultOptions.bezierSmoothness));
    let c = (Jbe - u) / 1;
    return c *= c, t1e(e, t, n, i, a, o, r, c), r;
  }
  function t1e(r, e, t, n, i, a, o, s) {
    mb(o, r, e, t, n, i, a, s, 0), o.push(i, a);
  }
  function mb(r, e, t, n, i, a, o, s, l) {
    if (l > jbe) return;
    const u = (e + n) / 2, c = (t + i) / 2, h = (n + a) / 2, f = (i + o) / 2, d = (u + h) / 2, p = (c + f) / 2;
    let v = a - e, g = o - t;
    const m = Math.abs((n - a) * g - (i - o) * v);
    if (m > Qbe) {
      if (m * m <= s * (v * v + g * g)) {
        r.push(d, p);
        return;
      }
    } else if (v = d - (e + a) / 2, g = p - (t + o) / 2, v * v + g * g <= s) {
      r.push(d, p);
      return;
    }
    mb(r, e, t, u, c, d, p, s, l + 1), mb(r, d, p, h, f, a, o, s, l + 1);
  }
  function qV(r, e, t, n, i, a, o, s) {
    let l = Math.abs(i - a);
    (!o && i > a || o && a > i) && (l = 2 * Math.PI - l), s || (s = Math.max(6, Math.floor(6 * Math.pow(n, 1 / 3) * (l / Math.PI)))), s = Math.max(s, 3);
    let u = l / s, c = i;
    u *= o ? -1 : 1;
    for (let h = 0; h < s + 1; h++) {
      const f = Math.cos(c), d = Math.sin(c), p = e + f * n, v = t + d * n;
      r.push(p, v), c += u;
    }
  }
  function r1e(r, e, t, n, i, a) {
    const o = r[r.length - 2], l = r[r.length - 1] - t, u = o - e, c = i - t, h = n - e, f = Math.abs(l * h - u * c);
    if (f < 1e-8 || a === 0) {
      (r[r.length - 2] !== e || r[r.length - 1] !== t) && r.push(e, t);
      return;
    }
    const d = l * l + u * u, p = c * c + h * h, v = l * c + u * h, g = a * Math.sqrt(d) / f, m = a * Math.sqrt(p) / f, y = g * v / d, x = m * v / p, _ = g * h + m * u, S = g * c + m * l, b = u * (m + y), w = l * (m + y), C = h * (g + x), T = c * (g + x), A = Math.atan2(w - S, b - _), M = Math.atan2(T - S, C - _);
    qV(r, _ + e, S + t, a, A, M, u * c > h * l);
  }
  const fh = Math.PI * 2, G0 = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  }, W0 = ({ x: r, y: e }, t, n, i, a, o, s, l) => {
    r *= t, e *= n;
    const u = i * r - a * e, c = a * r + i * e;
    return l.x = u + o, l.y = c + s, l;
  };
  function n1e(r, e) {
    const t = e === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(e / 4), n = e === 1.5707963267948966 ? 0.551915024494 : t, i = Math.cos(r), a = Math.sin(r), o = Math.cos(r + e), s = Math.sin(r + e);
    return [
      {
        x: i - a * n,
        y: a + i * n
      },
      {
        x: o + s * n,
        y: s - o * n
      },
      {
        x: o,
        y: s
      }
    ];
  }
  const Tk = (r, e, t, n) => {
    const i = r * n - e * t < 0 ? -1 : 1;
    let a = r * t + e * n;
    return a > 1 && (a = 1), a < -1 && (a = -1), i * Math.acos(a);
  }, i1e = (r, e, t, n, i, a, o, s, l, u, c, h, f) => {
    const d = Math.pow(i, 2), p = Math.pow(a, 2), v = Math.pow(c, 2), g = Math.pow(h, 2);
    let m = d * p - d * g - p * v;
    m < 0 && (m = 0), m /= d * g + p * v, m = Math.sqrt(m) * (o === s ? -1 : 1);
    const y = m * i / a * h, x = m * -a / i * c, _ = u * y - l * x + (r + t) / 2, S = l * y + u * x + (e + n) / 2, b = (c - y) / i, w = (h - x) / a, C = (-c - y) / i, T = (-h - x) / a, A = Tk(1, 0, b, w);
    let M = Tk(b, w, C, T);
    s === 0 && M > 0 && (M -= fh), s === 1 && M < 0 && (M += fh), f.centerX = _, f.centerY = S, f.ang1 = A, f.ang2 = M;
  };
  function a1e(r, e, t, n, i, a, o, s = 0, l = 0, u = 0) {
    if (a === 0 || o === 0) return;
    const c = Math.sin(s * fh / 360), h = Math.cos(s * fh / 360), f = h * (e - n) / 2 + c * (t - i) / 2, d = -c * (e - n) / 2 + h * (t - i) / 2;
    if (f === 0 && d === 0) return;
    a = Math.abs(a), o = Math.abs(o);
    const p = Math.pow(f, 2) / Math.pow(a, 2) + Math.pow(d, 2) / Math.pow(o, 2);
    p > 1 && (a *= Math.sqrt(p), o *= Math.sqrt(p)), i1e(e, t, n, i, a, o, l, u, c, h, f, d, G0);
    let { ang1: v, ang2: g } = G0;
    const { centerX: m, centerY: y } = G0;
    let x = Math.abs(g) / (fh / 4);
    Math.abs(1 - x) < 1e-7 && (x = 1);
    const _ = Math.max(Math.ceil(x), 1);
    g /= _;
    let S = r[r.length - 2], b = r[r.length - 1];
    const w = {
      x: 0,
      y: 0
    };
    for (let C = 0; C < _; C++) {
      const T = n1e(v, g), { x: A, y: M } = W0(T[0], a, o, h, c, m, y, w), { x: E, y: k } = W0(T[1], a, o, h, c, m, y, w), { x: R, y: N } = W0(T[2], a, o, h, c, m, y, w);
      XV(r, S, b, A, M, E, k, R, N), S = R, b = N, v += g;
    }
  }
  function o1e(r, e, t) {
    const n = (o, s) => {
      const l = s.x - o.x, u = s.y - o.y, c = Math.sqrt(l * l + u * u), h = l / c, f = u / c;
      return {
        len: c,
        nx: h,
        ny: f
      };
    }, i = (o, s) => {
      o === 0 ? r.moveTo(s.x, s.y) : r.lineTo(s.x, s.y);
    };
    let a = e[e.length - 1];
    for (let o = 0; o < e.length; o++) {
      const s = e[o % e.length], l = s.radius ?? t;
      if (l <= 0) {
        i(o, s), a = s;
        continue;
      }
      const u = e[(o + 1) % e.length], c = n(s, a), h = n(s, u);
      if (c.len < 1e-4 || h.len < 1e-4) {
        i(o, s), a = s;
        continue;
      }
      let f = Math.asin(c.nx * h.ny - c.ny * h.nx), d = 1, p = false;
      c.nx * h.nx - c.ny * -h.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, d = -1, p = true) : f > 0 && (d = -1, p = true);
      const v = f / 2;
      let g, m = Math.abs(Math.cos(v) * l / Math.sin(v));
      m > Math.min(c.len / 2, h.len / 2) ? (m = Math.min(c.len / 2, h.len / 2), g = Math.abs(m * Math.sin(v) / Math.cos(v))) : g = l;
      const y = s.x + h.nx * m + -h.ny * g * d, x = s.y + h.ny * m + h.nx * g * d, _ = Math.atan2(c.ny, c.nx) + Math.PI / 2 * d, S = Math.atan2(h.ny, h.nx) - Math.PI / 2 * d;
      o === 0 && r.moveTo(y + Math.cos(_) * g, x + Math.sin(_) * g), r.arc(y, x, g, _, S, p), a = s;
    }
  }
  function s1e(r, e, t, n) {
    const i = (s, l) => Math.sqrt((s.x - l.x) ** 2 + (s.y - l.y) ** 2), a = (s, l, u) => ({
      x: s.x + (l.x - s.x) * u,
      y: s.y + (l.y - s.y) * u
    }), o = e.length;
    for (let s = 0; s < o; s++) {
      const l = e[(s + 1) % o], u = l.radius ?? t;
      if (u <= 0) {
        s === 0 ? r.moveTo(l.x, l.y) : r.lineTo(l.x, l.y);
        continue;
      }
      const c = e[s], h = e[(s + 2) % o], f = i(c, l);
      let d;
      if (f < 1e-4) d = l;
      else {
        const g = Math.min(f / 2, u);
        d = a(l, c, g / f);
      }
      const p = i(h, l);
      let v;
      if (p < 1e-4) v = l;
      else {
        const g = Math.min(p / 2, u);
        v = a(l, h, g / p);
      }
      s === 0 ? r.moveTo(d.x, d.y) : r.lineTo(d.x, d.y), r.quadraticCurveTo(l.x, l.y, v.x, v.y, n);
    }
  }
  const l1e = new gr();
  class u1e {
    constructor(e) {
      this.shapePrimitives = [], this._currentPoly = null, this._bounds = new ui(), this._graphicsPath2D = e, this.signed = e.checkForHoles;
    }
    moveTo(e, t) {
      return this.startPoly(e, t), this;
    }
    lineTo(e, t) {
      this._ensurePoly();
      const n = this._currentPoly.points, i = n[n.length - 2], a = n[n.length - 1];
      return (i !== e || a !== t) && n.push(e, t), this;
    }
    arc(e, t, n, i, a, o) {
      this._ensurePoly(false);
      const s = this._currentPoly.points;
      return qV(s, e, t, n, i, a, o), this;
    }
    arcTo(e, t, n, i, a) {
      this._ensurePoly();
      const o = this._currentPoly.points;
      return r1e(o, e, t, n, i, a), this;
    }
    arcToSvg(e, t, n, i, a, o, s) {
      const l = this._currentPoly.points;
      return a1e(l, this._currentPoly.lastX, this._currentPoly.lastY, o, s, e, t, n, i, a), this;
    }
    bezierCurveTo(e, t, n, i, a, o, s) {
      this._ensurePoly();
      const l = this._currentPoly;
      return XV(this._currentPoly.points, l.lastX, l.lastY, e, t, n, i, a, o, s), this;
    }
    quadraticCurveTo(e, t, n, i, a) {
      this._ensurePoly();
      const o = this._currentPoly;
      return e1e(this._currentPoly.points, o.lastX, o.lastY, e, t, n, i, a), this;
    }
    closePath() {
      return this.endPoly(true), this;
    }
    addPath(e, t) {
      this.endPoly(), t && !t.isIdentity() && (e = e.clone(true), e.transform(t));
      const n = this.shapePrimitives, i = n.length;
      for (let a = 0; a < e.instructions.length; a++) {
        const o = e.instructions[a];
        this[o.action](...o.data);
      }
      if (e.checkForHoles && n.length - i > 1) {
        let a = null;
        for (let o = i; o < n.length; o++) {
          const s = n[o];
          if (s.shape.type === "polygon") {
            const l = s.shape, u = a == null ? void 0 : a.shape;
            u && u.containsPolygon(l) ? (a.holes || (a.holes = []), a.holes.push(s), n.copyWithin(o, o + 1), n.length--, o--) : a = s;
          }
        }
      }
      return this;
    }
    finish(e = false) {
      this.endPoly(e);
    }
    rect(e, t, n, i, a) {
      return this.drawShape(new gr(e, t, n, i), a), this;
    }
    circle(e, t, n, i) {
      return this.drawShape(new gw(e, t, n), i), this;
    }
    poly(e, t, n) {
      const i = new hh(e);
      return i.closePath = t, this.drawShape(i, n), this;
    }
    regularPoly(e, t, n, i, a = 0, o) {
      i = Math.max(i | 0, 3);
      const s = -1 * Math.PI / 2 + a, l = Math.PI * 2 / i, u = [];
      for (let c = 0; c < i; c++) {
        const h = s - c * l;
        u.push(e + n * Math.cos(h), t + n * Math.sin(h));
      }
      return this.poly(u, true, o), this;
    }
    roundPoly(e, t, n, i, a, o = 0, s) {
      if (i = Math.max(i | 0, 3), a <= 0) return this.regularPoly(e, t, n, i, o);
      const l = n * Math.sin(Math.PI / i) - 1e-3;
      a = Math.min(a, l);
      const u = -1 * Math.PI / 2 + o, c = Math.PI * 2 / i, h = (i - 2) * Math.PI / i / 2;
      for (let f = 0; f < i; f++) {
        const d = f * c + u, p = e + n * Math.cos(d), v = t + n * Math.sin(d), g = d + Math.PI + h, m = d - Math.PI - h, y = p + a * Math.cos(g), x = v + a * Math.sin(g), _ = p + a * Math.cos(m), S = v + a * Math.sin(m);
        f === 0 ? this.moveTo(y, x) : this.lineTo(y, x), this.quadraticCurveTo(p, v, _, S, s);
      }
      return this.closePath();
    }
    roundShape(e, t, n = false, i) {
      return e.length < 3 ? this : (n ? s1e(this, e, t, i) : o1e(this, e, t), this.closePath());
    }
    filletRect(e, t, n, i, a) {
      if (a === 0) return this.rect(e, t, n, i);
      const o = Math.min(n, i) / 2, s = Math.min(o, Math.max(-o, a)), l = e + n, u = t + i, c = s < 0 ? -s : 0, h = Math.abs(s);
      return this.moveTo(e, t + h).arcTo(e + c, t + c, e + h, t, h).lineTo(l - h, t).arcTo(l - c, t + c, l, t + h, h).lineTo(l, u - h).arcTo(l - c, u - c, e + n - h, u, h).lineTo(e + h, u).arcTo(e + c, u - c, e, u - h, h).closePath();
    }
    chamferRect(e, t, n, i, a, o) {
      if (a <= 0) return this.rect(e, t, n, i);
      const s = Math.min(a, Math.min(n, i) / 2), l = e + n, u = t + i, c = [
        e + s,
        t,
        l - s,
        t,
        l,
        t + s,
        l,
        u - s,
        l - s,
        u,
        e + s,
        u,
        e,
        u - s,
        e,
        t + s
      ];
      for (let h = c.length - 1; h >= 2; h -= 2) c[h] === c[h - 2] && c[h - 1] === c[h - 3] && c.splice(h - 1, 2);
      return this.poly(c, true, o);
    }
    ellipse(e, t, n, i, a) {
      return this.drawShape(new mw(e, t, n, i), a), this;
    }
    roundRect(e, t, n, i, a, o) {
      return this.drawShape(new yw(e, t, n, i, a), o), this;
    }
    drawShape(e, t) {
      return this.endPoly(), this.shapePrimitives.push({
        shape: e,
        transform: t
      }), this;
    }
    startPoly(e, t) {
      let n = this._currentPoly;
      return n && this.endPoly(), n = new hh(), n.points.push(e, t), this._currentPoly = n, this;
    }
    endPoly(e = false) {
      const t = this._currentPoly;
      return t && t.points.length > 2 && (t.closePath = e, this.shapePrimitives.push({
        shape: t
      })), this._currentPoly = null, this;
    }
    _ensurePoly(e = true) {
      if (!this._currentPoly && (this._currentPoly = new hh(), e)) {
        const t = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (t) {
          let n = t.shape.x, i = t.shape.y;
          if (t.transform && !t.transform.isIdentity()) {
            const a = t.transform, o = n;
            n = a.a * n + a.c * i + a.tx, i = a.b * o + a.d * i + a.ty;
          }
          this._currentPoly.points.push(n, i);
        } else this._currentPoly.points.push(0, 0);
      }
    }
    buildPath() {
      const e = this._graphicsPath2D;
      this.shapePrimitives.length = 0, this._currentPoly = null;
      for (let t = 0; t < e.instructions.length; t++) {
        const n = e.instructions[t];
        this[n.action](...n.data);
      }
      this.finish();
    }
    get bounds() {
      const e = this._bounds;
      e.clear();
      const t = this.shapePrimitives;
      for (let n = 0; n < t.length; n++) {
        const i = t[n], a = i.shape.getBounds(l1e);
        i.transform ? e.addRect(a, i.transform) : e.addRect(a);
      }
      return e;
    }
  }
  class Su {
    constructor(e, t = false) {
      this.instructions = [], this.uid = Qt("graphicsPath"), this._dirty = true, this.checkForHoles = t, typeof e == "string" ? L_e(e, this) : this.instructions = (e == null ? void 0 : e.slice()) ?? [];
    }
    get shapePath() {
      return this._shapePath || (this._shapePath = new u1e(this)), this._dirty && (this._dirty = false, this._shapePath.buildPath()), this._shapePath;
    }
    addPath(e, t) {
      return e = e.clone(), this.instructions.push({
        action: "addPath",
        data: [
          e,
          t
        ]
      }), this._dirty = true, this;
    }
    arc(...e) {
      return this.instructions.push({
        action: "arc",
        data: e
      }), this._dirty = true, this;
    }
    arcTo(...e) {
      return this.instructions.push({
        action: "arcTo",
        data: e
      }), this._dirty = true, this;
    }
    arcToSvg(...e) {
      return this.instructions.push({
        action: "arcToSvg",
        data: e
      }), this._dirty = true, this;
    }
    bezierCurveTo(...e) {
      return this.instructions.push({
        action: "bezierCurveTo",
        data: e
      }), this._dirty = true, this;
    }
    bezierCurveToShort(e, t, n, i, a) {
      const o = this.instructions[this.instructions.length - 1], s = this.getLastPoint(Dr.shared);
      let l = 0, u = 0;
      if (!o || o.action !== "bezierCurveTo") l = s.x, u = s.y;
      else {
        l = o.data[2], u = o.data[3];
        const c = s.x, h = s.y;
        l = c + (c - l), u = h + (h - u);
      }
      return this.instructions.push({
        action: "bezierCurveTo",
        data: [
          l,
          u,
          e,
          t,
          n,
          i,
          a
        ]
      }), this._dirty = true, this;
    }
    closePath() {
      return this.instructions.push({
        action: "closePath",
        data: []
      }), this._dirty = true, this;
    }
    ellipse(...e) {
      return this.instructions.push({
        action: "ellipse",
        data: e
      }), this._dirty = true, this;
    }
    lineTo(...e) {
      return this.instructions.push({
        action: "lineTo",
        data: e
      }), this._dirty = true, this;
    }
    moveTo(...e) {
      return this.instructions.push({
        action: "moveTo",
        data: e
      }), this;
    }
    quadraticCurveTo(...e) {
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: e
      }), this._dirty = true, this;
    }
    quadraticCurveToShort(e, t, n) {
      const i = this.instructions[this.instructions.length - 1], a = this.getLastPoint(Dr.shared);
      let o = 0, s = 0;
      if (!i || i.action !== "quadraticCurveTo") o = a.x, s = a.y;
      else {
        o = i.data[0], s = i.data[1];
        const l = a.x, u = a.y;
        o = l + (l - o), s = u + (u - s);
      }
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: [
          o,
          s,
          e,
          t,
          n
        ]
      }), this._dirty = true, this;
    }
    rect(e, t, n, i, a) {
      return this.instructions.push({
        action: "rect",
        data: [
          e,
          t,
          n,
          i,
          a
        ]
      }), this._dirty = true, this;
    }
    circle(e, t, n, i) {
      return this.instructions.push({
        action: "circle",
        data: [
          e,
          t,
          n,
          i
        ]
      }), this._dirty = true, this;
    }
    roundRect(...e) {
      return this.instructions.push({
        action: "roundRect",
        data: e
      }), this._dirty = true, this;
    }
    poly(...e) {
      return this.instructions.push({
        action: "poly",
        data: e
      }), this._dirty = true, this;
    }
    regularPoly(...e) {
      return this.instructions.push({
        action: "regularPoly",
        data: e
      }), this._dirty = true, this;
    }
    roundPoly(...e) {
      return this.instructions.push({
        action: "roundPoly",
        data: e
      }), this._dirty = true, this;
    }
    roundShape(...e) {
      return this.instructions.push({
        action: "roundShape",
        data: e
      }), this._dirty = true, this;
    }
    filletRect(...e) {
      return this.instructions.push({
        action: "filletRect",
        data: e
      }), this._dirty = true, this;
    }
    chamferRect(...e) {
      return this.instructions.push({
        action: "chamferRect",
        data: e
      }), this._dirty = true, this;
    }
    star(e, t, n, i, a, o, s) {
      a || (a = i / 2);
      const l = -1 * Math.PI / 2 + o, u = n * 2, c = Math.PI * 2 / u, h = [];
      for (let f = 0; f < u; f++) {
        const d = f % 2 ? a : i, p = f * c + l;
        h.push(e + d * Math.cos(p), t + d * Math.sin(p));
      }
      return this.poly(h, true, s), this;
    }
    clone(e = false) {
      const t = new Su();
      if (t.checkForHoles = this.checkForHoles, !e) t.instructions = this.instructions.slice();
      else for (let n = 0; n < this.instructions.length; n++) {
        const i = this.instructions[n];
        t.instructions.push({
          action: i.action,
          data: i.data.slice()
        });
      }
      return t;
    }
    clear() {
      return this.instructions.length = 0, this._dirty = true, this;
    }
    transform(e) {
      if (e.isIdentity()) return this;
      const t = e.a, n = e.b, i = e.c, a = e.d, o = e.tx, s = e.ty;
      let l = 0, u = 0, c = 0, h = 0, f = 0, d = 0, p = 0, v = 0;
      for (let g = 0; g < this.instructions.length; g++) {
        const m = this.instructions[g], y = m.data;
        switch (m.action) {
          case "moveTo":
          case "lineTo":
            l = y[0], u = y[1], y[0] = t * l + i * u + o, y[1] = n * l + a * u + s;
            break;
          case "bezierCurveTo":
            c = y[0], h = y[1], f = y[2], d = y[3], l = y[4], u = y[5], y[0] = t * c + i * h + o, y[1] = n * c + a * h + s, y[2] = t * f + i * d + o, y[3] = n * f + a * d + s, y[4] = t * l + i * u + o, y[5] = n * l + a * u + s;
            break;
          case "quadraticCurveTo":
            c = y[0], h = y[1], l = y[2], u = y[3], y[0] = t * c + i * h + o, y[1] = n * c + a * h + s, y[2] = t * l + i * u + o, y[3] = n * l + a * u + s;
            break;
          case "arcToSvg":
            l = y[5], u = y[6], p = y[0], v = y[1], y[0] = t * p + i * v, y[1] = n * p + a * v, y[5] = t * l + i * u + o, y[6] = n * l + a * u + s;
            break;
          case "circle":
            y[4] = Ac(y[3], e);
            break;
          case "rect":
            y[4] = Ac(y[4], e);
            break;
          case "ellipse":
            y[8] = Ac(y[8], e);
            break;
          case "roundRect":
            y[5] = Ac(y[5], e);
            break;
          case "addPath":
            y[0].transform(e);
            break;
          case "poly":
            y[2] = Ac(y[2], e);
            break;
          default:
            mn("unknown transform action", m.action);
            break;
        }
      }
      return this._dirty = true, this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(e) {
      let t = this.instructions.length - 1, n = this.instructions[t];
      if (!n) return e.x = 0, e.y = 0, e;
      for (; n.action === "closePath"; ) {
        if (t--, t < 0) return e.x = 0, e.y = 0, e;
        n = this.instructions[t];
      }
      switch (n.action) {
        case "moveTo":
        case "lineTo":
          e.x = n.data[0], e.y = n.data[1];
          break;
        case "quadraticCurveTo":
          e.x = n.data[2], e.y = n.data[3];
          break;
        case "bezierCurveTo":
          e.x = n.data[4], e.y = n.data[5];
          break;
        case "arc":
        case "arcToSvg":
          e.x = n.data[5], e.y = n.data[6];
          break;
        case "addPath":
          n.data[0].getLastPoint(e);
          break;
      }
      return e;
    }
  }
  function Ac(r, e) {
    return r ? r.prepend(e) : e.clone();
  }
  function zt(r, e, t) {
    const n = r.getAttribute(e);
    return n ? Number(n) : t;
  }
  function c1e(r, e) {
    const t = r.querySelectorAll("defs");
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      for (let a = 0; a < i.children.length; a++) {
        const o = i.children[a];
        switch (o.nodeName.toLowerCase()) {
          case "lineargradient":
            e.defs[o.id] = h1e(o);
            break;
          case "radialgradient":
            e.defs[o.id] = f1e();
            break;
        }
      }
    }
  }
  function h1e(r) {
    const e = zt(r, "x1", 0), t = zt(r, "y1", 0), n = zt(r, "x2", 1), i = zt(r, "y2", 0), a = r.getAttribute("gradientUnits") || "objectBoundingBox", o = new Hs(e, t, n, i, a === "objectBoundingBox" ? "local" : "global");
    for (let s = 0; s < r.children.length; s++) {
      const l = r.children[s], u = zt(l, "offset", 0), c = kr.shared.setValue(l.getAttribute("stop-color")).toNumber();
      o.addColorStop(u, c);
    }
    return o;
  }
  function f1e(r) {
    return mn("[SVG Parser] Radial gradients are not yet supported"), new Hs(0, 0, 1, 0);
  }
  function Ak(r) {
    const e = r.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return e ? e[1] : "";
  }
  const Ik = {
    fill: {
      type: "paint",
      default: 0
    },
    "fill-opacity": {
      type: "number",
      default: 1
    },
    stroke: {
      type: "paint",
      default: 0
    },
    "stroke-width": {
      type: "number",
      default: 1
    },
    "stroke-opacity": {
      type: "number",
      default: 1
    },
    "stroke-linecap": {
      type: "string",
      default: "butt"
    },
    "stroke-linejoin": {
      type: "string",
      default: "miter"
    },
    "stroke-miterlimit": {
      type: "number",
      default: 10
    },
    "stroke-dasharray": {
      type: "string",
      default: "none"
    },
    "stroke-dashoffset": {
      type: "number",
      default: 0
    },
    opacity: {
      type: "number",
      default: 1
    }
  };
  function KV(r, e) {
    const t = r.getAttribute("style"), n = {}, i = {}, a = {
      strokeStyle: n,
      fillStyle: i,
      useFill: false,
      useStroke: false
    };
    for (const o in Ik) {
      const s = r.getAttribute(o);
      s && Mk(e, a, o, s.trim());
    }
    if (t) {
      const o = t.split(";");
      for (let s = 0; s < o.length; s++) {
        const l = o[s].trim(), [u, c] = l.split(":");
        Ik[u] && Mk(e, a, u, c.trim());
      }
    }
    return {
      strokeStyle: a.useStroke ? n : null,
      fillStyle: a.useFill ? i : null,
      useFill: a.useFill,
      useStroke: a.useStroke
    };
  }
  function Mk(r, e, t, n) {
    switch (t) {
      case "stroke":
        if (n !== "none") {
          if (n.startsWith("url(")) {
            const i = Ak(n);
            e.strokeStyle.fill = r.defs[i];
          } else e.strokeStyle.color = kr.shared.setValue(n).toNumber();
          e.useStroke = true;
        }
        break;
      case "stroke-width":
        e.strokeStyle.width = Number(n);
        break;
      case "fill":
        if (n !== "none") {
          if (n.startsWith("url(")) {
            const i = Ak(n);
            e.fillStyle.fill = r.defs[i];
          } else e.fillStyle.color = kr.shared.setValue(n).toNumber();
          e.useFill = true;
        }
        break;
      case "fill-opacity":
        e.fillStyle.alpha = Number(n);
        break;
      case "stroke-opacity":
        e.strokeStyle.alpha = Number(n);
        break;
      case "opacity":
        e.fillStyle.alpha = Number(n), e.strokeStyle.alpha = Number(n);
        break;
    }
  }
  function d1e(r, e) {
    if (typeof r == "string") {
      const o = document.createElement("div");
      o.innerHTML = r.trim(), r = o.querySelector("svg");
    }
    const t = {
      context: e,
      defs: {},
      path: new Su()
    };
    c1e(r, t);
    const n = r.children, { fillStyle: i, strokeStyle: a } = KV(r, t);
    for (let o = 0; o < n.length; o++) {
      const s = n[o];
      s.nodeName.toLowerCase() !== "defs" && ZV(s, t, i, a);
    }
    return e;
  }
  function ZV(r, e, t, n) {
    const i = r.children, { fillStyle: a, strokeStyle: o } = KV(r, e);
    a && t ? t = {
      ...t,
      ...a
    } : a && (t = a), o && n ? n = {
      ...n,
      ...o
    } : o && (n = o);
    const s = !t && !n;
    s && (t = {
      color: 0
    });
    let l, u, c, h, f, d, p, v, g, m, y, x, _, S, b, w, C;
    switch (r.nodeName.toLowerCase()) {
      case "path":
        S = r.getAttribute("d"), r.getAttribute("fill-rule") === "evenodd" && mn("SVG Evenodd fill rule not supported, your svg may render incorrectly"), b = new Su(S, true), e.context.path(b), t && e.context.fill(t), n && e.context.stroke(n);
        break;
      case "circle":
        p = zt(r, "cx", 0), v = zt(r, "cy", 0), g = zt(r, "r", 0), e.context.ellipse(p, v, g, g), t && e.context.fill(t), n && e.context.stroke(n);
        break;
      case "rect":
        l = zt(r, "x", 0), u = zt(r, "y", 0), w = zt(r, "width", 0), C = zt(r, "height", 0), m = zt(r, "rx", 0), y = zt(r, "ry", 0), m || y ? e.context.roundRect(l, u, w, C, m || y) : e.context.rect(l, u, w, C), t && e.context.fill(t), n && e.context.stroke(n);
        break;
      case "ellipse":
        p = zt(r, "cx", 0), v = zt(r, "cy", 0), m = zt(r, "rx", 0), y = zt(r, "ry", 0), e.context.beginPath(), e.context.ellipse(p, v, m, y), t && e.context.fill(t), n && e.context.stroke(n);
        break;
      case "line":
        c = zt(r, "x1", 0), h = zt(r, "y1", 0), f = zt(r, "x2", 0), d = zt(r, "y2", 0), e.context.beginPath(), e.context.moveTo(c, h), e.context.lineTo(f, d), n && e.context.stroke(n);
        break;
      case "polygon":
        _ = r.getAttribute("points"), x = _.match(/\d+/g).map((T) => parseInt(T, 10)), e.context.poly(x, true), t && e.context.fill(t), n && e.context.stroke(n);
        break;
      case "polyline":
        _ = r.getAttribute("points"), x = _.match(/\d+/g).map((T) => parseInt(T, 10)), e.context.poly(x, false), n && e.context.stroke(n);
        break;
      case "g":
      case "svg":
        break;
      default: {
        mn(`[SVG parser] <${r.nodeName}> elements unsupported`);
        break;
      }
    }
    s && (t = null);
    for (let T = 0; T < i.length; T++) ZV(i[T], e, t, n);
  }
  function p1e(r) {
    return kr.isColorLike(r);
  }
  function Dk(r) {
    return r instanceof vw;
  }
  function Pk(r) {
    return r instanceof Hs;
  }
  function v1e(r) {
    return r instanceof At;
  }
  function g1e(r, e, t) {
    const n = kr.shared.setValue(e ?? 0);
    return r.color = n.toNumber(), r.alpha = n.alpha === 1 ? t.alpha : n.alpha, r.texture = At.WHITE, {
      ...t,
      ...r
    };
  }
  function m1e(r, e, t) {
    return r.texture = e, {
      ...t,
      ...r
    };
  }
  function kk(r, e, t) {
    return r.fill = e, r.color = 16777215, r.texture = e.texture, r.matrix = e.transform, {
      ...t,
      ...r
    };
  }
  function Lk(r, e, t) {
    return e.buildGradient(), r.fill = e, r.color = 16777215, r.texture = e.texture, r.matrix = e.transform, r.textureSpace = e.textureSpace, {
      ...t,
      ...r
    };
  }
  function y1e(r, e) {
    const t = {
      ...e,
      ...r
    }, n = kr.shared.setValue(t.color);
    return t.alpha *= n.alpha, t.color = n.toNumber(), t;
  }
  function ws(r, e) {
    if (r == null) return null;
    const t = {}, n = r;
    return p1e(r) ? g1e(t, r, e) : v1e(r) ? m1e(t, r, e) : Dk(r) ? kk(t, r, e) : Pk(r) ? Lk(t, r, e) : n.fill && Dk(n.fill) ? kk(n, n.fill, e) : n.fill && Pk(n.fill) ? Lk(n, n.fill, e) : y1e(n, e);
  }
  function Fv(r, e) {
    const { width: t, alignment: n, miterLimit: i, cap: a, join: o, pixelLine: s, ...l } = e, u = ws(r, l);
    return u ? {
      width: t,
      alignment: n,
      miterLimit: i,
      cap: a,
      join: o,
      pixelLine: s,
      ...u
    } : null;
  }
  const x1e = new Dr(), Rk = new pt(), _w = class wi extends Yi {
    constructor() {
      super(...arguments), this.uid = Qt("graphicsContext"), this.dirty = true, this.batchMode = "auto", this.instructions = [], this._activePath = new Su(), this._transform = new pt(), this._fillStyle = {
        ...wi.defaultFillStyle
      }, this._strokeStyle = {
        ...wi.defaultStrokeStyle
      }, this._stateStack = [], this._tick = 0, this._bounds = new ui(), this._boundsDirty = true;
    }
    clone() {
      const e = new wi();
      return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = {
        ...this._fillStyle
      }, e._strokeStyle = {
        ...this._strokeStyle
      }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = true, e;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(e) {
      this._fillStyle = ws(e, wi.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(e) {
      this._strokeStyle = Fv(e, wi.defaultStrokeStyle);
    }
    setFillStyle(e) {
      return this._fillStyle = ws(e, wi.defaultFillStyle), this;
    }
    setStrokeStyle(e) {
      return this._strokeStyle = ws(e, wi.defaultStrokeStyle), this;
    }
    texture(e, t, n, i, a, o) {
      return this.instructions.push({
        action: "texture",
        data: {
          image: e,
          dx: n || 0,
          dy: i || 0,
          dw: a || e.frame.width,
          dh: o || e.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: t ? kr.shared.setValue(t).toNumber() : 16777215
        }
      }), this.onUpdate(), this;
    }
    beginPath() {
      return this._activePath = new Su(), this;
    }
    fill(e, t) {
      let n;
      const i = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && i && i.action === "stroke" ? n = i.data.path : n = this._activePath.clone(), n ? (e != null && (t !== void 0 && typeof e == "number" && (Pt($t, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = {
        color: e,
        alpha: t
      }), this._fillStyle = ws(e, wi.defaultFillStyle)), this.instructions.push({
        action: "fill",
        data: {
          style: this.fillStyle,
          path: n
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    _initNextPathLocation() {
      const { x: e, y: t } = this._activePath.getLastPoint(Dr.shared);
      this._activePath.clear(), this._activePath.moveTo(e, t);
    }
    stroke(e) {
      let t;
      const n = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && n && n.action === "fill" ? t = n.data.path : t = this._activePath.clone(), t ? (e != null && (this._strokeStyle = Fv(e, wi.defaultStrokeStyle)), this.instructions.push({
        action: "stroke",
        data: {
          style: this.strokeStyle,
          path: t
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    cut() {
      for (let e = 0; e < 2; e++) {
        const t = this.instructions[this.instructions.length - 1 - e], n = this._activePath.clone();
        if (t && (t.action === "stroke" || t.action === "fill")) if (t.data.hole) t.data.hole.addPath(n);
        else {
          t.data.hole = n;
          break;
        }
      }
      return this._initNextPathLocation(), this;
    }
    arc(e, t, n, i, a, o) {
      this._tick++;
      const s = this._transform;
      return this._activePath.arc(s.a * e + s.c * t + s.tx, s.b * e + s.d * t + s.ty, n, i, a, o), this;
    }
    arcTo(e, t, n, i, a) {
      this._tick++;
      const o = this._transform;
      return this._activePath.arcTo(o.a * e + o.c * t + o.tx, o.b * e + o.d * t + o.ty, o.a * n + o.c * i + o.tx, o.b * n + o.d * i + o.ty, a), this;
    }
    arcToSvg(e, t, n, i, a, o, s) {
      this._tick++;
      const l = this._transform;
      return this._activePath.arcToSvg(e, t, n, i, a, l.a * o + l.c * s + l.tx, l.b * o + l.d * s + l.ty), this;
    }
    bezierCurveTo(e, t, n, i, a, o, s) {
      this._tick++;
      const l = this._transform;
      return this._activePath.bezierCurveTo(l.a * e + l.c * t + l.tx, l.b * e + l.d * t + l.ty, l.a * n + l.c * i + l.tx, l.b * n + l.d * i + l.ty, l.a * a + l.c * o + l.tx, l.b * a + l.d * o + l.ty, s), this;
    }
    closePath() {
      var _a2;
      return this._tick++, (_a2 = this._activePath) == null ? void 0 : _a2.closePath(), this;
    }
    ellipse(e, t, n, i) {
      return this._tick++, this._activePath.ellipse(e, t, n, i, this._transform.clone()), this;
    }
    circle(e, t, n) {
      return this._tick++, this._activePath.circle(e, t, n, this._transform.clone()), this;
    }
    path(e) {
      return this._tick++, this._activePath.addPath(e, this._transform.clone()), this;
    }
    lineTo(e, t) {
      this._tick++;
      const n = this._transform;
      return this._activePath.lineTo(n.a * e + n.c * t + n.tx, n.b * e + n.d * t + n.ty), this;
    }
    moveTo(e, t) {
      this._tick++;
      const n = this._transform, i = this._activePath.instructions, a = n.a * e + n.c * t + n.tx, o = n.b * e + n.d * t + n.ty;
      return i.length === 1 && i[0].action === "moveTo" ? (i[0].data[0] = a, i[0].data[1] = o, this) : (this._activePath.moveTo(a, o), this);
    }
    quadraticCurveTo(e, t, n, i, a) {
      this._tick++;
      const o = this._transform;
      return this._activePath.quadraticCurveTo(o.a * e + o.c * t + o.tx, o.b * e + o.d * t + o.ty, o.a * n + o.c * i + o.tx, o.b * n + o.d * i + o.ty, a), this;
    }
    rect(e, t, n, i) {
      return this._tick++, this._activePath.rect(e, t, n, i, this._transform.clone()), this;
    }
    roundRect(e, t, n, i, a) {
      return this._tick++, this._activePath.roundRect(e, t, n, i, a, this._transform.clone()), this;
    }
    poly(e, t) {
      return this._tick++, this._activePath.poly(e, t, this._transform.clone()), this;
    }
    regularPoly(e, t, n, i, a = 0, o) {
      return this._tick++, this._activePath.regularPoly(e, t, n, i, a, o), this;
    }
    roundPoly(e, t, n, i, a, o) {
      return this._tick++, this._activePath.roundPoly(e, t, n, i, a, o), this;
    }
    roundShape(e, t, n, i) {
      return this._tick++, this._activePath.roundShape(e, t, n, i), this;
    }
    filletRect(e, t, n, i, a) {
      return this._tick++, this._activePath.filletRect(e, t, n, i, a), this;
    }
    chamferRect(e, t, n, i, a, o) {
      return this._tick++, this._activePath.chamferRect(e, t, n, i, a, o), this;
    }
    star(e, t, n, i, a = 0, o = 0) {
      return this._tick++, this._activePath.star(e, t, n, i, a, o, this._transform.clone()), this;
    }
    svg(e) {
      return this._tick++, d1e(e, this), this;
    }
    restore() {
      const e = this._stateStack.pop();
      return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this;
    }
    save() {
      return this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: {
          ...this._fillStyle
        },
        strokeStyle: {
          ...this._strokeStyle
        }
      }), this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      return this._transform.identity(), this;
    }
    rotate(e) {
      return this._transform.rotate(e), this;
    }
    scale(e, t = e) {
      return this._transform.scale(e, t), this;
    }
    setTransform(e, t, n, i, a, o) {
      return e instanceof pt ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, t, n, i, a, o), this);
    }
    transform(e, t, n, i, a, o) {
      return e instanceof pt ? (this._transform.append(e), this) : (Rk.set(e, t, n, i, a, o), this._transform.append(Rk), this);
    }
    translate(e, t = e) {
      return this._transform.translate(e, t), this;
    }
    clear() {
      return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
    }
    onUpdate() {
      this.dirty || (this.emit("update", this, 16), this.dirty = true, this._boundsDirty = true);
    }
    get bounds() {
      if (!this._boundsDirty) return this._bounds;
      const e = this._bounds;
      e.clear();
      for (let t = 0; t < this.instructions.length; t++) {
        const n = this.instructions[t], i = n.action;
        if (i === "fill") {
          const a = n.data;
          e.addBounds(a.path.bounds);
        } else if (i === "texture") {
          const a = n.data;
          e.addFrame(a.dx, a.dy, a.dx + a.dw, a.dy + a.dh, a.transform);
        }
        if (i === "stroke") {
          const a = n.data, o = a.style.alignment, s = a.style.width * (1 - o), l = a.path.bounds;
          e.addFrame(l.minX - s, l.minY - s, l.maxX + s, l.maxY + s);
        }
      }
      return e;
    }
    containsPoint(e) {
      var _a2;
      if (!this.bounds.containsPoint(e.x, e.y)) return false;
      const t = this.instructions;
      let n = false;
      for (let i = 0; i < t.length; i++) {
        const a = t[i], o = a.data, s = o.path;
        if (!a.action || !s) continue;
        const l = o.style, u = s.shapePath.shapePrimitives;
        for (let c = 0; c < u.length; c++) {
          const h = u[c].shape;
          if (!l || !h) continue;
          const f = u[c].transform, d = f ? f.applyInverse(e, x1e) : e;
          if (a.action === "fill") n = h.contains(d.x, d.y);
          else {
            const v = l;
            n = h.strokeContains(d.x, d.y, v.width, v.alignment);
          }
          const p = o.hole;
          if (p) {
            const v = (_a2 = p.shapePath) == null ? void 0 : _a2.shapePrimitives;
            if (v) for (let g = 0; g < v.length; g++) v[g].shape.contains(d.x, d.y) && (n = false);
          }
          if (n) return true;
        }
      }
      return n;
    }
    destroy(e = false) {
      if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const n = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        this._fillStyle.texture && this._fillStyle.texture.destroy(n), this._strokeStyle.texture && this._strokeStyle.texture.destroy(n);
      }
      this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
    }
  };
  _w.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: At.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local"
  };
  _w.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: At.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: false
  };
  let Jn = _w;
  const Ek = [
    "align",
    "breakWords",
    "cssOverrides",
    "fontVariant",
    "fontWeight",
    "leading",
    "letterSpacing",
    "lineHeight",
    "padding",
    "textBaseline",
    "trim",
    "whiteSpace",
    "wordWrap",
    "wordWrapWidth",
    "fontFamily",
    "fontStyle",
    "fontSize"
  ];
  _1e = function(r) {
    const e = [];
    let t = 0;
    for (let n = 0; n < Ek.length; n++) {
      const i = `_${Ek[n]}`;
      e[t++] = r[i];
    }
    return t = jV(r._fill, e, t), t = b1e(r._stroke, e, t), t = S1e(r.dropShadow, e, t), e.join("-");
  };
  function jV(r, e, t) {
    var _a2;
    return r && (e[t++] = r.color, e[t++] = r.alpha, e[t++] = (_a2 = r.fill) == null ? void 0 : _a2.styleKey), t;
  }
  function b1e(r, e, t) {
    return r && (t = jV(r, e, t), e[t++] = r.width, e[t++] = r.alignment, e[t++] = r.cap, e[t++] = r.join, e[t++] = r.miterLimit), t;
  }
  function S1e(r, e, t) {
    return r && (e[t++] = r.alpha, e[t++] = r.angle, e[t++] = r.blur, e[t++] = r.distance, e[t++] = kr.shared.setValue(r.color).toNumber()), t;
  }
  const bw = class Hl extends Yi {
    constructor(e = {}) {
      super(), w1e(e);
      const t = {
        ...Hl.defaultTextStyle,
        ...e
      };
      for (const n in t) {
        const i = n;
        this[i] = t[n];
      }
      this.update();
    }
    get align() {
      return this._align;
    }
    set align(e) {
      this._align = e, this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(e) {
      this._breakWords = e, this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(e) {
      e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({
        ...Hl.defaultDropShadow,
        ...e
      }) : this._dropShadow = e ? this._createProxy({
        ...Hl.defaultDropShadow
      }) : null, this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(e) {
      this._fontFamily = e, this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(e) {
      typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(e) {
      this._fontStyle = e.toLowerCase(), this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(e) {
      this._fontVariant = e, this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(e) {
      this._fontWeight = e, this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(e) {
      this._leading = e, this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(e) {
      this._letterSpacing = e, this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(e) {
      this._lineHeight = e, this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(e) {
      this._padding = e, this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(e) {
      this._trim = e, this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(e) {
      this._textBaseline = e, this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(e) {
      this._whiteSpace = e, this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(e) {
      this._wordWrap = e, this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(e) {
      this._wordWrapWidth = e, this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(e) {
      e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({
        ...Jn.defaultFillStyle,
        ...e
      }, () => {
        this._fill = ws({
          ...this._originalFill
        }, Jn.defaultFillStyle);
      })), this._fill = ws(e === 0 ? "black" : e, Jn.defaultFillStyle), this.update());
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(e) {
      e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({
        ...Jn.defaultStrokeStyle,
        ...e
      }, () => {
        this._stroke = Fv({
          ...this._originalStroke
        }, Jn.defaultStrokeStyle);
      })), this._stroke = Fv(e, Jn.defaultStrokeStyle), this.update());
    }
    _generateKey() {
      return this._styleKey = _1e(this), this._styleKey;
    }
    update() {
      this._styleKey = null, this.emit("update", this);
    }
    reset() {
      const e = Hl.defaultTextStyle;
      for (const t in e) this[t] = e[t];
    }
    get styleKey() {
      return this._styleKey || this._generateKey();
    }
    clone() {
      return new Hl({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? {
          ...this._dropShadow
        } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth
      });
    }
    destroy(e = false) {
      var _a2, _b2, _c2, _d2;
      if (this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const n = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        ((_a2 = this._fill) == null ? void 0 : _a2.texture) && this._fill.texture.destroy(n), ((_b2 = this._originalFill) == null ? void 0 : _b2.texture) && this._originalFill.texture.destroy(n), ((_c2 = this._stroke) == null ? void 0 : _c2.texture) && this._stroke.texture.destroy(n), ((_d2 = this._originalStroke) == null ? void 0 : _d2.texture) && this._originalStroke.texture.destroy(n);
      }
      this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
    }
    _createProxy(e, t) {
      return new Proxy(e, {
        set: (n, i, a) => (n[i] = a, t == null ? void 0 : t(i, a), this.update(), true)
      });
    }
    _isFillStyle(e) {
      return (e ?? null) !== null && !(kr.isColorLike(e) || e instanceof Hs || e instanceof vw);
    }
  };
  bw.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
  };
  bw.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  yb = bw;
  function w1e(r) {
    const e = r;
    if (typeof e.dropShadow == "boolean" && e.dropShadow) {
      const t = yb.defaultDropShadow;
      r.dropShadow = {
        alpha: e.dropShadowAlpha ?? t.alpha,
        angle: e.dropShadowAngle ?? t.angle,
        blur: e.dropShadowBlur ?? t.blur,
        color: e.dropShadowColor ?? t.color,
        distance: e.dropShadowDistance ?? t.distance
      };
    }
    if (e.strokeThickness !== void 0) {
      Pt($t, "strokeThickness is now a part of stroke");
      const t = e.stroke;
      let n = {};
      if (kr.isColorLike(t)) n.color = t;
      else if (t instanceof Hs || t instanceof vw) n.fill = t;
      else if (Object.hasOwnProperty.call(t, "color") || Object.hasOwnProperty.call(t, "fill")) n = t;
      else throw new Error("Invalid stroke value.");
      r.stroke = {
        ...n,
        width: e.strokeThickness
      };
    }
    if (Array.isArray(e.fillGradientStops)) {
      Pt($t, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let t;
      r.fontSize == null ? r.fontSize = yb.defaultTextStyle.fontSize : typeof r.fontSize == "string" ? t = parseInt(r.fontSize, 10) : t = r.fontSize;
      const n = new Hs({
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: (t || 0) * 1.7
        }
      }), i = e.fillGradientStops.map((a) => kr.shared.setValue(a).toNumber());
      i.forEach((a, o) => {
        const s = o / (i.length - 1);
        n.addColorStop(s, a);
      }), r.fill = {
        fill: n
      };
    }
  }
  const C1e = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  T1e = function(r) {
    const e = typeof r.fontSize == "number" ? `${r.fontSize}px` : r.fontSize;
    let t = r.fontFamily;
    Array.isArray(r.fontFamily) || (t = r.fontFamily.split(","));
    for (let n = t.length - 1; n >= 0; n--) {
      let i = t[n].trim();
      !/([\"\'])[^\'\"]+\1/.test(i) && !C1e.includes(i) && (i = `"${i}"`), t[n] = i;
    }
    return `${r.fontStyle} ${r.fontVariant} ${r.fontWeight} ${e} ${t.join(",")}`;
  };
  const U0 = {
    willReadFrequently: true
  }, di = class ke {
    static get experimentalLetterSpacingSupported() {
      let e = ke._experimentalLetterSpacingSupported;
      if (e !== void 0) {
        const t = oi.get().getCanvasRenderingContext2D().prototype;
        e = ke._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t;
      }
      return e;
    }
    constructor(e, t, n, i, a, o, s, l, u) {
      this.text = e, this.style = t, this.width = n, this.height = i, this.lines = a, this.lineWidths = o, this.lineHeight = s, this.maxLineWidth = l, this.fontProperties = u;
    }
    static measureText(e = " ", t, n = ke._canvas, i = t.wordWrap) {
      var _a2;
      const a = `${e}:${t.styleKey}`;
      if (ke._measurementCache[a]) return ke._measurementCache[a];
      const o = T1e(t), s = ke.measureFont(o);
      s.fontSize === 0 && (s.fontSize = t.fontSize, s.ascent = t.fontSize);
      const l = ke.__context;
      l.font = o;
      const c = (i ? ke._wordWrap(e, t, n) : e).split(/(?:\r\n|\r|\n)/), h = new Array(c.length);
      let f = 0;
      for (let y = 0; y < c.length; y++) {
        const x = ke._measureText(c[y], t.letterSpacing, l);
        h[y] = x, f = Math.max(f, x);
      }
      const d = ((_a2 = t._stroke) == null ? void 0 : _a2.width) || 0;
      let p = f + d;
      t.dropShadow && (p += t.dropShadow.distance);
      const v = t.lineHeight || s.fontSize;
      let g = Math.max(v, s.fontSize + d) + (c.length - 1) * (v + t.leading);
      return t.dropShadow && (g += t.dropShadow.distance), new ke(e, t, p, g, c, h, v + t.leading, f, s);
    }
    static _measureText(e, t, n) {
      let i = false;
      ke.experimentalLetterSpacingSupported && (ke.experimentalLetterSpacing ? (n.letterSpacing = `${t}px`, n.textLetterSpacing = `${t}px`, i = true) : (n.letterSpacing = "0px", n.textLetterSpacing = "0px"));
      const a = n.measureText(e);
      let o = a.width;
      const s = -a.actualBoundingBoxLeft;
      let u = a.actualBoundingBoxRight - s;
      if (o > 0) if (i) o -= t, u -= t;
      else {
        const c = (ke.graphemeSegmenter(e).length - 1) * t;
        o += c, u += c;
      }
      return Math.max(o, u);
    }
    static _wordWrap(e, t, n = ke._canvas) {
      const i = n.getContext("2d", U0);
      let a = 0, o = "", s = "";
      const l = /* @__PURE__ */ Object.create(null), { letterSpacing: u, whiteSpace: c } = t, h = ke._collapseSpaces(c), f = ke._collapseNewlines(c);
      let d = !h;
      const p = t.wordWrapWidth + u, v = ke._tokenize(e);
      for (let g = 0; g < v.length; g++) {
        let m = v[g];
        if (ke._isNewline(m)) {
          if (!f) {
            s += ke._addLine(o), d = !h, o = "", a = 0;
            continue;
          }
          m = " ";
        }
        if (h) {
          const x = ke.isBreakingSpace(m), _ = ke.isBreakingSpace(o[o.length - 1]);
          if (x && _) continue;
        }
        const y = ke._getFromCache(m, u, l, i);
        if (y > p) if (o !== "" && (s += ke._addLine(o), o = "", a = 0), ke.canBreakWords(m, t.breakWords)) {
          const x = ke.wordWrapSplit(m);
          for (let _ = 0; _ < x.length; _++) {
            let S = x[_], b = S, w = 1;
            for (; x[_ + w]; ) {
              const T = x[_ + w];
              if (!ke.canBreakChars(b, T, m, _, t.breakWords)) S += T;
              else break;
              b = T, w++;
            }
            _ += w - 1;
            const C = ke._getFromCache(S, u, l, i);
            C + a > p && (s += ke._addLine(o), d = false, o = "", a = 0), o += S, a += C;
          }
        } else {
          o.length > 0 && (s += ke._addLine(o), o = "", a = 0);
          const x = g === v.length - 1;
          s += ke._addLine(m, !x), d = false, o = "", a = 0;
        }
        else y + a > p && (d = false, s += ke._addLine(o), o = "", a = 0), (o.length > 0 || !ke.isBreakingSpace(m) || d) && (o += m, a += y);
      }
      return s += ke._addLine(o, false), s;
    }
    static _addLine(e, t = true) {
      return e = ke._trimRight(e), e = t ? `${e}
` : e, e;
    }
    static _getFromCache(e, t, n, i) {
      let a = n[e];
      return typeof a != "number" && (a = ke._measureText(e, t, i) + t, n[e] = a), a;
    }
    static _collapseSpaces(e) {
      return e === "normal" || e === "pre-line";
    }
    static _collapseNewlines(e) {
      return e === "normal";
    }
    static _trimRight(e) {
      if (typeof e != "string") return "";
      for (let t = e.length - 1; t >= 0; t--) {
        const n = e[t];
        if (!ke.isBreakingSpace(n)) break;
        e = e.slice(0, -1);
      }
      return e;
    }
    static _isNewline(e) {
      return typeof e != "string" ? false : ke._newlines.includes(e.charCodeAt(0));
    }
    static isBreakingSpace(e, t) {
      return typeof e != "string" ? false : ke._breakingSpaces.includes(e.charCodeAt(0));
    }
    static _tokenize(e) {
      const t = [];
      let n = "";
      if (typeof e != "string") return t;
      for (let i = 0; i < e.length; i++) {
        const a = e[i], o = e[i + 1];
        if (ke.isBreakingSpace(a, o) || ke._isNewline(a)) {
          n !== "" && (t.push(n), n = ""), t.push(a);
          continue;
        }
        n += a;
      }
      return n !== "" && t.push(n), t;
    }
    static canBreakWords(e, t) {
      return t;
    }
    static canBreakChars(e, t, n, i, a) {
      return true;
    }
    static wordWrapSplit(e) {
      return ke.graphemeSegmenter(e);
    }
    static measureFont(e) {
      if (ke._fonts[e]) return ke._fonts[e];
      const t = ke._context;
      t.font = e;
      const n = t.measureText(ke.METRICS_STRING + ke.BASELINE_SYMBOL), i = {
        ascent: n.actualBoundingBoxAscent,
        descent: n.actualBoundingBoxDescent,
        fontSize: n.actualBoundingBoxAscent + n.actualBoundingBoxDescent
      };
      return ke._fonts[e] = i, i;
    }
    static clearMetrics(e = "") {
      e ? delete ke._fonts[e] : ke._fonts = {};
    }
    static get _canvas() {
      var _a2;
      if (!ke.__canvas) {
        let e;
        try {
          const t = new OffscreenCanvas(0, 0);
          if ((_a2 = t.getContext("2d", U0)) == null ? void 0 : _a2.measureText) return ke.__canvas = t, t;
          e = oi.get().createCanvas();
        } catch {
          e = oi.get().createCanvas();
        }
        e.width = e.height = 10, ke.__canvas = e;
      }
      return ke.__canvas;
    }
    static get _context() {
      return ke.__context || (ke.__context = ke._canvas.getContext("2d", U0)), ke.__context;
    }
  };
  di.METRICS_STRING = "|\xC9q\xC5";
  di.BASELINE_SYMBOL = "M";
  di.BASELINE_MULTIPLIER = 1.4;
  di.HEIGHT_MULTIPLIER = 2;
  di.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
      const r = new Intl.Segmenter();
      return (e) => [
        ...r.segment(e)
      ].map((t) => t.segment);
    }
    return (r) => [
      ...r
    ];
  })();
  di.experimentalLetterSpacing = false;
  di._fonts = {};
  di._newlines = [
    10,
    13
  ];
  di._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  di._measurementCache = {};
  A1e = di;
  Bv = class extends hw {
    constructor(e) {
      e instanceof Jn && (e = {
        context: e
      });
      const { context: t, roundPixels: n, ...i } = e || {};
      super({
        label: "Graphics",
        ...i
      }), this.renderPipeId = "graphics", t ? this._context = t : this._context = this._ownedContext = new Jn(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = false, this.roundPixels = n ?? false;
    }
    set context(e) {
      e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    updateBounds() {
    }
    containsPoint(e) {
      return this._context.containsPoint(e);
    }
    destroy(e) {
      this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === true || (e == null ? void 0 : e.context) === true) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e);
    }
    _callContextMethod(e, t) {
      return this.context[e](...t), this;
    }
    setFillStyle(...e) {
      return this._callContextMethod("setFillStyle", e);
    }
    setStrokeStyle(...e) {
      return this._callContextMethod("setStrokeStyle", e);
    }
    fill(...e) {
      return this._callContextMethod("fill", e);
    }
    stroke(...e) {
      return this._callContextMethod("stroke", e);
    }
    texture(...e) {
      return this._callContextMethod("texture", e);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...e) {
      return this._callContextMethod("arc", e);
    }
    arcTo(...e) {
      return this._callContextMethod("arcTo", e);
    }
    arcToSvg(...e) {
      return this._callContextMethod("arcToSvg", e);
    }
    bezierCurveTo(...e) {
      return this._callContextMethod("bezierCurveTo", e);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...e) {
      return this._callContextMethod("ellipse", e);
    }
    circle(...e) {
      return this._callContextMethod("circle", e);
    }
    path(...e) {
      return this._callContextMethod("path", e);
    }
    lineTo(...e) {
      return this._callContextMethod("lineTo", e);
    }
    moveTo(...e) {
      return this._callContextMethod("moveTo", e);
    }
    quadraticCurveTo(...e) {
      return this._callContextMethod("quadraticCurveTo", e);
    }
    rect(...e) {
      return this._callContextMethod("rect", e);
    }
    roundRect(...e) {
      return this._callContextMethod("roundRect", e);
    }
    poly(...e) {
      return this._callContextMethod("poly", e);
    }
    regularPoly(...e) {
      return this._callContextMethod("regularPoly", e);
    }
    roundPoly(...e) {
      return this._callContextMethod("roundPoly", e);
    }
    roundShape(...e) {
      return this._callContextMethod("roundShape", e);
    }
    filletRect(...e) {
      return this._callContextMethod("filletRect", e);
    }
    chamferRect(...e) {
      return this._callContextMethod("chamferRect", e);
    }
    star(...e) {
      return this._callContextMethod("star", e);
    }
    svg(...e) {
      return this._callContextMethod("svg", e);
    }
    restore(...e) {
      return this._callContextMethod("restore", e);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...e) {
      return this._callContextMethod("rotate", e);
    }
    scaleTransform(...e) {
      return this._callContextMethod("scale", e);
    }
    setTransform(...e) {
      return this._callContextMethod("setTransform", e);
    }
    transform(...e) {
      return this._callContextMethod("transform", e);
    }
    translateTransform(...e) {
      return this._callContextMethod("translate", e);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(e) {
      this._context.fillStyle = e;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(e) {
      this._context.strokeStyle = e;
    }
    clone(e = false) {
      return e ? new Bv(this._context.clone()) : (this._ownedContext = null, new Bv(this._context));
    }
    lineStyle(e, t, n) {
      Pt($t, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const i = {};
      return e && (i.width = e), t && (i.color = t), n && (i.alpha = n), this.context.strokeStyle = i, this;
    }
    beginFill(e, t) {
      Pt($t, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const n = {};
      return e !== void 0 && (n.color = e), t !== void 0 && (n.alpha = t), this.context.fillStyle = n, this;
    }
    endFill() {
      Pt($t, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
      const e = this.context.strokeStyle;
      return (e.width !== Jn.defaultStrokeStyle.width || e.color !== Jn.defaultStrokeStyle.color || e.alpha !== Jn.defaultStrokeStyle.alpha) && this.context.stroke(), this;
    }
    drawCircle(...e) {
      return Pt($t, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e);
    }
    drawEllipse(...e) {
      return Pt($t, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e);
    }
    drawPolygon(...e) {
      return Pt($t, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e);
    }
    drawRect(...e) {
      return Pt($t, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e);
    }
    drawRoundedRect(...e) {
      return Pt($t, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e);
    }
    drawStar(...e) {
      return Pt($t, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e);
    }
  };
  class I1e extends hw {
    constructor(e, t) {
      const { text: n, resolution: i, style: a, anchor: o, width: s, height: l, roundPixels: u, ...c } = e;
      super({
        ...c
      }), this.batched = true, this._resolution = null, this._autoResolution = true, this._didTextUpdate = true, this._styleClass = t, this.text = n ?? "", this.style = a, this.resolution = i ?? null, this.allowChildren = false, this._anchor = new Jr({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), o && (this.anchor = o), this.roundPixels = u ?? false, s !== void 0 && (this.width = s), l !== void 0 && (this.height = l);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    set text(e) {
      e = e.toString(), this._text !== e && (this._text = e, this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(e) {
      this._autoResolution = e === null, this._resolution = e, this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(e) {
      var _a2;
      e || (e = {}), (_a2 = this._style) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(e) {
      this._setWidth(e, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(e) {
      this._setHeight(e, this.bounds.height);
    }
    getSize(e) {
      return e || (e = {}), e.width = Math.abs(this.scale.x) * this.bounds.width, e.height = Math.abs(this.scale.y) * this.bounds.height, e;
    }
    setSize(e, t) {
      typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this.bounds.width), t !== void 0 && this._setHeight(t, this.bounds.height);
    }
    containsPoint(e) {
      const t = this.bounds.width, n = this.bounds.height, i = -t * this.anchor.x;
      let a = 0;
      return e.x >= i && e.x <= i + t && (a = -n * this.anchor.y, e.y >= a && e.y <= a + n);
    }
    onViewUpdate() {
      this.didViewUpdate || (this._didTextUpdate = true), super.onViewUpdate();
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    destroy(e = false) {
      super.destroy(e), this.owner = null, this._bounds = null, this._anchor = null, (typeof e == "boolean" ? e : e == null ? void 0 : e.style) && this._style.destroy(e), this._style = null, this._text = null;
    }
  }
  function M1e(r, e) {
    let t = r[0] ?? {};
    return (typeof t == "string" || r[1]) && (Pt($t, `use new ${e}({ text: "hi!", style }) instead`), t = {
      text: t,
      style: r[1]
    }), t;
  }
  class D1e extends I1e {
    constructor(...e) {
      const t = M1e(e, "Text");
      super(t, yb), this.renderPipeId = "text";
    }
    updateBounds() {
      const e = this._bounds, t = this._anchor, n = A1e.measureText(this._text, this._style), { width: i, height: a } = n;
      e.minX = -t._x * i, e.maxX = e.minX + i, e.minY = -t._y * a, e.maxY = e.minY + a;
    }
  }
  Sw = class extends At {
    static create(e) {
      return new Sw({
        source: new fi(e)
      });
    }
    resize(e, t, n) {
      return this.source.resize(e, t, n), this;
    }
  };
  Wn.add(X0e, q0e);
  class P1e extends zz {
    constructor(e) {
      super(e);
      __publicField(this, "app");
      __publicField(this, "graphicsList", []);
      this.app = new LV();
    }
    async init() {
      await this.app.init({
        canvas: this._canvas,
        width: this._canvas.width,
        height: this._canvas.height,
        backgroundAlpha: 0
      });
    }
    render(e, t, n, i, a, o = 0.6) {
      this.clear();
      const s = this.app.renderer.width, l = this.app.renderer.height, u = new PP(), c = Math.max(Math.round(Math.max(s, l) / 40), 14);
      for (let h = 0; h < n.length; ++h) {
        if (n[h] < o) continue;
        const f = t[i[h]], d = u.get(i[h]), p = (n[h] * 100).toFixed(1);
        let [v, g, m, y] = e.slice(h * 4, (h + 1) * 4);
        [g, y] = [
          g * a[0],
          y * a[0]
        ], [v, m] = [
          v * a[1],
          m * a[1]
        ];
        const x = y - g, _ = m - v, S = new Bv();
        S.rect(g, v, x, _).stroke({
          color: d,
          width: 2
        }).fill({
          color: PP.hexToRgba(d, 0.2)
        });
        const b = new D1e({
          text: `${f} - ${p}%`,
          style: {
            fontFamily: "Arial",
            fontSize: c,
            fill: "#ffffff"
          }
        }), w = b.width, C = b.height, T = v - (C + 2);
        S.fill({
          color: parseInt(d.slice(1), 16)
        }).rect(g - 1, T < 0 ? 0 : T, w + 2, C + 2).fill(), b.x = g - 1, b.y = T < 0 ? 0 : T, S.addChild(b), S.eventMode = "static", S.cursor = "pointer", S.on("mousedown", (A) => {
          var _a2;
          (_a2 = this.onSelect) == null ? void 0 : _a2.call(this, A, {
            boxes: e,
            labels: t,
            scores: n,
            classes: i,
            ratios: a,
            canvas: this.app.canvas
          });
        }), this.app.stage.addChild(S), this.graphicsList.push(S);
      }
    }
    capture(e) {
      const t = e.getContext("2d");
      return new Promise((n) => {
        const i = Sw.create({
          width: this.app.canvas.width,
          height: this.app.canvas.height
        });
        this.app.ticker.addOnce(() => {
          this.app.renderer.render(this.app.stage, {
            renderTexture: i
          });
          const a = new bu(i);
          t.drawImage(this.app.renderer.extract.canvas(a), 0, 0, e.width, e.height), n();
        });
      });
    }
    clear() {
      this.app.stage.removeChildren(), this.graphicsList.length = 0;
    }
    dispose() {
      this.clear(), this.app.destroy(true, {
        children: true,
        texture: true
      });
    }
  }
  function Nk(r, e) {
    switch (r) {
      case "fabric":
        return new Y0e(e);
      case "pixi":
        return new P1e(e);
      default:
        throw new Error(`Unsupported renderer type: ${r}`);
    }
  }
  const Zo = new H0e();
  class k1e {
    constructor(e, t) {
      __publicField(this, "labels");
      __publicField(this, "modelJson");
      __publicField(this, "loaded", false);
      __publicField(this, "inputShape");
      __publicField(this, "frameRate");
      __publicField(this, "renderer");
      __publicField(this, "detectState", false);
      this.labels = e.labels, this.modelJson = e.modelJson, (t == null ? void 0 : t.outputCanvas) && (this.renderer = Nk("pixi", t.outputCanvas));
    }
    get numClass() {
      return this.labels.length;
    }
    async setRenderer(e, t, n) {
      const i = Nk("pixi", t);
      await i.init(), this.renderer = i, this.renderer.onSelect = async (a, o) => {
        const [s, l, u] = this.inputShape, { canvas: c, ...h } = o, f = await this.capture(e, c);
        n({
          image: f,
          ...h,
          modelSize: [
            l,
            u
          ]
        });
      };
    }
    async capture(e, t) {
      var _a2;
      const n = document.createElement("canvas"), i = n.getContext("2d");
      return n.width = t.width, n.height = t.height, i.drawImage(e, 0, 0, n.width, n.height), await ((_a2 = this.renderer) == null ? void 0 : _a2.capture(n)), n.toDataURL();
    }
    async loadModel(e) {
      return new Promise((t, n) => {
        Zo.postMessage({
          cmd: Wc.loadModel,
          data: {
            model: this.modelJson,
            labels: this.labels
          }
        }), Zo.onmessage = (i) => {
          var _a2;
          i.data.cmd === "loadModel" && ((_a2 = e == null ? void 0 : e.onProgress) == null ? void 0 : _a2.call(e, i.data.percent), i.data.percent === 100 && i.data.inputShape && (this.inputShape = i.data.inputShape, this.loaded = true, t(true)));
        };
      });
    }
    async detect(e, t) {
      return new Promise((n, i) => {
        Zo.postMessage({
          cmd: Wc.detect,
          data: {
            source: e,
            options: t
          }
        }), Zo.onmessage = (a) => {
          n(a.data);
        };
      });
    }
    testRun() {
      return new Promise((e, t) => {
        this.inputShape && (Zo.postMessage({
          cmd: Wc.testRun
        }), Zo.onmessage = (n) => {
          n.data ? e(n.data) : t(new Error("Test run failed"));
        });
      });
    }
    detectVideo(e, t = {
      once: false,
      scoreThreshold: 0.6
    }) {
      const n = async () => {
        var _a2, _b2, _c2, _d2, _e2, _f2;
        if (!this.detectState || this.loaded == null) {
          (_a2 = this.renderer) == null ? void 0 : _a2.clear();
          return;
        }
        if (e instanceof HTMLVideoElement && e.videoWidth === 0 && e.srcObject === null) {
          (_b2 = this.renderer) == null ? void 0 : _b2.clear();
          return;
        }
        if (e instanceof HTMLCanvasElement && e.width === 0) {
          (_c2 = this.renderer) == null ? void 0 : _c2.clear();
          return;
        }
        const [i, a] = this.getSourceSize(e), o = this.inputShape[2], s = Math.min(a, o) / a, l = parseInt((a * s).toString(), 10), u = parseInt((i * s).toString(), 10), c = await createImageBitmap(e, {
          resizeWidth: l,
          resizeHeight: u
        }), h = await this.detect(c, {
          scoreThreshold: t.scoreThreshold
        }), [f, d] = h.ratios;
        if (h.ratios = [
          f / s,
          d / s
        ], (_d2 = this.renderer) == null ? void 0 : _d2.render(h.boxes, h.labels, h.scores, h.classes, h.ratios, t.scoreThreshold), h.boxes.length && ((_e2 = t.onOutput) == null ? void 0 : _e2.call(t, h)), t.once && h.boxes.length) {
          (_f2 = this.renderer) == null ? void 0 : _f2.clear();
          return;
        }
        this.frameRate !== void 0 && this.frameRate !== 0 ? setTimeout(n, 1e3 / this.frameRate) : requestAnimationFrame(n);
      };
      this.detectState = true, n();
    }
    stop() {
      this.detectState = false;
    }
    dispose() {
      var _a2;
      Zo.postMessage({
        cmd: Wc.disposeModel
      }), (_a2 = this.renderer) == null ? void 0 : _a2.dispose();
    }
    getSourceSize(e) {
      return e instanceof HTMLVideoElement ? [
        e.videoHeight,
        e.videoWidth
      ] : [
        e.height,
        e.width
      ];
    }
  }
  const _Cs = class _Cs {
    constructor() {
      __publicField(this, "ready", false);
      __publicField(this, "model");
      __publicField(this, "modelName", "");
      __publicField(this, "loadingModel", false);
      __publicField(this, "loadingModelProgress", 0);
    }
    static getInstance() {
      return _Cs._instance || (_Cs._instance = new _Cs()), _Cs._instance;
    }
    async init(e = "webgl") {
      if (this.ready) return Hg() !== e && (await Zw(e), await jw(), console.log(e, Hg())), true;
      try {
        return await Zw(e), console.log(e, Hg()), await jw(), this.ready = true, true;
      } catch (t) {
        return console.error("Failed to initialize backend:", t), false;
      }
    }
    async loadGraphModel(e, t, n = "webgl") {
      await this.init(n), this.model && (this.model.dispose(), this.model = null);
      const i = `${e}/model.json`, a = `${e}/metadata.yaml`, o = await (await fetch(a)).text(), s = dce.load(o), l = Object.values(s.names);
      if (!l) {
        console.error("No Labels Fetched");
        return;
      }
      return this.model = new k1e({
        modelJson: i,
        labels: l
      }), await this.model.loadModel({
        onProgress: (u) => {
          this.loadingModel = true, this.loadingModelProgress = Math.round(u), t(this.loadingModelProgress);
        }
      }), this.loadingModel = false, this.loadingModelProgress = 100, t(this.loadingModelProgress), this.modelName = e, this.model;
    }
    testRun() {
      var _a2;
      return (_a2 = this.model) == null ? void 0 : _a2.testRun();
    }
  };
  __publicField(_Cs, "_instance");
  let Cs = _Cs;
  const Ok = Cs.getInstance(), L1e = FL("video-detect", {
    state: () => ({
      backend: "webgl",
      loadedModel: "",
      loadState: {
        loading: false,
        progress: 0
      }
    }),
    actions: {
      async setBackend(r = "webgl") {
        this.backend = r;
      },
      async loadModel(r) {
        await Ok.loadGraphModel(r, (e) => {
          e === 100 ? this.loadState.progress = e : (this.loadState.loading = true, this.loadState.progress = e);
        }, this.backend), await Ok.testRun(), this.loadState.loading = false, this.loadedModel = r;
      }
    }
  }), R1e = (r, e, t) => {
    const n = r[e];
    return n ? typeof n == "function" ? n() : Promise.resolve(n) : new Promise((i, a) => {
      (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(a.bind(null, new Error("Unknown variable dynamic import: " + e + (e.split("/").length !== t ? ". Note that variables only represent file names one level deep." : ""))));
    });
  };
  const zv = typeof window < "u", _o = (r, e = false) => e ? Symbol.for(r) : Symbol(r), E1e = (r, e, t) => N1e({
    l: r,
    k: e,
    s: t
  }), N1e = (r) => JSON.stringify(r).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), Zt = (r) => typeof r == "number" && isFinite(r), O1e = (r) => ww(r) === "[object Date]", wu = (r) => ww(r) === "[object RegExp]", zg = (r) => st(r) && Object.keys(r).length === 0, sr = Object.assign, F1e = Object.create, It = (r = null) => F1e(r);
  let Fk;
  const Ts = () => Fk || (Fk = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : It());
  function Bk(r) {
    return r.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const B1e = Object.prototype.hasOwnProperty;
  function ri(r, e) {
    return B1e.call(r, e);
  }
  const Jt = Array.isArray, Et = (r) => typeof r == "function", xe = (r) => typeof r == "string", vt = (r) => typeof r == "boolean", mt = (r) => r !== null && typeof r == "object", z1e = (r) => mt(r) && Et(r.then) && Et(r.catch), QV = Object.prototype.toString, ww = (r) => QV.call(r), st = (r) => ww(r) === "[object Object]", V1e = (r) => r == null ? "" : Jt(r) || st(r) && r.toString === QV ? JSON.stringify(r, null, 2) : String(r);
  function Cw(r, e = "") {
    return r.reduce((t, n, i) => i === 0 ? t + n : t + e + n, "");
  }
  function $1e(r, e) {
    typeof console < "u" && (console.warn("[intlify] " + r), e && console.warn(e.stack));
  }
  const ep = (r) => !mt(r) || Jt(r);
  function Ep(r, e) {
    if (ep(r) || ep(e)) throw new Error("Invalid value");
    const t = [
      {
        src: r,
        des: e
      }
    ];
    for (; t.length; ) {
      const { src: n, des: i } = t.pop();
      Object.keys(n).forEach((a) => {
        a !== "__proto__" && (mt(n[a]) && !mt(i[a]) && (i[a] = Array.isArray(n[a]) ? [] : It()), ep(i[a]) || ep(n[a]) ? i[a] = n[a] : t.push({
          src: n[a],
          des: i[a]
        }));
      });
    }
  }
  function G1e(r, e, t) {
    return {
      line: r,
      column: e,
      offset: t
    };
  }
  function xb(r, e, t) {
    return {
      start: r,
      end: e
    };
  }
  const bt = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14
  }, W1e = 17;
  function Vg(r, e, t = {}) {
    const { domain: n, messages: i, args: a } = t, o = r, s = new SyntaxError(String(o));
    return s.code = r, e && (s.location = e), s.domain = n, s;
  }
  function U1e(r) {
    throw r;
  }
  const ji = " ", H1e = "\r", Or = `
`, Y1e = "\u2028", X1e = "\u2029";
  function q1e(r) {
    const e = r;
    let t = 0, n = 1, i = 1, a = 0;
    const o = (w) => e[w] === H1e && e[w + 1] === Or, s = (w) => e[w] === Or, l = (w) => e[w] === X1e, u = (w) => e[w] === Y1e, c = (w) => o(w) || s(w) || l(w) || u(w), h = () => t, f = () => n, d = () => i, p = () => a, v = (w) => o(w) || l(w) || u(w) ? Or : e[w], g = () => v(t), m = () => v(t + a);
    function y() {
      return a = 0, c(t) && (n++, i = 0), o(t) && t++, t++, i++, e[t];
    }
    function x() {
      return o(t + a) && a++, a++, e[t + a];
    }
    function _() {
      t = 0, n = 1, i = 1, a = 0;
    }
    function S(w = 0) {
      a = w;
    }
    function b() {
      const w = t + a;
      for (; w !== t; ) y();
      a = 0;
    }
    return {
      index: h,
      line: f,
      column: d,
      peekOffset: p,
      charAt: v,
      currentChar: g,
      currentPeek: m,
      next: y,
      peek: x,
      reset: _,
      resetPeek: S,
      skipToPeek: b
    };
  }
  const Fa = void 0, K1e = ".", zk = "'", Z1e = "tokenizer";
  function j1e(r, e = {}) {
    const t = e.location !== false, n = q1e(r), i = () => n.index(), a = () => G1e(n.line(), n.column(), n.index()), o = a(), s = i(), l = {
      currentType: 13,
      offset: s,
      startLoc: o,
      endLoc: o,
      lastType: 13,
      lastOffset: s,
      lastStartLoc: o,
      lastEndLoc: o,
      braceNest: 0,
      inLinked: false,
      text: ""
    }, u = () => l, { onError: c } = e;
    function h(z, $, j, ...Te) {
      const Ot = u();
      if ($.column += j, $.offset += j, c) {
        const Qe = t ? xb(Ot.startLoc, $) : null, Z = Vg(z, Qe, {
          domain: Z1e,
          args: Te
        });
        c(Z);
      }
    }
    function f(z, $, j) {
      z.endLoc = a(), z.currentType = $;
      const Te = {
        type: $
      };
      return t && (Te.loc = xb(z.startLoc, z.endLoc)), j != null && (Te.value = j), Te;
    }
    const d = (z) => f(z, 13);
    function p(z, $) {
      return z.currentChar() === $ ? (z.next(), $) : (h(bt.EXPECTED_TOKEN, a(), 0, $), "");
    }
    function v(z) {
      let $ = "";
      for (; z.currentPeek() === ji || z.currentPeek() === Or; ) $ += z.currentPeek(), z.peek();
      return $;
    }
    function g(z) {
      const $ = v(z);
      return z.skipToPeek(), $;
    }
    function m(z) {
      if (z === Fa) return false;
      const $ = z.charCodeAt(0);
      return $ >= 97 && $ <= 122 || $ >= 65 && $ <= 90 || $ === 95;
    }
    function y(z) {
      if (z === Fa) return false;
      const $ = z.charCodeAt(0);
      return $ >= 48 && $ <= 57;
    }
    function x(z, $) {
      const { currentType: j } = $;
      if (j !== 2) return false;
      v(z);
      const Te = m(z.currentPeek());
      return z.resetPeek(), Te;
    }
    function _(z, $) {
      const { currentType: j } = $;
      if (j !== 2) return false;
      v(z);
      const Te = z.currentPeek() === "-" ? z.peek() : z.currentPeek(), Ot = y(Te);
      return z.resetPeek(), Ot;
    }
    function S(z, $) {
      const { currentType: j } = $;
      if (j !== 2) return false;
      v(z);
      const Te = z.currentPeek() === zk;
      return z.resetPeek(), Te;
    }
    function b(z, $) {
      const { currentType: j } = $;
      if (j !== 7) return false;
      v(z);
      const Te = z.currentPeek() === ".";
      return z.resetPeek(), Te;
    }
    function w(z, $) {
      const { currentType: j } = $;
      if (j !== 8) return false;
      v(z);
      const Te = m(z.currentPeek());
      return z.resetPeek(), Te;
    }
    function C(z, $) {
      const { currentType: j } = $;
      if (!(j === 7 || j === 11)) return false;
      v(z);
      const Te = z.currentPeek() === ":";
      return z.resetPeek(), Te;
    }
    function T(z, $) {
      const { currentType: j } = $;
      if (j !== 9) return false;
      const Te = () => {
        const Qe = z.currentPeek();
        return Qe === "{" ? m(z.peek()) : Qe === "@" || Qe === "|" || Qe === ":" || Qe === "." || Qe === ji || !Qe ? false : Qe === Or ? (z.peek(), Te()) : M(z, false);
      }, Ot = Te();
      return z.resetPeek(), Ot;
    }
    function A(z) {
      v(z);
      const $ = z.currentPeek() === "|";
      return z.resetPeek(), $;
    }
    function M(z, $ = true) {
      const j = (Ot = false, Qe = "") => {
        const Z = z.currentPeek();
        return Z === "{" || Z === "@" || !Z ? Ot : Z === "|" ? !(Qe === ji || Qe === Or) : Z === ji ? (z.peek(), j(true, ji)) : Z === Or ? (z.peek(), j(true, Or)) : true;
      }, Te = j();
      return $ && z.resetPeek(), Te;
    }
    function E(z, $) {
      const j = z.currentChar();
      return j === Fa ? Fa : $(j) ? (z.next(), j) : null;
    }
    function k(z) {
      const $ = z.charCodeAt(0);
      return $ >= 97 && $ <= 122 || $ >= 65 && $ <= 90 || $ >= 48 && $ <= 57 || $ === 95 || $ === 36;
    }
    function R(z) {
      return E(z, k);
    }
    function N(z) {
      const $ = z.charCodeAt(0);
      return $ >= 97 && $ <= 122 || $ >= 65 && $ <= 90 || $ >= 48 && $ <= 57 || $ === 95 || $ === 36 || $ === 45;
    }
    function I(z) {
      return E(z, N);
    }
    function L(z) {
      const $ = z.charCodeAt(0);
      return $ >= 48 && $ <= 57;
    }
    function P(z) {
      return E(z, L);
    }
    function O(z) {
      const $ = z.charCodeAt(0);
      return $ >= 48 && $ <= 57 || $ >= 65 && $ <= 70 || $ >= 97 && $ <= 102;
    }
    function F(z) {
      return E(z, O);
    }
    function B(z) {
      let $ = "", j = "";
      for (; $ = P(z); ) j += $;
      return j;
    }
    function V(z) {
      let $ = "";
      for (; ; ) {
        const j = z.currentChar();
        if (j === "{" || j === "}" || j === "@" || j === "|" || !j) break;
        if (j === ji || j === Or) if (M(z)) $ += j, z.next();
        else {
          if (A(z)) break;
          $ += j, z.next();
        }
        else $ += j, z.next();
      }
      return $;
    }
    function U(z) {
      g(z);
      let $ = "", j = "";
      for (; $ = I(z); ) j += $;
      return z.currentChar() === Fa && h(bt.UNTERMINATED_CLOSING_BRACE, a(), 0), j;
    }
    function Y(z) {
      g(z);
      let $ = "";
      return z.currentChar() === "-" ? (z.next(), $ += `-${B(z)}`) : $ += B(z), z.currentChar() === Fa && h(bt.UNTERMINATED_CLOSING_BRACE, a(), 0), $;
    }
    function q(z) {
      return z !== zk && z !== Or;
    }
    function me(z) {
      g(z), p(z, "'");
      let $ = "", j = "";
      for (; $ = E(z, q); ) $ === "\\" ? j += Me(z) : j += $;
      const Te = z.currentChar();
      return Te === Or || Te === Fa ? (h(bt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, a(), 0), Te === Or && (z.next(), p(z, "'")), j) : (p(z, "'"), j);
    }
    function Me(z) {
      const $ = z.currentChar();
      switch ($) {
        case "\\":
        case "'":
          return z.next(), `\\${$}`;
        case "u":
          return re(z, $, 4);
        case "U":
          return re(z, $, 6);
        default:
          return h(bt.UNKNOWN_ESCAPE_SEQUENCE, a(), 0, $), "";
      }
    }
    function re(z, $, j) {
      p(z, $);
      let Te = "";
      for (let Ot = 0; Ot < j; Ot++) {
        const Qe = F(z);
        if (!Qe) {
          h(bt.INVALID_UNICODE_ESCAPE_SEQUENCE, a(), 0, `\\${$}${Te}${z.currentChar()}`);
          break;
        }
        Te += Qe;
      }
      return `\\${$}${Te}`;
    }
    function J(z) {
      return z !== "{" && z !== "}" && z !== ji && z !== Or;
    }
    function le(z) {
      g(z);
      let $ = "", j = "";
      for (; $ = E(z, J); ) j += $;
      return j;
    }
    function te(z) {
      let $ = "", j = "";
      for (; $ = R(z); ) j += $;
      return j;
    }
    function he(z) {
      const $ = (j) => {
        const Te = z.currentChar();
        return Te === "{" || Te === "@" || Te === "|" || Te === "(" || Te === ")" || !Te || Te === ji ? j : (j += Te, z.next(), $(j));
      };
      return $("");
    }
    function Xe(z) {
      g(z);
      const $ = p(z, "|");
      return g(z), $;
    }
    function Fe(z, $) {
      let j = null;
      switch (z.currentChar()) {
        case "{":
          return $.braceNest >= 1 && h(bt.NOT_ALLOW_NEST_PLACEHOLDER, a(), 0), z.next(), j = f($, 2, "{"), g(z), $.braceNest++, j;
        case "}":
          return $.braceNest > 0 && $.currentType === 2 && h(bt.EMPTY_PLACEHOLDER, a(), 0), z.next(), j = f($, 3, "}"), $.braceNest--, $.braceNest > 0 && g(z), $.inLinked && $.braceNest === 0 && ($.inLinked = false), j;
        case "@":
          return $.braceNest > 0 && h(bt.UNTERMINATED_CLOSING_BRACE, a(), 0), j = fe(z, $) || d($), $.braceNest = 0, j;
        default: {
          let Ot = true, Qe = true, Z = true;
          if (A(z)) return $.braceNest > 0 && h(bt.UNTERMINATED_CLOSING_BRACE, a(), 0), j = f($, 1, Xe(z)), $.braceNest = 0, $.inLinked = false, j;
          if ($.braceNest > 0 && ($.currentType === 4 || $.currentType === 5 || $.currentType === 6)) return h(bt.UNTERMINATED_CLOSING_BRACE, a(), 0), $.braceNest = 0, Se(z, $);
          if (Ot = x(z, $)) return j = f($, 4, U(z)), g(z), j;
          if (Qe = _(z, $)) return j = f($, 5, Y(z)), g(z), j;
          if (Z = S(z, $)) return j = f($, 6, me(z)), g(z), j;
          if (!Ot && !Qe && !Z) return j = f($, 12, le(z)), h(bt.INVALID_TOKEN_IN_PLACEHOLDER, a(), 0, j.value), g(z), j;
          break;
        }
      }
      return j;
    }
    function fe(z, $) {
      const { currentType: j } = $;
      let Te = null;
      const Ot = z.currentChar();
      switch ((j === 7 || j === 8 || j === 11 || j === 9) && (Ot === Or || Ot === ji) && h(bt.INVALID_LINKED_FORMAT, a(), 0), Ot) {
        case "@":
          return z.next(), Te = f($, 7, "@"), $.inLinked = true, Te;
        case ".":
          return g(z), z.next(), f($, 8, ".");
        case ":":
          return g(z), z.next(), f($, 9, ":");
        default:
          return A(z) ? (Te = f($, 1, Xe(z)), $.braceNest = 0, $.inLinked = false, Te) : b(z, $) || C(z, $) ? (g(z), fe(z, $)) : w(z, $) ? (g(z), f($, 11, te(z))) : T(z, $) ? (g(z), Ot === "{" ? Fe(z, $) || Te : f($, 10, he(z))) : (j === 7 && h(bt.INVALID_LINKED_FORMAT, a(), 0), $.braceNest = 0, $.inLinked = false, Se(z, $));
      }
    }
    function Se(z, $) {
      let j = {
        type: 13
      };
      if ($.braceNest > 0) return Fe(z, $) || d($);
      if ($.inLinked) return fe(z, $) || d($);
      switch (z.currentChar()) {
        case "{":
          return Fe(z, $) || d($);
        case "}":
          return h(bt.UNBALANCED_CLOSING_BRACE, a(), 0), z.next(), f($, 3, "}");
        case "@":
          return fe(z, $) || d($);
        default: {
          if (A(z)) return j = f($, 1, Xe(z)), $.braceNest = 0, $.inLinked = false, j;
          if (M(z)) return f($, 0, V(z));
          break;
        }
      }
      return j;
    }
    function Lt() {
      const { currentType: z, offset: $, startLoc: j, endLoc: Te } = l;
      return l.lastType = z, l.lastOffset = $, l.lastStartLoc = j, l.lastEndLoc = Te, l.offset = i(), l.startLoc = a(), n.currentChar() === Fa ? f(l, 13) : Se(n, l);
    }
    return {
      nextToken: Lt,
      currentOffset: i,
      currentPosition: a,
      context: u
    };
  }
  const Q1e = "parser", J1e = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function eSe(r, e, t) {
    switch (r) {
      case "\\\\":
        return "\\";
      case "\\'":
        return "'";
      default: {
        const n = parseInt(e || t, 16);
        return n <= 55295 || n >= 57344 ? String.fromCodePoint(n) : "\uFFFD";
      }
    }
  }
  function tSe(r = {}) {
    const e = r.location !== false, { onError: t } = r;
    function n(m, y, x, _, ...S) {
      const b = m.currentPosition();
      if (b.offset += _, b.column += _, t) {
        const w = e ? xb(x, b) : null, C = Vg(y, w, {
          domain: Q1e,
          args: S
        });
        t(C);
      }
    }
    function i(m, y, x) {
      const _ = {
        type: m
      };
      return e && (_.start = y, _.end = y, _.loc = {
        start: x,
        end: x
      }), _;
    }
    function a(m, y, x, _) {
      e && (m.end = y, m.loc && (m.loc.end = x));
    }
    function o(m, y) {
      const x = m.context(), _ = i(3, x.offset, x.startLoc);
      return _.value = y, a(_, m.currentOffset(), m.currentPosition()), _;
    }
    function s(m, y) {
      const x = m.context(), { lastOffset: _, lastStartLoc: S } = x, b = i(5, _, S);
      return b.index = parseInt(y, 10), m.nextToken(), a(b, m.currentOffset(), m.currentPosition()), b;
    }
    function l(m, y) {
      const x = m.context(), { lastOffset: _, lastStartLoc: S } = x, b = i(4, _, S);
      return b.key = y, m.nextToken(), a(b, m.currentOffset(), m.currentPosition()), b;
    }
    function u(m, y) {
      const x = m.context(), { lastOffset: _, lastStartLoc: S } = x, b = i(9, _, S);
      return b.value = y.replace(J1e, eSe), m.nextToken(), a(b, m.currentOffset(), m.currentPosition()), b;
    }
    function c(m) {
      const y = m.nextToken(), x = m.context(), { lastOffset: _, lastStartLoc: S } = x, b = i(8, _, S);
      return y.type !== 11 ? (n(m, bt.UNEXPECTED_EMPTY_LINKED_MODIFIER, x.lastStartLoc, 0), b.value = "", a(b, _, S), {
        nextConsumeToken: y,
        node: b
      }) : (y.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, xi(y)), b.value = y.value || "", a(b, m.currentOffset(), m.currentPosition()), {
        node: b
      });
    }
    function h(m, y) {
      const x = m.context(), _ = i(7, x.offset, x.startLoc);
      return _.value = y, a(_, m.currentOffset(), m.currentPosition()), _;
    }
    function f(m) {
      const y = m.context(), x = i(6, y.offset, y.startLoc);
      let _ = m.nextToken();
      if (_.type === 8) {
        const S = c(m);
        x.modifier = S.node, _ = S.nextConsumeToken || m.nextToken();
      }
      switch (_.type !== 9 && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(_)), _ = m.nextToken(), _.type === 2 && (_ = m.nextToken()), _.type) {
        case 10:
          _.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(_)), x.key = h(m, _.value || "");
          break;
        case 4:
          _.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(_)), x.key = l(m, _.value || "");
          break;
        case 5:
          _.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(_)), x.key = s(m, _.value || "");
          break;
        case 6:
          _.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(_)), x.key = u(m, _.value || "");
          break;
        default: {
          n(m, bt.UNEXPECTED_EMPTY_LINKED_KEY, y.lastStartLoc, 0);
          const S = m.context(), b = i(7, S.offset, S.startLoc);
          return b.value = "", a(b, S.offset, S.startLoc), x.key = b, a(x, S.offset, S.startLoc), {
            nextConsumeToken: _,
            node: x
          };
        }
      }
      return a(x, m.currentOffset(), m.currentPosition()), {
        node: x
      };
    }
    function d(m) {
      const y = m.context(), x = y.currentType === 1 ? m.currentOffset() : y.offset, _ = y.currentType === 1 ? y.endLoc : y.startLoc, S = i(2, x, _);
      S.items = [];
      let b = null;
      do {
        const T = b || m.nextToken();
        switch (b = null, T.type) {
          case 0:
            T.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(T)), S.items.push(o(m, T.value || ""));
            break;
          case 5:
            T.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(T)), S.items.push(s(m, T.value || ""));
            break;
          case 4:
            T.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(T)), S.items.push(l(m, T.value || ""));
            break;
          case 6:
            T.value == null && n(m, bt.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, xi(T)), S.items.push(u(m, T.value || ""));
            break;
          case 7: {
            const A = f(m);
            S.items.push(A.node), b = A.nextConsumeToken || null;
            break;
          }
        }
      } while (y.currentType !== 13 && y.currentType !== 1);
      const w = y.currentType === 1 ? y.lastOffset : m.currentOffset(), C = y.currentType === 1 ? y.lastEndLoc : m.currentPosition();
      return a(S, w, C), S;
    }
    function p(m, y, x, _) {
      const S = m.context();
      let b = _.items.length === 0;
      const w = i(1, y, x);
      w.cases = [], w.cases.push(_);
      do {
        const C = d(m);
        b || (b = C.items.length === 0), w.cases.push(C);
      } while (S.currentType !== 13);
      return b && n(m, bt.MUST_HAVE_MESSAGES_IN_PLURAL, x, 0), a(w, m.currentOffset(), m.currentPosition()), w;
    }
    function v(m) {
      const y = m.context(), { offset: x, startLoc: _ } = y, S = d(m);
      return y.currentType === 13 ? S : p(m, x, _, S);
    }
    function g(m) {
      const y = j1e(m, sr({}, r)), x = y.context(), _ = i(0, x.offset, x.startLoc);
      return e && _.loc && (_.loc.source = m), _.body = v(y), r.onCacheKey && (_.cacheKey = r.onCacheKey(m)), x.currentType !== 13 && n(y, bt.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, m[x.offset] || ""), a(_, y.currentOffset(), y.currentPosition()), _;
    }
    return {
      parse: g
    };
  }
  function xi(r) {
    if (r.type === 13) return "EOF";
    const e = (r.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "\u2026" : e;
  }
  function rSe(r, e = {}) {
    const t = {
      ast: r,
      helpers: /* @__PURE__ */ new Set()
    };
    return {
      context: () => t,
      helper: (a) => (t.helpers.add(a), a)
    };
  }
  function Vk(r, e) {
    for (let t = 0; t < r.length; t++) Tw(r[t], e);
  }
  function Tw(r, e) {
    switch (r.type) {
      case 1:
        Vk(r.cases, e), e.helper("plural");
        break;
      case 2:
        Vk(r.items, e);
        break;
      case 6: {
        Tw(r.key, e), e.helper("linked"), e.helper("type");
        break;
      }
      case 5:
        e.helper("interpolate"), e.helper("list");
        break;
      case 4:
        e.helper("interpolate"), e.helper("named");
        break;
    }
  }
  function nSe(r, e = {}) {
    const t = rSe(r);
    t.helper("normalize"), r.body && Tw(r.body, t);
    const n = t.context();
    r.helpers = Array.from(n.helpers);
  }
  function iSe(r) {
    const e = r.body;
    return e.type === 2 ? $k(e) : e.cases.forEach((t) => $k(t)), r;
  }
  function $k(r) {
    if (r.items.length === 1) {
      const e = r.items[0];
      (e.type === 3 || e.type === 9) && (r.static = e.value, delete e.value);
    } else {
      const e = [];
      for (let t = 0; t < r.items.length; t++) {
        const n = r.items[t];
        if (!(n.type === 3 || n.type === 9) || n.value == null) break;
        e.push(n.value);
      }
      if (e.length === r.items.length) {
        r.static = Cw(e);
        for (let t = 0; t < r.items.length; t++) {
          const n = r.items[t];
          (n.type === 3 || n.type === 9) && delete n.value;
        }
      }
    }
  }
  function Yl(r) {
    switch (r.t = r.type, r.type) {
      case 0: {
        const e = r;
        Yl(e.body), e.b = e.body, delete e.body;
        break;
      }
      case 1: {
        const e = r, t = e.cases;
        for (let n = 0; n < t.length; n++) Yl(t[n]);
        e.c = t, delete e.cases;
        break;
      }
      case 2: {
        const e = r, t = e.items;
        for (let n = 0; n < t.length; n++) Yl(t[n]);
        e.i = t, delete e.items, e.static && (e.s = e.static, delete e.static);
        break;
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const e = r;
        e.value && (e.v = e.value, delete e.value);
        break;
      }
      case 6: {
        const e = r;
        Yl(e.key), e.k = e.key, delete e.key, e.modifier && (Yl(e.modifier), e.m = e.modifier, delete e.modifier);
        break;
      }
      case 5: {
        const e = r;
        e.i = e.index, delete e.index;
        break;
      }
      case 4: {
        const e = r;
        e.k = e.key, delete e.key;
        break;
      }
    }
    delete r.type;
  }
  function aSe(r, e) {
    const { filename: t, breakLineCode: n, needIndent: i } = e, a = e.location !== false, o = {
      filename: t,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: n,
      needIndent: i,
      indentLevel: 0
    };
    a && r.loc && (o.source = r.loc.source);
    const s = () => o;
    function l(v, g) {
      o.code += v;
    }
    function u(v, g = true) {
      const m = g ? n : "";
      l(i ? m + "  ".repeat(v) : m);
    }
    function c(v = true) {
      const g = ++o.indentLevel;
      v && u(g);
    }
    function h(v = true) {
      const g = --o.indentLevel;
      v && u(g);
    }
    function f() {
      u(o.indentLevel);
    }
    return {
      context: s,
      push: l,
      indent: c,
      deindent: h,
      newline: f,
      helper: (v) => `_${v}`,
      needIndent: () => o.needIndent
    };
  }
  function oSe(r, e) {
    const { helper: t } = r;
    r.push(`${t("linked")}(`), Cu(r, e.key), e.modifier ? (r.push(", "), Cu(r, e.modifier), r.push(", _type")) : r.push(", undefined, _type"), r.push(")");
  }
  function sSe(r, e) {
    const { helper: t, needIndent: n } = r;
    r.push(`${t("normalize")}([`), r.indent(n());
    const i = e.items.length;
    for (let a = 0; a < i && (Cu(r, e.items[a]), a !== i - 1); a++) r.push(", ");
    r.deindent(n()), r.push("])");
  }
  function lSe(r, e) {
    const { helper: t, needIndent: n } = r;
    if (e.cases.length > 1) {
      r.push(`${t("plural")}([`), r.indent(n());
      const i = e.cases.length;
      for (let a = 0; a < i && (Cu(r, e.cases[a]), a !== i - 1); a++) r.push(", ");
      r.deindent(n()), r.push("])");
    }
  }
  function uSe(r, e) {
    e.body ? Cu(r, e.body) : r.push("null");
  }
  function Cu(r, e) {
    const { helper: t } = r;
    switch (e.type) {
      case 0:
        uSe(r, e);
        break;
      case 1:
        lSe(r, e);
        break;
      case 2:
        sSe(r, e);
        break;
      case 6:
        oSe(r, e);
        break;
      case 8:
        r.push(JSON.stringify(e.value), e);
        break;
      case 7:
        r.push(JSON.stringify(e.value), e);
        break;
      case 5:
        r.push(`${t("interpolate")}(${t("list")}(${e.index}))`, e);
        break;
      case 4:
        r.push(`${t("interpolate")}(${t("named")}(${JSON.stringify(e.key)}))`, e);
        break;
      case 9:
        r.push(JSON.stringify(e.value), e);
        break;
      case 3:
        r.push(JSON.stringify(e.value), e);
        break;
    }
  }
  const cSe = (r, e = {}) => {
    const t = xe(e.mode) ? e.mode : "normal", n = xe(e.filename) ? e.filename : "message.intl";
    e.sourceMap;
    const i = e.breakLineCode != null ? e.breakLineCode : t === "arrow" ? ";" : `
`, a = e.needIndent ? e.needIndent : t !== "arrow", o = r.helpers || [], s = aSe(r, {
      filename: n,
      breakLineCode: i,
      needIndent: a
    });
    s.push(t === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), s.indent(a), o.length > 0 && (s.push(`const { ${Cw(o.map((c) => `${c}: _${c}`), ", ")} } = ctx`), s.newline()), s.push("return "), Cu(s, r), s.deindent(a), s.push("}"), delete r.helpers;
    const { code: l, map: u } = s.context();
    return {
      ast: r,
      code: l,
      map: u ? u.toJSON() : void 0
    };
  };
  function hSe(r, e = {}) {
    const t = sr({}, e), n = !!t.jit, i = !!t.minify, a = t.optimize == null ? true : t.optimize, s = tSe(t).parse(r);
    return n ? (a && iSe(s), i && Yl(s), {
      ast: s,
      code: ""
    }) : (nSe(s, t), cSe(s, t));
  }
  function fSe() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Ts().__INTLIFY_PROD_DEVTOOLS__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Ts().__INTLIFY_DROP_MESSAGE_COMPILER__ = false);
  }
  function H0(r) {
    return (t) => dSe(t, r);
  }
  function dSe(r, e) {
    const t = vSe(e);
    if (t == null) throw nf(0);
    if (Aw(t) === 1) {
      const a = mSe(t);
      return r.plural(a.reduce((o, s) => [
        ...o,
        Gk(r, s)
      ], []));
    } else return Gk(r, t);
  }
  const pSe = [
    "b",
    "body"
  ];
  function vSe(r) {
    return bo(r, pSe);
  }
  const gSe = [
    "c",
    "cases"
  ];
  function mSe(r) {
    return bo(r, gSe, []);
  }
  function Gk(r, e) {
    const t = xSe(e);
    if (t != null) return r.type === "text" ? t : r.normalize([
      t
    ]);
    {
      const n = bSe(e).reduce((i, a) => [
        ...i,
        _b(r, a)
      ], []);
      return r.normalize(n);
    }
  }
  const ySe = [
    "s",
    "static"
  ];
  function xSe(r) {
    return bo(r, ySe);
  }
  const _Se = [
    "i",
    "items"
  ];
  function bSe(r) {
    return bo(r, _Se, []);
  }
  function _b(r, e) {
    const t = Aw(e);
    switch (t) {
      case 3:
        return tp(e, t);
      case 9:
        return tp(e, t);
      case 4: {
        const n = e;
        if (ri(n, "k") && n.k) return r.interpolate(r.named(n.k));
        if (ri(n, "key") && n.key) return r.interpolate(r.named(n.key));
        throw nf(t);
      }
      case 5: {
        const n = e;
        if (ri(n, "i") && Zt(n.i)) return r.interpolate(r.list(n.i));
        if (ri(n, "index") && Zt(n.index)) return r.interpolate(r.list(n.index));
        throw nf(t);
      }
      case 6: {
        const n = e, i = TSe(n), a = ISe(n);
        return r.linked(_b(r, a), i ? _b(r, i) : void 0, r.type);
      }
      case 7:
        return tp(e, t);
      case 8:
        return tp(e, t);
      default:
        throw new Error(`unhandled node on format message part: ${t}`);
    }
  }
  const SSe = [
    "t",
    "type"
  ];
  function Aw(r) {
    return bo(r, SSe);
  }
  const wSe = [
    "v",
    "value"
  ];
  function tp(r, e) {
    const t = bo(r, wSe);
    if (t) return t;
    throw nf(e);
  }
  const CSe = [
    "m",
    "modifier"
  ];
  function TSe(r) {
    return bo(r, CSe);
  }
  const ASe = [
    "k",
    "key"
  ];
  function ISe(r) {
    const e = bo(r, ASe);
    if (e) return e;
    throw nf(6);
  }
  function bo(r, e, t) {
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (ri(r, i) && r[i] != null) return r[i];
    }
    return t;
  }
  function nf(r) {
    return new Error(`unhandled node type: ${r}`);
  }
  const MSe = (r) => r;
  let rp = It();
  function Tu(r) {
    return mt(r) && Aw(r) === 0 && (ri(r, "b") || ri(r, "body"));
  }
  function DSe(r, e = {}) {
    let t = false;
    const n = e.onError || U1e;
    return e.onError = (i) => {
      t = true, n(i);
    }, {
      ...hSe(r, e),
      detectError: t
    };
  }
  function PSe(r, e) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && xe(r)) {
      vt(e.warnHtmlMessage) && e.warnHtmlMessage;
      const n = (e.onCacheKey || MSe)(r), i = rp[n];
      if (i) return i;
      const { ast: a, detectError: o } = DSe(r, {
        ...e,
        location: false,
        jit: true
      }), s = H0(a);
      return o ? s : rp[n] = s;
    } else {
      const t = r.cacheKey;
      if (t) {
        const n = rp[t];
        return n || (rp[t] = H0(r));
      } else return H0(r);
    }
  }
  let af = null;
  function kSe(r) {
    af = r;
  }
  function LSe(r, e, t) {
    af && af.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: r,
      version: e,
      meta: t
    });
  }
  const RSe = ESe("function:translate");
  function ESe(r) {
    return (e) => af && af.emit(r, e);
  }
  const na = {
    INVALID_ARGUMENT: W1e,
    INVALID_DATE_ARGUMENT: 18,
    INVALID_ISO_DATE_ARGUMENT: 19,
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
    NOT_SUPPORT_LOCALE_TYPE: 23
  }, NSe = 24;
  function ia(r) {
    return Vg(r, null, void 0);
  }
  function Iw(r, e) {
    return e.locale != null ? Wk(e.locale) : Wk(r.locale);
  }
  let Y0;
  function Wk(r) {
    if (xe(r)) return r;
    if (Et(r)) {
      if (r.resolvedOnce && Y0 != null) return Y0;
      if (r.constructor.name === "Function") {
        const e = r();
        if (z1e(e)) throw ia(na.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        return Y0 = e;
      } else throw ia(na.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
    } else throw ia(na.NOT_SUPPORT_LOCALE_TYPE);
  }
  function OSe(r, e, t) {
    return [
      .../* @__PURE__ */ new Set([
        t,
        ...Jt(e) ? e : mt(e) ? Object.keys(e) : xe(e) ? [
          e
        ] : [
          t
        ]
      ])
    ];
  }
  function JV(r, e, t) {
    const n = xe(t) ? t : of, i = r;
    i.__localeChainCache || (i.__localeChainCache = /* @__PURE__ */ new Map());
    let a = i.__localeChainCache.get(n);
    if (!a) {
      a = [];
      let o = [
        t
      ];
      for (; Jt(o); ) o = Uk(a, o, e);
      const s = Jt(e) || !st(e) ? e : e.default ? e.default : null;
      o = xe(s) ? [
        s
      ] : s, Jt(o) && Uk(a, o, false), i.__localeChainCache.set(n, a);
    }
    return a;
  }
  function Uk(r, e, t) {
    let n = true;
    for (let i = 0; i < e.length && vt(n); i++) {
      const a = e[i];
      xe(a) && (n = FSe(r, e[i], t));
    }
    return n;
  }
  function FSe(r, e, t) {
    let n;
    const i = e.split("-");
    do {
      const a = i.join("-");
      n = BSe(r, a, t), i.splice(-1, 1);
    } while (i.length && n === true);
    return n;
  }
  function BSe(r, e, t) {
    let n = false;
    if (!r.includes(e) && (n = true, e)) {
      n = e[e.length - 1] !== "!";
      const i = e.replace(/!/g, "");
      r.push(i), (Jt(t) || st(t)) && t[i] && (n = t[i]);
    }
    return n;
  }
  const So = [];
  So[0] = {
    w: [
      0
    ],
    i: [
      3,
      0
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  So[1] = {
    w: [
      1
    ],
    ".": [
      2
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  So[2] = {
    w: [
      2
    ],
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ]
  };
  So[3] = {
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ],
    w: [
      1,
      1
    ],
    ".": [
      2,
      1
    ],
    "[": [
      4,
      1
    ],
    o: [
      7,
      1
    ]
  };
  So[4] = {
    "'": [
      5,
      0
    ],
    '"': [
      6,
      0
    ],
    "[": [
      4,
      2
    ],
    "]": [
      1,
      3
    ],
    o: 8,
    l: [
      4,
      0
    ]
  };
  So[5] = {
    "'": [
      4,
      0
    ],
    o: 8,
    l: [
      5,
      0
    ]
  };
  So[6] = {
    '"': [
      4,
      0
    ],
    o: 8,
    l: [
      6,
      0
    ]
  };
  const zSe = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function VSe(r) {
    return zSe.test(r);
  }
  function $Se(r) {
    const e = r.charCodeAt(0), t = r.charCodeAt(r.length - 1);
    return e === t && (e === 34 || e === 39) ? r.slice(1, -1) : r;
  }
  function GSe(r) {
    if (r == null) return "o";
    switch (r.charCodeAt(0)) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return r;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function WSe(r) {
    const e = r.trim();
    return r.charAt(0) === "0" && isNaN(parseInt(r)) ? false : VSe(e) ? $Se(e) : "*" + e;
  }
  function USe(r) {
    const e = [];
    let t = -1, n = 0, i = 0, a, o, s, l, u, c, h;
    const f = [];
    f[0] = () => {
      o === void 0 ? o = s : o += s;
    }, f[1] = () => {
      o !== void 0 && (e.push(o), o = void 0);
    }, f[2] = () => {
      f[0](), i++;
    }, f[3] = () => {
      if (i > 0) i--, n = 4, f[0]();
      else {
        if (i = 0, o === void 0 || (o = WSe(o), o === false)) return false;
        f[1]();
      }
    };
    function d() {
      const p = r[t + 1];
      if (n === 5 && p === "'" || n === 6 && p === '"') return t++, s = "\\" + p, f[0](), true;
    }
    for (; n !== null; ) if (t++, a = r[t], !(a === "\\" && d())) {
      if (l = GSe(a), h = So[n], u = h[l] || h.l || 8, u === 8 || (n = u[0], u[1] !== void 0 && (c = f[u[1]], c && (s = a, c() === false)))) return;
      if (n === 7) return e;
    }
  }
  const Hk = /* @__PURE__ */ new Map();
  function HSe(r, e) {
    return mt(r) ? r[e] : null;
  }
  function YSe(r, e) {
    if (!mt(r)) return null;
    let t = Hk.get(e);
    if (t || (t = USe(e), t && Hk.set(e, t)), !t) return null;
    const n = t.length;
    let i = r, a = 0;
    for (; a < n; ) {
      const o = i[t[a]];
      if (o === void 0 || Et(i)) return null;
      i = o, a++;
    }
    return i;
  }
  const XSe = "11.1.2", $g = -1, of = "en-US", Yk = "", Xk = (r) => `${r.charAt(0).toLocaleUpperCase()}${r.substr(1)}`;
  function qSe() {
    return {
      upper: (r, e) => e === "text" && xe(r) ? r.toUpperCase() : e === "vnode" && mt(r) && "__v_isVNode" in r ? r.children.toUpperCase() : r,
      lower: (r, e) => e === "text" && xe(r) ? r.toLowerCase() : e === "vnode" && mt(r) && "__v_isVNode" in r ? r.children.toLowerCase() : r,
      capitalize: (r, e) => e === "text" && xe(r) ? Xk(r) : e === "vnode" && mt(r) && "__v_isVNode" in r ? Xk(r.children) : r
    };
  }
  let e$;
  function KSe(r) {
    e$ = r;
  }
  let t$;
  function ZSe(r) {
    t$ = r;
  }
  let r$;
  function jSe(r) {
    r$ = r;
  }
  let n$ = null;
  const QSe = (r) => {
    n$ = r;
  }, JSe = () => n$;
  let i$ = null;
  const qk = (r) => {
    i$ = r;
  }, ewe = () => i$;
  let Kk = 0;
  function twe(r = {}) {
    const e = Et(r.onWarn) ? r.onWarn : $1e, t = xe(r.version) ? r.version : XSe, n = xe(r.locale) || Et(r.locale) ? r.locale : of, i = Et(n) ? of : n, a = Jt(r.fallbackLocale) || st(r.fallbackLocale) || xe(r.fallbackLocale) || r.fallbackLocale === false ? r.fallbackLocale : i, o = st(r.messages) ? r.messages : X0(i), s = st(r.datetimeFormats) ? r.datetimeFormats : X0(i), l = st(r.numberFormats) ? r.numberFormats : X0(i), u = sr(It(), r.modifiers, qSe()), c = r.pluralRules || It(), h = Et(r.missing) ? r.missing : null, f = vt(r.missingWarn) || wu(r.missingWarn) ? r.missingWarn : true, d = vt(r.fallbackWarn) || wu(r.fallbackWarn) ? r.fallbackWarn : true, p = !!r.fallbackFormat, v = !!r.unresolving, g = Et(r.postTranslation) ? r.postTranslation : null, m = st(r.processor) ? r.processor : null, y = vt(r.warnHtmlMessage) ? r.warnHtmlMessage : true, x = !!r.escapeParameter, _ = Et(r.messageCompiler) ? r.messageCompiler : e$, S = Et(r.messageResolver) ? r.messageResolver : t$ || HSe, b = Et(r.localeFallbacker) ? r.localeFallbacker : r$ || OSe, w = mt(r.fallbackContext) ? r.fallbackContext : void 0, C = r, T = mt(C.__datetimeFormatters) ? C.__datetimeFormatters : /* @__PURE__ */ new Map(), A = mt(C.__numberFormatters) ? C.__numberFormatters : /* @__PURE__ */ new Map(), M = mt(C.__meta) ? C.__meta : {};
    Kk++;
    const E = {
      version: t,
      cid: Kk,
      locale: n,
      fallbackLocale: a,
      messages: o,
      modifiers: u,
      pluralRules: c,
      missing: h,
      missingWarn: f,
      fallbackWarn: d,
      fallbackFormat: p,
      unresolving: v,
      postTranslation: g,
      processor: m,
      warnHtmlMessage: y,
      escapeParameter: x,
      messageCompiler: _,
      messageResolver: S,
      localeFallbacker: b,
      fallbackContext: w,
      onWarn: e,
      __meta: M
    };
    return E.datetimeFormats = s, E.numberFormats = l, E.__datetimeFormatters = T, E.__numberFormatters = A, __INTLIFY_PROD_DEVTOOLS__ && LSe(E, t, M), E;
  }
  const X0 = (r) => ({
    [r]: It()
  });
  function Mw(r, e, t, n, i) {
    const { missing: a, onWarn: o } = r;
    if (a !== null) {
      const s = a(r, t, e, i);
      return xe(s) ? s : e;
    } else return e;
  }
  function Ic(r, e, t) {
    const n = r;
    n.__localeChainCache = /* @__PURE__ */ new Map(), r.localeFallbacker(r, t, e);
  }
  function rwe(r, e) {
    return r === e ? false : r.split("-")[0] === e.split("-")[0];
  }
  function nwe(r, e) {
    const t = e.indexOf(r);
    if (t === -1) return false;
    for (let n = t + 1; n < e.length; n++) if (rwe(r, e[n])) return true;
    return false;
  }
  function Zk(r, ...e) {
    const { datetimeFormats: t, unresolving: n, fallbackLocale: i, onWarn: a, localeFallbacker: o } = r, { __datetimeFormatters: s } = r, [l, u, c, h] = bb(...e), f = vt(c.missingWarn) ? c.missingWarn : r.missingWarn;
    vt(c.fallbackWarn) ? c.fallbackWarn : r.fallbackWarn;
    const d = !!c.part, p = Iw(r, c), v = o(r, i, p);
    if (!xe(l) || l === "") return new Intl.DateTimeFormat(p, h).format(u);
    let g = {}, m, y = null;
    const x = "datetime format";
    for (let b = 0; b < v.length && (m = v[b], g = t[m] || {}, y = g[l], !st(y)); b++) Mw(r, l, m, f, x);
    if (!st(y) || !xe(m)) return n ? $g : l;
    let _ = `${m}__${l}`;
    zg(h) || (_ = `${_}__${JSON.stringify(h)}`);
    let S = s.get(_);
    return S || (S = new Intl.DateTimeFormat(m, sr({}, y, h)), s.set(_, S)), d ? S.formatToParts(u) : S.format(u);
  }
  const a$ = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function bb(...r) {
    const [e, t, n, i] = r, a = It();
    let o = It(), s;
    if (xe(e)) {
      const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!l) throw ia(na.INVALID_ISO_DATE_ARGUMENT);
      const u = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
      s = new Date(u);
      try {
        s.toISOString();
      } catch {
        throw ia(na.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (O1e(e)) {
      if (isNaN(e.getTime())) throw ia(na.INVALID_DATE_ARGUMENT);
      s = e;
    } else if (Zt(e)) s = e;
    else throw ia(na.INVALID_ARGUMENT);
    return xe(t) ? a.key = t : st(t) && Object.keys(t).forEach((l) => {
      a$.includes(l) ? o[l] = t[l] : a[l] = t[l];
    }), xe(n) ? a.locale = n : st(n) && (o = n), st(i) && (o = i), [
      a.key || "",
      s,
      a,
      o
    ];
  }
  function jk(r, e, t) {
    const n = r;
    for (const i in t) {
      const a = `${e}__${i}`;
      n.__datetimeFormatters.has(a) && n.__datetimeFormatters.delete(a);
    }
  }
  function Qk(r, ...e) {
    const { numberFormats: t, unresolving: n, fallbackLocale: i, onWarn: a, localeFallbacker: o } = r, { __numberFormatters: s } = r, [l, u, c, h] = Sb(...e), f = vt(c.missingWarn) ? c.missingWarn : r.missingWarn;
    vt(c.fallbackWarn) ? c.fallbackWarn : r.fallbackWarn;
    const d = !!c.part, p = Iw(r, c), v = o(r, i, p);
    if (!xe(l) || l === "") return new Intl.NumberFormat(p, h).format(u);
    let g = {}, m, y = null;
    const x = "number format";
    for (let b = 0; b < v.length && (m = v[b], g = t[m] || {}, y = g[l], !st(y)); b++) Mw(r, l, m, f, x);
    if (!st(y) || !xe(m)) return n ? $g : l;
    let _ = `${m}__${l}`;
    zg(h) || (_ = `${_}__${JSON.stringify(h)}`);
    let S = s.get(_);
    return S || (S = new Intl.NumberFormat(m, sr({}, y, h)), s.set(_, S)), d ? S.formatToParts(u) : S.format(u);
  }
  const o$ = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function Sb(...r) {
    const [e, t, n, i] = r, a = It();
    let o = It();
    if (!Zt(e)) throw ia(na.INVALID_ARGUMENT);
    const s = e;
    return xe(t) ? a.key = t : st(t) && Object.keys(t).forEach((l) => {
      o$.includes(l) ? o[l] = t[l] : a[l] = t[l];
    }), xe(n) ? a.locale = n : st(n) && (o = n), st(i) && (o = i), [
      a.key || "",
      s,
      a,
      o
    ];
  }
  function Jk(r, e, t) {
    const n = r;
    for (const i in t) {
      const a = `${e}__${i}`;
      n.__numberFormatters.has(a) && n.__numberFormatters.delete(a);
    }
  }
  const iwe = (r) => r, awe = (r) => "", owe = "text", swe = (r) => r.length === 0 ? "" : Cw(r), lwe = V1e;
  function eL(r, e) {
    return r = Math.abs(r), e === 2 ? r ? r > 1 ? 1 : 0 : 1 : r ? Math.min(r, 2) : 0;
  }
  function uwe(r) {
    const e = Zt(r.pluralIndex) ? r.pluralIndex : -1;
    return r.named && (Zt(r.named.count) || Zt(r.named.n)) ? Zt(r.named.count) ? r.named.count : Zt(r.named.n) ? r.named.n : e : e;
  }
  function cwe(r, e) {
    e.count || (e.count = r), e.n || (e.n = r);
  }
  function hwe(r = {}) {
    const e = r.locale, t = uwe(r), n = mt(r.pluralRules) && xe(e) && Et(r.pluralRules[e]) ? r.pluralRules[e] : eL, i = mt(r.pluralRules) && xe(e) && Et(r.pluralRules[e]) ? eL : void 0, a = (m) => m[n(t, m.length, i)], o = r.list || [], s = (m) => o[m], l = r.named || It();
    Zt(r.pluralIndex) && cwe(t, l);
    const u = (m) => l[m];
    function c(m, y) {
      const x = Et(r.messages) ? r.messages(m, !!y) : mt(r.messages) ? r.messages[m] : false;
      return x || (r.parent ? r.parent.message(m) : awe);
    }
    const h = (m) => r.modifiers ? r.modifiers[m] : iwe, f = st(r.processor) && Et(r.processor.normalize) ? r.processor.normalize : swe, d = st(r.processor) && Et(r.processor.interpolate) ? r.processor.interpolate : lwe, p = st(r.processor) && xe(r.processor.type) ? r.processor.type : owe, g = {
      list: s,
      named: u,
      plural: a,
      linked: (m, ...y) => {
        const [x, _] = y;
        let S = "text", b = "";
        y.length === 1 ? mt(x) ? (b = x.modifier || b, S = x.type || S) : xe(x) && (b = x || b) : y.length === 2 && (xe(x) && (b = x || b), xe(_) && (S = _ || S));
        const w = c(m, true)(g), C = S === "vnode" && Jt(w) && b ? w[0] : w;
        return b ? h(b)(C, S) : C;
      },
      message: c,
      type: p,
      interpolate: d,
      normalize: f,
      values: sr(It(), o, l)
    };
    return g;
  }
  const tL = () => "", Rn = (r) => Et(r);
  function rL(r, ...e) {
    const { fallbackFormat: t, postTranslation: n, unresolving: i, messageCompiler: a, fallbackLocale: o, messages: s } = r, [l, u] = wb(...e), c = vt(u.missingWarn) ? u.missingWarn : r.missingWarn, h = vt(u.fallbackWarn) ? u.fallbackWarn : r.fallbackWarn, f = vt(u.escapeParameter) ? u.escapeParameter : r.escapeParameter, d = !!u.resolvedMessage, p = xe(u.default) || vt(u.default) ? vt(u.default) ? a ? l : () => l : u.default : t ? a ? l : () => l : null, v = t || p != null && (xe(p) || Et(p)), g = Iw(r, u);
    f && fwe(u);
    let [m, y, x] = d ? [
      l,
      g,
      s[g] || It()
    ] : s$(r, l, g, o, h, c), _ = m, S = l;
    if (!d && !(xe(_) || Tu(_) || Rn(_)) && v && (_ = p, S = _), !d && (!(xe(_) || Tu(_) || Rn(_)) || !xe(y))) return i ? $g : l;
    let b = false;
    const w = () => {
      b = true;
    }, C = Rn(_) ? _ : l$(r, l, y, _, S, w);
    if (b) return _;
    const T = vwe(r, y, x, u), A = hwe(T), M = dwe(r, C, A), E = n ? n(M, l) : M;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const k = {
        timestamp: Date.now(),
        key: xe(l) ? l : Rn(_) ? _.key : "",
        locale: y || (Rn(_) ? _.locale : ""),
        format: xe(_) ? _ : Rn(_) ? _.source : "",
        message: E
      };
      k.meta = sr({}, r.__meta, JSe() || {}), RSe(k);
    }
    return E;
  }
  function fwe(r) {
    Jt(r.list) ? r.list = r.list.map((e) => xe(e) ? Bk(e) : e) : mt(r.named) && Object.keys(r.named).forEach((e) => {
      xe(r.named[e]) && (r.named[e] = Bk(r.named[e]));
    });
  }
  function s$(r, e, t, n, i, a) {
    const { messages: o, onWarn: s, messageResolver: l, localeFallbacker: u } = r, c = u(r, n, t);
    let h = It(), f, d = null;
    const p = "translate";
    for (let v = 0; v < c.length && (f = c[v], h = o[f] || It(), (d = l(h, e)) === null && (d = h[e]), !(xe(d) || Tu(d) || Rn(d))); v++) if (!nwe(f, c)) {
      const g = Mw(r, e, f, a, p);
      g !== e && (d = g);
    }
    return [
      d,
      f,
      h
    ];
  }
  function l$(r, e, t, n, i, a) {
    const { messageCompiler: o, warnHtmlMessage: s } = r;
    if (Rn(n)) {
      const u = n;
      return u.locale = u.locale || t, u.key = u.key || e, u;
    }
    if (o == null) {
      const u = () => n;
      return u.locale = t, u.key = e, u;
    }
    const l = o(n, pwe(r, t, i, n, s, a));
    return l.locale = t, l.key = e, l.source = n, l;
  }
  function dwe(r, e, t) {
    return e(t);
  }
  function wb(...r) {
    const [e, t, n] = r, i = It();
    if (!xe(e) && !Zt(e) && !Rn(e) && !Tu(e)) throw ia(na.INVALID_ARGUMENT);
    const a = Zt(e) ? String(e) : (Rn(e), e);
    return Zt(t) ? i.plural = t : xe(t) ? i.default = t : st(t) && !zg(t) ? i.named = t : Jt(t) && (i.list = t), Zt(n) ? i.plural = n : xe(n) ? i.default = n : st(n) && sr(i, n), [
      a,
      i
    ];
  }
  function pwe(r, e, t, n, i, a) {
    return {
      locale: e,
      key: t,
      warnHtmlMessage: i,
      onError: (o) => {
        throw a && a(o), o;
      },
      onCacheKey: (o) => E1e(e, t, o)
    };
  }
  function vwe(r, e, t, n) {
    const { modifiers: i, pluralRules: a, messageResolver: o, fallbackLocale: s, fallbackWarn: l, missingWarn: u, fallbackContext: c } = r, f = {
      locale: e,
      modifiers: i,
      pluralRules: a,
      messages: (d, p) => {
        let v = o(t, d);
        if (v == null && (c || p)) {
          const [, , g] = s$(c || r, d, e, s, l, u);
          v = o(g, d);
        }
        if (xe(v) || Tu(v)) {
          let g = false;
          const y = l$(r, d, e, v, d, () => {
            g = true;
          });
          return g ? tL : y;
        } else return Rn(v) ? v : tL;
      }
    };
    return r.processor && (f.processor = r.processor), n.list && (f.list = n.list), n.named && (f.named = n.named), Zt(n.plural) && (f.pluralIndex = n.plural), f;
  }
  fSe();
  const gwe = "11.1.2";
  function mwe() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Ts().__VUE_I18N_FULL_INSTALL__ = true), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Ts().__VUE_I18N_LEGACY_API__ = true), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Ts().__INTLIFY_DROP_MESSAGE_COMPILER__ = false), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Ts().__INTLIFY_PROD_DEVTOOLS__ = false);
  }
  const un = {
    UNEXPECTED_RETURN_TYPE: NSe,
    INVALID_ARGUMENT: 25,
    MUST_BE_CALL_SETUP_TOP: 26,
    NOT_INSTALLED: 27,
    REQUIRED_VALUE: 28,
    INVALID_VALUE: 29,
    NOT_INSTALLED_WITH_PROVIDE: 31,
    UNEXPECTED_ERROR: 32
  };
  function xn(r, ...e) {
    return Vg(r, null, void 0);
  }
  const Cb = _o("__translateVNode"), Tb = _o("__datetimeParts"), Ab = _o("__numberParts"), u$ = _o("__setPluralRules"), c$ = _o("__injectWithOption"), Ib = _o("__dispose");
  function sf(r) {
    if (!mt(r)) return r;
    for (const e in r) if (ri(r, e)) if (!e.includes(".")) mt(r[e]) && sf(r[e]);
    else {
      const t = e.split("."), n = t.length - 1;
      let i = r, a = false;
      for (let o = 0; o < n; o++) {
        if (t[o] === "__proto__") throw new Error(`unsafe key: ${t[o]}`);
        if (t[o] in i || (i[t[o]] = It()), !mt(i[t[o]])) {
          a = true;
          break;
        }
        i = i[t[o]];
      }
      a || (i[t[n]] = r[e], delete r[e]), mt(i[t[n]]) && sf(i[t[n]]);
    }
    return r;
  }
  function Dw(r, e) {
    const { messages: t, __i18n: n, messageResolver: i, flatJson: a } = e, o = st(t) ? t : Jt(n) ? It() : {
      [r]: It()
    };
    if (Jt(n) && n.forEach((s) => {
      if ("locale" in s && "resource" in s) {
        const { locale: l, resource: u } = s;
        l ? (o[l] = o[l] || It(), Ep(u, o[l])) : Ep(u, o);
      } else xe(s) && Ep(JSON.parse(s), o);
    }), i == null && a) for (const s in o) ri(o, s) && sf(o[s]);
    return o;
  }
  function h$(r) {
    return r.type;
  }
  function f$(r, e, t) {
    let n = mt(e.messages) ? e.messages : It();
    "__i18nGlobal" in t && (n = Dw(r.locale.value, {
      messages: n,
      __i18n: t.__i18nGlobal
    }));
    const i = Object.keys(n);
    i.length && i.forEach((a) => {
      r.mergeLocaleMessage(a, n[a]);
    });
    {
      if (mt(e.datetimeFormats)) {
        const a = Object.keys(e.datetimeFormats);
        a.length && a.forEach((o) => {
          r.mergeDateTimeFormat(o, e.datetimeFormats[o]);
        });
      }
      if (mt(e.numberFormats)) {
        const a = Object.keys(e.numberFormats);
        a.length && a.forEach((o) => {
          r.mergeNumberFormat(o, e.numberFormats[o]);
        });
      }
    }
  }
  function nL(r) {
    return Ge(L4, null, r, 0);
  }
  const iL = "__INTLIFY_META__", aL = () => [], ywe = () => false;
  let oL = 0;
  function sL(r) {
    return (e, t, n, i) => r(t, n, yn() || void 0, i);
  }
  const xwe = () => {
    const r = yn();
    let e = null;
    return r && (e = h$(r)[iL]) ? {
      [iL]: e
    } : null;
  };
  function Pw(r = {}) {
    const { __root: e, __injectWithOption: t } = r, n = e === void 0, i = r.flatJson, a = zv ? We : k4;
    let o = vt(r.inheritLocale) ? r.inheritLocale : true;
    const s = a(e && o ? e.locale.value : xe(r.locale) ? r.locale : of), l = a(e && o ? e.fallbackLocale.value : xe(r.fallbackLocale) || Jt(r.fallbackLocale) || st(r.fallbackLocale) || r.fallbackLocale === false ? r.fallbackLocale : s.value), u = a(Dw(s.value, r)), c = a(st(r.datetimeFormats) ? r.datetimeFormats : {
      [s.value]: {}
    }), h = a(st(r.numberFormats) ? r.numberFormats : {
      [s.value]: {}
    });
    let f = e ? e.missingWarn : vt(r.missingWarn) || wu(r.missingWarn) ? r.missingWarn : true, d = e ? e.fallbackWarn : vt(r.fallbackWarn) || wu(r.fallbackWarn) ? r.fallbackWarn : true, p = e ? e.fallbackRoot : vt(r.fallbackRoot) ? r.fallbackRoot : true, v = !!r.fallbackFormat, g = Et(r.missing) ? r.missing : null, m = Et(r.missing) ? sL(r.missing) : null, y = Et(r.postTranslation) ? r.postTranslation : null, x = e ? e.warnHtmlMessage : vt(r.warnHtmlMessage) ? r.warnHtmlMessage : true, _ = !!r.escapeParameter;
    const S = e ? e.modifiers : st(r.modifiers) ? r.modifiers : {};
    let b = r.pluralRules || e && e.pluralRules, w;
    w = (() => {
      n && qk(null);
      const Z = {
        version: gwe,
        locale: s.value,
        fallbackLocale: l.value,
        messages: u.value,
        modifiers: S,
        pluralRules: b,
        missing: m === null ? void 0 : m,
        missingWarn: f,
        fallbackWarn: d,
        fallbackFormat: v,
        unresolving: true,
        postTranslation: y === null ? void 0 : y,
        warnHtmlMessage: x,
        escapeParameter: _,
        messageResolver: r.messageResolver,
        messageCompiler: r.messageCompiler,
        __meta: {
          framework: "vue"
        }
      };
      Z.datetimeFormats = c.value, Z.numberFormats = h.value, Z.__datetimeFormatters = st(w) ? w.__datetimeFormatters : void 0, Z.__numberFormatters = st(w) ? w.__numberFormatters : void 0;
      const ae = twe(Z);
      return n && qk(ae), ae;
    })(), Ic(w, s.value, l.value);
    function T() {
      return [
        s.value,
        l.value,
        u.value,
        c.value,
        h.value
      ];
    }
    const A = at({
      get: () => s.value,
      set: (Z) => {
        w.locale = Z, s.value = Z;
      }
    }), M = at({
      get: () => l.value,
      set: (Z) => {
        w.fallbackLocale = Z, l.value = Z, Ic(w, s.value, Z);
      }
    }), E = at(() => u.value), k = at(() => c.value), R = at(() => h.value);
    function N() {
      return Et(y) ? y : null;
    }
    function I(Z) {
      y = Z, w.postTranslation = Z;
    }
    function L() {
      return g;
    }
    function P(Z) {
      Z !== null && (m = sL(Z)), g = Z, w.missing = m;
    }
    const O = (Z, ae, Dt, Ut, Co, Bf) => {
      T();
      let sl;
      try {
        __INTLIFY_PROD_DEVTOOLS__, n || (w.fallbackContext = e ? ewe() : void 0), sl = Z(w);
      } finally {
        __INTLIFY_PROD_DEVTOOLS__, n || (w.fallbackContext = void 0);
      }
      if (Dt !== "translate exists" && Zt(sl) && sl === $g || Dt === "translate exists" && !sl) {
        const [z$, BAe] = ae();
        return e && p ? Ut(e) : Co(z$);
      } else {
        if (Bf(sl)) return sl;
        throw xn(un.UNEXPECTED_RETURN_TYPE);
      }
    };
    function F(...Z) {
      return O((ae) => Reflect.apply(rL, null, [
        ae,
        ...Z
      ]), () => wb(...Z), "translate", (ae) => Reflect.apply(ae.t, ae, [
        ...Z
      ]), (ae) => ae, (ae) => xe(ae));
    }
    function B(...Z) {
      const [ae, Dt, Ut] = Z;
      if (Ut && !mt(Ut)) throw xn(un.INVALID_ARGUMENT);
      return F(ae, Dt, sr({
        resolvedMessage: true
      }, Ut || {}));
    }
    function V(...Z) {
      return O((ae) => Reflect.apply(Zk, null, [
        ae,
        ...Z
      ]), () => bb(...Z), "datetime format", (ae) => Reflect.apply(ae.d, ae, [
        ...Z
      ]), () => Yk, (ae) => xe(ae));
    }
    function U(...Z) {
      return O((ae) => Reflect.apply(Qk, null, [
        ae,
        ...Z
      ]), () => Sb(...Z), "number format", (ae) => Reflect.apply(ae.n, ae, [
        ...Z
      ]), () => Yk, (ae) => xe(ae));
    }
    function Y(Z) {
      return Z.map((ae) => xe(ae) || Zt(ae) || vt(ae) ? nL(String(ae)) : ae);
    }
    const me = {
      normalize: Y,
      interpolate: (Z) => Z,
      type: "vnode"
    };
    function Me(...Z) {
      return O((ae) => {
        let Dt;
        const Ut = ae;
        try {
          Ut.processor = me, Dt = Reflect.apply(rL, null, [
            Ut,
            ...Z
          ]);
        } finally {
          Ut.processor = null;
        }
        return Dt;
      }, () => wb(...Z), "translate", (ae) => ae[Cb](...Z), (ae) => [
        nL(ae)
      ], (ae) => Jt(ae));
    }
    function re(...Z) {
      return O((ae) => Reflect.apply(Qk, null, [
        ae,
        ...Z
      ]), () => Sb(...Z), "number format", (ae) => ae[Ab](...Z), aL, (ae) => xe(ae) || Jt(ae));
    }
    function J(...Z) {
      return O((ae) => Reflect.apply(Zk, null, [
        ae,
        ...Z
      ]), () => bb(...Z), "datetime format", (ae) => ae[Tb](...Z), aL, (ae) => xe(ae) || Jt(ae));
    }
    function le(Z) {
      b = Z, w.pluralRules = b;
    }
    function te(Z, ae) {
      return O(() => {
        if (!Z) return false;
        const Dt = xe(ae) ? ae : s.value, Ut = Fe(Dt), Co = w.messageResolver(Ut, Z);
        return Tu(Co) || Rn(Co) || xe(Co);
      }, () => [
        Z
      ], "translate exists", (Dt) => Reflect.apply(Dt.te, Dt, [
        Z,
        ae
      ]), ywe, (Dt) => vt(Dt));
    }
    function he(Z) {
      let ae = null;
      const Dt = JV(w, l.value, s.value);
      for (let Ut = 0; Ut < Dt.length; Ut++) {
        const Co = u.value[Dt[Ut]] || {}, Bf = w.messageResolver(Co, Z);
        if (Bf != null) {
          ae = Bf;
          break;
        }
      }
      return ae;
    }
    function Xe(Z) {
      const ae = he(Z);
      return ae ?? (e ? e.tm(Z) || {} : {});
    }
    function Fe(Z) {
      return u.value[Z] || {};
    }
    function fe(Z, ae) {
      if (i) {
        const Dt = {
          [Z]: ae
        };
        for (const Ut in Dt) ri(Dt, Ut) && sf(Dt[Ut]);
        ae = Dt[Z];
      }
      u.value[Z] = ae, w.messages = u.value;
    }
    function Se(Z, ae) {
      u.value[Z] = u.value[Z] || {};
      const Dt = {
        [Z]: ae
      };
      if (i) for (const Ut in Dt) ri(Dt, Ut) && sf(Dt[Ut]);
      ae = Dt[Z], Ep(ae, u.value[Z]), w.messages = u.value;
    }
    function Lt(Z) {
      return c.value[Z] || {};
    }
    function z(Z, ae) {
      c.value[Z] = ae, w.datetimeFormats = c.value, jk(w, Z, ae);
    }
    function $(Z, ae) {
      c.value[Z] = sr(c.value[Z] || {}, ae), w.datetimeFormats = c.value, jk(w, Z, ae);
    }
    function j(Z) {
      return h.value[Z] || {};
    }
    function Te(Z, ae) {
      h.value[Z] = ae, w.numberFormats = h.value, Jk(w, Z, ae);
    }
    function Ot(Z, ae) {
      h.value[Z] = sr(h.value[Z] || {}, ae), w.numberFormats = h.value, Jk(w, Z, ae);
    }
    oL++, e && zv && (Pr(e.locale, (Z) => {
      o && (s.value = Z, w.locale = Z, Ic(w, s.value, l.value));
    }), Pr(e.fallbackLocale, (Z) => {
      o && (l.value = Z, w.fallbackLocale = Z, Ic(w, s.value, l.value));
    }));
    const Qe = {
      id: oL,
      locale: A,
      fallbackLocale: M,
      get inheritLocale() {
        return o;
      },
      set inheritLocale(Z) {
        o = Z, Z && e && (s.value = e.locale.value, l.value = e.fallbackLocale.value, Ic(w, s.value, l.value));
      },
      get availableLocales() {
        return Object.keys(u.value).sort();
      },
      messages: E,
      get modifiers() {
        return S;
      },
      get pluralRules() {
        return b || {};
      },
      get isGlobal() {
        return n;
      },
      get missingWarn() {
        return f;
      },
      set missingWarn(Z) {
        f = Z, w.missingWarn = f;
      },
      get fallbackWarn() {
        return d;
      },
      set fallbackWarn(Z) {
        d = Z, w.fallbackWarn = d;
      },
      get fallbackRoot() {
        return p;
      },
      set fallbackRoot(Z) {
        p = Z;
      },
      get fallbackFormat() {
        return v;
      },
      set fallbackFormat(Z) {
        v = Z, w.fallbackFormat = v;
      },
      get warnHtmlMessage() {
        return x;
      },
      set warnHtmlMessage(Z) {
        x = Z, w.warnHtmlMessage = Z;
      },
      get escapeParameter() {
        return _;
      },
      set escapeParameter(Z) {
        _ = Z, w.escapeParameter = Z;
      },
      t: F,
      getLocaleMessage: Fe,
      setLocaleMessage: fe,
      mergeLocaleMessage: Se,
      getPostTranslationHandler: N,
      setPostTranslationHandler: I,
      getMissingHandler: L,
      setMissingHandler: P,
      [u$]: le
    };
    return Qe.datetimeFormats = k, Qe.numberFormats = R, Qe.rt = B, Qe.te = te, Qe.tm = Xe, Qe.d = V, Qe.n = U, Qe.getDateTimeFormat = Lt, Qe.setDateTimeFormat = z, Qe.mergeDateTimeFormat = $, Qe.getNumberFormat = j, Qe.setNumberFormat = Te, Qe.mergeNumberFormat = Ot, Qe[c$] = t, Qe[Cb] = Me, Qe[Tb] = J, Qe[Ab] = re, Qe;
  }
  function _we(r) {
    const e = xe(r.locale) ? r.locale : of, t = xe(r.fallbackLocale) || Jt(r.fallbackLocale) || st(r.fallbackLocale) || r.fallbackLocale === false ? r.fallbackLocale : e, n = Et(r.missing) ? r.missing : void 0, i = vt(r.silentTranslationWarn) || wu(r.silentTranslationWarn) ? !r.silentTranslationWarn : true, a = vt(r.silentFallbackWarn) || wu(r.silentFallbackWarn) ? !r.silentFallbackWarn : true, o = vt(r.fallbackRoot) ? r.fallbackRoot : true, s = !!r.formatFallbackMessages, l = st(r.modifiers) ? r.modifiers : {}, u = r.pluralizationRules, c = Et(r.postTranslation) ? r.postTranslation : void 0, h = xe(r.warnHtmlInMessage) ? r.warnHtmlInMessage !== "off" : true, f = !!r.escapeParameterHtml, d = vt(r.sync) ? r.sync : true;
    let p = r.messages;
    if (st(r.sharedMessages)) {
      const S = r.sharedMessages;
      p = Object.keys(S).reduce((w, C) => {
        const T = w[C] || (w[C] = {});
        return sr(T, S[C]), w;
      }, p || {});
    }
    const { __i18n: v, __root: g, __injectWithOption: m } = r, y = r.datetimeFormats, x = r.numberFormats, _ = r.flatJson;
    return {
      locale: e,
      fallbackLocale: t,
      messages: p,
      flatJson: _,
      datetimeFormats: y,
      numberFormats: x,
      missing: n,
      missingWarn: i,
      fallbackWarn: a,
      fallbackRoot: o,
      fallbackFormat: s,
      modifiers: l,
      pluralRules: u,
      postTranslation: c,
      warnHtmlMessage: h,
      escapeParameter: f,
      messageResolver: r.messageResolver,
      inheritLocale: d,
      __i18n: v,
      __root: g,
      __injectWithOption: m
    };
  }
  function Mb(r = {}) {
    const e = Pw(_we(r)), { __extender: t } = r, n = {
      id: e.id,
      get locale() {
        return e.locale.value;
      },
      set locale(i) {
        e.locale.value = i;
      },
      get fallbackLocale() {
        return e.fallbackLocale.value;
      },
      set fallbackLocale(i) {
        e.fallbackLocale.value = i;
      },
      get messages() {
        return e.messages.value;
      },
      get datetimeFormats() {
        return e.datetimeFormats.value;
      },
      get numberFormats() {
        return e.numberFormats.value;
      },
      get availableLocales() {
        return e.availableLocales;
      },
      get missing() {
        return e.getMissingHandler();
      },
      set missing(i) {
        e.setMissingHandler(i);
      },
      get silentTranslationWarn() {
        return vt(e.missingWarn) ? !e.missingWarn : e.missingWarn;
      },
      set silentTranslationWarn(i) {
        e.missingWarn = vt(i) ? !i : i;
      },
      get silentFallbackWarn() {
        return vt(e.fallbackWarn) ? !e.fallbackWarn : e.fallbackWarn;
      },
      set silentFallbackWarn(i) {
        e.fallbackWarn = vt(i) ? !i : i;
      },
      get modifiers() {
        return e.modifiers;
      },
      get formatFallbackMessages() {
        return e.fallbackFormat;
      },
      set formatFallbackMessages(i) {
        e.fallbackFormat = i;
      },
      get postTranslation() {
        return e.getPostTranslationHandler();
      },
      set postTranslation(i) {
        e.setPostTranslationHandler(i);
      },
      get sync() {
        return e.inheritLocale;
      },
      set sync(i) {
        e.inheritLocale = i;
      },
      get warnHtmlInMessage() {
        return e.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(i) {
        e.warnHtmlMessage = i !== "off";
      },
      get escapeParameterHtml() {
        return e.escapeParameter;
      },
      set escapeParameterHtml(i) {
        e.escapeParameter = i;
      },
      get pluralizationRules() {
        return e.pluralRules || {};
      },
      __composer: e,
      t(...i) {
        return Reflect.apply(e.t, e, [
          ...i
        ]);
      },
      rt(...i) {
        return Reflect.apply(e.rt, e, [
          ...i
        ]);
      },
      te(i, a) {
        return e.te(i, a);
      },
      tm(i) {
        return e.tm(i);
      },
      getLocaleMessage(i) {
        return e.getLocaleMessage(i);
      },
      setLocaleMessage(i, a) {
        e.setLocaleMessage(i, a);
      },
      mergeLocaleMessage(i, a) {
        e.mergeLocaleMessage(i, a);
      },
      d(...i) {
        return Reflect.apply(e.d, e, [
          ...i
        ]);
      },
      getDateTimeFormat(i) {
        return e.getDateTimeFormat(i);
      },
      setDateTimeFormat(i, a) {
        e.setDateTimeFormat(i, a);
      },
      mergeDateTimeFormat(i, a) {
        e.mergeDateTimeFormat(i, a);
      },
      n(...i) {
        return Reflect.apply(e.n, e, [
          ...i
        ]);
      },
      getNumberFormat(i) {
        return e.getNumberFormat(i);
      },
      setNumberFormat(i, a) {
        e.setNumberFormat(i, a);
      },
      mergeNumberFormat(i, a) {
        e.mergeNumberFormat(i, a);
      }
    };
    return n.__extender = t, n;
  }
  function bwe(r, e, t) {
    return {
      beforeCreate() {
        const n = yn();
        if (!n) throw xn(un.UNEXPECTED_ERROR);
        const i = this.$options;
        if (i.i18n) {
          const a = i.i18n;
          if (i.__i18n && (a.__i18n = i.__i18n), a.__root = e, this === this.$root) this.$i18n = lL(r, a);
          else {
            a.__injectWithOption = true, a.__extender = t.__vueI18nExtend, this.$i18n = Mb(a);
            const o = this.$i18n;
            o.__extender && (o.__disposer = o.__extender(this.$i18n));
          }
        } else if (i.__i18n) if (this === this.$root) this.$i18n = lL(r, i);
        else {
          this.$i18n = Mb({
            __i18n: i.__i18n,
            __injectWithOption: true,
            __extender: t.__vueI18nExtend,
            __root: e
          });
          const a = this.$i18n;
          a.__extender && (a.__disposer = a.__extender(this.$i18n));
        }
        else this.$i18n = r;
        i.__i18nGlobal && f$(e, i, i), this.$t = (...a) => this.$i18n.t(...a), this.$rt = (...a) => this.$i18n.rt(...a), this.$te = (a, o) => this.$i18n.te(a, o), this.$d = (...a) => this.$i18n.d(...a), this.$n = (...a) => this.$i18n.n(...a), this.$tm = (a) => this.$i18n.tm(a), t.__setInstance(n, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const n = yn();
        if (!n) throw xn(un.UNEXPECTED_ERROR);
        const i = this.$i18n;
        delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), t.__deleteInstance(n), delete this.$i18n;
      }
    };
  }
  function lL(r, e) {
    r.locale = e.locale || r.locale, r.fallbackLocale = e.fallbackLocale || r.fallbackLocale, r.missing = e.missing || r.missing, r.silentTranslationWarn = e.silentTranslationWarn || r.silentFallbackWarn, r.silentFallbackWarn = e.silentFallbackWarn || r.silentFallbackWarn, r.formatFallbackMessages = e.formatFallbackMessages || r.formatFallbackMessages, r.postTranslation = e.postTranslation || r.postTranslation, r.warnHtmlInMessage = e.warnHtmlInMessage || r.warnHtmlInMessage, r.escapeParameterHtml = e.escapeParameterHtml || r.escapeParameterHtml, r.sync = e.sync || r.sync, r.__composer[u$](e.pluralizationRules || r.pluralizationRules);
    const t = Dw(r.locale, {
      messages: e.messages,
      __i18n: e.__i18n
    });
    return Object.keys(t).forEach((n) => r.mergeLocaleMessage(n, t[n])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach((n) => r.mergeDateTimeFormat(n, e.datetimeFormats[n])), e.numberFormats && Object.keys(e.numberFormats).forEach((n) => r.mergeNumberFormat(n, e.numberFormats[n])), r;
  }
  const kw = {
    tag: {
      type: [
        String,
        Object
      ]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (r) => r === "parent" || r === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  function Swe({ slots: r }, e) {
    return e.length === 1 && e[0] === "default" ? (r.default ? r.default() : []).reduce((n, i) => [
      ...n,
      ...i.type === mh ? i.children : [
        i
      ]
    ], []) : e.reduce((t, n) => {
      const i = r[n];
      return i && (t[n] = i()), t;
    }, It());
  }
  function d$() {
    return mh;
  }
  const wwe = Ye({
    name: "i18n-t",
    props: sr({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [
          Number,
          String
        ],
        validator: (r) => Zt(r) || !isNaN(r)
      }
    }, kw),
    setup(r, e) {
      const { slots: t, attrs: n } = e, i = r.i18n || Lw({
        useScope: r.scope,
        __useComponent: true
      });
      return () => {
        const a = Object.keys(t).filter((h) => h !== "_"), o = It();
        r.locale && (o.locale = r.locale), r.plural !== void 0 && (o.plural = xe(r.plural) ? +r.plural : r.plural);
        const s = Swe(e, a), l = i[Cb](r.keypath, s, o), u = sr(It(), n), c = xe(r.tag) || mt(r.tag) ? r.tag : d$();
        return ni(c, u, l);
      };
    }
  }), uL = wwe;
  function Cwe(r) {
    return Jt(r) && !xe(r[0]);
  }
  function p$(r, e, t, n) {
    const { slots: i, attrs: a } = e;
    return () => {
      const o = {
        part: true
      };
      let s = It();
      r.locale && (o.locale = r.locale), xe(r.format) ? o.key = r.format : mt(r.format) && (xe(r.format.key) && (o.key = r.format.key), s = Object.keys(r.format).reduce((f, d) => t.includes(d) ? sr(It(), f, {
        [d]: r.format[d]
      }) : f, It()));
      const l = n(r.value, o, s);
      let u = [
        o.key
      ];
      Jt(l) ? u = l.map((f, d) => {
        const p = i[f.type], v = p ? p({
          [f.type]: f.value,
          index: d,
          parts: l
        }) : [
          f.value
        ];
        return Cwe(v) && (v[0].key = `${f.type}-${d}`), v;
      }) : xe(l) && (u = [
        l
      ]);
      const c = sr(It(), a), h = xe(r.tag) || mt(r.tag) ? r.tag : d$();
      return ni(h, c, u);
    };
  }
  const Twe = Ye({
    name: "i18n-n",
    props: sr({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, kw),
    setup(r, e) {
      const t = r.i18n || Lw({
        useScope: r.scope,
        __useComponent: true
      });
      return p$(r, e, o$, (...n) => t[Ab](...n));
    }
  }), cL = Twe;
  function Awe(r, e) {
    const t = r;
    if (r.mode === "composition") return t.__getInstance(e) || r.global;
    {
      const n = t.__getInstance(e);
      return n != null ? n.__composer : r.global.__composer;
    }
  }
  function Iwe(r) {
    const e = (o) => {
      const { instance: s, value: l } = o;
      if (!s || !s.$) throw xn(un.UNEXPECTED_ERROR);
      const u = Awe(r, s.$), c = hL(l);
      return [
        Reflect.apply(u.t, u, [
          ...fL(c)
        ]),
        u
      ];
    };
    return {
      created: (o, s) => {
        const [l, u] = e(s);
        zv && r.global === u && (o.__i18nWatcher = Pr(u.locale, () => {
          s.instance && s.instance.$forceUpdate();
        })), o.__composer = u, o.textContent = l;
      },
      unmounted: (o) => {
        zv && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer);
      },
      beforeUpdate: (o, { value: s }) => {
        if (o.__composer) {
          const l = o.__composer, u = hL(s);
          o.textContent = Reflect.apply(l.t, l, [
            ...fL(u)
          ]);
        }
      },
      getSSRProps: (o) => {
        const [s] = e(o);
        return {
          textContent: s
        };
      }
    };
  }
  function hL(r) {
    if (xe(r)) return {
      path: r
    };
    if (st(r)) {
      if (!("path" in r)) throw xn(un.REQUIRED_VALUE, "path");
      return r;
    } else throw xn(un.INVALID_VALUE);
  }
  function fL(r) {
    const { path: e, locale: t, args: n, choice: i, plural: a } = r, o = {}, s = n || {};
    return xe(t) && (o.locale = t), Zt(i) && (o.plural = i), Zt(a) && (o.plural = a), [
      e,
      s,
      o
    ];
  }
  function Mwe(r, e, ...t) {
    const n = st(t[0]) ? t[0] : {};
    (vt(n.globalInstall) ? n.globalInstall : true) && ([
      uL.name,
      "I18nT"
    ].forEach((a) => r.component(a, uL)), [
      cL.name,
      "I18nN"
    ].forEach((a) => r.component(a, cL)), [
      pL.name,
      "I18nD"
    ].forEach((a) => r.component(a, pL))), r.directive("t", Iwe(e));
  }
  const Dwe = _o("global-vue-i18n");
  function Pwe(r = {}) {
    const e = __VUE_I18N_LEGACY_API__ && vt(r.legacy) ? r.legacy : __VUE_I18N_LEGACY_API__, t = vt(r.globalInjection) ? r.globalInjection : true, n = /* @__PURE__ */ new Map(), [i, a] = kwe(r, e), o = _o("");
    function s(h) {
      return n.get(h) || null;
    }
    function l(h, f) {
      n.set(h, f);
    }
    function u(h) {
      n.delete(h);
    }
    const c = {
      get mode() {
        return __VUE_I18N_LEGACY_API__ && e ? "legacy" : "composition";
      },
      async install(h, ...f) {
        if (h.__VUE_I18N_SYMBOL__ = o, h.provide(h.__VUE_I18N_SYMBOL__, c), st(f[0])) {
          const v = f[0];
          c.__composerExtend = v.__composerExtend, c.__vueI18nExtend = v.__vueI18nExtend;
        }
        let d = null;
        !e && t && (d = zwe(h, c.global)), __VUE_I18N_FULL_INSTALL__ && Mwe(h, c, ...f), __VUE_I18N_LEGACY_API__ && e && h.mixin(bwe(a, a.__composer, c));
        const p = h.unmount;
        h.unmount = () => {
          d && d(), c.dispose(), p();
        };
      },
      get global() {
        return a;
      },
      dispose() {
        i.stop();
      },
      __instances: n,
      __getInstance: s,
      __setInstance: l,
      __deleteInstance: u
    };
    return c;
  }
  function Lw(r = {}) {
    const e = yn();
    if (e == null) throw xn(un.MUST_BE_CALL_SETUP_TOP);
    if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw xn(un.NOT_INSTALLED);
    const t = Lwe(e), n = Ewe(t), i = h$(e), a = Rwe(r, i);
    if (a === "global") return f$(n, r, i), n;
    if (a === "parent") {
      let l = Nwe(t, e, r.__useComponent);
      return l == null && (l = n), l;
    }
    const o = t;
    let s = o.__getInstance(e);
    if (s == null) {
      const l = sr({}, r);
      "__i18n" in i && (l.__i18n = i.__i18n), n && (l.__root = n), s = Pw(l), o.__composerExtend && (s[Ib] = o.__composerExtend(s)), Fwe(o, e, s), o.__setInstance(e, s);
    }
    return s;
  }
  function kwe(r, e) {
    const t = Vb(), n = __VUE_I18N_LEGACY_API__ && e ? t.run(() => Mb(r)) : t.run(() => Pw(r));
    if (n == null) throw xn(un.UNEXPECTED_ERROR);
    return [
      t,
      n
    ];
  }
  function Lwe(r) {
    const e = zL(r.isCE ? Dwe : r.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e) throw xn(r.isCE ? un.NOT_INSTALLED_WITH_PROVIDE : un.UNEXPECTED_ERROR);
    return e;
  }
  function Rwe(r, e) {
    return zg(r) ? "__i18n" in e ? "local" : "global" : r.useScope ? r.useScope : "local";
  }
  function Ewe(r) {
    return r.mode === "composition" ? r.global : r.global.__composer;
  }
  function Nwe(r, e, t = false) {
    let n = null;
    const i = e.root;
    let a = Owe(e, t);
    for (; a != null; ) {
      const o = r;
      if (r.mode === "composition") n = o.__getInstance(a);
      else if (__VUE_I18N_LEGACY_API__) {
        const s = o.__getInstance(a);
        s != null && (n = s.__composer, t && n && !n[c$] && (n = null));
      }
      if (n != null || i === a) break;
      a = a.parent;
    }
    return n;
  }
  function Owe(r, e = false) {
    return r == null ? null : e && r.vnode.ctx || r.parent;
  }
  function Fwe(r, e, t) {
    Iu(() => {
    }, e), Gv(() => {
      const n = t;
      r.__deleteInstance(e);
      const i = n[Ib];
      i && (i(), delete n[Ib]);
    }, e);
  }
  const Bwe = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ], dL = [
    "t",
    "rt",
    "d",
    "n",
    "tm",
    "te"
  ];
  function zwe(r, e) {
    const t = /* @__PURE__ */ Object.create(null);
    return Bwe.forEach((i) => {
      const a = Object.getOwnPropertyDescriptor(e, i);
      if (!a) throw xn(un.UNEXPECTED_ERROR);
      const o = BL(a.value) ? {
        get() {
          return a.value.value;
        },
        set(s) {
          a.value.value = s;
        }
      } : {
        get() {
          return a.get && a.get();
        }
      };
      Object.defineProperty(t, i, o);
    }), r.config.globalProperties.$i18n = t, dL.forEach((i) => {
      const a = Object.getOwnPropertyDescriptor(e, i);
      if (!a || !a.value) throw xn(un.UNEXPECTED_ERROR);
      Object.defineProperty(r.config.globalProperties, `$${i}`, a);
    }), () => {
      delete r.config.globalProperties.$i18n, dL.forEach((i) => {
        delete r.config.globalProperties[`$${i}`];
      });
    };
  }
  const Vwe = Ye({
    name: "i18n-d",
    props: sr({
      value: {
        type: [
          Number,
          Date
        ],
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, kw),
    setup(r, e) {
      const t = r.i18n || Lw({
        useScope: r.scope,
        __useComponent: true
      });
      return p$(r, e, a$, (...n) => t[Tb](...n));
    }
  }), pL = Vwe;
  mwe();
  KSe(PSe);
  ZSe(YSe);
  jSe(JV);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const r = Ts();
    r.__INTLIFY__ = true, kSe(r.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const $we = FL("app", {
    state: () => ({
      lang: ""
    }),
    actions: {
      setNowLang(r) {
        this.lang = r;
      }
    }
  }), vL = await Uwe({
    locale: Gwe()
  });
  function Gwe() {
    const r = window.location.href, e = navigator.language, t = Ywe(r).lang ?? e;
    return $we().setNowLang(t), t;
  }
  function Wwe(r) {
    return r.includes("zh");
  }
  async function Uwe(r = {
    locale: "zh-CN"
  }) {
    const e = Pwe({
      legacy: false,
      globalInjection: true,
      fallbackLocale: "zh-CN",
      ...r
    });
    return Hwe(e, r.locale), await gL(e, "zh-CN"), Wwe(r.locale) || await gL(e, r.locale), e;
  }
  function Hwe(r, e = "zh-CN") {
    var _a2;
    r.mode === "legacy" ? r.global.locale = e : typeof r.global.locale != "string" && (r.global.locale.value = e), (_a2 = document.querySelector("html")) == null ? void 0 : _a2.setAttribute("lang", e);
  }
  async function gL(r, e) {
    const t = await R1e(Object.assign({
      "./locales/en.json": () => ou(() => import("./en-6Y5830hC.js"), []),
      "./locales/zh-CN.json": () => ou(() => import("./zh-CN-HZdoqDhl.js"), [])
    }), `./locales/${e}.json`, 3);
    return r.global.setLocaleMessage(e, t.default), wa();
  }
  function Ywe(r) {
    const e = {};
    if (!r || r === "" || typeof r != "string") return e;
    const t = r.split("?")[1];
    return t && t.split("&").forEach((i) => {
      const [a, o] = i.split("=");
      o === void 0 ? e[a] = null : o === "true" ? e[a] = true : o === "false" ? e[a] = false : e[a] = decodeURIComponent(o);
    }), e;
  }
  const Xwe = () => {
    const r = at(() => W(vL.global.locale)), e = at(() => r.value.includes("zh"));
    return {
      t: vL.global.t,
      locale: r,
      isZh: e
    };
  };
  function v$(r) {
    var e, t, n = "";
    if (typeof r == "string" || typeof r == "number") n += r;
    else if (typeof r == "object") if (Array.isArray(r)) {
      var i = r.length;
      for (e = 0; e < i; e++) r[e] && (t = v$(r[e])) && (n && (n += " "), n += t);
    } else for (t in r) r[t] && (n && (n += " "), n += t);
    return n;
  }
  function g$() {
    for (var r, e, t = 0, n = "", i = arguments.length; t < i; t++) (r = arguments[t]) && (e = v$(r)) && (n && (n += " "), n += e);
    return n;
  }
  const mL = (r) => typeof r == "boolean" ? `${r}` : r === 0 ? "0" : r, yL = g$, qwe = (r, e) => (t) => {
    var n;
    if ((e == null ? void 0 : e.variants) == null) return yL(r, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
    const { variants: i, defaultVariants: a } = e, o = Object.keys(i).map((u) => {
      const c = t == null ? void 0 : t[u], h = a == null ? void 0 : a[u];
      if (c === null) return null;
      const f = mL(c) || mL(h);
      return i[u][f];
    }), s = t && Object.entries(t).reduce((u, c) => {
      let [h, f] = c;
      return f === void 0 || (u[h] = f), u;
    }, {}), l = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce((u, c) => {
      let { class: h, className: f, ...d } = c;
      return Object.entries(d).every((p) => {
        let [v, g] = p;
        return Array.isArray(g) ? g.includes({
          ...a,
          ...s
        }[v]) : {
          ...a,
          ...s
        }[v] === g;
      }) ? [
        ...u,
        h,
        f
      ] : u;
    }, []);
    return yL(r, o, l, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
  }, Rw = "-", Kwe = (r) => {
    const e = jwe(r), { conflictingClassGroups: t, conflictingClassGroupModifiers: n } = r;
    return {
      getClassGroupId: (o) => {
        const s = o.split(Rw);
        return s[0] === "" && s.length !== 1 && s.shift(), m$(s, e) || Zwe(o);
      },
      getConflictingClassGroupIds: (o, s) => {
        const l = t[o] || [];
        return s && n[o] ? [
          ...l,
          ...n[o]
        ] : l;
      }
    };
  }, m$ = (r, e) => {
    var _a2;
    if (r.length === 0) return e.classGroupId;
    const t = r[0], n = e.nextPart.get(t), i = n ? m$(r.slice(1), n) : void 0;
    if (i) return i;
    if (e.validators.length === 0) return;
    const a = r.join(Rw);
    return (_a2 = e.validators.find(({ validator: o }) => o(a))) == null ? void 0 : _a2.classGroupId;
  }, xL = /^\[(.+)\]$/, Zwe = (r) => {
    if (xL.test(r)) {
      const e = xL.exec(r)[1], t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
      if (t) return "arbitrary.." + t;
    }
  }, jwe = (r) => {
    const { theme: e, classGroups: t } = r, n = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    for (const i in t) Db(t[i], n, i, e);
    return n;
  }, Db = (r, e, t, n) => {
    r.forEach((i) => {
      if (typeof i == "string") {
        const a = i === "" ? e : _L(e, i);
        a.classGroupId = t;
        return;
      }
      if (typeof i == "function") {
        if (Qwe(i)) {
          Db(i(n), e, t, n);
          return;
        }
        e.validators.push({
          validator: i,
          classGroupId: t
        });
        return;
      }
      Object.entries(i).forEach(([a, o]) => {
        Db(o, _L(e, a), t, n);
      });
    });
  }, _L = (r, e) => {
    let t = r;
    return e.split(Rw).forEach((n) => {
      t.nextPart.has(n) || t.nextPart.set(n, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      }), t = t.nextPart.get(n);
    }), t;
  }, Qwe = (r) => r.isThemeGetter, Jwe = (r) => {
    if (r < 1) return {
      get: () => {
      },
      set: () => {
      }
    };
    let e = 0, t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    const i = (a, o) => {
      t.set(a, o), e++, e > r && (e = 0, n = t, t = /* @__PURE__ */ new Map());
    };
    return {
      get(a) {
        let o = t.get(a);
        if (o !== void 0) return o;
        if ((o = n.get(a)) !== void 0) return i(a, o), o;
      },
      set(a, o) {
        t.has(a) ? t.set(a, o) : i(a, o);
      }
    };
  }, Pb = "!", kb = ":", eCe = kb.length, tCe = (r) => {
    const { prefix: e, experimentalParseClassName: t } = r;
    let n = (i) => {
      const a = [];
      let o = 0, s = 0, l = 0, u;
      for (let p = 0; p < i.length; p++) {
        let v = i[p];
        if (o === 0 && s === 0) {
          if (v === kb) {
            a.push(i.slice(l, p)), l = p + eCe;
            continue;
          }
          if (v === "/") {
            u = p;
            continue;
          }
        }
        v === "[" ? o++ : v === "]" ? o-- : v === "(" ? s++ : v === ")" && s--;
      }
      const c = a.length === 0 ? i : i.substring(l), h = rCe(c), f = h !== c, d = u && u > l ? u - l : void 0;
      return {
        modifiers: a,
        hasImportantModifier: f,
        baseClassName: h,
        maybePostfixModifierPosition: d
      };
    };
    if (e) {
      const i = e + kb, a = n;
      n = (o) => o.startsWith(i) ? a(o.substring(i.length)) : {
        isExternal: true,
        modifiers: [],
        hasImportantModifier: false,
        baseClassName: o,
        maybePostfixModifierPosition: void 0
      };
    }
    if (t) {
      const i = n;
      n = (a) => t({
        className: a,
        parseClassName: i
      });
    }
    return n;
  }, rCe = (r) => r.endsWith(Pb) ? r.substring(0, r.length - 1) : r.startsWith(Pb) ? r.substring(1) : r, nCe = (r) => {
    const e = Object.fromEntries(r.orderSensitiveModifiers.map((n) => [
      n,
      true
    ]));
    return (n) => {
      if (n.length <= 1) return n;
      const i = [];
      let a = [];
      return n.forEach((o) => {
        o[0] === "[" || e[o] ? (i.push(...a.sort(), o), a = []) : a.push(o);
      }), i.push(...a.sort()), i;
    };
  }, iCe = (r) => ({
    cache: Jwe(r.cacheSize),
    parseClassName: tCe(r),
    sortModifiers: nCe(r),
    ...Kwe(r)
  }), aCe = /\s+/, oCe = (r, e) => {
    const { parseClassName: t, getClassGroupId: n, getConflictingClassGroupIds: i, sortModifiers: a } = e, o = [], s = r.trim().split(aCe);
    let l = "";
    for (let u = s.length - 1; u >= 0; u -= 1) {
      const c = s[u], { isExternal: h, modifiers: f, hasImportantModifier: d, baseClassName: p, maybePostfixModifierPosition: v } = t(c);
      if (h) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      let g = !!v, m = n(g ? p.substring(0, v) : p);
      if (!m) {
        if (!g) {
          l = c + (l.length > 0 ? " " + l : l);
          continue;
        }
        if (m = n(p), !m) {
          l = c + (l.length > 0 ? " " + l : l);
          continue;
        }
        g = false;
      }
      const y = a(f).join(":"), x = d ? y + Pb : y, _ = x + m;
      if (o.includes(_)) continue;
      o.push(_);
      const S = i(m, g);
      for (let b = 0; b < S.length; ++b) {
        const w = S[b];
        o.push(x + w);
      }
      l = c + (l.length > 0 ? " " + l : l);
    }
    return l;
  };
  function sCe() {
    let r = 0, e, t, n = "";
    for (; r < arguments.length; ) (e = arguments[r++]) && (t = y$(e)) && (n && (n += " "), n += t);
    return n;
  }
  const y$ = (r) => {
    if (typeof r == "string") return r;
    let e, t = "";
    for (let n = 0; n < r.length; n++) r[n] && (e = y$(r[n])) && (t && (t += " "), t += e);
    return t;
  };
  function lCe(r, ...e) {
    let t, n, i, a = o;
    function o(l) {
      const u = e.reduce((c, h) => h(c), r());
      return t = iCe(u), n = t.cache.get, i = t.cache.set, a = s, s(l);
    }
    function s(l) {
      const u = n(l);
      if (u) return u;
      const c = oCe(l, t);
      return i(l, c), c;
    }
    return function() {
      return a(sCe.apply(null, arguments));
    };
  }
  const fr = (r) => {
    const e = (t) => t[r] || [];
    return e.isThemeGetter = true, e;
  }, x$ = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, _$ = /^\((?:(\w[\w-]*):)?(.+)\)$/i, uCe = /^\d+\/\d+$/, cCe = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, hCe = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, fCe = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, dCe = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, pCe = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, El = (r) => uCe.test(r), lt = (r) => !!r && !Number.isNaN(Number(r)), jo = (r) => !!r && Number.isInteger(Number(r)), bL = (r) => r.endsWith("%") && lt(r.slice(0, -1)), Ba = (r) => cCe.test(r), vCe = () => true, gCe = (r) => hCe.test(r) && !fCe.test(r), Ew = () => false, mCe = (r) => dCe.test(r), yCe = (r) => pCe.test(r), xCe = (r) => !Ae(r) && !Ie(r), _Ce = (r) => Yu(r, w$, Ew), Ae = (r) => x$.test(r), Qo = (r) => Yu(r, C$, gCe), q0 = (r) => Yu(r, kCe, lt), bCe = (r) => Yu(r, b$, Ew), SCe = (r) => Yu(r, S$, yCe), wCe = (r) => Yu(r, Ew, mCe), Ie = (r) => _$.test(r), np = (r) => Xu(r, C$), CCe = (r) => Xu(r, LCe), TCe = (r) => Xu(r, b$), ACe = (r) => Xu(r, w$), ICe = (r) => Xu(r, S$), MCe = (r) => Xu(r, RCe, true), Yu = (r, e, t) => {
    const n = x$.exec(r);
    return n ? n[1] ? e(n[1]) : t(n[2]) : false;
  }, Xu = (r, e, t = false) => {
    const n = _$.exec(r);
    return n ? n[1] ? e(n[1]) : t : false;
  }, b$ = (r) => r === "position", DCe = /* @__PURE__ */ new Set([
    "image",
    "url"
  ]), S$ = (r) => DCe.has(r), PCe = /* @__PURE__ */ new Set([
    "length",
    "size",
    "percentage"
  ]), w$ = (r) => PCe.has(r), C$ = (r) => r === "length", kCe = (r) => r === "number", LCe = (r) => r === "family-name", RCe = (r) => r === "shadow", ECe = () => {
    const r = fr("color"), e = fr("font"), t = fr("text"), n = fr("font-weight"), i = fr("tracking"), a = fr("leading"), o = fr("breakpoint"), s = fr("container"), l = fr("spacing"), u = fr("radius"), c = fr("shadow"), h = fr("inset-shadow"), f = fr("drop-shadow"), d = fr("blur"), p = fr("perspective"), v = fr("aspect"), g = fr("ease"), m = fr("animate"), y = () => [
      "auto",
      "avoid",
      "all",
      "avoid-page",
      "page",
      "left",
      "right",
      "column"
    ], x = () => [
      "bottom",
      "center",
      "left",
      "left-bottom",
      "left-top",
      "right",
      "right-bottom",
      "right-top",
      "top"
    ], _ = () => [
      "auto",
      "hidden",
      "clip",
      "visible",
      "scroll"
    ], S = () => [
      "auto",
      "contain",
      "none"
    ], b = () => [
      Ie,
      Ae,
      l
    ], w = () => [
      El,
      "full",
      "auto",
      ...b()
    ], C = () => [
      jo,
      "none",
      "subgrid",
      Ie,
      Ae
    ], T = () => [
      "auto",
      {
        span: [
          "full",
          jo,
          Ie,
          Ae
        ]
      },
      Ie,
      Ae
    ], A = () => [
      jo,
      "auto",
      Ie,
      Ae
    ], M = () => [
      "auto",
      "min",
      "max",
      "fr",
      Ie,
      Ae
    ], E = () => [
      "start",
      "end",
      "center",
      "between",
      "around",
      "evenly",
      "stretch",
      "baseline"
    ], k = () => [
      "start",
      "end",
      "center",
      "stretch"
    ], R = () => [
      "auto",
      ...b()
    ], N = () => [
      El,
      "auto",
      "full",
      "dvw",
      "dvh",
      "lvw",
      "lvh",
      "svw",
      "svh",
      "min",
      "max",
      "fit",
      ...b()
    ], I = () => [
      r,
      Ie,
      Ae
    ], L = () => [
      bL,
      Qo
    ], P = () => [
      "",
      "none",
      "full",
      u,
      Ie,
      Ae
    ], O = () => [
      "",
      lt,
      np,
      Qo
    ], F = () => [
      "solid",
      "dashed",
      "dotted",
      "double"
    ], B = () => [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ], V = () => [
      "",
      "none",
      d,
      Ie,
      Ae
    ], U = () => [
      "center",
      "top",
      "top-right",
      "right",
      "bottom-right",
      "bottom",
      "bottom-left",
      "left",
      "top-left",
      Ie,
      Ae
    ], Y = () => [
      "none",
      lt,
      Ie,
      Ae
    ], q = () => [
      "none",
      lt,
      Ie,
      Ae
    ], me = () => [
      lt,
      Ie,
      Ae
    ], Me = () => [
      El,
      "full",
      ...b()
    ];
    return {
      cacheSize: 500,
      theme: {
        animate: [
          "spin",
          "ping",
          "pulse",
          "bounce"
        ],
        aspect: [
          "video"
        ],
        blur: [
          Ba
        ],
        breakpoint: [
          Ba
        ],
        color: [
          vCe
        ],
        container: [
          Ba
        ],
        "drop-shadow": [
          Ba
        ],
        ease: [
          "in",
          "out",
          "in-out"
        ],
        font: [
          xCe
        ],
        "font-weight": [
          "thin",
          "extralight",
          "light",
          "normal",
          "medium",
          "semibold",
          "bold",
          "extrabold",
          "black"
        ],
        "inset-shadow": [
          Ba
        ],
        leading: [
          "none",
          "tight",
          "snug",
          "normal",
          "relaxed",
          "loose"
        ],
        perspective: [
          "dramatic",
          "near",
          "normal",
          "midrange",
          "distant",
          "none"
        ],
        radius: [
          Ba
        ],
        shadow: [
          Ba
        ],
        spacing: [
          "px",
          lt
        ],
        text: [
          Ba
        ],
        tracking: [
          "tighter",
          "tight",
          "normal",
          "wide",
          "wider",
          "widest"
        ]
      },
      classGroups: {
        aspect: [
          {
            aspect: [
              "auto",
              "square",
              El,
              Ae,
              Ie,
              v
            ]
          }
        ],
        container: [
          "container"
        ],
        columns: [
          {
            columns: [
              lt,
              Ae,
              Ie,
              s
            ]
          }
        ],
        "break-after": [
          {
            "break-after": y()
          }
        ],
        "break-before": [
          {
            "break-before": y()
          }
        ],
        "break-inside": [
          {
            "break-inside": [
              "auto",
              "avoid",
              "avoid-page",
              "avoid-column"
            ]
          }
        ],
        "box-decoration": [
          {
            "box-decoration": [
              "slice",
              "clone"
            ]
          }
        ],
        box: [
          {
            box: [
              "border",
              "content"
            ]
          }
        ],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden"
        ],
        sr: [
          "sr-only",
          "not-sr-only"
        ],
        float: [
          {
            float: [
              "right",
              "left",
              "none",
              "start",
              "end"
            ]
          }
        ],
        clear: [
          {
            clear: [
              "left",
              "right",
              "both",
              "none",
              "start",
              "end"
            ]
          }
        ],
        isolation: [
          "isolate",
          "isolation-auto"
        ],
        "object-fit": [
          {
            object: [
              "contain",
              "cover",
              "fill",
              "none",
              "scale-down"
            ]
          }
        ],
        "object-position": [
          {
            object: [
              ...x(),
              Ae,
              Ie
            ]
          }
        ],
        overflow: [
          {
            overflow: _()
          }
        ],
        "overflow-x": [
          {
            "overflow-x": _()
          }
        ],
        "overflow-y": [
          {
            "overflow-y": _()
          }
        ],
        overscroll: [
          {
            overscroll: S()
          }
        ],
        "overscroll-x": [
          {
            "overscroll-x": S()
          }
        ],
        "overscroll-y": [
          {
            "overscroll-y": S()
          }
        ],
        position: [
          "static",
          "fixed",
          "absolute",
          "relative",
          "sticky"
        ],
        inset: [
          {
            inset: w()
          }
        ],
        "inset-x": [
          {
            "inset-x": w()
          }
        ],
        "inset-y": [
          {
            "inset-y": w()
          }
        ],
        start: [
          {
            start: w()
          }
        ],
        end: [
          {
            end: w()
          }
        ],
        top: [
          {
            top: w()
          }
        ],
        right: [
          {
            right: w()
          }
        ],
        bottom: [
          {
            bottom: w()
          }
        ],
        left: [
          {
            left: w()
          }
        ],
        visibility: [
          "visible",
          "invisible",
          "collapse"
        ],
        z: [
          {
            z: [
              jo,
              "auto",
              Ie,
              Ae
            ]
          }
        ],
        basis: [
          {
            basis: [
              El,
              "full",
              "auto",
              s,
              ...b()
            ]
          }
        ],
        "flex-direction": [
          {
            flex: [
              "row",
              "row-reverse",
              "col",
              "col-reverse"
            ]
          }
        ],
        "flex-wrap": [
          {
            flex: [
              "nowrap",
              "wrap",
              "wrap-reverse"
            ]
          }
        ],
        flex: [
          {
            flex: [
              lt,
              El,
              "auto",
              "initial",
              "none",
              Ae
            ]
          }
        ],
        grow: [
          {
            grow: [
              "",
              lt,
              Ie,
              Ae
            ]
          }
        ],
        shrink: [
          {
            shrink: [
              "",
              lt,
              Ie,
              Ae
            ]
          }
        ],
        order: [
          {
            order: [
              jo,
              "first",
              "last",
              "none",
              Ie,
              Ae
            ]
          }
        ],
        "grid-cols": [
          {
            "grid-cols": C()
          }
        ],
        "col-start-end": [
          {
            col: T()
          }
        ],
        "col-start": [
          {
            "col-start": A()
          }
        ],
        "col-end": [
          {
            "col-end": A()
          }
        ],
        "grid-rows": [
          {
            "grid-rows": C()
          }
        ],
        "row-start-end": [
          {
            row: T()
          }
        ],
        "row-start": [
          {
            "row-start": A()
          }
        ],
        "row-end": [
          {
            "row-end": A()
          }
        ],
        "grid-flow": [
          {
            "grid-flow": [
              "row",
              "col",
              "dense",
              "row-dense",
              "col-dense"
            ]
          }
        ],
        "auto-cols": [
          {
            "auto-cols": M()
          }
        ],
        "auto-rows": [
          {
            "auto-rows": M()
          }
        ],
        gap: [
          {
            gap: b()
          }
        ],
        "gap-x": [
          {
            "gap-x": b()
          }
        ],
        "gap-y": [
          {
            "gap-y": b()
          }
        ],
        "justify-content": [
          {
            justify: [
              ...E(),
              "normal"
            ]
          }
        ],
        "justify-items": [
          {
            "justify-items": [
              ...k(),
              "normal"
            ]
          }
        ],
        "justify-self": [
          {
            "justify-self": [
              "auto",
              ...k()
            ]
          }
        ],
        "align-content": [
          {
            content: [
              "normal",
              ...E()
            ]
          }
        ],
        "align-items": [
          {
            items: [
              ...k(),
              "baseline"
            ]
          }
        ],
        "align-self": [
          {
            self: [
              "auto",
              ...k(),
              "baseline"
            ]
          }
        ],
        "place-content": [
          {
            "place-content": E()
          }
        ],
        "place-items": [
          {
            "place-items": [
              ...k(),
              "baseline"
            ]
          }
        ],
        "place-self": [
          {
            "place-self": [
              "auto",
              ...k()
            ]
          }
        ],
        p: [
          {
            p: b()
          }
        ],
        px: [
          {
            px: b()
          }
        ],
        py: [
          {
            py: b()
          }
        ],
        ps: [
          {
            ps: b()
          }
        ],
        pe: [
          {
            pe: b()
          }
        ],
        pt: [
          {
            pt: b()
          }
        ],
        pr: [
          {
            pr: b()
          }
        ],
        pb: [
          {
            pb: b()
          }
        ],
        pl: [
          {
            pl: b()
          }
        ],
        m: [
          {
            m: R()
          }
        ],
        mx: [
          {
            mx: R()
          }
        ],
        my: [
          {
            my: R()
          }
        ],
        ms: [
          {
            ms: R()
          }
        ],
        me: [
          {
            me: R()
          }
        ],
        mt: [
          {
            mt: R()
          }
        ],
        mr: [
          {
            mr: R()
          }
        ],
        mb: [
          {
            mb: R()
          }
        ],
        ml: [
          {
            ml: R()
          }
        ],
        "space-x": [
          {
            "space-x": b()
          }
        ],
        "space-x-reverse": [
          "space-x-reverse"
        ],
        "space-y": [
          {
            "space-y": b()
          }
        ],
        "space-y-reverse": [
          "space-y-reverse"
        ],
        size: [
          {
            size: N()
          }
        ],
        w: [
          {
            w: [
              s,
              "screen",
              ...N()
            ]
          }
        ],
        "min-w": [
          {
            "min-w": [
              s,
              "screen",
              "none",
              ...N()
            ]
          }
        ],
        "max-w": [
          {
            "max-w": [
              s,
              "screen",
              "none",
              "prose",
              {
                screen: [
                  o
                ]
              },
              ...N()
            ]
          }
        ],
        h: [
          {
            h: [
              "screen",
              ...N()
            ]
          }
        ],
        "min-h": [
          {
            "min-h": [
              "screen",
              "none",
              ...N()
            ]
          }
        ],
        "max-h": [
          {
            "max-h": [
              "screen",
              ...N()
            ]
          }
        ],
        "font-size": [
          {
            text: [
              "base",
              t,
              np,
              Qo
            ]
          }
        ],
        "font-smoothing": [
          "antialiased",
          "subpixel-antialiased"
        ],
        "font-style": [
          "italic",
          "not-italic"
        ],
        "font-weight": [
          {
            font: [
              n,
              Ie,
              q0
            ]
          }
        ],
        "font-stretch": [
          {
            "font-stretch": [
              "ultra-condensed",
              "extra-condensed",
              "condensed",
              "semi-condensed",
              "normal",
              "semi-expanded",
              "expanded",
              "extra-expanded",
              "ultra-expanded",
              bL,
              Ae
            ]
          }
        ],
        "font-family": [
          {
            font: [
              CCe,
              Ae,
              e
            ]
          }
        ],
        "fvn-normal": [
          "normal-nums"
        ],
        "fvn-ordinal": [
          "ordinal"
        ],
        "fvn-slashed-zero": [
          "slashed-zero"
        ],
        "fvn-figure": [
          "lining-nums",
          "oldstyle-nums"
        ],
        "fvn-spacing": [
          "proportional-nums",
          "tabular-nums"
        ],
        "fvn-fraction": [
          "diagonal-fractions",
          "stacked-fractions"
        ],
        tracking: [
          {
            tracking: [
              i,
              Ie,
              Ae
            ]
          }
        ],
        "line-clamp": [
          {
            "line-clamp": [
              lt,
              "none",
              Ie,
              q0
            ]
          }
        ],
        leading: [
          {
            leading: [
              a,
              ...b()
            ]
          }
        ],
        "list-image": [
          {
            "list-image": [
              "none",
              Ie,
              Ae
            ]
          }
        ],
        "list-style-position": [
          {
            list: [
              "inside",
              "outside"
            ]
          }
        ],
        "list-style-type": [
          {
            list: [
              "disc",
              "decimal",
              "none",
              Ie,
              Ae
            ]
          }
        ],
        "text-alignment": [
          {
            text: [
              "left",
              "center",
              "right",
              "justify",
              "start",
              "end"
            ]
          }
        ],
        "placeholder-color": [
          {
            placeholder: I()
          }
        ],
        "text-color": [
          {
            text: I()
          }
        ],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline"
        ],
        "text-decoration-style": [
          {
            decoration: [
              ...F(),
              "wavy"
            ]
          }
        ],
        "text-decoration-thickness": [
          {
            decoration: [
              lt,
              "from-font",
              "auto",
              Ie,
              Qo
            ]
          }
        ],
        "text-decoration-color": [
          {
            decoration: I()
          }
        ],
        "underline-offset": [
          {
            "underline-offset": [
              lt,
              "auto",
              Ie,
              Ae
            ]
          }
        ],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case"
        ],
        "text-overflow": [
          "truncate",
          "text-ellipsis",
          "text-clip"
        ],
        "text-wrap": [
          {
            text: [
              "wrap",
              "nowrap",
              "balance",
              "pretty"
            ]
          }
        ],
        indent: [
          {
            indent: b()
          }
        ],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              Ie,
              Ae
            ]
          }
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces"
            ]
          }
        ],
        break: [
          {
            break: [
              "normal",
              "words",
              "all",
              "keep"
            ]
          }
        ],
        hyphens: [
          {
            hyphens: [
              "none",
              "manual",
              "auto"
            ]
          }
        ],
        content: [
          {
            content: [
              "none",
              Ie,
              Ae
            ]
          }
        ],
        "bg-attachment": [
          {
            bg: [
              "fixed",
              "local",
              "scroll"
            ]
          }
        ],
        "bg-clip": [
          {
            "bg-clip": [
              "border",
              "padding",
              "content",
              "text"
            ]
          }
        ],
        "bg-origin": [
          {
            "bg-origin": [
              "border",
              "padding",
              "content"
            ]
          }
        ],
        "bg-position": [
          {
            bg: [
              ...x(),
              TCe,
              bCe
            ]
          }
        ],
        "bg-repeat": [
          {
            bg: [
              "no-repeat",
              {
                repeat: [
                  "",
                  "x",
                  "y",
                  "space",
                  "round"
                ]
              }
            ]
          }
        ],
        "bg-size": [
          {
            bg: [
              "auto",
              "cover",
              "contain",
              ACe,
              _Ce
            ]
          }
        ],
        "bg-image": [
          {
            bg: [
              "none",
              {
                linear: [
                  {
                    to: [
                      "t",
                      "tr",
                      "r",
                      "br",
                      "b",
                      "bl",
                      "l",
                      "tl"
                    ]
                  },
                  jo,
                  Ie,
                  Ae
                ],
                radial: [
                  "",
                  Ie,
                  Ae
                ],
                conic: [
                  jo,
                  Ie,
                  Ae
                ]
              },
              ICe,
              SCe
            ]
          }
        ],
        "bg-color": [
          {
            bg: I()
          }
        ],
        "gradient-from-pos": [
          {
            from: L()
          }
        ],
        "gradient-via-pos": [
          {
            via: L()
          }
        ],
        "gradient-to-pos": [
          {
            to: L()
          }
        ],
        "gradient-from": [
          {
            from: I()
          }
        ],
        "gradient-via": [
          {
            via: I()
          }
        ],
        "gradient-to": [
          {
            to: I()
          }
        ],
        rounded: [
          {
            rounded: P()
          }
        ],
        "rounded-s": [
          {
            "rounded-s": P()
          }
        ],
        "rounded-e": [
          {
            "rounded-e": P()
          }
        ],
        "rounded-t": [
          {
            "rounded-t": P()
          }
        ],
        "rounded-r": [
          {
            "rounded-r": P()
          }
        ],
        "rounded-b": [
          {
            "rounded-b": P()
          }
        ],
        "rounded-l": [
          {
            "rounded-l": P()
          }
        ],
        "rounded-ss": [
          {
            "rounded-ss": P()
          }
        ],
        "rounded-se": [
          {
            "rounded-se": P()
          }
        ],
        "rounded-ee": [
          {
            "rounded-ee": P()
          }
        ],
        "rounded-es": [
          {
            "rounded-es": P()
          }
        ],
        "rounded-tl": [
          {
            "rounded-tl": P()
          }
        ],
        "rounded-tr": [
          {
            "rounded-tr": P()
          }
        ],
        "rounded-br": [
          {
            "rounded-br": P()
          }
        ],
        "rounded-bl": [
          {
            "rounded-bl": P()
          }
        ],
        "border-w": [
          {
            border: O()
          }
        ],
        "border-w-x": [
          {
            "border-x": O()
          }
        ],
        "border-w-y": [
          {
            "border-y": O()
          }
        ],
        "border-w-s": [
          {
            "border-s": O()
          }
        ],
        "border-w-e": [
          {
            "border-e": O()
          }
        ],
        "border-w-t": [
          {
            "border-t": O()
          }
        ],
        "border-w-r": [
          {
            "border-r": O()
          }
        ],
        "border-w-b": [
          {
            "border-b": O()
          }
        ],
        "border-w-l": [
          {
            "border-l": O()
          }
        ],
        "divide-x": [
          {
            "divide-x": O()
          }
        ],
        "divide-x-reverse": [
          "divide-x-reverse"
        ],
        "divide-y": [
          {
            "divide-y": O()
          }
        ],
        "divide-y-reverse": [
          "divide-y-reverse"
        ],
        "border-style": [
          {
            border: [
              ...F(),
              "hidden",
              "none"
            ]
          }
        ],
        "divide-style": [
          {
            divide: [
              ...F(),
              "hidden",
              "none"
            ]
          }
        ],
        "border-color": [
          {
            border: I()
          }
        ],
        "border-color-x": [
          {
            "border-x": I()
          }
        ],
        "border-color-y": [
          {
            "border-y": I()
          }
        ],
        "border-color-s": [
          {
            "border-s": I()
          }
        ],
        "border-color-e": [
          {
            "border-e": I()
          }
        ],
        "border-color-t": [
          {
            "border-t": I()
          }
        ],
        "border-color-r": [
          {
            "border-r": I()
          }
        ],
        "border-color-b": [
          {
            "border-b": I()
          }
        ],
        "border-color-l": [
          {
            "border-l": I()
          }
        ],
        "divide-color": [
          {
            divide: I()
          }
        ],
        "outline-style": [
          {
            outline: [
              ...F(),
              "none",
              "hidden"
            ]
          }
        ],
        "outline-offset": [
          {
            "outline-offset": [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "outline-w": [
          {
            outline: [
              "",
              lt,
              np,
              Qo
            ]
          }
        ],
        "outline-color": [
          {
            outline: [
              r
            ]
          }
        ],
        shadow: [
          {
            shadow: [
              "",
              "none",
              c,
              MCe,
              wCe
            ]
          }
        ],
        "shadow-color": [
          {
            shadow: I()
          }
        ],
        "inset-shadow": [
          {
            "inset-shadow": [
              "none",
              Ie,
              Ae,
              h
            ]
          }
        ],
        "inset-shadow-color": [
          {
            "inset-shadow": I()
          }
        ],
        "ring-w": [
          {
            ring: O()
          }
        ],
        "ring-w-inset": [
          "ring-inset"
        ],
        "ring-color": [
          {
            ring: I()
          }
        ],
        "ring-offset-w": [
          {
            "ring-offset": [
              lt,
              Qo
            ]
          }
        ],
        "ring-offset-color": [
          {
            "ring-offset": I()
          }
        ],
        "inset-ring-w": [
          {
            "inset-ring": O()
          }
        ],
        "inset-ring-color": [
          {
            "inset-ring": I()
          }
        ],
        opacity: [
          {
            opacity: [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "mix-blend": [
          {
            "mix-blend": [
              ...B(),
              "plus-darker",
              "plus-lighter"
            ]
          }
        ],
        "bg-blend": [
          {
            "bg-blend": B()
          }
        ],
        filter: [
          {
            filter: [
              "",
              "none",
              Ie,
              Ae
            ]
          }
        ],
        blur: [
          {
            blur: V()
          }
        ],
        brightness: [
          {
            brightness: [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        contrast: [
          {
            contrast: [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "drop-shadow": [
          {
            "drop-shadow": [
              "",
              "none",
              f,
              Ie,
              Ae
            ]
          }
        ],
        grayscale: [
          {
            grayscale: [
              "",
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "hue-rotate": [
          {
            "hue-rotate": [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        invert: [
          {
            invert: [
              "",
              lt,
              Ie,
              Ae
            ]
          }
        ],
        saturate: [
          {
            saturate: [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        sepia: [
          {
            sepia: [
              "",
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-filter": [
          {
            "backdrop-filter": [
              "",
              "none",
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-blur": [
          {
            "backdrop-blur": V()
          }
        ],
        "backdrop-brightness": [
          {
            "backdrop-brightness": [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-contrast": [
          {
            "backdrop-contrast": [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-grayscale": [
          {
            "backdrop-grayscale": [
              "",
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-hue-rotate": [
          {
            "backdrop-hue-rotate": [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-invert": [
          {
            "backdrop-invert": [
              "",
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-opacity": [
          {
            "backdrop-opacity": [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-saturate": [
          {
            "backdrop-saturate": [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "backdrop-sepia": [
          {
            "backdrop-sepia": [
              "",
              lt,
              Ie,
              Ae
            ]
          }
        ],
        "border-collapse": [
          {
            border: [
              "collapse",
              "separate"
            ]
          }
        ],
        "border-spacing": [
          {
            "border-spacing": b()
          }
        ],
        "border-spacing-x": [
          {
            "border-spacing-x": b()
          }
        ],
        "border-spacing-y": [
          {
            "border-spacing-y": b()
          }
        ],
        "table-layout": [
          {
            table: [
              "auto",
              "fixed"
            ]
          }
        ],
        caption: [
          {
            caption: [
              "top",
              "bottom"
            ]
          }
        ],
        transition: [
          {
            transition: [
              "",
              "all",
              "colors",
              "opacity",
              "shadow",
              "transform",
              "none",
              Ie,
              Ae
            ]
          }
        ],
        "transition-behavior": [
          {
            transition: [
              "normal",
              "discrete"
            ]
          }
        ],
        duration: [
          {
            duration: [
              lt,
              "initial",
              Ie,
              Ae
            ]
          }
        ],
        ease: [
          {
            ease: [
              "linear",
              "initial",
              g,
              Ie,
              Ae
            ]
          }
        ],
        delay: [
          {
            delay: [
              lt,
              Ie,
              Ae
            ]
          }
        ],
        animate: [
          {
            animate: [
              "none",
              m,
              Ie,
              Ae
            ]
          }
        ],
        backface: [
          {
            backface: [
              "hidden",
              "visible"
            ]
          }
        ],
        perspective: [
          {
            perspective: [
              p,
              Ie,
              Ae
            ]
          }
        ],
        "perspective-origin": [
          {
            "perspective-origin": U()
          }
        ],
        rotate: [
          {
            rotate: Y()
          }
        ],
        "rotate-x": [
          {
            "rotate-x": Y()
          }
        ],
        "rotate-y": [
          {
            "rotate-y": Y()
          }
        ],
        "rotate-z": [
          {
            "rotate-z": Y()
          }
        ],
        scale: [
          {
            scale: q()
          }
        ],
        "scale-x": [
          {
            "scale-x": q()
          }
        ],
        "scale-y": [
          {
            "scale-y": q()
          }
        ],
        "scale-z": [
          {
            "scale-z": q()
          }
        ],
        "scale-3d": [
          "scale-3d"
        ],
        skew: [
          {
            skew: me()
          }
        ],
        "skew-x": [
          {
            "skew-x": me()
          }
        ],
        "skew-y": [
          {
            "skew-y": me()
          }
        ],
        transform: [
          {
            transform: [
              Ie,
              Ae,
              "",
              "none",
              "gpu",
              "cpu"
            ]
          }
        ],
        "transform-origin": [
          {
            origin: U()
          }
        ],
        "transform-style": [
          {
            transform: [
              "3d",
              "flat"
            ]
          }
        ],
        translate: [
          {
            translate: Me()
          }
        ],
        "translate-x": [
          {
            "translate-x": Me()
          }
        ],
        "translate-y": [
          {
            "translate-y": Me()
          }
        ],
        "translate-z": [
          {
            "translate-z": Me()
          }
        ],
        "translate-none": [
          "translate-none"
        ],
        accent: [
          {
            accent: I()
          }
        ],
        appearance: [
          {
            appearance: [
              "none",
              "auto"
            ]
          }
        ],
        "caret-color": [
          {
            caret: I()
          }
        ],
        "color-scheme": [
          {
            scheme: [
              "normal",
              "dark",
              "light",
              "light-dark",
              "only-dark",
              "only-light"
            ]
          }
        ],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              Ie,
              Ae
            ]
          }
        ],
        "field-sizing": [
          {
            "field-sizing": [
              "fixed",
              "content"
            ]
          }
        ],
        "pointer-events": [
          {
            "pointer-events": [
              "auto",
              "none"
            ]
          }
        ],
        resize: [
          {
            resize: [
              "none",
              "",
              "y",
              "x"
            ]
          }
        ],
        "scroll-behavior": [
          {
            scroll: [
              "auto",
              "smooth"
            ]
          }
        ],
        "scroll-m": [
          {
            "scroll-m": b()
          }
        ],
        "scroll-mx": [
          {
            "scroll-mx": b()
          }
        ],
        "scroll-my": [
          {
            "scroll-my": b()
          }
        ],
        "scroll-ms": [
          {
            "scroll-ms": b()
          }
        ],
        "scroll-me": [
          {
            "scroll-me": b()
          }
        ],
        "scroll-mt": [
          {
            "scroll-mt": b()
          }
        ],
        "scroll-mr": [
          {
            "scroll-mr": b()
          }
        ],
        "scroll-mb": [
          {
            "scroll-mb": b()
          }
        ],
        "scroll-ml": [
          {
            "scroll-ml": b()
          }
        ],
        "scroll-p": [
          {
            "scroll-p": b()
          }
        ],
        "scroll-px": [
          {
            "scroll-px": b()
          }
        ],
        "scroll-py": [
          {
            "scroll-py": b()
          }
        ],
        "scroll-ps": [
          {
            "scroll-ps": b()
          }
        ],
        "scroll-pe": [
          {
            "scroll-pe": b()
          }
        ],
        "scroll-pt": [
          {
            "scroll-pt": b()
          }
        ],
        "scroll-pr": [
          {
            "scroll-pr": b()
          }
        ],
        "scroll-pb": [
          {
            "scroll-pb": b()
          }
        ],
        "scroll-pl": [
          {
            "scroll-pl": b()
          }
        ],
        "snap-align": [
          {
            snap: [
              "start",
              "end",
              "center",
              "align-none"
            ]
          }
        ],
        "snap-stop": [
          {
            snap: [
              "normal",
              "always"
            ]
          }
        ],
        "snap-type": [
          {
            snap: [
              "none",
              "x",
              "y",
              "both"
            ]
          }
        ],
        "snap-strictness": [
          {
            snap: [
              "mandatory",
              "proximity"
            ]
          }
        ],
        touch: [
          {
            touch: [
              "auto",
              "none",
              "manipulation"
            ]
          }
        ],
        "touch-x": [
          {
            "touch-pan": [
              "x",
              "left",
              "right"
            ]
          }
        ],
        "touch-y": [
          {
            "touch-pan": [
              "y",
              "up",
              "down"
            ]
          }
        ],
        "touch-pz": [
          "touch-pinch-zoom"
        ],
        select: [
          {
            select: [
              "none",
              "text",
              "all",
              "auto"
            ]
          }
        ],
        "will-change": [
          {
            "will-change": [
              "auto",
              "scroll",
              "contents",
              "transform",
              Ie,
              Ae
            ]
          }
        ],
        fill: [
          {
            fill: [
              "none",
              ...I()
            ]
          }
        ],
        "stroke-w": [
          {
            stroke: [
              lt,
              np,
              Qo,
              q0
            ]
          }
        ],
        stroke: [
          {
            stroke: [
              "none",
              ...I()
            ]
          }
        ],
        "forced-color-adjust": [
          {
            "forced-color-adjust": [
              "auto",
              "none"
            ]
          }
        ]
      },
      conflictingClassGroups: {
        overflow: [
          "overflow-x",
          "overflow-y"
        ],
        overscroll: [
          "overscroll-x",
          "overscroll-y"
        ],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left"
        ],
        "inset-x": [
          "right",
          "left"
        ],
        "inset-y": [
          "top",
          "bottom"
        ],
        flex: [
          "basis",
          "grow",
          "shrink"
        ],
        gap: [
          "gap-x",
          "gap-y"
        ],
        p: [
          "px",
          "py",
          "ps",
          "pe",
          "pt",
          "pr",
          "pb",
          "pl"
        ],
        px: [
          "pr",
          "pl"
        ],
        py: [
          "pt",
          "pb"
        ],
        m: [
          "mx",
          "my",
          "ms",
          "me",
          "mt",
          "mr",
          "mb",
          "ml"
        ],
        mx: [
          "mr",
          "ml"
        ],
        my: [
          "mt",
          "mb"
        ],
        size: [
          "w",
          "h"
        ],
        "font-size": [
          "leading"
        ],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction"
        ],
        "fvn-ordinal": [
          "fvn-normal"
        ],
        "fvn-slashed-zero": [
          "fvn-normal"
        ],
        "fvn-figure": [
          "fvn-normal"
        ],
        "fvn-spacing": [
          "fvn-normal"
        ],
        "fvn-fraction": [
          "fvn-normal"
        ],
        "line-clamp": [
          "display",
          "overflow"
        ],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-s": [
          "rounded-ss",
          "rounded-es"
        ],
        "rounded-e": [
          "rounded-se",
          "rounded-ee"
        ],
        "rounded-t": [
          "rounded-tl",
          "rounded-tr"
        ],
        "rounded-r": [
          "rounded-tr",
          "rounded-br"
        ],
        "rounded-b": [
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-l": [
          "rounded-tl",
          "rounded-bl"
        ],
        "border-spacing": [
          "border-spacing-x",
          "border-spacing-y"
        ],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l"
        ],
        "border-w-x": [
          "border-w-r",
          "border-w-l"
        ],
        "border-w-y": [
          "border-w-t",
          "border-w-b"
        ],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l"
        ],
        "border-color-x": [
          "border-color-r",
          "border-color-l"
        ],
        "border-color-y": [
          "border-color-t",
          "border-color-b"
        ],
        translate: [
          "translate-x",
          "translate-y",
          "translate-none"
        ],
        "translate-none": [
          "translate",
          "translate-x",
          "translate-y",
          "translate-z"
        ],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml"
        ],
        "scroll-mx": [
          "scroll-mr",
          "scroll-ml"
        ],
        "scroll-my": [
          "scroll-mt",
          "scroll-mb"
        ],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl"
        ],
        "scroll-px": [
          "scroll-pr",
          "scroll-pl"
        ],
        "scroll-py": [
          "scroll-pt",
          "scroll-pb"
        ],
        touch: [
          "touch-x",
          "touch-y",
          "touch-pz"
        ],
        "touch-x": [
          "touch"
        ],
        "touch-y": [
          "touch"
        ],
        "touch-pz": [
          "touch"
        ]
      },
      conflictingClassGroupModifiers: {
        "font-size": [
          "leading"
        ]
      },
      orderSensitiveModifiers: [
        "before",
        "after",
        "placeholder",
        "file",
        "marker",
        "selection",
        "first-line",
        "first-letter",
        "backdrop",
        "*",
        "**"
      ]
    };
  }, NCe = lCe(ECe);
  function wr(...r) {
    return NCe(g$(r));
  }
  function Of(r, e) {
    const t = typeof r == "string" && !e ? `${r}Context` : e, n = Symbol(t);
    return [
      (i) => {
        const a = zL(n, i);
        if (a || a === null) return a;
        throw new Error(`Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(r) ? `one of the following components: ${r.join(", ")}` : `\`${r}\``}`);
      },
      (i) => (W4(n, i), i)
    ];
  }
  function T$(r, e, t) {
    const n = t.originalEvent.target, i = new CustomEvent(r, {
      bubbles: false,
      cancelable: true,
      detail: t
    });
    e && n.addEventListener(r, e, {
      once: true
    }), n.dispatchEvent(i);
  }
  function A$(r) {
    return V4() ? ($4(r), true) : false;
  }
  function OCe(r) {
    let e = false, t;
    const n = Vb(true);
    return (...i) => (e || (t = n.run(() => r(...i)), e = true), t);
  }
  function FCe(r) {
    let e = 0, t, n;
    const i = () => {
      e -= 1, n && e <= 0 && (n.stop(), t = void 0, n = void 0);
    };
    return (...a) => (e += 1, t || (n = Vb(true), t = n.run(() => r(...a))), A$(i), t);
  }
  function Nw(r) {
    return typeof r == "function" ? r() : W(r);
  }
  const ol = typeof window < "u" && typeof document < "u";
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const BCe = (r) => typeof r < "u", zCe = Object.prototype.toString, VCe = (r) => zCe.call(r) === "[object Object]", $Ce = () => {
  }, SL = GCe();
  function GCe() {
    var r, e;
    return ol && ((r = window == null ? void 0 : window.navigator) == null ? void 0 : r.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
  }
  function WCe(r) {
    return yn();
  }
  function UCe(r, e) {
    WCe() && z4(r, e);
  }
  function Ff(r) {
    var e;
    const t = Nw(r);
    return (e = t == null ? void 0 : t.$el) != null ? e : t;
  }
  const Ow = ol ? window : void 0;
  function I$(...r) {
    let e, t, n, i;
    if (typeof r[0] == "string" || Array.isArray(r[0]) ? ([t, n, i] = r, e = Ow) : [e, t, n, i] = r, !e) return $Ce;
    Array.isArray(t) || (t = [
      t
    ]), Array.isArray(n) || (n = [
      n
    ]);
    const a = [], o = () => {
      a.forEach((c) => c()), a.length = 0;
    }, s = (c, h, f, d) => (c.addEventListener(h, f, d), () => c.removeEventListener(h, f, d)), l = Pr(() => [
      Ff(e),
      Nw(i)
    ], ([c, h]) => {
      if (o(), !c) return;
      const f = VCe(h) ? {
        ...h
      } : h;
      a.push(...t.flatMap((d) => n.map((p) => s(c, d, p, f))));
    }, {
      immediate: true,
      flush: "post"
    }), u = () => {
      l(), o();
    };
    return A$(u), u;
  }
  function HCe(r) {
    return typeof r == "function" ? r : typeof r == "string" ? (e) => e.key === r : Array.isArray(r) ? (e) => r.includes(e.key) : () => true;
  }
  function YCe(...r) {
    let e, t, n = {};
    r.length === 3 ? (e = r[0], t = r[1], n = r[2]) : r.length === 2 ? typeof r[1] == "object" ? (e = true, t = r[0], n = r[1]) : (e = r[0], t = r[1]) : (e = true, t = r[0]);
    const { target: i = Ow, eventName: a = "keydown", passive: o = false, dedupe: s = false } = n, l = HCe(e);
    return I$(i, a, (u) => {
      u.repeat && Nw(s) || l(u) && t(u);
    }, o);
  }
  function XCe() {
    const r = We(false), e = yn();
    return e && Iu(() => {
      r.value = true;
    }, e), r;
  }
  function qCe(r) {
    return JSON.parse(JSON.stringify(r));
  }
  function Fw(r, e, t, n = {}) {
    var i, a, o;
    const { clone: s = false, passive: l = false, eventName: u, deep: c = false, defaultValue: h, shouldEmit: f } = n, d = yn(), p = t || (d == null ? void 0 : d.emit) || ((i = d == null ? void 0 : d.$emit) == null ? void 0 : i.bind(d)) || ((o = (a = d == null ? void 0 : d.proxy) == null ? void 0 : a.$emit) == null ? void 0 : o.bind(d == null ? void 0 : d.proxy));
    let v = u;
    e || (e = "modelValue"), v = v || `update:${e.toString()}`;
    const g = (x) => s ? typeof s == "function" ? s(x) : qCe(x) : x, m = () => BCe(r[e]) ? g(r[e]) : h, y = (x) => {
      f ? f(x) && p(v, x) : p(v, x);
    };
    if (l) {
      const x = m(), _ = We(x);
      let S = false;
      return Pr(() => r[e], (b) => {
        S || (S = true, _.value = g(b), wa(() => S = false));
      }), Pr(_, (b) => {
        !S && (b !== r[e] || c) && y(b);
      }, {
        deep: c
      }), _;
    } else return at({
      get() {
        return m();
      },
      set(x) {
        y(x);
      }
    });
  }
  function Bw(r) {
    return r ? r.flatMap((e) => e.type === mh ? Bw(e.children) : [
      e
    ]) : [];
  }
  function Oi() {
    let r = document.activeElement;
    if (r == null) return null;
    for (; r != null && r.shadowRoot != null && r.shadowRoot.activeElement != null; ) r = r.shadowRoot.activeElement;
    return r;
  }
  function K0(r) {
    if (r === null || typeof r != "object") return false;
    const e = Object.getPrototypeOf(r);
    return e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.iterator in r ? false : Symbol.toStringTag in r ? Object.prototype.toString.call(r) === "[object Module]" : true;
  }
  function Lb(r, e, t = ".", n) {
    if (!K0(e)) return Lb(r, {}, t);
    const i = Object.assign({}, e);
    for (const a in r) {
      if (a === "__proto__" || a === "constructor") continue;
      const o = r[a];
      o != null && (Array.isArray(o) && Array.isArray(i[a]) ? i[a] = [
        ...o,
        ...i[a]
      ] : K0(o) && K0(i[a]) ? i[a] = Lb(o, i[a], (t ? `${t}.` : "") + a.toString()) : i[a] = o);
    }
    return i;
  }
  function KCe(r) {
    return (...e) => e.reduce((t, n) => Lb(t, n, ""), {});
  }
  const ZCe = KCe(), [zw, GAe] = Of("ConfigProvider");
  let jCe = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", QCe = (r = 21) => {
    let e = "", t = r;
    for (; t--; ) e += jCe[Math.random() * 64 | 0];
    return e;
  };
  const JCe = FCe(() => {
    const r = We(/* @__PURE__ */ new Map()), e = We(), t = at(() => {
      for (const o of r.value.values()) if (o) return true;
      return false;
    }), n = zw({
      scrollBody: We(true)
    });
    let i = null;
    const a = () => {
      document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = e.value ?? "", SL && (i == null ? void 0 : i()), e.value = void 0;
    };
    return Pr(t, (o, s) => {
      var l;
      if (!ol) return;
      if (!o) {
        s && a();
        return;
      }
      e.value === void 0 && (e.value = document.body.style.overflow);
      const u = window.innerWidth - document.documentElement.clientWidth, c = {
        padding: u,
        margin: 0
      }, h = (l = n.scrollBody) != null && l.value ? typeof n.scrollBody.value == "object" ? ZCe({
        padding: n.scrollBody.value.padding === true ? u : n.scrollBody.value.padding,
        margin: n.scrollBody.value.margin === true ? u : n.scrollBody.value.margin
      }, c) : c : {
        padding: 0,
        margin: 0
      };
      u > 0 && (document.body.style.paddingRight = typeof h.padding == "number" ? `${h.padding}px` : String(h.padding), document.body.style.marginRight = typeof h.margin == "number" ? `${h.margin}px` : String(h.margin), document.body.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), SL && (i = I$(document, "touchmove", (f) => t2e(f), {
        passive: false
      })), wa(() => {
        document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
      });
    }, {
      immediate: true,
      flush: "sync"
    }), r;
  });
  function e2e(r) {
    const e = QCe(6), t = JCe();
    t.value.set(e, r);
    const n = at({
      get: () => t.value.get(e) ?? false,
      set: (i) => t.value.set(e, i)
    });
    return UCe(() => {
      t.value.delete(e);
    }), n;
  }
  function M$(r) {
    const e = window.getComputedStyle(r);
    if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && r.clientWidth < r.scrollWidth || e.overflowY === "auto" && r.clientHeight < r.scrollHeight) return true;
    {
      const t = r.parentNode;
      return !(t instanceof Element) || t.tagName === "BODY" ? false : M$(t);
    }
  }
  function t2e(r) {
    const e = r || window.event, t = e.target;
    return t instanceof Element && M$(t) ? false : e.touches.length > 1 ? true : (e.preventDefault && e.cancelable && e.preventDefault(), false);
  }
  function D$(r) {
    const e = zw({
      dir: We("ltr")
    });
    return at(() => {
      var t;
      return (r == null ? void 0 : r.value) || ((t = e.dir) == null ? void 0 : t.value) || "ltr";
    });
  }
  function Gg(r) {
    const e = yn(), t = e == null ? void 0 : e.type.emits, n = {};
    return t != null && t.length || console.warn(`No emitted event found. Please check component: ${e == null ? void 0 : e.type.__name}`), t == null ? void 0 : t.forEach((i) => {
      n[E4(VL(i))] = (...a) => r(i, ...a);
    }), n;
  }
  function Vw(r) {
    const e = yn(), t = Object.keys((e == null ? void 0 : e.type.props) ?? {}).reduce((i, a) => {
      const o = (e == null ? void 0 : e.type.props[a]).default;
      return o !== void 0 && (i[a] = o), i;
    }, {}), n = R4(r);
    return at(() => {
      const i = {}, a = (e == null ? void 0 : e.vnode.props) ?? {};
      return Object.keys(a).forEach((o) => {
        i[VL(o)] = a[o];
      }), Object.keys({
        ...t,
        ...i
      }).reduce((o, s) => (n.value[s] !== void 0 && (o[s] = n.value[s]), o), {});
    });
  }
  function $w(r, e) {
    const t = Vw(r), n = e ? Gg(e) : {};
    return at(() => ({
      ...t.value,
      ...n
    }));
  }
  function cn() {
    const r = yn(), e = We(), t = at(() => {
      var o, s;
      return [
        "#text",
        "#comment"
      ].includes((o = e.value) == null ? void 0 : o.$el.nodeName) ? (s = e.value) == null ? void 0 : s.$el.nextElementSibling : Ff(e);
    }), n = Object.assign({}, r.exposed), i = {};
    for (const o in r.props) Object.defineProperty(i, o, {
      enumerable: true,
      configurable: true,
      get: () => r.props[o]
    });
    if (Object.keys(n).length > 0) for (const o in n) Object.defineProperty(i, o, {
      enumerable: true,
      configurable: true,
      get: () => n[o]
    });
    Object.defineProperty(i, "$el", {
      enumerable: true,
      configurable: true,
      get: () => r.vnode.el
    }), r.exposed = i;
    function a(o) {
      e.value = o, o && (Object.defineProperty(i, "$el", {
        enumerable: true,
        configurable: true,
        get: () => o instanceof Element ? o : o.$el
      }), r.exposed = i);
    }
    return {
      forwardRef: a,
      currentRef: e,
      currentElement: t
    };
  }
  var r2e = function(r) {
    if (typeof document > "u") return null;
    var e = Array.isArray(r) ? r[0] : r;
    return e.ownerDocument.body;
  }, Nl = /* @__PURE__ */ new WeakMap(), ip = /* @__PURE__ */ new WeakMap(), ap = {}, Z0 = 0, P$ = function(r) {
    return r && (r.host || P$(r.parentNode));
  }, n2e = function(r, e) {
    return e.map(function(t) {
      if (r.contains(t)) return t;
      var n = P$(t);
      return n && r.contains(n) ? n : (console.error("aria-hidden", t, "in not contained inside", r, ". Doing nothing"), null);
    }).filter(function(t) {
      return !!t;
    });
  }, i2e = function(r, e, t, n) {
    var i = n2e(e, Array.isArray(r) ? r : [
      r
    ]);
    ap[t] || (ap[t] = /* @__PURE__ */ new WeakMap());
    var a = ap[t], o = [], s = /* @__PURE__ */ new Set(), l = new Set(i), u = function(h) {
      !h || s.has(h) || (s.add(h), u(h.parentNode));
    };
    i.forEach(u);
    var c = function(h) {
      !h || l.has(h) || Array.prototype.forEach.call(h.children, function(f) {
        if (s.has(f)) c(f);
        else try {
          var d = f.getAttribute(n), p = d !== null && d !== "false", v = (Nl.get(f) || 0) + 1, g = (a.get(f) || 0) + 1;
          Nl.set(f, v), a.set(f, g), o.push(f), v === 1 && p && ip.set(f, true), g === 1 && f.setAttribute(t, "true"), p || f.setAttribute(n, "true");
        } catch (m) {
          console.error("aria-hidden: cannot operate on ", f, m);
        }
      });
    };
    return c(e), s.clear(), Z0++, function() {
      o.forEach(function(h) {
        var f = Nl.get(h) - 1, d = a.get(h) - 1;
        Nl.set(h, f), a.set(h, d), f || (ip.has(h) || h.removeAttribute(n), ip.delete(h)), d || h.removeAttribute(t);
      }), Z0--, Z0 || (Nl = /* @__PURE__ */ new WeakMap(), Nl = /* @__PURE__ */ new WeakMap(), ip = /* @__PURE__ */ new WeakMap(), ap = {});
    };
  }, a2e = function(r, e, t) {
    t === void 0 && (t = "data-aria-hidden");
    var n = Array.from(Array.isArray(r) ? r : [
      r
    ]), i = r2e(r);
    return i ? (n.push.apply(n, Array.from(i.querySelectorAll("[aria-live]"))), i2e(n, i, t, "aria-hidden")) : function() {
      return null;
    };
  };
  function o2e(r) {
    let e;
    Pr(() => Ff(r), (t) => {
      t ? e = a2e(t) : e && e();
    }), Gv(() => {
      e && e();
    });
  }
  let s2e = 0;
  function Vv(r, e = "radix") {
    const t = zw({
      useId: void 0
    });
    return Qw ? `${e}-${Qw()}` : t.useId ? `${e}-${t.useId()}` : `${e}-${++s2e}`;
  }
  function l2e(r, e) {
    const t = We(r);
    function n(i) {
      return e[t.value][i] ?? t.value;
    }
    return {
      state: t,
      dispatch: (i) => {
        t.value = n(i);
      }
    };
  }
  const Gw = Ye({
    name: "PrimitiveSlot",
    inheritAttrs: false,
    setup(r, { attrs: e, slots: t }) {
      return () => {
        var n, i;
        if (!t.default) return null;
        const a = Bw(t.default()), o = a.findIndex((c) => c.type !== N4);
        if (o === -1) return a;
        const s = a[o];
        (n = s.props) == null || delete n.ref;
        const l = s.props ? on(e, s.props) : e;
        e.class && (i = s.props) != null && i.class && delete s.props.class;
        const u = O4(s, l);
        for (const c in l) c.startsWith("on") && (u.props || (u.props = {}), u.props[c] = l[c]);
        return a.length === 1 ? u : (a[o] = u, a);
      };
    }
  }), Un = Ye({
    name: "Primitive",
    inheritAttrs: false,
    props: {
      asChild: {
        type: Boolean,
        default: false
      },
      as: {
        type: [
          String,
          Object
        ],
        default: "div"
      }
    },
    setup(r, { attrs: e, slots: t }) {
      const n = r.asChild ? "template" : r.as;
      return typeof n == "string" && [
        "area",
        "img",
        "input"
      ].includes(n) ? () => ni(n, e) : n !== "template" ? () => ni(r.as, e, {
        default: t.default
      }) : () => ni(Gw, e, {
        default: t.default
      });
    }
  });
  function k$() {
    const r = We(), e = at(() => {
      var t, n;
      return [
        "#text",
        "#comment"
      ].includes((t = r.value) == null ? void 0 : t.$el.nodeName) ? (n = r.value) == null ? void 0 : n.$el.nextElementSibling : Ff(r);
    });
    return {
      primitiveElement: r,
      currentElement: e
    };
  }
  function u2e(r, e) {
    var t;
    const n = We({}), i = We("none"), a = We(r), o = r.value ? "mounted" : "unmounted";
    let s;
    const l = ((t = e.value) == null ? void 0 : t.ownerDocument.defaultView) ?? Ow, { state: u, dispatch: c } = l2e(o, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    }), h = (g) => {
      var m;
      if (ol) {
        const y = new CustomEvent(g, {
          bubbles: false,
          cancelable: false
        });
        (m = e.value) == null || m.dispatchEvent(y);
      }
    };
    Pr(r, async (g, m) => {
      var y;
      const x = m !== g;
      if (await wa(), x) {
        const _ = i.value, S = op(e.value);
        g ? (c("MOUNT"), h("enter"), S === "none" && h("after-enter")) : S === "none" || ((y = n.value) == null ? void 0 : y.display) === "none" ? (c("UNMOUNT"), h("leave"), h("after-leave")) : m && _ !== S ? (c("ANIMATION_OUT"), h("leave")) : (c("UNMOUNT"), h("after-leave"));
      }
    }, {
      immediate: true
    });
    const f = (g) => {
      const m = op(e.value), y = m.includes(g.animationName), x = u.value === "mounted" ? "enter" : "leave";
      if (g.target === e.value && y && (h(`after-${x}`), c("ANIMATION_END"), !a.value)) {
        const _ = e.value.style.animationFillMode;
        e.value.style.animationFillMode = "forwards", s = l == null ? void 0 : l.setTimeout(() => {
          var S;
          ((S = e.value) == null ? void 0 : S.style.animationFillMode) === "forwards" && (e.value.style.animationFillMode = _);
        });
      }
      g.target === e.value && m === "none" && c("ANIMATION_END");
    }, d = (g) => {
      g.target === e.value && (i.value = op(e.value));
    }, p = Pr(e, (g, m) => {
      g ? (n.value = getComputedStyle(g), g.addEventListener("animationstart", d), g.addEventListener("animationcancel", f), g.addEventListener("animationend", f)) : (c("ANIMATION_END"), s !== void 0 && (l == null ? void 0 : l.clearTimeout(s)), m == null ? void 0 : m.removeEventListener("animationstart", d), m == null ? void 0 : m.removeEventListener("animationcancel", f), m == null ? void 0 : m.removeEventListener("animationend", f));
    }, {
      immediate: true
    }), v = Pr(u, () => {
      const g = op(e.value);
      i.value = u.value === "mounted" ? g : "none";
    });
    return Gv(() => {
      p(), v();
    }), {
      isPresent: at(() => [
        "mounted",
        "unmountSuspended"
      ].includes(u.value))
    };
  }
  function op(r) {
    return r && getComputedStyle(r).animationName || "none";
  }
  const Ww = Ye({
    name: "Presence",
    props: {
      present: {
        type: Boolean,
        required: true
      },
      forceMount: {
        type: Boolean
      }
    },
    slots: {},
    setup(r, { slots: e, expose: t }) {
      var n;
      const { present: i, forceMount: a } = ff(r), o = We(), { isPresent: s } = u2e(i, o);
      t({
        present: s
      });
      let l = e.default({
        present: s
      });
      l = Bw(l || []);
      const u = yn();
      if (l && (l == null ? void 0 : l.length) > 1) {
        const c = (n = u == null ? void 0 : u.parent) != null && n.type.name ? `<${u.parent.type.name} />` : "component";
        throw new Error([
          `Detected an invalid children for \`${c}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((h) => `  - ${h}`).join(`
`)
        ].join(`
`));
      }
      return () => a.value || i.value || s.value ? ni(e.default({
        present: s
      })[0], {
        ref: (c) => {
          const h = Ff(c);
          return typeof (h == null ? void 0 : h.hasAttribute) > "u" || (h != null && h.hasAttribute("data-radix-popper-content-wrapper") ? o.value = h.firstElementChild : o.value = h), h;
        }
      }) : null;
    }
  }), [wo, c2e] = Of("DialogRoot"), h2e = Ye({
    inheritAttrs: false,
    __name: "DialogRoot",
    props: {
      open: {
        type: Boolean,
        default: void 0
      },
      defaultOpen: {
        type: Boolean,
        default: false
      },
      modal: {
        type: Boolean,
        default: true
      }
    },
    emits: [
      "update:open"
    ],
    setup(r, { emit: e }) {
      const t = r, n = Fw(t, "open", e, {
        defaultValue: t.defaultOpen,
        passive: t.open === void 0
      }), i = We(), a = We(), { modal: o } = ff(t);
      return c2e({
        open: n,
        modal: o,
        openModal: () => {
          n.value = true;
        },
        onOpenChange: (s) => {
          n.value = s;
        },
        onOpenToggle: () => {
          n.value = !n.value;
        },
        contentId: "",
        titleId: "",
        descriptionId: "",
        triggerElement: i,
        contentElement: a
      }), (s, l) => ot(s.$slots, "default", {
        open: W(n)
      });
    }
  }), f2e = Ye({
    __name: "Teleport",
    props: {
      to: {
        default: "body"
      },
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(r) {
      const e = XCe();
      return (t, n) => W(e) || t.forceMount ? (qe(), _t(B4, {
        key: 0,
        to: t.to,
        disabled: t.disabled
      }, [
        ot(t.$slots, "default")
      ], 8, [
        "to",
        "disabled"
      ])) : yh("", true);
    }
  }), d2e = Ye({
    __name: "DialogPortal",
    props: {
      to: {},
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), _t(W(f2e), $b(Gb(e)), {
        default: ve(() => [
          ot(t.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), p2e = "dismissableLayer.pointerDownOutside", v2e = "dismissableLayer.focusOutside";
  function L$(r, e) {
    const t = e.closest("[data-dismissable-layer]"), n = r.dataset.dismissableLayer === "" ? r : r.querySelector("[data-dismissable-layer]"), i = Array.from(r.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
    return !!(t && n === t || i.indexOf(n) < i.indexOf(t));
  }
  function g2e(r, e) {
    var t;
    const n = ((t = e == null ? void 0 : e.value) == null ? void 0 : t.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = We(false), a = We(() => {
    });
    return Fs((o) => {
      if (!ol) return;
      const s = async (u) => {
        const c = u.target;
        if (e != null && e.value) {
          if (L$(e.value, c)) {
            i.value = false;
            return;
          }
          if (u.target && !i.value) {
            let h = function() {
              T$(p2e, r, f);
            };
            const f = {
              originalEvent: u
            };
            u.pointerType === "touch" ? (n.removeEventListener("click", a.value), a.value = h, n.addEventListener("click", a.value, {
              once: true
            })) : h();
          } else n.removeEventListener("click", a.value);
          i.value = false;
        }
      }, l = window.setTimeout(() => {
        n.addEventListener("pointerdown", s);
      }, 0);
      o(() => {
        window.clearTimeout(l), n.removeEventListener("pointerdown", s), n.removeEventListener("click", a.value);
      });
    }), {
      onPointerDownCapture: () => i.value = true
    };
  }
  function m2e(r, e) {
    var t;
    const n = ((t = e == null ? void 0 : e.value) == null ? void 0 : t.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = We(false);
    return Fs((a) => {
      if (!ol) return;
      const o = async (s) => {
        e != null && e.value && (await wa(), !(!e.value || L$(e.value, s.target)) && s.target && !i.value && T$(v2e, r, {
          originalEvent: s
        }));
      };
      n.addEventListener("focusin", o), a(() => n.removeEventListener("focusin", o));
    }), {
      onFocusCapture: () => i.value = true,
      onBlurCapture: () => i.value = false
    };
  }
  const Qi = $L({
    layersRoot: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  }), y2e = Ye({
    __name: "DismissableLayer",
    props: {
      disableOutsidePointerEvents: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "dismiss"
    ],
    setup(r, { emit: e }) {
      const t = r, n = e, { forwardRef: i, currentElement: a } = cn(), o = at(() => {
        var p;
        return ((p = a.value) == null ? void 0 : p.ownerDocument) ?? globalThis.document;
      }), s = at(() => Qi.layersRoot), l = at(() => a.value ? Array.from(s.value).indexOf(a.value) : -1), u = at(() => Qi.layersWithOutsidePointerEventsDisabled.size > 0), c = at(() => {
        const p = Array.from(s.value), [v] = [
          ...Qi.layersWithOutsidePointerEventsDisabled
        ].slice(-1), g = p.indexOf(v);
        return l.value >= g;
      }), h = g2e(async (p) => {
        const v = [
          ...Qi.branches
        ].some((g) => g == null ? void 0 : g.contains(p.target));
        !c.value || v || (n("pointerDownOutside", p), n("interactOutside", p), await wa(), p.defaultPrevented || n("dismiss"));
      }, a), f = m2e((p) => {
        [
          ...Qi.branches
        ].some((v) => v == null ? void 0 : v.contains(p.target)) || (n("focusOutside", p), n("interactOutside", p), p.defaultPrevented || n("dismiss"));
      }, a);
      YCe("Escape", (p) => {
        l.value === s.value.size - 1 && (n("escapeKeyDown", p), p.defaultPrevented || n("dismiss"));
      });
      let d;
      return Fs((p) => {
        a.value && (t.disableOutsidePointerEvents && (Qi.layersWithOutsidePointerEventsDisabled.size === 0 && (d = o.value.body.style.pointerEvents, o.value.body.style.pointerEvents = "none"), Qi.layersWithOutsidePointerEventsDisabled.add(a.value)), s.value.add(a.value), p(() => {
          t.disableOutsidePointerEvents && Qi.layersWithOutsidePointerEventsDisabled.size === 1 && (o.value.body.style.pointerEvents = d);
        }));
      }), Fs((p) => {
        p(() => {
          a.value && (s.value.delete(a.value), Qi.layersWithOutsidePointerEventsDisabled.delete(a.value));
        });
      }), (p, v) => (qe(), _t(W(Un), {
        ref: W(i),
        "as-child": p.asChild,
        as: p.as,
        "data-dismissable-layer": "",
        style: GL({
          pointerEvents: u.value ? c.value ? "auto" : "none" : void 0
        }),
        onFocusCapture: W(f).onFocusCapture,
        onBlurCapture: W(f).onBlurCapture,
        onPointerdownCapture: W(h).onPointerDownCapture
      }, {
        default: ve(() => [
          ot(p.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "style",
        "onFocusCapture",
        "onBlurCapture",
        "onPointerdownCapture"
      ]));
    }
  }), j0 = "focusScope.autoFocusOnMount", Q0 = "focusScope.autoFocusOnUnmount", wL = {
    bubbles: false,
    cancelable: true
  };
  function x2e(r, { select: e = false } = {}) {
    const t = Oi();
    for (const n of r) if ($a(n, {
      select: e
    }), Oi() !== t) return true;
  }
  function _2e(r) {
    const e = R$(r), t = CL(e, r), n = CL(e.reverse(), r);
    return [
      t,
      n
    ];
  }
  function R$(r) {
    const e = [], t = document.createTreeWalker(r, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (n) => {
        const i = n.tagName === "INPUT" && n.type === "hidden";
        return n.disabled || n.hidden || i ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; t.nextNode(); ) e.push(t.currentNode);
    return e;
  }
  function CL(r, e) {
    for (const t of r) if (!b2e(t, {
      upTo: e
    })) return t;
  }
  function b2e(r, { upTo: e }) {
    if (getComputedStyle(r).visibility === "hidden") return true;
    for (; r; ) {
      if (e !== void 0 && r === e) return false;
      if (getComputedStyle(r).display === "none") return true;
      r = r.parentElement;
    }
    return false;
  }
  function S2e(r) {
    return r instanceof HTMLInputElement && "select" in r;
  }
  function $a(r, { select: e = false } = {}) {
    if (r && r.focus) {
      const t = Oi();
      r.focus({
        preventScroll: true
      }), r !== t && S2e(r) && e && r.select();
    }
  }
  const w2e = OCe(() => We([]));
  function C2e() {
    const r = w2e();
    return {
      add(e) {
        const t = r.value[0];
        e !== t && (t == null ? void 0 : t.pause()), r.value = TL(r.value, e), r.value.unshift(e);
      },
      remove(e) {
        var t;
        r.value = TL(r.value, e), (t = r.value[0]) == null || t.resume();
      }
    };
  }
  function TL(r, e) {
    const t = [
      ...r
    ], n = t.indexOf(e);
    return n !== -1 && t.splice(n, 1), t;
  }
  function T2e(r) {
    return r.filter((e) => e.tagName !== "A");
  }
  const A2e = Ye({
    __name: "FocusScope",
    props: {
      loop: {
        type: Boolean,
        default: false
      },
      trapped: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "mountAutoFocus",
      "unmountAutoFocus"
    ],
    setup(r, { emit: e }) {
      const t = r, n = e, { currentRef: i, currentElement: a } = cn(), o = We(null), s = C2e(), l = $L({
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      });
      Fs((c) => {
        if (!ol) return;
        const h = a.value;
        if (!t.trapped) return;
        function f(g) {
          if (l.paused || !h) return;
          const m = g.target;
          h.contains(m) ? o.value = m : $a(o.value, {
            select: true
          });
        }
        function d(g) {
          if (l.paused || !h) return;
          const m = g.relatedTarget;
          m !== null && (h.contains(m) || $a(o.value, {
            select: true
          }));
        }
        function p(g) {
          h.contains(o.value) || $a(h);
        }
        document.addEventListener("focusin", f), document.addEventListener("focusout", d);
        const v = new MutationObserver(p);
        h && v.observe(h, {
          childList: true,
          subtree: true
        }), c(() => {
          document.removeEventListener("focusin", f), document.removeEventListener("focusout", d), v.disconnect();
        });
      }), Fs(async (c) => {
        const h = a.value;
        if (await wa(), !h) return;
        s.add(l);
        const f = Oi();
        if (!h.contains(f)) {
          const d = new CustomEvent(j0, wL);
          h.addEventListener(j0, (p) => n("mountAutoFocus", p)), h.dispatchEvent(d), d.defaultPrevented || (x2e(T2e(R$(h)), {
            select: true
          }), Oi() === f && $a(h));
        }
        c(() => {
          h.removeEventListener(j0, (v) => n("mountAutoFocus", v));
          const d = new CustomEvent(Q0, wL), p = (v) => {
            n("unmountAutoFocus", v);
          };
          h.addEventListener(Q0, p), h.dispatchEvent(d), setTimeout(() => {
            d.defaultPrevented || $a(f ?? document.body, {
              select: true
            }), h.removeEventListener(Q0, p), s.remove(l);
          }, 0);
        });
      });
      function u(c) {
        if (!t.loop && !t.trapped || l.paused) return;
        const h = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, f = Oi();
        if (h && f) {
          const d = c.currentTarget, [p, v] = _2e(d);
          p && v ? !c.shiftKey && f === v ? (c.preventDefault(), t.loop && $a(p, {
            select: true
          })) : c.shiftKey && f === p && (c.preventDefault(), t.loop && $a(v, {
            select: true
          })) : f === d && c.preventDefault();
        }
      }
      return (c, h) => (qe(), _t(W(Un), {
        ref_key: "currentRef",
        ref: i,
        tabindex: "-1",
        "as-child": c.asChild,
        as: c.as,
        onKeydown: u
      }, {
        default: ve(() => [
          ot(c.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as-child",
        "as"
      ]));
    }
  });
  function I2e(r) {
    return r ? "open" : "closed";
  }
  const E$ = Ye({
    __name: "DialogContentImpl",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(r, { emit: e }) {
      const t = r, n = e, i = wo(), { forwardRef: a, currentElement: o } = cn();
      return i.titleId || (i.titleId = Vv(void 0, "radix-vue-dialog-title")), i.descriptionId || (i.descriptionId = Vv(void 0, "radix-vue-dialog-description")), Iu(() => {
        i.contentElement = o, Oi() !== document.body && (i.triggerElement.value = Oi());
      }), (s, l) => (qe(), _t(W(A2e), {
        "as-child": "",
        loop: "",
        trapped: t.trapFocus,
        onMountAutoFocus: l[5] || (l[5] = (u) => n("openAutoFocus", u)),
        onUnmountAutoFocus: l[6] || (l[6] = (u) => n("closeAutoFocus", u))
      }, {
        default: ve(() => [
          Ge(W(y2e), on({
            id: W(i).contentId,
            ref: W(a),
            as: s.as,
            "as-child": s.asChild,
            "disable-outside-pointer-events": s.disableOutsidePointerEvents,
            role: "dialog",
            "aria-describedby": W(i).descriptionId,
            "aria-labelledby": W(i).titleId,
            "data-state": W(I2e)(W(i).open.value)
          }, s.$attrs, {
            onDismiss: l[0] || (l[0] = (u) => W(i).onOpenChange(false)),
            onEscapeKeyDown: l[1] || (l[1] = (u) => n("escapeKeyDown", u)),
            onFocusOutside: l[2] || (l[2] = (u) => n("focusOutside", u)),
            onInteractOutside: l[3] || (l[3] = (u) => n("interactOutside", u)),
            onPointerDownOutside: l[4] || (l[4] = (u) => n("pointerDownOutside", u))
          }), {
            default: ve(() => [
              ot(s.$slots, "default")
            ]),
            _: 3
          }, 16, [
            "id",
            "as",
            "as-child",
            "disable-outside-pointer-events",
            "aria-describedby",
            "aria-labelledby",
            "data-state"
          ])
        ]),
        _: 3
      }, 8, [
        "trapped"
      ]));
    }
  }), M2e = Ye({
    __name: "DialogContentModal",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(r, { emit: e }) {
      const t = r, n = e, i = wo(), a = Gg(n), { forwardRef: o, currentElement: s } = cn();
      return o2e(s), (l, u) => (qe(), _t(E$, on({
        ...t,
        ...W(a)
      }, {
        ref: W(o),
        "trap-focus": W(i).open.value,
        "disable-outside-pointer-events": true,
        onCloseAutoFocus: u[0] || (u[0] = (c) => {
          var h;
          c.defaultPrevented || (c.preventDefault(), (h = W(i).triggerElement.value) == null || h.focus());
        }),
        onPointerDownOutside: u[1] || (u[1] = (c) => {
          const h = c.detail.originalEvent, f = h.button === 0 && h.ctrlKey === true;
          (h.button === 2 || f) && c.preventDefault();
        }),
        onFocusOutside: u[2] || (u[2] = (c) => {
          c.preventDefault();
        })
      }), {
        default: ve(() => [
          ot(l.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "trap-focus"
      ]));
    }
  }), D2e = Ye({
    __name: "DialogContentNonModal",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(r, { emit: e }) {
      const t = r, n = Gg(e);
      cn();
      const i = wo(), a = We(false), o = We(false);
      return (s, l) => (qe(), _t(E$, on({
        ...t,
        ...W(n)
      }, {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: l[0] || (l[0] = (u) => {
          var c;
          u.defaultPrevented || (a.value || (c = W(i).triggerElement.value) == null || c.focus(), u.preventDefault()), a.value = false, o.value = false;
        }),
        onInteractOutside: l[1] || (l[1] = (u) => {
          var c;
          u.defaultPrevented || (a.value = true, u.detail.originalEvent.type === "pointerdown" && (o.value = true));
          const h = u.target;
          (c = W(i).triggerElement.value) != null && c.contains(h) && u.preventDefault(), u.detail.originalEvent.type === "focusin" && o.value && u.preventDefault();
        })
      }), {
        default: ve(() => [
          ot(s.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), P2e = Ye({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(r, { emit: e }) {
      const t = r, n = e, i = wo(), a = Gg(n), { forwardRef: o } = cn();
      return (s, l) => (qe(), _t(W(Ww), {
        present: s.forceMount || W(i).open.value
      }, {
        default: ve(() => [
          W(i).modal.value ? (qe(), _t(M2e, on({
            key: 0,
            ref: W(o)
          }, {
            ...t,
            ...W(a),
            ...s.$attrs
          }), {
            default: ve(() => [
              ot(s.$slots, "default")
            ]),
            _: 3
          }, 16)) : (qe(), _t(D2e, on({
            key: 1,
            ref: W(o)
          }, {
            ...t,
            ...W(a),
            ...s.$attrs
          }), {
            default: ve(() => [
              ot(s.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, [
        "present"
      ]));
    }
  }), k2e = Ye({
    __name: "DialogOverlayImpl",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(r) {
      const e = wo();
      return e2e(true), cn(), (t, n) => (qe(), _t(W(Un), {
        as: t.as,
        "as-child": t.asChild,
        "data-state": W(e).open.value ? "open" : "closed",
        style: {
          "pointer-events": "auto"
        }
      }, {
        default: ve(() => [
          ot(t.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ]));
    }
  }), L2e = Ye({
    __name: "DialogOverlay",
    props: {
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(r) {
      const e = wo(), { forwardRef: t } = cn();
      return (n, i) => {
        var a;
        return (a = W(e)) != null && a.modal.value ? (qe(), _t(W(Ww), {
          key: 0,
          present: n.forceMount || W(e).open.value
        }, {
          default: ve(() => [
            Ge(k2e, on(n.$attrs, {
              ref: W(t),
              as: n.as,
              "as-child": n.asChild
            }), {
              default: ve(() => [
                ot(n.$slots, "default")
              ]),
              _: 3
            }, 16, [
              "as",
              "as-child"
            ])
          ]),
          _: 3
        }, 8, [
          "present"
        ])) : yh("", true);
      };
    }
  }), R2e = Ye({
    __name: "DialogClose",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(r) {
      const e = r;
      cn();
      const t = wo();
      return (n, i) => (qe(), _t(W(Un), on(e, {
        type: n.as === "button" ? "button" : void 0,
        onClick: i[0] || (i[0] = (a) => W(t).onOpenChange(false))
      }), {
        default: ve(() => [
          ot(n.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "type"
      ]));
    }
  }), E2e = Ye({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "h2"
      }
    },
    setup(r) {
      const e = r, t = wo();
      return cn(), (n, i) => (qe(), _t(W(Un), on(e, {
        id: W(t).titleId
      }), {
        default: ve(() => [
          ot(n.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "id"
      ]));
    }
  }), N2e = "data-radix-vue-collection-item", [Uw, O2e] = Of("CollectionProvider");
  function F2e(r = N2e) {
    const e = We(/* @__PURE__ */ new Map()), t = We(), n = O2e({
      collectionRef: t,
      itemMap: e,
      attrName: r
    }), { getItems: i } = N$(n), a = at(() => Array.from(n.itemMap.value.values())), o = at(() => n.itemMap.value.size);
    return {
      getItems: i,
      reactiveItems: a,
      itemMapSize: o
    };
  }
  const B2e = Ye({
    name: "CollectionSlot",
    setup(r, { slots: e }) {
      const t = Uw(), { primitiveElement: n, currentElement: i } = k$();
      return Pr(i, () => {
        t.collectionRef.value = i.value;
      }), () => ni(Gw, {
        ref: n
      }, e);
    }
  }), z2e = Ye({
    name: "CollectionItem",
    inheritAttrs: false,
    props: {
      value: {
        validator: () => true
      }
    },
    setup(r, { slots: e, attrs: t }) {
      const n = Uw(), { primitiveElement: i, currentElement: a } = k$();
      return Fs((o) => {
        if (a.value) {
          const s = G4(a.value);
          n.itemMap.value.set(s, {
            ref: a.value,
            value: r.value
          }), o(() => n.itemMap.value.delete(s));
        }
      }), () => ni(Gw, {
        ...t,
        [n.attrName]: "",
        ref: i
      }, e);
    }
  });
  function N$(r) {
    const e = r ?? Uw();
    return {
      getItems: () => {
        const t = e.collectionRef.value;
        if (!t) return [];
        const n = Array.from(t.querySelectorAll(`[${e.attrName}]`));
        return Array.from(e.itemMap.value.values()).sort((i, a) => n.indexOf(i.ref) - n.indexOf(a.ref));
      }
    };
  }
  const V2e = "rovingFocusGroup.onEntryFocus", $2e = {
    bubbles: false,
    cancelable: true
  }, G2e = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function W2e(r, e) {
    return e !== "rtl" ? r : r === "ArrowLeft" ? "ArrowRight" : r === "ArrowRight" ? "ArrowLeft" : r;
  }
  function U2e(r, e, t) {
    const n = W2e(r.key, t);
    if (!(e === "vertical" && [
      "ArrowLeft",
      "ArrowRight"
    ].includes(n)) && !(e === "horizontal" && [
      "ArrowUp",
      "ArrowDown"
    ].includes(n))) return G2e[n];
  }
  function O$(r, e = false) {
    const t = Oi();
    for (const n of r) if (n === t || (n.focus({
      preventScroll: e
    }), Oi() !== t)) return;
  }
  function H2e(r, e) {
    return r.map((t, n) => r[(e + n) % r.length]);
  }
  const [Y2e, X2e] = Of("RovingFocusGroup"), q2e = Ye({
    __name: "RovingFocusGroup",
    props: {
      orientation: {
        default: void 0
      },
      dir: {},
      loop: {
        type: Boolean,
        default: false
      },
      currentTabStopId: {},
      defaultCurrentTabStopId: {},
      preventScrollOnEntryFocus: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "entryFocus",
      "update:currentTabStopId"
    ],
    setup(r, { expose: e, emit: t }) {
      const n = r, i = t, { loop: a, orientation: o, dir: s } = ff(n), l = D$(s), u = Fw(n, "currentTabStopId", i, {
        defaultValue: n.defaultCurrentTabStopId,
        passive: n.currentTabStopId === void 0
      }), c = We(false), h = We(false), f = We(0), { getItems: d } = F2e();
      function p(g) {
        const m = !h.value;
        if (g.currentTarget && g.target === g.currentTarget && m && !c.value) {
          const y = new CustomEvent(V2e, $2e);
          if (g.currentTarget.dispatchEvent(y), i("entryFocus", y), !y.defaultPrevented) {
            const x = d().map((w) => w.ref).filter((w) => w.dataset.disabled !== ""), _ = x.find((w) => w.getAttribute("data-active") === "true"), S = x.find((w) => w.id === u.value), b = [
              _,
              S,
              ...x
            ].filter(Boolean);
            O$(b, n.preventScrollOnEntryFocus);
          }
        }
        h.value = false;
      }
      function v() {
        setTimeout(() => {
          h.value = false;
        }, 1);
      }
      return e({
        getItems: d
      }), X2e({
        loop: a,
        dir: l,
        orientation: o,
        currentTabStopId: u,
        onItemFocus: (g) => {
          u.value = g;
        },
        onItemShiftTab: () => {
          c.value = true;
        },
        onFocusableItemAdd: () => {
          f.value++;
        },
        onFocusableItemRemove: () => {
          f.value--;
        }
      }), (g, m) => (qe(), _t(W(B2e), null, {
        default: ve(() => [
          Ge(W(Un), {
            tabindex: c.value || f.value === 0 ? -1 : 0,
            "data-orientation": W(o),
            as: g.as,
            "as-child": g.asChild,
            dir: W(l),
            style: {
              outline: "none"
            },
            onMousedown: m[0] || (m[0] = (y) => h.value = true),
            onMouseup: v,
            onFocus: p,
            onBlur: m[1] || (m[1] = (y) => c.value = false)
          }, {
            default: ve(() => [
              ot(g.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "as",
            "as-child",
            "dir"
          ])
        ]),
        _: 3
      }));
    }
  }), K2e = Ye({
    __name: "RovingFocusItem",
    props: {
      tabStopId: {},
      focusable: {
        type: Boolean,
        default: true
      },
      active: {
        type: Boolean,
        default: true
      },
      allowShiftKey: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(r) {
      const e = r, t = Y2e(), n = at(() => e.tabStopId || Vv()), i = at(() => t.currentTabStopId.value === n.value), { getItems: a } = N$();
      Iu(() => {
        e.focusable && t.onFocusableItemAdd();
      }), Gv(() => {
        e.focusable && t.onFocusableItemRemove();
      });
      function o(s) {
        if (s.key === "Tab" && s.shiftKey) {
          t.onItemShiftTab();
          return;
        }
        if (s.target !== s.currentTarget) return;
        const l = U2e(s, t.orientation.value, t.dir.value);
        if (l !== void 0) {
          if (s.metaKey || s.ctrlKey || s.altKey || !e.allowShiftKey && s.shiftKey) return;
          s.preventDefault();
          let u = [
            ...a().map((c) => c.ref).filter((c) => c.dataset.disabled !== "")
          ];
          if (l === "last") u.reverse();
          else if (l === "prev" || l === "next") {
            l === "prev" && u.reverse();
            const c = u.indexOf(s.currentTarget);
            u = t.loop.value ? H2e(u, c + 1) : u.slice(c + 1);
          }
          wa(() => O$(u));
        }
      }
      return (s, l) => (qe(), _t(W(z2e), null, {
        default: ve(() => [
          Ge(W(Un), {
            tabindex: i.value ? 0 : -1,
            "data-orientation": W(t).orientation.value,
            "data-active": s.active,
            "data-disabled": s.focusable ? void 0 : "",
            as: s.as,
            "as-child": s.asChild,
            onMousedown: l[0] || (l[0] = (u) => {
              s.focusable ? W(t).onItemFocus(n.value) : u.preventDefault();
            }),
            onFocus: l[1] || (l[1] = (u) => W(t).onItemFocus(n.value)),
            onKeydown: o
          }, {
            default: ve(() => [
              ot(s.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "data-active",
            "data-disabled",
            "as",
            "as-child"
          ])
        ]),
        _: 3
      }));
    }
  });
  function Z2e() {
    if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
  Z2e();
  const [Hw, j2e] = Of("TabsRoot"), Q2e = Ye({
    __name: "TabsRoot",
    props: {
      defaultValue: {},
      orientation: {
        default: "horizontal"
      },
      dir: {},
      activationMode: {
        default: "automatic"
      },
      modelValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(r, { emit: e }) {
      const t = r, n = e, { orientation: i, dir: a } = ff(t), o = D$(a);
      cn();
      const s = Fw(t, "modelValue", n, {
        defaultValue: t.defaultValue,
        passive: t.modelValue === void 0
      }), l = We();
      return j2e({
        modelValue: s,
        changeModelValue: (u) => {
          s.value = u;
        },
        orientation: i,
        dir: o,
        activationMode: t.activationMode,
        baseId: Vv(void 0, "radix-vue-tabs"),
        tabsList: l
      }), (u, c) => (qe(), _t(W(Un), {
        dir: W(o),
        "data-orientation": W(i),
        "as-child": u.asChild,
        as: u.as
      }, {
        default: ve(() => [
          ot(u.$slots, "default", {
            modelValue: W(s)
          })
        ]),
        _: 3
      }, 8, [
        "dir",
        "data-orientation",
        "as-child",
        "as"
      ]));
    }
  }), J2e = Ye({
    __name: "TabsList",
    props: {
      loop: {
        type: Boolean,
        default: true
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(r) {
      const e = r, { loop: t } = ff(e), { forwardRef: n, currentElement: i } = cn(), a = Hw();
      return a.tabsList = i, (o, s) => (qe(), _t(W(q2e), {
        "as-child": "",
        orientation: W(a).orientation.value,
        dir: W(a).dir.value,
        loop: W(t)
      }, {
        default: ve(() => [
          Ge(W(Un), {
            ref: W(n),
            role: "tablist",
            "as-child": o.asChild,
            as: o.as,
            "aria-orientation": W(a).orientation.value
          }, {
            default: ve(() => [
              ot(o.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "as-child",
            "as",
            "aria-orientation"
          ])
        ]),
        _: 3
      }, 8, [
        "orientation",
        "dir",
        "loop"
      ]));
    }
  });
  function F$(r, e) {
    return `${r}-trigger-${e}`;
  }
  function B$(r, e) {
    return `${r}-content-${e}`;
  }
  const eTe = Ye({
    __name: "TabsContent",
    props: {
      value: {},
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(r) {
      const e = r, { forwardRef: t } = cn(), n = Hw(), i = at(() => F$(n.baseId, e.value)), a = at(() => B$(n.baseId, e.value)), o = at(() => e.value === n.modelValue.value), s = We(o.value);
      return Iu(() => {
        requestAnimationFrame(() => {
          s.value = false;
        });
      }), (l, u) => (qe(), _t(W(Ww), {
        present: o.value,
        "force-mount": ""
      }, {
        default: ve(({ present: c }) => [
          Ge(W(Un), {
            id: a.value,
            ref: W(t),
            "as-child": l.asChild,
            as: l.as,
            role: "tabpanel",
            "data-state": o.value ? "active" : "inactive",
            "data-orientation": W(n).orientation.value,
            "aria-labelledby": i.value,
            hidden: !c.value,
            tabindex: "0",
            style: GL({
              animationDuration: s.value ? "0s" : void 0
            })
          }, {
            default: ve(() => [
              l.forceMount || o.value ? ot(l.$slots, "default", {
                key: 0
              }) : yh("", true)
            ]),
            _: 2
          }, 1032, [
            "id",
            "as-child",
            "as",
            "data-state",
            "data-orientation",
            "aria-labelledby",
            "hidden",
            "style"
          ])
        ]),
        _: 3
      }, 8, [
        "present"
      ]));
    }
  }), tTe = Ye({
    __name: "TabsTrigger",
    props: {
      value: {},
      disabled: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(r) {
      const e = r, { forwardRef: t } = cn(), n = Hw(), i = at(() => F$(n.baseId, e.value)), a = at(() => B$(n.baseId, e.value)), o = at(() => e.value === n.modelValue.value);
      return (s, l) => (qe(), _t(W(K2e), {
        "as-child": "",
        focusable: !s.disabled,
        active: o.value
      }, {
        default: ve(() => [
          Ge(W(Un), {
            id: i.value,
            ref: W(t),
            role: "tab",
            type: s.as === "button" ? "button" : void 0,
            as: s.as,
            "as-child": s.asChild,
            "aria-selected": o.value ? "true" : "false",
            "aria-controls": a.value,
            "data-state": o.value ? "active" : "inactive",
            disabled: s.disabled,
            "data-disabled": s.disabled ? "" : void 0,
            "data-orientation": W(n).orientation.value,
            onMousedown: l[0] || (l[0] = Mc((u) => {
              !s.disabled && u.ctrlKey === false ? W(n).changeModelValue(s.value) : u.preventDefault();
            }, [
              "left"
            ])),
            onKeydown: l[1] || (l[1] = F4((u) => W(n).changeModelValue(s.value), [
              "enter",
              "space"
            ])),
            onFocus: l[2] || (l[2] = () => {
              const u = W(n).activationMode !== "manual";
              !o.value && !s.disabled && u && W(n).changeModelValue(s.value);
            })
          }, {
            default: ve(() => [
              ot(s.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "id",
            "type",
            "as",
            "as-child",
            "aria-selected",
            "aria-controls",
            "data-state",
            "disabled",
            "data-disabled",
            "data-orientation"
          ])
        ]),
        _: 3
      }, 8, [
        "focusable",
        "active"
      ]));
    }
  }), J0 = Ye({
    __name: "Button",
    props: {
      variant: {},
      size: {},
      class: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), _t(W(Un), {
        as: t.as,
        "as-child": t.asChild,
        class: _n(W(wr)(W(rTe)({
          variant: t.variant,
          size: t.size
        }), e.class))
      }, {
        default: ve(() => [
          ot(t.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "class"
      ]));
    }
  }), rTe = qwe("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }), nTe = Ye({
    __name: "Card",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("div", {
        class: _n(W(wr)("rounded-lg border bg-card text-card-foreground shadow-sm", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), ex = Ye({
    __name: "CardContent",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("div", {
        class: _n(W(wr)("p-6 pt-0", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), iTe = Ye({
    __name: "CardHeader",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("div", {
        class: _n(W(wr)("flex flex-col gap-y-1.5 p-6", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), aTe = Ye({
    __name: "Dialog",
    props: {
      open: {
        type: Boolean
      },
      defaultOpen: {
        type: Boolean
      },
      modal: {
        type: Boolean
      }
    },
    emits: [
      "update:open"
    ],
    setup(r, { emit: e }) {
      const i = $w(r, e);
      return (a, o) => (qe(), _t(W(h2e), $b(Gb(W(i))), {
        default: ve(() => [
          ot(a.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), oTe = Ye({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(r, { emit: e }) {
      const t = r, n = e, i = at(() => {
        const { class: o, ...s } = t;
        return s;
      }), a = $w(i, n);
      return (o, s) => (qe(), _t(W(d2e), null, {
        default: ve(() => [
          Ge(W(L2e), {
            class: "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
          }),
          Ge(W(P2e), on(W(a), {
            class: W(wr)("fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", t.class)
          }), {
            default: ve(() => [
              ot(o.$slots, "default"),
              Ge(W(R2e), {
                class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground"
              }, {
                default: ve(() => [
                  Ge(W(Xse), {
                    class: "w-4 h-4"
                  }),
                  s[0] || (s[0] = pe("span", {
                    class: "sr-only"
                  }, "Close", -1))
                ]),
                _: 1
              })
            ]),
            _: 3
          }, 16, [
            "class"
          ])
        ]),
        _: 3
      }));
    }
  }), sTe = Ye({
    __name: "DialogHeader",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("div", {
        class: _n(W(wr)("flex flex-col gap-y-1.5 text-center sm:text-left", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), lTe = Ye({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(r) {
      const e = r, t = at(() => {
        const { class: i, ...a } = e;
        return a;
      }), n = Vw(t);
      return (i, a) => (qe(), _t(W(E2e), on(W(n), {
        class: W(wr)("text-lg font-semibold leading-none tracking-tight", e.class)
      }), {
        default: ve(() => [
          ot(i.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  });
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const uTe = (r) => typeof r < "u";
  function cTe(r) {
    return JSON.parse(JSON.stringify(r));
  }
  function hTe(r, e, t, n = {}) {
    var i, a, o;
    const { clone: s = false, passive: l = false, eventName: u, deep: c = false, defaultValue: h, shouldEmit: f } = n, d = yn(), p = t || (d == null ? void 0 : d.emit) || ((i = d == null ? void 0 : d.$emit) == null ? void 0 : i.bind(d)) || ((o = (a = d == null ? void 0 : d.proxy) == null ? void 0 : a.$emit) == null ? void 0 : o.bind(d == null ? void 0 : d.proxy));
    let v = u;
    v = v || `update:${e.toString()}`;
    const g = (x) => s ? typeof s == "function" ? s(x) : cTe(x) : x, m = () => uTe(r[e]) ? g(r[e]) : h, y = (x) => {
      f ? f(x) && p(v, x) : p(v, x);
    };
    if (l) {
      const x = m(), _ = We(x);
      let S = false;
      return Pr(() => r[e], (b) => {
        S || (S = true, _.value = g(b), wa(() => S = false));
      }), Pr(_, (b) => {
        !S && (b !== r[e] || c) && y(b);
      }, {
        deep: c
      }), _;
    } else return at({
      get() {
        return m();
      },
      set(x) {
        y(x);
      }
    });
  }
  const fTe = Ye({
    __name: "Textarea",
    props: {
      class: {},
      defaultValue: {},
      modelValue: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(r, { emit: e }) {
      const t = r, i = hTe(t, "modelValue", e, {
        passive: true,
        defaultValue: t.defaultValue
      });
      return (a, o) => sp((qe(), Mr("textarea", {
        "onUpdate:modelValue": o[0] || (o[0] = (s) => BL(i) ? i.value = s : null),
        class: _n(W(wr)("flex min-h-20 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t.class))
      }, null, 2)), [
        [
          nx,
          W(i)
        ]
      ]);
    }
  }), dTe = Ye({
    __name: "Tabs",
    props: {
      defaultValue: {},
      orientation: {},
      dir: {},
      activationMode: {},
      modelValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(r, { emit: e }) {
      const i = $w(r, e);
      return (a, o) => (qe(), _t(W(Q2e), $b(Gb(W(i))), {
        default: ve(() => [
          ot(a.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), AL = Ye({
    __name: "TabsContent",
    props: {
      value: {},
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(r) {
      const e = r, t = at(() => {
        const { class: n, ...i } = e;
        return i;
      });
      return (n, i) => (qe(), _t(W(eTe), on({
        class: W(wr)("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", e.class)
      }, t.value), {
        default: ve(() => [
          ot(n.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), pTe = Ye({
    __name: "TabsList",
    props: {
      loop: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(r) {
      const e = r, t = at(() => {
        const { class: n, ...i } = e;
        return i;
      });
      return (n, i) => (qe(), _t(W(J2e), on(t.value, {
        class: W(wr)("inline-flex items-center justify-center rounded-md bg-muted p-1 text-muted-foreground", e.class)
      }), {
        default: ve(() => [
          ot(n.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), vTe = {
    class: "truncate"
  }, IL = Ye({
    __name: "TabsTrigger",
    props: {
      value: {},
      disabled: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(r) {
      const e = r, t = at(() => {
        const { class: i, ...a } = e;
        return a;
      }), n = Vw(t);
      return (i, a) => (qe(), _t(W(tTe), on(W(n), {
        class: W(wr)("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm", e.class)
      }), {
        default: ve(() => [
          pe("span", vTe, [
            ot(i.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), gTe = {
    class: "relative w-full overflow-auto"
  }, mTe = Ye({
    __name: "Table",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("div", gTe, [
        pe("table", {
          class: _n(W(wr)("w-full caption-bottom text-sm", e.class))
        }, [
          ot(t.$slots, "default")
        ], 2)
      ]));
    }
  }), yTe = Ye({
    __name: "TableBody",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("tbody", {
        class: _n(W(wr)("[&_tr:last-child]:border-0", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), Ol = Ye({
    __name: "TableCell",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("td", {
        class: _n(W(wr)("p-4 align-middle [&:has([role=checkbox])]:pr-0", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), ML = Ye({
    __name: "TableRow",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("tr", {
        class: _n(W(wr)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), Fl = Ye({
    __name: "TableHead",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("th", {
        class: _n(W(wr)("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), xTe = Ye({
    __name: "TableHeader",
    props: {
      class: {}
    },
    setup(r) {
      const e = r;
      return (t, n) => (qe(), Mr("thead", {
        class: _n(W(wr)("[&_tr]:border-b", e.class))
      }, [
        ot(t.$slots, "default")
      ], 2));
    }
  }), _Te = 1, bTe = 1e6, aa = {
    ADD_TOAST: "ADD_TOAST",
    UPDATE_TOAST: "UPDATE_TOAST",
    DISMISS_TOAST: "DISMISS_TOAST",
    REMOVE_TOAST: "REMOVE_TOAST"
  };
  let tx = 0;
  function STe() {
    return tx = (tx + 1) % Number.MAX_VALUE, tx.toString();
  }
  const rx = /* @__PURE__ */ new Map();
  function DL(r) {
    if (rx.has(r)) return;
    const e = setTimeout(() => {
      rx.delete(r), dh({
        type: aa.REMOVE_TOAST,
        toastId: r
      });
    }, bTe);
    rx.set(r, e);
  }
  const Kn = We({
    toasts: []
  });
  function dh(r) {
    switch (r.type) {
      case aa.ADD_TOAST:
        Kn.value.toasts = [
          r.toast,
          ...Kn.value.toasts
        ].slice(0, _Te);
        break;
      case aa.UPDATE_TOAST:
        Kn.value.toasts = Kn.value.toasts.map((e) => e.id === r.toast.id ? {
          ...e,
          ...r.toast
        } : e);
        break;
      case aa.DISMISS_TOAST: {
        const { toastId: e } = r;
        e ? DL(e) : Kn.value.toasts.forEach((t) => {
          DL(t.id);
        }), Kn.value.toasts = Kn.value.toasts.map((t) => t.id === e || e === void 0 ? {
          ...t,
          open: false
        } : t);
        break;
      }
      case aa.REMOVE_TOAST:
        r.toastId === void 0 ? Kn.value.toasts = [] : Kn.value.toasts = Kn.value.toasts.filter((e) => e.id !== r.toastId);
        break;
    }
  }
  function wTe() {
    return {
      toasts: at(() => Kn.value.toasts),
      toast: CTe,
      dismiss: (r) => dh({
        type: aa.DISMISS_TOAST,
        toastId: r
      })
    };
  }
  function CTe(r) {
    const e = STe(), t = (i) => dh({
      type: aa.UPDATE_TOAST,
      toast: {
        ...i,
        id: e
      }
    }), n = () => dh({
      type: aa.DISMISS_TOAST,
      toastId: e
    });
    return dh({
      type: aa.ADD_TOAST,
      toast: {
        ...r,
        id: e,
        open: true,
        onOpenChange: (i) => {
          i || n();
        }
      }
    }), {
      id: e,
      dismiss: n,
      update: t
    };
  }
  let TTe, ATe, ITe, MTe, DTe, PTe, kTe, LTe, RTe, ETe, NTe, OTe, FTe, BTe, zTe, VTe, $Te, GTe, WTe, UTe, HTe, YTe, XTe, qTe, KTe, ZTe, jTe, QTe, JTe, eAe, tAe, rAe, nAe, iAe, aAe, oAe, sAe, lAe, uAe, cAe, hAe, fAe, dAe, pAe, vAe, gAe, mAe, yAe, xAe, _Ae, bAe, SAe, wAe, CAe, TAe, AAe, IAe, MAe, DAe, PAe, kAe, LAe, RAe, EAe, NAe, OAe, FAe;
  TTe = {
    class: "flex flex-col justify-start space-y-4 p-4 max-w-4xl mx-auto w-full"
  };
  ATe = {
    class: "text-lg font-bold"
  };
  ITe = {
    class: "text-sm text-gray-600 text-center"
  };
  MTe = {
    class: "text-primary font-medium hover:underline"
  };
  DTe = {
    key: 0,
    class: "w-full max-w-2xl mx-auto"
  };
  PTe = {
    class: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"
  };
  kTe = [
    "onClick"
  ];
  LTe = [
    "src",
    "alt"
  ];
  RTe = {
    class: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-center justify-center"
  };
  ETe = {
    class: "text-white text-sm truncate max-w-[90%] px-2"
  };
  NTe = {
    class: "flex flex-col gap-4 items-center justify-center"
  };
  OTe = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  FTe = {
    class: "text-sm text-gray-600"
  };
  BTe = [
    "disabled"
  ];
  zTe = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  VTe = {
    class: "text-sm text-gray-600"
  };
  $Te = [
    "disabled"
  ];
  GTe = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  WTe = {
    class: "text-sm text-gray-600"
  };
  UTe = [
    "disabled"
  ];
  HTe = {
    class: "flex gap-6"
  };
  YTe = {
    class: "bg-white rounded-xl shadow-sm"
  };
  XTe = {
    class: "mt-6 p-6 bg-gray-50/50 rounded-xl border border-gray-100"
  };
  qTe = {
    class: "border rounded-xl overflow-hidden overflow-x-auto"
  };
  KTe = {
    class: "flex flex-col gap-8 pt-4"
  };
  ZTe = {
    class: "relative w-full overflow-hidden rounded-xl shadow-lg bg-gray-50/50"
  };
  jTe = [
    "src"
  ];
  QTe = {
    class: "grid grid-cols-2 gap-6 p-6 border rounded-xl bg-gray-50/30"
  };
  JTe = {
    class: "space-y-2"
  };
  eAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  tAe = {
    class: "font-medium"
  };
  rAe = {
    class: "space-y-2"
  };
  nAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  iAe = {
    class: "font-medium"
  };
  aAe = {
    class: "space-y-2"
  };
  oAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  sAe = {
    class: "font-medium"
  };
  lAe = {
    class: "space-y-2"
  };
  uAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  cAe = {
    class: "font-medium"
  };
  hAe = {
    class: "space-y-2"
  };
  fAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  dAe = {
    class: "font-medium"
  };
  pAe = {
    class: "space-y-2"
  };
  vAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  gAe = {
    class: "font-medium"
  };
  mAe = {
    class: "space-y-2"
  };
  yAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  xAe = {
    class: "font-medium"
  };
  _Ae = {
    class: "space-y-2"
  };
  bAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  SAe = {
    class: "font-medium"
  };
  wAe = {
    class: "space-y-2"
  };
  CAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  TAe = {
    class: "font-medium"
  };
  AAe = {
    class: "space-y-2"
  };
  IAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  MAe = {
    class: "font-medium"
  };
  DAe = {
    class: "space-y-2"
  };
  PAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  kAe = {
    class: "font-medium"
  };
  LAe = {
    class: "space-y-2"
  };
  RAe = {
    class: "text-sm font-semibold text-gray-500"
  };
  EAe = {
    class: "font-medium"
  };
  NAe = 10;
  OAe = Ye({
    __name: "ModelPerformanceTest",
    setup(r) {
      const { t: e } = Xwe(), { toast: t } = wTe(), n = We([]), i = We(""), a = We([]), o = We(false), s = We("chart"), l = We(false), u = We(null), c = We(), h = We(), f = We(), d = We(1), p = We("webgl"), v = We(NAe), g = L1e(), m = We([]), y = We(false), x = (k) => {
        const N = k.target.value.split(`
`).filter((I) => I.trim()).map((I) => {
          if (I.includes(".json")) {
            const L = I.split("/");
            return L.slice(0, L.length - 1).join("/");
          }
          return I;
        });
        n.value = N.map((I) => {
          const L = I.split("/");
          return {
            name: L[L.length - 1].split(".")[0],
            url: I
          };
        });
      }, _ = (k) => {
        const R = k.target.files;
        R && Array.from(R).forEach((N) => {
          const I = new FileReader();
          I.addEventListener("load", async () => {
            const L = new Image();
            L.src = I.result, await new Promise((O) => {
              L.onload = O;
            });
            const P = await createImageBitmap(L);
            a.value.push({
              file: N,
              preview: I.result,
              bitmap: P
            });
          }, false), I.readAsDataURL(N);
        });
      }, S = async () => {
        if (!n.value.length || !a.value.length) {
          t({
            variant: "destructive",
            title: e("modelTest.messages.selectModelAndImage")
          });
          return;
        }
        o.value = true, m.value = [], await g.setBackend(p.value);
        try {
          for (const k of n.value) {
            const { name: R, url: N } = k;
            await g.loadModel(N);
            for (const I of a.value) {
              const L = performance.now(), P = [];
              for (let Y = 0; Y < d.value; Y++) {
                const q = await w(R, N, I.bitmap, I.file.name);
                P.push(q);
              }
              const O = Math.round(P.reduce((Y, q) => Y + q.inferenceTime, 0) / d.value), F = [];
              for (let Y = 0; Y < v.value; Y++) {
                const q = await w(R, N, I.bitmap, I.file.name);
                F.push(q);
              }
              const V = performance.now() - L, U = {
                modelName: R,
                modelUrl: N,
                imageName: I.file.name,
                warmupTime: O,
                inferenceTime: Math.round(F.reduce((Y, q) => Y + q.inferenceTime, 0) / v.value),
                fps: Math.round(F.reduce((Y, q) => Y + q.fps, 0) / v.value),
                detections: F[0].detections,
                batchSize: v.value,
                minInferenceTime: Math.min(...F.map((Y) => Y.inferenceTime)),
                maxInferenceTime: Math.max(...F.map((Y) => Y.inferenceTime)),
                totalTime: V,
                warmupResults: P,
                warmupCount: d.value,
                backend: p.value
              };
              m.value.push(U);
            }
          }
          y.value = true, T();
        } catch (k) {
          t({
            variant: "destructive",
            title: e("modelTest.messages.testError"),
            description: k.message
          });
        } finally {
          o.value = false;
        }
      }, b = () => {
        const k = m.value.map((P) => `${P.modelName},${P.imageName},${P.inferenceTime},${P.minInferenceTime},${P.maxInferenceTime},${P.fps},${v.value}`).join(`
`), R = [
          e("modelTest.tableColumns.model"),
          e("modelTest.tableColumns.image"),
          e("modelTest.tableColumns.inferenceTime"),
          e("modelTest.tableColumns.minInferenceTime"),
          e("modelTest.tableColumns.maxInferenceTime"),
          e("modelTest.tableColumns.fps"),
          e("modelTest.dialog.testCount")
        ].join(","), N = new Blob([
          `${R}
${k}`
        ], {
          type: "text/csv"
        }), I = URL.createObjectURL(N), L = document.createElement("a");
        L.href = I, L.download = `model_performance_${(/* @__PURE__ */ new Date()).toISOString()}.csv`, L.click();
      }, w = async (k, R, N, I) => {
        var _a2;
        const L = performance.now(), O = await ((_a2 = Cs.getInstance().model) == null ? void 0 : _a2.detect(N, {})), B = performance.now() - L;
        return {
          modelName: k,
          modelUrl: R,
          imageName: I,
          inferenceTime: B,
          fps: Math.round(1e3 / B),
          detections: ((O == null ? void 0 : O.boxes.length) ?? 0) / 4
        };
      }, C = (k) => {
        u.value = k, l.value = true;
      }, T = () => {
        if (!c.value) return;
        const k = O9(c.value), R = {
          tooltip: {
            trigger: "axis",
            backgroundColor: "rgba(255, 255, 255, 0.9)",
            borderColor: "#e5e7eb",
            textStyle: {
              color: "black"
            }
          },
          legend: {
            data: [
              e("modelTest.tableColumns.inferenceTime"),
              e("modelTest.tableColumns.fps")
            ],
            textStyle: {
              color: "black"
            }
          },
          xAxis: {
            type: "category",
            data: m.value.map((N) => N.modelName),
            axisLine: {
              lineStyle: {
                color: "#e5e7eb"
              }
            },
            axisLabel: {
              color: "#000"
            },
            nameTextStyle: {
              color: "#000"
            }
          },
          yAxis: [
            {
              type: "value",
              name: e("modelTest.tableColumns.inferenceTime"),
              axisLine: {
                lineStyle: {
                  color: "#e5e7eb"
                }
              },
              axisLabel: {
                color: "#000"
              },
              splitLine: {
                lineStyle: {
                  color: "#f3f4f6"
                }
              },
              nameTextStyle: {
                color: "#000"
              }
            },
            {
              type: "value",
              name: e("modelTest.tableColumns.fps"),
              axisLine: {
                lineStyle: {
                  color: "#e5e7eb"
                }
              },
              axisLabel: {
                color: "#000"
              },
              splitLine: {
                lineStyle: {
                  color: "#f3f4f6"
                }
              },
              nameTextStyle: {
                color: "#000"
              }
            }
          ],
          series: [
            {
              name: e("modelTest.tableColumns.inferenceTime"),
              type: "bar",
              data: m.value.map((N) => N.inferenceTime),
              itemStyle: {
                color: "#3b82f6"
              },
              emphasis: {
                itemStyle: {
                  color: "#2563eb"
                }
              }
            },
            {
              name: e("modelTest.tableColumns.fps"),
              type: "line",
              yAxisIndex: 1,
              data: m.value.map((N) => N.fps),
              lineStyle: {
                color: "#10b981"
              },
              itemStyle: {
                color: "#10b981"
              },
              emphasis: {
                itemStyle: {
                  color: "#059669"
                }
              }
            }
          ]
        };
        return k.setOption(R), window.addEventListener("resize", () => {
          k.resize();
        }), k;
      };
      Pr([
        m
      ], T), Pr(s, (k) => {
        k === "chart" && setTimeout(() => {
          T();
        }, 500);
      }), Iu(() => T());
      const A = (k) => {
        var _a2;
        const R = new Image();
        R.src = k, (_a2 = window.open("")) == null ? void 0 : _a2.document.write(R.outerHTML);
      }, M = We(false), E = (k) => {
        var _a2;
        M.value = false;
        const R = (_a2 = k.dataTransfer) == null ? void 0 : _a2.files;
        R && Array.from(R).filter((N) => N.type.startsWith("image/")).forEach((N) => {
          const I = new FileReader();
          I.addEventListener("load", async () => {
            const L = new Image();
            L.src = I.result, await new Promise((O) => {
              L.onload = O;
            });
            const P = await createImageBitmap(L);
            a.value.push({
              file: N,
              preview: I.result,
              bitmap: P
            });
          }, false), I.readAsDataURL(N);
        });
      };
      return (k, R) => (qe(), Mr("div", TTe, [
        Ge(W(nTe), {
          class: "shadow-lg hover:shadow-2xl transition-all duration-300 rounded-xl overflow-hidden bg-white/50 backdrop-blur-sm border border-gray-100"
        }, {
          default: ve(() => [
            Ge(W(iTe), null, {
              default: ve(() => [
                pe("h1", ATe, $e(W(e)("modelTest.title")), 1)
              ]),
              _: 1
            }),
            Ge(W(ex), null, {
              default: ve(() => [
                Ge(W(fTe), {
                  modelValue: i.value,
                  "onUpdate:modelValue": R[0] || (R[0] = (N) => i.value = N),
                  rows: "3",
                  class: "w-full max-w-2xl mx-auto transition-all duration-300 hover:shadow-md focus:ring-2 focus:ring-primary/20 rounded-lg",
                  placeholder: W(e)("modelTest.enterModelUrls"),
                  onInput: x
                }, null, 8, [
                  "modelValue",
                  "placeholder"
                ])
              ]),
              _: 1
            }),
            Ge(W(ex), {
              class: "space-y-6"
            }, {
              default: ve(() => [
                pe("div", {
                  class: _n([
                    "border-2 border-dashed border-gray-200 rounded-xl p-6 hover:border-primary/60 transition-all duration-300 hover:shadow-md bg-gray-50/50 group max-w-2xl mx-auto",
                    {
                      "border-primary/60 shadow-md": M.value
                    }
                  ]),
                  onDragover: R[4] || (R[4] = Mc(() => {
                  }, [
                    "prevent"
                  ])),
                  onDrop: Mc(E, [
                    "prevent"
                  ])
                }, [
                  pe("input", {
                    type: "file",
                    accept: "image/*",
                    multiple: "",
                    class: "hidden",
                    ref_key: "fileInput",
                    ref: f,
                    onChange: _
                  }, null, 544),
                  pe("div", {
                    class: "flex flex-col items-center justify-center h-full cursor-pointer space-y-4",
                    onClick: R[1] || (R[1] = () => f.value.click()),
                    onDragenter: R[2] || (R[2] = Mc((N) => M.value = true, [
                      "prevent"
                    ])),
                    onDragleave: R[3] || (R[3] = Mc((N) => M.value = false, [
                      "prevent"
                    ]))
                  }, [
                    Ge(W(Yse), {
                      class: "w-8 h-8 text-primary/70 group-hover:scale-110 transition-transform duration-300"
                    }),
                    pe("div", ITe, [
                      hr($e(W(e)("modelTest.uploadText")) + " ", 1),
                      pe("span", MTe, $e(W(e)("modelTest.uploadClickText")), 1)
                    ])
                  ], 32)
                ], 34),
                a.value.length > 0 ? (qe(), Mr("div", DTe, [
                  pe("div", PTe, [
                    (qe(true), Mr(mh, null, Jw(a.value, (N, I) => (qe(), Mr("div", {
                      key: I,
                      class: "relative group cursor-pointer rounded-lg overflow-hidden shadow-sm hover:shadow-lg transition-all duration-300",
                      onClick: (L) => A(N.preview)
                    }, [
                      pe("img", {
                        src: N.preview,
                        class: "w-full h-32 object-cover",
                        alt: N.file.name
                      }, null, 8, LTe),
                      pe("div", RTe, [
                        pe("span", ETe, $e(N.file.name), 1)
                      ])
                    ], 8, kTe))), 128))
                  ])
                ])) : yh("", true)
              ]),
              _: 1
            }),
            Ge(W(ex), null, {
              default: ve(() => [
                pe("div", NTe, [
                  pe("div", OTe, [
                    pe("label", FTe, $e(W(e)("modelTest.warmupCount")) + ":", 1),
                    sp(pe("input", {
                      type: "number",
                      "onUpdate:modelValue": R[5] || (R[5] = (N) => d.value = N),
                      min: "1",
                      max: "100",
                      disabled: o.value,
                      class: "w-24 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, null, 8, BTe), [
                      [
                        nx,
                        d.value
                      ]
                    ])
                  ]),
                  pe("div", zTe, [
                    pe("label", VTe, $e(W(e)("modelTest.inferenceCount")) + ":", 1),
                    sp(pe("input", {
                      type: "number",
                      "onUpdate:modelValue": R[6] || (R[6] = (N) => v.value = N),
                      min: "1",
                      max: "100",
                      disabled: o.value,
                      class: "w-24 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, null, 8, $Te), [
                      [
                        nx,
                        v.value
                      ]
                    ])
                  ]),
                  pe("div", GTe, [
                    pe("label", WTe, $e(W(e)("modelTest.backend")) + ":", 1),
                    sp(pe("select", {
                      "onUpdate:modelValue": R[7] || (R[7] = (N) => p.value = N),
                      disabled: o.value,
                      class: "w-32 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, R[10] || (R[10] = [
                      pe("option", {
                        value: "webgl"
                      }, "WebGL", -1),
                      pe("option", {
                        value: "webgpu"
                      }, "WebGPU", -1),
                      pe("option", {
                        value: "wasm"
                      }, "WASM", -1)
                    ]), 8, UTe), [
                      [
                        U4,
                        p.value
                      ]
                    ])
                  ]),
                  pe("div", HTe, [
                    Ge(W(J0), {
                      disabled: o.value || !n.value.length || !a.value.length,
                      class: "min-w-[140px] transition-all duration-300 hover:scale-105 shadow-md hover:shadow-lg disabled:opacity-50",
                      onClick: S
                    }, {
                      default: ve(() => [
                        o.value ? (qe(), _t(W(Hse), {
                          key: 0,
                          class: "mr-2 h-4 w-4 animate-spin"
                        })) : yh("", true),
                        hr(" " + $e(W(e)("modelTest.startTest")), 1)
                      ]),
                      _: 1
                    }, 8, [
                      "disabled"
                    ]),
                    Ge(W(J0), {
                      variant: "outline",
                      disabled: !y.value,
                      class: "min-w-[140px] transition-all duration-300 hover:scale-105 shadow-sm hover:shadow-md disabled:opacity-50",
                      onClick: b
                    }, {
                      default: ve(() => [
                        hr($e(W(e)("modelTest.exportResults")), 1)
                      ]),
                      _: 1
                    }, 8, [
                      "disabled"
                    ])
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        pe("div", YTe, [
          Ge(W(dTe), {
            modelValue: s.value,
            "onUpdate:modelValue": R[8] || (R[8] = (N) => s.value = N),
            class: "w-full"
          }, {
            default: ve(() => [
              Ge(W(pTe), {
                class: "grid w-full grid-cols-2 p-1 bg-gray-100/50 rounded-lg"
              }, {
                default: ve(() => [
                  Ge(W(IL), {
                    value: "chart",
                    class: "data-[state=active]:bg-white data-[state=active]:shadow-sm rounded-md transition-all duration-300"
                  }, {
                    default: ve(() => [
                      hr($e(W(e)("modelTest.performanceChart")), 1)
                    ]),
                    _: 1
                  }),
                  Ge(W(IL), {
                    value: "table",
                    class: "data-[state=active]:bg-white data-[state=active]:shadow-sm rounded-md transition-all duration-300"
                  }, {
                    default: ve(() => [
                      hr($e(W(e)("modelTest.detailData")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              Ge(W(AL), {
                value: "chart"
              }, {
                default: ve(() => [
                  pe("div", XTe, [
                    pe("div", {
                      ref_key: "performanceChart",
                      ref: c,
                      class: "h-[500px] w-full"
                    }, null, 512)
                  ])
                ]),
                _: 1
              }),
              Ge(W(AL), {
                value: "table"
              }, {
                default: ve(() => [
                  pe("div", qTe, [
                    Ge(W(mTe), {
                      class: "min-w-full table-auto"
                    }, {
                      default: ve(() => [
                        Ge(W(xTe), null, {
                          default: ve(() => [
                            Ge(W(ML), {
                              class: "bg-gray-50/70 hover:bg-gray-50/90"
                            }, {
                              default: ve(() => [
                                Ge(W(Fl), {
                                  class: "font-semibold"
                                }, {
                                  default: ve(() => [
                                    hr($e(W(e)("modelTest.tableColumns.model")), 1)
                                  ]),
                                  _: 1
                                }),
                                Ge(W(Fl), {
                                  class: "font-semibold"
                                }, {
                                  default: ve(() => [
                                    hr($e(W(e)("modelTest.tableColumns.image")), 1)
                                  ]),
                                  _: 1
                                }),
                                Ge(W(Fl), {
                                  class: "font-semibold"
                                }, {
                                  default: ve(() => [
                                    hr($e(W(e)("modelTest.tableColumns.warmupTime")), 1)
                                  ]),
                                  _: 1
                                }),
                                Ge(W(Fl), {
                                  class: "font-semibold"
                                }, {
                                  default: ve(() => [
                                    hr($e(W(e)("modelTest.tableColumns.inferenceTime")), 1)
                                  ]),
                                  _: 1
                                }),
                                Ge(W(Fl), {
                                  class: "font-semibold"
                                }, {
                                  default: ve(() => [
                                    hr($e(W(e)("modelTest.tableColumns.fps")), 1)
                                  ]),
                                  _: 1
                                }),
                                Ge(W(Fl), {
                                  class: "font-semibold"
                                }, {
                                  default: ve(() => [
                                    hr($e(W(e)("modelTest.tableColumns.actions")), 1)
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        Ge(W(yTe), null, {
                          default: ve(() => [
                            (qe(true), Mr(mh, null, Jw(m.value, (N) => (qe(), _t(W(ML), {
                              key: N.modelName + N.imageName,
                              class: "hover:bg-gray-50/50 transition-colors duration-200"
                            }, {
                              default: ve(() => [
                                Ge(W(Ol), {
                                  class: "font-medium"
                                }, {
                                  default: ve(() => [
                                    hr($e(N.modelName), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                Ge(W(Ol), null, {
                                  default: ve(() => [
                                    hr($e(N.imageName), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                Ge(W(Ol), null, {
                                  default: ve(() => [
                                    hr($e(N.warmupTime), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                Ge(W(Ol), null, {
                                  default: ve(() => [
                                    hr($e(N.inferenceTime), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                Ge(W(Ol), null, {
                                  default: ve(() => [
                                    hr($e(N.fps), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                Ge(W(Ol), null, {
                                  default: ve(() => [
                                    Ge(W(J0), {
                                      variant: "ghost",
                                      class: "transition-all duration-300 hover:scale-110 hover:text-primary",
                                      onClick: (I) => C(N)
                                    }, {
                                      default: ve(() => [
                                        hr($e(W(e)("modelTest.tableColumns.viewDetail")), 1)
                                      ]),
                                      _: 2
                                    }, 1032, [
                                      "onClick"
                                    ])
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1024))), 128))
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, [
            "modelValue"
          ])
        ]),
        Ge(W(aTe), {
          open: l.value,
          "onUpdate:open": R[9] || (R[9] = (N) => l.value = N)
        }, {
          default: ve(() => [
            Ge(W(oTe), {
              class: "sm:max-w-[800px] rounded-xl overflow-hidden bg-white/95 shadow-xl border border-gray-100/20"
            }, {
              default: ve(() => {
                var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r2;
                return [
                  Ge(W(sTe), {
                    class: "border-b pb-4"
                  }, {
                    default: ve(() => [
                      Ge(W(lTe), {
                        class: "text-xl font-bold"
                      }, {
                        default: ve(() => [
                          hr($e(W(e)("modelTest.dialog.title")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  pe("div", KTe, [
                    pe("div", ZTe, [
                      pe("img", {
                        src: (_a2 = u.value) == null ? void 0 : _a2.image,
                        class: "max-w-full h-auto"
                      }, null, 8, jTe),
                      pe("canvas", {
                        ref_key: "detailCanvas",
                        ref: h,
                        class: "max-w-full h-auto absolute top-0 left-0"
                      }, null, 512)
                    ]),
                    pe("div", QTe, [
                      pe("div", JTe, [
                        pe("div", eAe, $e(W(e)("modelTest.dialog.modelName")), 1),
                        pe("div", tAe, $e((_b2 = u.value) == null ? void 0 : _b2.modelName), 1)
                      ]),
                      pe("div", rAe, [
                        pe("div", nAe, $e(W(e)("modelTest.dialog.backend")), 1),
                        pe("div", iAe, $e((_c2 = u.value) == null ? void 0 : _c2.backend), 1)
                      ]),
                      pe("div", aAe, [
                        pe("div", oAe, $e(W(e)("modelTest.dialog.detectionCount")), 1),
                        pe("div", sAe, $e((_d2 = u.value) == null ? void 0 : _d2.detections), 1)
                      ]),
                      pe("div", lAe, [
                        pe("div", uAe, $e(W(e)("modelTest.warmupCount")), 1),
                        pe("div", cAe, $e((_e2 = u.value) == null ? void 0 : _e2.warmupCount), 1)
                      ]),
                      pe("div", hAe, [
                        pe("div", fAe, $e(W(e)("modelTest.dialog.testCount")), 1),
                        pe("div", dAe, $e((_f2 = u.value) == null ? void 0 : _f2.batchSize), 1)
                      ]),
                      pe("div", pAe, [
                        pe("div", vAe, $e(W(e)("modelTest.dialog.totalCount")), 1),
                        pe("div", gAe, $e((((_g2 = u.value) == null ? void 0 : _g2.batchSize) ?? 0) + (((_h2 = u.value) == null ? void 0 : _h2.warmupCount) ?? 0)), 1)
                      ]),
                      pe("div", mAe, [
                        pe("div", yAe, $e(W(e)("modelTest.dialog.warmupTime")), 1),
                        pe("div", xAe, $e((_j2 = (_i2 = u.value) == null ? void 0 : _i2.warmupTime) == null ? void 0 : _j2.toFixed(0)) + "ms", 1)
                      ]),
                      pe("div", _Ae, [
                        pe("div", bAe, $e(W(e)("modelTest.dialog.avgInferenceTime")), 1),
                        pe("div", SAe, $e((_l2 = (_k2 = u.value) == null ? void 0 : _k2.inferenceTime) == null ? void 0 : _l2.toFixed(0)) + "ms", 1)
                      ]),
                      pe("div", wAe, [
                        pe("div", CAe, $e(W(e)("modelTest.dialog.avgFps")), 1),
                        pe("div", TAe, $e((_m2 = u.value) == null ? void 0 : _m2.fps), 1)
                      ]),
                      pe("div", AAe, [
                        pe("div", IAe, $e(W(e)("modelTest.dialog.minInferenceTime")), 1),
                        pe("div", MAe, $e((_o2 = (_n2 = u.value) == null ? void 0 : _n2.minInferenceTime) == null ? void 0 : _o2.toFixed(0)) + "ms", 1)
                      ]),
                      pe("div", DAe, [
                        pe("div", PAe, $e(W(e)("modelTest.dialog.maxInferenceTime")), 1),
                        pe("div", kAe, $e((_q2 = (_p2 = u.value) == null ? void 0 : _p2.maxInferenceTime) == null ? void 0 : _q2.toFixed(0)) + "ms", 1)
                      ]),
                      pe("div", LAe, [
                        pe("div", RAe, $e(W(e)("modelTest.dialog.totalTime")), 1),
                        pe("div", EAe, $e(((((_r2 = u.value) == null ? void 0 : _r2.totalTime) ?? 0) / 1e3).toFixed(1)) + "s", 1)
                      ])
                    ])
                  ])
                ];
              }),
              _: 1
            })
          ]),
          _: 1
        }, 8, [
          "open"
        ])
      ]));
    }
  });
  FAe = H4(OAe, [
    [
      "__scopeId",
      "data-v-fff56941"
    ]
  ]);
  WAe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: FAe
  }, Symbol.toStringTag, {
    value: "Module"
  }));
});
export {
  Sw as $,
  MV as A,
  rn as B,
  al as C,
  oi as D,
  Ct as E,
  ui as F,
  Fg as G,
  Fxe as H,
  HP as I,
  bu as J,
  u_e as K,
  y_e as L,
  pt as M,
  Qt as N,
  gr as O,
  Dr as P,
  S_e as Q,
  cb as R,
  G_e as S,
  Yd as T,
  sb as U,
  XP as V,
  D0 as W,
  KP as X,
  Vxe as Y,
  kr as Z,
  Jz as _,
  __tla,
  Yi as a,
  DV as a0,
  Pt as a1,
  $t as a2,
  I_e as a3,
  q_e as a4,
  dbe as a5,
  vbe as a6,
  _be as a7,
  Sbe as a8,
  wbe as a9,
  vw as aa,
  Hs as ab,
  T1e as ac,
  A1e as ad,
  Ov as ae,
  yb as af,
  Ul as ag,
  _1e as ah,
  WV as ai,
  hk as aj,
  uk as ak,
  axe as al,
  Bv as am,
  sxe as an,
  YV as ao,
  WAe as ap,
  tf as b,
  Lp as c,
  fw as d,
  Wn as e,
  ck as f,
  z_e as g,
  TV as h,
  uV as i,
  fi as j,
  CV as k,
  fbe as l,
  pbe as m,
  RP as n,
  ybe as o,
  bbe as p,
  RV as q,
  _xe as r,
  dw as s,
  At as t,
  _V as u,
  oxe as v,
  mn as w,
  Tbe as x,
  fa as y,
  Zz as z
};
